tracking load time configuration options max lillack university of leipzig germanychristian k stner carnegie mellon university usaeric bodden fraunhofer sit tu darmstadt germany abstract highly con gurable software systems are pervasive although con guration options and their interactions raise complexity of the program and increase maintenance e ort.
especially load time con guration options such as parameters from command line options or con guration les are used with standard programming constructs such as variables and if statements intermixed with the program s implementation manually tracking con guration options from the time they are loaded to the point where they may in uence controlow decisions is tedious and error prone.
we design and implement lotrack an extended static taint analysis to automatically track con guration options.
lotrack derives a con guration map that explains for each code fragment under which con gurations it may be executed.
an evaluation on android applications shows that lotrack yields high accuracy with reasonable performance.
we use lotrack to empirically characterize how much of the implementation of android apps depends on the platform s con guration options or interactions of these options.
categories and subject descriptors k. .
software maintenance keywords variability mining con guration options static analysis .
introduction software has become increasingly con gurable to support di erent requirements for a wide range of customers and market segments.
con guration options can be used to support alternative hardware cater for backward compatibility enable extra functionality add debugging facilities and much more.
while con guration mechanisms allow end users to use the software in more contexts they also raise the software s complexity for developers adding more functionality that needs to be tested and maintained.
even worse permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
guration options may interact in unanticipated ways and subtle behavior may hide in speci c combinations of options that are di cult to discover and understand in the exponentially growing con guration space.
con guration options raise challenges since they vary and thus complicate the software s control and data ow.
as a result developers need to trace con guration options through the software to identify which code fragments are a ected by an option and where and how options may interact.
overall making changes becomes harder because developers need to understand a larger context and may need to retest many con gurations.
there are many strategies to implement con guration options but particularly common and problematic is to use load time parameters command line options con guration les registry entries and so forth parameters are loaded and used as ordinary values within the program at runtime and con guration decisions are made through ordinary control statements such as ifstatements within a common implementation.
the implementation of con guration options with plugins or conditional compilation provide some static traceability of an option s implementation which is missing in load time con guration options.
identifying the code fragments implementing an option requires tedious manual e ort and as our evaluation con rms is challenging to get right even in medium size software systems.
in this work we propose lotrack 1a tool to statically track con guration options from the moment they are loaded in the program to the code that is directly or indirectly affected.
speci cally lotrack aims at identifying all code that is included if and only if a speci c con guration option or combination of con guration options is selected .
the recovered traceability can support developers in many maintenance tasks but in the long run can also be used as input for further automated tasks such as removing a con guration option and its use from the program translating load time into compile time options or guaranteeing the absence of interactions among con guration options.
in contrast to slicing which determines whether a statement s execution depends on a given value lotrack determines under which con gurations i.e.
a set of selected con guration options a given statement is executed.
to track con guration options precisely we exploit the nature of how con guration options are typically implemented.
although a na ve forward slicing algorithm can identify all code potentially a ected by a con guration option directly or indirectly in practice it will frequently return slices that are largely overapproximated due to hard to handle programming features such as aliasing loops and recursion.
to increase precision we exploit the insight that con guration options are typically used di erently from other values in the code values for con guration options are often passed along unmodi ed and are used in simple conditions making their tracking comparatively easy and precise.
finally only few con guration options are usually used in any given part of a program.
technically lotrack extends a context ow object and eld sensitive taint analysis to build a con guration map describing how code fragments depend on con guration options.
this paper evaluates lotrack in the context of android applications.
android apps are interesting subjects for studying con guration options since the android platform has a reputation for being diverse and fragmented with many different platform versions and hardware features .
android apps query a xed set of con guration options given by the framework to dynamically switch between implementations or disable functionality if the corresponding feature e.g.
bluetooth support is not available on a device.
in a large set of android apps we track how con guration options are used and how much code is devoted to implement optional functionality.
we nd that most apps use standard con guration options given by the framework to optionally include code.
we estimate an average of of the apps source is executed depending on con guration options.
in summary this paper presents the following original contributions an encoding of the problem of tracking con guration options as a taint analysis problem a description of how to make use of common characteristics of con guration values in programs to increase the precision of the analysis an implementation based on flowdroid able to handle java android source code and bytecode and an empirical evaluation demonstrating the precision and recall of our implementation as well as an overview of con guration option usage based on a sample of open source android apps.
.
problem statement our goal is to trace con guration options to the code fragments implementing them.
that is we want to nd all code that is executed if and only if a speci c con guration constraint is satis ed.
for example in an android app we might want to nd all source code bound to the availability of bluetooth or to functionality only active on devices running android .
or higher.
technically we seek to establish a con guration map which maps every code fragment to a con guration constraint describing in which con gurations the code fragment may be executed in the program that is which con guration options or combinations of options need to be selected or deselected.
we describe the con guration constraint as a propositional formula over atomic con guration decisions.
a con guration constraint is a selection for a speci c conguration option such as bluetooth on abbreviated to bluetooth for boolean options or sdkversion .
if we only know that a con guration option ois involved but we are unable to gure out more precisely how we write o?
as con guration constraint.
a con guration constraint may describe many con gurations for example bluetooth class proxyservice static boolean n7tive proxy supporte 8uildgversiongs k int khw public void onsharedpreference9hanged2 string kethostw if 2bn7tive proxy supporte kethost getstring2rgstringgpref proxyhost w ggg string command path h u chost uw string result roottoolsgsendshell2command h kethost w ggg class 9onfiguration7ctivity public void onhelp2view view intent intentw if 2proxyservicegn7tive proxy supporte intent new intent2thisf proxy9onfggg w else intent new intent2intentg79tion viewf uri w start7ctivity2intent w k h !
m w k kk kh k!
k km k k kkw h hk hh h!
h s k0kh s k43kh s k0khfigure example from adblock plus app and expected con guration map sdkversion describes the set of con gurations in which bluetooth is enabled and a speci c sdk version is selected.
in figure we illustrate a con guration map for a simple excerpt from the adblock plus2app in which the con guration constraint for each statement is written to the left of the line.
it is only an excerpt the whole app uses the shown eld six times and in four di erent classes.
this shows the scattered nature of the con guration option s implementation.
a con guration map can support developers in performing maintenance tasks or in reasoning about the implementation.
developers can look up all code fragments implementing a speci c con guration option and can investigate how two con guration options relate.
for instance in prior work we and others have shown how background colors and views projections highlighting options can signi cantly improve developer productivity especially if the implementation of con guration options is scattered throughout multiple locations .
a con guration map simpli es otherwise potentially daunting tasks such as removing an obsolete option from the code refactoring the scattered implementation of an option into a module changing the binding time of a con guration option between compiletime and load time or determining test adequacy criteria with con guration coverage .
with a precise con guration map one could even determine that two con guration options can never interact and thus could establish that one does not need to test their interactions.
for the example shown in figure having the con guration map highlights the scattered implementation fragments implementing the option s functionality and supports quick navigation.
there are many di erent strategies to implement con guration options some of which allow us to extract a conguration map easily.
for example when providing optional functionality as plug ins to frameworks such as eclipse and wordpress one can locate the corresponding implementa2 446tion in those plug ins.
similarly using conditional compilation for example using the c preprocessor s ifdef directives despite all criticism enables a simple static localization of all scattered code fragments implementing an option with a simple search over those directives .
3unfortunately for load time con guration options there is no such simple static extraction because con guration happens after compile time and because a simple syntactic analysis is insu cient to distinguish con guration values from other runtime values.
in this work we thus design a static analysis that approximates a con guration map for load time con guration options by tracking each con guration option from the point at which it is loaded to the controlow decisions that include or exclude a code fragment depending on the option s value.
in figure we show an example of the result of our approach the android app loads a con guration option regarding the sdk version assigns it to a eld and uses it in other locations in the implementation to decide whether to execute additional code.
the resulting con guration map identi es that the additional code can only be executed in speci c con gurations shown in gray boxes .
note that in contrast to slicing our con guration map does not include statements that compute with con guration values or values in uenced by them e.g.
line in our example but only code blocks included or excluded by con gurationrelated controlow decisions.
to scope our approach we make the following assumptions con guration options are set at program load time and do not change during the execution of the program hence reading the same con guration value multiple times will always yield the same result.
yet the read con guration value may be assigned to variables and those variables values may change during runtime.
the api calls to load con guration values are known and can be identi ed syntactically e.g.
the read from eld sdk int in figure the possible values of conguration options are nite and known.
how these options are identi ed is outside the scope of this paper.
possible strategies include manual identi cation by reading source code and documentation or using existing heuristics and static analysis tools .
after being read from the api con guration values may be assigned to variables or elds and may be propagated or processed in arbitrary ways in the program.
con guration options may trigger data dependencies in other variables and only indirectly in uence controlow decisions.
by tracking con guration options in a program we are essentially tracking all control and data dependencies of a value through arbitrary computations.
since such static computation is undecidable rice s theorem our approach relies on standard static analysis techniques conservatively abstracting over concrete values similar to e.g.
program 3compile time con guration mechanisms can still trigger runtime decisions for example by using a macro with alternative compile time values to initialize a variable that is subsequently used in runtime controlow decisions.
current techniques do not discover these dependencies crossing binding times more advanced static analyses would be required similar to what we propose for load time con gurations in this paper.slicing .
in general one might think that too coarse abstractions could easily yield useless overapproximations where essentially every code fragment is potentially in uenced by every con guration option.
as we observed in practice however in many programs con guration options are used in limited ways.
in particular one can tailor static program analyses because con guration options often exhibit the following common characteristics con guration options often have a small domain in many cases they have just two possible values which makes it feasible to track concrete values and e ciently reason about expressions over con guration values.
con guration options are commonly reassigned and propagated throughout the program but they are rarely changed once they are loaded.
con guration options often occur in controlow decisions e.g.
ifstatements but they rarely are involved in more complex computations.
for example one might compute the sine of a regular input but rarely of a con guration option.
the context ow object and eld sensitive taint analysis underlying lotrack already allows a precise tracking of the use of con guration options.
.
approach the general idea of lotrack is to use a taint analysis to track con guration options through the code and identify when controlow decisions depend on tainted values.
a taint analysis is a dataow analysis typically used in security research e.g.
to detect information leaks.
to this end a private value is marked as tainted and all values derived from this value directly or indirectly are tainted as well allowing one to recognize when tainted private values are used in contexts where they should not e.g.
sent over a network .
lotrack uses a taint analysis in a slightly di erent way it taints all values resulting from reading a con guration option or from a computation of a tainted value when a tainted value occurs in a controlow decision one knows that all dependent code may depend on this con guration option.
to reduce over approximation and produce an accurate con guration map lotrack additionally tracks speci c values as conditional taints for selected con guration options as we will explain in section .
.
.
taint analysis for configuration options conceptually lotrack performs a taint analysis for each con guration option.
the analysis taints all values read from con guration options as identi ed by a list of the fully quali ed names of methods and elds used to access the conguration api.
the taint analysis then propagates the taints inter procedurally along controlow edges to all values that directly or indirectly depend on this value considering both controlow and dataow dependencies for example if the right hand side of assignments contains tainted values their left hand side is tainted and is considered to be derived from the con guration option.
when a tainted value is read in the condition of an ifstatement one knows that the subsequent computations depend on the con guration option.
for example reading from sdk int in figure causes the creation of a taint for the eld native proxy supported in its initialization expression and due to an indirect information ow also for intent in the two ifstatements we then see that the controlow condition depends on a tainted value.
wifibooleanwgpsonw wlocationmanager.isproviderenabled3gps4 booleanwwifionw wsettings.wifi on if3fwifion4 wwlog3gpson4 04figure example for access and use of con guration options to create a con guration map lotrack creates taints for all con guration options and maps each code fragment whose execution is dependent on a tainted variable to the con guration options associated with the taint.
intuitively every time a tainted value associated with some option occurs in the expression of an ifstatement or other controlow decision all statements in the then and else branch depend on the con guration option and thus are associated with it.
similarly classes and methods exclusively used in paths guarded by tainted conditionals are associated with this con guration option.
a common problem with taint analysis is how to handle native functions and environment interactions.
for a sound analysis unless one knows how information ows through the environment one has to assume the worst i.e.
that every value read from the environment may be tainted often leading to massively overapproximated results.
in practice we allow false negatives and only create taints for results of native method calls or environment interactions if they have been parameterized with a tainted value.
for example in our example in figure value result is tainted because it is returned by a call using the tainted parameter kethost .
this simpli cation is grounded in the assumption that conguration options are mostly used in simple ways so that false negatives should be rare.
in fact handling of native functions and environment interactions are customizable to di erent levels of strictness and the underlying flowdroid tool supports such customizations through its con guration.
.
tracking configuration values the simple taint based analysis above creates a map between code fragments and all involved con guration options.
however it does not tell howcon guration options in uence the selection of a code fragment.
in our example figure we would ideally like to know that line is only executed ifsdk int instead of only knowing that it somehow depends on sdk int i.e.
con guration constraint sdk int ?
.
to that end we extend the taint analysis to track con guration values instead of only con guration options.
to track con guration values lotrack implements several extensions to the taint analysis.
in particular lotrack tracks a taint for each possible value of a variable and tracks a constraint under which con guration this variable has this value.
second lotrack does not propagate all taints directly but analyzes restricts and merges constraints at controlow decisions.
to explain this in more detail consider a second example in figure .
here lotrack does not create a single taint for eld gpson explaining that it depends on con guration option gps but rather two di erent taints one with the value gpson under the condition that gps is selected and one with the value gpson under the condition that gps is deselected.
the same happens for variable wifion and option wifi .
in the controlow decision if !wifion oneknows that the then branch will only be executed if option wifi is deselected which is why the analysis marks the corresponding controlow edge with the constraint wifi and propagates all taints along this path only with restricted constraints in our case it propagates gpson only under the condition gps wifi .
with value tracking one can directly model constraints on options with small nite domains.
the analysis creates a taint for every possible value e.g.
true and false for booleans and version version 3for versions .
for a constraint with an unknown value of con guration option owe use the notation o?.
for example version ?indicates that the code fragment somehow depends on the version con guration option but allows no statement about the concrete version number.
the taint information denoted by the variable and the tracked value together with the constraint constitute a fact.
generally facts are simply propagated like taints in a taint analysis.
a fact is no longer propagated however if the corresponding constraint is unsatis able.
if a controlow decision depends on a tainted value we derive constraints for the controlow branches by evaluating the branching condition.
all facts are propagated along such controlow branches with the respective more restrictive constraint a conjunction of the fact s previous constraint and the controlow branch s constraint .
if several facts with the same taint information reach the same statement for instance at a controlow merge point the constraints for these facts are combined as disjunctions leading to a less restrictive constraint.
for example a fact expressing that variable a has the value trueunder condition debug merged with another fact expressing that the variable has value true under condition debug would be merged into a single fact that the variable has always the value true.
at the x point the analysis has gathered facts with constraints for each reachable statement in the program.
to create the con guration map lotrack creates a single constraint for each statement.
for this the constraints of all facts at a statement are disjoint.
.
algorithm lotrack works on top of a taint analysis which provides the functionality of taint creation and propagation as well as common features of static program analysis like call graph creation and alias analysis.
besides a basic overview of the algorithm for taint analysis we concentrate on the extension for the tracking of constraints and refer for a more detailed description of the basic taint tracking mechanisms to the works on flowdroid .
our value based taint tracking algorithm shown in algorithm requires an inter procedural controlow graph and an initial edge as input.
to handle the multiple possible entry points to mobile apps the underlying flowdroid tool creates an arti cial main method which calls every possible entry point.
the main method also simulates the initialization of static class members.
the analysis works on the level of summary edges .
an edge consists of a source and target fact the source and target statement as well as a constraint.
in line of algorithm the initial edge with constraint true given by the controlow graph is added to a set of edges to be processed.
more edges will be created from the algorithm itself as it traverses the controlow graph.
448input inter procedural controlow graph icfg initial edge output set of facts function tracktaints edges finitialedgeg result fg while edges do edge edges.remove for successor2icfg.successors edge do for fact2successor.facts edge do constr cur edge.constr constr fact createconstraint edge constr new constr cur constr fact if result contains fact then fact.constr fact.constr constr new else result.add new fact successor constr new end if constr new6 falsethen edges.add new edge successor fact end end end end return result end algorithm taint tracking algorithm for each edge the following basic steps are taken.
the successors of the edge s target statement are determined using the inter procedural controlow graph line .
using a normal taint analysis the possible taints at the successor are determined based on the current edge line .
at an api accessing statement the taint analysis creates new taints for each possible con guration value taint creation is not shown .
for each possible taint at the successor the constraint required for this taint to be propagated is determined using algorithm .
algorithm computes the constraint for the propagation of a fact along a controlow edge using the information in the edge as well as other facts for the same statement.
an api access or a branching statement can lead to the creation of new constraints all other cases will return true leaving constraints of facts which are propagated along the edge unchanged.
at an api access lines the algorithm creates an initial edge pointing to the fact representing the accessed option.
the algorithm checks whether value tracking is enabled for this con guration option.
for value tracking a constraint is created with respect to the values of the conguration option.
at this point the possible values are already encoded with possibly multiple fact one per value which are created in the taint analysis not shown in the algorithms .
in case of boolean variables the analysis simply di erentiates between true and false which are mapped to constraints for this con guration option for example wifi and wifi respectively.
to track values of other types the algorithm models the possible values as di erent conguration options e.g.
version version version .
if value tracking is not possible it creates the generic constraint wifi ?
line .input edge target statement and fact all facts at target mapping api to options output constraint for edge function createconstraint if target is api access and fact is for accessed option then option target.accessedoption if option can use value tracking then return option fact value else return option ?
end else if target is ifstatement then result null for fact2target.facts do if fact matches ifcondition then if result null then result false end result result fact.cstr end end if result6 null and is false branch then result negate result end if result null then result true end return result else return true end end algorithm computation of constraint for edge at a controlow decision4 lines a new constraint is created if the condition of the ifstatement is dependent on a tainted value.
the constraints of all matching facts are combined as a disjunction to create the most general constraint for this branching statement line .
a fact matches a condition if its variable and value satisfy the condition.
for example the condition in if a is satis ed only by the variable aand value true.
for operations on boolean variables there is at most one matching fact but for other types of variables multiple matching facts are possible.
for a condition like version and the three possible facts for option version shown above the resulting constraint will beversion 3 version .
the resulting constraint is used for the branch edge and its negation for the fall through edge line .
if no fact matched the condition the algorithm returns true line which indicates that the condition is not dependent on any con guration option and therefore should not change the constraint of any facts.
line in algorithm combines the resulting constraint for the edge from algorithm by conjoining it with the constraint propagated to this edge so far line .
for example 4all programs are analyzed in an intermediate representation where all kinds of control structures are expressed through if statements and gotos .
expressions are simpli ed to comparing a variable to another variable or constant.
449if a fact has the constraint aand the constraint from the controlow edge is b the resulting constraint for the fact will be a b. facts are not propagated further if the resulting constraint is unsatis able.
along di erent paths di erent facts with the same taint information i.e.
the same variable and value can reach the same statement.
in this case the facts are joined to a single fact disjoining the individual constraints line .
the fact with the nal constraint together with the successor statement results in a new edge which is added to the list of edges to be processed.
the algorithm nishes once there are no more edges to process.
in contrast to a regular taint analysis for value tracking the order in which the enlisted edges are processed is important.
the creation of a new constraint at an ifstatement requires the information about facts reaching this statement.
lotrack handles this restriction by ensuring that all open edges are processed before continuing with the edges for the ifstatement.
a normal statement with a single successor is handled in the order given the control ow.
for calls exit statements and statements with multiple successors if statements we de ne merge point statements to describe statement that merge the branches of the controlow graph.
edges out of these statements will not be processed until all other edges are processed.
for calls and exit statements we de ne the return sites as merge points.
return sites comprise the statement after the call and possible catch statements from exception handling.
for statements with multiple successors we select the post dominator of the statement as merge point.
this rule ensures the then branch as well as a possible elsebranch is covered before continuing.
.
example to illustrate the approach we walk through a nontrivial example shown in figure .
on the left side we show java source code of two simple methods.
on the right side we show a controlow graph annotated with information regarding the dataow information being tracked through the program.
our analysis uses jimple which is an intermediate threeaddress code representation created from java source code or bytecode.
jimple introduces intermediate variables partitions complex expressions and performs other simpli cations.
in our example lines show a jimple like expansion of the java expression in line .
we use this jimple like variant in the control ow on the right side to explain the analysis of the statement step by step.
the intermediate representation simpli es the implementation and explanation of the approach but does not a ect the ability to handle the full set of java.
our analysis proceeds as follows.
first we need the information which api can be used to retrieve the value of con guration options and whether value tracking is used.
table shows the necessary input for our example.
next we start the actual taint analysis with the entry point in this case the edge calling method start from where we analyze its rst statement the call to method isconfig .
before continuing within start we need to handle the called method to identify all possibly relevant results.
the rst statement of isconfig is the call to hasa whose result represents the con guration option a see table .
two dataow facts are created for variable aand the possible values true orfalse .
for each value a constraint atable con guration api and value tracking information for example figure api option value tracking com.company.hasa a com.company.hasb b com.company.hasc c com.company.hasd d n a com.company.hase e and arespectively is created based on the con guration option.
these constraints are combined with the current constraint true hence aand aare the nal constraints at this point.
figure shows facts as boxes.
at the following if statement line algorithm is used to create for both outgoing edges branch and fallthrough edge constraints based on the condition a true and the two facts at this statement.
for the sake of simplicity the resulting constraints afor branch edge and afor fall through edge are not shown in the gure.
the fact with value true satis es the constraint and is propagated along the branch edge to line .
the fact for the false case is not propagated along this edge because a ais not satis able.
in line the call to method hasb is used to access the con guration option b. two new facts for variable notb are created.
in this case the current constraint is aand the newly created facts represent band b. the resulting constraints are a b anda b. note how at this crucial point the condition value of notb is conditionalized further by the truth value of a. at the two possible return points lines and the new fact for the variable zat the call site is derived from the facts in the called method.
at line for instance the constraint for zisfalse is calculated from the three incoming facts as a a b a b simpli ed to a a b .
back in method start both facts about variable zare propagated from line to .
the ifstatement at line is handled the same way as previously described.
at line the value of zis overwritten by a non con guration value which is why facts about zare not propagated further along.
after the creation of the constraint on option c line and its use line line will depend on c. this dependency a ects the newly created constraint on option e c efor the true case and accordingly c eforfalse.
because start returns no value the analysis will not propagate any facts beyond the return statement at line .
the only fact at line has the constraint c which is the nal result for this statement.
the handling of option d is di erent from the previous example because value tracking is not used for d. unlike in the other cases there is only one fact created with an unde ned value and the opaque constraint d?.
each ifstatement with a condition dependent on a imprecisely tracked variable will create the constraint d?for the branching edge and d?
for the fall through edge.
we can generally not interpret the constraint d?and only use it to resolve the constraint d?
d ?
true even though this equation could be incorrect.
while constraints on value tracked variables become more and more restrictive in case of nested if statements the constraints on dstay the same.
lines will both possibly 450public void start a boolean z isconfig a if za method7 a z false boolean e false boolean c hasc a if ca e hase a return int c hasd a if c 7a if c 76a return method8 a public boolean isconfig a jimple3like notation boolean a hasa a if aa boolean notb 0hasb a if notba return true return false return hasa a 0hasb a ?
?
?
z false e false c hasc a if ca e hase a returnc!
c c3 c c?
d?
c!
c start isconfig a b z!
a a b z3 a a3a a!
a b notb3 a b notb!
true false undefined a variable name constraintvalue aa b z!
a a b z3 a b a!
a b a!a a!
a a3 if notbaa a!
a bnotb3z isconfig a68 if za method7 a6 ?
c hasd a77 if c 7a78 if c 76a79 method8 a7?
return a hasa a86 if aa87 notb 0hasb a88 return true8 return false86a b notb!
?c e e3 e!
c e c?
d?
c?
d?
c?
d?
c?
d?
figure source code and corresponding call graph annotated with tracked taints depend on dbut we can make no assumptions on how they relate to some form of the con guration option.
the con guration map is created by disjoining the constraints of all facts at a statement.
for example the con guration map entry for line is c c e c e c. .
implementation we implemented the approach presented in section in a tool called lotrack .
the implementation is based on flowdroid a tool for taint analysis of android apps which in turn is based on soot as well as spllift .
soot is a framework for implementing java analyses.
input les i.e.
java source code or java or android bytecode are transformed to the intermediate jimple format.
the jimple format supports analyses by e.g.
transforming complex expression to a set of simpler expressions and introducing variables holding provisional results.
the necessary information on relevant api calls and conguration options are given in a simple con guration le which makes it easy to adapt for most software systems.
we use ordered reduced binary decision diagrams bdds for all operations related to constraints.
because of this our current implementation is limited to precisely track boolean options only.
solving inequality constraints on integer values for instance would require an appropriate constraint solver.
to make it easier to use the analysis results lotrack displays the extracted constraints within the original java code instead of the intermediate jimple code.
the mapping of jimple to java code lines is possible if the compiler isset to include line numbers in the resulting bytecode les which is a common debug setting.
this enables integrating lotrack into ides.
the current implementation has limitations which can both lead to missed constraints as well as an overapproximation of constraints.
for instance dynamic binding of function calls is currently handled imprecisely.
a variabilityaware points to analysis is needed to overcome this limitation.
overapproximation can also happen due to unknown implementation of functions e.g.
in native libraries .
as we will show in our evaluation though lotrack achieves high accuracy.
.
ev aluation toward our goal of providing developers with practical tool support that can recover a con guration map for a wide array of maintenance tasks we have implemented our approach for java applications and speci cally for android apps.
first we evaluate the accuracy of our recovered conguration maps in terms of precision and recall.
second we evaluate the performance of our analysis on a large set of android apps.
subsequently we indirectly demonstrate usefulness by performing a small empirical study on how con guration options are used within common android apps and how con guration options interact.
android apps are an interesting subject for tracking conguration options because the android platform provides many con guration options up to the point that the android platform has gained a reputation for fragmentation into many di erent hardware and software versions and vari451table android con guration options excerpt api con guration option android.os.build version int sdk int sdk configuration.locale locale environment.getexternalstoragestate storage context.getsystemservice vibrator vibrator context.getsystemservice bluetooth bluetooth ants.
android apps use load time options to determine the availability of software and hardware functionality at runtime.
con guration options are accessed through standard api which means that we can study many apps with the same con guration options without the overhead of identifying each system s con guration options separately.
furthermore there is a large research community that has already prepared tool chains for analyzing android apps that we can build on.
finally there are a large number of free and open source apps available to study.
as con guration options we selected options from the android documentation including a wide array of di erent options regarding hardware and software e.g.
availability of sd card usable sensors or framework version .
for each of these options we identi ed the api for reading the con guration value.
we use precise value tracking for all boolean options of all con guration options .
in table we show an excerpt of the identi ed options a full list is available on the project s web page.
note that the list of con guration options could be easily changed or extended for other systems.
.
accuracy before we use our tool to study con guration options in practice we rst evaluate its accuracy.
to obtain an oracle we manually created a con guration map for android apps.
subsequently we automatically extracted a con guration map with lotrack and compared it to the manual result yielding measures of precision and recall.
.
.
oracles we are unaware of any android apps in which the mapping from code fragments to con guration constraints has been explicitly documented so that we could use them as oracle for our study.
instead we manually investigated a set of sample apps to establish ground truth by creating oracles.
as subjects for our evaluation we randomly selected apps from the fdroid5repository of open source android apps.
the selected apps are shown in table including some statistics about their size.
to create oracles we rst documented the process that a human developer would take to track con guration options or to create a con guration map.
this document includes the con guration options and corresponding api calls that should be tracked and a list of possible entry points of the android framework.
for every subject app we asked at least two experts at least one author and at least one researcher not involved in this project to independently identify and track all con guration options in the java source code of the app with the goal of describing all code fragments that are triggered by con guration options.
all experts have multiple years of experience in java and the used ide.
the experts discussed all di erences in their results with the goal of either unanimously agreeing on a correct version or clarifying the process documentation.
in fact we found that the process documentation was clear enough and that all di erences could be explained by omissions by one expert which occurred a few times in larger applications.
in fact our experience in creating the oracles anecdotally con rms that creating conguration maps is well de ned but tedious and error prone when performed manually.
the experts needed up to minutes per app.
using search features of ides the access of con guration apis can be identi ed easily but one quickly loses track of the use of the accessed con guration values and their extensive impact e.g.
on called methods.
to evaluate accuracy we compare the con guration map automatically derived by our tool from the apk bytecode le with the manually derived oracle.
we count continuous lines of jimple code as basic blocks to prevent a bias towards uses of con guration options that a ect a large number of lines.
we measure recall as blocks of jimple code that are correctly mapped to a con guration constraint compared to blocks of jimple code that are mapped to some con guration constraint in the oracle.
we measure precision as blocks of jimple code that are correctly mapped to a con guration constraint to all blocks of jimple code that are mapped to some con guration constraint by our tool.
a correct mapping requires the exact identi cation of the a ected statements as well as the correct constraint.
.
.
results in table we show accuracy of lotrack s results we reach a precision of and a recall of .
there was no case of incorrectly detected constraints the constraints were either correct or missed completely.
in most cases lotrack s result agrees with the oracle.
in cases the tool identi ed constraints for blocks that were missed by all experts when creating the oracle.
checking back with our process instructions we could con rm that the tool was correct and the experts were wrong.
this occurred especially for exception handling and methods called only from optional code.
we decided to update the oracle with the tool s results in these cases.
lotrack missed valid constraint cases mostly due to an incomplete call graph.
for instance some callbacks from the framework were unknown and therefore not handled by the underlying flowdroid implementation.
overapproximation occurred for blocks where most of the cases seem to be related to overly approximate pointsto analysis a well known problem that all static analyses share.
452table comparison of lotrack s result and manually created oracles on apps correct wrong name size java loc like oracle better than oracle missed overapproximation import contacts nectroid oschina tinfoil for facebook anysoftkeyboard mounts2sd impeller keepass nfc dolphin emulator document viewer sum overall our results indicate that the analysis is highly accurate.
in a few cases it has even corrected developers carefully performing the task manually to build the oracle and overapproximation had only a minor e ect.
.
performance to ensure practicality we evaluate performance in terms of analysis time and memory consumption.
we report the median wall clock time as reported by junitbenchmarks6of ve runs after three discarded warm up runs on a core i7 notebook with .3ghz and gb memory.
for memory consumption we report the peak memory usage.
we automatically performed the analysis on the apps from our accuracy analysis and additional randomly sampled apps from the fdroid repository ranging from to lines of jimple code listed on the project s web page.
of the full sample of apps we were unable to analyze four apps due to an error reading the android apk les.
the median time for the analysis is .
seconds the longest run time was seconds.
the maximum peak memory usage was .
gb.
.
configuration options in android apps to exemplify how our analysis can help researchers and developers understand highly con gurable systems we performed a small empirical study on con gurations in android apps.
we used the same set of subject apps as in our performance evaluation excluding the same four apps .
to study the use of con guration options we execute our analysis on each app and investigate the con guration map regarding the following research questions .rq1 what options are used in practice?
to that end we observe which con guration options occur in each app s con guration map.
.rq2 how much of the code depends on one or multiple con guration options in practice?
technically we use the con guration map to identify which code fragments are mapped to con guration constraints with one or more con guration options.
.rq3 how frequently do con guration options interact in practice?
technically we analyze how many code common con guration options option number of apps using the option sdk network storage bluetooth audio table distribution of common constraints constraint share sdk ?
.
network ?
.
storage ?
sdk ?
.
wifi ?
.
locale ?
.
location ?
.
other .
fragments are mapped to con guration constraints involving more than one option.
regarding rq1 the most commonly used con guration option is sdk used by apps .
the option is used to distinguish between the versions of android platform.
depending on the version di erent features of the framework can be used.
other commonly used options are network and storage options used by and apps respectively.
these options subsume information about availability and state of network and storage components.
regarding rq2 the share of statements in jimple notation with constraints ranges from to with an median of .
.
that is most apps depend on con guration options but typically only a small amount of their implementation is con guration speci c. only few outliers contain much con guration speci c code.
large amounts of con guration speci c code are typically due to classes or methods being exclusively used in parts of the code guarded by certain con guration settings.
certain patterns in the code may lead to an initially surprising high number of statements with constraints e.g.
an early return based on a conguration option or the use of exception handling.
453regarding rq3 we investigate not only options but speci c constraints to determine to what degree options interact.
table shows the distribution of common constraints as their share in of all extracted constraints.
by far most constraints involve only a single option.
by far the most statements depend on option sdk without interactions.
the most common interaction involves storage andsdk.
we did not nd any interactions among boolean options that would allow value tracking in our subject systems.
our ndings that interactions are relatively rare in practice is consistent with previous results on java applications .
.
threats to validity due to technical limitations of our implementation see section we only support the use of con guration options through their normal api though other ways e.g.
using re ection are possible.
in our evaluation of accuracy we only used a small sample to show the correctness of our implementation due to signi cant e ort for creating reliable oracles.
the results are consistent however giving con dence to the accuracy of our approach on real software systems.
we only looked for con guration options given by the used framework whereas more options can be de ned by each app.
this could increase the number of statements depending on con guration options.
.
related work our approach can be compared to static program slicing especially forward slicing with the api access as the slicing criteria.
the slice would contain all program statements affected by a con guration options including all statements that propagate con guration options.
in contrast to slices our con guration map only includes statements included or excluded due to con guration options and controlow decisions but not those statements that read compute with or assign con guration related values.
in addition where possible we track option values to report also how a code fragment depends on a con guration option.
thin slicing reduces the size of a traditional program slice by considering only producing statements reducing accuracy and producing smaller slices.
this technique is optimized towards debugging and program understanding tasks whereas we select optionally executed statements to support testing and maintenance of con gurable software.
recently a combination of thin slicing and bytecode instrumentation have been used to produce a ranking which con guration options may most likely in uence a controlow decision to assist with con guration errors .
this technique helps to nd relations between concrete program behavior and the con guration.
lotrack on the other side connects information about con guration options with the source code.
ouellet et al.
pursued a similar goal of tracking the inuence of con guration options with a static analysis.
however their approach does not track dataow dependencies and thus cannot identify indirect access of con guration options.
reisner et al.
used symbolic execution to explore how con guration options interact in the execution of a set of test cases.
they track con guration options as symbolic values and found that interactions are relatively rare and restricted to few options at a time.
their analysis is more accurate but also much more expensive several computation weeksper system and limited to speci c test executions whereas we statically analyze all possible executions tracking only con guration options.
ribeiro et al.
use dataow analysis to explain how data ows among code fragments belonging to di erent conguration options to support developers with mechanically derived documentation called emergent interfaces.
in contrast to our work they know a static con guration map from preprocessor usage and track potential dataow of all other variables whereas our goal is to track load time con guration options.
more generally our goal of nding a con guration map is related to work on con guration debugging and con guration testing.
in con guration debugging runtime faults are explained in terms of the current con guration and a di erent con guration is suggested to users to work around the problem using various dynamic and static analyses .
con guration testing determines whether con guration options in uence a test case s execution to determine the smallest set of con gurations that actually needs to be executed .
in contrast to con guration debugging and testing however we do not reason about runtime behavior beyond the in uence of con guration options.
furthermore researchers have investigated whether two patches can interact .
similar to our work they track the potential in uence of variations in their case patches in ours options to identify whether multiple changes can interact.
after detecting potential interactions they typically focus testing e orts on those code fragments.
technically our value tracking is roughly similar to dataow analyses extended with constraint tracking e.g.
used to build a path sensitive null pointer analysis for c which is unable to handle complex constraints representing interactions .
it is in uenced by ideas from variability aware analysis execution for product lines where di erent values can be tracked under di erent con gurations in the same application but tailored to support load time con guration options with small domains.
.
conclusion we have extended a standard taint analysis to track loadtime con guration options within a program.
the analysis produces a con guration map explaining for each code fragments under which con guration options it may be executed.
this con guration map can be used for a wide array of maintenance tasks such as understanding the impact and interactions of con guration options.
we have implemented the analysis in our tool lotrack and demonstrated its use by studying con guration options in android apps.
our evaluation demonstrated a good accuracy recall and precision as well as a performance good enough for use on real software systems .
sec on an average app .
lotrack is not limited to analyzing apps but can be used for java applications as well.
the general concepts should extend to most other imperative programming languages.
.