ranger parallel analysis of alloy models by range partitioning nicol as rosner department of computer science fceyn uba argentina nrosner dc.uba.arjunaid h. siddiqui department of computer science lums school of science and engineering pakistan junaid.siddiqui lums.edu.pknazareno aguirre department of computer science fcefqyn unrc argentina naguirre dc.exa.unrc.edu.ar sarfraz khurshid department of electrical and computer engineering the university of texas at austin usa khurshid ece.utexas.edumarcelo f. frias department of software engineering instituto tecnol ogico de buenos aires argentina mfrias itba.edu.ar abstract we present a novel approach for parallel analysis of models written in alloy a declarative extension of first order logic based on relations.
the alloy language is supported by the fully automatic alloy analyzer which translates models into propositional formulas and uses off the shelf sat technology to solve them.
our key insight is that the underlying constraint satisfaction problem can be split into subproblems of lesser complexity by using ranges of candidate solutions which partition the space of all candidate solutions.
conceptually we define a total ordering among the candidate solutions split this space of candidates into ranges and let independent sat searches take place within these ranges endpoints.
our tool ranger embodies our insight.
experimental evaluation shows that ranger provides substantial speedups in several cases superlinear ones for a variety of hard to solve alloy models and that adding more hardware reduces analysis costs almost linearly.
index terms static analysis alloy parallel analysis sat.
i. i ntroduction declarative formal models of software are valuable at a number of different stages of software development.
they are particularly useful during requirements elicitation as a means to express requirements in a language that is precise and expressive enough to document the needs of stakeholders.
moreover declarative models allow us to document rationales behind design decisions and even to analyze properties of software designs prior to implementation.
during the implementation phase declarative models allow programmers to document expected properties of their classes and methods e.g.
using class invariants method contracts and loop invariants which can also be exploited for different kinds of analyses.
a number of modeling languages today allow writing formal declarative models .
our specific focus is alloy a declarative extension of firstorder logic based on relations.
alloy s concise yet expressive notation together with its fully automated sat based alloy khurshid s work was funded in part by the us nsf grant ccf .analyzer tool make the language particularly appealing for modeling and analysis.
indeed alloy has already been used effectively in requirements design testing and as an intermediate language in static program analysis .
section ii provides further details regarding alloy and its analysis tool.
alloy s analysis technique known as scope bounded checking analyzes a model s correctness with respect to a bounded universe of discourse by searching for violations of assertions that the user may expect to hold in the model.
the assertions on a model are evaluated on model instances whose domains are bounded in size.
the bound on the size of model instances is termed the scope and is given by the user.
clearly assertions that pass the analysis are not necessarily valid in general they are valid for the given scope.
thus to enhance their confidence in the correctness of their models alloy users must run their analyses for larger scopes.
however the cost of the sat based analysis underlying alloy is exponential in those bounds so in many cases the analysis is limited to small scopes.
this might not be an issue if alloy is used just as a convenient declarative language with easy to use automated analysis to quickly check the validity of intended properties on small model instances.
but the versatility of the language and the significant advances on sat technology are causing a shift from the above use of the tool to its current use as an expressive specification language with a powerful underlying analysis technique.
thus alloy users are continuously demanding more efficiency from the tool as well as scalability the possibility of running analyses for larger scopes without having to resign the declarativity of the language.
this is evidenced by the existence of a variety of tools that use alloy as a backend for sophisticated analyses which push the limits of the alloy analyzer and by the increasing concern on employing suitable alloy idioms in modeling that allow for more efficient analysis.
c ieee ase palo alto usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.147our work in this paper is motivated by the aforementioned demand on scalability of alloy analysis and is driven by our desire to effectively leverage the increasing availability of commodity hardware for effective parallelization schemes.
we present ranger a novel parallel analysis technique for alloy models based on what we call range partitioning .
essentially the technique relies on the definition of a linear ordering on the state space of an alloy model.
a partition of the state space can then be defined by splitting the linear ordering into non overlapping intervals called ranges .
each restriction of the original problem to a particular range thus becomes an independent subproblem which can be analyzed by a separate processor on a cluster of computers.
further details are presented in section iii.
we also discuss some more technical implementation related issues in section iv.
we perform an experimental evaluation of our approach for range partitioning using a benchmark consisting of hard toanalyze properties from different alloy models section v .
the benchmark includes unsatisfiable and satisfiable problems from a variety of problem domains from protocol specification to complex test input generation.
we show that for workers the average speedup over the hardest scopes that were still tractable by the alloy analyzer within hours was .76x and the maximum such speedup was .35x.
more importantly in all cases ranger was able to push the tractability barrier successfully handling the assertions for scopes that exceed the capabilities of the alloy analyzer in some cases it was able to do so for scopes that stand no chance whatsoever of being tractable by the analyzer.
in section vi we discuss existing techniques aimed at improving the scalability of alloy including parallel analysis tools and techniques related or applicable to alloy.
finally our conclusions and some proposals for further work are presented in section vii.
in summary this paper makes the following contributions range partitioning.
we introduce the idea of distributing an alloy problem into several subproblems of lesser complexity by defining ranges of candidate solutions parallel analysis for alloy.
we present ranger our technique for effective parallelization of alloy problems using dynamic work stealing experimental evaluation.
we embody ranger into a prototype implementation and present experimental results that show the effectiveness of ranger in analyzing a variety of alloy models.
ii.
a lloy and the alloy analyzer alloy is a declarative modeling language whose syntax incorporates features that are ubiquitous in object orientation.
this amenable syntax has a relational semantics whose comprehension requires elementary concepts from discrete mathematics.
formally alloy s relational logic is an extension of first order logic with reflexive transitive closure.
let us introduce alloy s syntax and semantics through an example corresponding to an alloy model for a heap allocated binary tree data structure shown in figure .
data domains areone sig null abstract sig object sig bintree extends object root node null sig node extends object left right node null pred acyclic all n t.root.
left right n !in n. left right n. left n. right in null n !
null lone n. left right pred numnodesequalsnumedgesplusone t.root !
null t.root.
left right null left.node right.node pred nounreachablenodes t.root.
left right node null fact all t bintree nounreachablenodes check all t bintree acyclic numnodesequalsnumedgesplusone for but bintree exactly node fig.
.
a sample alloy model for binary trees.
defined using signatures denoted by the keyword sig which are represented as sets.
signature node for instance declares a set of node objects.
akin to classes in object oriented languages signatures may extend other signatures in which case domains defined by the extending signatures are subsets of the domains defined by the extended ones.
a signature may be abstract meaning that its domain only contains elements that belong to its extending signatures.
like classes signatures may contain fields which are captured by relations.
for example field root denotes a total and functional binary relation contained in bintree node null .
it is worth emphasizing that alloy fields may also denote relations of arity greater than .
predicates allow us to name properties while functions name terms.
they may be combined to write axioms which are called facts in alloy.
alloy expressions are built using set theoretical and relational operators and constants.
constants univ iden and none denote the set containing all elements the identity binary relation on such set and the empty set respectively.
operations and denote set union difference and intersection respectively.
relational operators include composition called navigation in alloy transpose and reflexive transitive closure.
they are defined as follows r s fha1 a n b2 b mi an b1 ha1 a ni2r hb1 b mi2sg navigation r fhb ai ha bi2rg transpose br i 0ri transitive closure r i 0ri re exive transitive closure 148we define r0 iden andri itimesz r r. transpose and closures are only defined for binary relations in alloy.
function computes the cardinality of a relation.
for example term t root left right null in predicate numnodesequalsnumedgesplusone denotes the number of nodes reachable from the root of tree tby traversing talong fields left andright .
expression lone rrequires relation r to have at most one element.
alloy formulas are built from the atomic predicate in inclusion using standard connectives from first order logic.
java notation is used for propositional connectives.
quantifiers are denoted by all universal and some existential .
our sample model also includes an assertion a property that is expected to hold in valid model instances i.e.
those satisfying the structural constraints imposed by signature definitions and facts .
as explained in section i assertions are a means to verify model correctness and are analyzed using the alloy analyzer within user prescribed bounds.
check commands are issued in the model and set the bounds for data domains.
in this example the analyzer will analyze all configurations with at most one tree and exactly nodes and zero elements for other domains except null which is constrained in the model to have exactly one element .
iii.
r ange partitioning in this section we present range partitioning our new technique for parallel analysis of alloy models.
as we will show later on this technique provides a substantial improvement to the scalability of the sat based analysis compared to the sequential alloy analyzer.
the technique essentially consists of the following stages given an alloy model all candidate configurations that would be explored by the analyzer are linearly ordered.
this step establishes a linear ordering c1 c2 c n notice that the number of configurations although usually very large is finite due to the imposed bounds .
some arbitrary configurations cj1 cj2 c jiare selected and the aforementioned ordering is split into ranges using those arbitrary configurations as partition points note that we do not demand these configurations to satisfy the model axioms .
we then obtain ranges c1 c2 c j1 .
the alloy model is constrained yielding models that correspond to the different ranges.
these models are distributed to different processors and analyzed in parallel.
the above described process requires addressing the following technical challenges define a linear ordering on the set of candidate configurations.
provide an algorithm for selecting appropriate configurations as partition points ideally we want ranges to contain roughly the same number of configurations .
solve the distribution problem in an efficient way.
we will deal with each one of these challenges in sections iii a iii c.a.
a linear ordering on configurations in order to explain how a linear ordering on configurations can be defined let us first describe how configurations are internally handled by the alloy analyzer.
this tool translates models to kodkod s language.
from the scopes in the check command kodkod generates a uniform naming for domain elements or atoms as these are called.
for the example in fig.
kodkod produces the naming in table i. table i naming table for the model from fig.
.
sig scope naming object object null null node node .
.
.
node from the naming and other information see section iv a ranger builds a vector specification i.e.
a mapping vecspec atomnames relnames!p atomnames that given an atom name nand a relation name r retrieves the atom names that may be considered as the result of computing n r. hence a vecspec is used to capture the state space of configurations.
for the sake of simplifying the presentation we will restrict ourselves to total and functional signature fields.
notice that in the example from fig.
all fields satisfy this constraint.
figure provides a graphical representation of the vecspec associated with the model from fig.
.
object null node node node node node object null node node node node node root left right fig.
.
graphical representation of a vecspec.
in the figure object may relate to null node .
.
.
node via relation root .
no element relates via any relation to object .
while a vecspec describes the state space a configuration is a particular state.
configurations can be described by choosing for each entry in the vecspec one of the possible values.
in fig.
we show a configuration vector as well as the binary tree described by the configuration.
we take the ordering in which kodkod lists atom names as the strict linear ordering on atom names.
we will denote this ordering on atom names by k. this ordering can be extended to a lexicographical ordering between configurations denoted by lc as follows notice that all vector configurations have the same size which we denote by s c lcc0 9i i s c c0 c kc0 149object null node node node node node node node node null node null node null null null null object root node node node null node leftright leftright node rightleft left leftright rightfig.
.
sample configuration for the model in fig.
.
theorem .relation lcis a strict total order on the set of configurations.
proof.
we must prove that lcis irreflexive transitive and total.
irreflexivity and totality follow from the irreflexivity and totality of k respectively.
let us focus then on transitivity.
letc1 lcc2andc2 lcc3.
let i0 i1be the values such that c1 c2 c1 kc2 andc2 c3 c2 kc3 .
let i min i0 i1 .
notice that c1 c3 .
ifi i0 i c1 c1 kc2 c3 .
if i i1 i c1 c1 c2 kc3 .
ifi i0 i1 then c1 c1 kc2 c2 kc3 .
thus since kis transitive c1 kc3 which implies c1 lcc3.
theorem allows us to adopt lcas the strict linear ordering on configurations.
b. selection of the partition points partition points are configurations that serve as boundaries between ranges.
in this section we show how given a range r with c1 lcc2 and a positive number n we can select configurations x1 x n 12rsuch that ranges where nextconf xi is the next configuration after xiwith respect to lc are all contained in and are balanced with respect to the number of configurations they contain.
alg.
presents the pseudocode for partitioning a range into two subranges.
it consists of finding an appropriate mid point between the two end points of the range.
lines describe the most frequent case where the first position in which the vectors corresponding to the end points of the range disagree contains elements that are far apart enough that a middle element can readily be found.
the scenario as well as the result returned by alg.
are illustrated in fig.
.
notice that once a partition point has been found the source range is split into the ranges and .
pseudocode for method nextconf which retrieves the next configuration according to ordering lc is presented in alg.
.
intuitively the behavior of alg.
is quite similar to adding in elementary arithmetic yet instead of using digits through or those of any other fixed uniform base the algorithm uses for each cell of a vector the sorted list of options available for that cell according to the vecspec.
the reader should keep in mind that the options for each cell can be an arbitrary subset of the set of all atoms.1config binrangepartition lv rv config vs vecspec i skip common prefix while lv rv do i i end fdl fdr lv rv first values that differ options fdl kx kfdr sorted list ifoptions !
then midoption options output lv output midoption fori j len vs do output max vs end return output else values at pos idiffer by e.g.
lv rv ifi len vs then return lv end i i while lv max vs rv min vs do i i ifi len vs then e.g.
lv and rv return lv end end iflv !
max vs then e.g.
lv and rv output lv fori j len vs do output max vs end return output else e.g.
lv and rv output rv fori j len vs do output min vs end return output end end 41endalgorithm the binary partitioning algorithm.
1config nextconf c config vs vecspec c must not be the last config.
i len vs output c while true do options sorted list pos position of options inoptions ifpos len options 1then output options return output else output options i i end end 15endalgorithm pseudocode for method nextconf .
let us now focus on the generation of range partitions in the general case.
algorithm presents the pseudocode for the actual partition algorithm.
the algorithm starts from an input150object null node node node node node node node node null node null node null null null null lv object null node node node node node node node node null node null node null null null null rv object null node node node node node node node node node node output node node node node node node fig.
.
application of partitioning standard case .
1list rangepartitioning r range n int vs vecspec l addtoemptylist r l i index for traversing the list while len l n hassplittableranges l do ifsplittable l then con g c1 leftendpoint l con g c2 rightendpoint l con g c3 binrangepartition c1 c2 vs removerangeatpos l i addrangeatpos l i addrangeatpos l i ifi len l 2then i i else i end else ifi len l 1then i i else i end end end 25endalgorithm the range partitioning algorithm.
range and iterates over a list of already generated ranges as long as the requested number of ranges has not been reached and there are still some ranges left to be split ranges of the form cannot be split any further .
c. parallel range analysis in section iii b we proposed a method to partition a range into sub ranges we now explain how to use the aforementioned in order to parallelize the analysis of an alloy model.
our scenario for parallel analysis makes use of a cluster of computers.
worker processes execute commands sent by a master process which runs on a dedicated processor.
actions that workers can perform include solving a task sequentially aborting the ongoing analysis splitting the current task into a given number of ranges and locally enqueueing the resulting subtasks fetching a new task from the local queue and moving tasks between local and remote queues requesting and obtaining tasks from other workers .
further details on ranger s implementation will be provided in section iv.
in the remaining parts of this section we present two alternatives for parallelization both based on range partitioning.
before so we discuss the impact of alloy s symmetrybreaking predicates on the ranges generated by partitioning.
range partitioning and symmetry breaking atom names are irrelevant when building an alloy configuration given a configuration that satisfies or not the facts of an alloy model any other configuration obtained by mere permutation of atom names while of course preserving typing constraints will behave in the same way.
symmetry breaking axioms are introduced by kodkod during the translation of the alloy model to a propositional formula and greatly improve the performance of the underlying sat solver by avoiding the exploration of many such superfluous isomorphisms.
therefore symmetry breaking has a direct impact on what nonsuperfluous configurations will look like.
for example for the model in fig.
field root can only relate to atom names null ornode .
hence any ranges in which root points to nodes node node node ornode contain configurations that cannot satisfy the propositional formula generated by kodkod.
for our sample alloy model from fig.
but using a scope of node since node is too easy table ii shows how partitioning the full range into increasingly large numbers of ranges yields very small numbers of nontrivial subproblems.
the remaining ranges can all be proved unsatisfiable in under a millisecond each.
as we will see in sections iii c2 and iii c3 the fact that a significant number of the tasks resulting from a partition may become trivial can lead to hardware being severely underused.
in order to measure the actual utilization of the assigned hardware during parallel analysis we define the metric hardware usee ciency total non idle seconds number of workers t where tis the wallclock runtime in seconds taken by the whole parallel analysis as perceived by the end user and the numerator is the sum over all workers of the number of seconds during which some task was actually being analyzed.
table ii range partitioning number and percentage of nontrivial subproblems of those generated for bintrees with 10no d e .
num.
ranges nontrivial nontrivial .
.
.
.
.
.
flat range partitioning one way of parallelizing the analysis based on range partitioning consists in determining a large enough value of n called the fan out of the analysis and having a worker partition the full range into nranges using algorithm rangepartitioning .
the nnewly generated tasks are then solved in parallel by the available workers.
each worker receives a task and solves it sequentially until a sat unsat verdict is obtained.
unfortunately this approach seldom performs as well as expected.
in most cases the solving time variance hardest vs. easiest subproblems obtained after initial partitioning is very high.
thus if the initial range is only partitioned once eventually only a few active workers will remain while almost all other workers will be idle until151the end of the run.
table iii reports the hue for the analysis of the model in fig.
when flat range partitioning is used.
table iii efficiency rates obtained for flat range partitioning of bintree example with 10no d e using 64workers .
num.
ranges hue .
.
.
.
.
recursive range partitioning the main drawback of flat range partitioning is its static nature.
trying to balance the number of candidate configurations in each range is indeed a reasonable starting point but we cannot predict in the general case where the harder subranges might lie.
a more dynamic approach to determining the location of nontrivial subranges is therefore desirable.
in recursive range partitioning the oldest active subproblem i.e.
the oldest among those that are still being sat solved can be re partitioned by its assigned worker.
this yields sub subproblems and so on recursively.
recursive partitioning of a range may occur under two circumstances the unsat frequency i.e.
the number of unsat verdicts per second falls below a user defined threshold or there are idle workers.
the first condition aims at achieving progress during analysis by avoiding wasting time analyzing tasks that are still too hard to be solved sequentially by a worker.
the second condition targets the hue metric and strives to make good use of resources by avoiding idle workers.
unlike flat partitioning where the fan out must be large and fixed beforehand in recursive partitioning we use a small fanout its value is set to the number of workers.
for instance in the experiments reported in section v the fan out is since that is the total number of worker cores in the cluster.
in this way whenever many of the tasks turn out to be trivial or shortly after idle workers start to abound the recursive partitioning process will react by zooming in i.e.
focusing the computational effort on the remaining nontrivial tasks.
using recursive range partitioning the hue value for our example for the same node scope becomes .
which is about times higher than with flat range partitioning.
even if we only count the time invested in successful solving attempts as non idle time i.e.
if partial solving attempts before resplitting were to be considered completely wasted effort the hue value for this run would be .
still a significant improvement over the low efficiency of flat partitioning.
the following theorem discusses the correctness of recursive range partitioning.
a detailed proof is omitted due to space constraints.
theorem .recursive range partitioning is sound and complete i.e.
an alloy model has a satisfying configuration if and only if one can be found using recursive range partitioning.
proof sketch recursive range partitioning splits ranges whenever tasks are aborted.
proving the theorem then requires showing that each time a range is partitioned according toalg.
no configurations are lost.
algorithm iteratively splits a list of ranges using the binary split implemented in alg.
.
then given a range visited by alg.
it suffices to show according to program lines and that where vs is the global vecspec and c3is the configuration returned by alg.
.
we now need to prove that c32 and thatnextconf c3 vs indeed returns the next configuration.
the first proof is completed by considering the alternatives provided by the guards in the algorithm.
for instance if the setoptions is nonempty the proof is immediate see lines .
regarding the second property we must prove that alg.
terminates and that when it terminates it produces the next configuration.
termination is guaranteed because index iiterates from the back of the array until it finds a position in the configuration in which the stored atom name is not the maximum possible.
such a position must exist because the input configuration is required not to be the largest possible one.
proving that the configuration produced by alg.
is the next one according to ordering lcreduces to showing that if a configuration cexists such that c3 lccand c lcnextconf c3 vs then c nextconf c3 vs .
iv.
i mplementation details a. initial model translation and vecspec construction given a user provided alloy model as a first step ranger interfaces with the alloy analyzer to obtain a list of suitable fields for range partitioning currently all functional binary relations are used see section v e and to have the model translated to cnf.
during the translation it also interacts with kodkod in order to obtain the necessary information to build the vecspec a copy of the atom universe details on which atoms appear in each relevant relation s domain and range and on which propositional variable is being used to represent presence or absence of each tuple in each relevant relation.
the model is only translated once.
the resulting cnf file is broadcast by the master to all workers along with a description of the vecspec just before the distributed analysis phase starts.
all further range related restrictions are to be injected by the workers directly at the clausal level every time they load a new task into their local sequential solver.
this eliminates the cost of re running the alloy translation toolchain and allows for subproblems to be very lightweight objects each pending task is represented by a pair of vectors which require less than a few hundred bytes each even for the largest scopes and models in our benchmark .
b. clauses added to enforce sat solving within range in alg.
we show pseudocode illustrating what each worker does when loading a new subproblem.
three groups of clauses are injected.
the first group limits the search to candidate configurations that are no smaller as per lc than the left endpoint of the range whereas the second group requires that they be no larger than the right endpoint.
for the third group both vectors are scanned from left to right until the end of their common prefix if any is found.
a unit clause is added152for every cell that could only have one possible value i.e.
within the common prefix .
at the first cell where left and right values differ an all positive clause is generated.
the third group does not really add any new constraints its clauses could also be derived with some effort from the first two groups and the rest of the translated model.
however empirical evidence suggests that the presence of this positive formulation often promotes faster propagation.
letlbe the vector length and ci with i l the number of choices for the i th cell according to a vecspec.
thenp i ci is a worst case upper bound for the number of clauses added by either of the first two groups as for the third group it cannot add more than lclauses.
in practice we have not seen any case where the total number of added clauses reached of the number of clauses in the cnf.
1addrangeclauses ss satsolver r range vs vecspec forbid anything smaller than left endpoint con g lvec leftendpoint r antecedent empty list forith atom in enumerate lvec do options vs atoms sorted list position options indexof atom forbidden options forfith fatom in enumerate forbidden do fpvar vs pvars ss addclause antecedent end atom pvar vs pvars antecedent append atom pvar end forbid anything greater than right endpoint con g rvec rightendpoint r antecedent empty list forith atom in enumerate lvec do options vs atoms sorted list position options indexof atom forbidden options forfith fatom in enumerate forbidden do fpvar vs pvars ss addclause antecedent end atom pvar vs pvars antecedent append atom pvar end add a unit clause per common prefix cell and a clause for the first differing cell atompairs zip lvec rvec forith latom ratom in enumerate atompairs do options vs atoms lpos options indexof latom rpos options indexof ratom iflatom ratom then still within common prefix ss addclause else first cell where values differ ss addclause vs pvars break end end 40end algorithm adding clauses to enforce ranged analysis.
v. e xperimental results in this section we first describe the hardware and software setup v a .
we then evaluate ranger on a benchmark ofmodels that includes valid v b and invalid v c assertions.
in v d we evaluate how the speedup achieved by ranger evolves as the amount of hardware used for the analysis varies.
finally in v e we discuss some possible threats to the validity of the presented experimental results.
a. setup and conventions ranger is a distributed application based on the mpi standard.
each of its worker threads runs the minisat solver version .
.
.
all experiments were run in a cluster of commodity pcs each featuring an intel core i7 core thread processor with a .
ghz clock speed and gb ddr3 ram running linux .
.
.
all ranger experiments were run on 8x8 nodes each running worker threads except where otherwise indicated.
each experiment was run times the reported timing is the average thereof.
all times are given in wallclock seconds.
to timeout means failure to complete within seconds hours except where otherwise indicated.
oofm out of memory means failure to complete due to exhausting gb of main memory.
aa alloy analyzer means that the same sequential sat solver used by ranger minisat .
.
was run on the unmodified cnf translation of the source alloy model.
b. unsat cases valid properties binary trees is the model that we introduced as a running example in section ii.
property t wodefsequivalent asserts the equivalence of two different characterizations of the binary tree structure.
as shown in table iv its difficulty curve is particularly steep although the property can be proven for scope in under a minute scope requires over hours.
ranger can prove the latter in under minutes a 119x speedup.
it can also prove the property for scope in under an hour whereas the alloy analyzer fails to prove it within the hour timeout.
note that in this case the speedup is conservatively reported as being since we do not know how much longer than hours the analyzer would need.
the actual speedup is likely to be much higher.
linked lists is a model involving singly linked lists.
in this case the goal is to verify that different definitions are equivalent.
the model includes two separate properties to that effect p airwise which asserts that d1 d2 d2 d3 and c ircular i.e.
d1 d2 d2 d3 d3 d1 .
tables v and vi show similar behaviors for both properties with ranger obtaining about 14x speedup on the largest scope that the alloy analyzer can handle within hours and then being able to prove the properties for additional scopes.
chord is a model of the chord distributed hash table lookup protocol.
it is one of the case studies bundled with the alloy distribution.
the model contains one property called findsuccessor works that is particularly hard to prove.
table vii shows a speedup of at least 103x again merely a floor value for the first scope that is not tractable sequentially.
it also shows that distributed analysis pushes the tractability barrier another scopes for this property.153stable mutex ring another alloy bundled example is a model of dijkstra s k state mutual exclusion algorithm for a ring .
there are two hard to prove properties in this model.
both use the notion of a bad tick an instant in time where two or more distinct processes try to run their critical sections simultaneously.
n obadsafety trace asserts that it is impossible to find a trace with a loop containing a bad tick such that the algorithm would never stabilize .
c losure asserts that there can be no bad ticks if the first tick is good .
as seen in tables viii and ix ranger pushes the ten hour tractability limit scopes from to for the former and scopes from to for the latter.
at the last aa tractable scopes and respectively the speedups exceed 200x for nobadsafety trace and 40x for c losure .
firewire describes the behavior of the leader election protocol used in the ieee standard for connecting consumer electronic devices.
this is another case study included with the alloy distribution.
the hardest property in the model is a tmostoneelected which asserts that two or more devices cannot be elected as leader in the same state.
as shown in table x distributed analysis yields nearly 20x speedup for scope .
for scope where the alloy analyzer fails to yield a result within hours ranger proves the property in under hours.
c. sat cases invalid properties instance generation many alloy borne sat cases are easy typically when the translation of an alloy formula results in a satisfiable cnf finding a satisfying valuation is a quick and simple matter.
however hard sat problems do come up in practice and can be very challenging indeed.
therefore we also evaluate ranger on some difficult sat instances.
binomial heap is the translation to alloy of a java binomial heap class implementation taken from .
one of its methods extractmin contains a bug that can only be detected for some sufficiently large input structures.
property e xtract mincorrect asserts the correctness of said method.
its translation to cnf yields unsat problems up to scope but nontrivial sat problems for scopes and above.
although the speedups obtained were modest around 3x on average it was important for us to confirm that ranger did not miss the counterexample whenever one existed.
avlt rees was originally written for automated test input generation.
the goal for scope n is to find some configuration that represents a valid a vl tree of size n. an easy task for small n this becomes much harder as ngrows.
table xii shows that it took the analyzer over one hour to produce an a vl tree of size while ranger achieved the same in seconds a 27x speedup.
at scope sequential analysis exhausted gb of memory whereas distributed analysis succeeded in producing a vls of sizes and .
the f irewiremodel also includes n orepeats an instance generation command.
this is an auxiliary property the author of the model suggests running it repeatedly increasing the number of states until no counterexample is found to determine how many states suffice for a certain scope.
fortable iv binary trees twodefsequivalent scope aa ranger speedup .
.
.
.
.
.
.
.
.
to .
.
to to table v linked lists three defsequivalent pairwise scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
to .
.
to .
.
to to table vi linked lists three defsequivalent circular scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
to .
.
to .
.
to to table vii chord findsuccessor works scope aa ranger speedup .
.
.
.
.
.
to .
.
to .
.
to to table viii stable mutex ring nobadsafety trace scope aa ranger speedup .
.
.
.
.
.
.
.
.
to .
.
to .
.
to .
.
to .
.
to .
.
to .
.
to .
.
to .
.
to .
.
to .
.
to to table ix stable mutex ring closure scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
to .
.
to .
.
to .
.
to .
.
to to table x firewire atmostoneelected scope aa ranger speedup .
.
.
.
.
.
.
.
.
to .
.
to to154large scopes finding such intermediate sat instances becomes a hard problem in its own right.
we ran these analyses sequentially for up to states per scope and for each scope re ran the most demanding analysis using ranger .
as shown in table xiii the distributed approach yielded over 40x speedup for the last sequentially tractable scope and was able to raise the tractability limit from to .
table xi binomial heap extract mincorrect scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table xii avlt rees generate instance scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
oofm .
oofm .
oofm to table xiii firewire norepeats scope aa ranger speedup .
.
.
.
.
.
.
.
.
.
.
.
oofm .
oofm .
oofm .
oofm .
oofm .
oofm .
oofm oofm d. adding more hardware for each of the aforementioned series we took the hardest scope that was tractable by ranger on 8x8 and re ran it using half as much hardware more hardware and twice as much hardware i.e.
on 4x8 12x8 and the full 16x8 capacity of the cluster .
the results are reported in table xiv.
in all unsat cases the actual runtimes were close to the linear extrapolation of the 8x8 timing.
sat cases are less predictable since rather than exhausting the search space success depends on quickly finding the first needle in the haystack.
while a vl instance generation scaled even better than expected the other two cases did not do as well and sat runs on 4x8 performed poorly in general.table xiv adding more hardware model property scope 4x8 8x8 12x8 16x8 linkedlists equiv.
pairwise to linkedlists equiv.
circular to bintrees equivalence chord findsuccworks smring closure to smring badsafetytrace to firewire atmostoneelected bheap extractmincorrect a vl instance generation to firewire norepeats e. threats to validity when building a vecspec from an alloy model the current ranger implementation considers functional binary relations.
note that this does not restrict input models to those that only use such relations.
ranger can analyze alloy models with relations of arbitrary type and arity it simply ignores nonfunctional and or ternary relations for the purposes of building the vecspec and therefore for those of range partitioning.
so far this does not seem to be an impediment most of the models in the benchmark use nonfunctional and or ternary relations some even use many of them and comparatively few functional binary ones.
however this does imply that if a model uses no functional binary relations at all it would not be splittable by the current version of ranger as the vecspec would be empty.
a binary nonfunctional relation r a b can be seen as a ternary relation tr a b ftrue falseg where a b 2r a b true 2tr.
therefore the problem reduces to handling ternary relations.
we can see a ternary relation t a b cas a total function ft a!p b c where ft a f b c 2b cj a b c 2tg.
note that such functions would introduce a large number of options in the vecspec but that each split reduces such options by half.
vi.
r elated work as stated in section i scaling alloy analysis to larger scopes is necessary to improve the confidence levels attainable by users when analyzing models.
an important step in this direction is the inclusion of symmetry breaking predicates during the translation to propositional logic significantly enhancing analysis capabilities .
surprisingly developments on parallel and or distributed analysis of alloy models are scarce.
the first option to consider is using a parallel sat solver.
multi core sat solver research has gained a lot of momentum.
manysat and plingeling are award winning multithreaded sat solvers.
as shown on table xv ranger frequently outperforms both of them even when running on a single machine 1x8 possibly due to the synergy between155table xv ranger on 1x8vs.multithreaded sat solvers .
to min model property scope ranger plingeling manysat 1x8 v578f 1x8 v2.
1x8 linkedlists equiv.
pairwise .
.
.
.
to to to to to bintrees equivalence .
.
.
.
to to to to to chord findsuccworks .
.
.
.
.
.
to to to smring closure .
.
.
.
.
.
to to to smring badsafetytrace .
to .
.
to to to to to firewire atmostoneelected .
.
.
to .
.
bheap extractmincorrect .
.
.
.
.
.
to .
.
a vl instance generation .
.
.
.
.
.
to .
.
firewire norepeats .
.
.
.
.
.
to .
.
range partitioning and alloy s symmetry breaking.
but another important advantage of ranger is its distributed nature which makes it possible to add more machines and combine their computational power.
multithreaded solvers heavily depend on shared memory and are thus confined to a single computer.
usable distributed sat solvers are hard to come by.
pmsat a cluster oriented version of minisat is available but reports generally small speed ups.
gradsat reported experiments showing an average .27x and a maximum .9x speed up using various numbers of workers ranging between and .
c sat is a sat solver for clusters.
it reports linear speed ups but the tool is not available for experimentation.
also relying on a parallel sat solver prevents making use of alloy level information that may contribute to better analyses.
in the notion of transcoping is introduced as an aid to improve parallel analysis of alloy models.
since alloy analyses occur within given bounds transcoping proposes to explore small scopes first in order to extrapolate the best way to distribute the analysis of larger scopes.
ranger may contribute to the development of transcoping given that it introduces a new technique for distributing the analysis.
although little research has been done on parallelizing its analysis alloy has been used as an intermediate language by different tools that parallelize code analysis.
in parallel analysis of code is performed by splitting the program control flow graph and using jforge which relies on kodkod to analyze each slice.
note that as in parallelization occurs at the code level not at the intermediate alloy representation level.
in parallel analysis of java code is performed by translating complete methods to alloy.
the partitions needed to parallelize the analysis are obtained from the intermediate alloy representation.
unfortunately the efficiency of the technique depends on the presence of class invariants or thelack of aliasing concepts usually absent in more general alloy models such as the ones considered in this article.
the vector based representation of alloy configurations is adopted from the candidate vectors of the korat tool that performs a backtracking search for test generation using imperative predicates.
two techniques implement korat in parallel one technique uses executions of the imperative predicate to distribute the search during backtracking by creating work items for parallel workers and the other technique fast forwards the search to create ranges for parallel exploration without work stealing.
the problems addressed by korat and ranger testing of imperative code and analysis of alloy models respectively as well as the respective partition techniques are quite different.
ranging techniques for symbolic execution and explicit state model checking of imperative programs were introduced recently in the context of the klee symbolic execution tool for c and the jpf model checker for java respectively.
ranging to analyze declarative models in alloy is very different from ranging to analyze imperative programs in c or java.
more precisely ranges in symbolic execution and model checking are based on program execution paths specifically sequences of control flow branches.
such paths do not exist in declarative models.
our technique for ranging for alloy defines a novel form of ranges at the black box input space level not white box control flow level.
vii.
c onclusions and further work this paper introduced a novel technique for scaling alloy s sat based analysis using ranging.
experiments using a variety of hard to solve alloy formulas showed that the technique is very effective especially for valid assertions where the search space needs to be exhausted.
when dealing with difficult invalid assertions except for some situations with particularly low quantities of available hardware counterexamples were always found in a timely fashion.
our work opens a new direction in scaling the analysis of declarative models.
with the increasing availability of multicore and multi processor systems such parallel techniques have a vital role to play in substantially enhacing our ability to develop more reliable software.
our next step is to update the implementation as discussed in section v e so that models can be range partitioned on a wider class of relations.
also the fact that superlinear speedups were obtained implies that some of the gain cannot stem from parallelism but rather from the partitioning itself in some cases merely splitting a problem and solving the resulting subproblems sequentially would have yielded some speedup.
this surprising phenomenon deserves further analysis.
we also plan to explore the application of ranging to other declarative domains such as smt solving as well as deep static checking where the program and its specification are represented together using a formula which captures a violation of the specification by the program for goal directed counterexample generation.156references abad p. aguirre n. bengolea v .
ciolek d. frias m.f.
galeotti j. maibaum t. moscato m. rosner n. vissani i. tight bounds incremental sat better test generation under rich contracts in proceedings of sixth ieee international conference on software testing verification and validation icst .
abrial j. r. .
the b book assigning programs to meanings .
cambridge uk cambridge university press .
alloy analyzer available at biere a. lingeling plingeling picosat and precosat at sat race in solver description special track parallel cnf sat race available at .pdf.
boyapati c. khurshid s. marinov d. korat automated testing based on java predicates.
issta .
cadar c. dunbar d. and engler d. r. klee unassisted and automatic generation of high coverage tests for complex systems programs .
in proc.
8thsymposium on operating systems design and implementation osdi pages .
chrabakh w. and wolski r. gradsat a parallel sat solver for the grid in ucsb computer science technical report number .
dennis g. chang f. jackson d. modular verification of code with sat.
in issta pp.
.
dijkstra e. w. a belated proof of self stabilization distributed computing v ol.
issue pp.
.
dolby j. vaziri m. tip f. finding bugs efficiently with a sat solver in esec fse pp.
acm press .
een n. and s orensson n. an extensible sat solver .
in sat .
funes d. siddiqui j. h. and khurshid s. ranged model checking .
in proc.
java pathfinder workshop jpf .
galeotti j. p. rosner n. l opez pombo c. frias m. f. analysis of invariants for efficient bounded verification .
in proceedings of issta pp.
.
galeotti j. p. rosner n. l opez pombo c. frias m. f. taco efficient sat based bounded verification using symmetry breaking and tight bounds .
ieee transactions on software engineering to appear.
gil l. flores p. and silveira l. m. pmsat a parallel version of minisat journal on satisfiability boolean modeling and computation .
hamadi y .
jabbour s. and sais l manysat a parallel sat solver international journal on satisfiability boolean modeling and computation jsat v olume special issue on parallel sat ios press .
ieee standard for a high performance serial bus available ar jackson d. software abstractions .
mit press .
kang e. jackson d. formal modeling and analysis of a flash filesystem in alloy .
in proceedings of abz lncs springer .
kim j. s. and garlan d. analyzing architectural styles journal of systems and software v ol.
issue elsevier .
leavens g.t.
baker a.l.
and ruby c. jml a notation for detailed design .
in behavioral specifications of businesses and systems chapter pp.
amsterdam kluwer .
leino k. r. m. m ulcer p. using the spec language methodology and tools to write bug free programs manuscript krml september available at marinov d. and khurshid s. testera a novel framework for automated testing of java programs .
in proc.
16th ieee conference on automated software engineering ase .
misailovic s. milicevic a. petrovic n. khurshid s. and marinov d.parallel test generation and execution with korat inproc.
6th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering esec fse .
maoz s. ringert j.o.
and rumpe b.. cd2alloy class diagrams analysis using alloy revisited .
in proceedings of models lncs springer .
object management group.
ocl specification v .
.
.
.
january 1st .
available at ohmura k. and ueda k. c sat a parallel sat solver for clusters in sat lncs .
rosner n. galeotti j. p. berm udez s. marucci blas g. perez de rosso s. pizzagalli l. zem n l. and frias m. f. parallel bounded analysis in code with rich invariants by refinement of field bounds to appear in proceedings of issta pp.
.
rosner n. l opez pombo c. g. aguirre n. jaoua a. mili a. and frias m. f. parallel bounded verification of alloy models by transcoping in proceedings of vstte to appear.
shlyakhter i. generating effective symmetry breaking predicates for search problems .
in proceedings of lics workshop on theory and applications of satisfiability testing june boston ma.
henry kautz and bart selman eds.
electronic notes in discrete mathematics v ol.
.
siddiqui j. h. and khurshid s. pkorat parallel generation of structurally complex test inputs.
2nd international conference on software testing verification and validation icst .
denver co. apr .
siddiqui j. h. and khurshid s. scaling symbolic execution using ranged analysis .
inproc.
27th acm sigplan conference on object oriented programming systems languages and applications oopsla .
shao d. gopinath d. khurshid s. perry d. e. optimizing incremental scope bounded checking with data flow analysis .
issre .
shao d. khurshid s. perry d. e. an incremental approach to scopebounded checking using a lightweight formal method .
fm .
spivey j. m. the z notation a reference manual 2nd ed.
upper saddle river nj prentice hall .
stoica i. and morris r. and liben nowell d. karge d. and kaashoek m. f. and balakrishnan h chord a scalable peer to peer lookup service for internet applications ieee transactions on networking vol.
.
torlak e. jackson d. kodkod a relational model finder .
in tacas lncs pp.
.
visser w. havelund k. brat g. and park s. model checking programs .
inproc.
15th conference on automated software engineering ase grenoble france .
visser w. p as areanu c. s. pel anek r. test input generation for java containers using state matching in issta pp.
.
zave p. compositional binding in network domains .
in proceedings of fm .
lncs springer .