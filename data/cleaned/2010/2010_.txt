incremental symbolic execution for automated test suite maintenance sarmad makhdoom muhammad adeel khan junaid haroon siddiqui department of computer science lums school of science and engineering lahore pakistan junaid.siddiqui lums.edu.pk abstract scaling software analysis techniques based on source code such as symbolic execution and data flow analyses remainsa challenging problem for systematically checking softwaresystems.
in this work we aim to e ciently apply symbolic execution in increments based on versions of code.
ourtechnique is based entirely on dynamic analysis and patchescompletely automated test suites based on the code changes.our key insight is that we can eliminate constraint solvingfor unchanged code by checking constraints using the testsuite of a previous version.
checking constraints is ordersof magnitude faster than solving them.
this is in contrastto previous techniques that rely on inexact static analysis orcache of previously solved constraints.
our technique identi fies ranges of paths each bounded by two concrete tests fromthe previous test suite.
exploring these path ranges coversall paths a ected by code changes up to a given depth bound.our experiments show that incremental symbolic executionbased on dynamic analysis is an order of magnitude fasterthan running complete standard symbolic execution on thenew version of code.
categories and subject descriptors d. .
symbolic execution keywords symbolic execution incremental analysis klee .
introduction symbolic execution is a powerful program analysis technique based on a systematic exploration of bounded pro gram paths which was developed over three decades ago .
a key idea used in symbolic execution is to build path conditions given a path a path condition represents a constraint on the input variables which is a conjunction of the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page.
copyrights for components of this work owned by others than theauthor s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.acm ... .
.
conditions on the path.
thus a solution to a feasible path condition is an input that executes the cor responding path.
a common application of symbolic execu tion is indeed to generate test inputs say to increase codecoverage.
automation of symbolic execution requires con straint solvers or decision procedures that can handlethe classes of constraints in the ensuing path conditions.
a lot of progress has been made during the last decade in constraint solving technology in particular sat andsmt solving.
moreover raw computation power isnow able to support the complexity of solving formulas thatarise in a number of real applications.
these technologi cal advances have fueled the research interest in symbolicexecution which today not only handles constructs of mod ern programming languages and enables traditional analy ses such as test input generation but also hasnon conventional applications for example in checking pro gram equivalence in repairing data structures for errorrecovery and in estimating power consumption .
despite the advances a key limiting factor of symbolic execution remains its inherently complex path based analysis.due to this complex analysis symbolic execution takes sig nificant time and its use becomes impractical for integratingin development work flow.
a key observation however isthat in a development work flow code changes in incrementsand the increments are often very small.
several recent re search projects have attempted to build on this idea.
twoapproaches have been used.
one approach is to use staticanalysis to find di erences in the code flow graph cfg and either prune symbolic execution by eliminating pathsthat will not be changed for sure or use heuristics toguide a manual test suite towards code changes .
theother approach is based on caching previous results of sym bolic analysis so that future runs are faster .
thelater technique does not utilize the information about codechanges directly and relies on the fact that similar code willresult in similar path conditions and hence the solving cangreatly benefit from caching prior results.
this paper presents a novel technique for incremental symbolic execution using a pure dynamic analysis approach with out caching any prior results.
our key insight is that whilesolving path conditions is costly generating and checkingthem is orders of magnitude faster.
instead of performing aninexact static analysis to eliminate generation of path con ditions we generate path conditions and use the prior testsuite to check satisfiability.
the tests are kept in memoryand e ciently divided along di erent paths of exploration program to find middle of three integers 1int mid int x int y int z if x y if y z return y else if x z return z else return x else if x z return x else if y z return z else return y to check against the generated path condition.
storing concrete tests and checking their satisfiability is much more ef ficient than caching path conditions canonicalizing them and comparing them.
paths in changed code do not match any prior tests and have to be fully explored.
the first and last such path de lineate a range that can be explored.
this builds on our previous work on ranged symbolic execution that introduced the concept of ranges of paths to be explored and usedit to enable parallel symbolic execution.
ranged symbolicexecution builds on the insight that the state of a symbolic execution run can rather surprisingly be encoded succinctlyby a test input specifically by the input that executes the last terminating feasible path explored by symbolic execu tion.
by defining a fixed branch exploration ordering e.g.
taking the true branch before taking the false branch at eachnon deterministic branch point during the exploration anoperation already fixed by common implementations of sym bolic execution we have that each test input parti tions the space of bounded paths under symbolic executioninto two sets explored paths and unexplored paths.
moreover the branch exploration ordering defines a linear order among test inputs specifically for any two inputs that donot execute the same path or lead to an infinite loop thebranching structure of the corresponding paths defines whichof the two paths will be explored first by symbolic execution.thus an ordered pair of tests say h 0i defines a range of bounded paths where path 1is executed by and path kis executed by and for i k path i is explored immediately after path i. the encoding allows us to separate out the ranges affected by code changes for incremental symbolic execution.we generate and solve path conditions for all test cases inthis range and generate new tests in the test suite.
for allpaths that have a matching test case from prior version wecopy the old test.
any tests that no longer have a matchingpath get discarded automatically.
this enables a totally au tomated maintenance of symbolic execution generated testsuite.
.
illustrative overview forward symbolic execution is a technique for executing a program on symbolic values .
there are two funda mental aspects of symbolic execution defining semanticsof operations that are originally defined for concrete valuesand maintaining a path condition for the current program path being executed a path condition specifies necessaryconstraints on input variables that must be satisfied to exe cute the corresponding path.
program contains a function that finds the middle of three integer values.
figure shows the execution tree ofx y y z ret y x z ret z ret x x z ret y x z ret z ret x path path path 3path path path figure execution tree of program program modified version of mid shown in program 1int mid int x int y int z if x y if y z return y else if x z return z else return x else if x z return x else if y z return z else return x x y y z ret y x z ret z ret x x z ret x x z ret z ret x path path path 3path path path figure execution tree of program this program and shows the path conditions explored.
thepath conditions for each of these paths can be solved usingo the shelf sat solvers for concrete tests that exercise theparticular path.
for example path can be solved to x y and z .
following are all the six paths explored path l2 l3 path l2 l3 l4path l2 l3 l4 l5path l2 l6path l2 l6 l7path l2 l6 l7 l8 program shows a newer version of the program.
line numbers and are changed in this version of the program.this results in the new execution tree shown in figure .here we can see the changed path conditions.
we need toidentify the change in the execution tree in order to performincremental symbolic execution.
we will use our previouslygenerated test suite to find the di erence in the executiontree.
we start by analyzing the modified tree while maintaining a list of all tests satisfying the current paths.
we startexecution that will first take path in the execution tree.we build the path condition and check against satisfying 272tests.
since this path is unchanged one test from previous suite will be attached to this path without solving it again.any branches that are unsatisfied by any test from previoussuite are discarded.
the second test input will not remainattached to the second path.
the program will take somepath but it won t be the one we discovered last time.
thepath condition would be di erent this time and no test fromprevious suite will validate with it.
we now know a pointwhere path are starting to diverge.
this is the starting pointof our range that we need to re examine for the changes.
we reach the point where an old test takes the same exact path generating the old path condition in the program.in this example that would be the path condition whereprogram will be the same on both versions path .
at thispoint we mark the previous test case as our last point inthe range that is a ected by code modification.
now afterthis analysis we have a range that states that the programis changed from this path condition to next path condition.we will complete symbolic execution only on the area iden tified in the program that will results in new tests.
thesetests are those which were invalidated in the newer ver sion of the program and results in new path conditions.
wethen use the sat solver to evaluate them and add these newvalues to our test suite.
we can safely remove our old testinputs that are invalided in the next run and reuse thosethat are still valid.
.
technique in this section we will discuss our approach to dynamically figure out the areas in the execution tree that aremodified in the newer version of code.
our presentation as sumes a standard bounded depth first symbolic executionwhere path exploration is systematic and for each condi tion the true branch is explored before the false branch.such exploration is standard in commonly used symbolic ex ecution techniques such as generalized symbolic executionusing jpf cute and klee .
in our technique we first symbolically execute the base version of the program which results in generation of a com prehensive test suite by solving the path conditions.
whileexecuting the new version symbolically we use previous testsuite.
while in the process of exploring states we compareand validate each new path condition with the solution wealready have in the test suite of base version.
if we have asuccessful comparison we just add that test case to the newtest suite.
in incremental testing most of the code remainssame so is the execution tree.
comparing new path condi tions with the old tests is less costly than solving the pathcondition for the concrete inputs.
algorithm is used to find and evaluate a ected ranges in the program execution tree.
it splits test suite on eachbranch condition in two sets.
one set contains all those teststhat are satisfiable if that branch evaluated true and otherset contains all those test cases that result in false evaluationof branch condition.
at this point if any of the true or falseside gets no test cases and all tests go on the other sidethen that area was infeasible before and need no furtherexploration.
that is first benefit of using our approach interms of time saving.
if any test case is not satisfiable atthis point we start exploring the program for new pathsuntil some other path in the way matches with our previoustest inputs.algorithm incrementalexplore to explore new ranges and not solving the present path conditions inthe new program input a finite set te s t su i t e t1 t2 ... t n of test cases 1foreach bi nb r a n c h c o n d i t i o n do ttrue split te s t su i t e b tfalse split te s t su i t e b tinvalid te s t su i t e ttrue tfalse iftinvalid6 then ifttrue then exploreandsolve ttrue incrementalexplore tfalse iftfalse then exploreandsolve tfalse incrementalexplore ttrue else incrementalexplore ttrue incrementalexplore tfalse t t2 t3 ... t n figure execution tree of new program without execution we will discuss it with the help of an example.
figure shows the execution tree of new version of the program whichis unknown to the executor before starting execution.
wegive test cases to the executor before it start exploring thecode.
on each branching node it will split the test suite intotwo possible subsets where one set belongs to the left side ofthe tree and other belongs to the right side.
on each branchwe also validate the test inputs to see whether they are stillsatisfiable or not.
in order to understand the concept of finding ranges in the program lets say one of the test cases reaches the leafnode in the execution tree as shown in figure .
we com pare and validate this test case and lets say it turns outto be successfully validated.
we then move to the next testcase from the test suite while executing the next test casewe discover that next test case is not validating.
these val idations fail due to change in the path conditions and theexecution tree.
we mark this test case as the start of ourrange range which needs to be explored for new test inputs.
we keep on testing the program until all other test cases either fail or we do not find any path in the exploration thatmatches with the one we already have.
lets say in figure we come across a test case which successfully validates withthe current path condition.
this is the point where we endour range.
so our range starts from the left most test caseto the last valid test case as shown in figure .
that rangewould have all the new states that need to be explored.
and t t2 t3 ... t n t t2 t3 t4 t5 t t2 t3 t t2 t figure execution tree of new program with one valid test reaching the leaf t1 t2 t3 ... t n t1 t2 t3 t4 t5 t1 t2 t3 t1 t2 t1 t10 t11 t12 t13 t10 t11 t10 t10 figure range for modified execution tree with two bounded test cases any tests present in this area should be solved with the solver for concrete inputs.
these tests are added to the new testsuite because either they were not present or they were in validated.
we can get such multiple ranges in the execution tree of modified program.
as we have already stated that thesymbolic execution for incremental testing is in order whileexploring the program state space so these ranges would benon overlapping and we can safely run them in parallel onmultiple machines to achieve more speed up for incrementaltesting.
we modified state of the art tool klee that operates on the llvm bit code for our implementation of ourtechnique.
klee takes llvm bit code performs symbolicanalysis and produces test cases along with their path con dition files.
test cases generated by the klee contains theactual values to use for symbolic data in order to reproducethe path that klee followed.
these can be used for obtain ing code coverage as well as for reproducing the bugs.
weused these test inputs called seeds generated by klee asan input test suite to the new program.
if we execute klee by providing seeds it stores them in hash maps.
while executing a program symbolically it takesall these seeds side by side.
on every branching conditionin the program it divides the seeds for both branches.
anynumber of seeds that belong to the true side of the branch areassociated with it and vice versa.
on each step it removesthose seeds that are no longer validating with current stateof the program.
a branch is considered infeasible if all seedsgo on the other side.
we took advantage of this seeding system in klee to implement our incremental technique.
for every branch seedsare compared and divided.
if all seeds are validated itmeans there is no change in the program.
but if any seedfails to validate it marks our starting point of the range.we start exploring for new states from that point until wefind some other seed in the way that was present before andstill validating.
we modified klee so that instead of justchecking and moving forward when seeds are supplied whensome seeds fail to validate it starts exploring the programfurther.
we then make new path conditions and solve themin the end for concrete values.
these new path conditionsand concrete values are added to the new test suite of theprogram so that they can serve as seeds for the next incre mental run.
comparing and validating the seeds are very easy processes because klee uses hashes for seeds as well as theprogram states so comparisons would not take much of thecomputing powers.
to validate a seed it just make sure thatprevious input values for the test case still satisfy the currentpath condition.
this is also not a very cpu intensive job ascompared to finding new values by giving path conditionsto the solver.
.
evaluation to evaluate incremental symbolic execution we used the gnu core utilities1 the basic file shell and text manipulation core utilities for gnu operating system.
coreutils aremedium sized programs between lines of code.some of these program performs basic tasks with lot of er ror checks and thus forms a deep search tree while otherperforms multiple functions and form a broad search tree.moreover because these are included in the every gnu op erating systems and they evolve much during the passage oftime.
we have much iteration available that are the resultsof bug fixes and feature improvements.
coreutils were also used in the evaluation of the klee symbolic execution tool.
as we build incremental symbolicexecution using klee coreutils provide a good benchmarkfor comparison with klee.
we ran klee on all coreutils for one hour and chose the utilities for which klee covered maximum pathsin this time.
we chose version .
as the base version ofthe coreutils and then incrementally test one minor updaterelease that is version .
.
figure shows a plot of the execution time of all utilities with and without using our incremental approach onversion .
in incremental seeds of version .
were used .time taken for each utility with incremental approach isshown as squares in the plot while time taken without usingincremental approach is shown as circles.
our incrementalapproach is about faster and we are saving about solver time by giving less queries.
in regular symbolic execution major portion of time is consumed at the solver side where it finds the solution ofthe path condition.
in our approach we are reducing thenumber of queries sent to the solver.
large number of testcases are reused in the process of building new test suite.only few test cases were solved for concrete inputs usingsolver.
these calls are very less in the incremental testing.this reduced number of calls to the solver is the cause oftime saving in the incremental testing.
.
related work clarke and king pioneered traditional symbolic execution for imperative programs with primitive types.
sym bolic execution guided by concrete inputs has been a topic ofextensive investigation during the last seven years.
dart combines concrete and symbolic execution to collect the 274arch base64 basename cat chcon chgrp chmod chown chroot cksum comm csplit cut date dd dircolors dirname du echo env expand expr factor false fmt fold getlimits groups head hostid hostname id join kill link ln logname mkdir mkfifo mknod mktemp nice nohup od paste pathchk pinky pr printenv printf ptx pwd readlink rmdir seq setuidgid sha1sum shuf sleep split stat stty su sum sync tac tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users wc who whoami yes05001 000execution time sec without incremental with incremental figure execution time of program from gnu coreutils suite of unix utilities version .
using incremental and non incremental approach.
square boxes show the time for symbolic execution time by usingincremental testing providing seeds from version .
.
circle shows the execution time of version .
withoutusing incremental technique.
branch conditions along the execution path.
dart negates the last branch condition to construct a new path condi tion that can drive the function to execute on another path.dart focuses only on path conditions involving integers.cute extends dart to handle constraints on refer ences.
egt and exe also use the negation of branchpredicates and symbolic execution to generate test cases.they increase the precision of symbolic pointer analysis tohandle pointer arithmetic and bit level memory locations.klee is the most recent tool from the egt exe fam ily.
klee is open sourced and has been used by a varietyof users in academia and industry.
klee works on llvmbyte code .
it works on unmodified programs written inc c and has been shown to work for many o the shelf programs.
ranged symbolic execution uses klee as an en abling technology.
.
incremental symbolic execution based on static analysis directed incremental symbolic execution leverages differences among program versions to optimize symbolic ex ecution of a ected paths that may exhibit modified behavior.
the basic motivation is to avoid symbolically executingpaths that have already been explored in a previous programversion that was symbolically executed.
a reachability anal ysis is used to identify a ected locations which guide thesymbolic exploration.
directed incremental symbolic execution dise uses static analysis to find the code blocks that are e ected by a change and then uses this information in dynamic analysisto prune the execution tree for symbolic execution.
diseonly generate a ected path conditions because it preforms symbolic execution after statically analyzing the both pro grams cfgs.
if a user wants a complete test suite usingdise he she needs to check what path conditions get obso lete which is not clear how to do.
our proposed techniqueuses dynamic analysis alone.
the range for symbolic exe cution is formed by validating path conditions generated bya previous execution.
the benefit of a pure dynamic tech nique is that we can estimate more accurately whereas diseto over estimate the e ect of a change.katch combines static and dynamic analysis for increased coverage of software patches.
katch uses heuristicsbasic on static analysis to select tests from a manual testsuite that are most likely to hit modified code and then ituses heuristics based on dynamic analysis to change the testinputs to increase chances of hitting modified code.
thedynamic analysis is built upon symbolic execution.
sincethe problem of code reachability is undecidable in general katch hopes that the heuristics will lead to modified code inmost cases.
our idea of incremental symbolic execution doesnot depend a manual test suite and instead does boundedexhaustive symbolic execution.
our claim is that if the faultcan be found using standard symbolic execution we will beable to find it in less time.
or in other words our incre mental symbolic execution can explore the program up to adeeper depth bound in the same time due to the time savedby incremental execution.
.
incremental symbolic execution based on caching solutions to path constraints green is a cache for storing path conditions and their solutions.
in green caching technique they slice the pathcondition for the purpose of reducing it to be checked forsatisfiability then they perform heuristic based canoniza tion to maximize the chance of finding matches with otherpath conditions and lastly they store this form in the store.on finding matches they server the results from their storeinstead of calling the solver.
while green is not an incre mental symbolic execution tool in itself it enables more e cient checking in incremental situations.
the reason of thatbenefit is that in an incremental setting many path condi tions will match from the last execution and thus the solvingcan be avoided.
path conditions are complex structures andeven though green canonicalizes them it requires some workto compare them and map the variables.
as the cache sizeincreases comparing becomes more di cult.
validating a path condition on the other hand is a quick operation andrequires no lookup.
green is therefore also orthogonal toour work and can be combined such that our technique finda ected ranges using validation and then a given range isexecuted using green such that any path conditions thathave occurred before need not be solved.
275memoized symbolic execution re uses results of a previous run of symbolic execution by storing them in a triebased data structure and re using them by maintaining andupdating the trie in the next run of symbolic execution onthe modified program.
the savings achieved by memoisefor regression analysis relies on the position of the change and may vary quite a lot between various kinds of changes.we believe our technique is more e ective due to low cost ofstoring concrete tests versus storing and comparing symbolicexecution results in tries.
.
conclusion in this work we showed how to scale symbolic execution for e ciently analyzing program increments.
the key nov elty of our work is to apply symbolic execution in incrementswith only dynamic analysis.
our approach does not use anyform of static analysis or caching of previous results for com pletely automated incremental testing.
the key idea of our technique is that we can use previously generated test cases for identification of code changesin the new version.
checking constraints is easy comparedto solving them.
as an enabling technology we leveragedthe open source tool klee a state of art tool for sym bolic execution.
experimental results using gnu coreutilsshow that our approach provides a significant speedup forincremental testing.
incremental execution finished in less time by giving less queries to the solver for pro grams.
.