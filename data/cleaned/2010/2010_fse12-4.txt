rubicon bounded verification of web applications joseph p .
near daniel jackson computer science and artificial intelligence lab massachusetts institute of technology cambridge ma usa jnear dnj csail.mit.edu abstract we present rubicon an application of lightweight formal methods to web programming.
rubicon provides an embedded domain speci c language for writing formal speci cations of web applications and performs automatic bounded checking that those speci cations hold.
rubicon s language is based on the rspec testing framework and is designed to be both powerful and familiar to programmers experienced in testing.
rubicon s analysis leverages the standard ruby interpreter to perform symbolic execution generating verication conditions that rubicon discharges using the alloy analyzer.
we have tested rubicon s scalability on ve realworld applications and found a previously unknown security bug in fat free crm a popular customer relationship management system.
keywords formal methods programming languages web programming .
introduction web applications have experienced explosive growth over recent years.
testing methodologies for web applications are beginning to catch up but despite their utility in building correct programs there has been as yet little use of formal methods in the domain.
this paper introduces rubicon an application of lightweight formal methods to web programming.
rubicon allows programmers to write speci cations of the behavior of their web application and performs automatic bounded analysis to check those speci cations against the implementation.
rubicon aims to be both powerful and easy to use its speci cation language is expressive but based on a domain speci c language for testing.
rubicon is implemented as a library for the ruby programming language and targets applications written using the popular rails web programming framework.
rubicon s spec i cation language is an extension of the ruby based rspec domain speci c language for testing rubicon adds the quanti ers of rst order logic allowing programmers to replace rspec tests over a set of mock objects with general speci cations over all objects.
this compatibility with the existing rspec language makes it easy for programmers already familiar with testing to write speci cations and to convert existing rspec tests into speci cations.
rubicon s automated analysis comprises two parts rst rubicon generates veri cation conditions based on speci cations second rubicon invokes a constraint solver to check those conditions.
the rubicon library modi es the environment so that executing a speci cation performs symbolic execution producing veri cation conditions rather than values.
to check the veri cation conditions rubicon currently compiles them into alloy a lightweight speci cation language for software design for analysis using the alloy analyzer a fully automatic bounded analysis engine for alloy.
alloy s relational language is convenient because its semantics closely match those of relational databases but in principle an unbounded smt solver or theorem prover could be used in place of alloy.
we tested rubicon s performance on ve open source web applications for which the original developers have written rspec tests.
we took a random sample of these tests and converted them into rubicon speci cations in every case rubicon s analysis took no more than a few seconds per speci cation.
in the largest of these applications a customer relationship management system called fat free crm rubicon s analysis uncovered a previously unknown security bug.
the authors of fat free crm have acknowledged this bug and are preparing a x. we have released rubicon under the terms of the gpl at .
the contributions of this paper include rubicon a domain speci c language for expressing speci cations of web applications a scalable automatic symbolic execution based bounded checker for rubicon speci cations an evaluation of rubicon on ve applications and the discovery of a previously unknown security bug.1describe userscontroller do it should expose the requested user as user and render template do user factory user get show id user.id assigns .
should user response.should render template users show end 8end describe contactscontroller do it should redirect to contact index if the contact is protected do private factory contact user factory user access private get show id private.id ash .
should not nil response.should redirect to contacts path end 17end figure rspec tests for displaying users and restricting access to private contacts .
the rubicon language rubicon provides an embedded domain speci c language for writing speci cations.
this language is based on rspec a testing framework for the ruby language whose goal is to make testing easier and more useful and that has made testdriven design popular amongst ruby programmers.
rspec tests are concise avoid repetition and resemble english speci cations of application features.
the framework also encourages programmers to write documentation for each test by providing elds for that documentation and using it to generate error reports when tests fail.
the rubicon language is designed for writing speci cations of rails applications.
rails is the most popular web programming framework for ruby and was designed speci cally to allow testing with rspec.
the integration of rails with rspec means that test driven development is just as popular in the rails community as it is in the larger ruby community and many open source rails applications are shipped with large rspec test suites.
.
the rspec approach to introduce the style of testing promoted by the rspec library we take the open source rails application fat free crm1as a case study.
fat free crm is a customer relationship management system designed to be used to build customized crm systems for use in organizations.
development of fat free crm began in and the software is currently maintained by michael dvorkin and nathan broadbent.
fat free crm is released under the agpl its codebase comprises 23kloc but is reasonably simple to understand and the developers have written more than rspec tests.
figure contains two examples of rspec tests from the fat crm codebase.
the rst lines is intended to test that the show action correctly displays summaries of the site s users.
what it actually tests is that a particular user created by the call to the factory is displayed.
the test begins with a natural language speci cation of the feature under test line the body of the test lines is ruby code written in the rspec domain speci c language.
this particular test constructs a mock object representing a single user line requests the summary page for that user line and then checks that the user that will be displayed matches the mock object just created line .
this check is written as an rspec assertion the general form of which is a.should p b where aand bare objects and pis a predicate describing the desired relationship between them.
the assigns variable is actually a ruby hash populated by the rails framework to contain the names and values of the instance variables set by the page request in line .
the second test lines is intended to check that private contacts are never displayed to users other than their owners.
what it actually tests is that a particular private contact is hidden from a particular user.
the test begins by building a mock object for the private contact owned by a mock user line .
the test then attempts to display the private contact line .
since the mock user created as the owner of the contact in line is by default distinct from the mock user representing the currently logged in user this request should fail.
the test checks that it does indeed fail by asserting that the value of ash which displays site errors is populated line and that the user should be redirected to the index of contacts line .
the example tests in figure check the desired properties in only a single case they may easily miss corner cases that the programmer does not anticipate.
for example the second test passes but the intended property that the show action in the contacts controller preserves permissions is actually false!
in fact displaying a contact also causes a summary of the associated opportunities to be displayed these opportunities also have associated user permissions.
the test either ignores the fact that opportunities will be displayed or assumes that the permissions on these opportunities will match those on the corresponding contact.
if they do not a user may be allowed to see another user s private opportunity.
this is an example of a corner case that is unlikely to be caught by testing alone since testing requires the programmer to specify exactly one case to test and the programmer is likely to test only the case in which the permissions match.
.
adding quantifiers rubicon allows programmers to write speci cations for web applications by extending the rspec language with the quanti ers of rst order logic.
rather than testing just a single case for compliance with the application s speci cation rubicon performs symbolic execution for a truly arbitrary case generates veri cation conditions that cover allpossible cases and uses an automatic bounded veri er to check them.
rubicon introduces two new methods on objects forall and exists which represent the universal and existential quantiers of rst order logic.
both methods accept a single argu specfile describe class do spec end spec it string do expr end expr ruby expression j object .
forall dojxj expr end j object .exists dojxj expr end j class .
forall dojxj expr end j class .exists dojxj expr end j expr .implies do expr end j object .should equal expr j object .should notequal expr j object .should pred expr j object .should not pred expr pred jbe j include j raise jthrow jrespond to jhave figure syntax of rubicon speci cations 1describe userscontroller do it should expose the requested user as user and render template do user.forall dojuserj get show id user.id assigns .
should user response.should render template users show end end 9end describe contactscontroller do it should redirect to contact index if the contact is protected do user.forall dojuserj contact.forall dojprivatej setcurrent user user get show id private.id private.access private private.user !
user .implies do ash .
should not nil response.should redirect to contacts path end end end end 25end figure rubicon speci cations for displaying users and restricting access to private contactsment a ruby block representing the property over which the quanti er ranges quanti ers succeed or fail in the same way as other rspec tests.
figure speci es the core syntax of rubicon speci cations.
rubicon s syntax is exactly that of rspec with the addition of quanti ers.
a set of rubicon speci cations begins with a describe block specifying the class being speci ed each individual speci cation is written inside an itblock with a string documenting that speci cation.
a speci cation is simply a sequence of expressions each of which may be a standard ruby expression or a rubicon assertion.
a quanti er is also an assertion a.forall dojxjb end means that the assertions inbshould hold for all possible values of xfrom the set a and a.exists dojxjb end means that the assertions in b should hold for at least one value of xfrom a. figure presents rubicon versions of the rspec tests from figure .
this speci cation for displaying users lines quanti es over allusers rather than testing the intended property for just a single user.
the block passed to the forall method is precisely the code we wrote in the original test only the underlined code has changed re ecting the introduction of quanti ed variables in place of mock objects.
the speci cation for restricting access to private contacts lines changes only slightly more.
in order to check that permissions are preserved no matter which user is logged in we quantify over users line and then set the loggedin user correspondingly line .
to express the class of contacts for which the property should hold we introduce a logical implication lines whose left hand side requires that the contact s access should be set to private and that its owner should be distinct from the logged in user.
.
the power of specification by writing full speci cations of application behavior programmers can catch errors that tests alone are unlikely to nd.
rubicon s automated analysis of formal speci cations can explore corner cases check for general regression errors and build complicated object hierarchies for testing areas in which standard rspec tests fall short.
moreover rubicon speci cations are often more concise than the rspec tests they replace since the programmer may replace complicated code for constructing mock objects with simpler quanti ers.
the previously mentioned fault involving the permissions on opportunities associated with contacts for example is unlikely to be caught in testing since its discovery requires the speci c situation in which the user in question has permission to view a particular contact but does nothave permission to view the associated opportunity.
because mock objects must take concrete values a programmer will tend to construct mock objects that represent the most common situation in this case one in which the permissions on the contact and its associated opportunities match.
in writing speci cations on the other hand the tendency is to provide as little information as possible so as to have the highest chance of discovering corner cases that were not considered by the programmer.
the rubicon speci cation in figure checks the property that permissions are actually respected when displaying a contact.
the speci cation1describe contactscontroller do it should not display other users private contacts or opportunities do user.
forall dojuj contact.
forall dojcj opportunity.
forall dojoj setcurrent user u get show id c.id c. access private c. user !
u .
implies do assigns .
should not c end o. access private o.user !
u .
implies do assigns .
opportunities should not include o end end end end end 23end figure rubicon speci cation for displaying contacts quanti es over users contacts and opportunities lines sets the current user to the quanti ed one line and requests the contact display page line .
the speci cation then checks two properties rst that for any contact if that contact s permissions are set to private and its contact s owner is not the current user then that contact should not be displayed lines and second that for anyopportunity if that opportunity s permissions are set to private and its owner is not the current user then that opportunity should notbe included in the list of opportunities to be displayed lines .
this speci cation makes no assumptions about any properties of the contact and opportunities in question most importantly it does not rule out the case that the requested contact is public but one of the associated opportunities is private and not owned by the current user.
indeed rubicon catches this case immediately returning the following counterexample for the second property u userf id ...g c contactf access public user u opportunities ...g o opportunityf access private user user1 ...g this counterexample represents the case in which the current user owns the contact being displayed but does notown the opportunity associated with that contact.
even though that opportunity is private it will be displayed to the user.
the blame for this fault lies in the assumption made in1describe contactscontroller do it should be able to associate newly created contact with the opportunity do opportunity factory opportunity id contact factory.build contact contact.stub !
new .and return contact xhr post create contact f rst name billy g account fg opportunity assigns contact .
opportunities .should include opportunity response.should render template contacts create end 11end figure rspec test for contact creation 1describe contactscontroller do it should not associate another user s private opportunity with newly created contact do user.
forall dojuserj contact.
forall dojcontactj opportunity.
forall dojopportunityj setcurrent user user xhr post create contact contact.attributes opportunity opportunity.id opportunity .
user !
user opportunity .
access private .
implies do assigns .
opportunities .should not include opportunity end end end end end 17end figure rubicon speci cation for contact creation theshow action of the contacts controller that the permissions and ownership of a contact and its opportunities will be identical.
the show method uses the mymethod of the contact class to determine which contact to display the developers of fat free crm have rede ned the mymethod elsewhere so as to return only those records that the current user has permission to view.
referencing a particular contact s opportunities eld however accesses the associated opportunities directly bypassing the rede ned mymethod and ignoring the opportunities permissions settings.
if a user has permission to display a contact then he or she will be able to access all of its associated opportunities regardless of their permission settings.
.
exploiting the bug the corner case discovered in the previous section only quali es as a serious security bug if it is possible to exploit it.
the exploit described in the counterexample requires an in variant on the database to be broken that the permissions of all the opportunities associated with a particular contact are compatible with the permissions on that contact.
rubicon can help us again this time in checking whether or not it is possible to create a new contact that violates the invariant.
invariants can be checked the same way using tests but the contrived nature of test cases makes this strategy less useful than might be hoped run time assertions checking for invariant violations are therefore much more popular.
figure contains the rspec test written by the fat free crm developers to check that the invariant is preserved.
as usual this test uses mock objects lines to construct the common case one with the default permissions creates a new contact line and tests that the opportunity is correctly associated with the contact line .
the corresponding rubicon speci cation figure on the other hand quanti es over all users contacts and opportunities lines constructs a new contact associated with the quanti ed opportunity line and checks that if the opportunity is private and not owned by the current user then it should not be included in the resulting contact s set of associated opportunities lines in other words it should be impossible to create a contact that violates the invariant.
once again rubicon s analysis yields a counterexample informing us that it is indeed possible to violate the invariant user userf id ...g contact contact f opportunities ...g opportunity opportunity f access private user user1g investigating the code for the create action in the contacts controller we found that the code that looks up the attached opportunity uses the nd method rather than the permission enforcing mymethod to nd the opportunity whose id is referenced in the html form submitted by the user.
exploiting this security bug then is as easy as submitting a contact creation request with the id of another user s opportunity in the opportunity id html eld.
the developers of fat free crm have acknowledged the bug and are working on a x. .
the rubicon analysis rubicon is implemented as a library on top of ruby rspec and rails.
it extracts veri cation conditions from speci cations by using the standard ruby interpreter to perform symbolic rather than concrete execution instead of concrete values this style of execution produces abstract syntax trees representing the appropriate veri cation conditions.
rubicon then compiles the veri cation conditions into an alloy a lightweight speci cation language for software engineering and performs bounded analysis using the alloy analyzer.e obj.
forall b x e b. call x e obj.
exists b x e b. call x e obj.should p e e obj.p e e obj.should not p e e obj.p e e e rubyinterpreter e figure semantics of rubicon speci cations c obj.
forall b all x c b. call x c obj.
exists b some x c b. call x x is a new symbolic object c obj.should p e call should c obj c p c e c obj.
attribute eld ref c obj c args c obj.meth args call meth c obj c args c obj.where e query v obj c e if obj is symbolic c e rubyinterpreter e if e is concrete figure compiling speci cations to abstract syntax trees .
rubicon s semantics rubicon s semantics are intended to match those of ruby precisely and to combine ruby s semantics in a natural way with the standard semantics of the quanti ers of rst order logic.
figure contains an informal summary of rubicon s semantics using the standard quanti er symbols and a function representing the semantics of the standard ruby interpreter rubyinterpreter .
given standard quanti cation over ruby values we can represent rubicon s basic assertions should and should not by simply invoking the predicate on the object in question a true result means that the assertion holds.
it is the goal of rubicon s implementation to implement these semantics faithfully.
.
rubicon s implementation to implement the semantics in figure rubicon transforms speci cations into veri cation conditions represented as abstract syntax trees and checks those conditions using a constraint solver.
figure summarizes that transformation the transformation is based on the use of symbolic objects de ned by the rubicon library to represent quanti ed variables.
to avoid re implementing the ruby interpreter rubicon implements the transformation from figure by persuading the standard ruby interpreter to perform symbolic execution.
rubicon accomplishes this by de ning symbolic objects in such a way that all method invocations on symbolic objects yield abstract syntax trees rather than values.
since speci cations necessarily refer to symbolic objects if they use quanti ers rubicon can use the results of running code with symbolic objects to build abstract syntax trees representing veri cation conditions for the speci cation.
this strategy works especially well for web applications for two reasons rst the database schema of a web application speci es exactly the set of possible symbolic objects figure comparison between rspec execution and rubicon analysis and second web applications typically move much of the application s logic into the database so the remaining code has few branches.
these two facts lend our approach its scalability by limiting the number of symbolic objects we perform as much execution as possible over concrete objects using the standard ruby interpreter and reduce the size of the resulting veri cation conditions and because the code contains few branches the branch explosion problem that typically plagues symbolic execution does not occur.
a diagram comparing rubicon s execution model to that of rspec is presented in figure .
rubicon s analysis proceeds in three parts rst the rubicon library stubs the standard libraries and activerecord objects second rubicon runs the speci cation body in the standard ruby interpreter producing veri cation conditions and nally rubicon compiles those veri cation conditions for the alloy analyzer to check.
.
preprocessing stubbing objects rails uses the activerecord class as the basis for its objectrelational mapper.
in a standard rails application every object to be stored in the database is descended from activerecord.
to determine the set of classes that should be represented by symbolic objects then rubicon builds a list of all the classes descended from activerecord.
the next step is to stub those classes replacing them with new classes that respond the same way to the operations dened on them but with di erent behavior.
rubicon takes each activerecord class and rede nes two basic types of methods class methods that query the database and instance methods that allow the programmer to get and set the attributes values to be stored in the database of an object representing a particular record in the database.
for example the call user.all returns a list of all users and given a user object user.id returns that user s id number.
rubicon rede nes these methods to produce abstract syntax trees rather than values user.all returns expr call all user and user.all returns expr field ref user id .
the classes that de ne abstract syntax trees are de ned so that methods invoked on them produce new trees re ectingt all x e allx typeof x jt e t some x e some x typeof x jt e t eld ref obj f t obj .
f t call include obj a t obj int a t call obj a t obj t a t query name type e f name typejt e g t call should obj p a t call p obj a t v v figure compiling abstract syntax trees to alloy speci cations these operations and the should method for building assertions is also rede ned to produce abstract syntax trees.
as a result the following ruby expression 1user1.
id .should user2.id evaluates to the following abstract syntax tree instead of a value expr callrepresents the constructor of an abstract syntax tree node 1expr call should expr field ref user1 id expr field ref user2 id having prepared the environment this way running rubicon speci cation code in the standard ruby interpreter yields abstract syntax trees representing veri cation conditions.
.
postprocessing producing alloy specifications all that remains is to translate veri cation conditions into alloy speci cations.
since our abstract syntax trees are designed for this purpose so is straightforward.
we summarize the translation in figure .
the alloy language includes all of rst order relational logic plus transitive closure.
quanti ers therefore are translated into their analogues in alloy eld