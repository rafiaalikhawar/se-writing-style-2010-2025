computing repair trees for resolving inconsistencies in design models alexander reder johannes kepler university linz austria alexander.reder jku.atalexander egyed johannes kepler university linz austria alexander.egyed jku.at abstract resolving inconsistencies in software models is a complex task because the number of repairs grows exponentially.
existing approaches thus emphasize on selected repairs only but so diminishes their usefulness.
this paper copes with the large number of repairs by focusing on what caused an inconsistency and presenting repairs as a linearly growi ng repair tree.
the cause is computed by examining the runtime evaluation of the inconsistency to understand where and why it failed.
the individual changes that make up repairs are then modeled in a repair tree as alternatives and se quences reflecting the syntactic structure of the inconsist ent design rule.
the approach is automated and tool supported.
its scalability was empirically evaluated on uml models and ocl design rules where we show that the approach computes repair trees in milliseconds on average.
we believ e that the approach is applicable to arbitrary modeling and constraint languages.
categories and subject descriptors d. .
design tools and techniques general terms design performance keywords inconsistency management repairing inconsistencies .
introduction state of the art on inconsistency management in modelbased software development has focused on detecting inconsistencies .
today many approaches are available and they detect inconsistencies fast and correctly .
while it is important to allow inconsistencies they mus t be resolved eventually.
unfortunately repairing inconsi stencies is much harder than detecting them because the number permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.of alternatives grows exponentially with the complexity of the design rule and the number of model elements accessed.
existing approaches either ignore the exponential growth or emphasize on selected repairs only .
yet other approaches pose limitations on the consistency language or focus on individual inconsistencies .
all these limitations are problematic because the designer must ulti mately choose and the generated repairs either overwhelm the designer or may fail to include the one the designer wants.
since the repair of inconsistencies goes hand in hand with the creative process of modeling we strongly advocate against heuristics that replace the role of the human designer.
for example a repair that favors the fewest model changes is frequently the same as an undo.
our approach combines the structure of design rules as in xlinkit the design rule s expected and observed validation results in part through observing the rule s va lidation as in and basic facts about the meta model types of fields non changeable model elements to filter impossible changes.
the structure is important for understanding the inconsistency and enumerating repair alterna tives.
for example if an inconsistent rule s structure requires a b true then there are three repair alternatives as generated by xlinkit repair a repair b or repair a andb.
this list appears reasonable however it may contain incorrect repair alternatives and non minimal repair acti ons.
for example if bis true already then repair bis incorrect because it would repair something that is not broken and repair aandbis non minimal because it would repair more than necessary.
of course repair amay inadvertently break bwhich is a side effect and also detectable by our approach.
by eliminating false and non minimal repairs the approach vastly reduces the number of repair alternatives ho wever not necessarily the exponential growth.
this paper thus also introduces repair trees.
a repair tree organizes the repair actions in a hierarchical manner that reflects the structure of the design rule.
the repair tree is thus intuitive to understand and more significantly the repair tree repair actions grows linearly with design rule complexit y expressions that must be validated .
the main contribution of this paper is a fully automated tool supported scalable approach for generating a complet e set of repair alternatives where each alternative consist s of sequences of model changes repair actions that are needed to resolve the inconsistency.
typically there exist many alternatives for repairing inconsistencies however the se alternatives strongly overlap in the model changes repair ac tions they require.
enumerating all repair alternatives i spermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
trivial in principle however it results in a large number o f alternatives too many for human consumption.
the repair tree computed by our approach focuses on repair actions on the part of the model that caused the inconsistency and organizes those repair actions in a hierarchical manner to hel p the designer decide how to repair the model.
its correctness and scalability was validated on mostly industrial models.
the approach was designed to apply to arbitrary modeling language our focus on three quite distinct types of uml diagrams supports this since these diagrams are often considered separate modeling languages and constrain t languages.
the remainder of this paper is organized as follows.
section defines the basic terms that are used in this paper and section illustrates the main idea.
the approach is discussed in section and validated in section .
section gives an overview of related work and section concludes this paper with an outlook on future work.
.
definitions this section provides some basic definitions definition .amodel represents the software system that must be implemented.
it consists of model elements which contain properties e. g. a name or a reference to other model elements.
adesign rule defines a requirement that the model must fulfill.
the requirement is expressed as a condition that evaluates to true consistent or false inconsistent .
a d esign rule is written for a specific context that can be a single model element the design rule will be validated once or a type of model element the design will be validated for each instance of this model element type in the model .
design rule an bracketle tcontext condition an bracketri ht condition context true false definition .a design rule condition consists of a set of hierarchical ordered expressions where each expression co nsists of an operation o a set of to arguments an expected and a validated result .
the arguments of an expression are also expressions forming a tree analogous to that of programming languages.
an expression has exactly one parent except for the root expression 0 but as many child expressions as there are arguments.
condition n uniondisplay i 0 i braceleftbigg i j j i. ifj i ne ationslash j i j j i. if j i ne ationslash j an bracketle to an bracketri ht definition .arepair action defines a change of a model element property that resolves an inconsistency in part or full often multiple repair actions are needed to resolve an inconsistency .
a repair action contains the type o f change the model element and the model element property that is affected by a change.
the following types of changes are possible add adds a model element delete deletes a model element or modify modifies a model element property .
an bracketle t an bracketri ht add delete modify switch light turn on deactivates switch l light activate deactivate figure inconsistent uml class and sequence diagram for a light switch definition .arepair tree r is a hierarchical ordered set of repair actions for a single inconsistency.
the nodes of a repair tree define whether the underlying repair actions are alternatives or sequences .
.
illustration and problem to illustrate an inconsistency figure introduces a small uml model.
the model consists of a class diagram containing a switch and a light class.
the sequence diagram reveals that the switch calls activate and deactivate on the light to turn on or turn off the light.
design rule is an example of a non trivial uml design rule.
it validates whether a given message in a sequence diagram matches the direction of the class association .
and whether that class has an operation that matches the message name .
.
design rules are typically written from the perspective of a context element.
in the case of design rule the context is the uml type message .
message m l1 m.receiveevent.covered l2 m.sendevent.covered a l2.represents.type.ownedattribute a ne ationslash null a.type l1.represents.type .
l m.receiveevent.covered o l.represents.type.ownedoperation o.name m.name .
the condition of design rule is a boolean expression that is validated on the design model.
the rule reveals the sequence in which model elements are accessed and the specific properties are used.
for example rule is a conjunctio n with the first argument being an universal quantifier and the second argument an existential quantifier .
the universal quantifier iterates over a set of lifelines l. these lifelines are found by first validating the receiveevent p roperty of the message m which