flowtwist efficient context sensitive inside out taint analysis for large codebases johannes lerch1 ben hermann1 eric bodden1 2and mira mezini1 1technische universit t darmstadt 2fraunhofer sit darmstadt germany lastname cs.tu darmstadt.de abstract over the past years widely used platforms such as the java class library have been under constant attack through vulnerabilities that involve a combination of two taint analysis problems an integrity problem allowing attackers to trigger sensitive operations within the platform and a con dentiality problem allowing the attacker to retrieve sensitive information or pointers from the results of those operations.
while existing static taint analyses are good at solving either of those problems we show that they scale prohibitively badly when being applied to situations that require the exploitation of both an integrity and con dentiality problem in combination.
the main problem is the huge attack surface of libraries such as the java class library which exposes thousands of methods potentially controllable by an attacker.
in this work we thus present flowtwist a novel taintanalysis approach that works inside out i.e.
tracks data ows from potentially vulnerable calls to the outer level of the api which the attacker might control.
this inside out analysis requires a careful context sensitive coordination of both a backward and a forward taint analysis.
in this work we expose a design of the analysis approach based on the ifds algorithm and explain several extensions to ifds that enable not only this coordination but also a helpful reporting of error situations to security analysts.
experiments with the java class library show that while a simple forward taint analysis approach does not scale even with much machine power flowtwist s algorithm is able to fully analyze the library within minutes.
categories and subject descriptors f. .
semantics of programming languages program analysis general terms design languages performance security keywords taint analysis confused deputy ifds permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction static taint analyses constitute an important class of static program analyses that track data to check whether it can ow from given sources to given sinks.
taint analyses are used to address integrity or con dentiality problems.
when using the analysis for an integrity problem sources are inputs that are controllable by an attacker and sinks are functions that perform sensitive operations.
for con dentiality problems sources are functions that may leak private data and sinks are outputs that an attacker can read.
common vulnerabilities in systems that execute untrusted code often involve a combination of related integrity and condentiality issues.
assuming these vulnerabilities have been introduced to a system s code accidentially they are called confused deputy problems .
in this class of problems an attacker uses a proxy possessing the necessary authority the confused deputy to carry out operations on its behalf.
detecting instances of this problem requires a combination of an integrity and a con dentiality analysis.
instances of the confused deputy problem are a real and relevant problem for example in the java class library jcl .
vulnerabilities based on this problem have been exploited multiple times in the past.
the most prominent exploits are described in the common vulnerabilities and exposures directory under the identi ers and and have posed grave risk to the security of the java platform.
in the most common attack vector against java the attacker exploits the vulnerability to have the platform load a class on his behalf which otherwise he would have no permission to load.
in this kind of attack the attacker controls the input to a class loading method call an integrity problem and then retrieves the class object returned from that call a con dentiality problem.
existing taint analysis approaches show often prohibitive scalability problems when considered as a means to discover the kind of problems described above as we elaborate in the following.
a taint analysis for discovering integrity problems typically works in a forward mode it starts at sources and follows assignments until nding a sink.
if there are more sources than sinks such a forward taint analysis may follow unnecessarily many paths which will never lead to a sink.
these excess computations will eventually impede the scalability of such an analysis.
in a real world system that executes untrusted code sources are all public api functions that the untrusted code can call.
the amount of these public functions is typically by orders of magnitude larger than the number of sensitive sinks to control.
for instance in thejava class library there are over public methods.
when considering an analysis to nd vulnerabilities of calls toclass.forname call sites have to be regarded as sinks.
seeing all of the public methods of the jcl as sources there are clearly more sources than sinks in an analysis of this kind.
a backward analysis starting at sinks can address the scalability issues of a forward taint analysis .
however this only provides a scalable solution to the integrity problem.
for the con dentiality part of a confused deputy problem the backward analysis would now face the same problems described above in principle many methods of the public api would have to be considered as possible sources for the backward analysis most of which would never probably reach a sink.
in this work we thus present flowtwist a novel analysis approach which e ciently solves the integrity part of a confused deputy problem in a backward manner and solves the con dentiality part just as e ciently in a forward manner.
if applied to the java class library this analysis needs to start only at potentially vulnerable class.forname calls and not at all public api methods.
the challenge for flowtwist is to e ciently combine the analysis results of both analyses in a context sensitive fashion such as to avoid spurious results caused by unrealizable controlow paths.
to reconstruct the context sensitivity between the two independent analyses we match and connect a reconstruction of the call stacks of their results.
thereby complete paths from sources to sinks and back towards the source are constructed which are a ected by an integrity and a con dentiality problem.
we call this analysis an inside out analysis as it starts at the inner layer of the api which we consider as sinks e.g.
a call to class.forname within the java runtime library and then works its way outward to the public api the sources .
we implement our approach by several extensions of the interprocedural finite distributive subset ifds algorithm by reps et.
al.
.
the original ifds algorithm was designed to accommodate for instance forward taint analyses owing from sources to sinks.
previous work added the possibility to use the algorithm for backward analysis.
in this work we extend the ifds algorithm with support for so called unbalanced return ows i.e.
a ow out of a function whose calls have not been considered previously.
support for unbalanced return ows is necessary to facilitate an analysis that progresses from the inner layer of a api to the outer layer.
third we extend the facts propagated by the algorithm to store information on the paths they were propagated on to be able to reconstruct these paths.
this information is not only useful for reporting vulnerabilities but it is also used by another novel algorithm which combines the results of the forward and backward taint analyses to derive a complete result containing code paths that are possibly vulnerable due to the combined integrity and con dentiality problem.
the algorithm rst constructs semipaths from the two analyses results and then matches them to establish context sensitivity.
matched semi paths are combined to complete paths providing detailed information about the leaking data ows.
however enumerating all semi paths for matching threatens the scalability of the whole approach.
therefore we introduce an additional extension to the ifds algorithm that keeps the context of the forward and backwards analysisconstantly in sync.
as a result the analysis algorithm will never produce semi paths for the integrity problem for which no matching path of the con dentiality problem exists in the rst place and vice versa greatly reducing the number of paths that the path matching algorithm needs to consider.
to validate our hypothesis that the inside out approach is faster and scales better for large codebases than a pure forward taint analysis we apply both analyses to the confuseddeputy problem.
all analyses implemented for the experiments are equally precise context sensitive ow sensitive and report the same data ows.
in our experiments we run them on the java class library jcl shipped with the java runtime environment.
we consider the jcl as a large codebase as it contains over .
classes with over .
attacker callable api methods.
we nd that our inside out approach scales signi cantly better for an analysis of vulnerabilities to calls to class.forname than a pure forward analysis which we extended to cover integrity and con dentiality problems.
in our experiments the inside out approach was on average ve times faster than a pure forward analysis whilst using notably less memory.
also we observe that only our dependent inside out analysis is able to terminate in reasonable time for a larger problem targeted at nding vulnerabilities to calls to methods marked with the annotation callersensitive .
we therefore conclude that this approach e ectively solves larger problems and thus scales better.
to recap the main contributions of this paper are a context sensitive inside out taint analysis approach that solves the scalability problems of current approaches when applied to detect problems involving combined integrity and con dentiality issues in large codebases.
an implementation of the proposed approach as an extension to the ifds algorithm a novel path construction algorithm for more comprehensive reporting for the ifds algorithm an extension to our analysis that e ectively solves scalability problems in path construction an extensive evaluation of the proposed approach on a real problem scenario the remainder of this paper is structured as follows.
in section we give a brief overview of our approach.
section .
presents and overview on the ifds algorithm.
in section we present the inside out analysis approach that we propose in further detail.
section presents the design execution and the results of our evaluation.
in section we discuss the relationship of other work.
we conclude the paper in section with a summary of the ndings and an outlook on possible future work.
.
overview in this section we give background information on the ifds algorithm followed by a high level overview of our proposal.foo a if ... b a else c a c b return c a ab bc c a foo a if ... b a else c a c b return c value a1 a value b1 b source b1 b a pred a2 a1 pred b1 a2 pred a3 a1 pred c1 a3 pred c2 b1a1 a2 b1a3 c1 c2c2 fact along flow function fact along summary edge b bar a if ... b a else b a return b pred a2 a1 pred b1 a2 pred a3 a1 pred b2 a3 neigh b1 b2a1 a2 b1a3 b2b1 c figure fact propagation in the ifds algorithm the relations predecessor and neighbors are shortened here as predand neigh procedure propagateandmerge hsp d1i!h n d 2i if9d0 2jvalue d2 value d0 hsp d1i!h n d0 2i2seen then neighbors d0 neighbors d0 d2 else inserthsp d1i!h n d 2iinto seen propagate hsp d1i!h n d 2i end if end procedure figure change to support neighbors in ifds .
ifds algorithm the interprocedural finite distributive subset ifds algorithm addresses dataow problems with distributive ow functions over nite domains.
reps et al.
show that if the problem is modelled in this fashion the analysis problem can be reduced to a graph reachability problem.
the graph they built is a so called exploded super graph in which for each node s d is reachable from a special distinct start node if a dataow fact dholds at a statement s. for illustration consider a taint analysis which should be applied to the example in figure 1a.
for the assignment b athe ow function of a taint analysis should generate a fact that variable bis tainted after executing the statement assuming variable awas tainted before.
it also should retain the fact that variable awill then still be tainted.
but if variable awas not tainted before but variable bwas then variable bshould not be tainted afterwards.
such semantics are typically illustrated by graphs as in the figure 1a.
each dot represents a fact before and after the execution of a statement.
arrows between these dots represent that the applied ow function claims there is a dataow from one fact to the other for a speci c statement.
in the presented example there is a path shown in red color from a value passed as a parameter to the returned value.
after analyzing the function fooonce the ifds algorithm will create and store this path as a summary edge.
this is important for scalability as it allows to reuse the summary edge the next time a call to foois being processed instead of analyzing the whole function body again.
this becomes 1measured on oracle java update 25java bytecodeicfgflow facts flow factssemipaths semipathscomplete pathsstep step step step figure overview of steps performed even more obvious when considering that foocould itself call other functions which in turn had to be analyzed again too.
.
the proposal in a nutshell the suggested analysis performs four steps as illustrated in figure .
in the rst step the static analysis framework soot is used to read java bytecode and to transform it to an intermediate three address representation called jimple.
in that step it also computes an interprocedural control flow graph icfg .
in the next step the interprocedural finite distributive subset ifds algorithm uses the icfg to compute dataow facts along edges of the icfg.
heros is used as implementation of the ifds algorithm which is actually an implementation of the extended ifds algorithm .
the ifds algorithm is performed two times one time for the integrity problem and another time for the con dentiality problem.
the ifds algorithm implementation is extended and the dataow facts are modelled such that they support reconstruction of exact paths along which the dataow facts were propagated.
these paths are reconstructed in the third step.
however we call these paths semi paths as they represent only the integrity or con dentiality part of a complete path.
in the last step semi paths are matched to generate complete paths.
.
analysis design the analysis design we propose is capable of addressing integrity and con dentiality issues at the same time.
based on the observation that a pure forward analysis is not scalable or fast enough to be applied for such taint analysis problemson huge codebases we propose an inside out analysis design.
additionally we address the lack of reporting along which statements a dataow exists in the ifds algorithm.
in section .
we rst introduce how we model facts propagated by the ifds algorithm to include information about statements and paths taken in data ows.
an inside out analysis requires the support of unbalanced returns i.e.
return ows for which no previous call ow has been registered.
the original ifds algorithm does not support such unbalanced ow.
we therefore formalize them as an extension to ifds in section .
.
after having executed the ifds algorithm flowtwist constructs two classes of semi paths one for the integrity and one for the con dentiality problem.
these are then matched pairwise to construct combined execution paths.
section .
explains this path matching followed by a discussion of simpli cations to improve scalability in section .
.
section .
presents changes to the ifds algorithm that make the analyses for integrity and con dentiality dependent on each other avoiding analyzing and creating paths for program parts for which only an integrity orcon dentiality issue exists.
from a security point of view such paths are not interesting for instance because an attacker while being able to trigger the loading of a restricted class would not be able to obtain access to the loaded class handle.
we applied all extensions and changes to the ifds algorithm implementation heros and provided these as contributions.2additionally we provide the implementation of our analysis.
.
ifds extension to store path information the use of summary edges in ifds has drawbacks when it comes to reporting analysis results.
in the example in figure 1a only one branch propagates a potential taint from the parameter to the returned value.
yet information on possible alternative ows or in this case their nonexistence is lost.
but not only information about these intraprocedural paths are lost one also loses information about the interprocedural edges the analysis takes as the summaries abstract over called procedures.
moreover an ifds based analysis is only able to report the source and sink of a data ow but not any intermediate statements.
to overcome this limitation flowtwist adopts a model of facts that allows to track the ow along which they are propagated.
a natural approach to taint analysis with the ifds algorithm is to use the identi ers of variables as propagated taint facts.
however to enable path tracking we need a more extensive fact representation.
we propagate facts of type fact instead and de ne several relations on this type value fact!v ariable source fact!statement predecessor fact!fact neighbors fact!p fact the relation value maps each fact to the related tainted variable.
the relation source maps a fact to a statement at which the fact was generated.
the relation predecessor links to the fact from which a ow function generated the current fact.
e ectively this creates a chain of facts allowing to 2the implementation of heros is available on github 3the implementation of flowtwist is available on github the complete ow for a fact reported at an arbitrary sink.
the relation neighbors links to similar facts i.e.
facts with the same value at positions where ows are merged.
following examples will illustrate why this is model is simpler than storing multiple predecessors.
figure 1b shows the propagated facts when modeled as described.
note that some propagated facts are left out to simplify the illustration.
consider how the fact that predecessor c2 isb1and not c1encodes that the ow is only possible along one branch in foo c.f.
figure 1a .
the chaining of facts does not preclude the algorithm from computing summary functions which is important for the scalability of the ifds algorithm.
in the example the summary edge represents that if a tainted variable is passed as argument tofoo then the fact c2holds i.e.
cis tainted when the method returns.
the summary abstracts of the intermediate facts a1 a2 and b1 but nevertheless the chain of predecessor links allows flowtwist to later reconstruct the path along these facts through the reference to c2 which is included in the summary.
to illustrate the role of the neighbors relation consider the example in figure 1c.
here the facts b1andb2both hold at the same statement and both represent the fact that variable bis tainted.
moreover these facts should be merged into a single one as otherwise from this point on every propagation is computed two times for similar facts.
this e ect multiplies further for every branch taken yielding a clear threat to the scalability of the analysis.
ifds is restricted to set union as a merge operator and is thus unable to identify similarity of flowtwist s dataow facts.
therefore we extend the ifds algorithm to recognize if a fact is propagated along an edge for which previously a fact was propagated with the same value .
if this occurs the second propagated fact is set to be a neighbor of the rst propagated fact and the second fact is not propagated further.
in contrast to creating predecessor links it is not possible to encode this behavior in a ow function.
however the ifds algorithm can be extended by simply wrapping calls to the propagate procedure as shown in figure .
given the fact d2to be propagated propagateandmerge checks whether there is a factd0 2stored in the set seen for which the value is the same as the value ofd2.
if such a fact d0 2exists then d2is added to its neighbors and not propagated further otherwise d2is added to the set seen and propagated.
we do not use the predecessor relation to store information about a merge as it increases complexity of handling summary edges.
in the example function barwe would have to create two summary edges one for the fact b1and one for fact b2.
for each caller of the function these have to be recognized as representing the same value i.e.
adding both as predecessors.
using the neighbors relation allows to store only one summary edge i.e.
for the rst fact propagated to the return statement.
nevertheless the path through the second fact can be equally reconstructed as it is stored as a neighbor of the rst.
.
unbalanced return flows neither in its original version nor in its extended version does the ifds algorithm support unbalanced return ows.
unbalanced return ow occur when processing a return of a method for which no matching previous call was processed.
in a typical context sensitive analysis starting at the outer layer of an api calls are always processed beforeprocedure forwardtabulateslrps .
.
.
select and remove an edge hsp d1i !hn d 2ifrom worklist .
.
.
foreachhc d 4i2incoming do .
.
.
unchanged handling of balanced return ows od .
ifd1 incoming then .
foreach c2callsitescalling procof sp do .
foreach d52returnval hep d2i hc d 1i do .
propagate hsprocof c 0ic !hreturnsite c d5i .
od .
od .
end if .
.
.
end procedure figure extension to support unbalanced return flows line numbers match the complete representation of the ifds algorithm shown in figure of a bouter layer c dinner layer call return a c x y b x if ... l1 d y else l2 z d const return z b figure example flow from inner to outer layer returns making unbalanced returns impossible.
but flowtwist starts the analysis on the inside of the api which naturally calls for supporting such unbalanced return ows.
figure shows our extension to the ifds algorithm to enable unbalanced return ows.
in line through the algorithm originally loops over all incoming edges and propagates return ows accordingly.
our modi cation adds lines .
through .
.
in line .
we check if the algorithm is currently in a unbalanced situation.
this is the case when d1 is the autological fact which always holds and when there is no incoming edge into d1for the current function s starting point sp.
if identi ed to be in an unbalanced situation the algorithm computes and propagates return ows to each possible call site.
note that in situations where flowtwist returns from a method min an unbalanced way and then processes a call to magain say with a fact d1 then this will lead to a situation where the incoming set of hsp d1iis not empty which is why in this case flowtwist will perform a normal balanced return maintaining context sensitivity returning only to the appropriate call site.
.
creating and matching semi paths if working in a regular outside in manner a taint analysis would start at sources on the outer level of the api through some sensitive method such as class.forname .. and then then back to the original method at which the analysis started.
that way the analysis can report a possible ow as soon as it reaches this starting point again.
flowtwist cannotadopt the same strategy as both its analyses the one for the integrity problem and the one for the con dentiality problem are inside out analyses they start at some inner layer of the program being analyzed and should report potential ows reaching some outer layer.
to report a ow for the inside out analyses two conditions have to be met the ow must reach a source method we do not de ne what characterizes source methods at this point as this depends on the concrete analysis problem addressed.
that function must be a transitive caller of the sink.
the need for condition is illustrated in figure 5a.
assume we start an inside out analysis at function d. this function returns unbalanced to function c. function ccalls b from which the ow returns balanced context sensitively .
subsequently the ow returns unbalanced to a. condition holds for functions aandb.
yet reporting at bdoes not make sense because if bgets called by untrusted code there is no program ow to dasbwill return to the untrusted code.
this is where condition comes to play.
it only holds for aandc but not for b. so a ow is only reported at a. note that condition can be easily checked it will hold if and only if the function is entered by an unbalanced return.
once a ow is reported the algorithm traverses the predecessor chain of facts to construct a semi path through the program along which a ow exists.
it is a semi path because it only contains one way from a source to a sink.
to construct complete paths the semi paths produced by the two analyses in isolation need to be matched.
this has to happen with awareness of context as it otherwise leads to paths that are infeasible at run time.
this context is the call stack which has to be same to match semi paths.
for the example ow illustrated in figure 5a the call stack would be .
instead of function names however flowtwist uses the concrete call sites to encode the call stack.
the code of function cshown in figure 5b illustrates why concrete call sites are required.
in that example semi paths exist both for the integrity problem and the con dentiality problem and they also share the same functions on their call stacks.
but the semi path for integrity uses the call site labeled as l1 while the semi path for con dentiality uses l2.
thus the two semi paths should actually not be combined into one execution path.
however this conclusion could not be reached if flowtwist used function names rather than concrete call sites in the call stacks.
the question is how to retrieve concrete call sites along the semi paths.
using the relation source does not serve the purpose because return edges start at an exit statement and end at a return site the call sites themselves are not included.
it is also infeasible to model the call stack as part of facts because this would make facts caller dependent thus it is not possible to reuse summary edges across multiple callers.
to address the need of storing the call sites we extend our model of facts by the following relations.
for facts propagated along call and return edge relatedcallsite maps to the related call site and callstacke ect is used to store the e ect on the simulated call stack when traversing a fact.
for intra procedural ow edges callstacke ect maps tonone .
relatedcallsite fact!statement callstacke ect fact!
the construction of all semi paths for a fact fis implemented by the work list algorithm shown in figure .
as semi paths are constructed by traversing the predecessor chain of facts their corresponding call stacks are computed as well.
due to merging facts in the ifds algorithm step the predecessor and neighbor