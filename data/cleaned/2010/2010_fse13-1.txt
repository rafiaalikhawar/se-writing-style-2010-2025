compiling mockups to flexible uis nishant sinha ibm research india nishant.sinha in.ibm.comrezwana karim rutgers university usa rkarim cs.rutgers.edu abstract as the web becomes ubiquitous developers are obliged to develop web applications for a variety of desktop and mobile platforms.
redesigning the user interface for every such platform is clearly cumbersome.
we propose a new framework based on model based compilation to assist the designer in solving this problem.
starting from an under specified visual design mockup drawn by the designer we show how faithful and flexible web pages can be obtained with virtually no manual effort.
our framework in sharp contrast to existing web design tools overcomes the tough challenges involved in mockup compilation by a employing combinatorial search to infer hierarchical layouts and b mechanizing adhoc principles for css design into a modular extensible rule based architecture.
we believe ours is the first disciplined effort to solve the problem and will inspire rapid low effort web design.
categories and subject descriptors d. .
design tools and techniques user interfaces case general terms algorithms design.
keywords layout inference mockup based design html css.
.
introduction web user interface ui design is a fundamental part of web application design .
the ui quality often directly influences the adoption of the application and therefore designers spend significant effort in getting the user interface right.
an important component of ui design is static design involving selection of elements their layout and styling coloring typography for a particular web page view.
static web design requires a deep understanding of interaction between a page structure definition in html and b the layout style modeling in css .
both of these are low level technologies and css in particular has a steep learning curve.
this makes html css authoring extremely labor intensive and timeconsuming .
in particular css styling largely remains an art css does not include constructs for specifying complex layouts directly designers must carefully work around various css features manually to obtain desirable layouts for different platforms.
consequently web design often involves two people working closely a web designer who uses a graphic editor e.g.
adobe photoshop to design the look in a drag drop fashion and a developer who encodes the design based on her html css expertise.
this partnership is often unproductive due to the strong permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright c acm .
.
.
.00coupling and feedback delays minor changes by the either party may cause significant grievances for the other.
with the web becoming ubiquitous on mobile devices with multiple form factors the problem has become worse.
applications must be designed for multiple devices simultaneously and adapt to rapidly evolving technology besides having a shorter time tomarket.
moreover we observe an increasing involvement of nonexpert developers in the new echo system who are barely skilled in html css.
the prevalent partnership model hardly scales to the increased development demand.
in fact we now need tools which shield the developers from the low level technologies and minimize distractions thus enabling low effort rapid web development.
mockup based design offers an appealing solution to rectify the current dismal state of affairs.
a mockup also called awireframe is a rough visual depiction of the desired design drawn in a software tool called a wysiwyg editor and reflects the designer s intention visually.
a designer can draw mockups easily in an editor by using drag drop operations on ui widgets from a palette collection and apply menu based style selections.
mockups are essentially technology independent a designer only needs a superficial understanding of the underlying technology to draw mockups.
further a single mockup may be used to obtain different implementations for multiple devices via device specific compilation.
finally these designs are reusable even as the web technologies evolve.
clearly mockup based design is advantageous in multiple ways.
to bring this vision to reality several wysiwyg editors have been designed e.g.
adobe dreamweaver microsoft expression web over the past decade.
although these editors assist the designer with content authoring it is widely accepted that they have failed to inspire ubiquitous mockup based development.
the key hurdle is that enormous low level manual effort and a deep knowledge of html css is required to work with these editors.
moreover the tool requires the designer to not only specify the ui elements constituting the core design but also the precise layout for those elements.
this often leads to exposing the designer to underlying low level details of html css which was originally intended to be kept under the hood.
moreover in return for the extreme manual effort most editors generate fixed designs which cannot adapt to browser viewport or device changes.
thus these tools generate lot of user dissatisfaction and are deserted by unskilled designers.
more recent wysiwyg tools restrict themselves to quick design prototyping and do not promise high quality code translations.
this brings up the natural question why can t they do better?
how hard is compiling mockups?
automatic high quality compilation of mockups is indeed quite non trivial.
there are two main challenges challenge infer layout a mockupmis a freely drawn underspecified design schema over ui elements where the page layout is not explicit.
a tool must mine and generalize from the latent hierarchical structure in mto extract the right layout form i.e.
the local vertical horizontal flow of the page content which also preserves the relative sizes and alignment of individual elements.infer layout l encode linto mockup m ofm html csshtml cssflexible viewfigure .
overview of the two phase approach for encoding mockups to flexible web pages.
this involves solving a non trivial combinatorial search problem over the set of possible layouts.
challenge encode in html css the second problem is how to encode the inferred layout in an html page faithfully.
this requires a deep understanding of css semantics which is complex and has no support for encoding layouts directly.
moreover to generate superior encodings the tool must incorporate the poorly documented css design principles used by designers in practice.
somewhat surprisingly there exists no systematic framework to address the above two challenges for web design.
researchers have employed constraint solvers to address the first challenge of finding layouts and personalized interfaces in context of standalone desktop based applications.
these efforts assume that a dedicated rendering engine is used which can readily interpret the pixel value solutions provided by the solver.
the web unfortunately fails to meet this requirement.
each off the shelf web browser embeds a complex rendering engine optimized over many years which can primarily interpret html css javascript commands.
modifying the layout engine is therefore not advisable instead we would like to exploit the existing engines to maximum.
using heavy javascript for layout is undesirable specifically for mobile devices.
the problem therefore becomes that of communicating layout information to the browser efficiently in terms of html css boxes .
this in turn requires us to express and search for layout in terms of a hierarchy of rectangular boxes and infer a hierarchy of container boxes for ui objects as opposed to pixel values.
box based layouts have been investigated for text documents e.g.
latex and grids both of which are unsuitable cf.
sec.
for laying out variable sized boxes with heterogeneous content as in a web application mockup.
similarly most wysiwyg editors dodge the second challenge and adopt the path of least resistance.
this is not surprising because encoding css rules automatically is quite challenging cf.
sec.
.
they use simplified encoding techniques e.g.
based on widely criticized html tables and often resort to a fixed layout which necessitates scrollbars and does not adapt to viewport or font resizes.
the low quality encodings generated by these tools however diminish the user experience and adoption significantly .
in this paper we present a systematic framework to obtain faithful html css designs from a mockup mautomatically.
our encoding technique consists of two phases shown in fig.
.
we first propose a new algorithm to infer an hierarchical layout lfromm challenge by recursively partitioning it into boxes which flow left to right hboxes or top to down vboxes .
this recursive partitioning extracts the implicit hierarchical structure of m besides capturing the relative size and alignment of elements.
to address challenge we present a systematic modular architecture for encoding these layouts into html css each module consists of a set of mathematical rules for step wise encoding linto html css.
the proposed architecture is extensible and allows easy fine tuning of encoding rules.
further along the lines of the original vision we show how to construct flexible designs from a single mockup which can adapt to multiple devices gracefully.
fig.
shows the advantage of our flexible encoding over a fixed encoding note how the fixed layout on the top gets cropped as the browser window re sizes but the fluid layout bottom scales down to the smaller viewport size with an elastic text formatting.
we evaluate the framework on mockup benchmarks which model several common web ui design patterns and demonstrate high quality encodings of the original mockup in html css automatically.
we figure .
comparison of a fixed layout top and a fluid elastic layout bottom generated by our tool.
show that in absence of our method generating these designs would have required significant manual effort.
our main contributions are as follows.
we present a systematic automatic framework to encode mockups into faithful html css designs with flexible layouts.
the generated design may be viewed in an off the shelf browser without modifying the browser or changing the prevalent web markup echosystem we exploit the browser layout engine to the largest extent possible to achieve high quality encoding.
our framework consists of a new technique to infer hierarchical layouts from mockups based on combinatorial search together with a systematic extensible set of rules to encode these layouts.
extensibility enables fine tuning designs as well as adapting encoding to technology evolution.
finally our tool enables nonexperts to develop complex web page designs with low manual effort without exposing them to much of under the hood html css technologies.
to tackle difficult design scenarios for automated heuristics we enable the designer to interact with and guide the tool towards desired encodings.
we evaluated our method on a collection of mockups modeling common web design patterns.
our results shows that automatic high quality flexible mockup encoding is indeed feasible using our tool with hardly any user intervention.
the paper is structured as follows.
sec.
overviews html and css semantics and sec.
defines mockups and layouts formally.
sec.
presents the hierarchical layout inference algorithm and sec.
presents the modular encoding rules into css.
sec.
discusses our tool infrastructure and evaluation results.
sec.
presents the related work and sec.
concludes.
.
a brief tour of html and css html consists of a set of markup conventions to describe the structure of a web document in a device independent manner using a set oftags e.g.
title headings h1 h2 etc.
division div paragraphs p lists ul anchors a inputs input forms and so on.
the content of the document is embedded in the html structure.
the upcoming html5 standard also includes tags for specifying multimedia content e.g.
audio video etc.
.paddingbordermargincontent boxpadding boxborder box marginb2 b1b2 s b1 s inner outer heightheightfigure .
anatomy of a css block box.
acss style sheet consists of a set of rules each ruleris composed of one or more selectors and a declaration.
the declaration consists of a set of property value pairs.
properties and their values determine the visual appearance e.g.
height width font color margin padding of the elements in the browser.
selectors determine the html elements to which the properties apply to.
they are defined using relations between html tags e.g.
div p selects all paragraph elements which are children of some div element.
the mutual alignment of the html elements i.e.
the layout is also specified using css discussed later .
the css standards specify how properties may be inherited among the elements in a page s html structure and how rules are prioritized depending on their order or specificity .
we will primarily focus on css2.
in this paper because it is implemented by browsers to a reasonably complete extent and is well known among web designers.
structure style separation.
css rules may be specified inline with the html specification but such mixing of style and structure is discouraged .
to enhance modularity css and html should be specified separately.
the coupling between css and html is achieved by annotating html elements with label s corresponding to css style object s which may affect their appearance see example below .
this separation between html css has multiple advantages e.g.
the order of specification of blocks in html remains independent of their positioning in the actual page layout.
moreover blocks may be moved around in the hierarchy arbitrarily without changing their style.
box model semantics.
the semantic structure of a web page consists of a set of boxes a box may be simple or compound contain other boxes .
boxes which start on a new line and have a line break after them are called block boxes blocks in short otherwise they are called inline boxes.
block boxes take width of their parent unless specified inline elements e.g.
span only expand to contain the content inside them.
the boxes are specified using specific html tags e.g.
the division div html tag is commonly used to specify a block box.
the position and size of each box is given by a set of attributes top left height andwidth .
boxes also have other style properties e.g.
border padding margin color font etc.
.
margin padding border of boxes.
the margin property of a box bspecifies the distance of an adjacent box from the border of the b. the padding property specifies the distance between the border and the box contents.
both margin and padding may be specified along four directions i.e.
left right top and bottom.
these attributes are conveniently visualized using a box figure shown in fig.
.
in css2.
the size height width of a box refers to the actual size of the content box not the border box .
thus the combination of height width border margin and padding for boxes must be computed carefully during page design.
example.
fig.
shows a html css design.
the html top consists of a divelement is labeled with the identifier content and contains a header element h1 a paragraph element p and two divelements containing text box and box respectively both of which are labeled with class mybox .
the visual attributes of boxes with labels content andmybox are specified in css separately on right.
the css rules say that the top level divelement referred to div id content h1 main content h1 p lorem ipsum etc.. p div class mybox box div div class mybox box div div content padding 10px margin 100px .mybox height 100px width 100px figure .
interaction of css styling with html.
by its css selector content has a padding of10px on all sides and margin of 0pxon top and bottom and of 100px on left and right.
the class mybox denoted by selector .mybox has two properties height and width both of value 100px .
the mybox class applies to both box and box divs making them of height width 100px each.
fig.
a shows how the above html css is rendered in the browser.
all elements are laid out vertically in the normal flow.
because there is no spacing between box and box they appear as a continuous block.
to improve the appearance of the design we need to add margin and padding for both box and box .
we do this by adding margin 10px andpadding 10px to the .mybox specification which results in fig.
b .
note how adding margins moves both the boxes slightly south east and separates them from each other.
also padding separates the text inside each .mybox from the box borders.
now suppose that we want the boxes to be arranged left to right instead of top to down.
for this we add float left to the .mybox specification explained later .
fig.
c shows the result.
the final .mybox specification is .myboxfheight 100px width 100px margin 10px padding 10px float left g note how the separation between structure html and style css is beneficial it enables us to obtain three different designs by modifying only the css without changing the html structure.
also note that developing a simple web page where elements flow both vertically and horizontally requires a somewhat deep understanding of css box semantics e.g.
floats.
the involved semantics have led in practice to multiple ambiguous interpretations of their behavior.
thus modern css design is virtually an art form.
.
preliminaries mockups layouts hvboxes a mockup is a schema of the desired ui based on representative ui elements drawn in a wysiwyg editor using direct manipulation.
mockups.
formally a mockup mis a collection of rectangular objects boxes m each box having its visual properties e.g.
size border color etc.
.
an object mmay correspond to an html5 ui element e.g.
div p ul label input img or a widget from a ui library e.g.
.
non rectangular ui objects e.g.
text images circular objects are represented by their bounding boxes inm.
let the setacontain the common visual properties of boxes e.g.
height width top left for their size position font size border background color for their look as well as other css attributes.
also the values for elements of set a are stored in the set da.
quantitative property values in mare specified in pixels orems .
formally each object mis a tuple r id whereidis a string identifier and a !
d a is a map from attribute names to their values.
instead of writing height px form we simply write m.height .
intuitively a mockup corresponds to a free hand drawing of ui elements on a canvas e.g.
that of a wysiwyg editor where the page layout is not explicit.
given such a drawing d our approach extracts the absolute height width and position attributes of the bounding boxes in the editor along with their style properties to obtain a mockupm.
textual content is extracted out from the dand added tom.
designer specified container elements in the drawing are captured as parent child relationships between boxes in m. the layout inference algorithm then uses mtoguess the layout intended by the designer.
taxonomy of layouts.
a layout refers to a particular arrangement of ui elements on a page.
web designers use an informal nomenclature to refer to common layout patterns.
a fixed layout uses a fixed unit of measurement pixels typically for positions and sizes of elements independent of the browser viewport or the font size.
thus fixed layouts are completely static and do not change across font resolution and viewport changes.
while fixed layouts offer maximum consistency across multiple browsers they are considered less user friendly e.g.
they may require scrollbars on smaller viewports.
arelative layout uses a relative unit of measurement e.g.
a percentage of the viewport size the page content resizes to adapt to viewport or font size changes.
two common relative layouts are used a liquid or afluid layout and an elastic layout.
fluid layouts are characterized by specifying size of children as percentage of their parent sizes while elastic layouts focus on how elements resize on change in font sizes.
hybrid layouts which combine fluid elastic and fixed layout styles are also common.
computing a fixed layout from a mockup is straightforward because the positions and sizes of all elements are fixed and hence they can be styled independently.
in contrast to generate a relative layout we need to consider the relative vertical horizontal alignment of elements in the page which may also change locally across the page.
therefore a more sophisticated approach is needed.
layout representation.
a horizontal box hbox contains child boxes aligned along the x axis left right .
the children of a vertical boxvbox are aligned along y axis top down .
we use hvbox to denote a box which is either an hbox or a vbox.
a cut is called a guillotine cut if it breaks a connected area into at least two parts.
a vertical horizontal guillotine cut is a cut parallel to the y x axis and creates an hbox vbox respectively.
an hvbox partition p ofbis obtained by performing a sequence of vertical or horizontal cuts ppartitionsbinto a hierarchy of disjoint hvboxes.
the box type of an element nis denoted by n.box.
most web pages are laid out in a structured manner and their layout can be captured using hvbox partitions.
given a mockup mdrawn on a canvas box c ahvbox layout formis defined to be a hvbox partition pofcsuch that each minimal partition in pcontains exactly one ui element from m. inferring an hvbox layout allows us to model the structure of the page in a holistic fashion the model captures relative sizes and positions of the ui elements as well as the vertical horizontal flow of the elements at different locations on the page.
this in turn enables encoding a relative layout formin html efficiently.
grid vs hvbox layouts.
layouts are often modeled using grids.
however grids result in fine grained layouts which have additional overhead.
consider fig.
showing layout with four boxes b1 b4.
to model the layout using grids we need to specify the fine grained grid shown in dotted lines.
in contrast we only need guillotine cuts with an hvbox partitioning solid lines .
encoding grids with html tables is even worse e.g.
because of redundant markup for empty table cells and harder re designs .
further designer must b1b2 b3 b4figure .
hvbox solid vs grid dotted partitioning.
spend additional effort chopping content and aligning boxes with the grid in a wysiwyg editor which is laborious.
as mentioned earlier our encoding framework consists of two phases a infer an hvbox layout t b encode the layout tinto html css.
obtaining faithful encodings is non trivial both these phases require sophisticated algorithmic machinery and multiple design choices.
we now describe the first phase of our framework i.e.
hvbox layout inference.
.
hvbox layout inference because mockups contain implicit layout information we must extract their layout by analysis.
an hvbox layout lfor a mockup mmay be viewed as a tree t where the leaves represent the content boxes an intermediate node is an hvbox and the root of t represents the top level box body in html .
computing a valid hvbox layout lmay involve searching over a large number of possible hvbox partitions.
to minimize the search space we use a greedy search which performs iterative bottom up merging of boxes by choosing a pair of boxes to merge at each iteration.
some of these choices may not lead to a valid hvbox layout.
therefore the algorithm is capable of backtracking i.e.
if it is unable to proceed by merging further it backtracks and tries out other possible merge choices.
a valid layout lcorresponds to a correct sequence of merges theorem .
the procedure computelayout alg.
computes the layout treetform using procedures preprocess merge andmergeimplied .
it maintains a forest of treesfto compute layout initially fcontains a separate tree for each box in m. the procedure finishes successfully if fcontains a single tree tat some iteration.
procedure merge merges two boxes b1 b22fto obtain an hbox vbox .
it first computes the minimum bounding box mbb for b1andb2 i.e.
the smallest horizontal vertical box cwhich containsb1andb2.
a new box tree c box b b2 is added tof whereboxis hbox or vbox and b1 b2removed from f. to improve search a potential merge setp b for each box bis maintained which contains all the boxes in fwhich may merge with b. merge forms the core of our layout procedure it needs to efficiently compute adjacent boxes which can be aligned and merged up to a degree of tolerance.
we use the k d tree data structure to store box coordinates compute p b and answer box overlap queries efficiently.
the procedure mergeimplied computes the merges which areimplied at each iteration i.e.
for all boxes bi2fwhosep bi contains exactly one element say bj the procedure merges biand bj.
the procedure continues until no implied merges are possible.
in alg.
the preprocess method first strips mto extract the set of hierarchical boxes drawn by user.
because a recursive partitioning is infeasible with overlapping boxes it computes a maximal subset of non overlapping boxes fto compute layout with1.
after preprocessing merge combines boxes in finto an hvbox while updating the forest funtil a single tree remains in f. note that this merge may updatepof other boxes adjacent to biandbjand hence 1most designs avoid such boxes but complex designs may contain a few.
we handle overlapping boxes at a later stage.trigger other implied merges.
after computing the implied merges the algorithm checks if a conflict occurred defined as follows.
aconflicting configuration during search is where the set p b for each block b2fis empty and fcontains more than one element.
clearly we cannot continue merging and obtain a valid layout with the current sequence of merges.
therefore we undo one or more previous choices and continue the search by trying other merge choices.
moreover we learn facts from the conflict into a conflict setr.
this set stores all the incompatible merge choices encountered during search and prevents the algorithm from making similar bad choices in the future.
the procedure handlecon ict implements conflict analysis and backtracking.
on success handlecon ict returnstrue and the algorithm proceeds to find other merge choices.
otherwise no merge choices will lead to a valid hvbox layout and the algorithm terminates with a no answer.
otherwise the algorithm returns the computed layout tree t f .
the procedure can be extended to the case where the mockup contains user defined containers e.g.
an html form which contain children ui elements.
in this case we check if there exists a parent box pinmwhich corresponds to the bounding box bobtained on merging the children ui elements.
then merge labels the merged node in twithpinstead ofb.
readers may observe that our layout algorithm in spirit follows the explore fail learn paradigm of the general dpll algorithm cf.
for constraint solving which is known to solve hard combinatorial problems efficiently in practice.
we choose to formulate the approach over boxes directly instead of using a sat solver so as to exploit the problem structure as well as avoid expensive propositional or quantifier based encodings.
procedure computelayout mockup m f preprocess m mergeimplied update f p while size of f 1do choose box bi2fandbj2 p bi merge bi bj update f p mergeimplied update f p ifcon ict then r handlecon ict update r p if rthen return no return f algorithm layout computation.
theorem .if a mockup has a valid hvbox partition then the computelayout procedure will compute a valid tree for it.
proof sketch.
we prove by induction over the number of horizontal vertical cuts in the hvbox partition.
for a single cut the mockup is an hbox or vbox with two elements.
merge will obtain the hbox or vbox via a single merging step.
suppose the iterative merging obtains a valid layout for all hvbox partitions with n 1cuts.
consider a partition with ncuts remove any one cut from it to obtain ann 1cut partition.
by hypothesis iterative merging will compute a correct layout tree tfor the latter.
now the nthcut must separate two boxes bi bj both of which lie in some leaf loft and bj2p bi .
this is sufficient for merge to combinebi bjinto tree tand replacelintbytto computet0for then cut partition.
example.
consider the mockup with boxes 1a 1d and shown in fig.
a .
starting with a forest consisting of these singleton box trees computelayout tries to merge the trees into a single tree iteratively.
fig.
b shows the initial merge set p b for each boxbas a graph each edge denotes that the corresponding pair of nodes may be merged without intersecting with other boxes.
the graph shows that in fig.
a 1a 1d only merge among themselves box has two merge choices and and box has no choices merging with intersects with 1d intersects 1c .
implied merges are computed first there are two of them p p 1a2 a b c d 45vhhv1b 1c 1d1a 1b 1d 1c 1a 1b 1d 1cfigure .
example layout inference.
and the algorithm must make a choice.
suppose it chooses to merge boxes first.
now box cannot merge with and there are no more implied merges.
further suppose boxes 1a 1d are merged among themselves to form a box labeled .
fig.
c shows the resultant configuration.
now all the boxes and have their merge setpempty.
hence we have a conflict .
to resolve the conflict we undo the earlier merge choice and record 1a 1d as an incompatible set of merge choices if we merge then 1a 1d cannot be merged .
now the other merge choice from fig.
b is tried.
after merging p f5gandp f2g.
the procedure computes implied merges boxes are merged and boxes are merged with box .
finally and are merged as shown in fig.
d and we obtain a valid hvbox partition.
the final layout tree is shown in fig.
d with the intermediate hbox vbox nodes labeled by h v .
procedure compact treet repeat foreach nodenintdo ifcis a child of n c box n box isremovable c then for each child gofc make ga child of n delete cfromt untiltdoes not change algorithm compact the partition tree.
for element x x box has values hbox or vbox or is undefined.
the treetcomputed by computelayout may have redundant hvboxes e.g.
if a tree node nis an hbox and all its children are also hboxes we can flattentby removing each child cofnand attaching the children of cton.
in general note that every child hboxcof an hboxnis redundant i.e.
all children of ccan be made direct children of nwithout affecting the hvbox layout.
using this observation compact alg.
computes a minimized partition with fewer hvboxes.
we cannot remove an intermediate node n from treetif it corresponds to an element in the mockup which is deemed essential by the designer.
the isremovable procedure checks if an element is essential before removing it.
.
html css encoding encoding the inferred layout tin html css would be straightforward if css supported hboxes and vboxes natively.
unfortunately no such constructs exist in css2.
and as we discussed earlier using html tables makes layout redundant and mockup drawing labor intensive.
thus we need to exploit the css box semantics as professional designers do in order to hack css to create the desired layout.
two main css notions are used for layout in practice figure .
collapsing parents with floating children.
block formatting contexts bfcs and floated elements.
the precise definitions of these notions are quite involved we present a simplified description here to provide intuition.
encoding hvboxes.
a block formatting context bfc is the central layout primitive in css it defines an independent scope for formatting elements contained inside it oblivious to other page components.
a block box b e.g.
div may define a new bfc by using special css keywords e.g.
overflow orfloat in the css rules forb.
by default blocks in a bfc are laid out from top to down one after another also called the flow layout .
so we can simply encode a vbox in css by defining a new bfc html body element is a bfc already .
the main issue is how to create horizontal flow for hboxes.
css float properties come to our rescue here.
given a list of child boxes inside an hbox p we can encode them by floating eachbito the left or right inside p. this is specified by adding float left for eachbi.
intuitively this may be understood as an extension of text wrapping e.g.
in latex to boxes floating boxes wrap next to their previous box sibling.
additional care is needed when we would like to recover the vertical flow we must clear the floats after the final child bn.
this intricate combination of bfc and floats allows us to obtain nested horizontal and vertical layouts.
css quirks.
the description above glosses over many css quirks which our encoding also needs to handle.
consider e.g.
the issue of collapsing parents .
a floated child bidoes not contribute to parent p s container size in css or in other words biis ignored when sizingp.
this behavior known as the great collapse popularly leads to a bad layout in many cases.
fig.
a shows the same example from fig.
b except that the content boxpis highlighted by adding the rule background cbc to content in css.
now we float children of pusing .mybox class leading to the collapse shown in fig.
b .
interestingly this was not apparent in fig.
c but is still undesired.
to fix this we establish a new bfc with pso thatp s layout now owns its children s layout add a rule overflow hidden top s css content .
other tricks e.g.
by clearing floats can also solve this problem.
as mentioned earlier our encoding should be both fluid and elastic sec.
and not fixed.
fluidity is essentially obtained by specifying size margins of boxes in percentages relative to their parent but involves additional challenges we must consider how the complex multi box structure interacts with the size margin properties.
handling padding and borders in pixels together with fluidity introduces rounding errors and requires computing tolerant relative values.
many more challenges exist e.g.
collapsing margins aligning labels with corresponding input elements in forms etc.
discussed later.
overall automatic encoding into css turns out to be quite an ordeal .
note that at present these encoding hardships need to be borne manually by the designer.
.
rule based modular encoding architecture we wish to hide the aforementioned css hardships under the hood to reduce designer s burden.
to this goal we propose a modular rule based architecture for encoding layouts systematically.
our approach automates and unifies multiple adhoc design principles make blockmark flex mark floatcompute relative margin fluid size fluid size fluid elastic html css code generation code generationfigure .
html css encoding architecture overview.
has a clear separation of sub tasks and avoids re computation of intermediate results.
this in turn allows it to be reusable even as css evolves or encoding goals change.
fig.
shows the architecture boxes represent the key individual modules and the arrows show their mutual dependency.
the top modules m ake block compute relative and m ark flex compute intermediate results which are required by multiple lower modules i.e.
m ark float m argin fluid size fluid and size fluid elastic which encode the alignment relative margins and the height width of ui elements.
each module is defined by a set of rules given in fig.
which recurse over the structure of layout treet.
specifying modules as rules helps highlight the key logical challenges during encoding and enables an abstract description decoupled from their application order in a specific implementation.
encode structure html .
encoding the structure of the layout treetin html is relatively straightforward.
each intermediate node intmaps to a divelement div div which encloses the html code for its subtree.
the root node maps to the body html element.
the leaf ui elements in the layout tree tare encoded by corresponding html tags or widgets .
care must be taken to encode the content of the ui element properties e.g.
all the options of a select element must be encoded into html.
.
encode layout and style css .
the modules in fig.
encode tree tinto css in a manner faithful to the original mockup i.e.
preserve relative positions sizes alignment and visual properties.
recall that only block box elements cf.
sec.
e.g.
div ul may be assigned height width values and establish a bfc in css .
therefore we must convert non block leaf elementsnin treetto block elements to control their size and ensure proper alignment.
however children of a few block elements e.g.
pcannot be made block .
hence this module recurses down tusing the rules canmakeblock andmayhaveblockchildren .
when it finds an non block element n ishtmlblockelement n which can be converted it sets propertyn.toblk totrue .
this module additionally takes care of elements e.g.
tr which do not allow immediate block children but allow other descendants to be block.
the toblk value is looked up during html code generation to generate a wrapper div block containingn this block essentially serves as an alias for nin the other rules which enforce the size and position of n. for css translation we associate each node nintwith a css object denoted n.css which contains properties of ncomputed by the modules.
as discussed above non block elements cannot accept height width margin properties and hence are wrapped by alias div elements.
so to assign css properties correctly we use the cssobj function ifnhas a wrapper div n.toblk is set then cssobj c returns the css object for wrapper of c else it returns c.css.
the rules refer to n.cssorcssobj n appropriately.
to handle text containing flexible elements this module marks all such elements and their ancestors with propertyisflex true .
note that marking all ancestors is necessary to allow flexible children to re size freely without overflowing their parents.
this module defines how the layout hvboxes are encoded in css.
vboxes are encoded directly the key question is how to encode an hbox.
this module traverses trecursively and assigns over ow hidden value to each hbox element and oat left values to all its children.
this floats children to the leftedge of their parent.
margin computation see below takes care of the spacing in between even if the children are closer to the right edge of the parent.
this module pre computes the offset and height width of an element relative to its parent s content box .
the offsets along four directions between child s and parent s contentboxes are stored as properties topr leftr bottomr andrightr with pixel values.
the relative height width relheight relwidth are computed in percentages.
this module additionally computes the offsets between the child s border box and the parent s content box and stores them as properties topr leftr and so on not shown in fig.
.
these are required by the m argin fluid module.
margin values align the set of children properly inside their parent s container cf.
fig.
.
to obtain a fluid layout sec.
we compute margins in percentages of parent s width .
all margins for non block elements are set to m5 .
the margins for the first child cof parentn given bychildk c n depends only on the separation between content box of nand the border box ofc rule m1 .
for other children of n rules m2 m4 the left top margins depend on the right bottom border of the previous sibling fields immt imml depending on whether nis a hbox or a vbox respectively.
computing only the left and top margins is sufficient for fluid designs if the height width of children relative to their parent is fixed i.e.
we can set the right margin of cto0and take into account the width of cwhen computing the left margin of the next sibling ofc.
this also helps avoid the collapsing margin problem because e.g.
only the top margins are specified for each element in vbox.
this assumption however breaks down for elastic designs see below .
this module computes the sizes of each box relative to its parents in percentages.
the height andwidth of nonroot nodes simply assume the relheight andrelwidth values computed previously by module c ompute relative .
the root and non block nodes assume of their parent s size.
this allows the root node to resize with the browser and all other nodes resize automatically due to their relative sizes.
however fluid sizes are not sufficient for handling flexible elements with text which may overflow its container on resizing.
encoding flexible elements which respond to both font and viewport changes gracefully is non trivial.
note that to obtain fluid layouts it is sufficient to specify the relative size of a child cas above i.e.
child size depends only on the parent size upward dependency .
however in an elastic layout sec.
the size of calso depends on the text font size for c i.e.
cmust grow as the font size increases.
consequently the size of all the ancestors of cnow also depends on the size of c downward dependency .
if we enforce only a fluid layout i.e.
the contained text may overflow the boundaries of the child on font size increase.
on the other hand if c s and its ancestors size dependent solely on the font size e.g.
by setting the size to auto thencand its ancestors may expand or shrink to an undesired size depending on font size changes.
having both fluidity and auto constraints is not possible because it introduces a circular dependency between cand its ancestors.
we therefore have to carefully balance the upward and downward dependencies to obtain a desirable layout.
our key insight here is that by constraining only the width of the elements relative to their parent we can keep the flexible elements and their ancestors unconstrained while ensuring fluidity of the overall design.
the height of flexible elements is left unconstrained or minimally constrained if required so that they can adapt to convert non block leaves to blocks b1 child c n b canmakeblock n mayhaveblockchildren n canmakeblock c b b2 leaf n t ishtmlblockelement n canmakeblock n n toblk true b3 canmakeblock root t true mark elements flexible fe1 hasflexsize n n isflex true fe2 child n p n isflex p isflex true encode hvboxes using float fo1 hbox n n over ow hiddenchild c n f hbox n ?left none c oat f fo2 offset and size relative to parent cr1 root n t n topr n y n parent yn leftr n x n parent x cr2 n rightr n leftr n width n bottomr n topr n height n relheight n height n parent height n relwidth n width n parent width encode margins in css m1 childk c n o cssobj c o margin top n topr n width o margin left n leftr n width m2 childk c n i i chn n childk cp n i hbox n c immt c topr c imml c leftr cp rightr m3 childk c n i i chn n childk cp n i vbox n c immt c topr cp bottomr c imml c leftr m4 childk c n i i chn n o cssobj c o margin top c immt n width o margin left c imml n width o margin f f2fbottom rightg m5 n toblk o n css o margin s s2ftop left bottom right g encode fluid height width in css sf1 o cssobj n n6 root t o height n relheight o width n relwidth sf2 n toblk n root t o n css o f f2fheight widthg encode elastic fluid height width sfe1 child c n o cssobj c n isflex c isflex o height c relheight o width c relwidth sfe2 child c n hbox n n isflex c isflex o cssobj c o width c relwidth sfe3 child c n hbox n n isflex c isflex o cssobj c o min height c height px o width c relwidth sfe4 child c n vbox n n isflex c isflex o cssobj c o min height c height px o min width c relwidth figure .
rules for css encoding.
variables c cp nrange over nodes of the layout tree t. chn n number of children of n child c n childk c n i holds ifcis some child ithchild ofnint.
hbox n or vbox n holds ifn.box hbox vbox .
to keep brevity we concatenate numeric and string expressions in javascript style.viewport and font changes.
to encode this cf.
fig.
we add rules sfe1 and remove the earlier rule se1 which assigns fluid constraints naively.
for a flexible child cof an hboxn sfe2 we therefore only set its relative width leaving height unconstrained.
for a non flexible sibling c0ofc sfe3 we constrain the minheight ofc0to its mockup given height in pixels.
this prevents c0from shrinking to an undesired size.
ideally max height forc0 should also be set but it wasn t required for our benchmarks.
ifnis a vboxn we leave the flexible element size fully unconstrained but we constrain the min height and min width of its nonflexible siblings rule sfe4 .
recall that m argin fluid module assumes that fixed relative height width of children with respect to its parent which does not hold now.
so we also modify rule m4 to compute bottom right margin values for all children of a flexible hbox vbox and right bottom margins for the last hbox vbox child rules not shown to save space .
we believe our rules provide an elegant solution which avoids circular dependencies as well as achieves elastic and fluid layout.
font properties.
for the ui elements with specific font size and line width properties a separate module encodes these font properties in relative notation by using percentages.
this allows changing the font properties throughout by making a single change at the top level body element without losing the correlation between the font sizes of different elements.
code generation.
the html code is generated by recursively traversing the layout tree and each element is assigned a unique class name.
wrapper divs are introduced around flexible leaves.
css code is generated for each element using its identifier as the selector followed by its css properties e.g.
height width oat margin computed using the rules above.
a normalizing css style file is added in the beginning for ensuring cross browser compatibility and setting properties like padding margin and border values to wherever necessary.
identical css annotations for different html elements are also grouped together in a single css class.
extensibility.
our the encoding framework is modular and each module can be refined independently without affecting other parts of the encoding as long as the interfaces remain the same.
for example we could easily refine rules from module s ize fluid to handle elasticity without modifying the overall flow.
multiple implementations of the same module can co exist and selected by the designer on demand e.g.
m ark float can be implemented differently using dummy divs and clear .
modularity also enables fine tuning our encoding for issues specific to ui elements or browser behaviors.
.
additional implementation challenges rounding.
rounding errors during multiple margin and size calculations can cause the child content to overflow its parent.
to avoid this we truncate all values to one decimal position.
for handling images with elastic layout we set both their width andmax height to of the wrapper box and do not set the height property.
some more optimizations are possible e.g.
if a node has a single child we can use margin auto text align center properties to center the child.
moreover we can float hbox children to right if necessary during margin computation and then constrain right instead of left margins.
user guidance.
our automated layout inference approach may not be always successful in computing a correct html css encoding due to a number of reasons.
for example the mockup may be ambiguous cf.
1a 1d in fig.
and not capture the designer intent fully such that there may be multiple valid merge choice sequences and therefore multiple feasible layouts.
consequently our hvbox inference algorithm may not infer the layout desired by the user.
different or non standard implementations of css standards may also cause problems.
in such cases user guidance is required.
our tool enables the user via configuration files to guide the layout inference and encoding for a particular design e.g.
specify groups of elements which must be merged or must not be merged.
thetool provides multiple other options to enable user guidance float clearing mechanism fix body height in pixels or percentage specify elements with fixed size in pixels use a fixed max width for textcontaining boxes and whether to automatically center a box if it is the only child.
moreover we can allow the user to fix other style properties e.g.
position z index in the wysiwyg editor these values will be retained in the final design and override the tool computed values in case of conflict.
browser incompatibilities.
our encoding relies on a small set of css idioms to maximize cross browser compatibility.
further to get rid of the well known browser inconsistencies due to css we prepend a normalizing stylesheet to each generated mockup.
still the pages may not display correctly in all browsers especially the older ones e.g.
because the browser does not implement the css2.
standards correctly or completely.
in such cases based on browser detection we can fall back to fixed layouts which display correctly in most browsers e.g.
we can use css conditional comments to detect older versions of the internet explorer ie browser and apply different css rules to correctly display the page.
we believe that this is a reasonable compromise to support legacy browsers in the face of rapid adoption of newer browsers supporting css2.
standards to a large extent and even css3 substantially and modern markup technologies.
finally we note that browser compatibility cannot be guaranteed statically and needs testing specific to targeted browsers.
nevertheless our tool saves considerable manual effort in page design by automating layout inference and html encoding systematically.
our framework being modular and systematic can also be re targeted to other existing or new technologies as they arrive.
we have also provided the designer several knobs to tweak the designs to match the user intent as well as deal with limitations of css.
also we observe that many hurdles of crossbrowser compatibility and limited css2.
expressivity will be overcome once css3 is standardized and all browsers support it fully.
overlapping boxes and dynamic layouts.
recall that our framework discards the overlapping boxes before inferring layout.
in most cases we observed that the designers intend these boxes to be located at a fixed position relative to the viewport.
therefore we add these boxes back to the design at the original fixed positions with original sizes using position property.
we do not support dynamic rearrangement of layout as of now.
however our float based encoding of hboxes together with min width values partially overcomes this drawback if the viewport size is too small children of hboxes will rearrange automatically to the next row.
css3 is an in progress standard for styling web documents and contains much better support for specifying hvboxes and relative layout than css2.
.
however the standard is still in flux and different web browsers support it to different degrees.
our modular encoding framework can be reused for css3 also by instantiating the modules with css3 specific rules many of which do not change.
further our mockup based compilation approach allows transparent extension to generate css3 code behind thescenes without burdening the designer.
.
tool architecture and evaluation we implemented and evaluated our approach using an open source mockup builder maqetta being developed at ibm.
maqetta supports design of mockups of both desktop and mobile applications by dragging and dropping ui elements on the editor canvas specifying css properties for user elements.
maqetta generates html on thefly when mockup is drawn.
it provides two kinds of default layout modes flow andabsolute for designing applications.
in flow layout the elements are placed vertically one after another.
to align elements horizontally the designer must specify it using css floats manually.
in the absolute layout the elements are fixed to specific coordinates thus allowing arbitrary placement of ui elements on a web page.
however maqetta generates a fixed layout where elements do not respond to change in viewport sizes as we desire.
drawn neighbors inf.
boxes min.
boxes inferred attributes file size kb benchmark boxes merge set tree ht.
tree ht.
float overflow height width margin html css master detail .
.
column .
.
search .
filter .
form .
.
canvas .
dashboard .
spreadsheet .
.
wizard .
qa .
.
parallel .
.
interactive .
.
table .
tool statistics for the benchmarks in table .
see analysis in sec.
.
.
benchmark description master detail navigate the items of the master menu and view the details on the same screen column hierarchical tabular data navigation search display search results for a particular query filter refine data search results further form standard form ui canvas canvas object for drawing graphics dashboard show aggregated information at a glance spreadsheet view and edit tabular information wizard guides user through a complex work flow qa select among multiple choices and view answer parallel view inventory list of similar items interactive combination of forms with result display table .
benchmarks corresponding to standard ui patterns.
our tool takes an input a maqetta mockup specification drawn in absolute layout mode and generates a faithful replica of the mockup in html css which has a relative layout.
the designer specifies only the key ui elements constituting a web page without worrying about the enclosing boxes which determine the page layout.
the height width and position of the elements along with margins and the relative alignment of elements are extracted from the visual design and need not be specified separately.
the designer however needs to specify properties like padding and border widths for the elements separately which are hard to specify visually.
our tool is wholly implemented in javascript both on the client side maqetta and server side node.js application .
the mockup in maqetta is serialized and transmitted to the server which processes it infers layout encodes it to html css and dumps the corresponding html css files to the disk.
we modified the maqetta source to add a button clicking the button serializes the mockup to json and sends it to the server using an ajax call.
note that our back end can also be moved into the browser for creating layouts if necessary.
.
evaluation to show that our encoding is effective we require benchmarks covering the wide array of possible web designs.
unfortunately no representative benchmark set exists to evaluate a tool like ours.
selecting designs from the top alexa pages does not make sense because they are in no way representative of the possible web layouts.
therefore we constructed a benchmark set consisting of web pages which capture various representative design patterns found across web.
we used multiple popular design sites including yahoo!
design pattern library and ui patterns.com to collect these benchmarks and curated them manually to avoid similar or duplicate patterns.
table.
shows the representative patterns and their descriptions.
we drew mockups corresponding to these patterns in maqetta and performed layout and code generation for them.
note that these designs closely imitiate real websites and are quite complex and hence may contain up to a few hundred elements.
obtaining correct fluid elastic layouts needed a couple of iterations the encoding procedure had to be refined multiple times before we got it correct.
we verified the correctness of the generated encodings using firefox mac figure .
incorrect box merge during layout inference.
snow leopard .
.
windows chrome mac snow leopard .
.
win and ie9 win .
we also used browser tools to visualize the output for different form factors.
our tool takes only a few seconds to encode each benchmark and all the encoded files represent faithful replicas in html of the original mockups.
as opposed to the fixed layouts generated by maqetta the generated designs are fluid i.e.
they resize with the browser cf.
fig.
gracefully.
moreover they are elastic i.e.
the boxes containing text expand or shrink based on font size changes without destroying the overall fluidity of the design.
analysis.
table shows details of the benchmarks and their encoding in html.
the first column shows the number of user drawn ui elements boxes which vary between to for our benchmarks.
although the number of neighbors nearby elements for boxes may go up to the set of mergeable neighbors merge set cf.
alg.
remains small or because the merged elements quickly begin to overlap.
this reduces the merge choices and enables the algorithm to converge fast.
the third column shows the total number of boxes after layout inference and the layout tree height cf.
fig.
the fourth column shows the same values after compaction cf.
alg.
.
compacting the tree is essential it removes a large number of redundant boxes introduced by the layout inference and reduces the tree height significantly thus reducing the size of the final html css code.
the next five columns show the number of attributes computed for layout and size spacing.
the most benefits in terms of designer effort reduction is due to these attributes in particular height width and margins.
note that in absence of our tool the designer will have to make careful calculations of relative size and margin values to obtain fluid layouts.
besides she will need a deep understanding of bfcs and floats to encode the hvbox layout correctly.
also note the difference between number of height and width attributes computed.
in order to obtain elastic layouts sec.
.
our tool omits constraining the height wherever possible however widths are always constrained to ensure fluidity.
with our tool the designer need not put in additional effort to ensure the balance between fluidity and elasticity.
layout inference.
we did not encounter any conflicts in these benchmarks during layout inference because implied merging cf.
alg.
often avoids them successfully.
however an incorrect set of elements were merged together sometimes e.g.
in fig.
instead of merging all the checkbox label pairs in a single vbox the algorithm merges the label i am currently with the top checkboxlabel pair.
to solve this we provide manual guidance sec.
.
by marking the checkbox label pairs to be merged.
while such manual effort is unavoidable in general hard to obtain unambiguous mockups better symmetry detection heuristics will avoid this effort.fine grained tweaks.
most of the encodings generated by our tool are high quality replicas of the original mockup.
also they adapt gracefully on reducing the viewport size or increasing font size columns shrink in width as viewport size reduces while the text splits into multiple lines to accommodate the smaller width.
owing to complexity of css and incompatible implementations a few finegrained issues remain.
in some cases filter master detail thebutton does not fill its wrapper div element see m akeblock this is fixed by setting the min height of the button in pixels and removing the min height constraints from its parent wrapper.
same fix is applied for the html select elements also.
these fixes make the designs less fluid but they are unavoidable with the current less expressive css standards.
to obtain correct image sizes setting the max height of the image to is not sufficient in some cases.
then we also fix the image wrapper s height in pixels.
input elements e.g.
checkbox or radio buttons do not align properly in some cases.
this is solved by removing the constraints height width relative to their wrapper divs.
in some cases we want the child element to fill the parent div even if the latter s size is not specified.
this is fixed by adding padding to expand the child.
note that these fine grained refinements can be also included as special rules invoked under user guidance in our extensible framework.
single word labels begin to overlap with other elements on resizing to small widths.
finally making the viewport too small or the font too large may distort the design requiring dynamic layouts.
in spite of these issues our experiments demonstrate that high quality flexible layouts can be indeed obtained automatically from mockups with minimal manual effort.
experience with drawing mockups.
drawing a mockup took the authors about an hour on average.
note that the authors are not experts in ui design or maqetta we believe experts may be able to draw mockups faster.
a few time consuming factors were setting color border and font properties obtaining images aligning elements inside a parent box or keeping them equi distant.
some of these issues can be improved in our tool by allowing a tolerance during size calculations and better symmetry detection both of which are part of our planned tool improvements.
we believe that in absence of our tool a few hours of additional manual effort would be required per mockup to align size and layout elements properly.
.
related work automated document formatting has been studied extensively see for surveys and most approaches model the problem as a constraint optimization problem.
much work has focused onmicro typography specific to text dominated documents cf.
e.g.
.
for macro typography i.e.
layout of objects constraintsolving based methods are used they take input alignment constraints between ui elements their sizes etc.
as input and solve these constraints to output a layout i.e.
coordinate values of each ui element on the canvas.
the work in uses constraint solving to generate multiple mockups similar to the original one.
all these methods infer pixel locations of ui elements as opposed to inferring a regular box grid structure in which the elements can be embedded.
the latter problem which is our focus is completely different from the earlier one techniques for solving the earlier problem do not apply here.
moreover constraint solving based methods assume a dedicated layout engine and cannot use an off the shelf browser for layout directly.
instead our goal is to leverage the browser s layout engine fully with no augmentations.
several javascript based engines perform dynamic layout inside the browser however using js for layout unnecessarily burdens the application and fails to exploit the native layout engine.
the limited expressivity as well as complexity of css for web design is a known problem .
the work in emphasizes the necessity of debugging tools for css and proposes solutions to assist css development in authoring tools while propose compilation from more expressive style languages to css to improve productivity and avoid bugs.
none of these ap proaches however infer css layout rules from visual descriptions.
constraint cascading style sheets augment css with expressive arithmetic constraints relating sizes of elements and font sizes but require a modified browser layout engine for supporting it.
techniques to assist css based development by eliminating redundant css rules or by performing sophisticated property checking and coverage analysis for css rules have been proposed.
modern wysiwyg editors allow convenient css authoring with drag and drop features and employ their own layout engines to enable page visualization.
however they generate only fixed or non hierarchical layouts automatically.
complex layouts must be specified manually by the designer.
some tools now enable grid based design also however additional manual effort is required to make these designs elastic and fluid simultaneously.
rectangular partitioning see for a survey has been studied extensively.
many of these problems reduce to covering problems where boxes may be reordered to minimize cost.
in contrast boxes may not be reordered in our setting.
computing an optimal hvbox layout is an instance of the problem of hierarchical binary tiling whose complexity is polynomial in the grid size but with a high exponent value.
therefore instead of adopting the usual dynamic programming solution we propose an efficient backtracking based procedure which consumes less memory and tries to find one solution instead of the optimal one.
guillotine partition for table layout has been investigated in using dynamic programming.
our work obtains a partition for arbitrary set of boxes on a canvas not just tables .
the work in uses machine learning to transfer page layout and design from one page to another.
popular content management systems cmss e.g.
drupal or wordpress natively provide the designer with a set of fixed layout templates to create pages.
many systems e.g.
zengrids allow grid based fluid layout specification using modern css extensions .
a few cms plugins e.g.
sasson for drupal enable flexible layouts in the cms again based on re sizing grids.
such frameworks however require user to explicitly fit the contents into the grid by specifying the location and the number of grids taken by a box.
further they require learning new styling primitives of the framework.
in contrast with our tool the user can freely draw ui elements in a wysiwyg editor while our tool takes care of the relative layout completely.
further to our knowledge no tool infers a hierarchical layout from the mockup which captures local flow of elements besides their relative size spacing.
.
conclusions we presented a method to systematically encode mockups drawn in a wysiwyg editor into flexible fluid and elastic layouts.
our method first infers a hierarchical hvbox layout for the mockup and then encodes the layout with modular rules into html css.
we believe that ours is the first disciplined effort to solve the challenging problem of automatically encoding mockups in html css.
the ability to generate flexible html encodings from mockups automatically will allow quicker development of the application for multiple devices at once besides reducing the learning curves among novices.
we do not generate fully dynamic layouts currently future work will build upon the current framework to obtain such layouts possibly with more involved constraint solving.
our modular framework can also be extended to generate optimized cleaner css using modern css extensions .
we also plan to augment maqetta to enable user feedback directly in maqetta as opposed to using a textual configuration file and carry out usability surveys.
we believe that automated compilation will enable the tool to exploit evolving technologies including improved layout techniques e.g.
css3 sass and re enable adoption of mockup based ui development.