angelic debugging satish chandra ibm research satishchandra us.ibm.comemina torlak ibm research etorlak us.ibm.comshaon barman uc berkeley sbarman cs.berkeley.edu rastislav bodik uc berkeley bodik cs.berkeley.edu abstract software ships with known bugs because it is expensive to pinpoint and fix the bug exposed by a failing test.
to reduce the cost of bug identification we locate expressions that are likely causes of bugs and thus candidates for repair.
our symbolic method approximates an ideal approach to fixing bugs mechanically which is to search the space of all edits to the program for one that repairs the failing test without breaking any passing test.
we approximate the expensive ideal of exploring syntactic edits by instead computing the set of values whose substitution for the expression corrects the execution.
we observe that an expression is a repair candidate if it can be replaced with a value that fixes a failing test and in each passing test its value can be changed to another value without breaking the test.
the latter condition makes the expression flexible in that it permits multiple values.
the key observation is that the repair of a flexible expression is less likely to break a passing test.
the method is called angelic debugging because the values are computed by angelically nondeterministic statements.
we implemented the method on top of the java pathfinder model checker.
our experiments with this technique show promise of its applicability in speeding up program debugging.
categories and subject descriptors d. .
testing and debugging general terms testing debugging validation keywords angelic non determinism debugging symbolic execution tests .
introduction software producers often ship code with known faults that are deemed too expensive to fix and unlikely to occur in practice.
isolating causes of these faults from failing tests is a labor intensive process with considerable costs.
given that compute cycles are abundant and inexpensive judicious use of automation for fault permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.isolation could greatly improve software quality as well as reduce costs.
in this paper we propose a computer assisted debugging methodology in which value based reasoning is used to identify plausiblerepair candidates in a faulty program.
we consider only those faulty programs in which the defect can be repaired by altering at most one expression.
a repair candidate is an expression that can be modified to correct the failing test s without breaking any passing tests.
in principle we could identify repair candidates by exploring a subset of valid syntactic variations of all expressions in the program.
this however tends to be too computationally demanding in practice.
our idea is to approximate syntactic changes with value changes.
instead of checking if the program can be fixed by replacing an expressionewith some expression e0 we check whether a failing test can be repaired by replacing the value vofewith some value v0.
ifv0fixes the test we assume it is possible to find an expression e0that evaluates to v0.
if no suchv0exists we can filter out efrom the set of repair candidates.
of course the value replacement check based only on a failing test may not be able to filter out repair candidates that could break some of the passing tests.
our approach takes into account the effects of repairing einpassing tests as follows if eevaluates tow in a passing test but the same test continues to pass if wis replaced with a value w06 w then we have a level of confidence that ecan be replaced with a syntactically different expression e0 as we shall see later this is an approximate test .
in summary if replacing an expression ewith a value vfixes the failing test then repairing ehas the potential to fix the failing test.
if replacing ewith a value vdifferent than ecomputes does not break a passing test then we have some freedom to change e we say that it is flexible and a good repair candidate.
our methodology is called angelic debugging and comprises the following steps .
the programmer based on intuition observation of runtime logs or feedback from fault localization tools e.g.
tarantula demarcates a scope in the code where he believes the defect might lie.
by selecting a scope the programmer expresses the hypothesis that altering some expression within the scope can resolve the bug.
.
the computer tries to validate this hypothesis.
it automatically examines all expressions in the scope to find plausible repair candidates.
for each such candidate the computer demonstrates the existence of one alternative value that would have rescued the failing test case.
.
the computer then factors in information from any passing test cases to automatically eliminate inflexible repair candi 1public int classify inta intb intc intretval if a b b c if a c b c if a b a c retval equilateral else retval isosceles else if a a !
b b c c if a a b b c c retval acute else retval obtuse else retval right else retval illegal return retval figure triangles example from demillo .
dates.
a repair candidate is inflexible if changing the candidate expression can rescue a particular failing test but any change would break one of the previously passing tests.
if all repair candidates are eliminated in this step then the programmer has either not chosen the scope correctly or there is indeed no fix to the program that can pass all test cases.
.
the programmer attempts to devise a suitable replacement expression for each of the remaining repair candidates one at a time until one works.
a successful replacement expression must give passing results on the hitherto failing input as well as on the previously passing inputs.
the search for such a replacement expression is not computer assisted as the space of possible syntactic expressions is unbounded.
however the programmer can draw inspiration from the sample alternate value demonstrated by the second step.
example .consider the code in figure .
it is a slightly modified version of an example from the paper by demillo et al.
on mutation testing.
the program takes as input the lengths of three sides of a triangle presented in non decreasing order and it is supposed to classify the triangle as one of equilateral isosceles right angled acute or obtuse.
table shows eight sample inputs to the program also taken from the demillo paper.
the code works correctly for inputs t1t7 but not for t8.
suppose the program is known to be fixable in the specific sense that there is a single expression that if altered will let all of the test inputs pass.
it is the task of the programmer to find the faulty expression and repair it.
in the first step the programmer has to hypothesize a scope.
we assume that the entire program is in scope.
in the second step the computer figures out the repair candidates for the failing test t8.
these are shown in table .
each repair candidate could have salvaged this particular execution by evaluating to a different value than it did.
the column titled alt value lists the alternate value that would have made t8 pass.
for example the first row in the table says that if the value were to be produced in place of the high lighted expression a whose runtime value is t8 would pass.
for brevity we have considered only reads of local variables and constants but there is no conceptual reason to exclude arithmetic and logical expressions e.g.
the result of a c .
among the kinds of expressions considered these are the only possible repair candidates.
the third step uses the passing test cases to filter out the inflexible repair candidates leaving the right choice and one wrong choice.
this is shown in the last column of table .
for example the last row says it is no good changing the value of acute at line to isosceles so will rescue t8 but break test t6 whose only correct outcome is in fact acute .
this much would be obvious to a programmer.
the other two choices that our technique eliminates from consideration on the basis of test t3 may not be immediately obvious.
given the information in table a programmer would consider each of the remaining two candidates in turn and try to find a syntactic replacement that produces an acceptable value for t8 and moreover works for all the other test cases t1 t7 as well.
note that the concrete values that our technique suggests are specific to t8.
of these two candidates the first choice is in fact futile but we cannot get that information from the passing tests.
the second choice is the real bug it should be bin place of c. we call our methodology angelic debugging because it relies on angelic nondeterminism.
imagine that an expression is replaced with a call to an oracle that returns a value chosen nondeterministically.
the oracle is both omniscient and co operative in the sense that if a suitable value exists one that makes the failing input now pass the oracle is guaranteed to return it.
while supporting angelic nondeterminism is computationally expensive it is becoming increasingly viable for selective use thanks to recent advancements in decision procedures.
in our case angelic non determinism is used only on one expression at a time.
this limits the kinds of defects on which our technique is effective but enhances computational feasibility.
nondeteminism has long been used in testing to create an adversary a demonic oracle but its use as an ally is less common.
a key novelty in this work is in how we use information from passing tests to filter out repair candidates that will not work out.
while the programmer still needs to go through the laborious task of finding replacement expressions for multiple repair candidates he does not need to carry out the sisyphean effort in looking for replacement expressions for repair candidates that are doomed by another test case.
without first positing a replacement expression he would not know whether it would work out or not and the space of replacement expressions can be huge.
previous work on fault localization that has leveraged information from a suite of passing tests has relied on indirect information.
the basic idea is that a failing run has an anomalous behavior in test a b c expected outcome t1 illegal t2 right t3 isosceles t4 equilateral t5 obtuse t6 acute t7 illegal t8 isosceles actual outcome acute table inputs for fig.
1line code alt value t8 inhibitor 4if a c b c 4if a c b c 4if a c b c t3 4if a c b c t3 retval acute isosceles t6 table repair candidates for fig.
.
some regard when compared to passing runs.
the anomaly in behavior could be executing statements that are rarely if ever executed by passing tests or it could be violating invariants that have been discovered to hold during passing executions.
this information while useful in fault localization does not directly answer the question can i change a specific expression?
we believe that for debugging applications this is the more important question.
we have built a tool a ngelina that supports angelic debugging.
it has been built on top of the j ava pathfinder model checker .
a ngelina accepts as input a java program a failing test case and a suite of passing test cases.
the default scope is the entire program but a programmer can specify scopes at various granularities a class file a method or a range of lines.
a ngelina outputs information of the kind shown in table .
a ngelina takes no specification or annotation it bases its findings only on the input mentioned above.
remarkably a ngelina not only finds faulty arithmetic and logical expressions but also faulty heap