what good are strong specifications?
nadia polikarpova carlo a. furia yu pei yi wei bertrand meyer y chair of software engineering eth zurich switzerlandyitmo national research university st. petersburg russia firstname.lastname inf.ethz.ch abstract experience with lightweight formal methods suggests that programmers are willing to write specification if it brings tangible benefits to their usual development activities.
this paper considers stronger specifications and studies whether they can be deployed as an incremental practice that brings additional benefits without being unacceptably expensive.
we introduce a methodology that extends design by contract to write strong specifications of functional properties in the form of preconditions postconditions and invariants.
the methodology aims at being palatable to developers who are not fluent in formal techniques but are comfortable with writing simple specifications.
we evaluate the cost and the benefits of using strong specifications by applying the methodology to testing data structure implementations written in eiffel and c .
in our extensive experiments testing against strong specifications detects twice as many bugs as standard contracts with a reasonable overhead in terms of annotation burden and run time performance while testing.
in the wide spectrum of formal techniques for software quality testing against strong specifications lies in a sweet spot with a favorable benefit to effort ratio.
i. i ntroduction many years of progress in the theory and practice of formal methods notwithstanding writing software specifications1still seems to be disliked by almost everyone .
in many cases this disliking is a consequence of a high cost benefit ratio perceived or real of writing and maintaining accurate specifications on top of the code.
after all developers will write specifications as long as they are simple have a straightforward connection with the implementation and help them write and debug code better and faster.
one example is design by contract where simple executable specifications written in the same syntax as programming language expressions support design incremental development and testing and debugging.
another one is test driven development where rigorously defined test cases play the role of specifications in defining correct and incorrect behavior.
experiences with these techniques show that providing lightweight specifications is an accepted practice when it brings tangible benefits and integrates well with the overall development process.
but what about strong specifications which attempt to capture the entire functional behavior of the software?
should we dismiss them on the grounds that the effort required to write them is not justified against the benefits they bring in the majority of mundane software projects?
this paper studies the impact of deploying strong behavioral specifications in the form of contracts pre and postconditions and class invariants for detecting errors in software using automatic testing.
1in this paper we target formal specifications of functional properties.using strong contracts involves costs and possible benefits.
among the former we have the programming effort necessary to write such strong specifications and the runtime overhead of checking them during execution.
the benefits may include finding more errors finding more subtle errors finding errors more quickly and exposing errors in ways that are easier to understand and correct.
our contributions address the cost factors by measuring and trying to mitigate them and assess the benefits sect.
iii presents a methodology to write strong specifications extending our previous work that does not require fluency in formal techniques because it is an extension of such traditional practices as design by contract.
this is instrumental in reducing the programming effort associated with strong specifications.
the methodology comes with tool support and specification libraries so that strong specifications are usable with standard debugging and testing tools.
sect.
iv and v describe an extensive empirical study that evaluates the use of strong contracts for real software and measures their costs and benefits in terms of defect detection.
the bulk of our empirical study targets eiffelbase a library of generic containers and data structures such as lists tables and trees which has been in use in the eiffel community for more than years.
the production version of eiffelbase includes simple contracts a form of partial specification that are nonetheless quite effective at finding implementation bugs automatically using contract based random testing where executable contracts serve as oracles and enable a push button testing process.
in the present paper we augment the simple contracts that come with eiffelbase using the methodology discussed in sect.
iii.
the result is eiffelbase a version of eiffelbase with identical implementation but strong mostly complete specifications.
in an extensive set of experiments we compare the effectiveness of random testing on eiffelbase and eiffelbase with the goal of assessing whether the additional effort invested into the strong contracts pays off in terms of quantity and complexity of the bugs found.
our experiments show that these measures dramatically increase when deploying strong specifications random testing found twice as many bugs in eiffelbase and the simple contracts of eiffelbase would have uncovered none of the new bugs.
the overhead size of specifications in contrast remains moderate with the specification to code ratio going from .
to .
.arxiv .3337v4 feb 2013merge right other linked list require notafter other6 void other6 current ensure count oldcount oldother .count index oldindex end table i standard specification of routine merge right inlinked list .
our approach to writing strong specifications that are effective for testing is not limited to eiffel programs.
in a companion set of experiments we applied the same technique to writing strong specifications for the dsa c library and tested the result using pex in this case too we discovered new bugs with reasonable additional effort.
ii.
s trong specifications anexample the following example illustrates and justifies the use of strong specifications.
consider the eiffelbase class linked list eiffel s standard implementation of linked lists.
like many containers in eiffelbase linked list includes an internal cursor to iterate over elements of the list.
the query2index gives the cursor s position which can be on any element of the list in positions through count or take the special boundary values before the list and count after the list .
the attribute count denotes the number of elements in the list.
tab.
i shows the eiffelbase specification of linked list s routine method merge right.
the routine inserts another list other passed as argument into the current list denoted current in eiffel corresponding to thisin java and c immediately after the cursor position.
for example if current stores the sequence of elements b a r twith cursor positioned on the r index and other stores o n e merge right changes current tob a r o n e t. the precondition require specifies that the routine cannot be called when the cursor is after there is no valid position to the right of it.
it also demands that other be non void nullin java and c and not aliased with the current list otherwise merging is not well defined.
the postcondition ensure describes some expected effects of executing merge right the current list will contain as many elements as it contained before the call to merge right denoted by oldcount plus the number of elements of the other list and the cursor s position index will not change.
the contracts in tab.
i are a good example of the kind of specification that eiffel programmers normally write it is correct and nontrivial and it can help detect errors in the implementation such as performing partial merges or incorrectly leaving the cursor at a different position.
unfortunately the specification is also incomplete because it does not precisely describe the expected state of the list after merging.
in fact the current implementation of merge rightcontains an error that is undetectable against the specification of tab.
i. the error 2aquery is an attribute or a function .merge right other linked list require as in tab.
i modify sequence ensure sequence old sequence .front index other .sequence sequence .tail index end table ii model based specification of routine merge right inlinked list .
occurs in the special case of calling merge right with cursor before the list index the implementation will insert other at the second rather than at the first position.
for example merging f o l dand u nwhen the cursor is before yields f u n o l d instead of the correct u n f o l d. sect.
iii presents a methodology to write with moderate effort strong specifications that extend and whenever possible complete this kind of partial specification.
tab.
ii shows the strong specification obtained by applying the methodology to merge right the way it appears in eiffelbase .
as is common in most eiffel projects the programmer who wrote merge right did a good job with the precondition which is sufficiently detailed and need not be strengthened.
the postcondition however turns into a single assertion that defines the sequence of elements stored in the list after calling merge right as the concatenation operator of three segments current s original sequence up until position index written sequence .front index followed by other s element sequence followed by the original sequence from position index written sequence .tail index .
this postcondition relies on an abstract model of the linked list in the form of a mathematical sequence of elements which was already implicitly present above in the informal description of the semantics of merge right.
models blend well with eiffel s standard specification constructs to help formalize programmers intuitive understanding of data structures semantics.
using the strong postcondition in tab.
ii completely automatic testing with the autotest tool detected the error that occurs in merge right when the cursor is before .
the postcondition in tab.
ii describes how the sequence changes but it does not say what does not change .
including the assertion index oldindex from the original postcondition is not sufficient as it only mentions one piece of state that does not change.
instead we include the assertion modify sequence which means that merge right may only modify the sequence of elements in the current list and nothing else .
together pre postcondition and modify clause give a complete specification ofmerge rightbehavior against which we can automatically test any implementation for correctness.
iii.
h ow to write strong specifications writing good specification is hard at least this is the common belief.
experience with design by contract suggests that programmers can competently write simple specifications if they can be expressed using familiar syntax.
see for examplethe specification in tab.
i which refers to regular class queries such as count and index also used in the implementation.
without further guidance and language support however programmers tend to write only partial specifications because expressing complex properties is cumbersome.
this section describes model based contracts mbc a methodology to write strong specifications that structures and extends traditional design by contract.
mbc includes simple guidelines to define the abstract model of a class sect.
iii a and to write pre and postconditions of routines sect.
iii b and iii c and other more advanced specification elements sect.
iii d and iii e .
the mbc approach supports writing strong specifications in a number of ways models facilitate choosing the right level of abstraction and expressing complex behavioral properties concisely while the structured discipline for writing postconditions and invariants together with the notion of completeness sect.
iii d provides precise guidelines as to which properties are worth documenting in a contract and when a contract is strong enough.
while fostering rigor and accuracy in specifications mbc is still palatable to practitioners because its notation is part of the programming language.
when developing specifications for testing as opposed to formal verification mbc can be exploited incrementally developers may skip writing the most advanced specification elements for example complex class invariants while still getting strong specifications that are useful to detect subtle errors.
the following subsections present mbc using examples from eiffelbase.
the few additional constructs introduced by mbc are highlighted in a different color and underlined in the examples e.g.
modify .
the current presentation of mbc derives from previous work of ours which focused on using strong specifications when designing new software.
in this paper we adapt the principles introduced in to the goal of supplying existing software with flexible strong specifications for runtime checking and automatic testing see sect.
iii f .
we also extend the specification methodology with new construct that handle framing sect.
iii d and complex class invariants sect.
iii e .
a. abstract class models writing strong specifications becomes simpler if we can readily express the abstract state space of classes and how it changes.
therefore the first step in specifying a class with mbc is defining a model for the class a set of mathematical elements that capture the abstract state space.
syntactically the annotation model see tab.
iii declares the abstract model of a class as a list of attributes or functions called model queries each element listed after model is either a query of basic type boolean integer or object reference already used in the implementation or a specification query meaning a query introduced solely to define the model.
as part of our work on mbc we developed the mathematical model library mml a collection of immutable eiffel classes that represent mathematical concepts useful for specification sets bags sequences maps and relations.
specification queriesclass linked list model sequence index sequence mml sequence status specification specification query sequence of elements in the list.
index integer internal cursor position.
off boolean is the cursor not on a list element?
ensure result notsequence .domain .has index end invariant model constraint index and index sequence .count attribute definition count sequence .count linking invariant bag sequence .tobag internal representation constraint notsequence .isempty implies last cell.item sequence .last end table iii excerpt of linked list smbc specification in eiffel base .
make use of mml classes to represent complex components of class models.
for example linked list s model in tab.
iii has two components a specification function sequence with return type mml sequence that gives the abstract sequence of elements stored in the list and the ordinary class attribute index of integer type.
class models should be expressive enough to formalize the class behavior as seen at the api level without exposing implementation specific details.
for example the same abstract model a sequence of elements is suitable for all three implementations of lists in eiffelbase singly linked doublylinked and array based as the particular representation does not influence the functional properties of public routines.
in practice it is usually easy to devise a model for a data structure using mml abstractions.
even for classes representing complex real world concepts such as an atm or a flight scheduler mml remains applicable if used incrementally to define partial yet useful behavioral properties.
b. preconditions theprecondition of a routine defines when a call to the routine is valid.
in practice preconditions appear to be the most widely and accurately used form of contract .
therefore mbc does not introduce special guidelines for writing preconditions.
c. postconditions thepostcondition of a routine rdescribes the intended effects of executing ron the object state it is a relation between the state just before denoted using the keyword old and the state just after executing r.mbc postconditions express the intended effect of executing a routine on the model that is in terms of the model queries.
procedure merge right in tab.
ii for example declares its effect on the model query sequence of the current object.
for functions the postcondition also mentions the returned object and its model queries using the keyword result .
for example function offin tab.
iii defines result in terms of sequence and index.
d. framing specification an accurate routine specification should limit the effects of the routine execution to a certain part of the program state.
such specification elements are called framing specifications .
eiffel offers no dedicated language support for writing framing specifications.
in principle this support is not strictly necessary because one can express the unchanged elements in postconditions with expressions such as index oldindex in tab.
i. in practice however this is cumbersome because any given routine usually affects only a handful of program elements hence explicitly specifying all that does not change is verbose and tedious.
in fact eiffel practitioners rarely write framing specifications in this form.
in mbc the keyword modify introduces a routine s framing specification a list of all model queries whose value is allowed to change after executing the routine.
for example routine merge right in tab.
ii may only change sequence but not index and not any component of the other list s model.
the modify clause mechanism is taken from other specification notations and methodologies e.g.
spec usually targeted to formal correctness proofs.
it is only with a specification technique based on models however that it becomes practical for real classes and standard programming practices.
writing modify clauses in terms of attributes would violate information hiding and be of limited usefulness to the client while listing arbitrary public queries is too tedious since the values of several regular queries are often related for example the value of offmay change when index changes see tab.
iii modify clauses should include all related queries possibly also queries with arguments and on other objects.
model queries are instead normally only a small number they are orthogonal and only depend on the state of the current object.
hence specifying which model queries change is not onerous the values of all other queries are automatically defined in terms of them.
this approach to framing also supports a simple definition of specification completeness a routine postcondition and framing specification are complete if the relation between the model s pre and poststate is a function .3completeness is not an imperative in the mbc methodology programmers can still approach writing postconditions and framing incrementally.
it should rather be viewed as a safeguard against accidentally missing an important property.
3such notion of completeness is of course relative to the model.e.
class invariants the class invariant specifies global properties of valid instances of a class which every operation must preserve.
since the semantics of class invariants can be subtle mbc introduces additional dedicated constructs for complex invariant properties.
we borrow some ideas from the existing techniques developed for formal correctness proofs e.g.
among many unlike these sophisticated techniques mbc s solution for class invariants does not target comprehensiveness but is easy to deploy and sufficient in practice for finding errors by testing and avoiding spurious invariant violations.
class invariant types.
like postconditions class invariants in mbc use models to describe which object states are valid and which are not.
for example the first invariant clause in tab.
iii constrains the values of the model queries sequence and index stating that index must never take values outside the interval .
additionally class invariants in mbc have three more specific usages definitions of public attributes linking invariants and internal representation constraints.
public attributes from the class interface standpoint are indistinguishable from public functions and thus their values should be defined in terms of model queries.
an example of such attribute definition is the second invariant clause in tab.
iii which explains the attribute count is terms of the model query sequence .
parent classes may use simpler abstract models than their children.
linked list for instance inherits from a generic container class whose model is a bag multiset rather than a sequence because the order of its elements is immaterial.
to reuse the specification of the parent stated in terms of a different model we introduce class invariants that define the parent s model queries in terms of the child s model we call them linking invariants .
for example the third invariant clause in tab.
iii says that the parent s model query bag contains the same elements as sequence disregarding the order sequence .tobag .
finally internal representation constraints introduce specifications that relate the values of model queries to the private attributes of the class.
for example the last invariant clause in tab.
iii says that the private attribute last cellstores the same value as sequence s last element whenever the sequence is not empty .
unlike other mbc specifications invariants of this type do not describe the public interface of the class and usually cannot be made complete without revealing unnecessary implementation details in the model.
however even in this limited form they turned out to be very effective at revealing errors that corrupt object s internal representation see sect.
v a .
class invariant semantics.
eiffel checks class invariants at the beginning and at the end of every qualified4call on an object of the class.
this rule prevents checking the invariant whenever routines of a class call one another within the boundaries of a single object in order to accomplish a common task as the object will normally be inconsistent 4a call t.risqualified when the target tis an object other than current .
open until all operations are completed.
when circular dependencies between objects arise this semantics may lead to spurious invariant violations this is the dependent delegate problem .
consider an example derived from real code in eiffelbase a binary tree data structure where each node has a link to its parent and leftand right children.
the current node is executing one of its routines and is temporarily in a state that violates the invariant to restore it it makes a qualified call on say its right child.
the object right however does not know that its parent is in the middle of executing a call if right calls back tocurrent then it detects an invariant violation even if right s call does not rely on the invariant.
mbc deploys a runtime semantics where these spurious invariant violations do not occur.
objects are implicitly equipped with a boolean attribute isopenthat is set to true at the entrance of every public routine call on the object and restored to its previous value when the routine terminates class invariants are checked only if isopen is false.
this automatically solves the dependent delegate problem in the presence of callbacks when right calls back to current the latter is open and hence its invariant is not checked.
this implicit opening mechanism is not sufficient to avoid spurious invariant violations when an object s invariant depends on the state of other objects.
consider again binary trees an invariant states that the current node is its parent s left or right child parent6 void implies parent .left current or parent .right current routine prune leftremoves current s left child as follows oldleft left left void ifoldleft6 void then oldleft.setparent void end when oldleft.setparent void is called to remove the back link from current s child oldleft s class invariant is violated its parent s leftis already set to void and oldleftis not open in fact the very reason for calling setparent is to remove this inconsistency.
mbc provides the keyword depend to declare that an invariant clause depends on the state of an attribute and hence it should be checked only if the object attached to attribute is closed.
annotating the invariant in the example with depend parent removes the spurious invariant violation oldleft.parent iscurrent which is open .
in the few cases when fine grained control over the opening of objects is necessary mbc provides the open clause for routines which explicitly opens the objects attached to some of the routine s arguments when the routine begins execution and restores them when the routine terminates as we discussed the target is always opened implicitly .
consider a variant of the binary tree example where nodes have an attribute isroot that should be true when their parent node is void parent void implies isroot true in this variant prune takes an argument of class node that is supposed to be its left or right child and removes it as follows prune n node do ifleft nthen left.setparent void left.setroot true left void end ifright nthen end end when prune s call to left.setparent returns the invariant about parent and isrootis violated left.parent voidbut left.isrootis still false .
annotating prune with open nsuspends checking of n s invariant until prune terminates thus removing the spurious invariant violation.
as we discuss in sect.
iv in eiffelbase we had to deploy explicit depend and open annotations only in a very few cases limited to doubly linked list nodes and binary and n ary trees.
f .
runtime support for strong specifications model based postconditions and invariants can be checked at runtime and used in testing out of the box with the same tools and user experience as standard eiffel contracts.
model queries introduced for specification purposes are implemented as regular functions that compute the abstract model value from the concrete object state and thus do not require explicit initialization or updates.
the specification classes we provide in mml are also regular eiffel classes implemented in a functional style.
even though this approach to implementation of model queries and model classes potentially incurs a high runtime overhead the experiment results in sect.
v confirm that using mbc for contract based testing is feasible.
newly introduced specification constructs such as modify depend and open do not have any effect in the standard eiffel semantics they are specified using notemeta annotations similar to javadoc or c s meta data .
we have developed a simple tool that rewrites these annotations into plain eiffel for example modify clauses become explicit postconditions such asitem olditem.
the mbc methodology is conservative in that the class semantics is still sound if we ignore the special annotations ignoring modify clauses for instance yields weaker yet correct postconditions.
iv.
u sing strong specifications experiments we performed an extensive experimental evaluation to assess the benefits of using strong specifications for finding errors in software.
a. research questions the overall goal of this evaluation is assessing and comparing the advantages and the cost of deploying strong specifications in the form of model based contracts mbc described in sect.
iii when applied to automatic contract based testing of real software.
this materializes into the following research questions are strong specifications effective for finding faults in software?
do strong specifications find subtle and complex faults?
do strong specifications find faults in little testing time?
what is the performance overhead of checking strong specifications at runtime?
what is the development effort required to provide strong specifications for existing software?
to answer these questions we conducted two sets of experiments targeting software written in eiffel sect.
iv b and c sect.
iv c .
in both cases we selected an open source library specified it following the mbc methodology and extensively tested it with a standard automatic testing tool.
the rest of this section discusses the experiments sect.
v presents the results.
b. eiffel experiments the main experiments target eiffelbase rev.
eiffel s standard base library from which we selected classes of varying size and complexity.
using the facilities of the eiffelstudio ide we built the flatversion of each class which is a self contained implementation including all inherited members explicitly in the class text.
this simplified the task of writing specifications without being distracted by eiffelbase s deep multiple inheritance hierarchy.
for each of the classes in their flat version tab.
iv lists the size in loc and the number of public routines pr possibly also including helper classes directly used in the class implementation.
since different classes may share some parent or helper classes the totals at the bottom of the table are in general less than the sum of the elements in each column.
like most eiffel software eiffelbase comes with partial specification in the form of contracts the classes include precondition clauses postcondition clauses and class invariant clauses.
in eiffelbase we completely replaced eiffelbase s original postconditions and class invariants with model based annotations but we kept eiffelbase s preconditions with a few exceptions discussed below .
eiffelbase s strong specification includes precondition clauses postcondition clauses and class invariant clauses model constraints attribute definitions linking invariants internal representation constraints as well as modify depend and open clauses.
tab.
iv shows the size in loc and pr of eiffelbase which also includes model definitions and implementations of the model queries necessary to write mbc.
preconditions.
in all but two eiffelbase classes we kept the same preconditions as in eiffelbase.
within the specific setup of our experiments where we compare traditional contracts and strong contracts it is important to have the same preconditions in the two artifacts under comparison.
preconditions define the valid calling contexts of routines in particular contract based testing tools use them to select valid test cases .
changing preconditions would change the semantics of classes in a way similar to changing implementation strengthening a precondition may reduce the number of faults detectable for the routine since it would move obligations from the routine to its clients weakening a precondition may increase 5all the code developed as part of the study as well as descriptions of found faults are publicly available online .the number of faults since it would impose a heavier burden on its implementation.
we treat preconditions as developers design decisions which we normally take at face value.
this policy makes the experiments with eiffelbase and eiffelbase fully comparable.
the only exception occurred with four routines of class binary tree and eight routines of class two way tree that insert new nodes into a tree.
in these twelve cases we strengthened the preconditions to disallow creating cycles among nodes in the tree.
without the strengthening tree instances can be driven into inconsistent states with cycles where the whole specification of trees would be inapplicable.
these changes in preconditions are conservative the eiffelbase experiments using these stronger preconditions miss a few faults that are detected in eiffelbase because the new preconditions rule out some previously valid failing test cases.
since these changes affect only a small fraction of all the experiments the results with eiffelbase and eiffelbase remain comparable.
specification correctness.
to write correct strong contracts with mbc we analyzed the original implementation contracts and comments in eiffelbase and relied on our informal knowledge of the semantics of data structures and their implementation.
to increase our confidence in the correctness of the new specification we ran a series of short preliminary testing sessions with the goal of detecting inconsistencies and inaccuracies.
all our changes were conservative in that whenever a new contract forbade a behavior that was not clearly forbidden by the comments standard contracts or informal knowledge we weakened the specification to allow the behavior.
in all we reached a high confidence that eiffelbase s specification is correct and strong enough.
the results of the main testing sessions sect.
v corroborate this informal assessment.
testing experiments.
we ran a large number of random testing sessions with the autotest framework on a computing cluster of the swiss national supercomputing centre configured to allocate a standard .
ghz core and gb memory to each parallel autotest session.
the experiments totalled hours of testing time that generated nearly millions of test cases the tc columns in tab.
iv list the million of test cases drawn when testing each class in eiffelbase and in eiffelbase .
the testing of every class was split into sessions of minutes each with a new seed for the random number generator such that corresponding sessions in eiffelbase and eiffelbase use the same seeds.
this thorough testing protocol guaranteed statistically significant results .
c. c experiment a smaller set of experiments targets classes from dsa v. .
an open source data structure and algorithm library written in c .
support for contracts in c appeared only recently through the code contracts framework therefore most c projects including dsa do not have any formal specification.
this was a chance to extend the validation of the mbc methodology to other languages and to projects without pre existing specification.table iv eiffel classes under test and results .
eiffel base eiffel base class loc pr tc s pec inc real new loc pr tc i nc real new array .
.
arrayed list .
.
arrayed queue .
.
arrayed set .
.
binary tree .
.
bounded queue .
.
hash table .
.
hash table iterator .
.
indexable iterator .
.
integer interval .
.
linked list .
.
linked list iterator .
.
linked set .
.
linked set iterator .
.
linked stack .
.
two way list .
.
two way list iterator .
.
two way sorted set .
.
two way sorted set iterator .
.
two way tree .
.
two way tree iterator .
.
total .
.
loc lines of code pr public routines tc test cases drawn million spec specification errors found i nc inconsistency errors found r eal real faults found n ew faults found only in this experiment table v c classes under test and results .
dsa dsa testing class loc pr loc pr t f avltree binarysearchtree commonbinarytree deque doublylinkedlist heap orderedset priorityqueue singlylinkedlist total loc lines of code pr public routines t testing time minutes f faults found we instructed one of our bachelor s students to follow the methodology of sect.
iii and create dsa a variant of dsa with the same implementation but equipped with strong model based contracts.
dsa s specification includes precondition clauses postcondition clauses and class invariant clauses.
for each of the classes tab.
v shows the size in loc and pr of both dsa and dsa inclusive of all specification elements and model query implementations.
as in tab.
iv the count also includes possibly shared helper classes.
flattening was not necessary in this case because the inheritance hierarchy is shallow.
specification correctness.
we manually inspected the dsa specification written by our student and assessed its quality to be comparable to that of eiffelbase in terms of correctness and completeness.
since dsa was not designed with contracts in mind it makes recurrent usage of defensive programming throwing exceptions to signal invalid arguments.the experiment setup is consistent with this programming style we do not consider such exceptions to be faults.
testing experiments.
we performed automatic testing with the pex concolic testing framework running on a windows box equipped with a .
ghz intel core2 processor and gb of memory.
the experiments ran for about hours column t in tab.
v reports the breakdown per class in minutes.
the testing time is different from class to class because pex testing sessions by default are limited by coverage criteria rather than duration.
we only tested dsa since dsa has no formal specification elements usable as automated testing oracles.
the c experiment is less extensive than the eiffel experiment and intended as a control mechanism to identify any potential dependency of the results on the eiffel language libraries eiffelbase or tools.
v. u sing strong specifications results this section discusses the result of the experiments focusing on the larger eiffelbase experiments with v a through v e targeting the research questions of sect.
iv a. then v f briefly discusses the experiments with c and v g presents possible threats to validity of the results.
a. faults found autotest found faults in eiffelbase and in eiffelbase these are unique that is they identify distinct and independent errors.
we classified them in three categories.
specification faults correspond to violations of wrong contracts meaning that in our judgement they specify the expected behavior of the program incorrectly .
we found specification faults in eiffelbase column s pec in tab.
iv and none in eiffelbase which increased our confidencethat the preliminary testing sessions mentioned in sect.
iv b were sufficient to achieve correct specifications.
we consider specification faults spurious in our study because we are not comparing the correctness of the specification in eiffelbase and eiffelbase but rather their effectiveness at finding real errors in the implementation.
inconsistency faults correspond to failures triggered by calls on objects in inconsistent states which are not captured by a partial class invariant.
for example linked setmay be driven into a state where the container stores duplicate elements calling remove x in such a state triggers a failure only one occurrence of xis removed but remove is not to blame for it since it is due to previous erroneous behavior that went undetected.
while inconsistency faults are genuine errors we classify them separately because understanding and locating the ultimate source of an inconsistency is normally harder.
additionally a single inconsistency fault often results in many failing test cases potentially in all routines of the class that rely on the broken invariant requiring additional effort from the developer when analyzing the testing results.
we found inconsistency faults in eiffelbase and in eiffelbase columns i ncin tab.
iv the ultimate source of the latter fault is a class invariant not including all internal representation constraints see sect.
iii e which would have required exposing implementation details in the model.
the other inconsistency faults of eiffelbase are not detected in eiffelbase because due to stronger class invariants their real source is detected instead.
in the linked setexample above instead of the inconsistency fault in remove mbc report a fault in routine replace which does not check if the new value is already present in the set thereby introducing duplicates.
the results in this category indicate that strong specifications report faults in a way that is easier to understand and debug.
all other errors are real faults which correspond to genuine errors directly traceable to the code.
we found real faults in eiffelbase and in eiffelbase columns r eal in tab.
iv of them are found in both sets of experiments only in eiffelbase and only in eiffelbase .
we submitted bug reports for all the faults found in our experiments.
the eiffel software developers in charge confirmed of them as real bugs to be fixed.
this is evidence that we are dealing with genuine faults in our evaluation.
the remaining three faults not taken on by the developers also arguably highlight real problems in the implementation but they are probably not so likely to occur during normal runs.
the rest of the discussion focuses on real faults unless stated otherwise.
only seven faults are found in eiffelbase but not in eiffelbase columns n ewin tab.
iv .
four of them are prevented by the strengthened preconditions in the tree classes sect.
iv b two are shadowed by new failures occurring earlier and one disappears with mbc due to an unintentional side effect of a model query that amends an invariant violation.
none of these faults found only in eiffelbase show inherent deficiencies of strong specifications or of the mbc method.
in contrast the faults found only in eiffelbase are undetectable in eiffelbase.
total number of faults found40 90eiffelbase eiffelbase fig.
.
unique real faults found in all classes over minute testing sessions.
except for the two iterator classes no faults in both cases and the two queue classes the same two faults in both cases the number of faults found is consistently higher in eiffelbase in each class .
as evident from the boxplot in fig.
the difference is highly significant the mann whitney utest gives u testing eiffelbase outperforms testing eiffelbase in allsessions and p 11overall and p 11for every class except the iterator s and queue s .
the difference remains highly statistically significant even if we aggregate the experiments in sessions of different length.
testing with strong specifications detected more twice as many unique real faults than testing with standard partial contracts.
of the faults are detected only with strong specifications.
b. fault complexity although it is to some extent subjective whether a fault is deep or subtle faults violating postconditions or class invariants are arguably more complex because so are the violated properties.
while there is no significant difference in the percentage of class invariant violations between eiffelbase and eiffelbase in both cases postconditions trigger of violations in eiffelbase but only in eiffelbase the wilcoxon signed rank test among all classes gives w andp 3both for postconditions alone and for postconditions and class invariants counted together which demonstrates that strong specifications systematically detect more complex errors.
of faults in eiffelbase are detected thanks to postconditions or invariants a direct consequence of the effectiveness of the mbc methodology for writing them.
one example of a fault detected by a model based postcondition was already discussed in sect.
ii.
here we give two other examples to demonstrate that they are indeed subtle yet understandable routine array .force v i inserts value vat position iinto an array extending its bounds if needed.
all elements in between the old bound and iare supposed to be initialized with default values however force contains an off by one error and in a particular scenario fails to initialize one element.
this is missed by the original postcondition item i v which only takes care of the newly inserted element but detected by the complete modelbased postcondition which following the methodology specifies array elements at all positions.
time min unique faults found eiffelbase eiffelbase fig.
.
median number of faults aggregated from all classes in time.
dotted lines show minimum and maximum for each case.
both arrayed setand linked setinherit most of their implementation from the corresponding list classes including the implementation of isequal the object equality function.
as a result two sets with the same elements in a different order are considered different.
the original postcondition only states that equal sets must have the same size and that equality is symmetric which does not capture the specifics of set equality.
it is revealing that faults in eiffelbase are detected due to violations of contracts generated automatically by our tool that processes mbc annotations sect.
iii f such as modify and depend .
these faults are practically out of the scope of regular contracts as specifying the corresponding properties explicitly is extremely onerous.
throughout the whole experiment we encountered one violation of an invariant that could be later restored before the enclosing public routine call terminates.
strictly speaking such violation is spurious and to eliminate it we would have to extend the notation for open clauses in order to support opening arbitrary expressions rather than just routine arguments.
however in reality this particular invariant was notrestored so the violation pointed to a real fault.
this example suggests that if an object is too far away in the object structure from the call target to be mentioned in the open ordepend clause it is likely that a developer forgets to restore its invariant anyway because the object is not in the area of immediate interest for the routine.
c. usage of testing time fig.
plots the number of faults detected in eiffelbase and eiffelbase over a median minute session it is cleartable vi specification overhead tokens eiffel base eiffel base o verhead preconditions .
postconditions .
invariants .
mbc annotations model queries total .
spec code .
.
that the behavior with strong specifications dominates over standard contracts after only a few minutes.
dominance is observed consistently in all classes with the usual exception of iterator s and queue s a median session with strong contracts finds more faults than a median session with standard contracts after a time between two seconds and five minutes depending on the class under test after a time between seconds and minutes testing with strong contracts finds more faults than testing with standard contracts will find in the whole session.
testing with standard contracts also seems to exhaust earlier its fault finding potential given any time from minutes on there are more eiffelbase sessions than eiffelbase sessions that have found all the faults they ever will by this time.
this may indicate that standard contracts are good to find quick to detect faults but they also soon run out of steam.
we considered other differences between experiments with eiffelbase and with eiffelbase in the usage of testing time repeatability of testing session history and the presence of rare faults triggered only in a small number of cases.
our experiments with strong specifications are slightly less repeatable and include a few more rare faults but the differences with standard contracts are not statistically significant.
d. runtime performance overhead runtime checking of strong specifications based on models often requires traversing the whole data structure to construct an object of a model class whenever a contract element is exercised.
as a rule this demands more computational resources than executing the simple checks involved in standard contracts.
to measure the runtime overhead of checking mbc specifications in automated testing we compared the number of test cases generated by autotest in the same amount of time when testing eiffelbase and eiffelbase .
contrary to our expectations the overhead is small in many cases and not significant overall see column tc of tab.
iv .
a possible interpretation of this data is that the overhead of strong specifications grows as larger data structures are instantiated because random testing most of the time only exercises small data structures this overhead does not show.
we did not find a significant correlation between the variation of overhead for different classes and any source code metrics we considered.
on the other hand some autotest heuristics that decide to discard previously created objects are activated more often for classes where strong specifications are faster to check.e.
specification writing overhead applying mbc to create eiffelbase required roughly one person month plus one person week of preliminary testing for fine tuning the specification which puts the overall ratio benefit effort at about four defects detected per person day.
tab.
vi measures the amount of work produced in this time for each specification item including preconditions postconditions class invariants mbc annotations such as modify and model query implementations we compare the number oftokens in eiffelbase against those in eiffelbase when applicable and give the o verhead of strong specifications as the ratio of the two values.
the last line also shows the overall specification to code ratios.
reflecting the importance mbc gives to strong postconditions and the more restricted role of class invariants of all new specification in eiffelbase are postconditions whereas only are class invariants.
mbc specific annotations are mostly modify clauses that are however straightforward to write and dispense for more intricate explicit framing specifications.
model query implementations account for the remaining .
these numbers suggest that the specification overhead of mbc is moderate and abundantly paid off by the advantages in terms of errors found and quality of documentation.
the specification to code ratio also compares favorably to other approaches to improving software quality.
detailed quantitative data about industrial experiences with test driven development is scarce but few