locating distinguishing features using diff sets julia rubin university of toronto canada and ibm research at haifa israel mjulia il.ibm.commarsha chechik university of toronto canada chechik cs.toronto.edu abstract in this paper we focus on the problem of feature location for families of related software products realized via code cloning.
locating code that corresponds to features in such families is an important task in many software development activities such as support for sharing features between different products of the family or refactoring the code into product line representations that eliminate duplications and facilitate reuse.
we suggest two heuristics for improving the accuracy of existing feature location techniques when locating distinguishing features those that are present in one product variant while absent in another.
our heuristics are based on identifying code regions that have a high potential to implement a feature of interest.
we refer to these regions as diff sets and compute them by comparing product variants to each other.
we exemplify our approach on a small but realistic example and describe initial evaluation results.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering d. .
reusable software reuse models general terms design algorithms keywords software product lines software maintenance feature location.
.
introduction software product line engineering sple is an engineering discipline supporting efficient development and maintenance of related software products.
it capitalizes on identifying and managing common andvariable product line features across a product portfolio and promotes systematic software reuse by leveraging the knowledge about the set of available features relationships among the features and traceability between the features and software artifacts that implement them.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.while sple promotes systematic reuse of features between product variants in reality product families often emerge ad hoc when companies have to release a new product that is similar yet not identical to existing ones.
in many cases new products are created using code cloning mechanisms the clone and own approach when an existing product is copied and later modified independently from the original version .
a feature implemented in one cloned variant might often be useful for another.
thus its code should be located andcopied to that different variant promoting sharing of features between products .
moreover numerous approaches e.g.
advocate refactoring of cloned program variants into single copy representations eliminating duplications and explicating variabilities e.g.
theannotative orcompositional sple approaches .
identifying traceability between product features and artifacts that realize those features can help with such refactorings in many cases the set of features is known upfront and is specified by the product documentation whereas the relationship between the features and their corresponding implementation is rarely documented.
feature location techniques aim at solving this problem by locating pieces of code that implement a specific program functionality a.k.a.
a feature .
numerous feature location approaches that are based on static program analysis dynamic analysis information retrieval ir techniques change set analysis or a combination of several aforementioned techniques are extensively studied in the literature .
obviously each of the existing feature location techniques can be used for locating features of products in a product family when treating these related products as singular independent entities.
however leveraging any available information that can help improve accuracy of existing feature location techniques can be beneficial as the accuracy of many contemporary techniques is still low for example see .
in this paper we propose to extend the set of heuristics used by feature location techniques when locating distinguishing features those that are present in one but not all variants of a product family realized via code cloning.
our heuristics are based on additional information available when considering multiple product variants together .
such information can be obtained by comparing the code of a variant that contains a particular feature of interest to the one that does not.
the comparison provides an initial coarse grained partitioning of a program into relevant and irrelevant parts and assists the feature location process the features of interest are implemented in the unshared parts of the program providing a clue where to locate them.
we thus detect and explicitly capture information about the unshared parts of the program as a separate artifact called a diff set and propose heuristics that use this artifact for improving the accuracy of feature location.
the remainder of this paper is structured as follows in section we illustrate and motivate the problem.
in section we define diff setsand outline the two heuristics based on them.
our preliminary results are reported in section .
section discusses related workpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
figure a snippet of the automatic save file call graph.
in the area.
we present possible directions of future work and conclude the paper in section .
.
example consider the problem of locating the automatic save file feature in the code of the freemind open source mind mapping tool1 previously studied in .
figure presents the relevant freemind s call graph snippet where the four methods which contribute to the feature implementation are shaded elements .
central to the implementation of the feature is the run method of the mindmapmapmodel s sub class doautomaticsave element which calls the saveinternal method element responsible for performing the save operation itself.
the doautomaticsave class is initiated by the mindmapmapmodel s constructor element as shown in figure .
the constructor assigns values to several configuration parameters related to the automatic save file function initializes the doautomaticsave class by calling its constructor element and then registers the class on the scheduling queue.
the scheduler not shown in figure calls the runmethods of all elements added to its queue including the runmethod of doautomaticsave element .
the implementation of the automatic save file feature is integrated into the freemind code and relies on additional program elements.
for example element also initiates a call to method save writer mindmapmapmodel offreemindnodemodel element which in turn calls element save writer mindmapmapmodel .
element itself is called by mindmap mapmodel ssave file element which is called by mindmap controller sactionperformed actionevent element .
these methods are not relevant to the feature implementation because they handle a user triggered save operation instead of automatic save .
in fact element initiates calls to additional methods all of which are irrelevant to the implementation of the feature.
in figure irrelevant methods are not shaded.
comparing the variant of the freemind software that has the automatic save file feature to another one that does not have that feature produces a set of unshared elements that distinguish between the variants the diff set .
in figure unshared elements are denoted by solid line boxes while common ones have dotted line boxes.
since our goal is to detect the feature that is present in one but absent in another variant of the software all relevant methods are by definition in the unshared parts of the code.
methods that arecommon to both variants such as elements and can thus be safely ignored as they do not contribute to the automatic save but rather a previously present user triggered save functionality relied upon by the automatic save file feature.
public mindmapmapmodel mindmapnodemodel root freemindmain frame automatic save timerforautomaticsaving new timer int delay integer.parseint getframe .
getproperty time for automatic save int numberoftempfiles integer.parseint getframe .
getproperty number of different files for automatic save boolean filesshouldbedeletedaftershutdown tools.
safeequals getframe .
getproperty delete automatic save at exit true string path getframe .getproperty path to automatic saves timerforautomaticsaving.schedule new doautomaticsave this numberoftempfiles filesshouldbedeletedaftershutdown dirtostore delay delay .
.
.
.
.
.
figure the automatic save file code snippet.
unshared code may also include elements not relevant to the studied feature e.g.
element .
in fact freemind s automatic save file feature is implemented by four methods while there are unshared methods between the variants.
thus elements present in a specific part of the code should not be considered relevant automatically.
instead existing feature location techniques should use this information to enhance their heuristics.
.
diff set based heuristics feature location techniques are commonly evaluated by their precision the fraction of elements deemed relevant among those reported and recall the fraction of reported relevant elements among all those deemed relevant.
in this section we define a notion of a diff set an artifact capturingunshared parts of the program of interest.
we then describe two heuristics aimed to improve precision and recall of feature location techniques using diff sets filtering andscore modification .
definition .letpand pbe program variants.
a diff set of pcompared to p denoted by p is a set of all elements of p that do not have corresponding elements in p. that is p is a set of all elements of pthat are either different or absent from p. filtering.
since we focus on distinguishing features of a program p i.e.
those that exist in pbut not in another variant p we know a priori that all code of such features is present in pbut absent in p. that is the implementation of such features fully resides in diff sets .
thus all those elements retrieved by a feature location technique that do not reside in diff sets are false positives they do not contribute directly to the feature of interest and should not be returned to the user.
as such we propose to filter elements that do not reside in diff sets before returning feature location results to the user.
filtering can significantly improve the precision of existing feature location techniques without hurting their recall.
for the example in section the precision of a feature location technique that retrieves elements as the result of locating automatic save file feature is only four shaded elements are really relevant to this feature rather than to the manual save file feature which automatic save file uses .
considering the corresponding diff set which contains five elements denoted by a solid line boxes elements and helps improve the precision to at least elements and even if retrieved during feature location can befiltered from the list of results.
in addition filtering can help increase the number of relevant elements reported in the top ten highest ranked results another often used metric inspired by the study in which shows that users are generally unlikely to look at more than ten elements in a list.
such metric is suitable for the techniques that assign numeric243rank to the retrieved elements representing their deemed relevance to the feature of interest.
leaving out elements that definitely do not contribute to the feature of interest can help push more relevant results up in the list.
score modification.
while filtering is applicable to any feature location approach focusing on a specific family of approaches e.g.
dynamic or static can bring up additional improvements to the heuristics that they use.
we consider a family of feature location algorithms that employ an iterative multi staged program exploration approach returning to the user a ranked list of relevant program elements.
such algorithms e.g.
dora or suade usually traverse the program structure following program relationships such as method calls data access accessed by relationships type hierarchies and others.
analyzed program elements are scored based on their lexical and or syntactical properties and elements that are scored above a preset relevance threshold are returned to the user.
scoring is also used to determine which elements should be further traversed in the next iteration of the algorithm since they have a high chance to lead the analysis to additional relevant elements and which are dead ends where the exploration should stop.
for example while traversing the call graph in figure a feature location technique might score each element based on its lexical similarity to a given query that describes a feature e.g.
automatic save file and based on its structural proximity to other elements already determined to be relevant.
the resulting score for each element represents the degree of relevance to the feature that is being detected.
elements that reside in diff sets are more likely to be relevant to the feature of interest.
thus we propose a score modification strategy aimed to increase the score of those elements in order to improve the recall of a given feature location technique.
we increase the score of the elements in diff sets proportionally to their original score calculated by the original feature location algorithm instead of uniformly assigning a high score to all diff set elements.
this is done in order to avoid a high number of false positives and thus a decrease in precision as many elements in diff sets might not be relevant to the feature being located.
for the example in figure consider evaluating relevance of the element w.r.t.
the automatic save file feature if the relevance threshold is .
.
while the lexical similarity of this element to the automatic save file query together with its structural proximity to other elements deemed relevant is relatively low e.g.
.
increasing the score of this element by would push it above the relevance threshold.
thus the feature location algorithm would determine it to be relevant to the feature in question as desired.
increasing the score of the element that has a lower initial score assigned by the original algorithm e.g.
.
by will not push it above the relevance threshold even though this element is also located in the diff set .
.
initial ev aluation subjects and methodology.
for evaluating our diff set based approach we are exploring a set of open source programs whose features were identified and studied earlier .
these studies analyzed new functionality introduced by a specific software release and thus absent in a previous version .
the new functionality came in the form of program patches orbug fixes described in the projects documentation or in online tracking systems.
even though the main focus of our work is on features in different variants of a product family realized via code cloning releases of a program mimic the qualities of such families when locating distinguishing features.
figure sketches the cloning process in a family of related products in which variants are created by duplicating a specific version and continuing its development independently from the original.
for example products p2andp3are created by cloning the existing product p1at points and rep4 1p2 p1 p32 11figure cloned product variants.
spectively.
after cloning both new and existing products continue to involve independently from each other.
furthermore product p2 itself is cloned at point to create another variant p4.
when studying distinguishing features of a variant instead of comparing it to another variant that lack those features we can focus on comparing it to an earlier version that does not contain the features.
for example when studying distinguishing features of p4 instead of comparing it to p2at point we can compare it to p2at point from which p4was cloned.
in fact comparing p4to p2in these two points yields the exact same diff set the evolution ofp2is irrelevant because we are only interested in those features that are present in p4and absent in p2.
thus for our analysis we focus on versions of a program and use an earlier release to represent a variant that does not contain the feature of interest.
that is we produced diff sets for the analyzed case studies by comparing the analyzed program variant pto an earlier release p which does not contain the feature of interest.
to automate the comparison we adapted a java difference detection tool c hange distiller that extracts fine grained source code changes between subsequent revisions of java classes based on calculating differences of their abstract syntax trees.
as the result we obtained a set of elements that are newormodified inp compared to p. observations.
we analyzed the examples introduced by the study of revelle and poshyvanyk .
in their work the authors focused on ten ir based feature location approaches combined with static and dynamic techniques and compared the results returned by each of the approaches to those produced manually by human evaluators.
specifically the authors measured the percentage of elements perceived as relevant by human evaluators out of the top ten results reported by each of the evaluated techniques.
the study demonstrated that contemporary feature location techniques are able to find only .
to of relevant elements in their top ten results returning a large number of false positives.
unfortunately the source code of the studied feature location approaches was not available to us.
thus we were unable to measure the exact improvement in the precision and recall as well as in the number of relevant elements returned by each of the techniques in its ten top ranked results once the approaches have been enhanced with heuristics based on diff sets .
however we observed that around of elements perceived as not relevant by the human evaluators in corresponded to elements that did not change between program versions.
this confirmed that our diff set based heuristics can help improve the accuracy of a variety of feature location approaches.
we are now implementing the diff set based score modification for two tools whose source code was made available to us by their authors dora and suade .
an initial comparison of original vs. enhanced versions of these tools yields promising results.
.
discussion and related work numerous existing feature location approaches are extensively surveyed in .
the approaches are largely divided into dynamic which collect information about a program at runtime and static which do not involve program execution.
most dynamic approaches are based on analyzing two sets of traces those produced by scenarios that activate a feature of interest and those that do not.
elements are considered relevant if they appear only in the former set.
while execution trace partitioning is similar to our244partitioning of a program into common andunshared parts the two strategies are orthogonal potentially extending each other.
also our approach does not require program execution.
static feature location techniques look for desired results by leveraging program dependencies such as data or control flow or lexical similarity of the code to a query describing the feature of interest.
these works do not explicitly address the issue of finding distinguishing features and thus are orthogonal to our approach and can be extended by it.
project documentation together with configuration management systems might help determine code that corresponds to features.
however detailed logs associating code with high level features are rarely available.
several works attempted to discover features by analyzing commit operations.
for example cvssearch analyzed cvs log comments that describe the change made to the committed lines of code.
given a user query the tool returns all lines of code that are mapped to comments containing at least one of the query words.
unlike cvssearch our approach does not rely on the availability of meaningful comments and is applicable even when no change tracking is present.
yoshimura et al.
detect variability in a software product line using its evolution history.
the work assumes that each product consists of individual components and evolution entails an update to these.
components that are frequently modified together when creating one product from another are deemed to represent a product line variability point which can also be perceived as a feature.
we also attempt to detect elements that are introduced together and thus correspond to features that distinguish one product from another as opposed to elements that are frequently committed together by the developer.
however we do not employ statistical techniques that require analyzing extensive historical data but rather suggest a simple heuristic for using common andunshared parts of code obtained from comparing program variants.
k stner et al.
also deals with migration of a legacy system not designed as a software product line into a product line representation.
even though we share a similar goal of identifying product line features our approach is for systems realized via code cloning whereas the approach in assumes single copy legacy code.
.
conclusions and future work feature location is one of the most common activities undertaken by developers during software maintenance and evolution .
the goal of feature location is to retrieve those and only those elements that are relevant to the feature being detected.
however in practice all feature location techniques are heuristic and thus unable to provide a clear cut distinction between relevant and irrelevant elements.
in this paper we focused on locating distinguishing features of software product families realized via code cloning.
that is we aimed to find those features that are present in one variant of the program and absent in another.
while in product families the mapping of features to product variants is usually well documented locating the code of a feature in a given product variant is still challenging and in many cases inaccurate.
our approach is based on explicitly capturing the information obtained when comparing a product variant that has the feature of interest to another one that does not and using that information to enhance the set of heuristics employed by existing feature location techniques.
we believe that our approach helps increase the number of relevant elements identified by feature location as well as to reduce the number of false positive results.
as a future work we intend to fully implement the outlined approach and evaluate its effectiveness on a set of realistic case studies.
we are also interested in exploring additional usages of the collected information on program differences as well as additional heuristics that can be derived for handling feature location in product lines.
.