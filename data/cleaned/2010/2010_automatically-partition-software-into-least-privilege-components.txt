automatically partition software into leastprivilege components using dynamic datadependency analysisyongzheng wu and jun sunsingapore university of technology and design yongzhengwu sunjun sutd.edu.sgyang liunanyang technological universityyangliu ntu.edu.sgjin song dongschool of computingnational university of singaporedongjs nus.edu.sgabstract the principle of least privilege requires that soft ware components should be granted only necessary privileges so that compromising one component does not lead to com promising others.
however writing privilege separated softwareis difficult and as a result a large number of software ismonolithic i.e.
it runs as a whole without separation.
manuallyrewriting monolithic software into privilege separated softwarerequires significant effort and can be error prone.
we proposeprogramcutter a novel approach to automatically partitioningmonolithic software using dynamic data dependency analysis.programcutter works by constructing a data dependency graphwhose nodes are functions and edges are data dependenciesbetween functions.
the graph is then partitioned into subgraphswhere each subgraph represents a least privilege component.
theprivilege separated software runs each component in a separatedprocess with confined system privileges.
we evaluate it by apply ing it on four open source software.
we can reduce the privilegedpart of the program from100 to below22 while having areasonable execution time overhead.
since programcutter doesnot require any expert knowledge of the software it not onlycan be used by its developers for software refactoring but alsoby end users or system administrators.
our contributions arethreefold i we define a quantitative measure of the securityand performance of privilege separation ii we propose agraph based approach to compute the optimal separation basedon dynamic information flow analysis and iii the separationprocess is automatic and does not require expert knowledge ofthe software.i.
introductionthe principle of least privilege requires that softwarecomponents are only granted privileges that they need.
ifone component is compromised the impact is minimized.unfortunately most software adopts the monolithic design where the privileges of components are not separated.
anycomponent is able to invoke procedures and modify states ofany other components.
every component can access the sameset of system resources such as files network connections andhardware devices.
if a bug in a component is exploited or acomponent is malicious the whole software is compromised.one of the reasons why the principle of least privilege is notwidely applied on software components and monolithic designstill dominates is because it is hard to find a good separationgiven the complexity of software.
firstly it is hard toseparate software running in one process into multiple com ponents running in multiple processes without shared memory.secondly the communication between components running inmultiple processes is more costly comparing to single processversion.
lastly the privilege of different components must besufficiently distinct so that the separation is meaningful.consider a scenario where the software provides someservice to users connected from the internet.
the softwareuses pam pluggable authentication modules to authenticateeach connected user by passing the user name and passwordto pam.
pam then accesses the password database backendsuch as etc shadow or private keys and then returns back theauthentication result.
the software runs in a single process thus compromising the software results in leaking etc shadowor private keys to the internet.
even worse since the processruns as the super user the whole system can be compromised resulting all files to be stolen.
we can separate the softwareinto three components each running in a separate process an unprivileged component a network component and apam component.
the unprivileged component performs mostof the computation of the service which requires neitheraccess to the backend nor network.
it presumably containsmost of the software s logic and code base thus is mostlikely to be buggy or vulnerable.
the network componentmanages network connections and only accesses the network but not the backend.
the pam component only accessesthe backend.
the unprivileged component can interact withthe other components by calling their api functions.
if theunprivileged component is compromised it can neither readthe backend nor send information through the internet.1manually finding the cut among the three componentsrequires understanding the software which can be quite com plex.
a good cut should satisfy the following requirements.first the code base of the high privilege components shouldbe small so that they are less likely to be vulnerable.
second the privilege of the high privilege components should besufficiently distinct.
in the previous case a high privilegecomponent can access either file or network but not both.third the component interactions should be minimized so thatthe system is efficient.1the compromised unprivileged component can still interact with othercomponents through their api.
for example it can try all possible passwordsin a brute force manner by calling the pam api but this can be easily limitedby rate control.
.
c ieee ase palo alto usa323we propose programcutter a tool to help software de velopers automatically refactor monolithic software into leastprivilege components which run in different processes.
pro gramcutter finds the optimal cut according to the threerequirements above.
in addition given the source code ofmonolithic software programcutter automatically transformsit into the component separated form.
programcutter does notrequire expert knowledge of the software although additionalknowledge can give better results.programcutter works by analyzing execution traces of thesoftware to get the communication and privilege of eachfunction.
we consider two forms of communications betweenfunctions function invocation and data dependency.
functioninvocation is self explanatory.
a functionf1is data dependentonf2iff1reads from the data that is previously writtenbyf2.
the communication among functions forms a graph where the functions are nodes and the communications areedges.
each function invocation and data dependency has acommunication cost which is reflected on the edge weight.each function is associated with certain system privileges if itmakes certain system calls.
each node is also associated witha weight reflecting the size of the code of the function body.programcutter finds the optimal separation of components bysearching for a partition of the graph such that nodes withdifferent privileges are in different partitions inter partitionedge weight is minimized and the total node weight of highprivilege component is minimized.
finally programcutterrefactors the software into a privilege separated form bychanging inter component calls to remote procedure calls.we have implemented a prototype and evaluated it byseparating four open source software.
the evaluation showsthat we can bring about of the code from runningin privileged mode to unprivileged mode.
this means thatmost of the vulnerabilities are contained in the unprivilegedcomponent thus they are mitigated by programcutter.
thecost paid in performance overhead is below except in arare extreme case.ii.
relatedworkmanual separation privilege separation has been man ually applied on many software to prevent attackers fromgaining full privilege.
service software daemon such aspostfix sendmail and vsftpd typically first executesas the super user in order to acquire system resources such asbinding network ports and opening log files for writing.
afterthat it gives up all privileges so that in case it is compromised it cannot acquire additional system resources.
service softwarethat constantly requires privilege cannot adopt this method.
forexample openssh needs to callsetuid which requiresroot privilege after each successful user authentication inorder to launch a shell on behave of the user.
provos etal.
manually separated openssh into a high privilegeprocess which only does authentication and a low privilegeprocess which does everything else.
privilege separationmanually can take a substantial amount of time and can beerror prone.automated separation kilpatrick proposed privman which provides reusable library to help software developersto write privilege separated software.
brumley et al.
proposedprivtrans which provides some degree of automation inprivilege separation.
software developers only need to specifyprivileged functions and variables by adding annotations in thesource code and privtrans generates source code of privilegeseparated software.
although both approaches provide somedegree of automation expert knowledge on the software isstill required.
programcutter does not require any expertknowledge.
other than that the main difference between priv trans and programcutter is that privtrans uses static analysiswhereas programcutter uses dynamic analysis.
the problemwith static analysis is that firstly dynamic behavior suchas type cast function pointer and pointer arithmetic cannotbe accurately analyzed by static analysis.
secondly runtimeinformation such as buffer size is not available for static anal ysis.
as a result privtrans prefers the size of high privilegedcomponent to be minimal and ignores the communication cost.programcutter generalizes this by considering communicationcost and allowing the user to balance the trade off betweenthe two.
lastly software developers are still required to under stand the software in order to pinpoint the privileged functionsand variables.
on the other hand dynamic analysis has thedownside of incomplete coverage.
the accuracy of dynamicanalysis depends on the completeness of the execution traces.we will further discuss this issue in section iii a.apart from separating c programs swift works on ajava like language named jif in which programmers explic itly classify variables in order to specify a information flowpolicy such as confidential information should stay in the webserver and not be send to the web browser.
swift is then ableto partition the program into two programs one running in theweb server and the other in the web browser while ensuringthe information flow policy.
both swift and programcutteradopt a graph cut based approach where the edge weightrepresents the amount of information flow.
however swiftadopts a static approach while programcutter adopts a dy namic one.
to determine the amount of information flow weneed to know the number of times a piece of code is executed which is unavailable in static analysis.
swift uses certainassumptions such as equal probability of both branches in allifstatements.
on the other hand programcutter relies onexecution traces.
the lack of dynamic features such as pointerarithmetic function pointers and unrestricted type casting injif or java make static information flow analysis simpler.separation mechanisms implementation of separationshould ensure software components only i access theirdedicated memory ii execute their dedicated code and iii only call the granted system calls.
there are two com monly adopted approaches verification based and os based.verification based separation ensures thatthere is no bad instruction which accesses memory beyondthe dedicated memory range.
this is done by scanning allmemory loading and storing instructions to make sure thatthe target address falls inside the dedicated memory range.324for indirect memory access where the target address is onlyknown at the runtime an assertion is inserted before theinstruction.
os based separation runs dif ferent components in different processes and uses the hardwarepaging mechanism to ensure the memory safety and thereforethere is no performance penalty on memory access as inverification based separation.
however the inter componentcalls are implemented as ipcs thus it has performance penaltyproportional to the number of inter component calls and sizeof parameter passed.
it is feasible to adopt either approach.however as our component separation tries to minimize inter component communication the os based separation suits usbetter.software module clustering graph based approach hasbeen used to partition software module for the purpose ofprogram comprehension.
bunch models software intoa graph where the nodes represent modules and the edgesrepresent their dependencies such as function invocations andvariable access.
it then searches for the optimal cut thathas least inter partition edge weight.
while both bunch andprogramcutter adopt a min cut algorithm on searching for theoptimal cut programcutter incorporates security propertiesof software components and the graph cut has to satisfy theconstrain of the security policy.
in addition the edge weight inprogramcutter represents information flow dynamic while itrepresents module dependency static in bunch.iii.
systemdesignseparating software using programcutter consists of threestages.
as illustrated in fig.
a monolithic program is firstcompiled with debug symbols.
the program is then executedin thetrace collectorwhich collects execution traces.
thetraces are then analyzed by thegraph partitionerin order tocompute the optimal separation of components.
the separatedcomponents are used by thesource translatorto rewrite themonolithic program into a privilege separated program wheredifferent components run in different processes.when using programcutter we do not assume that the userhas any knowledge of the program to be separated hence weclaim that programcutter separates programsautomatically.however we assume that the user has some knowledge onsystem privileges which are independent of the program itself.to describe how programcutter works we separate a toyprogram shown in fig.
.
the program signs the message iam for an authenticated user.
the user launches theprogram by providing his user name and password.
the pro gram then employs a password based authentication method which reads the system password database etc shadow.
af ter a successful authentication it signs the message i am where is the authenticated user using aprivate key.
for simplicity we omit the error handling andcleaning code.
we also omit the code of functionmatches anddosign .matches l u p matches passwordptogether with user nameuwith an entrylin the passworddatabase.dosign p m signs messagemusing private keykand returns a signature.
the program reads two confidentialfiles etc shadowand private key.
we purposelyintroduced a buffer overflow vulnerability in line .
thisis a typical stack based buffer overflow vulnerability which can lead to execution of arbitrary code.
we will laterdemonstrate how programcutter automatically separates theprogram into three components with different privileges sothat in case the vulnerability is exploited the confidential filescannot be stolen by the attacker.a.
trace collectorthe trace collector logs execution traces that record memoryaccess and privileged system calls done by each function.more specifically each trace consists of a sequence of events where each event is either a memory access or a privilegedsystem call.
memory access we record all memory read and writeoperations together with the virtual address range.
thisincludes all memory accesses to the program stack andheap.
each record is in the form of function operation address and size tuple.
only user space memory accessesare recorded.
the recorded functions are the functionsthat perform the memory operations.
the operationscan be either reading or writing.
the address and sizecapture the target memory range.
we only record memoryaddresses but not variable names because using debugsymbol of the program we can translate memory ad dresses to variable names.in addition to instructions that read or write user spacememory we also record memory access to user spacememory due to system calls.
for example the systemcallwrite fd ptr size writesnbytes of userspace memory fromptrto file descriptorfd wherenis the return value.
in this case we record that memory ptr ptr n is read.table i shows some of the memory access records gen erated by our authentication program.
the order of therecords is significant.
note that the last column line which is the program line number responsible for thememory access does not appear in the record and isadded manually for the purpose of the illustration.
privileged system call in this paper we assume thatall privileged operations are made by system calls suchas opening a file sending data to a remote host.
to havefine grained privilege we record system call parameterssuch as file path and network address.after traces are collected the user lists all privilegedsystem calls and labels some of them.
in the end the program will be partitioned into lease privilegedcomponents according to the labels.
labeling privilegedsystem calls does not require understanding the structureof the software because only the knowledge on systemprivileges is required.in our toy program reading from etc shadow or privatekey is considered privileged.
the user may use one labelto label reading from the two files.
he may use twolabels to label them separately to give more fine grained325program binary withdebug symbolexecution traces components1.
trace collector2.
graph partitioner3.
source translatormonolitic programsource code separated programsource codeprivilege specification optional compileinputintermediate resultoutputprocessing stagelegendfig.
.
overview of programcutter stagestable imemoryaccessrecordsfunction operation address size line main writeusernamepointer size 23inpasswd writelinebufsize by syscall 5inpasswd write return value word size 7main read return value word size 25separation.
in the latter case the program will be sepa rated into three components an unprivileged component a component for reading etc shadow and a componentfor reading privatekey.for another example in openssh server the user mayuse three labels.
opening etc ssh sshhostrsakey islabeledprivatekey network related system calls are la belednetworkand other file writing except in tmp arelabeledfilewrite.
in the end it will be partitioned intofour components.we can collect traces from multiple executions in order toget sufficient coverage of the program.
multiple executionscan be collected by running the test cases given by the pro gram developer or from other automated test case generationmethods .b.
graph partitionerthe task of graph partitioner is to partition the set offunctions into a number of components such that differentprivileges are separated into different components.
in addition there is an unprivileged component which cannot call anyprivileged system call.
as mentioned earlier the code size ofprivileged components2should be minimized as well as thecommunication among components.we propose a novel graph based formulation of this prob lem.
a functionf1depends onf2iff1reads memory thatis last written byf2.
if we partitionf1andf2into twodifferent components we need to transfer the memory fromone component to the other which incurs communication cost.2for simplicity we consider all privileges to be equally significant.
analternative would be having a significance factor for each privilege andminimizing the weighted sum of the code size.in our graph each node denotes a function.
the edge weightbetween two nodes is the sum of the number of bytes of thememory dependency between the two functions.
this capturesthe communication cost if the two functions are partitionedinto different components.
each node is associated with aweight denoting the size of the source code implementingthe function.
this captures the size of the code base of acomponent which is correlated to the probability of beingbuggy or vulnerable.
if a function performs a privileged systemcall the corresponding node is labeled with the privilege ofthe system call.
functions that do not perform system callsare not labeled except that the program entry point main is assigned with a special unprivileged label3.
the task of thegraph partitioner is to partition the graph intonpartitions wherenis the number of different labels such that i alllabeled nodes in each partition share the same label ii thetotal weight of the inter partition edge is minimized and iii the total weight of privileged partitions is minimized.
sincewe have two values to minimize we aggregate the two intoone value by computing a weighted sum.
the weight is usedto balance between security and performance.fig.
shows the data dependency graph of our toy program.the dependency betweenmainandinpasswordis thesize of user name and password which is typically less than40 bytes.
however the dependency betweeninpasswordandfgetsis the size of etc shadow file which is muchlarger.
the graph partitioner may partition theinpasswordfunction in the privileged component in order to minimizecommunication cost.
in this way the graph partitioner auto 3we assumemain does not directly perform any privileged system call.if it does as the case in section vi b we manually make a wrapper for thesystem call.3261static intinpasswd char username char password 3charline 4file fp fopen etc shadow r 5while fgets line bufsize fp !
null 6if matches line username password 7return1 9return0 1112static char signmsg char message 14charprivkey 15file fp fopen private key r 16fread privkey keysize fp 17char signature dosign privkey message 18returnsignature 2021intmain intargc char argv 23char username argv 24char password argv 25if inpasswd username password 26charbuffer 27sprintf buffer i am s username 28char signature signmsg buffer 29printf s n signature else31printf bad login n fig.
.
a toy program that signs a message for an authenticated usermatically finds out the function in charge of authentication.similarly the data dependency betweenmainandsignmsgis the size of the message and the signature which is smallerthan the cryptographic key.
thus the graph partitioner maypartition thesignmsgfunction in the privileged component.this problem is a variant of multi terminal cut problem whose complexity is in general np hard and was first exten sively studied by dahlhaus et al.
.
a number of solutionsand approximations were proposed .
our main focusis not to solve the multi terminal cut problem instead wecan apply any existing solution.
in particular we choose aninteger programming based solution which will be describedin section iv.
our choice of solution is easy to implementand its performance is sufficient for our purpose which willbe shown in section vi.in the end the graph partitioner outputs the labels toall functions.
in our toy example if we define two labels private keyfor reading private keyanduser passwordfor reading etc shadow the graph partitioner will assignmain signmsgandinpasswordto the unprivileged label private keyanduser passwordrespectively.c.
source translatorthe output of the graph partitioner can be manually exam ined by the software developer to help studying code structureor to find out the code that is responsible for privilegedoperations.
in this way programcutter is used as a programcomprehension tool.
we take a step further to automaticallytranslate the original program into privilege separated pro gram.the privilege separated program works as follows.
the pro gram consists oflprocesses wherelis the number of labelsincluding the unprivileged label.
asmainis always assignedthe unprivileged label the program starts in the unprivilegedprocess which cannot directly perform any privileged systemcall.
rather it needs to perform privileged operations throughthe privileged processes by remote procedure calls rpcs .
the privilege separated program firstly launcheslprocesses where the unprivileged process start the execution327maininpasswdsignmsgsprintfprintffopen privilege 1fgets privilege 1matchesfopen privilege 2fread privilege 2dosignfig.
.
the data dependency graph of our toy program.
the thickness of anedge represents the amount of the data dependency between two functions.we mark two sets of privileges .
reading etc shadowand .
readingprivate key file.frommain and other processes wait to be called by rpcs.the inter component function calls are translated to rpcs.each component is allowed to call a limited set of rpcs inother components.
this set is determined by outgoing edgesof each partitioned component in the graph.in the separated toy program three processes represent ing three components are created.
the unprivileged processexecutesmain while the two privileged processes waitfor rpc.
the invocation ofinpassword on line isreplaced by a rpc invocation.
after the unprivileged processinvokes the rpc the execution is transferred to the privilegedprocess which then executesinpassword and returnsthe result back to the unprivileged process through the rpcreturn.
similarly the invocation ofsignmsg on line 28is replaced by a rpc invocation as well.when the buffer overflow vulnerability on line isexploited the attack can execute arbitrary code in the un privileged process.
this process cannot read etc shadowor private key.
it can invoke the two rpcs.
however by invokinginpassword it cannot read the passworddatabase either.
by invokingsignmsg it can sign arbitrarymessages but cannot read the private key.
in this case we mitigate the damage from losing private key to signingarbitrary messages.difficulty on parameter marshalling rpc requires pa rameters to be passed by value because passing by referencedoes not work when the caller and callee are in two differentaddress spaces.
our source translator translates passing by reference function call to passed by value using parametermarshalling.
unfortunately parameter marshalling requires thetype of each parameter to be serializable which cannot bedone automatically hence the serialization function has to bemanually implemented for each data type.we manually implemented the serialization functions forc library s commonly used data types such asfileandtime t. in addition our source translator deals with thefollowing types.
buffer with statically known size this includes char acter arrays such as thebuffer privkeyandlinevariables in our toy program.
structure with no pointers a structure s size is stati cally known thus it can be handled similar to a buffer.however if a structure contains pointers which may bedereferenced by the other process we need to marshal thepointed data.
this can be problematic if the other processmodifies the pointer.
null terminated string although the length of a stringis not statically known we can compute it at runtime aslong as we know it is a null terminated string.
we usesome heuristic to determine whether a character arrayis a string.
i strings are passed as a parameter to aknown library function.
for example if variablesxandyare passed tofopen x y we know that bothxandyare null terminated strings.
the variablesusernameandpasswordare recognized as string in this manner.
ii similarly strings are returned from a known libraryfunction such asstrdup.for other custom types the serialization functions have to bemanually implemented in order to use our source translator.implementing the serialization functions requires much littlework than manually separating the program.iv.
implementationwe choose to implement programcutter in gnu linuxsince there are more open source software to test with.
it canbe easily ported to other operating systems since we do notrely on any special feature of linux.trace collector the trace collector is implemented usingpin .
pin works by dynamically instrumenting instruc tions of a program binary in run time.
we need to collectinformation on two types of events memory reading writ ing and system call.
the former is done by instrumentingeach memory reading writing instruction and recording theinstruction pointer memory range during execution.
the latteris done by hooking all system call entry and exit points4and recording the instruction pointers that invoke the systemcall parameters and return values.
programcutter currentlyrecognizes the following privileged system calls file open ing reading writing socket creation binding connecting send ing receiving program execution changing user id and send ing signal.
additional privileged system calls can be easilyadded.
we only record the instruction pointer but not thename of the function because we can look up the name ofthe function using instruction pointer from the debug symbol.we only record functions of the program but not allfunctions including system libraries because programcutter4pin addsyscallentryfunctionandpin addsyscallexitfunctionare pin apis to hook system calls.328partitions the program not system libraries.
as a result whenthe instruction pointer does not fall within the program s coderange we need to backtrack and find out the latest caller inthe program and record the instruction pointer of that callinvocation.
for example in our toy example line fgets5 which is a c library function writes to the buffer pointed byline.
instead of recording the instruction pointer offgets we record its caller in the program inpasswd.graph partitioner the graph partitioner consists of twostages constructing the graph and partitioning the graph.the graph can be constructed by scanning the trace in asingle pass.
throughout the algorithm a data structure ismaintained to keep the last writer of each byte in the memory.initially the last writer of the whole memory isnone meaninguninitialized.
when scanning a memory writing record the lastwriter of all the bytes in the record s memory range is changedto the function of the record.
when scanning a memoryreading record for each byte in the record s memory range we add an edge or increment the edge s weight if alreadyadded between the reader and the last writer.
in the end weobtain a graph where each node represents a function andeach edge represents the data dependency.
instead of keepingthe last writer of individual bytes we use a redblack tree tostore segments of memory.
the running time complexity iso nlogk wherenis the number of records in the trace andkis the number of memory segments which is much smallerthannin practice.after we have obtained the graph we reduce the multi terminal cut problem to an integer programming problem anduselpsolve to solve it.
we choose this approach becauseit is easy to implement and works reasonably well.we reduce it into an integer programming problem asfollows.
for each function we declare an integer variablel1...f2 wherelis the number of labels andfisthe number of functions to denote the label to be assignedto the function.
we use value to denote the unprivilegedlabel and value above for privileged labels.
for pre labeledfunctioni liis fixed.
for an edgeiwith weightwbetweenfunctionjandk we declare a variableei wiflj6 lkandei 0iflj lkto represent the cost of cutting it.
for eachfunctioniwith weightw we declare a variablefi wifli6 1andfi 0ifli 1to represent the cost of putting thefunction in a privileged partition.
the value to be minimized isweighted sum of i the sum of all edge costs and ii sum of allfunctions pei 1ei pfi 1fi where is the weightthat can be adjusted.
in total fdlog2 l e evariables and2edlog2 l econstrains are declared wherefis the numberof unlabeled functions andeis the number of edges.source translator to make different components executein different processes there are two major changes to theprogram.
first before invokingmain i the additional pro cesses have to be created ii their system privileges have tobe confined according to the privilege specification and iii 5more precisely io getline internal which is called byfgets performs the memory write.the communication sockets have to be initialized.
confiningsystem privilege can be enforced by capability systems or system call monitoring which are orthogonal toprogramcutter.
second inter component function calls haveto be changed to rpcs.we use a substitutedmainto perform the initialization.the originalmainis renamed toorig main6.
if the processis the main process the substitutedmaincallsorig mainafter the initialization.
otherwise after initialization the sub stitutedmainenters an event loop in which the process waitsand dispatches incoming rpcs.we say a function to be acomponent entryfunction if it canbe called from another component.
we substitute each com ponent entry function with an rpc wrapper which handlesthe parameter marshalling and communication.
we also checkif the calling component is allowed to call the entry functionat runtime.
the original function is renamed toorig func.the calling of a component entry function e.g.
line and28 in fig.
is unchanged.in our toy example the function names in the declarationson line and are rewriten with prefixorig .
thesubstitutedmainperforms initialization as described earlierand either invokesorig mainor enters rpc dispatchingloop.
sinceinpasswdandsignmsgare component entryfunctions we add one rpc wrapper for each function.v.
securityanalysisin our threat model we assume the privileged componentto be vulnerability free while the unprivileged component tobe vulnerable and is compromised to execute arbitrary code.this assumption is based on the fact that i the number ofsoftware bugs is positively correlated to the size of code and ii programcutter makes the privileged component to be assmall as possible.
previous study has built different modelsto correlate the number software bugs and the software size.akiyama found that the lines of code l and the numberof bugs b are linearly correlated while lipow foundbto follow a quadratic function oflog l .
we also assumethat the attacker is aware of programcutter and knows howthe program is partitioned.
our goal is to prevent the attackerfrom performing privileged operations that are specified to thegraph partitioner.
we now discuss the potential attacks andhow programcutter prevents or fails to prevent them.
system call invocation the compromised unprivilegedcomponent may try to directly invoke privileged systemcalls.
since the unprivileged component runs in an un privileged process the invocation is denied by the systemcall filtering mechanism.
modifying privileged code data the compromisedcomponent may try to change the code of the privilegedcomponent and let it perform privileged operations onbehave of the attacker.
the compromised component maymodify data to achieve similar purposes.
for example 6for simplicity we assume that there is no function namedorig mainin the original program.329it can change function pointers or other control flowrelated data structures.
this is prevented because differentcomponents run in different processes and they do nothave directly access each other s memory.
exploiting privileged component entry function an unprivileged component is permitted to call entryfunctions of another component.
if the entry functions in turn invoke privileged system calls the attacker cancall it to perform attacks.
for example if the task ofan entry function is to append a string to a log file and both the string and log file are specified as functionarguments the attacker is able to append arbitrary data toan arbitrary file.
this can be exploited to attack the filesystem.
one way to prevent this type of attacks is to sanitization in the entry functions.
programcutterdoes not automatically perform input sanitization thusmanual work is needed.
collusion attack two or more compromised compo nents can collude to perform attacks that cannot beachieved by a single component.
for example if boththe network component and sensitive data component arecompromised by the same attacker sensitive data canbe sent to the network.
two conditions must be met inorder for the attack to succeed.
first there must be ausable entry function.
for example there must be anentry function in the network component that can beused to send data to the attacker.
similar to previousattack input sanitization can be used to eliminate thiscondition.
second the entry function must be directlycallable from the other component.
programcutter failsto prevent collusion attack if and only if both conditionsare satisfied.
denial of service the compromised component canpass incorrect data or refuse to do any useful work.
thiscan cause the program to behave incorrectly or crash.programcutter does not ensure correctness thus does notprevent this type of attacks.
another form of dos attackis that the compromised component repeatedly calls thetrusted component so that the trusted component is notable to serve other legitimate components.
this attackcan be effectively mitigated by thresholding the callingfrequency based on the calling component if the expectedfrequency is known.vi.
eva l uat i o nin this section we use programcutter to partition real wordprograms.
we want to evaluate programcutter based on thefollowing criteria.
the trace collector should be able to monitor and collectall function calls system calls and memory operations ofthe program.
the execution time overhead of the programbeing monitored and the size of the trace should bepractical.
the graph partitioner should be able to construct thegraph and solve its optimal partition within a reasonabletime.
the partitioned program should behave identical to theoriginal program in normal execution.
in addition to runthe program in the same configuration command lineoptions and input as the one generating the trace weshould be able to run it in different configurations.
theperformance overhead should be reasonable.
the size of the privileged components in the partitionedprogram should be small.
we also want to know if real world security vulnerabilities can be mitigated.
if a bug in an unprivileged component is exploited toexecute malicious code system privileges should not beused by the component.
in particular we should be ableto prevent the attacker from gaining a root shell.7we evaluate programcutter using the following software openssh server wget ping and thttpd because they i usesystem privileges especially openssh server and ping run asroot which make them to be attacker s valuable targets ii read from external input which can an attacking vector and iii are widely used and previously known to have securityvulnerabilities.for each of the four programs we first describe how weexecute it to collect the execution trace.
we then show statisticsof the program and trace.
we label the privileged system callsand use the graph partitioner to partition the program intocomponents.
finally we use the source translator to obtain theprivilege separated programs.
we test the privilege separatedprograms from three aspects i we execute them several timeswith different configurations or input to see if the separatedprogram behave like the original program.
ii we comparethe execution time of the two programs.
iii we execute theprivilege separated programs with root privilege and try toexploit their vulnerabilities to see if we can obtain a root shellor read confidential information such as user passwords andprivate keys.we quantitatively evaluate the quality of the partition interms of security and performance.
we measure the securityby the size of code executed in unprivileged process.
theoriginal program executes all code in the privileged process.the privilege separated program executes only a fraction ofthe code in the privileged process.
the smaller the fraction is the more secure the program is.
we look at the performanceoverhead which is the additional execution time divided bythe original execution time.
in all our test cases we set theweight in the optimization algorithm to be .
which weobtain through experiments.
a summary of the statistics andbenchmark results are listed in table ii.
all the benchmarksare performed on an intel core i5 2520m machine with 4gphysical memory running bit fedora kernel .
.
.a.
openssh serveropenssh server is the most widely used ssh server inunix based systems.
we collect an execution trace of theserver by connecting to the server performing a password7a root shell is a shell with root privilege.
gaining a root shell is commonlythe first thing to do after a security vulnerability is exploited.330table iisummary of ev aluation results.abbreviations func.
total number of functions appeared in the trace l o c total lines ofcode in the corresponding functions f inv total number of function invocations in the trace comp.
number of componentsto partition into p loc totallocin the privileged partitions tpart the running time of the graph partitioner tmono theexecution time of the original monolithic program and tsep the execution time of the separated program.softwarefunc.locf ivk.comp.p loctparttmonotsepopenssh219102447707633563 .
.771s153ms181ms ping11214973692304 .133s10000.196s10000.281s wget19713156223052791 .150s815ms830ms .
thttpd38271774922617 .859s815ms815ms based authentication and immediately logging out from theserver.
the source code of openssh server version .1p1 consists of lines of code loc and functions.
inour trace different functions are invoked times intotal.
we define two privileged labels shadow filefor readingthe user password file andprivate keyfor reading the privatekey files.
the graph partitioner partitions the functions intothree components.
theshadow filepartition has functionswith loc theprivate keypartition has functions with162 loc and the unprivileged partition has the rest.the execution time of the original monolithic server is0.
seconds and the time of separated server is .181s more .
note that the execution time here is an average of10 executions.
to minimize the network delay we executeboth the ssh server and client on the same host and usethe local loop back interface as the network medium thus with actual networks the performance overhead should bemuch smaller than .
since .
of the code is in theunprivileged component most of the vulnerabilities such ascve and cve are due to bugsin the unprivileged component thus they can be mitigated byprogramcutter.
for example cve exploits a buginbuffer initwhich is in the unprivileged component thus it cannot access the shadow file or private key.we test the following different execution scenarios andfound the privilege separated ssh server and the originalserver behave identical.
i the client authenticates with dif ferent accounts.
ii try two different client versions .9p1and .1p1 .
iii try different server key sizes 2048and bits .
note that we use the same privilege separatedssh server to test all scenarios.
this shows that our tracehas sufficient coverage in order to support different executionscenarios.b.
pingping is a network diagnostic program which sends icmpecho packets to a remote host and receives reply from it.
sincesending icmp packets requires super user privilege the pingtool is a setuid program which means that the program alwaysruns in super user privilege regardless of the user who runs it.this makespingto be a highly wanted program by attackersto find vulnerabilities.
for example the vulnerability cve allows normal user to use super user privilege toexecute arbitrary code.ping is a simple program with only functions in 2149loc.
we execute ping version s20101006 to send andreceive packets in our trace collector.
function invo cations are recorded in the trace.
we label the system callof sending and receiving icmp packets as privileges.
wefound that themainfunction directly invokes the privilegedsystem callssocket setsockopt ioctlandbind.
thismakes programcutter unable to partition the single function.we thus add four wrapper functions for them.
the graphpartitioner partitions the program into two components.
theprivileged component contains functions with loc fromthe original program and wrapper functions.the execution time overhead is too small to be measuredbecause ping waits for one second between sending eachpacket by default.
the variance of the execution time causedby random factors is larger than the overhead we want tomeasure.
in order to minimize the base execution time weset the wait interval between sending each packet to floodmode and use the local loopback interface as destination.
thetime of sending packets using the original monolithicprogram is .
seconds while the time using the separatedprogram is .
seconds more .
using this timing wecan estimate the execution time overhead with the defaultone packet per second.
the execution time of the monolithicprogram to send packets istmono .
.
and the time of the separated program program istsep .
.
.
thus the overhead is tsep tmono tmono .
.we test different scenarios such as running in verbose andquiet modes using different packet sizes and sending todifferent addresses.
the separated program mitigates cve such that the attacker cannot gain super userprivilege.c.
wgetwget is a command line program to download files from theinternet.
we want to partition it into a privileged networkingcomponent and an unprivileged component.
we collect ourtraces by using wget version .
.
to download a file froma web server.
different functions are invoked in 22305invocations.
the privileged system calls performed arebind connect socket read write8 recvandsend.
the8readandwritecan operate on both local files and sockets.
here weare only interested in sockets.331privileged partition has functions with loc and theunprivileged partition has functions with loc.to measure the execution time we download a 1mb file100 times from a local web server.
the execution time of theoriginal monolithic wget is .
seconds and the time of theseparated wget is .
seconds .
more .
we test differentscenarios using different urls file sizes and enumerating dif ferent command line options such as verbose mode continuingdownloading previously partially downloaded files and usinga web proxy.
the privilege separated wget behaves identicalto the original one.d.
thttpdthttpdis an open source web server.
similar to wget wewant to partition it into a privileged networking componentand an unprivileged component.
we collect our trace byletting thttpd version .25b serve one file download request.
different functions are invoked in invocations.
theprivileged partition has functions with loc and theunprivileged partition has functions with loc.to measure the execution time we use it to serve a 1mb filedownloading times by a local client.
the execution time ofthe original monolithic thttpd is .
seconds with standarddeviation as large as .
seconds which is much larger thanthe overhead less than 10ms .
as a result the overhead is notmeasurable with practical number of tests.
we test the privilegeseparatedthttpdwith different configuration options suchas different document root logging option cache policy.
wealso try to use different web browsers to access the server.
thetwo copies behave identical.vii.
limitationswe now discuss the limitations of programcutter.
our dependency graph is based on execution traces thusthe correctness of the graph partitioner depends on thecompleteness of the execution traces.
although we cannotguarantee our dynamic approach to be complete we cansee from our evaluation that different execution scenariosare covered.
in addition works in theliterature have made progress in generating test cases toget good code coverage.
as discussed in section iii c the source translator canonly automatically handle parameter passing of genericdata structures.
manual work is needed in implementingmarshalling of application defined data structures.
how ever the amount of manual work is substantially smallerthan rewriting the program in a different programminglanguage as in swift .
also the person who imple ments the marshalling is only required to understand thedata structure to be marshalled but not the full programto be partitioned.
if an unprivileged component is compromised it is ableto invoke rpc to privileged components.
the potentialdamage to the system depends on the functionality of therpc.
for example if the entry function of a privilegedcomponent does not sanitize function parameters it canbe exploited to execute arbitrary code in the privilegedcomponent.there are two ways to prevent this.
firstly the program mer can sanitize the function parameters of the entryfunctions so that they cannot be abused by the caller.secondly a fine grained system privilege can be appliedto restrict the privileged component so that even if it isexploited the damage is limited.
we adopt a function based separation where a functionis the base unit.
thus we cannot partition a programwhich has only one function.
a workaround is to makea wrapper function for the privileged system calls andperform proper parameter sanitation to prevent abuse.this is demonstrated in thepingcase in section vi.viii.
conclusionin this paper we present programcutter a novel approachto automatically partitioning software into least privilegecomponents using dynamic data dependency analysis.
thepartition is optimal in terms of our quantitative measure ofsecurity and performance.
the separation process is automaticand does not require any expert knowledge of the software.our evaluation shows that we can take most of the codefrom running in privileged mode to unprivileged mode withreasonable performance overhead.ix.
acknowledgmentthis work is supported by project idd11100102a idg31100105a from singapore university of technologyand design and ntu nap project formal verification oncloud .