assessing the value of branches with what if analysis christian bird microsoft research redmond wa usa cbird microsoft.com thomas zimmermann microsoft research redmond wa usa tzimmer microsoft.com abstract branches within source code management systems scms allow a software project to divide work among its teams for concurrent development by isolating changes .
however this benefit comes with several costs increased time required for changes to move through the system and pain and error potential when integrating changes across branches.
in this paper we present the results of a survey to characterize how developers use branches in a large industrial project and common problems that they face.
one of the major problems mentioned was the long delay that it takes chan ges to move from one team to another which is often caused by having too many branches branchmania .
to monitor branch health we introduce a novel what if analysis to assess alternative branch structures with respect to two prope rties isolation and liveness.
we demonstrate with several scenarios how our what if analysis can support branch decisions.
by removing high costlow benefit branches in windows based on our what if analysis changes would each have saved .
days of delay and only intr oduced .
additional conflicts on average.
categories and subject descriptors d. .
distribution maintenance and enhancement version control d. .
management software configuration managem ent.
general terms measurement management human factors keywords concurrent development branches teams what if analysis branch refactoring coordination .
introduction as software projects grow ever larger both in terms of develo pment teams and co de size coordinating work and changes to the system without causing undue harm or hindering others unnece ssarily becomes a challenge.
thousands of developers making substantial changes to the contents and interfaces of hundreds of subsystems can quickly lead to disaster.
one common solution to this problem is to use branches within the source code manag ement system scm .
branches provide developers a facility for working individually or in teams on the source code of a sof tware project independent of the changes being made by others.
the branch provides a workspace where changes can be made designs explored and code tested in parallel with other teams working in other br anches.
once a work task has been completed and the software is judged to be of sufficient quality via testing or some other method thes e changes can be integrated also known as merged into other branches and their corresponding features as they move towards a common branch sometimes called trunk master or root in different scms from which the product is released.
the practice of using branches to divide teams and tasks is used extensively at microsoft for projects with large codebases mu ltiple concurrent releases undergoing development and large teams.
in recent years with the advent of scms that facilitate easy branching and merging such as git mercurial darcs and bazaar many open source projects have begun using branching increa singly in their development practices.
prominent examples include the linux kernel python perl ruby on rails x.org and gnome.
of the projects reporting their scm in debian indicated that they used next generation scms that facilitate branching .
branching is a practice that is only becoming more prominent.
branches do not come without a price however.
since a change is initially only visible to the team working within its branch it must be integrated into other branches before it can be seen by the rest of the project.
the process of integrating changes from mu ltiple branches can be difficult and error prone especially if changes on different branches conflict either syntactically or semantically.
in addition this process takes time which can slow teams on different branches that are dependent on each other or features which are related.
thus branches incur an overhead in both developer effort and time which if not monitored and ma naged can have severe impact on the project in the form of missed deadlines and increased failures.
in an effort to identify the extent of the cost of branching we surveyed developers at microsoft to determine the difficulty and time associated with integra ting changes from multiple branches as well as tools and practices used to verify such work.
we also included questions to determine how often common problems with branches also called anti patterns initially identified by appleton et al are encountered and what the ir severity is.
based on the survey and follow up discussions with developers we found that branch awareness and decisions surrounding branches are important pain points for many s oftware projects especially for scms that contain many branches leading to many large integrations and long delays in moving changes across teams anti patterns known as branchmania and big bang merge .
to address scenarios involving monitoring and making decisions about branches we present a what if analysis which serves to characterize individual branches in terms of isolation how many conflicts they prevent and liveness how quickly changes made on the branches are conveyed to other teams.
our approach sep arates branches which exhibit the expected bene fits which we term permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.
high benefit low cost branches from those that slow development without providing high levels of isolation low benefit highcost .
this analysis can aid developers by alerting them to parts of the branch structure that are unhealthy and hindering deve lopment or indicating which branches should be considered for removal.
throughout this paper w e demonstrate and evaluate the utility of our technique by illustrating its use on windows.
for example we found that removing high cost low benefit branches based on our analysis changes would each have saved .
days of delay and only introduced .
additional conflicts on average.
over the past year we also applied this analysis t o windows mobile and bing with similar results.
we make the following contributions in this paper results of a survey of conducted with microsoft developers on branching practices and issues encountered with branch use section .
technique for measuring the isolation and liveness of branc hes via what if analysis section and .
decisions scenarios supported by this technique and demonstration of these scenarios in the context of windows deve lopment section .
.
branches at microsof t let us first illustrate how the windows development process works.
as shown in figure the windows software development takes place in various branches of the version control system with tightly integrated schedules for code integration and compr ehensive builds.
there are several parts of windows each of which are developed in individual branches.
an example feature could be sound in the component directx in the area multim edia .
each of these individual branches can work as though the rest of the code base to be frozen except for their own evolving features.
engineers check in their code to the feature branches.
to ensure that the newly developed code in the feature branch mai ntains compatibility with the other changes committed to the main branches the feature branches continually synchronize with the main branch also called forward integration or simply fi .
after passing quality gates for example code coverage or static anal ysis the code moves to the parent branch in the tree reverse int egration ri .
once the code reaches the main branch level it is automatically integrated fi ed with the rest of the code base to ensure that other code being developed is compat ible with these changes.
this process ensures stability in the main windows branch with a working version of windows always available for system test and other purposes however this isolation also comes at a cost transit time is increased as changes ar e only vis ible to other teams after several integrations.
an example could be multimedia branches where changes have first to be integrated to the main branch before they are visible in the networking branc hes.
the branch structure in windows and other products at m icrosoft is typically chosen at the beginning of a release and r emains mostly unchanged during the development of the release.
thus there is not a strong notion of short lived vs. long lived branches.
with this paper we introduce an approach to quantit atively assess cost and benefit of branches to inform branch dec isions.
.
survey on branch usage many best practices exist in software configuration management such as the work by berczuk and aiello which also di scuss how branches should be handled.
as an example a white paper from perforce software presents five best practices related to branches based on the authors experience in deploying scm systems branch only when necessary don t copy when you mean to branch branch on incompatible policy br anch late branch instead of freeze.
appleton et al.
present patterns best practices for managing branching in parallel development pr ojects .
they further present common traps and pitfalls in branching that they call anti patterns see figure .
examples of such anti patterns are creating too many branches branchmania deferring branch merging and then attempting to merge all branches simultaneously big bang merge or stopping all deve lopment activities while branching and merging permitting only activities focused on shipping the impending release development freeze .
in order t o characterize branch usage we sent an online survey to microsoft engineers in january .
for the design of the q1 approximately how many hours per month do you spend on branching operations such as creating branches and integrating changes from other branches?
number decimals okay q2 how much time does an integration take on average including the time to verify that changes have been integrated correctly?
please provide also the unit of time.
comment q3 how do you validate correctness of an integration?
comment q4 based on your experience how many errors are caused by incorrect integrations and in which areas do these errors occur?
comment q5 based on your experience how many times have you encountered the following branch anti patterns?
list of anti patterns by appleton et al.
with description see figure .
never once or twice occasionally frequently no opinion q6 based on your experience how large is the impact of the following branch anti patterns on productivity?
list of anti patterns by appleton et al.
with description see figure .
no impact small impact moderate impact large impact no opinion figure .
the survey questions.
figure .
branches in windows development.
fis forward integrations move changes from parent to child branches.
ris reverse integrations move changes in the opposite direction.
survey we followed kitchenham and pfleeger s guidelines f or personal opinion surveys .
our survey consisted of que stions all optional of which were related to branching and are shown in figure .
the survey was anonymous as this increases response rates and leads to more candid responses.
since we wanted to solicit the opinions of people well versed in working with the scm system and dealing with branches we chose our survey participants as the top of people who had either created most branches integrated most changes or submitted most edits within the months before the survey date.
pa rticipants were invited with a personalized email and could enter their names into a raffle of two us gift certificates.
we r eceived responses a .
response rate without sending any reminders other online surveys in software engineering have reported response rates ranging from to .
for the write in questions the completion rate was between and .
almost all respondents were developers and most were fairly experienced with a median of years of work experience in the software industry and .
years a t microsoft.
.
integrations on average the survey respondents spent .
hours per month creating branches or integrating changes from other branches the median was hours q1 .
these numbers may appear low but often teams select a single person to be in charge of integrations and maintain a branch this observation is supported by the 95th percentile of .
hours and several of the free form comments in the survey.
the time spent on branching operations depends also largely on the work area build eng ineers spend significantly more time than developers.
for the time that integrations take on average q2 we solicited responses in the form of comments rather than numbers because we wanted to know more about the specific context of the integr ations.
th e time varied widely across responses ranging from minutes for simple integrations to days for more complicated integrations.
most of the time is spent on resolving conflicts and verifying correctness.
the total time spent depends largely on the presence of conflicts but also on the size of the payload how well the branches are partitioned in terms of work going on inside them and how far back is the baseline .
several people and teams had developed custom tools and scripts to help them speed up the integration and its validation.
to validate the correctness of integrations q3 respondents used a wide spectrum of techniques manual inspection using diff tools historic change information custom tools and scripts builds pr ogram executions test ru ns and also code review.
several people stressed the importance of social communication especially when there are merge conflicts and the resolution is not clear.
survey respondents pointed out that the validation often depends on the type of branch private one man branches vs. public team based and aggregation branches and the complexity of the changes to be integrated.
in windows and other systems feature branches typically have quality gates that must be met before a change can move to a different branch .
we also asked about how many errors are caused by incorrect integrations q4 again we solicited responses in the form of comments rather than numbers.
the consensus among respondents was that errors happen from time to time but relatively rarely because changes are validated extensively e.g.
through quality gates .
however errors tend to be subtle because if they happen they often aren t noticed for a while when totally bizarre behavior occurs and it takes a long time to track down what ha ppened.
frequent causes for integration errors are merge conflicts that were not resolved correctly or partial integrations missing a file.
errors often occurred in files that were not source code such as xml files or build manifests and are difficult to compare.
.
anti patterns figure contains the descriptions of the anti patterns that were presented to the surveyed developers.
with respect to anti patterns we focused on two aspects frequency q .
in the survey we asked how many times each anti pattern had been encountered by a person.
for the question we used an ordinal scale with four levels never once or twice occasionally and frequently.
t o avoid any guesswork by participants we provided an explicit option for no opinion .
for the analysis of the responses we followed the advice by kitchenham and pfleeger and dichotomized the ordina l scale to avoid any scale violations.
more specifically for each anti pattern k we computed the percentage p f k of the response frequently among all responses excluding respon ses that had no opinion .
severity q .
in addition we asked which anti patterns had the highest impact on productivity.
we used an ordinal scale with four levels no impact small impact moderate impact and large impact again we offered an explicit option or no opinion.
we computed for each anti pattern k the percentage p s k of the response large impact among all responses excluding responses that had no opinion .
merge paranoia avoiding merging at all cost usually because of a fear of the cons equences.
merge mania spending too much time merging code instead of developing it.
big bang merge deferring branch merging and attempting to merge all branches simultaneously.
never ending merge continuous merging activity because there is always more to merge.
wrong way merge merging into the wrong branch.
branch mania creating too many branches.
cascading branches branching but never merging back to the main line.
mysterious branches branching for no apparent reason.
runaway branche s branching for single purpose evolves to multi purpose branch for unrelated tasks.
volatile branches branching with unstable files merged into other branches.
development freeze stopping all development activities while branching and merging.
integration wall using branches to divide the development team members instead of dividing work.
spaghetti branching integrating changes between unrelated branches.
figure .
branch anti patterns identified by appleton et al in the order they appeared in the survey.
to identify anti patterns with both a high frequency and a high severity we additionally computed for each anti pattern the pro duct pfs k of the percentages pf k and ps k .
pfs k pf k ps k in figure we show a bubble chart of the frequency and severity of the branch anti patterns.
each anti pattern k is represented as a bubble the position on the x axis corresponds to the percentage p f k of responses that selected frequently in q5 and the pos ition on the y axis corresponds to the percentage ps k of responses that select high impact on productivity in q .
the bubble size corresponds to the combined percentage pfs k .
intuitively the product pfs k is the area of the rectangle spanned by the zero point and the point representing the anti pattern.
to increase readability we show full names only for the four anti patterns with the highest pfs values the other patterns are identified with numbers.
the mysterious branches anti pattern is not shown because no developers indicated that it had high severity and therefore the area is .
the four highest ranked anti patterns in figure are development freeze big bang merge integration wall and bran chmania.
development f reezes allow only activities that are focused on shipping the next release work on subsequent releases is blocked until the software is released.
appleton et al.
discuss several solutions for this problem such as having parallel release and development lines.
the anti pattern integration w all means that branches are used to divide the development team members rather than the work itself.
in a prior work related to this anti pattern we presented a preliminary study of how branches are used to o rganize goals and teams .
for this paper however we focus on the anti patterns big bang merge and branchmania which are re lated too many branches often lead to large integrations.
branchmania may also lead to longs delays to recover from and prevent branchmania project members need awareness of how different branches are affecting their work.
if developers can identify wh at branches are posing problems or are not actually needed they can make decisions such as where to integrate changes more frequently or which branches to remove proactively.
in this paper we provide a methodology to empirica lly assess branches and show how our approach can be used in a number of branch decision scenarios by illustrating them on windows.
.
liveness and isolation it is important to understand how developers and other project members view branches within a project and what qualities are important to them.
at microsoft project members care deeply about making fast and continuous progress .
one aspect of this progress is how quickly changes made on branches are being seen by the rest of the project.
we term this general property of how fast changes are being integrated into the rest of the project as liveness.
one specific measure of liveness is the amount of time that it takes for a change on a branch to reach the root.
this is important because even if a developer has completed a feature o r a bug fix the task is not considered complete until the change has reached the root without error .
furthermore some defects do not manifest until changes from different branches reach each other and their inter action leads to problems a high liveness helps to reveal these problems faster.
the interval between the checkin of a change and the time that it reaches the root branch is the transit time of the cha nge.
low transit times result in high liveness .
many teams at microsoft are interested in tracking the transit time of edits in their project.
while transit time for individual edits is fairly straightforward to compute from scm metadata accounting which branches contribute the most to long transit times on the path to the root branch is more com plex.
branches that increase transit times may represent a bottleneck and pose a severe barrier to project agility.
developers are aided by branches because of the isolation that they afford.
by making changes on a branch developers are una ffected by others and need not worry about unduly impeding teams on other branches.
developers working in different branches can change the same file without immediate negative impact.
such activity means that the changes will eventually need to reach each other and their interactions will need to be resolved but developers can wait until their changes are complete and stable before hand.
if a file is changed on two branches a and b then when the change from one is integrated into the other or the two changes meet on another branch perhaps the parent of a and b there is a file level conflict which needs to be resolved.
we can mea sure how many conflicts occur when branches integrate with other branches but many edits to the same file in two different branches may only result in one conflict if there is only one integration consequently this measure does not accurately reflect isolation.
note that there are different levels of conflicts.
line level conflicts are when two changes if they change the same lines in a file and require manual merging by developers.
for this paper we focus on file level conflicts which is when the same file has been changed on different branches.
while some of these can be merged automatically even these merges have caused enough problems that the integration still has to be validated by developers for example via compilation and testing as i ndicated in our survey to avoid errors based on bad merges .
figure .
the frequency and impact of branch anti patterns.
to increase readability we used numbers to label some of the anti patterns.
merge paranoia never ending merge volatile branches merge mania spaghetti branc hing runaway bra nches cascading branches wrong way merge mysterious branches accurately quantifying liveness and isolation via what if analysis and using such data to aid project members decision making is one of the main contributions of this paper.
.
methodology isolation and the liveness of a branch can provide valuable information to project members that can be used in a number of scena rios from monitoring branch health to identifying branches that should be removed from the system.
however measuring isol ation and liveness is not straightforward how can we determine how many conflicts were avoided?
h ow much code movement was slowed due to the use of a branch?
to address such questions we introduce a what if analysis as illustrated in figure .
we take an original development history h0 and apply several branch removal operations sections .
and .
to obtain an alternative history h1 .
we then compare how liveness and isolation change between h0 and h1 section .
.
we demonstrate based on windows branches how such data can support several decision scenarios section .
.
terminology we first introduce basic definitions needed to describe our what if analysis.
where possible we adhere to accepted terms from scm parlance and only describe key terms and concepts that would otherwise be confusing or ambiguous.
for a more detailed and formal description of our methodology we refer the reader to the online appendix .
to model file histories we use br anches edits and integrations as shown in the diagram below.
time flow s left to right.
edits and integrations are referred to as checkins.
in this paper we use circles on a horizontal line to denote checkins on a branch.
parentchild integration integration editanchor branchescheckins editedit anchor we represent a branch by the list of subsequent checkins that have been made to the file on the branch.
branches form a hierarchy in which the main branch is called the root branch.
likewise there are parent and child branches.
checkins are integrated between branches and propagated towards the root branch.
the depth of a br anch in the hierarchy is also referred to as the level with level being the root branch.
an edit includes a direct modification of a file by a developer such as editt ing its content as well as adding or removing a file from the scm.
edits are a type of checkin and we denote edits with a solid circle.
an integration merges the contents of a file at a specific point in time on one branch source into another branch target .
in most cases but not always i ntegrations occur between parent and child branches.
integration s are a type of checkin and we denote int egrations with a large hollow circle.
to model the state of the file at the specific point in time on the source branch we introduce anchors which are temporal p laceholder s on the source branch and contain no actual change to the file.
anchors are denoted with a small hollow circle.
note that the anchor and the corresponding integration have the same time .
simulated removal of a single branch the core part of our what if analysis is removi ng a single branch.
this allows us to explore a variety of alternative branch structures because scenarios where more than one branch is removed can be reduced to a series of single branch removal steps.
to simulate what would have happened if a branch was removed we use the past development history and examine and modify the checkins and branch operations that involve the removed branch the parent and the children.
throughout this paper we refer to the branch being removed as the victim branch.
we first describe our simulation .
figure shows the changes to the history that are involved when simulating the removal of the victim.
figure .a shows the original history for a subset of development history as it actually happened in the scm.
in this figure a and b are horizontal lines representing branches.
b is the victim and a is the victim s parent.
as before solid circles represent edits and h ollow circles represent integration s from one branch to another.
in this diagram the color of the circle indicates which branch the checkin occurred on in the original history figure .a .
we use the following steps to simulate an alternative history with the victim removed.
first we identify all edits that occur on the victim.
since we are simulating wha t would have happened if the victim had not exis ted the edit s would have been made on the parent branch.
thus we move these edits to the parent branch while preserving chrono a initial history h0 with branches a parent and b victim .
b move checkins from victim branch b to parent branch a. c remove the i ntegrations between parent and victim.
d final alternative history h1.
figure .
the steps required to simulate the removal of a branch.
in this figure a is the parent branch b is the child bra nch solid circles represent checkins hollow circles represent integration checkins between branches.
checkins are colored according to the branch that they were made on in the original history.
figure .
what if analysis applies one or more branch remo val operations to create an alternative history and then co mpare liveness and isolation.
logical order.
figure .
b illustrates this step by moving the checkins from b t o a. second we remove integrations between the parent and the vi ctim.
since all edits now reside on the parent branch the integr ations to and from the victim branch are no longer needed.
this is illustrated in figure .c where the integration s and anch ors between parent and victim are removed.
third all integrations from the victim to its children or any other branches are modified so that they now have the parent branch rather than the victim as the source.
likewise all integrations that have the victim as the target branch are modified so that they have the parent branch as the target.
this step is not shown in figure as these integrations do not occur in the simple history shown.
the final alternative history is shown in figure .d.
note that although all checkins occur on the parent branch a we can still determine which branch each checkin was made on in the original history.
this is required for our branch metrics .
a more complex example is shown in figure original history in .a alternative history with victim removed in .b .
the edits on the victim are moved to the parent branch in t he alternative history.
integration and corresponding anchor checkins have either been removed x and y or rerouted e.g.
c d .
while more complex this illustrates the effect of simulated branch removal the path shown as a dashed line in both histories from the two edit checkins e and f is different in the original and alternative histories.
in the alternative history the edits reach the parent branch and leave towards the root earlier.
the difference in transit time to the root branch is the delay caused by the victim.
on the other hand some edits that originally occurred on diffe rent branches are now subsequent conf licting edits on the parent branch as indicated by the arcs between edit checkins in figure .b for example a in conflict with b .
these conflicts chara cterize the isolation provided by the victim branch in the original history where a and b were isolated on different branches .
.
alternative branch structure scenarios based on the single branch removal step described above we perform what if analysis for a wide spectrum of alternative branch structures to address different scenarios .
examples include what if a s ingle branch is removed?
is there a particular branch that is causing problems and should receive attention?
this scenario simply applies the step described in the previous section.
in figure .b we illustrate the history produced when this step is applied to the history shown in fig ure .a.
what if an entire branch subtree is removed?
are there sections of the branch structure that aren t actually needed?
this scenario select s a victim branch and removes the entire subtree rooted at the victim.
for each branch removed from the subtree we follow the process described in section .
.
what if we only had branches up to level n?
several teams asked how liveness and isolation would change if the depth of the branch hierarchy is restricted.
this would limit the maximum number of hops for changes to reach the root branch and thus may maintain pr ogress within a project.
to assess this scenario we remove all branches on levels greater than n with the process described in section .
.
if a scenario requires removing multiple branches the actual order of the branch removals does not affect the results.
we record two branches for each checkin the branch that the checkin occurred on in the original history which is never changed throughout the entire analysis and the branch that it was made on in the alternative history which is initialized to the orig inal branch but subsequently changed via branch removal operations .
this allows us to apply multiple branch removals in an arbitrary order be cause our analysis only needs the original branch and the final target branch for each checkin.
regardless of the order of branch r emovals the final target branch for a checkin on a victim branch is always well defined checkins are moved to the first non victim parent branch of their original branch.
thus branch removal is associative and commutative.
figure .
simulating branch removal.
.
measuring liveness and isolation we now describe the two measures that we use to quantify the benefit and cost of branches delay and provided isolation.
we present an intuitive description here .
a more formal definition is available for the interested reader in the online appendix .
delay.
recall that transit time is the time that it takes for an ed it to reach the root from the branch that it was checked into.
once an alternative history has been created through branch removal operations from the original history the transit time for some edits may have changed for example see checkins e and f in figure .
the delay that branches within a scenario incur is the difference in total transit time the sum of transit times for all edits for all edits between the original history h0 and an alternative history h1.
delay totaltransittime h0 totaltransittime h1 isolation.
we quantify the isolation that a branch provides by determining the number of conflicts that are avoided because of the existence of the branch.
if there was concur rent activity to the same file in a branch and its parent or in a branch and its children then the branch provided a level of deve lopment isolation and was beneficial .
however if development in a file on a branch had no potential conflicting changes in its children or parent then this isolation was likely not needed.
we calculate this by examining the checkins on the parent in the alternative history h1 and counting the number of conflicts.
a conflict is a pair of subsequent e dit checkins on a branch in the alternative history h1 that occurred on different b ranches in the origi nal history h0 for example edits a in conflict with b in figure .b .
these are indicative of checkins that may be incompatible even if the algorithm used by the scm to merge textual changes runs without error a developer must stil l validate e.g.
through builds and test runs that the merged file does not contain any problems.
thus each conflict introduced by the removal of a branch represents a non trivial amount of add itional work for a developer .
we compare the number of conf licts in h1 against the number of conflicts in h0 during integrations.
isolation conflicts h1 conflicts h0 while we cannot know what exactly would have actually hap pened had a br anch not existed our alternative history effectively quantifies the isola tion provided and delay introduced by a given branch.
even if developers coordinate d their changes to avoid conflicts this would be additional effort.
.
normalization some branches have an order of magnitude more changes than others.
thus total delay and t otal isolation may be misleading especially when comparing different branches.
as an example branches with many edits will have more influence on total delay just because of the high number of edits.
therefore d epending on the question that we are interested in answering delay and isol ation may need to be normalized f or scenarios related to compa risons and decisions on individual branches or subtrees we normalize the delay and isolation measures .
for scenarios related branch structure as a whole we do not normalize.
more specif ically for the scenarios presented in this paper we normalize in the following ways.
normalized delay.
the removal of branch es can only affect the transit time of edits on the victim branches and on their children recursively .
we call the edits on these branches the affected edits regardless of if their transit time is changed .
therefore when normalizing delay we divide the sum of the differences in transit time by the number of affected edits normalizeddelay delay numberaffectededits h0 h1 put simply the normalized delay for a branch is the average change in transit times for edits that occur on or below the branches that have been removed.
we say that the branch es incur this delay per edit for edits on a nd below them .
normalized isolation.
here we normalize by the maximum nu mber of possible conflicts that can be introduced.
all edit checkins on the removed branches end up in the victims parent branches there may be multiple victims if multiple branch r emoval steps are taken from h0 to create h1 .
thus t he maximum number of conflicts occurs when there is perfect interleaving of edits that were created on different branches in h0 possibleconflicts number ofeditsonvictims numberofeditsonparents we normalize isolation by dividing the number of conflicts that the branch avoids by the maximum number of possible conflicts.
normalizedisolation isolation possibleconflicts intuitively the normalized isolation indicates how many conflicts per edit checkin a branch prevents.
.
decision support scenarios having described our methodology we now illustrate these sc enarios by using our analysis on windows development history.
.
branch health our branch assessment metrics can provide awareness of branch health to project stakeholders such as developers managers and build engi neers.
in the same way that test results or code coverage metrics can alert project members to potentially problematic parts of the software the measures of isolation and livenes s can be used to alert project m embers to parts of the branch structure that are unnecessarily impeding progress .
over the past year we have provided branch health reports to windows windows mobile and bing.
for each branch the reports contain standard measures such as number of edits integrations edit conflict ratio as well as delay and isolation based on the scenarios listed in section .
.
our analysis helped the product groups identify what specific parts of the branch structure were responsible for low liveness.
note that high delay low isolation branches do not necessarily have to be removed from the branch hierarchy.
as with most if not with all metrics the actions to be taken depend highly on the context .
for example branches might exhibit a high delay because of a temporary code freeze or because they are integral parts of the quality assurance and serve as quality gates these branches should likely not be removed.
other than removing a branch a team can also decide to integrate more frequently to the parent branch to decrease delay.
.
separating the sheep from the goats2 figure contains a scatterplot showing the normalized delay and isolation of all branches during the complete development cycle of windows .
the graph shows the results for recursive branch removal removing a branch and all of its descendants .
isolation separating the sheep from the goats is an english idiom and an allusion to a biblical metaphor matthew in which sheep provide value and are blessed while goats do not and are cursed.
is shown along the x axis farther right is better as it means more conflicts are prevented by a branch and delay is shown on the yaxis lower is better .
we consider isolation to be the benefit that a branch provides at the cost of delay.
high benefit low cost branches sheep are colored green and on the bottom and right .
low benefit high cost branches goats are colored red and are on the top and left.
medium benefit mediumcost branches hybrids provide isolation but also incur delay s and are near the x y line.
our categorization is based on ranking each branch in terms of the isolation that it provides and the delay that it incurs.
we give each branch two ranks one for delay from least delay to most and one for isolation from most isolation to least .
then branches are sorted by the sum of their two ranks.
the first of branches are labeled sheep in graph in figure the last have highest delay and lowest isolation and are l abeled goats the middle are hybrid branches.
this method of ranking is simply one way to combine isolation and delay and is not intended to be definitive for example other rankings could weight one measure more than the other.
we include our two dimensional thresholds in the graph for ease of reading.
the graph shows a number of extreme branches.
approximately of the branches don t avoid any conflicts at all points on the y axis .
these branches do not provide any benefit.
in contrast of the branches provide isolation while incurring only little or no delay branches that lie near the x axis .
these branches are the ideal as they provide benefit at almost no cost .
such identification of sheep and goat branches is most useful if it can inform decisions about future branch structures and if it can be used at any point in the development cycle.
to assess whether what if analysis can inform decisions during development we evaluated the effect of making decisions based on what if analysis prior to the end of a product development cycle.
like many i ndustrial projects windows development occurs in iterations around mil estones.
we performed our what if analysis to evaluate branches based on development of windows that occurred prior to the end of the first milestone m1 .
that is we labeled each branch as a sheep a goat or a hybrid based on the delay and isol ation for that branch in the first mile stone.
we then evaluated the effect of removing goat branches those that provided the least isolation while causing the most delay for the remaining milestones after m1 to determine if taking action based these metrics would be effective.
table shows the results.
by removing branches labeled goats in m1 each edit saved on average .
days of delay from m1 to the end of development and experienced .
additional conflicts each.
in contrast removing sheep branches at m1 would only save .
days of delay per edit while incurring .
additional conflicts more conflicts and less saved time than goats .
to put these va lues in perspective w e compared this to the optimal choice of branches to remove if we had perfect for esight and removed the branches that actually performed wor st post m1.
in that case .
days of delay per edit would be saved at the cost of .
conflicts each.
thus making decisions on which branches are the most costly in m1 achieves of the maximum possible cost savings while incurring only more conflicts than the least possible.
we also examined the correlation between branch categorization based on m1 development and branch categorization after m1.
we found that the category remained the sam e for .
of the branches and a kendall s correlation of branch category before and after m1 was .
p .
.
sheep branches tend to remain sheep goat branches remain goats etc.
both of these results indicate that what if analysis based on deve lopment data mid cycle is reliable.
put more pragmatically decisions about branch practices such as which to remove or which to focus resources on can be made during development with high confidence based on measurement earlier in the development cycle.
.
quantifying the liveness isolation tradeoff our choice of division of branches into sheep goats and hybrids based on a split may see m arbitrary and indeed it is to some degree.
the divisions into the interquartile range and the resulting visu alization were inspired by standard boxplot ana lysis .
the divisions simply represent the tradeoff between providing isolation and reducing delay.
to quantify this tradeoff we compute d regression lines shown in figure for each group.
for confidentiality reasons we are unable to disclose the actual absolute measurement s. however since a regression line defines proportions we normalize to one conflict and use the generic term delay unit .
we found that the average tradeoff was prevented conflict per edit at the cost of delay units for sheep delay units for hybrid and delay units for goats.
thus if one is willing to deal with one confl ict per edit in order to save units of delay per edit these are actually ratios so this is the same as one con flict every two edits to save delay units then goat branches should be eliminated.
in contrast removing a sheep branch will only save delay units per additional conflict.
figure .
usefulness of branches in terms of provided isolation and delay based on recursive branch removal .
top and left shows goat branches low benefit high cost and bottom and right show sheep branches high benefit low cost while those in the center are hybrid branches that exhibit a trade off between delay and isolation.
removal strategy delay saved conflicts added sheep .
days .
goats .
days .
optimal .
days .
table .
the number of days saved and conflicts added per edit if sheep or goats classified from data in t he first milestone are removed for later milestones.
in practice development teams can define the tradeof fs that they are willing to accept and make decisions accordingly.
thresholds are in fact not required in order to use what if analysis results.
for example branches may be ranked according to some comb ination of isolation and delay and those with the lowest ranks could be removed.
.
depth analysis managers have considered limiting the maximum depth of the branch structure due to a belief that liveness would be improved if there are fewer bra nch levels.
until now th is belief has not been empirically confirmed or refuted .
we used what if analysis to investigate branch depth by looking at the total isolation and total delay when restricting the branch structure to different ma ximum depth levels.
a depth level of n means that there are at most n levels of branches below the root which has level .
branches closer to the root are called shallow branches while branches further away from the root are called deep branches.
in this scenario we are not comparing branches to each other but rather taking a global view on the branch structure as a whole.
therefore we use total delay and total isolation and show the percentage decrease in transit time and the percent of edits that cause conflicts.
our findings are shown in t able and are two fold.
first the branches at very deep levels don t actually incur very much delay.
in fact limiting the depth to four levels of branching saves less than .
of the total transit time.
most of the delay c an be attributed to the branches closer to the root.
a policy of maximum branch depth would have to make the branch structure quite sha llow for a non trivial effect on delay however this would come at a rather high cost of severely reduced isolation.
for an .
speedup windows would have had to deal with .
of the edits creating conflicts maximum depth of .
if the branch structure had only a single branch that is the root maximum depth of the transit time would reduce by to for all e dits but then .
of edits would incur con flicts.
having only a single branch is not reasonable for other re asons than just conflicts build breaks would stall the entire pr oject preventing thousands of people from being able to work .
these findings suggest that deep branches actually do not impede liveness.
they may not be needed as they also do not provide much isolation but removing them would have only a trivial e ffect as they integrate their changes to parent branches on a fr equent basis.
in contrast to conventional wisdom that the holdup is a deep branch structure our results show that in the case of wi ndows the key to increasing liveness may actually lie in finding ways to move changes through shallow branches more quickly.
.
discussion in this section we discuss future areas of research in the area of scm branches .
we also present assumptions in our methodology potential threats to result validity as well as our mitigation steps and common misconceptions.
.
branch refactoring and optimization in this paper we have introduced a technique to empirically characterize delay and isolation for individual branches.
this supports data driven decision making on branches for example to identify candidates for deletion.
we believe that this is just the first step towards a new discipline branch refactoring which is the process of improving and refi n ing branch structures as a software project evolves.
for this paper we focused on the refactoring remove useless branch .
howe ver as projects evolve th ere will be other opportunities for refacto ring such as create new branch split branch merge related branches and bypass branch .
a related area is branch opt imization which is concerned with distributing files and people across branches based on empirical evidence.
both branch refactoring and branch optimization offer opportun ities for new research and tool development assemble a branch refactoring catalogue with empirically validated guidelines of when to apply a refactoring.
develop technique s to distribute files people and teams across branches.
build a recommender system to identify branch refactoring opportunities.
train prediction models to predict which branches will turn from sheep to goats.
empirical studies on relationship between br anch structures and code quality.
.
assumptions threats to validity for our survey we identified the following threats to validity.
our selection of survey participants was constrained to only exper ienced engineers in our context engineers who were most active in the scm.
while this skews our results to these engineers they are also the ones who will benefit most by better branch structures.
a related threat is that to some extent our survey operated on a self selection principle the participation in th e survey was voluntary.
as a consequence results might be skewed towards people that are likely to answer the survey such as engineers with extra spare time or who care about branch structures.
avoiding the self selection principle is almost impossible .
as pointed out by singer and vinson the decision of responders to participate could be unduly influenced by the perception of possible benefits or reprisals ensuing from the decision .
some o f our analysis is based on self reported data e.g.
integration time q2 .
ho wever software developers are known to underestimate effort and we consider the estimates to be a lower bound.
for any empi rical study it is difficult to draw general conclusions because of a large number of contextual variables .
for example different sc ms use different merging tools which may affect developers perceptions of difficulty of integration.
in addition the process used by a development project can have a strong relationship with branch structure and frequency of integrations.
however we are confident our techniques can be applied to other proj ects especially given the increased popularity of branching through distri buted version control systems .
to increase the generality of our results we hope to partner with academic researchers to replimax depth transit time decrease isolation edits in conflict .
.
.
.
.
.
.
.
.
table .
the decrease in transit time and percent of edits in conflict if the branch structure is limited to a maximum depth.
depth of represents level of branching below the root etc.
cate this analysis on open source projects such as the l inux kernel.
some key assumptions underlie our results.
first our measures of delay and isolation assume that a similar sequence of checkins and integrations would occur in a different branch structure.
we argue that the changes themselves are necessary to achieve the d esired software functionality and that dependencies between edits introduce a partial order that imposes a similar sequence.
further to minimize the risk of this assumption each scenario is evaluated in its own alternative history with the rest of the branch structure unchanged rather than evaluating the effect of making multiple changes which would likely effect development behavior more intrusively.
second we assume that if a branch had not existed the changes and integrations made on that branch would have instead been made on the parent.
lastly some branches at shallow depths play a quality gating role whereby checkins are a ggregated tested and in some cases corr ected before moving to the root.
branches with such roles should be considered carefully when maki ng decisions .
.
common misconceptions a common misconception about industrial research at large co mpanies such as microsoft is that software projects at micros oft are not representative of other software projects.
while projects might be larger in size most development practices at microsoft are adapted from the general software engineering community and also used outside microsoft.
f or example branches are frequently used at other compa nies and in open source .
another frequent misconception is that empirical research within one company or one project is not good enough provides little value for the academic community and does not contribute to scientific development.
historical evidence shows otherwise.
flyvbjerg provides several examples of individual cases that co ntributed to discovery in physics economics and social science .
beveridge observed for social sciences more discoveries have arisen from intense observation than from statistics applied to large groups as quoted in kuper and kuper page .
please note that this should not be interpreted as a criticism of research that focuses on large samples or entire populations.
for the development of an empirical body of knowledge as championed by basili both types of research are essential.
the work presented in this paper has been successfully applied to three microsoft products windows bing and windows phone .
.
related work to the best of our knowledge this is the first work that empirically assesses the usefulness of software development branches at an individual level.
we were unable to find metrics similar to the ideas of delay and isolation in pre vious research.
we also provide empirical insights into multi branch software development and qualitative observations from developers on efficiency of branc hes.
standard simulation techniques rely on distributions and other methods to generate data and evaluate outcomes.
in co ntrast we use actual data recovered from windows development and replay these activities on differi ng branch structures to answer what if scenarios.
this gives us increased confidence in our r esults as we are not trying to generalize development behavior but use it as it actually happened.
two questions in our survey among developers were based on the list of anti patterns for parallel software development .
several books and articles discuss best practice for software config uration management and branch structures .
however these practices are mainly based on the authors experience and less on em pirical evidence.
with this work we provide a way to empirically assess branches.
perry et al.
observed a high degree and multiple levels of p arallel development in the 5ess system .
they also observed a signi ficant correlation between the degree of parallel work and the number of quality problems in a given component.
zimmermann studied workspace updates in gcc jboss jedit and python and observed that between .
and .
of commits had integr ations .
between .
and .
of integrations could not be automatically resolved by cvs and resulted in conflicts.
brun et al.
pointed out that besides textual conflicts there are also compile conflicts program does not compile and build conflicts program fails test suite when integrating changes .
independently from us in phillips et al.
conducted a survey among version control users and asked how branching and merging are used in practice and what defines a successful branching strategy i n terms of user satisfaction .
premraj et al.
surveyed software personnel on their use of branching and merging .
our survey complements both studies as the que stions asked are different.
we also go beyond user satisfaction and introduce quantitative measurements for cost and benefit of branches.
in our earlier work we explored how people and files span across multiple branches to understand how socio technical factors affect parallel development .
the earlier work measured similarity between branches the focus of this paper is instead on a different aspect of branching namely to measure the cost and benefit of branches.
we also introduced an algorithm to identify the changes and bug fixes that are included in a reverse integration .
several tools have been proposed to inc rease the awareness of changes across different branches or workspaces with the goal to reduce conflicts sarma et al.
developed palant r which shares information about changes to the same files across different wor kspaces .
sarma and colleagues also provided quantitative evidence of the benefits of workspace awareness in software d evelopment and compared pal an t r with two other awareness tools fastdash and collabvs .
in a workshop paper guimar es and rito silva proposed a system for real time integration of changes .
brun et al.
proposed speculative conflict detection which searches for unrecognized conflicts across branches and opportunities for straightforward merging .
.
conclusion we have presented a survey on how branches are used at m icrosoft and an empirical what if analysis to assess cost and benefit of branches to aid in a number of branch related scenarios .
our approach helps to identify and separate high benefit low cost branches from low benefit high cost branches.
such findings enable informed decisions about branch structures and processes such as frequency of integrations regarding branches and allow refining a branc h structure as a project progresses.
we have only touched on branch removal as one possible branch refactoring operation.
there are many other possible operations such as ad ding splitting merging and restructuring branches.
this presents a potential new research area.
with the rise of distributed version control systems such as git and mercurial branching has become more common in open source software development and accessible to a wider r esearch audience.
this provides an opportunity for academic r esearch to have immediate impact in industry where branches are often used to deal with the complexity of software.
.