katch high coverage testing of software patches paul dan marinescu department of computing imperial college london uk p.marinescu imperial.ac.ukcristian cadar department of computing imperial college london uk c.cadar imperial.ac.uk abstract one of the distinguishing characteristics of software systems is that they evolve new patches are committed to software repositories and new versions are released to users on a continuous basis.
unfortunately many of these changes bring unexpected bugs that break the stability of the system or a ect its security.
in this paper we address this problem using a technique for automatically testing code patches.
our technique combines symbolic execution with several novel heuristics based on static and dynamic program analysis which allow it to quickly reach the code of the patch.
we have implemented our approach in a tool called katch which we have applied to all the patches written in a combined period of approximately six years for nineteen mature programs from the popular gnu di utils gnu binutils and gnu ndutils utility suites which are shipped with virtually all unix based distributions.
our results show that katch can automatically synthesise inputs that significantly increase the patch coverage achieved by the existing manual test suites and nd bugs at the moment they are introduced.
categories and subject descriptors d. .
reliability d. .
symbolic execution general terms reliability veri cation keywords patch testing symbolic execution permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russian federation copyright is held by the authors.
publication rights licensed to acm.
acm ... .
figure katch is integrated in the software development life cycle and automatically generates inputs that execute newly added or modi ed code.
.
introduction a large fraction of the cost of maintaining software is associated with detecting and xing errors introduced by recent patches.
it is well known that patches are prone to introduce failures .
as a result users often refuse to upgrade their software to the most recent version relying instead on older versions which are frequently prone to critical bugs and have a reduced set of features.
in this paper we aim to improve the quality of software patches by providing the means to automatically test them.
over the last years we have seen signi cant advances in test generation techniques in particular dynamic symbolic execution has proved to be a good t for comprehensively testing real software through its ability to systematically explore di erent program paths accurately reason about memory and interact with uninstrumented code.
the vast majority of work on dynamic symbolic execution has focused on wholeprogram testing in which all parts of the program are treated equally.
however more recent work has looked at various forms of incremental or directed dynamic symbolic execution where the testing e ort is focused on code that has changed from one version to the next .
despite this recent progress we are still far away from the goal of quickly and automatically generating test cases that cover code changes in real programs.
this paper aims to improve the state of the art in the area by developing novel techniques that can rapidly cover recently changed code and applying these techniques to a large number of indiscriminately chosen patches speci cally to all patches written in a combined period of six years for gnu diffutils gnu binutils andgnu findutils .at a high level we envision a system which we call katch that would be fully integrated in the software development cycle as shown in figure .
when a new patch is sent to the repository our system automatically explores paths through the patch code using dynamic symbolic execution augmented with several patch aware heuristics and provides to the developer a set of test inputs that achieve high coverage of the patch code which could be added to the regression suite and a report of any bugs introduced by the patch accompanied by actual inputs that trigger them.
to be adopted by developers a system like katch has to meet several requirements it has to be easy to use ideally fully automatic it has to be fast to encourage developers to run it after every single commit and it has to demonstrate value by nding bugs and generating inputs that cover more code through the patch than existing manual test suites.
in this paper we provide some promising evidence that such a system could become a reality.
in our experiments on all the patches written in a combined period of around six years for nineteen applications katch was able to signi cantly increase the overall patch coverage and nd fteen distinct bugs while spending only a relatively short amount of time per patch.
in summary the main contributions of this paper are .
a technique for patch testing that combines symbolic execution with several novel heuristics based on program analysis that e ectively exploit the program structure and existing program inputs .
a exible system called katch based on the stateof the art symbolic execution engine klee that implements these techniques for real c programs .
a thorough evaluation of our technique on all patches made to nineteen programs in the gnu diffutils gnu binutils andgnu findutils application suites over a cumulative period of approximately six years.
the rest of this paper is structured as follows.
we give a brief overview of katch x2 describe our approach in detail x3 and present the most important implementation details x4 .
we then evaluate katch x5 discuss related work x6 and conclude x7 .
.
overview while the code of real software systems is frequently changing these changes or patches are often poorly tested by developers.
in fact as we report in x5.
developers often add or modify lines of code without adding a single test that executes them!
to some extent we have not found this result surprising as we know from experience how di cult it can be to construct a test case that covers a particular line of code.
while the problem of generating inputs that cover speci c parts of a program is generally undecidable we believe that in many practical circumstances it is possible to automatically construct such inputs in a reasonable amount of time.
our system katch uses several insights to implement a robust solution.
first katch uses existing test cases from the program s regression suite which come for free and 1the name comes from k atch.
klee is an open source symbolic execution engine on which katch is based.
8aabcdec 6f a 3b 9c 10b 4f 3b 9c 3b 9cec 8d 8c 3b 9c 1a 18bcb 3b 9c a 1bb 5bcd 1c 1d 1e 1f 9d 1e 8a 19afb 1b 9d bc 6f 3afigure the main stages of the katch patch testing infrastructure.
often already execute interesting parts of the code as a starting point for synthesising new inputs.
for each test case input katch computes an estimated distance to the patch and then selects the closest input x3.
as the starting point for symbolic exploration.
second symbolic execution provides a framework for navigating intelligently through the intricate set of paths through a program starting from the trace obtained by running the previously identi ed closest input.
to reach the patch katch employs three heuristics based on program analysis greedy exploration informed path regeneration x3.
and de nition switching x3.
.
figure presents the high level architecture of katch .
the framework takes as input a program a set of existing program inputs and a patch description in the form of a diff le and automatically constructs new inputs that execute the patch code by following three steps.
patch preprocessing is responsible for parsing the raw patch le and splitting it into lines of code.
lines of code that are part of the same basic block and thus always executed together are grouped to form a single target .
targets which are already executed by the program s regression suite are dismissed at this step.
for each remaining target the following stages are executed to synthesise an input which exercises it.
input selection leverages the fact that real applications already come with regression suites that contain a rich set of well formed inputs created by the developers.
input selection takes as input the program a target and an existing test suite.
it then associates with each of the test inputs adistance estimating the e ort required to modify it such that it executes the target.
the closest input to the target is then used in the next stage.
the last step combines symbolic execution with three heuristics based on program analysis to derive a new input that exercises the target starting from the input selected at the previous step.
the role of symbolic execution is twofold.
first it provides a framework for inspecting the program branch decisions and their relation to program inputs and gives the means to generate new inputs by changing the outcome of particular branches.
second it thoroughly checks program operations such as memory accesses and assertions in order to nd errors.
the heuristics based on program analysis complement symbolic execution by partly mitigating its scalability problems and steering it actively towards the target.
to scale this process to multiple systems and hundreds or thousands of patches we have also built an infrastructure which executes automatically as appropriate each of the previous steps requiring no changes to the systems under test nor to their regression suites x4 .
.
katch this section describes in more detail the katch patch testing infrastructure patch preprocessing x3.
input selection with weakest preconditions x3.
greedy exploration with informed path regeneration x3.
and de nition switching x3.
.
.
patch preprocessing the rst stage of our analysis is mainly responsible for retrieving each program version from the version control system determining the di erences from the previous version i.e.
the patch and breaking this patch into lines which are then handled individually by the subsequent steps.
in addition the lines are ltered and consolidated when appropriate as described next.
while each line in a patch is a potential target to katch in practice many lines do not need to be considered.
first source code contains many non executable lines such as declarations comments blank lines or lines not compiled into the executable due to conditional compilation directives.
second lines which are part of the same basic block are always going to be executed together so we only need to keep one representative per basic block.
finally we are not interested in lines already covered by the system s regression test suite.
the patch preprocessing stage is responsible for eliminating all these lines and works in two steps a rst step performs a simple static pass to eliminate non executable code and all but one line in each basic block and a second step runs the program s regression suite to eliminate lines already covered by its test cases.
this results in a set of lines which are on the one hand executable and on the other hand are not executed by the program s test suite which we call targets .
each of them is processed individually in the following stages.
.
seed selection with weakest preconditions our input synthesis technique starts from an existing program input called the seed extracted from the program s test suite and iteratively changes it.
the ideal seed executes code which is close to the target in order to allow katch to quickly steer execution by switching only a few branch outcomes to reach the target.
to estimate the distance between the path executed by a seed and the target we calculate the static minimum distance in the program s interprocedural control ow graph cfg between each basic block exercised by the seed and the target basic block.
intuitively the e ort of symbolic execution lies in switching the outcome of branch statements therefore we compute this distance in terms of the number of branch statements between the two basic blocks.
we also simplify the minimum distance computation by not requiring it to be context sensitive.
to do this we note that pairs of matched function calls and returns should not contribute to the distance between two basic blocks.
in practice this means that we can shortcut function calls i.e.
each function call introduces an edge to the instruction immediately following the call in addition to the edge to the target function.
in turn shortcutting function calls allows us to remove all return edges simplifying the analysis.
however the estimated distance outlined so far which we call cow distance as it only takes the control ow into account can select inputs which exercise paths close1if input f 4if input if input f input 8void f intx f if x target 11gc ow 0wp figure code snippet with instructions annotated with the minimum distance to the target computed using only controlow analysis cow column and controlow analysis combined with our weakest precondition variant wp column .
to a target but cannot be easily changed to actually reach the target.
in the interest of simplicity we show a contrived example in figure to illustrate such a scenario.
the code snippet takes a single integer as input and uses it to decide whether to call function f which contains the target.
the only input which exercises the target is .
the gure also shows the cow distance from each instruction to the target.
for example the cow distance for the instruction at line is because the shortest path to the target traverses two branches on lines and .
for simplicity assume that we only want to assess whether input50is better than input .
from a pure controlow perspective 50appears to be a better choice because it exercises function fand gets to the ifcondition guarding the target while 150does not call fat all .
upon closer inspection however it is clear that the target guard condition x is always false on this path because function fis called with argument 0on line and therefore the target cannot get executed through this call.
this observation led us to create a technique which automatically prunes cfg edges which can be proven to make the target unreachable.
to nd such edges we use an interprocedural dataow analysis which computes for each target and basic block in the program a necessary condition to reach that target a form of weakest preconditions .
if by traversing an edge we obtain a false condition we conclude that the target is unreachable through that edge.
considering the same example the branch on line which guards the target creates the condition x while the edge from the function call at line de nes xto be0.
by substitution we obtain the formula which evaluates to false and conclude that the function call on line cannot help in reaching the target.
column wpof figure shows the minimum distance from each instruction to the target after removing the edge introduced by this function call.
lines and have their distances updated.
for the interested reader we present the dataow equations which compute the preconditions relative to a target at the beginning and at the end of each basic block and give an intuition on their correctness.
outb w s2succ b cond b!s ins inb wp b out b with initial values intarget true outtarget false inb outb false 8b6 target cond b!srepresents the condition required to go from basic block btos.
for unconditional branches the condition is alwaystrue.wp b out b is the standard weakest precondition function applied to basic block band postcondition outb which is easily computed for a single basic block as we describe below.
the equations guarantee that any edge b!sfor which cond b!s insisfalse and any basic block bfor which inb isfalse cannot lead to the target.
the rst equation intuitively says that at the end of a basic block b the condition to reach the target is the disjunction of the conditions for all possible paths from that basic block to the target.
the second equation obtains the weakest precondition for a basic block from its corresponding postcondition.
this is done by iterating through the instructions of the basic block in reverse order and substituting all variables from the postcondition with their de nition as appropriate.
a variable not de ned in the current basic block is left unchanged.
when applied to the target basic block the wpfunction always yields true.
solving the system is done using a standard xed point computation approach.
our implementation makes two conservative approximations to make the analysis tractable even on large programs.
first the wpfunction only handles assignments.
if the basic block applies other operations to the postcondition variables the returned value is true.
second a disjunction of syntactically non identical formulae in the rst equation is also treated as true to prevent formulae from growing exponentially.
these two approximations capture two common practical cases.
first formulae which become false when applying thewpfunction usually correspond to code patterns which use boolean ags or enumerated type variables in branch conditions basic blocks which for example set a ag to false and make a certain branch infeasible are recognised accordingly.
the example in figure is such a case.
second formulae may become false because the set of conjuncts accumulated through the rst dataow equation becomes inconsistent.
this case correspond to patterns where the same variables are used in branch conditions multiple times possibly in di erent parts of the program and some of the conditions are mutually incompatible.
a simple example can be observed in figure the weakest preconditions algorithm can prove that the branch between lines !
does not to lead to the target because the branch condition input is incompatible with the condition input which appears subsequently on the only path to the target.
after obtaining the distance from each basic block to the target through the controlow analysis and the branches and basic blocks that cannot lead to the target through the weakest preconditions analysis the distance from each available seed input to the target is computed as follows .
compute the subgraph gof the program s cfg induced by running the program on the seed input.
g s nodes are the basic blocks executed and its edges are the branches taken during execution .
remove all nodes and edges in gwhich were proven to make the target unreachable .
iteratively remove from gall nodes orphaned by the previous step i.e.
while there are nodes with in degree except the program entry point remove them and all their outgoing edges .
choose the minimum from the distances of the remaining nodes to the target.
.
greedy exploration with informed path regeneration the last and most challenging stage of katch is responsible for transforming the previously selected seed input into a new input that executes the target.
our approach is based on symbolic execution a program analysis technique that can systematically explore paths through a program.
the key idea behind symbolic execution is to run the program on symbolic input which is initially allowed to have any value.
then whenever a branch depending directly or indirectly on the symbolic input is encountered execution is conceptually forked to follow both sides if both are feasible adding appropriate constraints on each side of the branch.
finally whenever a path terminates or hits an error the constraints gathered on that path are solved to produce a concrete input that exercises the path.
for example if we run the code in figure treating the input variable as symbolic then at branch execution will be split into two paths one following the thenside of the branch on which we add the constraint that input and one following the implicit else side of the branch on which we add the constraint that input .
when the path with the constraint input reaches line only the else side is feasible so no other path is spawned at this point.
on the other hand when the path with the constraint input 100reaches line both sides are feasible so execution is again split into two paths one on which we add the constraint that input and one on which we add the constraint that input which together with the existing constraint that input 100gets simpli ed to input .
the branches at lines and similarly spawn new execution paths.
finally when a path terminates a constraint solver is used to generate a solution to all the constraints gathered on that path which represents an input that can be used to exercise the path.
for example the path with the constraints input input andinput 200may return the solution input which exercises that path.
in our approach we start symbolic execution from an existing input the seed similarly to the approach taken in concolic execution and our zesti system .
the seed is then iteratively modi ed by exploring paths which get closer to the target symbolic execution provides the framework for the exploration and constraint solving is used to map program paths back to inputs.
the novelty of our approach lies in the way paths are selected for exploration.
the selection is based on a metric which estimates the distance from a path to the target similar to the distance used by the input selection stage x3.
.
in each iteration we execute the program using the latest input and remember all branch points e.g.
if conditions along with information necessary to continue execution on the other side of the branch should we later decide to.
we then select the branch point whose unexplored side sis closest to the target according to the estimated distance and attempt to explore this side.
if sis feasible 1void log char input f int le open access.log owronlyjoappend if input input f write le input 5gelsef char escinput escape input write le escinput 8g close le 10g figure example based on lighttpd patch2660used to illustrate the greedy exploration step.
lines represent the patch.
i.e.
the conjunction of the branch condition towards sand the current path condition is satis able we eagerly explore it in what we call a greedy exploration step .
otherwise we examine two possibilities the branch condition is symbolic i.e.
it has a data dependence on program input on the current path and the branch condition is concrete i.e.
it has a control dependence on program input.
informally a branch condition is data dependent on program input if data propagates from the input to at least one of the variables involved in the branch condition via a sequence of assignments.
a condition is control dependent on the input if at least one variable involved in the condition has more than one reaching de nition.
note that some conditions can be both data and control dependent.
for data dependent conditions including those which are also control dependent we apply informed path regeneration where we travel back to the branch point that made s infeasible and take there the other side of the branch.
for control dependent conditions we attempt to nd a di erent de nition for the variables involved in the condition such that the condition becomes true.
in the following we examine each of these cases in detail.
to illustrate our approach we use the code snippet in figure which is based on a patch introduced in revision2660 of thelighttpd web server which we analysed in prior work .
the logfunction takes a single character as input and writes it into a text le.
the function was initially writing all characters unmodi ed but was patched in order to escape sensitive characters that could corrupt the le structure.
however the program was tested only with printable character inputs and thus the else branch was never executed.
after seeding the analysis with such an input containing only printable characters our technique determines that the else side of the symbolic branch point at line is the unexplored branch side closest to the patch in fact it is part of the patch and goes on to explore it in a greedy exploration step by negating the condition on line .
to understand when informed path regeneration is necessary consider the example in figure in which the log function of figure is called for each character of the requestverb string.
assuming that the seed request contains thegetverb the comparison at line constrains this input to the value getfor the remainder of the execution.
changing any of the characters in the requestverb is impossible after1if strcmp requestverb get f...g .
.
.
2for char p requestverb p p f log p figure example based on lighttpd patch2660used to illustrate the informed path regeneration step.
as in figure the patch is on lines of the log function.
this point because it would create an inconsistent execution and thus on this path we cannot follow the else side of the branch in the logfunction.
instead our informed path regeneration step travels back just before the execution of the symbolic branch point that introduced the constraint that makes the patch unreachable and then explores the other side of that branch point.
in our example that symbolic branch point is the one at whichrequestverb was constrained to be t and thus our technique takes here the other side of the branch in whichrequestverb is constrained to be di erent from t .
with this updated path condition execution reaches again line of the logfunction where execution is allowed to take theelse path and thus cover the patch.
.
definition switching informed path regeneration does not work if the branch condition has a concrete value essentially because we cannot reason symbolically about concrete expressions.
this case occurs when the condition does not have a data dependence on the input on the currently explored path but only a control dependence.
figure containing code from diffutils revision 8739d45f showcases such a scenario.
the revision modi es line which is our target.
to execute the patch one needs to pass through the switch statement on line requiring ig white space and in turn ignore white space to be equal to the ignore all space constant.
this only happens when the program is given the w command line argument line .
assuming the current input does not include w the lack of a data dependence between the switch condition and the command line arguments renders informed path regeneration unusable.
to solve this problem we use a lightweight approach that nds the reaching de nitions for the variables involved in the condition using static analysis and then attempts to nd a path to an uncovered de nition using the two techniques previously presented.
to further improve the chances of getting the right de nition early the algorithm gives priority to de nitions that can be statically shown to satisfy the target branch condition.
furthermore the algorithm works recursively on all de nitions which were already executed but for which the right hand side is not a constant.
that is the algorithm can be nested multiple times by using a stack of intermediary targets when a de nition needs to be switched the active target is saved on the stack and the selected de nition becomes the new active target.
as soon as the de nition is executed the previous target is popped o the stack.
to show how de nition switching works in practice consider the same code snippet and the input a y a b provided by input selection which compares two les aandb treating them as text a and outputs the results side by src io.c enum diff whsp ig white space ignore white space ... switch igwhite space 231f caseignore all space while c p !
n if !
isspace c h hash h ig case ?
tolower c c break src di .c while c getopt long argc argv shortopts longopts null !
292f switch c 294f ... case b if ignore white space ignore space change ignore white space ignore space change break case z if ignore white space ignore space change ignore white spacej ignore trailing space ... case e if ignore white space ignore space change ignore white spacej ignore tab expansion break ... case w ignore white space ignore all space break figure example from diffutils revision 8739d45f showcasing the need for de nition switching.
the patch is on line and is guarded by a condition that is control dependent on the input.
side y .
this input reaches the guarding switch statement on line but evaluates to a di erent case.
to reach the target we need to modify the input such that the conditionig white space ignore all space is satis ed.
because the condition does not have a data dependence on the input katch attempts to nd another de nition for the ig white space local variable and discovers one on line .
however it detects that this de nition was already executed so it recursively attempts to nd de nitions for the righthand side of the assignment the ignore white space global variable.
at this point katch nds four de nitions each corresponding to a di erent command line argument and decides to use ignore white space ignore all space because it matches exactly the original condition which it attempts to satisfy.
katch now pushes the original target line to the stack and changes the active target to line .
it thenrepo git git.savannah.gnu.org diffutils.git difftargets src lib programs src diff src diff3 src sdiff src cmp libs lrt figure con guration le used to test diffutils .
the le speci es the repository address the folders which may contain relevant changes the programs to test and the libraries required to build the system.
uses an informed path regeneration step to replace the rst command line argument with the required woption.
this reaches the intermediary target which causes the original target to be popped o the target stack and transformed back into the active target.
execution continues and this time the ignore white space andig white space variables have the appropriate values to reach the patch.
the synthesised input which reaches the patch is w y a b .
.
implementation katch consists of patch preprocessing scripts the input selection subsystem the augmented symbolic execution tool and a set of scripts which automatically iterate through all patches in a given set of program revisions.
most components operate at the level of llvm bitcode the intermediate language used by the popular llvm compiler .
at a high level a tester is only required to create a conguration le with details about the system to test such as the repository address and the names of targeted executable les.
figure shows the actual le used for testing diffutils .
optionally the tester can also provide scripts for compiling the system and running its regression suite.
otherwise the default configure make andmake check commands are used adapted for creating llvm bitcode along with the native executables.
having this setup the tester only needs to issue a command such as .
test patch multiple diffutils rev1 rev2 to test all diffutils revisions between rev1 and rev2.
this script could be easily added to a continuous integration system to automatically test the last patch.
.
patch preprocessing patch preprocessing is implemented via two llvm passes the rst one statically prunes non executable lines by traversing the compiled program and using debug information to map llvm instructions back to source code a line is deemed non executable if no instruction maps back to it.
the second pass instruments the program to obtain test suite coverage information and determine which patch lines are executed by the test suite.
.
input selection input selection uses a combination of scripts and llvm passes to instrument the program and analyse the execution of its test suite.
in this phase the original executables speci ed in the con guration le are replaced with wrapper scripts that invoke an instrumented copy of the corresponding binary.
for each target the instrumentation computes and outputs to a le the minimum distance from each test suite input allowing the wrapper to determine which inputgets closest to the target.
this input is identi ed transparently by its sequence number i.e.
the number of times the program was executed by the test suite so far.
subsequently we run the test suite again and when reaching the target sequence number we invoke katch instead of the regular executable.
the only assumption made by our approach is that the order of running the tests is deterministic which holds in all cases we have looked at.
while we could have used other solutions we found that they are either not as general or they do not perform as well.
for example a di erent solution would be to record the program arguments used to get to the minimum distance instead of the sequence number and then run katch directly using these arguments.
however this approach fails when the test suite harness creates any non trivial setup not captured by the command line arguments such as les pipes or environment variables.
another approach is to directly run katch on all test inputs.
the downside is the larger overhead symbolically interpreting the program is several orders of magnitude slower than native execution while the instrumented programs have a comparable execution time to their native counterparts.
instrumenting the program is performed through an llvm pass which takes as input the original program and the current target.
the pass uses a standard shortest path algorithm to statically compute the distance from each basic block to the target in the program s interprocedural control ow graph and adds code to each basic block to record this distance at runtime.
it further uses the weakest precondition dataow analysis described in x3.
to re ne this distance and inserts code in the executable to eliminate from the computation those branches which provably cannot lead to the target.
to increase maintainability most of the instrumentation is written in c as a set of helper functions which are then statically linked with the target program.
.
symbolic exploration katch is implemented on top of the klee open source symbolic execution engine.
katch starts by executing the program on the path induced by the selected seed input to completion or until a prede ned timeout expires.
on this path it records all possible branches feasible and infeasible that the program does not take.
this provides more information for selecting the next path as opposed to previous approaches which only considered the feasible branches.
the branches are then considered in order of increasing distance to the target as candidates for one of the techniques employed by katch greedy exploration for feasible branches and informed path regeneration or de nition switching for infeasible branches.
once a suitable branch is found the process repeats executing a batch of instructions and reevaluating the available paths.
we decided to use a batch of instructions instead of a single one because this o ers the advantage of generating more paths to choose from at the next iteration with only a small time penalty e ectively providing a form of lookahead.
in certain scenarios this compensates for the underestimation of the distance between two instructions by permitting the execution of longer paths than dictated by the static estimation.
our implementation currently uses batches of llvm instructions.
katch uses another optimisation to handle e ciently several common functions whose use is expensive in a sym bolic execution context the getopt family of functions and strcmp .
for space reasons we discuss only getopt below.
thegetopt functions are helpers used by many programs to process command line arguments.
they work by allowing the programmer to write a simple speci cation of the arguments accepted by the program thus moving the bulk of the command line parsing code inside the library functions.
katch is aware of the getopt semantics and uses this information to speed up processing.
more precisely whenever the return value of getopt is a reaching de nition instead of recursively descending in the function code it inspects the function argument corresponding to the speci cation of accepted command line arguments and directly determines the command line option needed to obtain the desired definition.
the new argument is added to the command line and program execution restarts from the beginning.
.
limitations we discuss below the most signi cant limitations of our current prototype.
most importantly we currently do not handle targets which are accessible only through function pointer calls that have not been exercised by the regression suite.
such indirect calls pose problems both during the static analysis when computing the closest input and during dynamic exploration.
the problems could be mitigated by including support for pointer analysis which katch currently does not o er.
second our current implementation of de nition switching does not support aggregate data types such as structures and arrays.
finally klee s environment model is incomplete e.g.
it does not handle certain system calls.
.
experimental ev aluation for an objective evaluation of our technique we have set ourselves the following two requirements.
first we have decided to do no cherry picking once we have chosen a set of benchmark programs rather than selecting the or or patches on which our technique works well we included all the patches written over an extended period of time.
second we have decided to allow a short timeout for our system of no more than minutes which we believe is representative for the amount of time developers typically dedicate to testing a patch.
we evaluated katch on nineteen programs from the gnu diffutils gnu binutils andgnu findutils systems.
these are all mature and widely used programs installed on virtually all unix based distributions.
gnu ndutils is a collection of three programs find xargs andlocate .
they are smaller in size than the other two benchmarks having a combined lines of code loc in the tools themselves and include additional portions of code from gnulib which totals more than loc at the latest revision that we inspected.
we examined the patches written in the two years and two months period between november and january .
gnu di utils comprises four programs diff sdiff diff3 andcmp.
they are of medium size with loc in the tools themselves and include additional portions of code from gnulib similarly to findutils .
we have analysed all the patches written during the .
years between november and may .
2we report the number of loc in the latest version tested measured usingcloc .
160targets distancecovered by katch not covered by katchfigure distribution of minimum distances for the targets not covered by the regression suites.
the gure does not include binutils targets accessible only through indirect function calls not exercised by the test suite which are outside the current capabilities of katch.
each bar also shows the fraction of target covered by katch.
gnu binutils includes a variety of programs out of which we selected the twelve assorted binary utilities from the binutils folder addr2line ar cxxfilt elfedit nm objcopy objdump ranlib readelf size strings andstrip .
they contain loc and use the statically linked libraries libbfd libopcodes andlibiberty which total over loc.
because of the more accelerated development pace in binutils we examined a shorter year months period between april and august in which patches were added to the binutils directory.
we set a short timeout of ten minutes per target for findutils anddiffutils and a timeout of fteen minutes for the larger binutils programs.
we used a four core intel xeon e3 machine with gb of ram running a bit fedora system.
as an extra safety check we veri ed that all inputs generated by katch execute the corresponding patch code on the natively compiled programs using gcov for coverage measurement.
our tool and results have been successfully evaluated by the esec fse artifact evaluation committee and found to meet expectations.
.
coverage improvement as a rst measure of katch s e ectiveness we looked at its ability to improve patch coverage .
because katch operates at the basic block level we de ne patch coverage as the number of executed basic blocks which contain statements added or modi ed by a patch over the total number of basic blocks which contain such statements.
the patches analysed contain altogether textual lines of code.3after processing these lines to remove non executable statements and group related executable lines we obtained potential targets which are part of patches.
upon manual inspection we found that the rest of the patches only keep the build system up todate with the program dependencies or make changes to 3this includes only lines in .cand.h les.table number of targets covered by the manual test suite and the manual test suite plus katch.
program targets covered suite test test katch findutils diffutils binutils total the documentation or test suite.
a total of targets were already covered by the system s test suite leaving targets for katch to analyse.
the rst step performed by katch is to compute the minimum distance from the regression test inputs to each target.
figure presents the distribution of the minimum distances which also provides a rough estimate of the work that katch needs to do for each target.
more than half of the targets have regression tests which get relatively close to the target at a distance smaller than ve.
just a small fraction of the targets are at a distance over which are all contained in completely untested binutils features.
the gure does not include binutils targets accessible only through indirect function calls not exercised by the test suite which are outside the current capabilities of katch .
table summarises the results obtained after applying katch to these targets.
the targets column lists the total number of targets for each benchmark and the covered column lists the number of targets covered by the regression test suite respectively the regression test suite and katch .
it can be seen that katch has automatically increased the overall patch coverage from to covering out of the targets .
we analyse below the cases in which katch fails to reach the target in order to illustrate its limitations.
more than half of the cases are targets accessible only through indirect function calls never exercised by the test suite which our current prototype does not handle see x4.
.
another large number of cases relate to complex or multiple guard conditions.
to satisfy them katch would need to alter the input structure or to have access to a richer test suite containing di erent seed inputs.
for example manybinutils targets are only executed when the input le contains speci c sections with an individually de ned structure.
when none of the test suite les contains such a section type the targets are usually not covered because katch cannot synthesise a complete section from scratch in the allotted time.
a more subtle scenario involves data stored using variablelength encoding which is often used by binutils .
in this case katch can easily change input values only as long as they would be encoded using the same length.
changing to a value with a di erent encoding length would require inserting or removing one or more bytes in the middle of the input signi cantly increasing complexity by possibly a ecting other parts of the input such as header o sets.
therefore katch works best when the seed input does not need to have its structure altered.
this is an inherent limitation of symbolic execution which does not treat the input structure e.g.
its size symbolically.
this limitation is mitigated as the test suite quality improves and the chances of nding a good seed input increase.table number of targets covered by di erent combinations of heuristics greedy g greedy and informed path regeneration g ipr greedy and de nition switching g ds and all katch .
program g g ipr g ds katch suite findutils diffutils binutils total the fact that our de nition switching analysis does not support aggregate data types x4.
also a ects several targets.
a smaller number of targets cannot be reached due to the incomplete environment model implemented in klee such as unsupported system calls.
finally we also noticed that several targets were not covered because they correspond to unreachable code on our test system e.g.
are reachable only on operating systems which di erentiate between text and binary les.
in addition to the overall coverage improvement we also wanted to measure exactly the contribution of each heuristic used by katch .
we therefore re executed the same experiments selectively disabling all possible combinations of heuristics note that all heuristics depend on greedy .
table shows the results.
it can be seen that the improvement brought by each heuristic varies from system to system.
at one end of the spectrum diffutils covers more targets when using all heuristics compared to greedy alone while at the other end findutils sees only a improvement.
overall informed path regeneration and de nition switching combined brought a improvement.
we have also run our experiments using klee instead of katch to see how well a pure dynamic symbolic execution approach performs.
we ran klee for minutes on each revision and we used an appropriate set of symbolic arguments.
the results were very poor with only two targets covered in the smaller findutils programs.
.
bugs found katch was also able to identify a total of fteen distinct crash bugs.
we could verify that thirteen of these are also present in the latest version and we reported them to the developers providing automatically generated inputs which trigger them.
eleven of the bugs were discovered as a direct consequence of katch s goal to reach the target six bugs are in the actual targets and are discovered as they are introduced while the other ve are discovered because code is introduced in their vicinity.
one bug was found in findutils and the rest were found inbinutils the largest and most complex of all three application suites.
a manual analysis of the bugs revealed that they relate to the handling of unexpected inputs.
interestingly binutils generally does a good job handling such situations but in several cases the checks performed are incomplete.
an example is bug 152064inobjdump a bu er over ow caused by improperly checked bu er bounds.
the bug appears in revision 119e7b90 shown in part in figure .
process extlineop unsigned char data intisstmt ... len read leb128 data bytes read data bytes read ... unsigned int rlen len bytes read ... for rlen rlen printf 02x data figure example showing a bug found by katch introduced in binutils revision 119e7b90 .
the bug is triggered on line .
the highlighted lines are part of the patch.
binutils readelf.c while external elfexternal note char pnotes length 12233f ... if !isia64 vms 12239f inote.type byte get external type inote.namesz byte get external namesz figure example showing a bug found by katch introduced in binutils revision b895e9d .
the bug is triggered on line .
the highlighted line is part of the patch.
line reads the bu er size from the bu er itself and lines and rely on this size to iterate through the entire bu er.
the over ow occurs if the size read does not match the allocated bu er size.
another example is the readelf bug 5shown in figure .
this bug was detected in revision b895e9d when code was added to conditionally execute several existing lines.
none of the code shown was executed by the regression tests.
line was newly added therefore katch used it as a target and eventually executed it.
it then attempted to run the program until the end and reached the next line where it discovered an over ow when reading through the external pointer.
we have not debugged the exact root cause of the bug ourselves but we sent an input triggering the crash to the developers who xed it shortly.
.
related work synthesising inputs which cover a target is an essential problem in test generation and debugging and has been addressed through a variety of techniques including symbolic execution dependence analysis iterative relaxation and search based software testing among others .
we borrow ideas from the state of the art in these areas our approach di ers by treating the task as an optimisation problem where we try to explore paths that minimise the estimated distance to the target using symbolic execution seeded with existing test inputs and enhanced with various heuristics based on program analysis.
we introduced our approach in a workshop paper which phrased the problem in terms of distance minimisation combined with input selection.
however the technique described there was limited to the basic algorithm in x3.
and did not include any of the advanced program analyses in particular weakest preconditions for input selection and switching de nitions for control dependent branches which are necessary to make it practical to a wide variety of patch types.
furthermore the workshop paper only evaluated the approach on three hand chosen patches while here we include an extensive evaluation on all the patches written for nineteen programs over a combined period of six years.
our technique ts within the paradigms of longitudinal and di erential program analysis in which the testing e ort is directed toward the parts of a program that have changed from one version to the next i.e.
software patches.
in particular di erential symbolic execution introduces a general framework for using symbolic execution to compute the behavioural characterisation of a program change and discusses several applications including regression test generation.
the work most closely related to katch is that on directed symbolic execution.
xu and rothermel introduced directed test suite augmentation in which existing test suites are combined with dynamic symbolic execution to exercise uncovered branches in a patch.
the technique is similar to the greedy step in katch without any of our additional analyses.
researchers have proposed several improvements to this technique express prunes cfg branches which provably do not lead to the patch directed symbolic execution introduces call chain backward symbolic execution as a guiding technique for symbolic execution staticallydirected test generation uses the size of the target s backward slice reachable from the current state as an estimate for the likelihood of reaching it.
directed incremental symbolic execution is a related technique which improves the e ciency of symbolic execution when having to analyse only the di erences between two program versions.
it can dynamically prune program paths which exercise the same behaviours in two program versions and could be combined with katch if multiple behaviourally di erent inputs which cover the patch are desired.
while it is di cult to accurately compare these techniques with katch or among each other we believe that katch improves upon previous work in several ways.
first by using the de nition switching heuristic katch takes into account more than the currently explored set of paths and reasoning about unexecuted statements is critical for reaching certain targets.
second informed path regeneration uses a surgical approach to reaching previously infeasible states by making changes to exactly those variables involved in infeasible branch conditions.
third our evaluation is performed on signi cantly more patches than in prior work which gives a better insight into the strengths and limitations of such a technique.
finally we believe katch could be combined with some of these prior approaches e.g.
itcould dynamically prune paths that are shown not to lead to the target.
katch also shares characteristics with search based software testing sbst .
first our notion of estimated distance is similar to that of tness in sbst.
second the idea of reusing existing test cases has also been successfully employed in sbst .
future work could try to combine these techniques for the purpose of patch testing.
research on automatic generation of lters based on vulnerability signatures addresses the problem of executing a speci c target from a di erent angle.
given an existing input which exploits a program vulnerability the goal is to infer the entire class of inputs that lead to that vulnerability.
similarly generating inputs with the same e ect as a crashing input but which do not leak sensitive data is used in bug reporting to preserve user privacy .
in the context of automated debugging execution synthesis and bugredux attempt to solve a similar problem generating an input or a path starting from a set of waypoints through which execution has to pass.
research on test suite augmentation requirements has used the di erences between two program versions to derive requirements that test suites have to meet in order to ensure proper patch testing .
while we currently only use simple coverage metrics to guide our analysis it is possible to combine our approach with such requirements.
.
discussion and conclusion we have presented katch an automated technique for testing software patches.
our approach relies on symbolic execution augmented by several synergistic heuristics based on static and dynamic program analysis.
we have applied katch to all the patches written for nineteen programs over a combined period of approximately six years and have shown that our technique can nd bugs and signi cantly increase patch coverage with only a few minutes per target.
we have learned several lessons from this research.
first it has reminded us that achieving high patch coverage is hard and that as a result most patches remain untested e.g.
for our benchmarks the manual patch coverage was a modest overall.
second it has reinforced our belief that automatic techniques are able to increase patch coverage and nd bugs in the process.
on average katch was able to increase patch coverage from to while on the best performing benchmark diffutils it more than doubled it from to .
in addition we found fteen crash bugs in widelyused mature programs.
finally it has shown us that the state of the art needs more advances to reach the goal of fully automated testing of real patches despite the increase in coverage and the bugs found katch was still unable to cover most of the targets in thebinutils programs.
we hope our current results will act as a challenge to other researchers working in this area.
.