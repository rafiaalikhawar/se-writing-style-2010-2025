seeking the user interface steven p. reiss department of computer science brown university providence ri.
usa spr cs.brown.edu abstract user interface design and coding can be complex and messy.
we describe a system that uses code search to simplify and automate the generation of such code.
we start with a simple sketch of the desired interface along with a set of keywords describing theapplication context.
we then use existing code search engines to find results based on the keywords.
we look for potential javabased user interface solutions within those results and apply aseries of code transformations to the solutions to generate derivative solutions aiming to get solutions that constitute only the user interface and that will compile and run.
we run the resultant solu tions and compare the generated interfaces to the user s sketches.
finally we let programmers interact with the matched solutions and return the running code for the solutions they choose.
thesystem can be used not only for generating initial user interface code for an application but also for exploring alternative interfaces and for looking at the user interfaces in a code repository.
categories and subject descriptors d. .
design tools and techniques user interfaces.
keywords code search user interfaces user interface generation tools.
.
introduction user interfaces are always fun to design and create.
the coding involves understanding complex widget sets building multiple prototypes to try achieving the best user experience convoluted inverted control based code and a variety of layout strategies.the resultant code is often complex bug ridden difficult to maintain and not particularly transparent.
testing user interfaces especially during development is difficult and time consuming testinginterfaces aesthetics and usability even more so.
yet user interfaces are a critical part of today s applications.
the goal of our research is to simplify and eventually automate the process of building user interfaces by letting the programmer rely on the growing repository of already developed and tested open source applications.
essentially we eventually want to use codesearch to generate the user interface.
programmers should simply sketch the user interface they want and then our tool will search the various repositories of open source applications extract userinterfaces from these applications and return working code that is close to the programmer s design.
open source code repositories and systems are growing exponen tially.
ohloh now claims over half a million repositories with over billion lines of code.
last year it was billion.
for manyapplications already developed tested and used interfaces in the repository are similar to what a programmer is looking for and could be used with minor modifications.
our work lets the programmer start with a sketch of the user interface along with some context information.
we use the context information to search open source repositories for appropriatejava applications using existing search engines.
we extract the user interface code from these applications get the code to compile and run check whether the generated interface matchesthe given diagrams and let the programmer check the result interfaces by interacting with and editing them.
the actual source code for the generated interfaces is returned to the programmer.
this approach can return interfaces that are fully developed that include interaction code code to handle different window sizes and callback hooks.
such interfaces are more substantial thanthose generated by the user interface builders common to today s programming environments.
the approach can also be used to explore the space of interfaces for an application domain lookingat different alternatives and filling in the gap between a preliminary sketch and a usable interface.
finally the approach has been used to explore user interfaces as an aid to browsing code repositories.
the contributions of this work in addition to showing the feasibility of using code search for user interface design are a means for translating user interface sketches into a form that can be used to check if a given user interface is valid.
methods for gathering the appropriate code for a user interface from the simple results returned by code search engines.
transformations that take the raw code returned from code search extract the user interfaces and then make the code runnable outside of the original context.
techniques for matching a user interface sketch with an actual user interface.
tools that let the programmer see and interact with candidate interfaces to choose which they want the code for.
.
overview searching for user interfaces can be broken down into three stages specifying what to search for generating candidate solu tion and validating those solutions.
to specify a user interface the user provides a sketch of what is desired along with a set of keywords describing the applicationcontext of the desired interface.
our tool is shown in figure .
the user interface sketch is provided as an svg file.
while a freehand sketch might be more appropriate we wanted to start withsomething more structured and sli ghtly easier to interpret.
svg is a common standard works well with the web there are manyavailable tools for creating and editing such diagrams and apacheprovides a suite of java based tools for svg.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advant age and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permissi on and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
when the user completes the specification and hits the search button we build a java code search request for a modified version of our s6 search engine .
to do this we transform the user s sketch into a hierarchical component description .
this description includes the components that should be in the user interface andthe relationships among those components.
components can benested.
for each component the description includes a set of java swing awt widget types that can be used to implement this particular component.
the component description from the exampleshown in figure is shown in figure .
next s uses the keywords to find candidate solutions from an existing code search engine such as ohloh krugle or github.
s6 next looks for candidate user interfaces.
a candidate solution can be a class that implements a swing awt component or a nonprivate method that returns such a component.
next s6 applies transformations to each solution in an attempt to create code that is compilable runnable and only contains the user interface.
the result of each transformation is a new solution that can also betransformed.
the end result of these transformations is a set of candidate user interfaces that might meet the user s criteria.
we validate these solutions in several ways.
first we ensure the code compiles and runs.
second the user interface generated by the code needs to match the hierarchical component specification.
third the interface needs to look and act correctly.
for the first two of these s6 compiles and runs the code and then matches the user interface generated in the run against the component specification.
the various constraints and values included inthe specification are used to generate a matching score which is used to rank the solutions.
the task of seeing whether the user interface is appropriate and what the programmer was thinking of is left to the programmer.
our tool presents the candidate solutions to the user first by showing images of the interface as seen in figure .
the user canaccept or reject the solutions directly based on their image.
alternatively if a solution is clicked on then the system will run the user interface along with a viewer that lets the user investigate thewidget hierarchy and the various events generated by interaction.
once the user has selected a set of acceptable solutions they hit the show the code button to get a display of the resultant code.this is shown in figure .
in the next section we describe s and other related work.
section .
describes how we generate the hierarchical component description from the svg diagram.
section .
describes the various transformations and other extensions to s6 that are needed for handling user interfaces.
section .
describes the matching algorithm along with the tools and techniques for presenting the solution to the user.
section .
describes our experiences to date and offers an evaluation of the work.
section .
then concludes bydescribing our on going work.
.
related work creating graphical user interfaces has been a difficult problem since the s when such interfaces starting to become common.
figure .
the user interface for specifying what to search for.
the specification includes keywords and an svg based sketch.
se arch options include which code search engine to use and the scope of the search.
component height .
id u 70 types java.awt.container width x y component data my address book height id u 51 left u 70 top u 70 types javax.swing.jlabel width x y component data e mail height id u 64 types javax.swing.jlabel width x y component data contact details height id u 60 types javax.swing.jlabel width x y component height id u 62 right u 70 types javax.swing.jtextfield width x y component height id u 52 left u 70 types javax.swing.jlist javax.swing.jtextarea javax.swing.jeditorpane width x y component data name height id u 61 types javax.swing.jlabel width x y component height id u 67 right u 70 types javax.swing.jtextfield width x y component bottom u 70 data create a new contact height id u 58 left u 70 types javax.swing.jbutton javax.swing.jmenuitem width x y component data phone height id u 69 types javax.swing.jlabel width x y component height id u 65 right u 70 types javax.swing.jtextfield width x y component figure .
hierarchical component specification generated from the diagram shown in figure .
each component includes a position and size.
104while most interfaces then and now are still hand coded there have been a wide variety of tools developed to assist and evenattempt to automate the process.
a good summary of the state of the art in is provided by .
.
user interface generation modern development environments such as netbeans visualstudio and eclipse support user interface generation.
they let the developer drag and drop widgets into containers and to set thevarious properties of the widgets.
once a user interface is designed the basic code for the interface can be generated.
the programmer can modify this code to interact correctly with otherportions of the application.
these tools provide some simplification of the process but are not ideal in that a they don t handle interaction data validation or other interface dynamics b theyoften use absolute positions and it is complex to generate easily resizable interfaces c they don t handle dynamically generated interfaces where the interface depends on external files or the stateof the application d the code that is generated may not be in a style or form the programmer desires and e once the code is modified it becomes difficult to use the support to update or change theuser interface.
the latter is a problem because user interface design often involves the rapid iterative design exploration and comparison of different interface implementations .
there are some tools that attempt to generate user interfaces without actually writing code.
some of these involve using nonprocedural specifications such as mozilla s xul .
othersinvolve developing various models representing the underlying data and the presentation and then generating the interface from figure .
the resultant display showing potential solutions for the address book sketch of figure .
each solution can be accept ed or rejected by the user.
moreover the user can experiment with the solution by clicking on it.
figure .
final display showing the code for the user interfaces the user accepted.
105these models .
the model driven tools have been more successful when applied to specialized environments .
there has also been work on automatically adapting user interfaces based on device or user constraints .
.
basic code search code search technology has been developed mainly as an exten sion to the very effective uses of web search in general.
a variety of code search tools have been developed by researchers to help the programmer find the particular code they might be interested inout of the large available body of code .
this is in addition to commercial tools such as ohloh code.ohloh.net formerly koders at kod ers.com krugel krugel.com github and the now defunct google code search.
while code search shows much promise it has not caught on extensively.
to some extent this is because the various code search engines are not particularly effective.
however even with an effective search the programmer still has to do a significantamount of work in order to use the result.
this includes checking whether the code actually does what is desired adapting the code to their particular project possibly debugging the code and con verting the code to their style and formatting standards.
.
semantic search with s6 our prior work on code search is the semantic code search engine s6.
s6 attempts to address several of the problems with current code search technology by effectively automating the multiple tasks the programmer has to do manually in order to use the output of a code search tool .
s6 can be used to search for either java classes or methods.
it provides a web based interface that asks the user to first provide a description of what is wanted in terms of keywords and the semantics of the target code.
the latter includes the signature for thetarget class or method one or more test cases and optionally contracts preconditions and postconditions and security specifications e.g.
the returned code should not do any file i o .
once this data is entered s6 processes the request.
it first uses the keywords with an existing code search engine ohloh krugle github grepcode or sourcerer to get a starting set.
it gener ally takes the first files from the search results to build an initial set of solutions.
the next step is to apply transformations to each solution to generate new solutions.
this is done repeatedlyuntil no more transformations are applicable and no new solutions are generated.
these transformations include relatively simply ones such as change the name of the method to match the name inthe specified signature or reordering the parameters moderately complex ones such as replacing a parameter with an appropriate assignment and complex ones such as extracting functionalityfrom a method by finding a top level statement computing a value of the return type a backward slice of the code until the only free variables are of the parameter types and then extracting theresultant code into its own function.
the system next takes all the resultant candidate solutions and does a dependency check.
this check adds other code fragmentssuch as field declarations and auxiliary methods from the initial file that might be needed to make the candidate compile.
it removes candidate solutions with unmet dependencies that will notcompile.
for each passing candidate the system generates a test program that tests that candidate against the user s original test cases contracts and security constraints.
this test program is com piled and run using apache ant and junit.
the system does an additional pass looking at the output from the tests and will try additional transformations as appropriate for example transfor mations that handle off by one or uppercase lowercase errors.
finally the system takes the candidate solutions that pass all thetest cases and passes the resultant co de back to the user.
it gives the user the option of different formatting styles and differentorderings for the results e.g.
fastest to slowest smallest to largest least to most complex .
it also provides license information for each of the fragments.
the user can then take the result cut and paste it into their program and use it with the confidence it actuallycompiles and passes their test cases.
s provides a general framework for using code search for different purposes.
it starts with keywords to identify a set of initial candidate files.
next it uses a set of transformations that convert these candidate files into initial candidate solutions.
next it transforms the candidate solutions so that they are likely to compile and run.these transformations are limited by applying an intermediate check as to whether the solution is feasible or not.
finally it needs to compile and validate the resultant solutions.
our search toolimplements and specializes this framework for user interfaces.
.
other search tools other code search tools use test cases rather than keywords and are closer to the approach taken by s6.
a recent test driven approach is codegenie .
more recent code search work on test cases includes .
test cases and semantics have also been used in a similar fashion for findin g web services .
most current research code search tools are based on information retrieval techniques.
early work here demonstrated that keywords from comments and variable names were often sufficient for finding reusable routines .
later work here did queryrefinement either directly by looking at what the programmer was using an appropriate ontology using learning techniques using natural language or using collabora tive feedback .
recent approaches such as assieme sorcerer codifier exemplar and portfolio incorporate program structure and semantics as a search basis.
.
specifying user interfaces our goals in specifying a user interface for code search were three fold.
first we needed to provide an appropriate starting point forthe search process.
second we wanted to use a natural metaphor starting with sketches as designers typically do.
third we wanted to be able to check the result against the specification so we couldtest if a generated search solution was appropriate.
there are two aspects to identifying a starting point for the search.
the first is the set of keywords that will be used in conjunction with an existing code search engine to find initial files.
the second specifies if the solution should be within a single file within a single package or spanning multiple packages.
user interfaces can be implemented in a variety of ways.
simple interfaces and interfaces developed using user interface builders are often implemented within a single file.
more complex inter faces where the user creates custom components uses custom models for tables or lists or implements complex internal functionality are often implemented in multiple classes within a singlepackage.
applications that have multiple user interfaces may use a common user interface package for support code while implementing the actual interface in a separate package within the system.
in order to accommodate these different user interface implementation styles we support initial solutions that are either file based package based or system based.
for package based solutions westart with the initial file returned from the code search engine search for other classes in the same package and merge the results into a single virtual file for further processing.
this merger yields asingle java file containing multiple classes that would typically not compile directly.
however we retain enough information to sepa106rate this into multiple files when we need to compile it.
the merger also takes into account the different imports for the different files yielding a common set of imports by replacing simple names with qualified names where necessary.
in the case where the user interface might span packages we start with the initial file add the other files for the package as above and then use the import clauses and qualified names in the result toidentify packages that share a common prefix with the original one.
all the classes in these packages are merged with the original file as well and the process is repeated until no new packages areidentified.
the merging here moves all the files to a single package updating names and import statements accordingly.
the remainder of the specification is a sketch of the desired interface.
while we would ideally allow free form input this seemed overly complex for an initial system.
instead we assume that the user creates the sketch using an svg editor.
svg is web friendly matching the current s web interface.
moreover there are several tools available for creating and editing svg files such as inkscapeand the web based svg edit.
the edit image button on the bottomof the interface will bring up an appropriate editor either inkscape if it is installed on the system or glips graffiti.
finally the search button at the bottom right of the interface starts the whole userinterface search process.
the svg based user interface sketch addresses our second criteria letting the user start with a sketch.to make this usable by s we analyze the sketch and translate it into a hierarchical component description in stages.
the first stage finds potential components.
we use apache s batik package to map the svg diagram into drawable components either shapes rectangles rounded rectangles ellipses or general paths or text.
we further characterize shapes as either boxes inputregions lines symbols icons rounded regions or text.
input regions are boxes that are either lightly filled or that have a thicker than normal border.
lines are either lines or are boxes that haveessentially one dimension.
symbols are shapes that are small and can represent either a simple button e.g.
a radio button an icon or an arrow for a scroll bar .
icons are larger two dimensionalsymbols and can represent larger icons or general drawings.
squiggly paths that are long and narrow are taken to represent potential text.
text regions are further characterized as containing single ormultiple lines.
the next stage creates a hierarchy of the candidate components.
this is done by looking at the bounding boxes of each componentand seeing what other components are nested inside.
here we use an approximation to actual nesting to accommodate minor errors in the sketch.
for example if a string happens to lie mostly inside arectangle but extends outside slightly we consider the string to be nested.
once we determine all nestings we build a hierarchy by finding the innermost nesting for each component.
finally if thereis no unique top level component we create one.
the next stage attempts to merge logical groups of components and to characterize the components so that we can assign potentialwidget types for checking.
this is done with a series of handcoded checks that assign properties to the components and clean up the hierarchy.
the actual checks done here include looking for components containing only text subcomponents.
this characterizes components as buttons if the text is a simple string and is generally centered or if the enclosing region is circu lar or as single line or multiple line text input regions otherwise.
if text is present we check for asterisks to indicate a password or hidden field and for only numbers to indicate a numeric field.where components are further characterized the text subcomponents are removed from the result hierarchy.
looking for combo boxes buttons with a choice of options .
these are text boxes with a symbol on the right.
if one is found the symbol and text are removed.
looking for toggle buttons such as radio buttons and check boxes.
these are buttons or text components with an adjacent symbol.
where these are found a new component is created spanningboth the original components which are removed.
looking for menu and tool bars.
these are long narrow regions containing a one or more symbols buttons or text strings.
looking for tables trees and lists.
tables are characterized as boxes containing both vertical and horizontal lines and possible text elements.
lists can contain horizontal lines or multiple text items.
trees can contain vertical lines and have text areas that areproperly offset.
any internal subcomponents are removed.
looking for scroll bars.
these are either long or narrow regions that contain symbols at the top and bottom and possibly a box or symbols in the middle.
any internal symbols and boxes are removed if a scroll bar is identified.
looking for spinners.
these are numeric fields with one or two symbols immediately to the right.
looking for sliders.
we look for a long narrow component with additional symbols on top of it and with potential text immediatelyabove or below.
if a slider is identified all the internal components are replaced with a single slider component.
looking for drawing areas.
these are characterized as a component containing multiple symbols and shapes but no buttons.
the checks here are designed to be forgiving in order to accommo date minor errors in the original sketch.
this comes first from the fact that the hierarchy determination is not strict.
moreover the checks for aspect ratio accept an overly broad range of values checks for horizontal and vertical lines allow ease and extra marks or boxes that are small or seem irrelevant are ignored.
the fourth stage of component processing takes the resultant set of components and computes a set of relative positional constraints that can be used for checking.
each component can identify another component that is immediately above it one that is imme diately below one to the left and one to the right.
nested components can also be assigned a position relative to their parent for example a component that is at the top of its parent has the parentidentified as the component immediately above it.
the final stage assigns potential widget types to each component.
this uses the properties set by the above drawing analysis to createa list of candidate awt swing widgets for each component.
this is the only part of the specification stage that is dependent on the user interface being generated for java awt swing.
the resultant component hierarchy for the input shown in figure is shown in figure .
the box on the left is identified as either a jlist jtextarea or jeditorpane the three boxes on the right are identified as jtextfield s and the box at the bottom as a jbutton or jmenuitem .
the remaining elements are either jlabels or the outermost container.
our user interface for specifying what to search for can be seen in figure .
the top three boxes define the starting point for search.
the top box contains the keywords the second box identifies thetype of search the third box selects the search engine to be used.
the sketch selected from a file is displayed below.
.
generating solutions to do the actual work of searching for a user interface we substan tially modified the s6 search engine.
the modifications generally fall into three categories.
the first is handling packages and systems rather than individual functions or classes.
these were described in the previous section.
the second involves restricting the code to that relevant to the user interface by eliminating unnec107essary elements.
the third involves getting the resultant code to compile and run effectively duplicating what a programmer might do when extracting the interface from the code.
s6 for user interface search starts with the code generated from either files packages or multiple packages based on the initial code search.
each of these code files with the latter ones being considered single files after all the code has been merged is con sidered a candidate solution.
the next step is to identify potential user interfaces in each solution and generate separate solutions for each.
this is done using s6 code transforms.
we first convert the package name to a standard one for the user interface.
next we find all candidate interfaces.
these are non private constructors for any class that extendsjava.awt.container and any non private methods of a class that return an object that extends container .
for each such candidate we create a new solution by creating a new class with a standardname that either calls the appropriate constructor or first builds the class and then calls the identified method.
where there are multiple possible constructors we generate separate solutions for each using logical default values for any parameters.
similarly if the identified methods take parameters we will generate separate solutions using different default values for those parameters.
each potential user interface solution is restricted by a transformation that eliminates any code that cannot be reached from the class added for the solution.
the result of this is a set of candidate solu tions that implement a potentially relevant user interface and that are restricted to the code needed for that interface.
the next step uses existing s transforms along with swing specific transforms to take these solutions and build new solutions that have a greater possibility of compiling and meeting the user s needs.
the transformations that we have added for handling multi ple classes user interfaces and swing include removing any code that