see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation explicating symbolic execution xsymexe an evidence based verification framework conf erence paper in proceedings int ernational conf erence on softw are engineering may .
ic se.
.
citations 7reads author s including john hat cliff kansas st ate univ ersity publica tions citations see profile robb y kansas st ate univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y john hat cliff on july .
the user has r equest ed enhanc ement of the do wnlo aded file.explicating symbolic execution xsymexe an evidence based verification framework john hatcliff robby patrice chalin jason belt department of computing and information sciences college of engineering kansas state university usa hatcliff robby chalin belt k state.edu abstract previous applications of symbolic execution symexe have focused on bug finding and test case generation.
however symexehas the potential to significantly improve usability and automation when applied to verification of software contracts in safety critical systems.
due to the lack of support for processing software contracts and ad hoc approaches for introducing a variety of over under approximations and optimizations most symexeimplementations cannot precisely characterize the verification status of contracts.
moreover these tools do not provide explicit justifications for their conclusions and thus they are not aligned with trends toward evidencebased verification and certification.
we introduce the concept of explicating symbolic execution xsymexe that builds on a strong semantic foundation supports full verification of rich software contracts explicitly tracks where over under approximations are introduced or avoided precisely characterizes the verification status of each contractual claim and associates each claim with explications for its reported verification status.
we report on case studies in the use of bakar kiasan our open source xsymexe tool for spark ada.
i. i ntroduction over the last decade software engineering and formal methods research has demonstrated that symbolic execution symexe can be an effective technique for automatically checking wide ranging properties of a program s behavior with little or no developer intervention.
previous applications of symexehave centered around detection of common faults such as null pointer dereferencing buffer overflows array bounds violations and test case generation .
symexetools aim to provide highly automated and precise reasoning about program states by employing a variety of approximating optimizations.
path sensitive analyses are guided by heuristics that prune or cutoff certain paths.
for example to reduce the burden on developers in s ymexe loop invariants are optional instead loops are dynamically lazily unrolled up to a developer configurable bounded depth.
rather than requiring complex shape properties for data structures to be declared by developers data structures are explored up to a bounded size.
finally rather than requiring manual steps in a theorem prover logical constraints over program variables are solved by decision procedures dps that may return don t know or timeout after a developer configured time bound.
when these this material is based upon work supported by the national science foundation under grant and by the us air force office of scientific research afosr under contract fa9550 .path cutoff optimizations occur they can cause s ymexeto compute an under approximation of the program s behavior thus s ymexemay fail to discover faults in a program that occur beyond path cutoff points.
on the other hand programs often contain data computations that lie outside the theories handled by dps and the typical strategy for dealing with such cases can cause s ymexeto introduce an over approximation of a portion of the program s behavior thus it may report false alarms .
while these approximations are effective for automation their impact on the coverage of a program s state space and the reporting of results of property checking cannot be easily predicted.
at a more fundamental level the unconstrained and unmonitored use of these optimizations means that developers cannot trust the tool to yield a definitive report of the correctness of assertions or other program properties.
in contrast to the emphasis on bug finding for predefined properties and faults outlined above we are interested in the verification of developer supplied contracts that specify full functional correctness.
while software contract checking is useful in many contexts we are interested primarily in its application in the development of safety critical software.
unfortunately our experience in several industrial collaborations with companies such as rockwell collins who produce certified safety and security critical software has shown that current tools for contract checking place too great a burden on developers.
for example the s park language and tool framework is one of the premier commercial development frameworks for high assurance software.
s park has been used to develop a number of safety security critical systems.
even though s park and its static analysis components are beneficial and easy to use its contract language is rarely used due to the burdens the associated tools and methodology impose on developers.
in fact we are not aware of any industrial development effort that makes significant use of the s park pre post condition notation other than to specify enough context information for procedures to enable absence of run time errors to be proved.
we believe that a more foundational approach to s ymexe can significantly improve the usability and effectiveness of contract checking tools by providing a completely automated lazy bounded verification technology that scales to very complex contracts.
our vision is that the highly automated nature of s ymexewould allow developers to apply contractchecking early in the development process with very little effort.
we believe that in many cases s ymexecan provide complete verification that code conforms to contracts.
in cases where complete verification is not achieved bounded s ymexe based checking can lead to the detection and removal of the vast majority of functional flaws in code and contracts.
moreover s ymexecan provide a variety of forms of semantic visualizations test generation etc.
that can help developers better understand their code enable more rapid development of contracts and provide evidence that significantly increases confidence in program correctness.
our aim is not to replace e.g.
the s park examiner spark sverification condition generation vcgen based tool but to complement it by offering highly automated developer friendly techniques that can be used directly in the code specify test check debug understanding feedback loop of typical developer workflows.
our vision includes providing tool reports that clearly distinguish between contracts that have been proven by s ymexefrom those with remaining proof obligations.
contracts with undischarged proof obligations would be handed off later in the development process to verification engineers who apply less automated tools and proof assistants.
to achieve this vision we have developed a novel approach to s ymexefor software contract checking.
we call this approach explicating symbolic execution xsymexe because it is designed from the ground up to have robust semantic underpinnings and to produce explicit explanations and justifications about the verification status of each of developer supplied claim in a program.
we make the following contributions introduce the concept of xsymexeas the foundation of an evidence based framework for justifying the verification status of software contracts checked by s ymexe and explain the basic algorithms of xsymexeused to explicitly track when under over approximations are introduced sections ii a iii v .
provide rigorous mathematical definitions for the basic principles of xsymexeincluding notions of soundness that justify the developer interpretation of verification results of s ymexewhen applied to software contracts sections ii b iii iv .
implement xsymexein the open source bakar kiasan kiasan for short symbolic execution tool for spark ada.
summarize the results of publicly available case studies and related artifacts on applying kiasan to a variety of spark examples section vi .
this work was motivated by collaborations with engineers at rockwell collins and knowledge of how s park is being used in rockwell collins security critical projects.
we are currently collaborating with adacore and altran praxis to integrate this technology into their next version of s park .
although we illustrate our techniques in the context of s park we believe that the concepts can easily be adapted to other tools working on different languages such as the symbolic path finder spf and klee .ii.
b ackground in this paper we are concerned with xsymexefor contractbased languages like s park ada.
we will use the term claim to be a contract pre or post condition or inline assert statements and their specialized forms such as loop invariants .
a. evidence based verif.
conventional symexeshortfalls we carefully illustrate here the ways in which s ymexe can lead to uncertainty in the verification status of claims while pointing out how xsymexecan offer clarity in the conclusions that can be drawn.
examples are in s park and the essence of the notation is explained as we go along.
issue under approximation due to bound or selective search cutoffs may mask program faults one of the more obvious limitations of bounded s ymexe is illustrated in figure a where an array is used to implement a queue of size elements.
s park s contract notation is fairly conventional and should be easy to interpret once one knows that occurrences ofe in a post condition refers to pre state values of e. execution of this procedure will result in an implicit claim violation due to the array index being out of range in the expression a k at line .
the ada standard mandates several kinds of implicit claims like these.
the source of the problem is the upper bound of the forloop it should be size .
when a conventional implementation of s ymexe is invoked with a loop bound less than size then no contract violation is reported because the last iteration of the loop in which kis equal to size is never reached due to the path cutoff from the loop bound exhaustion.
solution because xsymexeprecisely tracks when bound exhaustion leads to path cutoffs and the implicit and explicit claims whose checking may be bypassed due to those particular cutoffs kiasan reports that the implicit range claim at line is v erified?.
in kiasan we consistently use ?
as an inconclusiveness qualifier read as maybe .
kiasan also provides an explication that enumerates all the program points in which s ymexebound exhaustion occurred which may prevent the full evaluation of the claim.
issue cutoffs in assumption statements a precondition in the case illustrated in figure b can lead to overapproximation and false alarms .
the procedure contract is actually valid but the over approximation introduces a false alarm as we explain next.
consider s ymexeof this example with a loop bound of and an array bound of .
s ymexe begins at the precondition.
since the precondition s universal quantifier is symbolically executed as a loop and since size can take on the value its evaluation will lead to a symbolic state in which a k empty fork .. but will leave a unconstrained since the last iteration of the quantifier loop is cutoff due to loop bound exhaustion.
symexecontinues with the evaluation of the procedure body using simplifying slightly a symbolic state built out of the 1terminating the analysis at cutoff points in assumptions would cause the subsequent code claims to be unanalyzed.
in contrast any claim verified under an over approximating assumption is satisfied in any concrete execution.
a verified?
read inconclusiveness qualifier ?
as maybe i.e.
maybe verified due to under approx.
caused by bounding.
claim is actually invalid.
subtype index i si n t e g e r range .
.
type v e c t o r i s array index ofi n t e g e r empty c o n s t a n t procedure dequeue a in out v e c t o r s i z e in out i n t e g e r r out i n t e g e r pre f o r a l l k i n i n d e x range index f i r s t .
.
s i z e a k empty and index f i r s t s i z e and s i z e index l a s t p o s t f o r a l l k i n i n d e x range index f i r s t .
.
s i z e a k empty and r a index f i r s t and a s i z e empty and s i z e s i z e and f o r a l l k i n i n d e x range index f i r s t .
.
s i z e a k a k i s begin r a index f i r s t f o r kinindex range index f i r s t .
.
s i z e loop a k a k end loop a s i z e empty s i z e s i z e end dequeue b false alarm refuted?
read maybe refuted claim that is actually valid due to bound exhaustion in assumption precondition causing over approx.
procedure d e q u e u e f i x e d .
.
.
c o n t r a c t same as dequeue 25i s begin r a index f i r s t f o r kinindex range index f i r s t .
.
s i z e loop a k a k end loop r e s t o f body l i k e dequeue c false alarm indeterminate claim reported due to unhandled theory over approximation but claim is actually valid.
procedure fait i j i n t e g e r r k q out i n t e g e r pre i and i and j and j p o s t q and q i s begin r i j k r q k end fait d uncovered claim at line if the loop bound is less than .
procedure b k i n t e g e r r out i n t e g e r i s begin r f o r jini n t e g e r range .
.
loop r r k end loop a s s e r t p1 k r 40end b e deadclaim and code since the product of naturals cannot be negative.
procedure deadex j k n a t u r a l r out i n t e g e r i s begin r j k i f r then a s s e r t p2 j k r r end i f end deadex f faulty postcondition as it yields an array index out of bounds violation.
procedure i n s e r t i o n s o r t a in out v e c t o r p o s t f o r a l l k i n i n d e x a k a k d e t a i l s o f body e l i d e d f o r b r e v i t y .
g verified claim fully verified .
no bound exhaustion or unhanded theories.
55procedure s h i f t n index a in out v e c t o r p o s t f o r a l l k i n i n d e x range .
.
n a k a k i s begin f o r kinindex range index f i r s t .
.
n loop a k a k end loop end s h i f t h refuted claim post condition .
procedure swap a in out v e c t o r j k inindex p o s t a k a j and a j a k 65i st i n t e g e r begin t a k a j a k a k t end swap fig.
.
examples used to contrast conventional s ymexeand xsymexe excerpt e.g.
spark derive clauses are elided state at the cutoff point.
thus on the fourth evaluation of line the unconstrained value of a gets copied into a .
being unconstrained this value can be empty and hence subsequent evaluation of the post condition results in a claim violation because the first quantifier s body namely a k empty is f alse when kis .
solution xsymexeprecisely tracks when over approximation is introduced during the evaluation of an assume statement such as a precondition due to bound cutoffs kiasan qualifies that the postcondition is r efuted?.
it justifies the ?
qualification with an explication consisting of the assumption expression context where over approximation was introduced and a counter example in support of the claim violation.
of course due to over approximation the counterexample may not satisfy the full precondition.
issue false alarm from over approximation due to unhandled theories is illustrated in figure c where the procedure contract is correct but conventional s ymexewould report a violation of the post condition line as we explain next.
while the precondition sufficiently constrains the values ofiandjto ensure that qis in the stated range in the post condition the multiplication i j at line introduces non linear arithmetic which at best is partially handled and generally completely unhandled by many dp.
while integer non linear arithmetic is used in this example there are other theories that are undecidable unsupported by even the most advanced dps e.g.
floating point unbounded strings.
acommon s ymexestrategy in such situations is to introduce uninterpreted functions abstracting away sub expressions over unhandled theories along with basic axioms over them e.g.
for multiplication a non negative number multiplied by a nonnegative number yields a non negative number.
this introduces an over approximation which for this example would lead a conventional s ymexetool to wrongly conclude that the postcondition can be violated.
solution xsymexeprecisely tracks over approximation for unhandled theories due to the use of uninterpreted functions.
in addition kiasan can determine if a claim status depends on such uninterpreted functions e.g.
via a form of data and control dependency analysis and if it does kiasan reports the status as i ndeterminate indicating that evidence cannot be generated to refute the claim and that as opposed to the example in figure b re running xsymexewith higher bounds will do nothing to help.
in situations where uninterpreted functions are introduced and a particular claim violation does not depend on them then kiasan can conclude that the claim is r efuted .
issue uncovered claims.
naive approaches to s ymexe simply report when a claim is possibly violated.
in these approaches the absence of a claim violation could lead the developer to incorrectly conclude that a claim can never be violated.
however it is possible that the bounding strategy used by s ymexehas simply cutoff some paths creating an under approximation that misses evaluating the claims.for example when s ymexeis applied to the example of figure d with a loop bound of the last iteration of the loop will never be executed the path to the claim at line will be cutoff and nothing will be reported about this claim.
solution kiasan reports this claim as u ncovered and it produces explications that includes bound cutoffs that may be blocking the execution of the claim along with paths from the bound cutoff points to the uncovered assertion.
issue distinguishing dead from uncovered code claims.
some claims lie along paths for which no concrete execution exists.
even if code coverage is used conventional s ymexe algorithms cannot distinguish between claims and code that are uncovered due to cutoffs as in figure d from claims or code that are semantically unreachable as in figure e .
solution because xsymexetracks where paths are cutoff due to bound exhaustion kiasan can identify claims and code that are semantically unreachable from claims and code that are merely uncovered.
while the example in figure e uses non linear arithmetic because of the basic axiom added on non negative multiplications mentioned previously kiasan can conclude that the claim and code are dead.
a claim or code is reported as d ead if it is uncovered and there are no bound cutoffs along s ymexepaths from which the code in question is reachable in the procedure control flow graph.
dead code detection is important for critical embedded systems.
in fact in some sectors such as avionics dead code must be removed to comply with e.g.
do 178c.
many dead code detection approaches rely on data flow frameworks or syntactic detection our approach is more powerful potentially detecting more dead code and generates less number of false alarms because it considers infeasible path conditions.
issue undefinedness exceptions during claim evaluation.
because claims are built from programming language expressions their evaluation can lead to run time exceptions.
such claims are faulty because their evaluation in a particular state may not return a definite truth value.
figure f illustrates a faulty contract with a post condition that will generate a range check violation at a k .
it is important for developers to understand when their claims are faulty because no useful verification conclusions can be drawn from them eliminating such exceptions from claims should be one of the first tasks in a contract based quality assurance methodology.
solution because xsymexe decomposes each contract into primitive claims and tracks the verification status of both explicit and implicit claims kiasan reports that the contract of figure f is f aulty .
to explain why the contract is f aulty it also provides an explication listing implicit claims runtime checks in the contract and a counterexample for such claims that are r efuted .
issue is a verified claim really verified?
conventional s ymexeapplied to figure g may report no violations and offer no clear indication of the actual claim status.
has the postcondition been exhaustively validated for all possible states?solution in analyzing this example kiasan relies only on the manipulation of logic constraints that are completely supported in the theories of the underlying dp and does not give rise to under approximations due to bounding as long as the loop and array bounds are greater than index last .
if the latter is not true then v erified?is reported hinting to the developer that an increase in the loop and array bounds might enable xsymexeto report that the contract has been unequivocally v erified which is the case for this example.
note that no loop invariant is needed to verify the example.
issue is a refuted claim really refuted?
as was alluded to earlier a common pitfall of static analyses is that they produce too many false alarms that negatively impact one s ability to correct true claim violations.
many s ymexetools introduce over approximations that can lead to false alarms and do not precisely track when such approximations have been introduced.
thus they are unable to distinguish a potential false alarm from an actual claim violation.
solution kiasan does not introduce any over approximations when run on the example of figure h .
because xsymexe precisely tracks when over approximations are introduced kiasan is able to report that the claim represented by this contract can be r efuted .
moreover it yields an explication in the form of a concrete test case and counter example e.g.
a pre state having j k a j a k that leads to violation of the postcondition the bug is that the first assignment s right hand side should be a j .
b.symexe basic formalization in this section we present a basic formalization of s ymexe giving enough mathematical machinery to enable us to rigorously explain claim reporting and its associated semantics.
procedures and commands without loss of generality we focus our technical definitions on procedural units and execution states for those units that include bindings of the procedure s local variables parameters and global variables that are either read or written by the procedure.
we will assume unless stated otherwise that our formal definitions given below apply to the context of a given procedure p. as is commonly done in works formalizing program correctness for imperative languages we assume that our core command language includes the basic assume andassert statements which are used in particular to encode the preand post conditions of procedure contracts.
execution of an assert statement whose expression evaluates to true has no effect otherwise the procedure s execution is said to terminate inerror .
similarly execution of an assume statement whose expression evaluates to true has no effect otherwise the procedure s execution is said to terminate due to infeasibility .
for simplicity procedure contracts are embedded in the procedure s code as assume e.g.
precondition and assert e.g.
postcondition statements via program transformation .
concrete and symbolic stores astore is a finite partial function relating variables var to their values.
a concrete store c2var valuec associates variables to concretevalues valuec.
since symbolic execution manipulates both valuecand symbolic values we define a symbolic store s2var values where valuec values.
concrete and symbolic states aconcrete state sc l c is a pair consisting of a program point also called a label land a concrete store c where intuitively c represents the value of the program variables immediately before the command at lis executed.
we say that scis a state forl.
similarly a symbolic state ss l s g is a tuple consisting of a program point a symbolic store a path condition consisting of a finite set of formulae that act as constraints on symbolic values in the store and a status flag used to indicate among other things whether a state is normal or potentially over approximating explained further below .
we also say that ssis astate forl.
let c pand s pdenote the concrete and symbolic state sets of the procedure p respectively.
when referring to state sets generically we shall omit the pqualifier on the name.
concrete execution aconcrete path c sc sc for procedure pis a possibly infinite sequence of one or more concrete states representing the states generated by executing commands in pfrom the initial state sc .
similar to we have each finite path cforpend in a final state sc nhaving a special label ln2fnormal error infeasiblegdenoting the path termination status.
an i nfeasible state results from an assume statement s expression evaluating to false .
assume statements are used e.g.
to encode preconditions.
we let c p denote the set of all possible concrete paths in p. the program pointlinpis said to be reachable iff there exists a path in c p containing a state for l otherwise it is said to be unreachable ordead .
symbolic execution asymbolic path s ss ss n2 s pfor procedure pis a sequence of one or more symbolic states representing the states generated by symbolically executing commands in pfrom the initial statess .
unlike concrete paths symbolic paths are not required to end in a state for one of the special terminal labels.
this models the fact that a symbolic path may be partial due to a s ymexebounds cutoffs e.g.
array loop or call chain bounds.
for simplicity we often refer to user configurable analysis bounds e.g.
loop bound bounding on arrays timeout simply as bounding .
we call a symbolic path complete iff it ends in a state for one of the special terminal labels and it is termed incomplete otherwise.
ss 1es ss sc ec sc fig.
.
commutativity of concrete execution and s ymexe6 soundness since we use symexefor formal verification as opposed to just bug finding we define a binary simulation relation relating concrete and symbolic states such that sc ss whenssover approximates abstracts orsimulates sc.
a symbolic state and the concrete states that it abstracts always agree on their program point.
a concrete path c sc sc isover approximated by a symbolic path s ss ss n on its first n 1states denoted cn s iff cis at least of length nandsc i ss i for all i n. when cand sare both of length nand cn s then we simply write c s. symexeissound iff figure commutes where a step of concrete symbolic execution is denoted by ec es respectively.
iii.
c laims we address the checking of developer claims written in a formal specification language that state desired properties of programs written in a particular programming language .
several approaches have been proposed for interpreting claims.
in themathematical interpretation approach taken in languages such as the current version of s park claims are viewed as pure logical formula whose evaluation completes in a single step yielding either true orfalse as a result.
in this work we adopt the executable interpretation approach to align with the semantics of specifications to be used in the next generation of s park based on ada .
in the executable approach claims are decomposed to atomic boolean expressions in the programming language.
interpreting a claim amounts to executing the boolean expressions to which it decomposes.
thus claim evaluation does not in general proceed in a single atomic step it may have the possibility of terminating abnormally due to ill formed subexpressions array accesses with out of bound indices divideby zero errors etc.
a.k.a.
undefinedness as illustrated in figure f .
in the subsequent subsections we give a top down description of concrete and symbolic evaluation of claims beginning first with the developer s view of claim evaluation and then drilling down to the details of claim decomposition.
a. concrete evaluation of claims because s ymexeis a path sensitive analysis we first address the evaluation of a claim at a particular state along a path and then derive the semantics of a claim by summarizing across all paths.
whenever the command at a program pointlis a claim in the form of an assert or assume statement we use clto denote the claim at l. we define check claimc sc cl bool?to be a function returning either t rue false or u ndefined that represents the concrete evaluation of clin concrete state scwhose program point isl.
sincescis a state for l providing clas a second argument is unnecessary but including it provides uniformity in the arguments of the semantic functions defined later.
to build towards the developer s intuitive understanding of the meaning of clacross a set of executions c we define the concrete collecting summary of cl denoted collect claimc c cl p bool?
as the union of all possible concrete execution results of clacross all paths in c. the concrete interpretation of a claim is the conclusion that a developer can draw about clbased on its concrete behavior across allexecutions in c interp claimc c cl is defined as follows d d ead iff c ollect claimc c cl i.e.
clnever appears in the paths c it is unreachable .
v v erified iff c ollect claimc c cl ftrueg i.e.
clis reachable and is t rue in all states in which it is encountered.
r r efuted when f alse2collect claimc c cl i.e.
cl is reachable and is f alse on at least one path.
f otherwise when undefined 2collect claimc c cl i.e.
clis reachable and is u ndefined on at least one path.
in those situations above where more than one when case holds true then the first case is chosen.
b. symbolic evaluation of claims symbolic claim check let c heck claims ss cl bool?
?be the result of symbolically evaluating the claim cl in the symbolic state ss for cl where b ool?
?
bool?
fdontknow false?
undefined?g.
while this function is generally implemented by a call to a decision procedure dp preprocessing and optimization steps may be applied before and or instead of calling the dp.
details will be given in section iv and as will be explained there d ontknow represents the situation where the decision procedure itself returns don t know or when a particular theory used in the primitive assertion is not supported by the decision procedure.
false?and u ndefined?
read as maybe false and maybe undefined will be explained in section iii b3 after the introduction of some essential terminology.
symexebound exhaustion and cutoff paths as explained in section ii in bounded s ymexe some symbolic paths are terminated prematurely due to bound exhaustion.
we refer to these as cutoff paths which are instances of incomplete paths mentioned in section ii b5.
we say that clisimpacted by the cutoff path sof lengthnterminating in a state ss niff there exists a concrete path ccontaining a state sc ifor cl wherei n for which cn s. intuitively a claim that is impacted by a cutoff causes inconclusiveness in the analysis results due to the cutoff because there are behaviors that are not analyzed that might affect the claim s status.
the detection of the potential impact of a claim clby a cutoff can be seen as a reachability problem since a cutoff at a program point lncould prevent the flow of control from continuing to cl.
we define a conservative approximation of cutoff impacts using a control flow graph cfg as follows.
let sbe a cutoff path then we say that clispotentially impacted by s and write cl2cutoffimpacts s iff clcan be reached from ln the program point of the final state in s in the cfg.
a more precise c utoffimpacts can be defined using control and data dependencies instead of cfg reachability we opt to use cfg here for simplicity.
symexebound exhaustion in assume contexts a symexebound exhaustion results in a cutoff in every execution context except that of an assume statement in which case the assume expression evaluation is stopped and the symbolic constraints accumulated up until that point are preserved in such cases the boolean sub expression is assigned a nondeterministic value and s ymexecontinues to the sibling boolean sub expression of the assume statement if any otherwise s ymexecontinues to the next statement .
because a non deterministic value is introduced the symbolic statestatus flag gdescribed in section ii b is set to indicate that the state and all its successors are potentially overapproximating.
this is how the over approximation discussed for the example of figure b is tracked.
in general overapproximation may result in false alarms but the alternative is to halt the exploration of the path which would typically give less feedback to developers about the remaining procedure code and contract clauses.
we can now clarify that the previously mentioned c heck claims ss cl outputs f alse?
and u ndefined?represent the situations where the dp yields false or u ndefined respectively but that ssis flagged as potentially over approximating due to a bound exhaustion taking place during the symbolic evaluation of an assume statement at some point earlier in the path .
collecting summary analogous to the concrete case we define the symbolic collecting summary of cl denoted collect claims s cl p bool?
?
fcutoffg as the union of all symbolic execution results of cl across all paths in sas reported by c heck claims and fcutoffg if clcan be potentially impacted by a cutoff path in s. symbolic interpretation we now define the symbolic interpretation of clto represent the conclusions that a developer can draw about this claim from the results of s ymexe.
interp claims s cl is defined as follows d d ead iff c ollect claims s cl .
v v erified iff c ollect claims s cl ftrueg.
r r efuted when f alse2collect claims s cl .
f faulty when u ndefined 2collect claims s cl .
r?
r efuted?when f alse?2collect claims s cl .
f?
faulty?when u ndefined?2collect claims s cl .
u u ncovered iff c ollect claims s cl fcutoff g. v?
v erified?iff collect claims s cl ftrue cutoff g. i indeterminate otherwise.
as before when more than one when case occurs in the interpretation of the above the first case is taken as defining.
iv.
p rimitive claims and their semantics thus far we have explained the semantics of claims from a developer s perspective.
in this section we describe how the concrete and symbolic c heck claim methods are realized.
a. primitive claims and classical dps programmers have a natural intuitive understanding of the execution of a claim expression yielding either t rue false or in situations where execution cannot terminate normally e.g.
due to an exception u ndefined .
this leads to logical formula over a valued logic .
almost all dps operate over theories expressed in classical valued logic.
hence we adopt an approach that we developed earlier for use in the java modeling language and explained next.
generally speaking a developer claim c consists of n primitive claims a i for i n. we use the term defining primitive claim a d to refer to a n the primitive claim that defines the logical meaning of the developer claim after all subexpressions have been evaluated and supporting primitive claims a s e.g.
array bounds checks and other range checksrequired by ada on sub expressions in the developer claim to mean an a i for1 i n .
due to the lack of space we omit the full details of how a composite claim is decomposed into primitive claims.
we do note here that supporting primitive claims are generated among other reasons to encode 2valued conditions whose truth will guarantee that evaluation of the rest of the claim will not result in u ndefined e.g.
a claim expression involving division will have a supporting primitive claim asserting that the divisor is not zero.
b.check primsand decision procedure the checking of the developer claim via c heck claimsis defined in terms of the more elementary c heck prims which is applied to constituent primitive claims.
c heck primsis in turn defined via calls to a decision procedure.
we now explain how c heck prims ss a can return t rue false dontknow or f alse?.
consider the case where s ymexereaches a primitive claim a on a state ss.
in c heck prims ss a we are interested in determining validity of a under ss.
typically this is implemented as a call to a decision procedure such as a satisfiability modulo theory smt solver like e.g.
z3 and yices .
smt solvers do not directly tell us if an assertion is valid since they are designed to check satisfiability of a formula instead of the formula s validity .
we abstract the means by which we determine validity through satisfiability checkers behind an interface we call dp which returns true false dontknow .
we require dp to be sound that is it may at most introduce over approximation possibly generating false alarms but not under approximation which could result in missed detection of bugs .
claim expressions over undecidable theories are the main reason for over approximation and unfortunately most interesting programs deal with theories that are undecidable e.g.
non linear arithmetic and unbounded string theories .
in such cases a dp may not be able to give a definite answer that is it may give up producing an answer when it tries to reason about state constraints involving undecidable theories and hence return d ontknow .
we design our tool to work with multiple smt solvers but this is complicated by the fact that the solvers differ in their reasoning strengths and or the theories that they directly support.
for example yices has no support for non linear arithmetic while z3 tries its best to conservatively solve non linear arithmetic constraints neither supports theories of unbounded strings or floating point numbers.
the typical workaround for constraints involving theories not supported by the underlying solver is to weaken such constraints by using uninterpreted functions.
while this approach is sound it leads to over approximation.
thus to distinguish conclusive results we design check prims ss a to return t rue only if the claim is valid provably true f alse only if the claim is invalid provably false .
c heck primscan achieve this by a post processing step after calls to dp as follows.
let ut ss a returns true iffssor a contain terms from unhandled theories.
ifdp ss a false then c heck prims returns f alse if ut ss a otherwise d ontknow .
a naive ut can be defined as the path condition in ssand the constraint in a involves weakening for unhandled theory.
if dp answers true or d ontknow the answer is directly returned by check primsregardless whether the constraint involves unhandled theory.
note that this naive ut may sometimes be overly conservative but can be improved.
for example when using yices where non linear arithmetic is unsupported one can emulate multiplication by using an uninterpreted function but with e.g.
the following sign axiom multiplication of non negative numbers yields a non negative number.
in certain cases where such axiom applies dp can give a definite answer.
this can be detected by further queries to the underlying solver.
moreover ut can be refined further by using a cone of influence data dependence analysis and control dependence analysis see the technical report version of this paper for more discussion .
in section iii b3 we described that we may have an overapproximation while evaluating an assumption.
in such case if the dp returns f alse it maybe a false alarm introduced by the over approximation.
thus to distinguish this case with the case where we can conclusively determine that the assertion is provably invalid c heck primsexamines the overapproximating flag ginss it returns f alse?whengis set which indicates there was an assumption over approximation along the path.
a test case can be generated to try to convert false?to f alse that is if the test case execution refines the symbolic path a witness that refutes the claim then check primsshould return f alse .
due to the lack of space we omit the definitions of collect prims s al and i nterp prims s al since they are quite similar to those for developer claims.
c.check claims finally we can explain how symbolic claim checking is defined in terms of its constituent primitive claims.
thus for a claim a c heck claims ss c bool?
?
where b ool?
?
bool?
fdontknow false?
undefined?g is defined in terms of the primitive claims of c and c heck prims whose return values are t rue false d ontknow and false?
as follows undefined when c heck prims ss as false for any supporting assertion a s. undefined?when c heck prims ss as false?
for any supporting assertion a s. dontknow when c heck prims ss as dontknow for any a s. the value of c heck prims ss ad when check prims ss as true for all a s. again when more than one when case occurs in the interpretation of the above the first case is chosen.
v. c laim explication the main goals of xsymexeare to be more precise about the conclusiveness of contract checking results and to provide informative evidence for each of the results.
xsymexeexplications are multi tiered so that developers can see an initial explication for a developer claim status and then drill down through multiple levels of abstraction for more details including results of claim checking on individual paths as well as results for the primitive claims that make up a developer claim.
explications for both developer and primitive claims are organized according to the set of status results obtained when collecting the results of claim evaluation across all paths.
for example the top level report may indicate that a developer claim is r efuted in a situation where the claim s defining primitive claim is f alse along some paths and t rue along other paths.
in this case explication drill down yields two categories of explications one for the t rue paths and one for the f alse paths .
drill down through the t rue category produces a collection of concrete and symbolic paths for when the primitive claim is t rue similarly for the f alse case .
the table below describes the nature of the explications for each status category that can be returned by c ollect prims.
collect category explication false c s counter examples program location true c s path cutoff partial c s path cutoff location path chop dontknow s path unhandled theory program locations false?c s counter example over approx.
location false to illustrate an assertion refutation it is sufficient to generate a counter example demonstrating that the assertion does not hold under a certain circumstance.
it is also helpful to highlight the assertion s source level program location region this is especially valuable for identifying the source of undefinedness of a claim s supporting assertion.
true as an evidence of an assertion verification it is useful to generate a concrete symbolic c s path or a test case demonstrating that the assertion holds.
cutoff to illustrate an assertion impacted by a cutoff we generate a partial c s path demonstrating the program execution leading to the cutoff point this is coupled with generating a possible path chop description visualization illustrating how program control can transfer from the cutoff program location to the assertion.
dontknow we can output a symbolic path to illustrate an assertion whose validity cannot be determined unfortunately due to the unhandled theory issue described in section iv b it may not always possible to generate a concrete path.
thus we can only guarantee to output a symbolic path.
hence it is helpful to also highlight program points that give rise to constraints with unhandled theory.
false?
recall that f alse?can only happen when there is an assumption over approximation impacting an assertion that is refuted under that over approximating assumption .
thus we can generate c s counter examples illustrating the assertion refutation.
as mentioned previously the counter examples may not fully satisfy the assumption.
thus it is helpful to also highlight the program point where the assumption overapproximation occurred.vi.
e valuation to evaluate our approach we implemented xsymexein bakar kiasan and applied it to an extended set of examples including the examples of section ii a standard sorting algorithms used for benchmarking and representatives of data structures used to maintain data packet filtering and transformation in embedded security applications.
the latter set is derived from a rockwell collins code base and uses arrays to provide a linked list set implementation where links are represented as indices in an auxiliary array with more efficient additions deletions.
these units are relatively small but generally have rich behavioral contracts since we focus on compositional verification of strong behavioral properties instead of selective search whole program bug finding.
note that many programs in safety security critical embedded applications are relatively small in size.
bakar kiasan summarizes the developer claim statuses on a per routine basis as well as the individual statuses of primitive and defining claims in each developer claim.
status tokens as described in section iii b5 such as d v v?
etc.
are provided along with claim status evidence like so type s col explication index lower v t paths .
.
.
.
.
.
.
.
.
.
.
.
index upper v t paths post check r ft failing path paths overall status r the above is a condensed report excerpt for the swap procedure of figure h the report summary style follows that of s park s pogs.
the report shows the verification status ofswap s postcondition the overall status isrindicating that the claim is refuted including its supporting primitive claims e.g.
index lower index upper which are array range checks and its defining primitive claim i.e.
post .
for each primitive claim the scolumn gives the verification status of the primitive claim given by i nterp prims the colcolumn gives the result of c ollect prims and the explication column gives links to the evidence that justifies the status.
as can be observed from the report there are three distinct paths that soundly abstract allthe concrete executions of swap s code contract.
the supporting claims are verified for all executions but the defining claim is refuted by failing path while the other two interestingly perhaps unexpectedly satisfy the post condition.
to complement this high level summary bakar kiasan also generates detailed html reports that include source code highlighting e.g.
syntax highlighting highlighting of problematic areas as described in section v and code coverage.
the html report illustrates each path as a test case with visualization of its pre post states.
space constraints prevent us from illustrating the html reports in sufficient detail interested readers can find complete evaluation reports for all our examples online .
figure presents the collective summary of the claim statuses for all examples mentioned at the start of this section.
this represents data for explicit claims recall that a d v r f r?
f?
u v?
i explicit .
.
.
.
.
.
.
.
.
implicit .
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
fig.
.
claim status distribution claim such as a post condition of figure a can consist of a complex expression spanning several source lines and calls to helper functions and implicit claims.
for each claim status the table gives the percentage of claims that have that status.
our goal here is not to suggest that the given distribution is in any way representative of what might be obtained if a different and larger sample of code was analyzed.
rather we believe that our main achievement is that xsymexeisable to generate such results.
as stated in the introduction our aim in the creation of xsymexeis not to suggest a replacement for say vcgen based verification technology but to offer a fully automated complementary alternative that we have found most useful during the early stages of contract and code development in critical systems.
as for the results themselves to our surprise the tool pointed out some dead claims in our s park suite despite it being used and analyzed in previous studies.
the number of verified claims is high and the percentage for the other statuses are low.
this is what we would expect because our spark code suite is fairly mature the contracts have been repeatedly analyzed and re worked.
we anticipate that in practice developers will more frequently encounter faulty and refuted claims as they write code contracts and they will want to eliminate those as early as possible during development e.g.
analogous to experiences when coding in a statically typed language .
once those are addressed their verification effort can then focus on the inconclusive statuses i.e.
uncovered indeterminate and those qualified with ?
which may require the use of higher reward higher effort techniques e.g.
vcgen tools or using proof assistants .
the proportion of claim statuses that are conclusive vs. those that are not is for explicit claims and .
overall.
that is on average our tool is able to report .
conclusive claim results for every inconclusive one in our sample.
while this is a good ratio for xsymexe more studies are needed to better appreciate what the proportion may be on a larger and perhaps evolving code in production.
vii.
r elated work early work on the application of s ymexeto the verification of safety critical software is described by coen porisini et al.
.
they used s ymexeto verify properties expressed in a specialized path description language pdl of functions written in safe c a very restricted dialect of c. in their approach a user must first use tooling to semi automatically create a finite program execution model em which is then used as input to the pdl property checker which in turn reports the list of em paths for which given properties hold.
our work differs firstly in that kiasan directly processes spark specifications expressed as contracts as opposed toseparate properties written in a specialized language.
s park contracts are formed from predicates built from standard ada expressions.
more importantly kiasan is fully automatic and does not require e.g.
user intervention in the creation of a finite model in the presence of while loops as is the case for the em generator.
forcing users to create finite ems side steps many of the problems we address in xsymexe.
our work was partly inspired by the s park proof obligation summariser pogs that a summarizes the verification status of verification conditions as they are processed by different stages in the s park tool chain and b uses spark s zombiescope tool to indicate code regions that are semantically dead.
our aim was to see how this concept could be adapted from the logical interpretation of contracts in the current version of s park to the executable interpretation to be used in the upcoming version and vcg ento s ymexe so that developers could profit from the benefits of s ymexe.
specifically in contrast to s park s vcg enapproach symexenaturally generates counter examples and test cases as evidence enables a number of helpful visualizations and does not require loop invariants to obtain an initial degree of contract checking.
in addition s park s vcg entends to yield an all or nothing approach when verifying contracts.
paths through a procedure are broken into segments and a vc is generated for each segment.
unless vcs for all segments are discharged or one is observed to be false nothing meaningful can be said about the verification status of the contract.
with s ymexe a developer s knowledge about the verification status of a contract is much more continuous immediate feedback with a degree on inconclusiveness is provided with low bounds and conclusiveness is increased as bounds increase.
pogs is less discerning.
it only characterizes a vc as discharged or undischarged it does not distinguish between an obligation that can be refuted from one whose status is yet to be determined.
finally our approach detects both dead code and dead claims.
this is beneficial for identifying e.g.
portions of contracts that are not useful.
zombiescope can detect dead code and thus detecting dead claims that are inside the dead code regions however it does not detect dead claims outside of code such as pre and post conditions as it uses the logical contract interpretation.
our discussion above applies to some extent to other vcg entechniques such as esc java tool family boogie and why .
similar to s park tools esc java2 has dead code detection however it does not detect dead claims.
esc java2 boogie openjml esc and why do not generate concrete counter examples to illustrate claim refutations.
some of these tools do provide counter examples but not in a form that is familiar to developers i.e.
logical formulae instead of test cases e.g.
thus it does not scale well in terms of clarity to counter examples involving complex constraints.
similar to the s park examiner esc tools and why do not distinguish provable claim refutations from failed verification attempts.
some vcg en based tools such as boogie can resort to a form of eager bounded analysis by loop unrolling hence loopinvariants are not required but in such cases it diminishes the technique to merely bug finding.
in contrast xsymexeuses dynamic lazy bounding thus xsymexecan achieve verification when it determines all behaviors are within the bounds.
moreover we are not aware of their reporting capabilities e.g.
evidence generation and result categorization especially to the extent of the work presented here.
we believe our work can be adapted to a bounded vcg en based approach as well.
verifast and jstar are verification tools based on separation logic for checking claims about heap data.
they use an algorithmic approach to s ymexethat differs from that are used in spf klee bakar kiasan etc.. instead of relying on bounded checking these tools require loop invariants and inductive predicates over data structures to create symbolic summaries of heap shapes.
while these tools are beneficial they target a different space i.e.
focusing on full verification of heap properties and require significantly more annotations to be added by developers.
for counter example information jstar can only generate program locations of interest when it cannot verify claims.
in addition it does not discern undischarged claims similar to the s park examiner and vcg en tools above and it does not address contract undefinedness.
we believe bug finding tools such as spf klee and pex are useful especially when applied to code as it is being developed.
however because of many engineering compromises such as selective search e.g.
heuristic based symbolic state space exploration context bounding e.g.
test harness etc.
they do not provide guarantees when there is no bug detected.
hence such approaches are not be able to verify claims or to precisely determine dead claims or code .
regardless we believe our approach can be applied in such under over approximating settings.
for example in the context of selective search which causes some states to not be explored the states can be treated as cutoff points.
context bounding is essentially an ad hoc form of assumption which may produce under over approximation it is typically done for testing certain code behaviors.
as the code is geared for verification it should be codified as a contract.
viii.
c onclusions and future work we have argued that bounded s ymexe as commonly implemented in the software engineering community cannot be applied effectively for verification.
despite the fact that it a offers various usability advantages and b typically employs the same underlying decision procedure packages as verification condition generation vcgen the ad hoc approaches taken in s ymexefor introducing optimizations and over under approximations have prevented tools from reporting the precise verification status of contract claims causing s ymexeto take a back seat to other deduction based techniques like vcgen in the context of verification.
in this work we have presented a collection of principles that allow s ymexeto be used confidently in development contexts that require verification as opposed to just bugfinding.
furthermore we have presented an approach by which information accumulated during s ymexecan organized intoexplications that provide evidence based justifications for the resulting verification status of claims.
although we have demonstrated our approach in the context of the s park framework the principles that we have introduced can be applied by other bounded s ymexetools as well.
the foundation presented here enables a number of interesting future directions.
for example making verification status of claims explicit enables a synergistic combination with other verification tools e.g.
vcgen based tools programs are first submitted to highly automated xsymexebased techniques and then only undischarged claims i.e.
any status but verified refuted dead are handed off to downstream verification tools that require more manual effort.