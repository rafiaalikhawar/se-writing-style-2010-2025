operator based and random mutant selection better together lingming zhang university of texas austin tx zhanglm utexas.edumilos gligoric university of illinois urbana il gliga illinois.edudarko marinov university of illinois urbana il marinov illinois.edusarfraz khurshid university of texas austin tx khurshid utexas.edu abstract mutation testing is a powerful methodology for evaluating the quality of a test suite.
however the methodo logy is also very costly as the test suite may have to be executed f or each mutant.
selective mutation testing is a well studied technique to reduce this cost by selecting a subset of all mutants whic h would otherwise have to be considered in their entirety.
two common approaches are operator based mutant selection which only generates mutants using a subset of mutation operators and random mutant selection which selects a subset of mutants generated using all mutation operators.
while each of the tw o approaches provides some reduction in the number of mutants to execute applying either of the two to medium sized real world programs can still generate a huge number of mutants which makes their execution too expensive.
this paper prese nts eight random sampling strategies defined on top of operatorbased mutant selection and empirically validates that ope ratorbased selection and random selection can be applied in tande m to further reduce the cost of mutation testing.
the experime ntal results show that even sampling only of mutants generated by operator based selection can still provide precise muta tion testing results while reducing the average mutation testi ng time to .
i.e.
on average less than minutes for this study .
i. i ntroduction mutation testing has been shown to be a powerful methodology for evaluating the quality of test suites.
in fi rstorder mutation testing many variants of a program known asmutants are generated through a set of rules known as mutation operators that seed one syntactic change at a time in order to generate one mutant.
then all the generated mutant s are executed against the test suite under evaluation.
a test suite is said to killa mutant if at least one test from the suite has a different result for the mutant and original program.
i f a mutant is semantically equivalent to the original program then it cannot be killed by any test.
the more non equivalent mutants a test suite can kill the higher quality the test sui te is predicted to be.
indeed several studies have fou nd mutants to be suitable alternatives for real faults which ca n be used for comparing testing techniques and test suites.
th e predicted quality of test suites also depends on the quality of mutants consequently higher order mutation testing has b een proposed to generate a small number of mutants that each have multiple syntactic changes .
mutation testi ng has also been used to guide the test generation to kill mutant s automatically .while mutation testing could be useful in many domains it is extremely expensive.
for example a mutation testing tool for c proteum implements mutation operators that generate mutants for a small c program with only non blank non comment lines of code .
therefore generating and especially executing the large number of m utants against the test suite under evaluation is costly.
var ious methodologies for reducing the cost of mutation testing hav e been proposed.
one widely used methodology is selective mutation testing which only generates and executes a subset of mutants for mutation testing.
ideal ly the selected subset of mutants should be representative of t he entire set of mutants.
the most widely studied approach for selective mutation testing is operator based mutant selection which only generates mutants using a subset of mutatio n operators the selected subset of mutation operators is req uired to be effective i.e.
if a test suite kills all the non equivalent mutants generated by the selected set of operators i.e.
th e test suite is adequate for selected mutants then the test suite should kill almost all the non equivalent mutants genera ted by all mutation operators.
further selected operators sho uld lead to high savings the savings is usually calculated as the ratio of non selected mutants over all the mutants.
researc hers also evaluated a simple approach of random mutant selection and a recent study reported that random selection is as effective as operator based mutant selecti on when random selection selects the same number of mutants from all mutants as the operator based selection selects.
although the existing approaches are effective mutation testing remains one of the most expensive methodologies in software testing.
no previous study has explored how to further reduce the number of mutants generated by operatorbased mutant selection and whether operator based select ion and random selection can be combined.
also previous work has not explored how random mutant selection and operatorbased selection relate for test suites that do not kill all no nequivalent mutants i.e.
non adequate test suites .
in addition all the studies for sequential mutants evaluated mutant selection on small c and fortran programs the largest program used for selective mutation testing was only lines of code.
empirical studies on larger real wo rld programs are lacking.
c ieee ase palo alto usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.92this paper makes the following contributions sampling mutation we investigate a simple idea which we call sampling mutation to reduce the number of mutants generated by operator based mutant selection sampling mutation randomly selects from the set of mutants generated by operator based mutant selection rather than from the set of mutants generated by all operators we call the process of obtaining the mutants sampling the percentage of randomly selected mutants thesampling ratio and the resulting set of mutants a sample .
various sampling mutation strategies we evaluate sampling strategies our study is the first to consider random selection based on the program elements rather than on the mutation operators .
our empirical study shows that although all sampling strategies are effective for mutation testing sampling based on program elements can provide the most effective results.
extensive study we evaluate mutation sampling on real world java projects of various sizes from to lines of code to investigate the effectiveness predictive power and savings of sampling mutation.
our study evaluates effectiveness in case of adequate test suites predictive power in case of non adequate test suites and savings in terms of time to generate and execute mutants.
empirical evidence the study shows that sampling mutation remains effective and has a high predictive power even while providing high savings.
the study shows the cost effectiveness of applying sampling mutation with various strategies and ratios.
surprisingly for all our subjects the experimental results show that sampling only of operator based selected mutants can still provide a precise mutation score with almost no loss in precision while reducing the mutation time to .
on average.
moreover the study shows that the sampling strategies are more beneficial for larger subjects as more and more researchers are using mutants to compare testing techniques our sampling strategies can help researchers to scale mutation to larger programs by choosing a representative subset of mutants for efficient but effective evaluation.
ii.
s tudy approach a. problem definition given a program under test p and a test suite t we denote the set of all selected mutants generated by operatorbased mutant selection as m and the set of non equivalent mutants in masnem .
following existing studies we randomly construct ntest suites of various sizes t1 t2 ... tn the set of mutants that can be killed by ti i n is denoted k ti m .
then the actual selected mutation score achieved by tiover the selected mutantsmis defined as ms ti m k ti m nem in this study we apply a set of sampling strategies on top of the selected mutants.
let sbe a sampling strategy the set of mutants sampled bysfrommis denoted ms. we apply each strategy mtimes with different random seeds to generate a set of mutant samples ms1 ms2 ... m sm .
the set of mutants in msj j m that are killed by test suite ti i n is denoted k ti msj .
then the sampling mutation score achieved by tiovermsjcan be represented as ms ti msj k ti msj msj nem intuitively if ms ti msj is close to ms ti m for all i nand1 j m we say that the sampling strategysapplied on top of selected mutants is effective at predicting the result that would be obtained on all selected mutants.
section iii precisely defines the predictive powe r. b. measurement in the literature there are two main approaches for evaluating the effectiveness of how a subset of mutants represent s a larger set of mutants.
traditionally the sets are genera ted by all operators and the subsets are selected mutants in our study the sets are selected mutants and the subsets are sampled mutants.
first researchers co nstruct test suite ti i n that can kill all non equivalent mutants from the subset called adequate test suites and calculate the mutation score of tion the original set of mutants.
second namin et al.
also examined how for test suitesti i n that cannot kill all the non equivalent mutants from the subset called non adequate test suites the mutation score of tion the subset of mutants compares with the mutation score of tion the original set of mutants.
in this study we use both approaches to evaluate the sampling strategies applied on top of operator based mutan t selection.
for the first approach since our sampling strate gy may select different subsets of mutants at different runs w e randomly construct nadequate test suites that can kill all sampled non equivalent mutants for each of the msampling runs.
we denote the ith i n test suite that kills all sampled non equivalent mutants in the jth j m run of sampling i.e.
the selected mutants are msj astij.
following previous work we use the following formula to measure theeffectiveness of a sampling technique s ef s m j 1 n i ms tij m n m the only difference between our formula and the original formula is that we also average over msampling runs the previous work did not average over different runs becaus e each run of their operator based selection gives a fixed subs et of mutants.
also note that in the evaluation we present the standard deviation sd values across msampling runs to show the stability of the sampling strategies.
for the second approach we randomly construct knonadequate test suites t1 t2 ... tk for each subject and check how mruns of sampling influence the mutation scores93of the constructed test suites.
we use the correlation betwe en sampling mutation score of tiand selected mutation score of tito measure the predictive power of a random sampling strategy sover the mutants generated by operator based mutant selection pp s corr an bracketle tms ti msj ms ti m an bracketri ht i k j m the correlation analysis is between the mutation scores on the sampled mutant set msjand the mutation scores on the selected mutants mfor all constructed test suites for all sampling runs j m .
section iii presents both visually and statistically the corr functions we use.
to illustrate for all the msampling runs of a strategy s if we use the mutation scores of the ktests suites on sampled mutants msj j m i.e.
ms ti msj i k as the xaxis values for each x value we will have a corresponding y value to predict which is ms ti m i k .
for a perfect strategy the graph will be the straight line funct ion y x which means all the ktest suites have exactly the same mutation score on sampled mutants and all original mutants before sampling.
c. combining operator based and random mutant selection given selected mutants m we define eight random sampling strategies that specify which mutants to select from m. baseline strategy which samples x mutants from the selected set of mutants m. formally the set of mutants sampled by strategy sbase can be defined as msbase sample m x wheresample m x denotes random sampling of x mutants from m. mop based strategy which samples x mutants from each set of mutants generated by the same mutation operator.
assume the sets of mutants generated by the set of selective mutation operators say op1 op2 ... op k are mop1 mop2 ... mopk i.e.
m k i 1mopi.
then the set of mutants sampled by strategy smopcan be formally defined as msmop k i 1sample mopi x pelem based strategies which sample x mutants from each set of mutants generated inside the same program element e.g.
class method or statement .
assume the sets of mutants generated for the set of elements in the project under test are me1 me2 ... mek i.e.
m k i 1mei.
then the set of sampled mutants can be defined as mspelem k i 1sample mei x 1if the sample size is a float f we first sample f mutants at random and then with probability f f pick one more mutant at random.table i subject programs used in the evaluation mutants subject loc tests all killed timemoneyr207 jdependv2.
jtopasv2.
barbecuer87 mime4jv0.
jaxenr1346 xstreamv1.
xmlsecurityv3.
commonslangr1040879 jodatimer1604 jmeterv1.
in this way sclass smeth andsstmt can be defined when using the program element granularities of class method and statement respectively.
pelem mop based strategies which sample x mutants from each set of mutants generated by the same mutation operator inside the same program element.
assume the sets of mutants generated for the set of program elements in the project under test are me1 me2 ... mek thenm k i 1mei.
also assume the sets of mutants generated by the set of selective mutation operator are mop1 mop2 ... moph thenm h j 1mopj.
finally the set of sampled mutants can be defined as mspelem mop k i h j 1sample mei mopj x in this way sclass mop smeth mop andsstmt mopcan be defined when using the program element granularities of class method and statement respectively.
note that the first two strategies sbaseandsmop have been used by previous studies to evaluate random mutant selection from all mutants .we believe that using all mutants as the candidate set may be unnecessary.
therefore we use these two strategies to evaluate random mutant sampling fro m operator based selected mutants .
in addition our three spelem strategies which aim to sample mutants across all program locations evenly are the first to randomly sample mutants at the program element dimension.
furthermore our three spelem mop strategies are the first to sample mutants across two dimensions mutation operators and program elements.
iii.
e mpirical study we performed an extensive empirical evaluation to demonstrate the effectiveness predictive power and savings of the proposed sampling strategies.
a. subject programs the evaluation includes a broad set of java programs from various sources.
we chose programs of different sizes from to loc to explore the benefits of our sampling strategies for various cases.94table i shows subject programs used in the evaluation timemoney a set of classes for manipulating time and money jdepend a tool for measuring the quality of code design jtopas a library for parsing arbitrary text da ta barbecue a library for creating barcodes mime4j a parser for e mail message streams in mime format jaxen an implementation of xpath engine xstream a library for fast serialization deserialization to from xml xmlsecurity an apache project that implements security standards for xml commonslang an apache project that extends standard java library jodatime a replacement for standard java date and time classes and jmeter an apache project for performance testing.
all the subjects have been widely used in softwar e testing research .
table i includes some characteristics of the programs.
column subject shows the name of each subject program the version revision number as applicable and the refere nce to the webpage with sources loc shows the number of non blank lines of code measured by javasourcemetric tests shows the number of available tests for the program it is important to note that we have not created any special test for the purpose of this study all the tests for subjects come from their code repositories and to the best of our knowledge all these tests are manually written mutantsall and mutantskilled show the total number of mutants that javalanche generated using operat orbased selection and the number of killed mutants respectiv ely.
we used javalanche because it is a state of the art mutatio n testing tool for java programs.
it generates mutants using t he operator based mutant selection approach proposed by offu tt et al.
.
specifically javalanche uses the followin g four mutation operators negate jump condition omit method call replace arithmetic operator and replace numerical constant.
note that the subjects used in our study are orders of magnitude larger than the subjects used in previous studi es on selective mutation testing .
b. experimental design we next describe our experimental setup and the data we collected.
independent variables we used the following independent variables in the study iv1 different random sampling strategies.
we apply each of our eight sampling strategies on top of the mutants generated by operator based mutant selection to investig ate their effectiveness predictive power and savings.
iv2 different sampling ratios.
for each sampling strategy s we use sampling ratios r ... .
iv3 different subject sizes.
for each strategy swith each ratior we apply son all the subjects with various sizes and investigate the differences.
dependent variables we used the following dependent variables to investigate the output of the experiments dv1 effectiveness.
for the mutants sampled by each strategy samong all selected mutants we construct test suites that can kill all sampled non equivalent mutants and record theselected mutation score of those test suites.
the higher the selected mutation score is the more effective the selected mutants are for evaluating test suites equation .
the sa me experimental procedure was used previously to measure the effectiveness of operator base selection and random selec tion .
dv2 predictive power.
for each sampling strategy s we also construct test suites that do not kill all sampled nonequivalent mutants and use statistical analysis to measur e the predictive power of the sampled mutants equation .
if the constructed test suites have similar values for samplin g mutation score and selected mutation score then the sample d mutants are a good predictor of the selected mutants.
more precisely we instantiate the corr function to measure r2 coefficient of determination for linear regression kendal l s rank correlation coefficient and spearman s rank correlation coefficient.
dv3 time savings.
for each triple p s r of subject program p sampling strategy s and sampling ratio r we compare the mutation testing time for the sampled mutants and the mutation testing time for the selected mutants.
experimental setup following previous studies on selective mutation testing we deemed all mutants tha t cannot be killed by any test from the original test suite as equivalent mutants in our study.
we evaluate all the samplin g strategies with all sampling ratios on all subjects.
given a subject program and selected mutants for that program we first run sampling times for each of sampling strategies with each of the sampling ratios.
as a result we get samples of mutants for each subject program.
then for each sample of mutants we randomly construct adequate test suites that each kill all the non equivalen t mutants in sampled mutants i.e.
we construct test suites for each subject.
next we measure the selected mutation score for each test suite.
each test suite is random ly constructed by including one test at a time until all sampled non equivalent mutants are killed.
we deviate from the prev ious work that constructed test suites by inclu ding multiple tests at a time using increment of or as suc h decision can lead to large test suites and high selected muta tion scores that do not correspond to practice.
by including one t est at a time we simulate a more realistic use of mutation testin g in practice where a user could include one test at a time unti l all the mutants are killed.
next for each subject we randomly construct nonadequate test suites of various sizes that do not necessary kill all the sampled mutants.
we randomly construct each test sui te by uniformly selecting the size of the test suite to be betwee n and the number of tests available for the subject.
note that our experiments differ in this step from previous work where test suites were generated by taking two test suite s for each size between and .
the reason to deviate from previous work is that our programs greatly differ in size and number of tests which was not the case in previous studies.
for example taking sizes between and does not seem appropriate for both barbecue and jodatime with and953818 tests respectively .
therefore we uniformly select the sizes of the test suites up to the total number of tests for each subject program.
then we measure the sampling mutation score i.e.
the mutation score on the sampled mutants and selected mutation score i.e.
the mutation score on the sel ected mutants achieved by each of the constructed test suites.
we further perform correlation analysis between the sampling mutation score and the selected mutation score for all test suites on each strategy and ratio combination on each subjec t. section iii c2 shows the details.
finally for each sample of mutants we also trace the time for generating and executing the mutants.
although it i s common in the literature to report the savings in terms of the number of mutants not generated this information is implic itly given in our study through the sampling ratio e.g.
if a sampling ratio is we have 20x fewer mutants .
therefore our study also reports the mutation execution time in order to confirm that savings in terms of the number of mutants correspond to the savings in terms of mutation execution tim e for mutation sampling.
we performed all experiments on a dell desktop with intel i7 core .8ghz processor 8g ram and windows enterprise bit version.
c. results and analysis we report the most interesting findings of our study in this section while some additional results and detailed experi mental data are publicly available online .
effectiveness for adequate test suites table ii shows the selected mutation scores achieved by randomly construc ted adequate test suites that achieve sampled mutation sco re i.e.
kill all the sampled non equivalent mutants.
accordi ng to our experimental setup for each triple of subject program strategy and sampling ratio p s r we obtain samples of mutants and construct adequate test suites for each sample.
thus for each p s r we show the average selected mutation score and standard deviation achieved by the test suites.
specifically column ra.
shows sampling ratio column subject shows the subject name an d columns show the average values and standard deviation s achieved by sampling strategies.
the results for all the sampling ratios can be found on the project webpage .
based on the obtained values we make several observations as follows.
first for all subjects and all sampling strategies one can see that the sampled mutants are extremely effective i.e.
the sampled mutants are representative of the selected mutants .
for example even when sampling of the selected mutants the test suites that kill all the sampled mutants can kill almost all selected mutants.
to illustrate when sampling of select ed mutants the selected mutation score for sbase strategy ranges from .
on jdepend to .
on jodatime with the average value of .
.
as the sampling ratio increases all the strategies have higher selected mutation score and lower standard deviation for all subjects.
this demonstrat e that a user can use the sampling strategies to control the cos t effectiveness of mutation testing the more mutants sample d the more precise and stable the results would be.
second the studied strategies perform better on larger subjects than on the smaller subjects.
for example when sampling of mutants smeth achieves the average selected mutation scores ranging from .
to .
for the first four subjects that have fewer than loc while it achieves the average selected mutation scores ranging from .
to .
for all the other seven larger subjects.
thi s demonstrates that using small sampling ratios e.g.
r of mutants is more beneficial for evaluating test suites for lar ger subjects.
section iii d further investigates the effectiv eness of sampling mutation for ratios even below .
third all the strategies perform similarly but smeth and smeth mop tend to perform the best of all the strategies for the majority of the subjects.
moreover the additional use o f mutation operator information in smeth mopdoes not make it outperform smeth .
this demonstrates that sampling mutants across different program elements can be a better choice than sampling mutants globally sbase or across different mutation operators smop .smeth performs better than sclass andsstmt likely because sampling at the class level is too coarse bringing it closer to sbase while sampling at the statement level is too fine making it select no mutant from some statements because the number of mutants for each statement is relatively small .
predictive power for non adequate test suites while the above results showed that adequate sampling mutation score implies high selected mutation score it is uncommon i n practice to have adequate test suites.
thus we further inve stigate the predictive power of the sampling strategies for nonadequate test suites that do not kill all sampled non equivalent mutants.
more precisely we analyze whether the sampling mutation score is a good predictor of the selected mutation score across a range of test suites which are almost all nonadequate.
ideally for all non adequate test suites samp ling and selected mutation score would have the same value.
in practice if a test suite achieves selected mutation score ms the same test suite may achieve sampling mutation score ms such that ms ms ms ms orms ms .
we use three statistical measures to evaluate the predictive powe r of sampling mutation score for all strategies.
evaluating single test suite.
originally mutation testing was proposed as a method for evaluating the quality of test suites by measuring mutation score the higher mutation sco re means higher quality.
to evaluate a test suite using one of the sampling strategies we have to ensure that the result obtained on the sampled mutants predicts the result that wou ld be obtained on all the selected mutants.
following previous work we determine how well the independent variable sampling mutation score predicts the dependent variable selected mutation score using a linear regression model.
we measure the quality of fit of a model by calculating the adjusted coefficient of determination r2 which is a statistical measure of how well the regression line approximates the rea l96table ii selected mutation scores achieved by the test s uites that achieve sampled mutation scores base mop class meth stmt class mop meth mop stmt mop ra.
subjects ms. dev.
ms. dev.
ms. dev.
ms. dev.
ms. dev.
ms. dev.
ms. dev.
ms. dev.
timemoney .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdepend .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jtopas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
barbecue .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4j .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xstream .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commonslang .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jodatime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmeter .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
timemoney .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdepend .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jtopas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
barbecue .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4j .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xstream .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commonslang .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jodatime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmeter .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
timemoney .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdepend .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jtopas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
barbecue .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4j .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xstream .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commonslang .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jodatime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmeter .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
timemoney .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdepend .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jtopas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
barbecue .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4j .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xstream .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commonslang .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jodatime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmeter .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
data points.
the value of r2is between and where a higher value indicates a better goodness of fit.
we calculate r2for each triple p s r consisting of a subject program strategy and ratio.
for each sample strat egy s we sample mutants at each ratio rand measure sampling mutation score for the same set of randomly constructed test suites section iii b3 .
we repeat sampling times to obta in sampling and selected mutation scores for a variety of sampl es.
we then calculate how well the sampling mutation scores from all the sampling runs predict the selected mutation score s by calculating r2values2.
note that we calculate r2for all sampling runs at once which gives a more robust result than calculating r2for individual runs and averaging the result over sampling runs .
to illustrate figure shows scatte r plots of the sampling mutation score and the selected mutati on score for commonslang.
in each of the three subfigures 2we use r language for statistical computing.the x axis shows the sampling mutation scores achieved by the test suites on various sampling runs while the y axis shows the selected mutation score for the same test suites.
there are points on each plot.
from the three subfigures we can see that a higher sampling ratio r leads to more stable data points which can also be seen by smoother splines.
however note that the sampling mutation scores on all sampling runs are close to their selected mutation score s even when r .
the left part of table iii shows r2values for all strategies with the sampling ratio of on all subjects.
due to the space limit the detailed results for the other ratios are no t shown but can be found on the project webpage .
column subjects lists the name of the subjects and columns includer2values for all sampling strategies.
the higher ther2value is the better predictor the sampling strategy is.
we find that the r2results at the ratio level are970 100commonslang sampling mutation score selected mutation score a ratio0 100commonslang sampling mutation score selected mutation score b ratio0 100commonslang sampling mutation score selected mutation score c ratio fig.
sampling mutation score vs. selected mutation score with best fit line black color and smoothing spline line r ed color for commonslang subject meth strategy and three d ifferent sampling ratios table iii r2and correlation values between mutation scores on sampled mu tants and on mutants before sampling r2correlation kendall s correlation subjects base mop class meth stmt class meth stmt base mop class meth stmt class meth stmt mop mop mop mop mop mop timemoney .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdepend .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jtopas .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
barbecue .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4j .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xstream .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commonslang .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jodatime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmeter .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
already extremely high e.g.
ranging from .
on jtopas to .
on commonslang for the smeth strategy.
this further confirms our findings for adequate test suites the sampling ratio of can be effective for mutation testing in practice .
in addition similar to our findings for adequate test suites the sampling strategies are less effective for smaller subj ects e.g.
ther2for thesmeth strategy ranges from .
to .
for the first four subjects below loc while it is over .
for the other seven larger subjects.
furthermore alth ough all the strategies perform well the smeth strategy slightly outperforms sbase andsmopfor all the subjects indicating again that sampling across different program elements can b e a better choice than sampling purely randomly from all mutant s or sampling across different mutation operators.
to show how the correlation varies when the sampling ratio changes figure 2a shows the r2values for all strategies when the sampling ratio increases from to for the subject commonslang.
the plots for the other subjects look similar and are available on the project webpage .
we can draw the following conclusions.
first smeth is slightly better than the other strategies across all sampling ratios further demonstrating the benefits of sampling mutants acro ss program elements.
second more importantly all sampling strategies predict the selected mutation score very well.
a cross all the programs strategies and ratios the minimum r2was .
for jtopas .
extremely high r2gives evidence thatsampling mutation is valuable and can be used for evaluation of test suites.
we believe that the results of our study can greatly impact the use of mutation testing in research pract ice using sampling mutation testing makes it feasible to evalua te the quality of test suites for large scale programs.
comparing testing techniques and test suites.
mutation testing has also been extensively used in studies that compa re testing techniques .
commonly a testing techniq ue or a test suite that has a relatively higher mutation score th an another testing technique or test suite is claimed to be bett er regardless of the absolute mutation score that it achieves .
we thus want to evaluate whether sampling mutation can be used for comparison of testing techniques and test suites i.e.
if a test suite thas a higher sampling mutation score than another test suite t doesthave a higher selected mutation score than t ?
similar to a previous study we calculate kendall s and spearman s rank correlation coefficients which measure the strength of the agreement between two rankings.
both and can take values between and where indicates perfect agreement and indicates perfect disagreement.
to illustrate how is computed consider all the pairs of sampling and selected mutation scores two pairs ms1 ms and ms2 ms are said to be concordant if ms1 ms2 ms ms ms1 ms ms ms and discordant if ms1 ms ms ms ms1 ms2 ms ms otherwise the pair is neither concor .
.
.
.000commonslang sampling ratio r base mop class method stat class mop method mop stat mop a r220 .
.
.
.
.00commonslang sampling ratio kendallbase mop class method stat class mop method mop stat mop b fig.
correlation values for commonslang subject all str ategies and all rates table iv selective and sampling mutation testing time all mutants sampled mutants mm ss subject mmm ss min.
max.
avg.
pct.
timemoney .
jdepend .
jtopas .
barbecue .
mime4j .
jaxen .
xstream .
xmlsecurity .
commonslang .
jodatime .
jmeter .
avg.
.
dant nor discordant.
kendall s is calculated as the ratio of difference between the number of concordant and discordant pairs over total number of pairs.
in this paper we use b which has a more complex computation because it takes ties into consideration.
we calculate kendall s bfor each triple p s r following the same procedure as for r2.
similar with the r2measure we show the bmeasure for all the strategies on all subjects with the sampling ratio of in the right part of table iii.
we also show kendall s bvalues for commonslang subject all sampling strategies and all sampling ratios in figure 2b.
t he plots for the other examples look similar and are available o n the project webpage .
across all the subjects all strat egies and all ratios the minimal value for bin our study was .
for jdepend .
considering table iii and figure 2b we can draw similar conclusions as from the r2correlation measures.
first all sampling strategies provide very similar result for kendal l s .
in addition smeth slightly outperforms sbase andsmopfor all subjects.
second all the values are very high which indicates very strong agreement between rankings .
the results for spearman s show even stronger agreement details can be found on the project webpage .
based on our study we believe that the comparison of test suites or testing techni ques can be done using sampling mutation.
savings obtained by mutation sampling table iv shows the selected mutation testing time for all the mutants generated by javalanche recall that javalanche usesoperator based selection and the sampling mutation test ing time for the sampling ratio of and our smeth strategy.
column subject lists the subjects column all mutants shows the mutant generation and execution times for all the mutants generated by javalanche and columns list the minimum maximum average mutant generation and execution times for the sampling mutation with the sampling ratio of across sampling runs.
in column pct.
we also show the ratio of the sampling mutation testing time over the selected mutation testing time.
note that we include the mutant generation time of all selected mutants for both selected mutation and sampling mutation because our curre nt implementation requires javalanche to generate all the mut ants before sampling.
the results show that the sampling mutatio n testing time with sampling ratio of is close to of the selected mutation testing time.
we further noticed that the sampling mutation testing time on small subjects tends to be longer than expected of selected mutation time because f or small subjects the tool setup time and the mutant generation time rather than the mutation execution time can dominate the total mutation testing time.
however for the seven larg er subjects the tool setup time and the mutant generation time take insignificant time compared to the total mutation testi ng time leading to sampling mutation time from .
to .
of the selected mutation time.
on average across all the subjects the sampling mutation testing time is less than minutes in contrast the original javalanche time is much m ore and exceeds minutes.
d. below our experimental results show that it is possible to greatly reduce the number of mutants e.g.
sampling only mutants while still preserving the mutation score.
however it was not clear whether we can use sampling ratio below .
thus we additionally collected the experimental results f or sampling fewer than mutants.
table v shows the results for thesbase andsmeth strategies.
the detailed results for all the strategies can be found online .
in the table column lists all the studied sampling ratios columns l ist the average selected mutation scores for adequate test suit es as well as the average r2and the correlation values for99table v results of sampling below of selected mutants ra.
base meth ms. r2 ms. r2 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
inadequate test suites by the sbase strategy across all subjects.
similarly columns list the corresponding results for t he smeth strategy.
the results show that it is possible to have a fairly reliable mutation score even when sampling fewer than mutants.
however by the rule of which would require the sampling mutation score to be or higher the ratio of .
is on the borderline for our set of programs and tests and may not generalize to other programs and tests.
in the future we plan to evaluate whether advanced techniques e.g.
search based mutant selection could ach ieve even smaller sampling ratios.
in addition the results show that smeth outperforms sbasein terms of all the three metrics with sampling ratio of greater than further demonstrating th e benefits of our proposed sampling based on program elements.
e. threats to validity threats to construct validity.
the main threat to construct validity for our study is the set of metrics used to evaluate t he mutant sampling strategies.
to reduce this threat we use tw o widely used metrics the mutation score metric for adequate test suites and the correlation ana lysis for non adequate test suites .
our study still inherits a major threat to construct validity as in those previous studies we considered all mutants not killed by the original test pool t o be equivalent due to the lack of precise techniques for detecti ng equivalent mutants.
threats to internal validity.
the main threat to internal validity is the potential faults in the implementation of ou r sampling strategies or in our data analysis.
to reduce this threat the first two authors carefully reviewed all the code for mutant sampling and data analysis during the study.
threats to external validity.
the main threat to external validity is that our results from this study may not generali ze to other contexts including programs tests and mutants.
to reduce this threat we select real world java programs with various sizes from to lines of code from various application domains.
note that our study includes m ore programs than any previous study on selective mutation test ing for sequential code .
in addition t he programs used in our study are one to two orders of magnitude larger than programs used in similar previous studies.
iv.
r elated work mutation testing was first proposed by hamlet and demillo et al.
.
since then due to its cost and effectiven ess a large amount of research has been dedicated to reducing the cost of mutation testing and exploring the application o f mutation testing.
in this section we first discuss the relat ed work in reducing the cost of mutation testing.
then we discus s the existing applications of mutation testing.
more detail s about existing work on mutation testing can be found in a recent survey by jia and harman .
a. reducing the cost of mutation testing there are mainly three ways to reduce the cost of mutation testing selecting a subset of all mutants section iv a1 executing each mutant partially section iv a2 and optimiz ing mutation generation and execution section iv a3 .
selective mutation testing selective mutation testing which was first proposed by mathur aims to select a representative subset of all mutants that can still achiev e similar results as all mutants.
since its first proposal a la rge amount of research effort has been put on operator based mutant selection which only generates mutants based on a subs et of mutation operators.
wong and mathur investigated selection of two mutation operators among all the mutatio n operators in mothra and found that mutants generated with the selected two mutation operators can achieve simila r mutation testing results as all the mutation operators.
o ffutt et al.
then proposed five mutation operators named sufficient mutation operators through a set of experimental studies to ensure that the selected set of mutants achieves almost the same results as the entire mutant set.
barbosa et al.
proposed six guidelines to determine a set of mutation operators.
namin et al.
used rigorous statisti cal analysis to determine mutation operators from all the mutation operators of proteum .
recently gligoric et al.
also investigated operator based mutant selection for concurrent mutation operators.
in contrast to operator based mutant selection random mutant selection was less widely researched.
the idea of rando m mutant selection was first proposed by acree et al.
and budd .
wong and mathur empirically studied randomly selecting x of all mutants generated by mothra.
since then researchers mainly used random mutant selectio n as a control technique when evaluating operator based muta nt selection .
however a recent study by zhang et al.
demonstrated that random mutant selection can be equally effective with operator based selection when selecting th e same number of mutants.
the study used larger subjects c programs from siemens suite ranging from to lines of code and more mutation operators mutation operators implemented by proteum than previous studi es.
however the studied subjects are still relatively small.
i n addition they did not demonstrate that random mutant selecti on can further be applied to operator based selected mutants .
in contrast our study is the first to show that random mutant selection can be applied together with operator based sele cted mutants e.g.
even sampling of operator based generate d mutants can still achieve precise mutation score.
in additi on we used real world java programs from to lines100of code which are orders of magnitude larger than subject programs used in previous studies on selective mutation .
weakened mutation testing weakened mutation testing which was first proposed by howden aims to provide a more efficient way to determine whether a mutant is killed by a test.
more precisely the traditional mutation testing con siders a mutant as killed only when a test generates different final results for the mutant and the original program.
on the contrary the first work of weakened mutation testing weak mutation considers a mutant as weakly killed when a test triggers a different program internal state when executing the mutated statement on the mutant and on the original program.
however this approach is imprecise because some internal states triggered by a test may not be propagated to the final result.
to better balance the cost and precision woodward a nd halewood proposed firm mutation which is a spectrum of techniques between weak and strong mutation.
offutt and lee experimentally investigated the relationships be tween weak mutation and strong mutation.
our study is orthogonal to this line of work our study aims to reduce the number of mutants while weakened mutation testing aims to reduce the execution cost for each mutant.
optimized mutation testing optimized mutation testing aims to explore efficient ways to generate compile and execute mutants.
demillo et al.
extended a compiler to compile all mutants at once to reduce the cost of generating and compiling a large number of mutants.
similarly untch et al.
proposed the schema based mutation approach which generates one meta mutant that encodes all the mutant s and can be compiled by a traditional compiler.
researchers have also investigated various ways to run mutants in parallel to speed up mutation testing .
recently we proposed approaches inspired by regression testing to optimize the test execution for each mutant .
more specifically inspired by regression test selection w e proposed remt to incrementally collect mutation testi ng results based on old mutation results inspired by regressi on test prioritization and reduction we proposed famt to prioritize and reduce tests for each mutant to collect mutat ion testing results faster.
our sampling strategies which fur ther sample mutants over operator based selected mutants aim t o reduce the cost of mutation testing at a different dimension .
b. applications of mutation testing mutation testing was initially used to evaluate the quality of test suites.
after achieving the mutation score for the te st suite evaluation the user can improve the quality of the tes t suite manually.
researchers have also proposed techniques that automatically generate tests to kill mutants.
demillo and offutt first proposed constraint based testing cbt to generate tests each killing one mutant based on static symbolic evaluation.
offutt et al.
further proposed th e dynamic domain reduction technique to further refine cbt.
recently researchers proposed more solutions for this are a due to the growing computing power.
fraser and zeller used search based software testing sbst to generate test s for mutant killing.
zhang et al.
and papadakis et al.
used dynamic symbolic execution dse to generate tests for mutant killing.
harman et al.
combined sbst and dse techniques to generate tests that kill multiple mutants at a time.
our sampling strategies may make these test generatio n techniques more efficient by only generating tests that kill a sample of mutants.
mutants generated by mutation testing can also be used to simulate real program faults to evaluate software testin g techniques.
the advantage compared with seeded or real faul ts is that mutation faults can be systematically generated ma king the generation replicable and sufficient for statistical an alysis.
andrews et al.
empirically showed that the mutant s which are generated by selective operators simulate real f aults better than manually seeded faults and is appropriated for evaluating testing techniques.
do et al.
also showed th at it is suitable to use mutation faults to evaluate regression te sting techniques.
recently zhang et al.
showed that mutatio n faults can be used to simulate the impacts of real faults.
thu s more and more software testing techniques are evaluated usi ng mutation faults .
currently testing techniques are mainly evaluated using an arbitrary set of mutant s due to the large number of mutants.
our study establishes rul es for evaluating testing techniques if technique toutperforms technique t on sampled mutants we can predict with high confidence that tis better than t on all mutants.
v. c onclusions and future work this paper reports an empirical study to answer an important question for selective mutation testing can random mutant sampling be applied on top of operator based mutant selecti on to further reduce the cost of mutation testing?
we evaluate that question for various sampling strategies for adequat e and non adequate test suites and on real world java program s. surprisingly the empirical results show that sampling onl y of mutants generated by operator based selection can still provide a highly precise mutation score.
in addition the study shows that our newly proposed random mutant sampling strategies based on program elements can be more effective than strategies based on mutation operators.
furthermore the study shows that mutant sampling is more beneficial for large r programs indicating a promising future for applying mutan t sampling to larger projects.
in the future we plan to consider more sophisticated mutant sampling based on dynamic test behavior e.g.
we may sample more mutants on some critical paths or on combinations of random mutant sampling and search based mutant selection.