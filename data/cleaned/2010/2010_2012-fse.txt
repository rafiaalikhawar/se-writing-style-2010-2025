history slicing assisting code evolution tasks francisco servant department of informatics university of california irvine irvine ca u.s.a. fservant ics.uci.edujames a. jones department of informatics university of california irvine irvine ca u.s.a. jajones ics.uci.edu abstract many software engineering tasks require developers to understand the history and evolution of source code.
however today s software development techniques and tools are not well suited for the easy and e cient procurement of such information.
in this paper we present an approach called history slicing that can automatically identify a minimal number of code modifications across any number of revisions for any arbitrary segment of source code at fine granularity.
we also present our implementation of history slicing chronos that includes a novel visualization of the entire evolution for the code of interest.
we provide two experiments one experiment automatically computes history slices to determine the benefit brought by various levels of automation and another experiment that assesses the practical implications of history slicing for actual developers using the technique for actual software maintenance tasks that involve code evolution.
the experiments show that history slicing o ered drastic improvements over the conventional techniques in three ways the amount of information needed to be examined and traced by developers was reduced by up to three orders of magnitude the correctness of developers attempting to solve softwaremaintenance tasks was more than doubled and the time to completion of these software maintenance tasks was almost halved.
categories and subject descriptors.
d. .
software engineering distribution maintenance and enhancement version control d. .
management software configuration management keywords.
mining software repositories program comprehension software evolution software visualization .
introduction software developers frequently face hard to answer questions about source code.
a study by latoza et al.
found that answering questions about rationale is a serious problem for developers.
additionally ko et al.
found that questions about why code had been implemented in a certain way were among the most time consuming to answer.
a di erent study by latoza and myers found that some of the hard to answer questions seek knowledge about the history of code like when how by whom and why some code was changed or inserted.
answering questions about the history of source code also serves as a strategy for understanding rationale because it potentially provides context and motivation.
given the frequency and di culty of such tasks mechanisms that e ciently support them can significantly and positively a ect software developer performance.
existing software configuration management scm systems such as cvs subversion and git allow users to track and query revisions and investigate di erences per file.
however studies have found that developer tasks require information about the history at the level of a block of code and that developers require information about a series of changes .
to address this need existing scm systems provide features such as annotate that allow a developer to view for each line of a file the last revision in which it was modified.
such features address the need for line level querying but do not enable for e cient inspection of a sequence of changes for an arbitrary block of code.
while such querying can be performed with these tools they require significant manual e ort by the developer to track a line of interest track and query each of its past revisions and then to repeat and synthesize the results for each line of interest.
to better support such querying and exploration of the evolution of source code we created a technique called history slicing that automatically tracks the lineage of each line of code in an scm system and e ciently enables developer querying and exploration of such evolution.
the history slice for a set of lines of code of interest i.e.
slicing criterion contains all their corresponding lines of code in all past revisions of the software project in which they were modified.
the goal of a history slice is to provide a reduced amount of information about the history of a set of lines of code.
in the same way that program slicing selects the relevant areas of the code in the dimension of space history slicing selects both the relevant revisions of the code in the dimension of time and the appropriate lines of code in each of those revisions in the dimension of space.
history slicing addresses the limitations of traditional scm systems by providing the ability to query at the line level any arbitrary set of lines across any set of files and view the minimum complete evolution of those lines along acm .
this is the author s version of the work.
it is posted here for your personal use.
the definitive version of record was published as francisco servant and james a. jones.
.
history slicing assisting code evolution tasks.
in proceedings of the acm sigsoft 20th international symposium on the foundations of software engineering fse .
association for computing machinery new york ny usa article .
their tracing among revisions.
a third emergent benefit of such a technique is that the results reveal interesting patterns that indicate characteristics of the code evolution that were previously obscured such as co evolution of two method bodies .
in this paper we provide three main contributions a detailed description of the concept of history slicing which enables developers to generate a history slice for any arbitrary set of lines of code i.e.
contiguous or fragmented and in a single file or across any number of files .
we provide a definition of history slicing a detailed description of how history slicing is performed with today s scm systems and summarize our approach to automating it.
a description of chronos our implementation of history slicing which includes the model generation analysis and a novel user interface that provides a visualization of any history slice that may include many files and revisions.
the visualization also supports developers to visually recognize patterns in the evolution of the code.
an extensive evaluation consisting of two experiments.
the first experiment involves the computation of history slicing tasks to evaluate the degree to which our technique may alleviate the information overload that would be present with existing tools.
the second experiment is a user study of actual developers and includes history slicing tasks to evaluate the real world impact of our technique.
.
motivation a study by latoza et al.
observed developers at their workplace and found that they frequently ask questions about the history of source code.
they also found that developers wanted to know both the latest changes and the entire history at the level of a code snippet.
in addition two di erent studies by latoza et al.
and ko et al.
found that developers often asked questions about why a snippet of source code had been implemented in a specific way.
they also found that resolving such questions about the rationale of source code was highly time consuming.
methods that can provide the code s creation and evolutionary history may help developers to understand such design rationale motivations and the context in which they were made.
the exploration of the entire history of a set of lines of code can be applied in a wide variety of scenarios.
consider an example scenario in which a developer wants to find an earlier implementation of a specific piece of code for example a loop body.
in this example situation our developer implemented multiple versions of the functionality performed by that loop throughout the history of the project.
at some point she realizes that a specific earlier implementation better suits the needs of the program but she can t remember which revision contains the desired implementation.
in this situation finding which revisions contain changes for that specific loop body and the corresponding lines to that piece of code in each of those revisions can be a tedious task if performed with today s scm tools unless log messages were quite explicit and detailed and even still there would likely be an overabundance of log messages to read to find the specific revision .
in another example scenario a project manager may needto know all of the developers who ever modified a specific segment of the source code for example two methods that interact to form a specific functionality.
latoza et al.
found that developers asked questions about the authorship of code and their teammates and a number of researchers proposed approaches for mapping expert developers to components of source code .
however if a developer wanted to perform a detailed exploration through the history of when how and why each developer made changes to that segment of the source code she would again need to perform a tedious task with today s scm tools.
in a final example scenario developers may want to explore the parallel history of multiple segments of source code in order to find out whether and when they were modified together.
zimmermann et al.
found that multiple software artifacts being committed together to the source code repository is a signal of these entities being dependent on each other.
this dependency is the definition for evolutionary coupling .
another motivation for tracking commits across multiple arbitrary segments of code is to help assess code clone risks.
bakota found that segments of code that are identified as code clones often were modified together and that violations of this pattern can indicate possible problems.
in each of these cases extracting and presenting a detailed exploration of the history of two pieces of code for example two small methods in two large files would be a highly repetitive and time consuming task if performed with today s scm tools.
a common characteristic of each of these three scenarios is that they are di cult to answer with today s scm tools for three reasons they require deep exploration of the history i.e.
not simply a pairwise di they require the exploration of multiple sets of lines of code potentially across multiple files and they require the recognition of patterns and characteristics across potentially long epochs of the projects life.
we posit that a technique that can automatically address and assist with these three code evolution task characteristics can benefit developers attempting to solve such tasks.
we conjecture that for all three of these scenarios developers often give up on answering such code evolution questions.
that is because these tasks are exorbitantly time consuming to perform with today s scm tools the possibility for successfully and accurately answering them is considered infeasible.
in this paper we first present history slicing as a means to assist such code evolution tasks and secondly study whether and how e ciently history slicing allows their performance.
.
slicing of history history slicing models the process that developers have to follow in order to obtain the whole history of a set of lines of code.
to display a real world example figure 1represents the whole history of lines up to revision .
of file ajbuildmanager.java of the aspectj open source project.
source code files are normally committed multiple times generating multiple revisions.
however not all revisions contain changes to all lines of code.
in our example out of a total of revisions for file ajbuildmanager.java only revisions .
.
.
.
and .
contain changes to the lines of interest.
we define lines of interest as the lines of code whose history a developer wants to explore.
each line of interest will940 if environment null... list cps buildcon.. dump.savefullcla... string classpaths... for int i i cp... classpaths str... environment new... state.setnameenv... list cps buildcon... dump.savefullcla... string classpaths... for int i i cp... classpaths str... list cps buildcon... string classpaths... for int i i cp... classpaths str... rv1.156rv1.134rv1.60rv1.14rv1.1newestversionoldestversiontime dimension if environment null... list cps buildcon... dump.savefullcla... string classpaths... for int i i cp... classpaths str... environment new... state.setnameenv... else statefulnameenv... state.deltaaddedc... if environment null... list string cps ... dump.savefullcla... string classpaths... for int i i cp... classpaths cps... environment new... state.setnameenv... else statefulnameenv... state.deltaaddedc... rv1.162space dimension figure real world example of the history of a set of lines of code.
also be characterized by the revision of interest of the file of interest inside which it is contained.
these lines of interest may be few e.g.
a single line or a basic block of code or numerous e.g.
a method or class contiguous e.g.
a method or fragmented e.g.
a dynamic slice and within a single file e.g.
a method or across multiple files e.g.
a test case s statement coverage set .
such sets of lines of interest are akin to a slicing criterion for program slicing.
we also define snapshot as the set of lines of code in a particular version that correlate either directly or transitively to the original lines of interest i.e.
a snapshot represents a previous state of the lines of interest.
thus the snapshot of lines of interest for revision .
is represented by lines and .
the line numbers of a snapshot are di erent in each revision since an undetermined number of lines will be added and or deleted before and after it.
the product of history slicing is a history slice .
the history slice for a set of lines of interest contains all their snapshots in all the past revisions in which they were modified.
slicing history with today s scm systems is not trivial because they do not provide an automated way of obtaining the whole history of an arbitrary set of lines of code.
instead four subtasks are required .retrieve the previous revision rof a file.
.find inside revision rwhich lines correspond to the lines of interest.
.check the contents of those lines and identify whether they were modified.
.if they were modified save them.
return to step until all history is explored.
depending on their level of expertise with today s scm systems developers may perform these steps by using a fully manual approach or a more advanced conventionally assisted approach as well as a spectrum of approaches in between.
.
manual naive slicing of history we present this approach because it is the most straightforward solution and one that is likely to be employed by more novice developers who are unaware of advanced features of scm systems and because it clearly demonstrates the challenges brought by each of the four subtasks.
to determine the previous revision to the revision of interest step a developer could manually retrieve every individual revision of the file s of interest from the scm system.
of course this requires an exorbitant amount of unnecessary work because only a subset of those revisions contain changes for the lines of interest.
we can say thatthis ine ciency a ects the search in the dimension of time as indicated by the time dimension arrow in figure .
to determine the snapshot in a prior revision step the developer would in the worst case manually inspect the full contents of the files in order to find the position of the snapshot.
if the files are large this step also involves a high amount of unnecessary work.
we can say that this ine ciency a ects the search in the dimension of space as indicated by the space dimension arrow in figure .
to determine whether there are changes in the snapshot step the developer would compare each pair of snapshots.
this comparison may not be straightforward when the snapshots are large disjoint or contain subtle and hardto notice changes.
finally to keep track of the entire history of the lines of interest step the developer would need to keep a log of all the snapshots for all the files.
this log could be kept in a text editor requiring application and context switching and thereby imposing an additional overhead on the process.
for all of these reasons following such a naive approach can be extremely time consuming.
we want to point out that while this manual approach may often be an unrealistic scenario developers are likely to follow it in cases when they don t have much expertise with scm systems or in cases where the task only involves a few changes in a few lines in a single file.
nonetheless we present the manual approach mostly for illustrative purposes.
.
conventionally assisted slicing of history developers may use capabilities of scm systems to support the previously mentioned four steps for slicing history.
in order to determine the previous modified revision step the developer can utilize the annotate blame feature on the revision of interest.
annotate will return for every line in the file the latest revision to modify it.
then the developer would need to manually find the snapshot inside annotate s output.
since annotate will return di erent last revision for di erent lines the developer would select the most recent highest revision rin which any of the lines in the snapshot was modified.
this automation would resolve the ine ciency in the dimension of time of the manual approach.
to find the snapshot inside revision r step the developer may use the ctrl f functionality in a text editor with the contents of the revision in order to navigate to the area of the file that contains the snapshot.
however this option might still involve multiple attempts.
since developers would be searching in an older revision they might be searching for words that were di erent then.
another short .
build history graphscm system2.
select slicing criterion3.
traverse history graph4.
represent history slicehistory graphslicing criterionmarked history graphhistory slicedeveloper or automated analyses figure approach to automatically compute history slices.
cut for this step would be to run di overrandr but the developer would still have to manually inspect the contents of its output.
additionally for both ctrl f anddi i n the case of fragmented snapshots each line of the snapshot would have to be found individually and manually.
while this automation mitigates the ine ciency in the dimension ofspace of the manual approach it is hard to predict by how much.
in a worst case scenario the developer would still need to inspect the full contents of the file.
determining whether the snapshots are di erent step will be straight forward since annotate will directly point developers to only those revisions which do contain changes to the snapshot.
however some degree of ine ciency would be introduced in this step if the specific implementation of annotate detects false modifications such as modifications in white space.
in such case developers would have to inspect some unnecessary revisions.
keeping track of the history slice step is still performed exactly as in the manual approach.
in summary this approach assists the process of finding the history of a set of lines of code.
however despite some automation it is still a highly manual process of performing multiple commands and correlating and interpreting their output.
in the extreme case where the lines of interest are fragmented and scattered among multiple files this process can be extremely time consuming even with such assistance.
.
automation of history slicing our approach to automating history slicing involves multiple steps each of which can be parameterized in a number of ways.
the overall process is depicted in figure .
step build history graph.
in the first step we create a history graph which contains the history of each line of code.
a history graph is a multipartite graph where each part represents a revision of a file.
inside a part each node represents a line of code in that revision.
each node is linked to only one node in the previous part and or only one node in the following part.
additionally each node can be labeled to store additional metadata such as authorship time stamps and log messages.
figure 3shows a simple example of a history graph.
in this figure each node contains a label which describes the operation that produced each line in each revision.
in general history graphs are similar to annotation graphs .
unlike the modification hunk granularity of annotation graphs history graphs require a one to one node mapping between revisions.
the links between nodes are assigned by applying a linemapping i.e.
fine grained program di erencing technique.
because existing line mapping techniques vary in their power and flexibility our framework allows the choice of line mapaucuauuauda addedu unchangedc changedd deletedauucrv1.1rv1.2rv1.3rv1.4figure history graph.
ping to be customized according to the tasks at hand.
for example a simple plain text di erencing technique may be desirable if following the history of non executable code such as comments or xml metadata.
alternatively a differencing technique based on the abstract syntax tree may be desirable to track changes that change the structure of the executable code.
once the history graph is built it can be used for the computation of any history slice.
building the history graph is a one time expense and as the code history grows it can be extended with minimal e ort.
step select slicing criterion.
in the second step of our approach we need to select a slicing criterion which contains a set of lines of interest from a specific revision of a program.
the slicing criterion may contain any set of lines of code contiguous or fragmented from any file and revision or combination of files and revisions.
this freedom is provided as a result of the fine grain in which the history graph stores the evolution of the source code.
step traverse history graph.
in the third step the approach traverses the history graph starting from the nodes that represent the slicing criterion.
in this traversal the approach visits all the nodes included in the history path of all the lines of code in the slicing criterion.
a history path for a line of code includes all the changes to it from the moment that it was initially conceived until it is deleted or is part of the newest revision of the file.
in the process of traversing a history path nodes are marked for inclusion into the slice according to the choice of a minimal history slice visited modified nodes or extended history slice visited modified and unmodified nodes for all revisions in which there is at least one modified node .
marked nodes will be considered as part of the final history slice.
step represent history slice.
the fourth and final step of our approach is the visualization of the history slice.
this step is also performed di erently depending on the task being solved.
some scenarios will require minimal information such as statistics on the number of changes made on a set of lines while other scenarios will require more context and therefore will need to display the history slice together with the lines that surround the snapshots.
in summary all four steps can be performed in multiple ways.
the decision about how to implement each of them will be influenced by the intended use of the history slice.
this decision will also a ect the contents of the computed history slice.
in any case a history slice will contain a minimal but complete amount of information about the history of a set of lines of code.
.chronos in order to facilitate experimentation we instantiated the automated history slicing framework that we described in section 4in a tool chronos .
for each step of the framework we describe the choices made in its implementation.step build history graph.
we implemented a component of chronos that queries an scm system and builds a history graph.
this component first obtains the list of all files stored in the repository.
next for each file it queries its list of revisions.
then for each revision it retrieves its contents as well as its di with the previous revision.
for each line of code for a particular revision it creates a node.
the final step for the graph builder is to create the correlation edges between consecutive revisions.
this step requires a line mapping technique .
we incorporated many of the lessons and methods of such techniques to form our own line mapping technique.
in the same way as chen et al.
our technique performs a first phase that utilizes the scm system s di functionality to determine added deleted and changed individual lines and labels their nodes as such and for those lines that di marks as blocks of changes i.e.
modification hunks a second phase is utilized to provide a line to line mapping.
much like williams and spacco we used the kuhn munkres combinatorial optimization algorithm coupled with a computed levenshtein distance to compute an optimal mapping among lines in such change blocks.
the final result of graph building component is a history graph that contains the complete history of any line of the project.
the graph is stored in a relational database that can be queried both directly and through a supporting api.
step select slicing criterion.
we implemented the slicing criterion selector as an eclipse plugin.
a developer can open any revision of any file select any set of lines and right click to reveal a contextual menu that includes an option to add to history slicing criterion.
as such any set of lines contiguous or fragmented across any number of files or revisions can be added to the slicing criterion.
step traverse history graph.
once the history graph is built step and the slicing criterion has been specified step the history slice can be computed.
the history slicer component is initiated through the eclipse plugin or alternatively through the api .
the history slicer interacts with the relational database that contains the history graph through sql queries.
the history slicer traverses the history graph from the most recent revision of each line in the slicing criterion and traces their evolution going backward in time.
each revision that contains changes is recorded and the snapshot at that revision captured.
step represent history slice.
with the history slice computed it can be presented to the developers for them to explore and interpret.
for this component we implemented an interactive visualization of the history slice.
the visualization is a zoom able canvas that depicts all snapshots for all lines in the slicing criterion with mappings between them.
in addition timelines are presented to show proportionally in time when changes were made.
figure 4is a screenshot of the history slice visualization inchronos .
the history slice that is being visualized was computed from a slicing criterion that spanned two files.
the top two gray bars labeled as 1in the figure represent a global display of the timelines for these two files.
just above them a gray ruler marks the months that the timelines encompass.
inside each of these timelines each blue mark represents a revision of that file that includes changes relevant to the original slicing criterion at the position in the timeline that represents the time of the revision.the top two timelines are placed adjacent to allow the user to view correlations between changes and their times and thus potentially recognize patterns.
in contrast the timelines are repeated below labeled 2and with call out lines for each modification revision that lead to the full source code of the snapshot.
each snapshot is colored to indicate which lines in the snapshot were modified in that revision blue lines were changed in that revision and gray lines stayed unchanged.
in addition each snapshot is annotated with metadata such as the revision number date and author colored in green.
the entire visualization is zoom able and pan able allowing the user to both see a high level view of all changes and revisions and to potentially recognize patterns in the changes and to inspect and explore the fine details of what was changed and when.
we depict a zoomed in screenshot in the overlaid call out labeled .
.
evaluation utilizing chronos we conducted two experiments to determine the merits of automating the slicing of history.
the first experiment involves the construction of history slices using various levels of automation.
the goal of the first experiment is to determine the degree to which extraneous information can be minimized by the use of historyslicing automation.
the second experiment involves the study of developers that use tools that provide di erent levels of automation assistance for history slicing.
the goal of the second experiment is to determine the practical benefits brought to actual developers for performing actual code evolution tasks.
to evaluate the e ectiveness of history slicing we define the following research questions rq1 how much does the automation of history slicing reduce the problem space in terms of the total number of lines of code needing to be examined?
rq2 how much does the size of the slicing criterion a ect the problem space reduction in both the time and space dimensions ?
rq3 what is its practical benefit to developers performing code evolution tasks?
in both experiments we use the aspectj open source project as the code base on which we perform history slicing.
aspectj is an aspect oriented extension to the java programming language.
it consists of over lines of code and has been in active development for more than eight years.
.
experiment to answer research questions rq1 and rq2 we randomly produced slicing criteria at each of four sizes and computed their history slices using four parameterizations of the history slicing approach discussed in sections 3and4 for a total of di erent slicing criteria and computed history slices.
the goal of computing history slices with four parameterizations of the history slicing approach is to approximate the benefits brought by the range of conventional tools and our automated history slicing approach research question rq1 .
the goal of computing history slices with four di erently sized slicing criteria was to determine how the size of the slicing criteria a ects the degree of benefit from automation research question rq2 .
figure visualization of a history slice.
chronos allows zooming at any level over any area of the visualization.
.
.
experimental variables we experimented using two independent variables technique treatments and slicing criteria size and evaluated their benefit using three dependent variables number of revisions average number of lines and total number of lines.
each variable will be defined and motivated in turn.
independent variable technique treatment.
in order to determine the degree to which the automation of history slicing can reduce the problem space for code evolution tasks rq1 we parameterized its computation in the following four ways treatment naive.
every revision is examined to determine where and if any changes were made that are relevant to the slicing criterion.
this parameterization approximates the effort that would be necessary without any automation at all and is presented as a baseline.
treatment conventionally assisted.
only the revisions required by the annotate tool are examined and the snapshots are found without assistance.
for fragmented slicing criteria such as a dynamic program slice each line would be found individually and manually.
then we consider that all lines in each identified revision are manually inspected.
treatment history slicing with context.
only the revisions identified by the automated history slicing approach are examined and only the lines inside the snapshots are examined.
in each such revision at least one line changed in the history of the slicing criterion.
in addition all lines that have an evolutionary relationship with the slicing criterion are included as context to provide a full view of each snapshot at each relevant revision.
treatment history slicing without context.
only the revisions identified by the history slicing approach are examined and only the lines that changed in the snapshot are examined.
for this treatment the unchanged yet correlated code is omitted.
such a technique may be useful for subsequent automated analyses that utilize the output of history slicing.
independent variable slicing criterion size.
in order to determine the degree to which the initial slicing criterion size a ects the problem space reduction we varied the sizes of our randomly generated slicing criteria as such size .
as e to f1 0r a n d o m l yg e n e r a t e dc o n t i g u o u sl i n e so fc o d e .
this size was chosen to approximate the size of a block of code e.g.
an ifblock .
size .
as e to f2 0r a n d o m l yg e n e r a t e dc o n t i g u o u sl i n e so f code.
this size was chosen to approximate the size of a small method or function.
size .
as e to f5 0r a n d o m l yg e n e r a t e dc o n t i g u o u sl i n e so fc o d e .
this size was chosen to approximate the size of a large method or a small class.fragmented.
ap o t e n t i a l l yf r a g m e n t e ds e to fv a r y i n gn u m b e r s of lines of code.
in order to select a fragmented non contiguous set of lines of code we selected the lines executed by a test case inside a file.
we randomly chose a test case generated its statement coverage randomly chose one of the files that it executed and selected the lines executed in it as the fragmented slicing criterion.
dependent variables.
to assess the problem space size for a developer or an automated client analysis in interpreting a history slice we define the following three dependent variables number of revisions.
the number of revisions in the history of the slicing criterion that need to be examined.
average number of lines for a revision.
the average number of lines of code that a developer would need to inspect in each revision.
this is computed as the average number of lines for any given revision inside the history slice aggregated across all relevant revisions according to the treatment technique.
total number of lines for a task.
the total number of lines of code that a developer would need to examine across all relevant revisions.
this is computed as the sum of all examined lines across all relevant revisions according to the treatment technique.
this serves as a proxy measure of the total amount of work that a developer would need to expend to fully explore and process the history slice.
.
.
experiment design for each slicing criterion size i.e.
independent variable we randomly generated slicing criteria.
although history slicing is generalizable to criteria that span multiple files for this experiment each individual criterion is contained in a single file for the continuity requirement of criterion size and to limit the size of the fragmented criterion.
also we discarded and replaced randomly generated criteria that resulted in no history that is the code in the slicing criteria had no previous revisions.
in such cases we viewed the prospect of exploring history unnecessary and fruitless.
then for each slicing criteria and treatment technique we used chronos to generate the resulting history slice.
the resulting history slice was used to compute the resulting dependent variable metrics to determine the problem space costs.
.
.
results after computing the values of the dependent variables for each combination of slicing criterion size and treatment technique we averaged them and obtained the results displayed in table .table results for experiment slicing crit.
sizeapproach avg.
revisionsavg.
linesavg.
total lines naive .
.
.
conventional .
.
.
h.s.
w context .
.
.
h.s.
w o context .
.
.
naive .
.
.
conventional .
.
.
h.s.
w context .
.
.
h.s.
w o context .
.
.
naive .
.
.
conventional .
.
.
h.s.
w context .
.
.
h.s.
w o context .
.
.
fragm.
naive .
.
.
fragm.
conventional .
.
.
fragm.
h.s.
w context .
.
.
fragm.
h.s.
w o context .
.
.
from table we focus on the value of the total lines variable as this is a proxy measure of the amount of work required by the developer in processing the history slice and plot it in figure .
the value of this variable represents the size of the problem space when a developer searches for the history of each slicing criterion by following each approach.
for example when a developer tries to find the history of contiguous lines of code in a file in the aspectj project by manually inspecting each revision of the file she will have to search inside an average problem space of lines of code.
such scenarios are likely unrealistic as any developer would likely give up very quickly after starting the naive approach.
we do not expect developers to actually follow this approach we present it to demonstrate the size of the original problem space.
the current practice is probably to use tool supported approaches like conventionally assisted which reduces the problem space by one order of magnitude.
for a slicing criterion of lines developers face an average problem space of lines of code.
the reduction of the problem space provided by the conventionally assisted approach result from the savings in the dimension of time i.e.
fewer revisions .
however developers still may need to inspect many lines of each revision i.e.
the space dimension in order to correlate each line of each snapshot with their corresponding earlier and later versions.
the history slicing with context approach also provides another reduction of one order of magnitude in the problem space over the conventionally assisted approach.
for a slicing criterion of lines the average problem space is reduced to lines of code.
this approach provides savings in both the dimensions of time and space because it reduces the number of revisions that need to be inspected and the number of lines that need to be inspected inside each revision.
finally the history slicing without context approach also provides yet another reduction of one order of magnitude over the history slicing with context approach.
for a slicing criterion of lines the average problem space gets reduced to lines of code.
in this case the full problem space represents the solution that developers are looking for if they are interested in a minimal history slice i.e.
only the lines of the snapshots that actually changed.
this approach pro figure average total number of lines to be examined by a developer using each treatment technique.
chronos automated history slice hs drastically reduces the expense for a developer.
note that the columns representing the naive approach far exceed the bounds of the chart.
vides further savings because it further reduces the number of lines that need to be inspected inside each revision.
in summary from experiment we observed a savings of needed developer e ort of an order of magnitude as measured by the cumulative number of lines of code needed to be examined and processed for each additional level of automation.
in all the full history slicing without context approach reduced the problem space by three orders of magnitude over the naive approach.
.
experiment whereas experiment demonstrates the quantitative benefits of automating history slicing through the computation of a large number of slices experiment is designed to assess how these benefits translate to actual use by real developers seeking to solve real code evolution tasks i.e.
research question rq3 .
as such experiment is a comparative study of users using a conventionally assisted approach and chronos .
.
.
experimental variables we experimented using two independent variables treatment technique and code evolution task and evaluated their benefit using two dependent variables time to task completion andtask success .
in addition we controlled for two variables user subject skill andtask order .
each variable will be defined and motivated in turn.
independent variable technique treatment.
we varied the technique that the subjects used to solve a codeevolution task.
the two techniques were treatment conventionally assisted.
we selected this technique as it is the one currently employed by developers.
for the conventionally assisted approach we used eclipse s default cvs plugin which is a widely used graphical user interface for cvs an industry standard revision control system.
the plugin enables an easy and automated use of the annotate feature the user can select a file and through a context menu choose to see the last revision in which each of its lines was changed.
it also provides implementations of the ctrl f anddi features.table number of subjects with nyears of experience with ides and revision control systems.
tool ides revision control treatment history slicing with context.
our automated implementation of history slicing chronos i m p l e m e n t e d as an eclipse plugin along with its visualization presented in section .
we chose to represent history slices with context given that they were going to be consumed by humans as opposed to history slices without context which we envision being used as input for other analysis techniques.
independent variable code evolution task.
we varied the code evolution task that the subjects were asked to solve.
the three tasks were task authorship.
our user subjects were asked to identify the complete set of developers who had ever contributed changes to a segment of code.
this task reflects the real task demand of determining authorship and expertise discussed in section .
task original revision.
our user subjects were asked to identify the original revisions in which a segment of code was originally created.
this task reflects the real task demand of determining an earlier implementation of a given functionality discussed in section .
task co evolution.
our user subjects were asked to identify the revisions in which two segments of code in two different files were changed within a day of each other.
this task reflects the real task demand of determining evolutionary coupling for identifying related code or code clone risk discussed in section .
dependent variables.
to assess the benefits of automated history slicing to actual developers rq3 we define two dependent variables time to task completion.
the time that the subject needed to perform a task.
the time is determined by when the subject decides that they are confident and satisfied with their result.
task success.
the correctness of the answer given by the subject.
we precomputed the correct answer for each task in advance and were able to determine whether the answer supplied by the subject matched it.
controlled variables.
to control for the e ects of outside influences we vary the following two variables subject skill.
we studied sub jects of varying levels of experience with programming in integrated development environments ides and revision control systems.
the number of years of experience with each of these is presented in table task order.
we varied the order in which the sub jects used each technique.
half of the subjects used treatment first and treatment second and vice versa .
.
.
experiment design we recruited subjects four our user study.
we required subjects to have knowledge about both java and revision control systems.
to ensure such knowledge we asked subjects to fill in an online questionnaire in order to sign up for our study.
we used the information in this questionnaire to screen subjects according to our requirements and to capture the demographics of our population.
twenty two of our subjects were male and two were female.
twenty three subjects fell in the age group and one of them fell in the age group .
all our subjects were graduate students at uci two of them were also professional software developerstable time to task completion and success rate for each technique and task.
technique task avg.
time success conventional task .
history slicing task conventional task .
history slicing task conventional task history slicing task .
and one was also a professional software tester.
thirteen subjects were majoring in informatics ten were majoring in computer science and one was majoring in computer engineering.
table 2contains the years of experience that subjects reported to have with ides and revision control systems.
the experiment was structured as such for each subject .we trained the subject on how to use the chosen treatment technique.
.we presented the subject with the randomly chosen task and the source on which it will be performed.
.we asked the subject to answer the chosen task.
.we repeated steps for the other treatment technique and another randomly chosen task.
each subject was asked to perform two tasks with two techniques.
twelve of the subjects used the conventionally assisted approach first and the history slicing with context approach second and other twelve used the tools in the opposite order.
each of the three tasks was assigned to an equal number of subjects and each technique was used on each task in equal numbers i.e.
each task was answered with each tool eight times.
in other words every combination of treatment techniques task and task order was performed in equal numbers.
to encourage subject participation we o ered a small base monetary compensation.
additionally we o ered a small additional compensation to encourage speed and correctness.
the subjects were given a maximum of ten minutes to answer each task that they were given regardless of the treatment technique.
a correct answer was rewarded with a small additional compensation and the earlier that the answer was given determined the size of that small additional compensation.
for example a correct answer given at minute was rewarded more greatly than a correct answer given at minute .
this compensation structure was implemented equally for both techniques to encourage the subjects to answer quickly and accurately.
.
.
results for each technique task combination we averaged the time that all subjects took to perform the task and we calculated the percentage of subjects whose answer was correct.
table contains the results that we obtained for all technique task combinations.
as we can see in this table the subjects who used the history slicing with context technique could perform any of the tasks in around half the time that was needed by the subjects who used the conventionally assisted technique.
we performed a paired t test with degrees of freedom over the times that we captured for subjects performing the tasks.
the di erence in time needed to perform the tasks for the two di erent techniques was statistically significant withpvalues of .
.
and .
for tasks and respectively.
in the specific case of task the di erences in time are so high because most subjects using the conventionally assisted technique for task were unable to answer it in the maximum ten minutes allotted.
only two subjects provided an incomplete incorrect answer when they had seconds and seconds left respectively.
in a post experiment discussion some of the subjects mentioned that in real life they would have just given up on performing task before spending ten minutes on it by using the conventionally assisted technique.
regarding success rate the subjects who used the history slicing with context technique were in general .
more likely to provide correct solutions to any of the tasks than those subjects who used the conventionally assisted technique.
we also performed a paired t test with degrees of freedom over the correctness of the answers provided by our subjects.
the di erence in correctness of the answers for the two di erent techniques was also statistically significant with a pvalue of .
for each task.
we observed multiple reasons why our subjects did not provide a correct answer for each question when using the conventionally assisted technique.
for task some subjects only reported information about the last change to each line of interest instead of their whole history some other subjects only reported information about the header of the method of interest instead of all its lines and another subject checked all revisions of the file one by one manually checking which revisions a ected the lines of interest and ending up providing a partial answer.
for task some subjects interpreted changes in lines as additions and other subjects ran out of time.
for task all subjects ran out of time long before even composing a small portion of the correct answer.
we also observed a common phenomenon to all tasks when using the conventionally assisted technique subjects very frequently lost track of where in the file they were and they needed to backstep to remind and re focus their search.
when subjects used the history slicing with context technique they only provided incorrect answers for task that is for tasks and allof our subjects provided the correct answer and a majority of the subjects provided correct answers to task despite zero success for the other technique .
for the .
that incorrectly answered task with history slicing we observed the following reasons for their failure one subject did not explore the beginning of the timeline missing the first revision.
another subject rushed and explored only the latter half of the timeline.
another subject only explored a small subset of the timeline because she thought that her partial view was complete the zooming function did not refresh the image until the button of the mouse was released causing her to think that her zoomed in view contained the whole timeline.
.
summary of results considering the results from both experiment and we now answer our research questions specified in section .
to research question rq1 we assess that automating the computation of history slices greatly reduced the problem space needed to be examined by the developer.
experiment confirmed this and found multiple orders of magnitude in savings by automating the history slice computation.to research question rq2 we assess that the size of the slicing criterion did indeed a ect these reductions the larger the slicing criterion the larger the cost in its computation.
however the cost increases are minimal especially when considering the automated approaches.
also the fragmentation of the slicing criterion does not a ect the cost.
to research questions rq3 we assess that the practical benefits of the automated history slicing had profound influence on both the speed and correctness of the users attempting to solve the code evolution tasks.
the users o ered their answers significantly more quickly with chronos and even so their answers were correct significantly more often.
overall we find these results as strong evidence that the task of computing history slices is a non trivial task for developers to compute on their own with current toolkits.
.
threats to validity an external threat to the validity of our evaluation is that our results may not hold for other codebases or users.
despite the fact that we studied only one codebase aspectj we do not consider this a significant threat.
the main factors that a ect history slicing are the codebase s age and the size of the slicing criterion regardless of the nature or functionality of the codebase.
we experimented with the size of the slicing criterion and found an e ect that easily scales with criteria size.
and given the random selection of slicing criteria history slices were computed on files that were brand new as well as other files that were nearly a decade old.
regardless of the age of the code sliced chronos computed quickly the maximum was seconds in our unoptimized tool .
moreover older codebases and larger criteria will likely a ect the conventional scm approaches much more than the automated history slicing technique.
another external threat to validity is that our user study in experiment does not study people who are already familiar with the code base and thus its results may not generalize to such more experienced developers.
however we believe this factor to be insignificant because the same experience level was brought to both approaches.
we expect that greater experience would assist the more automated approach because its results require more interpretation and application of experience whereas the manual approach requires more tedium.
nevertheless in the future we plan to evaluate with in vivo field studies.
an internal threat to validity is that chronos our implementation of history slicing uses a textual line mapping technique which may not always identify the correct line equivalence in between revisions e.g.
when a method is moved to another file.
however this limitation a ects both chronos and the manual approaches to history slicing since traditional scm tools do not provide any mechanism for tracking movements of code in between files.
as a consequence we believe that this limitation does not a ect the results of our experiments.
moreover history slicing may address this limitation because its approach allows other line mapping techniques .
a threat to construct validity is that in experiment we measured developer expense in terms of the number of lines that need to be examined.
while we use the metric of the number of lines to be examined as a proxy measure for developer e ort we posit that it is actually indicative of the amount of e ort that would be needed by a developer more lines will require the developer to inspect thoselines leading to greater e ort.
regardless while experiment allowed us to compute a great number of history slices we intentionally conducted experiment to allow us to determine if the proxy measure of e ort manifests for real developers on real code evolution tasks.
.
related work existing research into analyzing and presenting code history follows two general directions that we will describe here analyses to trace history through revisions and user interfaces to access these histories.
girba et al.
presented an evolution meta model to represent the history of source code artifacts at multiple levels of granularity e.g.
class method attribute .
to model the history of source code at the level of individual lines of code zimmermann et al.
proposed annotation graphs.
while similar to the history graphs defined herein blocks of changed code i.e.
modification hunks are undi erentiated in their historical evolution due to the limited granularity offered by di on which they are built.
to address the problem of modification hunks multiple researchers proposed line mapping techniques.
canfora et al.
first perform an inexact di erence like the annotation graph approach and then further refine blocks of code using a distancing algorithm among the constituent lines.
chen et al.
and williams and spacco propose a similar approach using a combinatorial optimization algorithm to refine blocks.
reiss proposed a set of line mapping techniques and performed an empirical comparison of them.
other researchers proposed more sophisticated algorithms by performing the mapping over models of the program allowing the detection of moved code or providing techniques for specific domains .
in this work we leverage their results to implement our own line mapping technique that incorporates aspects drawn from each.
moreover the concept of history slicing applies to any line mapping technique.
to provide interfaces to code history some authors presented visualizations of the evolution of code at the system level .
at the file level industry standard scm systems provide functionalities that allow for a user to access course grained whole history information such as cvs log or fine grained history information that is limited to a pair of revisions such as svn diff .
in addition they allow for a functionality e.g.
annotate that presents a single revision number for each line of code to represent its most recent change.
such limited functionality leaves much of a traversal of the history e ort to the labor of the developer.
bradley and murphy augment the information presented by such conventional scm tools by making information such as the date and author available for each line of an annotate query.
hassan and holt and holmes and begel propose techniques that provide whole history information but at the level of granularity of a single program method without details for the lines therein.
history slicing in contrast targets a di erent problem allowing a developer to view deep history evolution across any number of revisions for any block of code in any number of files and to be able to draw inferences from the patterns seen.
.
conclusions and future work in this paper we present an approach history slicing for assisting code evolution tasks that involve the exploration ofsource code history.
this approach enables the extraction of all revisions and lines of code that are related to a set of lines of interest.
we define the concept of a history slice as this resulting set of lines across multiple revisions and their mapping between revisions.
history slices can be used to e ciently and accurately solve software maintenance tasks that require knowledge of the code evolution.
history slicing has four key benefits over conventional history exploration tools that are included with scm systems and traditional add on user interfaces to them history slicing can drastically reduce the amount of information that a developer would need to examine in order to trace the history of a set of lines of code history slicing enables the computation and representation of any number of revisions whereas conventional tools primarily perform pairwise di erences history slicing directly supports tracing of the history for any arbitrary set of lines of code regardless of whether they are contiguous or fragmented in a single file or in multiple and in a single revision or across multiple revisions and the presentation of the history slice can enable users to recognize patterns in the evolution and changes to the constituent lines and files.
we present the history slicing approach as a framework of multiple constituent steps each of which are configurable with multiple possible techniques.
we also present our instantiation of this framework to implement our technique in a prototype history slicing tool chronos .
we performed two experiments using chronos t oe v a l uate the merits of history slicing.
the first experiment involved the automatic computation history slices with various levels of automation and various sizes of slicing criteria.
the results of this experiment show that history slicing can drastically reduce the amount of information that a developer would need to examine to trace the history of a set of lines of code.
we found savings of three orders of magnitude in the lines to be examined by the developer for the fully automated history slicing over the baseline.
the second experiment involved actual users performing code evolution tasks to determine the practical benefits of history slicing.
the results of this study show that the reduction of the information that needs to be examined translated to actual benefit to users.
in addition the experiment demonstrated the practical benefits of the ability to represent several revisions in a single view as well as viewing change patterns among code in multiple files.
the users could solve their tasks correctly more than twice as often with history slicing over conventional tools and moreover could give those correct answers in about half the time.
while the results of our experiment are quite positive more experiments are necessary.
we will conduct more experiments using other codebases and user subjects to ensure generalizability.
we will also explore how di erent line mapping techniques a ect our results.
in addition we will explore the tasks that can be assisted by coupling history analyses with traditional program analyses for example viewing the recent history of lines that are identified as faulty according to a fault localization technique.
.