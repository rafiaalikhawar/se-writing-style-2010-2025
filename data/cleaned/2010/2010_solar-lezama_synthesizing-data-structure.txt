mit open access articles synthesizing data structure manipulations from storyboards the mit faculty has made this article openly available.
please share how this access benefits you.
your story matters.
citation rishabh singh and armando solar lezama.
.
synthesizing data structure manipulations from storyboards.
in proceedings of the 19th acm sigsoft symposium and the 13th european conference on foundations of software engineering esec fse .
acm new york ny usa .
as published publisher association for computing machinery acm persistent url version author s final manuscript final author s manuscript post peer review without publisher s formatting or copy editing terms of use creative commons attribution noncommercial share alike .
synthesizing data structure manipulations from storyboards rishabh singh mit csail massachusetts usa rishabh csail.mit.eduarmando solar lezama mit csail massachusetts usa asolar csail.mit.edu abstract we present the storyboard programming framework a new synthesis system designed to help programmers write imperative low level data structure manipulations.
the goal of this system is to bridge the gap between the boxes andarrows diagrams that programmers often use to think about data structure manipulation algorithms and the low level imperative code that implements them.
the system takes as input a set of partial input output examples as well as a description of the high level structure of the desired solution.
from this information it is able to synthesize low level imperative implementations in a matter of minutes.
the framework is based on a new approach for combining constraint based synthesis and abstract interpretationbased shape analysis.
the approach works by encoding both the synthesis and the abstract interpretation problem as a constraint satisfaction problem whose solution de nes the desired low level implementation.
we have used the framework to synthesize several data structure manipulations involving linked lists and binary search trees as well as an insertion operation into an and inverter graph.
categories and subject descriptors d. .
automatic programming i. .
program synthesis keywords program synthesis storyboard programming data structure manipulations .
introduction when implementing complex data structure manipulations programmers must bridge the gulf that separates their intuitive understanding of how the manipulation works from the low level code that actually implements it.
the intuition behind these manipulations often takes the form of boxesand arrows diagrams which programmers might draw on a permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.whiteboard to illustrate the evolution of the data structure as it is manipulated.
unfortunately the visual intuition reected in these diagrams is absent from the low level pointer updates that make up the implementation.
this semantic gap between intuition and implementation makes datastructure manipulations di cult to write and maintain.
to illustrate this gap consider the example in figure .
part a of the gure shows a graphical description of the removal of a node from a doubly linked list.
the diagram we call it a storyboard communicates very clearly the e ect of the manipulation.
by contrast the imperative code in figure b is short but not self explanatory understanding this code essentially requires one to mentally recreate the image from the storyboard in part a .
the system presented in this paper bridges this gap by using constraint based synthesis technology to automatically implement data structure manipulations that are provably correct with respect to highlevel descriptions like the one illustrated by figure .
a graphical intuition b x next prev a next prev next prev next prev b next prev a next prev next prev v b code void dllremove node v f v .
n .
p v .
p v .
p .
n v .
n g figure doubly linked list deletion example our system is not yet a graphical programming system it lacks a graphical user interface but it brings closer to reality the promise of an e ective graphical programming model for data structure manipulations.
it does so by supporting a form of programming by example pbe where the manipulations are synthesized from partial descriptions of their e ects.
the main input to the system is a set of descriptions of the state of a data structure before and after manipulation essentially text descriptions of storyboards like the one in figure .
two important features however distinguish our system from traditional pbe systems.
the rst is the ability to abstract away those parts of the datastructure that are not relevant to the manipulation as is done in figure through the use of ellipsis.
this form of abstraction gives our system a lot of expressive power because it allows a single gure to succinctly describe the behavior of the algorithm on an in nite number of concrete inputs turning a simple input output pair into a partial speci cation.
the second di erence with pbe is that our system asks the user to provide information about the controlow structure of the solution this information reduces the space of possible implementations that the system needs to consider and makes it less likely that the system will produce a solution that only works for the given examples.
these two features allow us to synthesize complex data structure manipulations from relatively simple storyboards.
the system is made possible by a new synthesis algorithm that combines previous work on constraint based synthesis with abstract interpretation.
our algorithm is not the rst to do this but it is the rst to scale to the very large and complex abstract domains required to reason about data structure manipulations.
the key idea behind the algorithm is to use quanti cation to eliminate operations that require complex set based reasoning and to use the sketch solver to solve these formulas section .
the new synthesis algorithm allows us to combine constraintbased synthesis with a form of shape analysis loosely based on tvla .
the shape analysis algorithm used by our system is not as powerful as many of those found in the literature but it is powerful enough to reason about most operations involving trees and lists.
the strength of our particular form of shape analysis however lies in the ease with which we can take the abstractions expressed as part of the storyboard and use them as the basis for an abstract domain that is then used to verify each candidate implementation.
in summary the key contributions of the paper are development of a new model of interaction between the synthesizer and the programmer targeted at the domain of data structure manipulations section .
a novel synthesis algorithm that combines constraintbased synthesis with abstract interpretation to bridge the gap between high level graphical speci cations and their low level implementation section .
the development and evaluation of a tool to automatically synthesize data structure manipulations involving linked lists and trees from high level graphical speci cations section .
so far we have used our system to successfully synthesize several data structure manipulations such as insertion deletion search reversal and rotation operations over singly linked list doubly linked list and binary search tree data structures.
we have also used our framework to synthesize small puzzle problems as well as some manipulations involving a tricky real world and inverter graph datastructure used in the abc solver .
.
overview linked list reversal in this section we present an overview of our framework through a textbook data structure manipulation example in place linked list reversal.
reversing a list with a loop and using only a constant amount of additional memory isnon trivial in fact the algorithm for this manipulation is a common question in technical interviews.
in the remainder of the section we describe how the user describes this data structure manipulation to the framework and provide a high level view of how the synthesizer uses this input to derive an implementation.
.
storyboard in order to synthesize the manipulation our system takes as input a storyboard composed of three elements a set of scenarios each of which corresponds to an abstract inputoutput pair a set of foldand unfold de nitions and a skeleton of the looping structure of the desired algorithm.
a scenario in our system is an input output pair describing the e ect of the manipulation on a potentially abstract data structure where abstraction is used to elide details of the data structure that are not considered relevant.
for example figure below shows the main scenario describing the e ect of reversing a linked list.
like the more informal f emid a b e f mid a bhead next next next next head figure graphical description of linked list reverse example in figure the scenario uses ellipses to abstract away part of the list.
in our notation however the ellipses are formalized by using the concept of summary nodes .
for this example the scenario uses a summary node midto represent the middle part of the list which may vary in size for di erent runs of the algorithm.
out of all the nodes in the sub list represented by mid the rst and last node deserve special attention because other nodes outside the sub list midmay point to them.
we call these special nodes attachment points of the summary node and as we shall see they play an important role in reasoning about scenarios.
figure shows the complete set of scenarios needed for this example including scenarios to describe the behavior of the algorithm on lists of length zero one and two.
figure a presents the text notation used by our system to describe one of the scenarios on the right.
the storyboard consists of an environment description and a sequence of scenario descriptions.
the environment de nes the set of variables used in the implementation the set of elds in the objects that make up the data structure which are called selectors in the shape analysis literature and the set of concrete and summary locations.
for this example there are only four program variables head temp1 temp2 and temp3 one selector corresponding to the eld next and eight concrete locations a f e b f and e .
the concrete locations f and e resp.
f and e represent the two attachment points of the summary node mid resp.
mid .
the environment description also states a global invariant that the next pointers of locations fand f point to midand mid respectively with a value of in a valued logic similar to tvla .
each scenario description in turn uses variable predicates se environment vars node head temp1 temp2 temp3 selectors node node next locations node a f e b f e summary node mid f e mid f e invariant next f mid next f mid scenario input head a vars next a f next e b next b null sels output head b vars next b f next e a next a null sels a a b next head a b head next a head a head head head f e mid a b head next next e f mid a b next next head b figure storyboard for in place linked list reversal lector predicates and data constraint predicates to de ne a pair of input output state con gurations.
the variable predicates of the form var loc denote that variable varpoints to location loc and the selector predicates of the form sel loc loc2 denote that the sel eld of location loc1points to location loc2.
the data constraint predicates de ne additional constraints involving the data values of locations.
in order to make scenarios precise it is often necessary to provide additional information about the structure of summary nodes.
for example in figure the summary node midrepresents a set of nodes with a very particular structure speci cally the scenario only makes sense under the assumption that node eis reachable from node f. our system allows the user to provide this structural information through foldand unfold predicates.
for example figure shows the foldand unfold predicates used to describe the recursive structure of the midsummary node.
the predicates describe the structure of summary nodes in terms of their attachment points in a similar way as fradet et al.
used context free graph grammars to describe shape types.
the exact syntax and semantics of the predicates will be discussed in detail in section .
for now it is enough to understand that the predicates in figure a are precise text representations of the recursive de nitions illustrated in figure b .
for example the unfold rule shows two alternatives for the summary node mid either the attachment points fand eare actually the same node x and this is the only node in mid orfis a node x whose nextpointer points to the attachment point f of another similar summary node mid .
for this example foldis an inverse of unfold and could be derived automatically but section .
will show other examples where it is useful to de ne foldand unfold independently as a way to guide the solver to a speci c solution.
the scenarios and the foldand unfold de nitions together describe the e ects of the desired manipulation but recall that our running example included some non functional requirements such as the requirement that the implementation use of a single loop.
this requirement is expressed by providing a skeleton of the looping structure of the desired algorithm.
figure shows the skeleton for list reverse which states that the implementation should contain exactly one while loop with some blocks of code before and after it.
the code produced by the synthesizer will have each of theseblocks replaced by a series of guarded assignments of the form if cond then stmt .
the conditional cond corresponds to expressions exp op exp where exp is either an expression of the form var .sel?
ornulland opranges over the set of comparison operators.
the set of assignment statements stmt corresponds to assignments of the form lhs exp where lhs is the same set as exp but excluding null.
each of these elements the scenarios the loop skeleton and the foldand unfold de nitions comprise a partial specication of the desired function.
for example the storyboard above is a partial speci cation because the abstraction does not de ne the relationship between midin the input and mid in the output.
in this case asking the synthesizer to produce a solution with a small number of statements is sufcient to ensure the correct answer but sometimes the user may have to provide the system with additional information.
in keeping with the pbe model this additional information usually takes the form of additional scenarios with concrete examples but it can also include providing intermediate state con gurations adding predicates in scenarios or providing a more detailed implementation sketch in place of the simple loop skeletons.
the strength of our synthesis approach is that it can combine these di erent constraints into a concrete implementation.
moreover as shown in section the constraints imposed by the storyboards are strong enough that in the few cases where the speci cation has to be strengthened it only takes a few additional concrete scenarios or an intermediate state con guration to guide the framework to synthesize the correct implementation.
.
synthesizing code from storyboards our synthesis strategy is based on constraint based synthesis .
the key idea behind this form of synthesis is to de ne a space of possible solutions to the synthesis problem and to represent it as a parameterized program.
for example in our case each unknown assignment can be represented as a switch statement where an unknown parameter determines which assignment is actually performed.
this means that the entire solution space can be represented as a programp in c whereinis the input to the program and c is a vector of control parameters that determines which computations are performed.
the goal of the synthesis processunfold f f f in x0 e out x0 g unfold f f f in x0 e out e0 g fold x f x in f0 x out e0 g fold x f x in f0 e out e0 g a f e mid f e mid x next x x f x e x f e e f e mid f e mid x next x x f x e x f e e unfold fold b figure unfold and fold predicate de nitions for mid summary node void l l r e v e r s e node head f while f g return head g figure control ow sketch for list reversal.
each number corresponds to an unknown block of code.
is then to nd a value csolsuch that the program p in c sol meets the storyboard speci cation for all inputs in.
this view of the synthesis problem is common to all constraint based synthesis approaches .
in our framework we derive these constraints from the storyboard by interpreting the input output states in each scenario of the storyboard as abstract states in a specially crafted abstract domain.
this allows us to use the theory of abstract interpretation to frame the correctness condition as a set of equations.
the fold unfold predicates can be understood in the context of abstract interpretation as a way of de ning instrumentation predicates for summary nodes.
once the correctness condition has been framed as a set of equations the translation to constraints follows with only a small amount of e ort.
.
.
from storyboards to equations our framework uses a powerset domain as an abstract domain where the state is represented as a set of shapes.
each shape in turn is represented as a set of predicates following a formalism similar to tvla .
given this abstract domain the next step is to use the control ow sketch to derive a set of equations relating the abstract states at program points as described by sharir and pnueli in .
in these equations each one of the unknown blocks of code in the control ow sketch is represented by a parameterized transition function fm ti c that maps an abstract state to an output abstract state for a given control value c. the control ow sketch then de nes a set of equations involving the transition functions.
for example the control ow sketch in figure induces the following equations where thetransition function ficorresponds to block iin the sketch.
t0 f1 in c t1 f3 t0 t2 c t2 f2 t1 c t3 f2 t0 t2 c out f4 t3 c if these equations came from a veri cation problem each of thefiwould be a transition function and we could use an iterative approach to nd the least xed point solution to the equations and check that outmatched the solution required by the storyboard.
but for synthesis each firepresents an unknown block of code and the cvalues we are interested in nding do not form a lattice so we cannot use a standard iterative solver nd csol.
instead we provide an e cient way to encode the problem in a form that an o the shelf constraint solver can e ciently solve.
transition functions each transition function fm ti c encodes the behavior of set of possible sequences of guarded assignments that can be used to complete the control ow skeleton.
in addition to conditional statements a transition function can also include two special kinds of statements unfold var and fold var .
the semantics of unfold and fold correspond to no ops in the concrete domain their sole purpose is to allow the abstract interpretation to reach a xed point while allowing for very precise reasoning within the abstract domain.
figure shows the role of the unfold and fold functions in materializing abstract nodes to allow for more precise reasoning and then collapsing multiple abstract shapes into a single one to allow the abstract interpretation to reach a xed point.
the semantics of fold and unfold will be described in detail in section after we formalize the overall abstract interpretation framework.
.
.
equations to constraints so far we have described how to encode the problem in terms of the least xed point solution of a set of equations.
our framework translates these equations into a 2qbf formula which in principle could be solved by any 2qbf solver although in practice we have found that only our sketch solver scales to large synthesis problems.
as we will show in section the key idea in the translation to constraints is that instead of having the transfer functions produce sets of states we make the functions non deterministically produce one element in the set.
therefore by exploring allfigure unfold and fold operations in action node l l r e v e r s e node head f node temp1 null temp2 n u l l node temp3 n u l l temp1 head while temp1 !
n u l l f u n f o l d temp1 head temp1 temp1 temp1 .
next head .
next head head .
next temp3 temp3 head f o l d head g g figure synthesized list reverse implementation non deterministic choices we guarantee that the entire set is considered.
.
synthesized implementation from a satisfying assignment to the constraints the framework derives the imperative implementation shown in figure for the linked list reverse manipulation.
the conditionals all true from the conditional assignment statements have been removed for better readability of the code.
it can be noted that the implementation did not use the program variable temp2 and the loop body includes an extra dead store assignment statement head.next head .
aside from the additional assignment the code is an e cient implementation of the desired algorithm and the entire synthesis process takes only a couple of minutes.
.
data structure configurations in this section we present the formalism used by our framework to encode and reason about the storyboard description.
the formalism is based on abstract interpretation and is similar to that of tvla the primary di erence is our treatment of summary nodes with attachment points.
but before we describe the abstract interpretation we need to de ne the concrete domain over which programs operate.
in this concrete domain the state of the program is de ned by a xed set of local variables and a set of memory locations also called nodes where each location can have a number of elds pointing to other memory locations.
our framework currently does not support the allocation of memory by a synthesized routine so the set of nodes that the program has to reason about does not grow as the routine executes.
letl represent the set of memory locations the syn f e mid a b next next x0 a b next next x0 a x1 next next b next next next x0 a x1 next next x2 b figure an abstract list representing in nite concrete lists thesized program will operate on.
then the state of the program is captured by two sets of predicates.
first for every variable vand location l2l there is a predicate v l that indicates whether vpoints to location l. then for every eld sel there is a predicate sel l1 l2 that indicates whether a location l1has a eld selthat points to location l2.
these two sets of predicates encode a concrete shape which de nes the instantaneous con guration of the heap at any point in the execution.
shapes in the abstract domain.
the abstract domain consists of sets of abstract shapes where each abstract shape itself represents a set of concrete shapes.
the abstract shapes are de ned in terms of a set of locationsl.
each location loc2lcan be either a summary location or a concrete location we use the predicate sm loc to indicate that locis a summary location so sm loc indicates that the location is concrete.
as we have stated before a concrete location locmay serve as an attachment point for a summary location u which we express with the notation loc2a u we use the predicate apt loc to indicate the role oflocas an attachment point.
f e mid n1 n2 head next next temp1 temp2 figure state con guration for a singly linked list example .the state con guration in figure is encoded as follows.
the set of locations is given by l fl1 mid f e l2g with a summary node mid and attachment pointsa mid ff eg.
the set of program variables arev fhead temp1 temp2g.
the variable predicates head l1 temp1 f and temp2 l2 are true.
the next selector predicates next l1 f next e l2 and next l2 null are true and next f mid .to make the de nition of the abstract domain more formal consider a concrete shape s with a set of nodes l a selector predicate sel and a variable predicate var together with an abstract shape swith a set of nodes l selectorseland variable predicate var.
we say that shape s is in the concretization of s s s when there exists a relationm l lthat satis es the following conditions.
every node in s maps to some node in sand vice versa i.e.8l12l 9n12ls t m l1 n1 and8n12l9l12 l s t m l1 n1 nodes that do not map to summary nodes map to a single concrete node i.e.for anyl12l if 9n2s t sm n2 m l1 n2 thenm l1 na m l1 nb na nb.
summary nodes do not overlap i.e.
sm na m l1 na m l1 nb na nb nb2a na .
edges between concrete nodes are preserved i.e.given l1 l22l andn1 n22lwhere sm n1 and sm n2 letm l1 n1 andm l2 n2 then sel l1 l2 sel n1 n2 and var l1 var n1 .
summary nodes own their associated attachment points i.e.ifm l1 n2 andn22a u thenm l1 u any edge pointing to a summary node from the outside must point to one of its attachment points i.e.let sel l1 l2 m l2 nb sm nb then eitherm l1 nb or 9na2a nb s t m l2 na and for variables var l2 m l2 nb sm nb then9na2a nb s t m l2 na selector edges for summary nodes not originating in an attachment point are ignored i.e.ifsm na sm nb then sel na nb 0 na2a nb .
selector edges from an attachment point to its enclosing summary node will have value i.e.ifna2a nb and 9l1 l22l s t sel l1 l2 m l1 na m l2 nb and 9ncs t m l2 nc sm nc then sel na nb .
in shape analysis it is common to use valued logic to represent the values of selector and variable predicates in abstract shapes.
however notice that the rules above specifically require us to ignore most selector edges involving summary nodes.
the restrictions imply that the only selector edges that will potentially have value equal to are edges from an attachment point to its corresponding summary node that is why we have next f mid in the earlier example.
as we shall see in the next section the transition rules in the abstract semantics are de ned in such a way that if the algorithm under analysis ever tries to dereference a eld corresponding to one of these half edges it will transition into an error state.
this makes the analysis simpler at the expense of added imprecision but our analysis compensates for this imprecision by relying on the unfold predicates tomaterialize summary nodes.
.
abstract interpretation having de ned the structure of the abstract domain we now describe the transition rules used to model statements and conditionals focusing on those aspects unique to our framework.
figures and show respectively the statements and conditionals considered by the synthesizer.
the gures also show the formal de nitions of the transition rules associated with each construct.
the transition rules relate the state before the transition the pre state represented with non primed predicates with the post state represented with primed predicates.
it is assumed that the values of all other predicates not mentioned in the transition rule remain unchanged.
statement transition rule x null8l2l x0 l x t8l2l x0 l t l x t.sel assert 9l1 l22l t l1 sel l1 l2 sm l2 8l2l x0 l 9l1t l1 sel l1 l x.sel null assert 9l1 l22l x l1 sel l1 l2 sm l2 8l1 l22l sel0 l1 l2 x l1 sel l1 l2 x.sel t8l1 l22l sel0 l1 l2 sel l1 l2 x l1 t l2 unfold xunfoldpred e m c x e 8l1in!l22m fresh l2 8v2v v0 l2 v l1 v0 l1 8l2l sel0 l l2 sel l l1 sel0 l l1 8l1out!l22m fresh l2 8l2l sel0 l2 l sel l1 l sel0 l1 l c fold xfoldpred e m c x e c 8l1in!l22m fresh l2 8v2v v0 l2 v l1 v0 l1 8l2l sel0 l l2 sel l l1 sel0 l l1 8l1out!l22m fresh l2 8l2l sel0 l2 l sel l1 l sel0 l1 l figure abstract semantics of statements manipulating pointers and pointer valued elds the rules follow a convention from shape analysis to assume that every statement of the form exp t is preceded by a statement of the form exp null where expis either xorx.sel.
this assumption simpli es the rules because the transition rule for exp t does not have to worry about destroying the value previously stored at exp .
the other important observation about the rules is the use of assertions for the two rules that do eld dereferences.
these assertions ensure that the system will transition into an error state when it tries to dereference a selector that points to a summary node which in turn guarantees that values corresponding to these selector predicates will not propagate through the representation.
the abstract semantics for the class of conditionals is shown in figure .
it can be noted that although the assignment statements in our target language of programs ignore data elds of the data structure .data as opposed to .sel the conditionals can reason about the data constraints.
we store data predicates using gt gte eqetc.
which encode data constraints over the data values of locations.
we do not consider conditionals involving selector dereferencing of variables e.g.
of the form x.next null as they can be reduced into a conditional of the form y null where the variable yis rst assigned by the statement y x.next .
.
fold unfold semantics the unfold operation is described with a triple unfoldpred e m c .
the rst argument eis called the enabling node and it represents the summary node that is being expanded.
the transition rule for the unfold x statement performs the unfold operation only if the variable xpoints to the enabling node e. the second argument mis the location mapping m loc!loc which describes how nodes before expansion relate to nodes after expansion.
there are two kinds of loca tion mappings in m in!mappings andout!mappings.
anin!
mapping maps a location loc1toloc2such that all variables and selector edges pointing to loc1in the pre state should point to loc2in the post state.
anout!mapping maps a location loc1toloc2such that all outgoing selector edges from loc1in the pre state emanate from loc2in the post state.
finally the description of unfold also includes a set of constraints c. these constraints describe how the new nodes will be connected together and are asserted to hold in the post state after unfolding.
the transition rule for fold x statement works similarly to the unfold rule.
the di erence is that the foldoperations are enabled only if the constraints care also satis ed by the state con guration in addition to the requirement of xpointing to the enabling node e. the unfold and fold predicate de nitions on the summary node midare shown in figure .
another set of fold unfold examples for the binary search tree bst case studies is shown in figure .
the goal of bst search is to search for a value xin the tree where rrepresents its root.
the bst search contains manipulation assumes that the value xalways exists in the tree.
the three cases of bst search contains unfold are i x y val ii x y val and iii x y val as shown in fig a where ydenotes the root node of the subtree being unfolded.
the unfold de nition for the more general case of bst search is shown in figure b .
the tree summary nodes labeled stu are given without any unfold rules which means they cannot be materialized so the veri er will not be able to reason about any implementation that tries to visit them.
in this way the unfold rule is providing algorithmic insights telling the synthesizer that a given region of the tree should not be visited or manipulated.
one important thing to note about unfold is that a given shape can be expanded in many di erent ways as illustrated in figure .
this is expressed by having multiple unfoldpred triples with the same enabling node.
as a consequence every abstract shape in the pre state of an unfold operation may be expanded into a setof abstract shapes.
this expansion allows the analysis to maintain precision but having to represent sets of abstract shapes in the abstract interpreter will pose an interesting challenge when we turn the problem into a constraint satisfaction problem.
another very important aspect about unfold is that the presence of unfold changes the concretization relation between abstract and concrete shapes.
in the absence of unfold any arbitrary set of concrete nodes can be mapped to a summary node by the relation mdescribed in the previous section but unfold has the e ect of placing some structural constraints on the set of nodes that can be mapped to a summary node.
this is a result of the requirement that unfold correspond to skipin the concrete domain this means that if a given abstract shape scan be transformed by unfold into any shape in the set fsig then the set of concrete shapes s should equals i si .
so we can re ne the earlier de nition of the concretization function to say thats s if it satis es the requirements stated before andifs 2s i si wheresiare all the shapes that can be derived from sthrough the application of unfold .
the next section elaborates on how this de nition relates to the instrumentation predicates used by tvla to describe the structure of summary nodes.conditional transition rule x null8l2l x l x !
null9l2l x l x t8l2l x l t l x.data t.data8l1 l22l x l1 t l2 gt data l1 l2 x.data t.data8l1 l22l x l1 t l2 gte data l1 l2 x.data t.data 8l1 l22l x l1 t l2 eq data l1 l2 x.data !
t.data 8l1 l22l x l1 t l2 eq data l1 l2 figure abstract semantics of the conditionals involving the pointer variables .
relationship with tvla in order to understand some of the more subtle aspects of our formalism it is useful to understand how it relates to the formalism in tvla .
the two most apparent di erences between the two formalisms are the use of attachment points as part of summary nodes and the use of foldand unfold .
in our system the unfold de nition serves two purposes it provides a mechanism to convey structural properties of summary nodes and it is also used to materialize summary nodes i.e.to produce a set of more re ned shapes that together represent the same set of concrete con gurations as the original con guration.
in tvla by contrast structural properties are described through instrumentation predicates .
these predicates are also used for materialization but not directly instead a focus operation rst expands a summary node into a set of possible shapes and then a coerce operation uses the instrumentation predicates to re ne the new shapes and to remove those that do not satisfy the required structural properties.
one can understand the unfold rules in our framework as a specialized way of describing instrumentation predicates.
for example from the unfold rule for midwe can derive the following instrumentation predicate ismid f e f e 9f0 f next f0 ismid f0 e the predicate ismid encodes that every node in midis reachable from the front attachment point and therefore that the sub list between fandeis acyclic.
when we say that a summary node satis es this predicate it means that the summary node can only represent sets of nodes where we can nd two nodes f and e that satisfy the predicate.
the unfold operation induces this predicate because we want the e ect of unfold in the abstract domain to be equivalent to the e ect of skip in the concrete domain and this will only be true if the summary nodes satisfy this predicate.
it is interesting to see however that the structure of the predicate is very close to the structure of the unfold rules with the attachment points serving as convenient parameters to the predicate.
given such an instrumentation predicate we can map our summary nodes with attachment points to a shape in tvla for example figure shows how mid would look like as a shape in tvla.
our unfold operation is equivalent to rst applying materialization to partially concretize the summary node and then coerce to remove invalid shapes obtained after materialization.
the use of unfold in place of instrumentation predicates and the use of attachment points both have a number of advantages for the purpose of our framework.
the rst important advantage is that it simpli es the transition rules because it eliminates the need to track instrumentation pred r b stree stuff y stuff u u x y.val stuff y r b stree u x y.val y stuff r b stree u x y.val unfold a bst search contains x unfold r b stree stuff y stuff u u stuff y u y stuff u stuff y r b stree u y stuff r b stree u x y.val x y.val x y.val ispresent x ispresent x ispresent x unfold b bst search may not contain x unfold r l stree y stuff r l stree y stuff u u unfold r y l r y l l c bst minimum unfold r b stree stuff y y stuff r b stree y stuff r b stree stuff y u u u u fold d bst search fold figure unfold and fold operations for di erent data structure manipulations f e next next next ismid ismid ismid ismid ismid ismid f next ismid ismid ismid ismid f e next next next ismid ismid ismid ismid ismid ismid figure unfold in valued shape analysis icates.
another important bene t of using summary nodes with attachment points is that it simpli es the graphical representations as can be readily appreciated by comparing figure with figure .
one clear di erence between the two representations is that figure includes a number of selector edges with value which are not present in the diagrams in figure .
this is partly by convention since we omit from our representation the selector edges within summary nodes and partly because the assumptions in section ensure that