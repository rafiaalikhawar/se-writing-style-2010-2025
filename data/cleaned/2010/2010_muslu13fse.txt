making offline analyses continuous k van mu slu yuriy brun michael d. ernst david notkin computer science engineering school of computer science university of washington university of massachusetts seattle wa usa amherst ma usa kivanc mernst cs.washington.edu brun cs.umass.edu abstract developers use analysis tools to help write debug and understand software systems under development.
a developer s change to the system source code may affect analysis results.
typically to learn those effects the developer must explicitly initiate the analysis.
this may interrupt the developer s workflow and or the delay until the developer learns the implications of the change.
the situation is even worse for impure analyses ones that modify the code on which it runs because such analyses block the developer from working on the code.
this paper presents codebase replication a novel approach to easily convert an offline analysis even an impure one into a continuous analysis that informs the developer of the implications of recent changes as quickly as possible after the change is made.
codebase replication copies the developer s codebase incrementally keeps this copy codebase in sync with the developer s codebase makes that copy codebase available for offline analyses to run without disturbing the developer and without the developer s changes disturbing the analyses and makes analysis results available to be presented to the developer.
we have implemented codebase replication in solstice an opensource publicly available eclipse plug in.
we have used solstice to convert three offline analyses findbugs pmd and unit testing into continuous ones.
each conversion required on average ncsl and took on average hours.
solstice based analyses experience no more than .
milliseconds of runtime overhead per developer action.
categories and subject descriptors d. .
programming environments d. .
coding tools and techniques general terms design keywords continuous analysis codebase replication solstice .
introduction many program analysis tools exist that can inform developers about the code they write.
the sooner the developer learns the implications of a code change the more useful the feedback is a delay between making the change and learning the analysis result permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.can lead to wasted effort or confusion .
ideally the developer learns the implications of a change as soon as the change is made.
for example modern ides such as eclipse and visual studio continuously compile the code and inform developers about a compilation error as soon as the developer causes one.
similarly continuous testing informs the developer as soon as possible after a change breaks a test speculative conflict detection informs developers of conflicts soon after they commit their changes locally and speculative quick fix informs developers of the implications of making compilation error fixing changes before the change even takes place .
this paper introduces codebase replication an approach that enables a tool builder to easily convert an offline analysis that developers must run manually into a continuous analysis that runs constantly and always provides the developer with up to date results.
our goal is not to make an analysis run faster nor incrementally but to run it more frequently and to simplify the developer s workflow all without requiring a redesign of the analysis tool.
this allows developers to rely on the continuous analysis tool to notify the developer if and when something relevant happens instead of the developer having to interrupt their work to run the analyses and examine the results.
these notifications may display analysis results indicate that potentially interesting information is available or cue other relevant analyses or tools to run.
making an analysis continuous executing quickly after each code change to identify problems in a timely manner is challenging.
this explains why few continuous analyses exist despite their benefits.
two major challenges are isolation andcurrency .
isolation requires that the analysis should not prevent the developer from making new changes and that code changes made by an impure analysis should alter the code neither visibly nor functionally while the developer is working.
currency requires that an analysis is optionally restarted and old results are marked as stale when the developer makes an edit and that analysis results are made available as soon as the analysis completes.
we have addressed these challenges with codebase replication an approach that enables conversion of offline analyses even impure ones into continuous analyses that inform the developer of the implications of recent changes as quickly as possible after those changes are made.
codebase replication employs four principles to overcome the challenges of isolation and currency replication keeping a separate in sync copy of the program on which the analysis executes buffer level synchronization including the latest changes in the analysis exclusive ownership allowing analyses to request exclusive write access to the program under analysis and invalidation detection identifying results made stale by new developer changes.
we demonstrate codebase replication by converting three previously offline analyses into continuous analysis plug inspermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
323for eclipse.
each plug in uses the offline analysis internally.
the key idea underlying codebase replication is to create and maintain a copy of the developer s codebase.
this allows the underlying offline analysis to run on the copy codebase without the developer s changes affecting analysis execution.
further if the analysis needs to alter the copy codebase it can do so without affecting the developer s codebase and without distracting the developer .
the offline analysis can start quickly because the copy codebase is always in sync it does not need to make a fresh copy of the code before executing.
if the developer edits the code while the analysis is running codebase replication allows the analysis to terminate and restart the offline analysis so that the results are always accurate at the moment they are delivered defer propagating the developer s edits until the analysis is finished so that the analysis can complete in case the results are useful even when a little stale or complete the analysis and use analysis specific logic to invalidate parts of the results.
the main contributions of our work are the identification of isolation andcurrency as challenges to the creation of continuous analyses.
codebase replication an approach to using a copy codebase to meet the challenges with little overhead .
milliseconds per developer action .
solstice an open source publicly available implementation of codebase replication within eclipse.
three new publicly available continuous analysis eclipse plug ins each based on an existing analysis findbugs pmd and unit testing.
an evaluation of the effort needed to create these plug ins demonstrating that solstice and therefore codebase replication significantly reduces the programmer effort needed to develop continuous analysis eclipse plug ins.
a preliminary case study in which one of the authors used a solstice based continuous testing plug in on a small program kloc showing that the plug in is fast stable and useful.
computing analysis results early and often means that more accurate results are available sooner after the developer changes the code.
the results could be shown to the developer immediately to reduce wasted time or less frequently to avoid distracting and annoying the developer .
codebase replication supports both.
the rest of this paper is structured as follows.
section formally defines continuous analysis.
section introduces codebase replication and explains how it addresses the challenges of isolation and currency for continuous analysis implementation.
section introduces solstice a codebase replication implementation for eclipse.
section evaluates solstice s performance and our experience implementing three proof of concept continuous analyses with solstice.
section places our work in the context of related research.
finally section summarizes our contributions.
.
definitions in order to explain codebase replication we first define several concepts including what it means for an analysis to be continuous.
asnapshot is the state of a software program at a point in time.
ananalysis is a computation on a snapshot that produces a result.
anoffline analysis is an analysis that requires no user input.
a continuous analysis is one that automatically computes an up todate result without user intervention.
finally a pure analysis is one that does not modify the snapshot on which it runs while an impure analysis does.
more formally definition snapshot .asnapshot is a single developer s view of a program at a point in time including the latest file contents from unsaved editor buffers if any or from the disk otherwise.each of a developer s changes e.g.
made via an ide creates a new snapshot.
in this paper we limit ourselves to considering analyses that run on a single developer s codebase.
some analyses e.g.
conflict detection may need multiple developers codebases of the same program.
our work is applicable to such analyses as well although the definition of a snapshot would need to be modified.
definition analysis .ananalysis is a function a s!r that maps a snapshot s2sto a result r2r a s r. definition offline analysis .anoffline analysis is an analysis that requires no human input during execution.
as an example a rename refactoring is not an offline analysis because each execution requires specifying a programming element e.g.
a variable and a new name for this element.
an offline analysis may require human input for one time setup such as configuration parameters or the location of a resource.
definition analysis implementation .ananalysis implementationiais a computer program that on input snapshot s produces r a s .
lettia s be the time it takes an analysis implementation iato compute aon a snapshot s. it is our goal to convert an offline analysis implementation iainto a continuous analysis implementation ic athat executes iainternally.
a user may edit the program faster than an analysis implementation is able to complete that is faster than tia s .
in this case ic a should be responsive to changes in the program and the completion of the analysis in two ways computing the analysis on the latest snapshot and notifying the developer that previous analysis results are stale.
there are multiple policy choices for what ic amay do in terms of computing the analysis on the latest snapshot.
for example ic amay terminate ia since it is running on a stale snapshot and restart it on the current snapshot.
or ic amight permit iato complete to deliver the results even if somewhat stale.
other options include restarting iaonly during a sufficiently long pause in user edits or computing whether a specific user edit might affect the results ignoring edits to comments for example .
similarly there are multiple policies ic acould follow in notifying the developer about possibly outdated results.
for example ic acould remove the possibly stale results from developer s view or merely mark them as stale.
when an analysis completes the computation of a new result ic acould display those results immediately or could delay to reduce churn and give users a chance to save work such as marking analysis results as inspected .
for simplicity of presentation our definition of a continuous analysis assumes the most eager policies.
it could be extended to accommodate other policy choices.
definition e continuous analysis implementation .letabe an offline analysis and let tsbe the time at which snapshot scomes into existence.
an analysis implementation ic athat uses iaisecontinuous if9ea ei esuch that for all snapshots s both of the following are true .ic amakes r a s available no later than ts tia s eaif no new snapshot is created before this time.
eais the analysis delay the time it takes to terminate an ongoing analysis execution of ia apply any pending edits to the copy codebase restart the analysis and deliver the results e.g.
to a ui or a downstream analysis .
.for all times after ts ei ic aindicates that all results for sand snapshots prior to sare stale.
eiis the invalidation delay the time it takes to invalidate the displayed results after the moment they become stale.
we often refer to e continuous analyses as simply continuous implying that appropriately small eaand eiexist.
it is particularly challenging to convert an impure offline analysis to a continuous analysis.
our approach handles both pure and impure analyses.
definition pure analysis implementation .an analysis implementation iaispure iff its computation on a snapshot sdoes not alter s. an impure analysis implementation may alter s. running a test suite is an example of a pure analysis because it does not alter the source code.
mutation analysis applying a mutation operation to the source code and running tests on this mutant is an impure analysis.
.
codebase replication codebase replication converts an offline analysis iainto a continuous analysis ic awhile addressing the two major challenges in creating continuous analysis tools isolation and currency.
the developer should be isolated from ic a ic ashould neither block the developer nor change the code as the developer is editing it which could happen for an impure ia .
additionally ic ashould be isolated from the developer developer edits should not alter the snapshot in the middle of an iaexecution potentially affecting the results.
despite isolation between the developer and ic a currency requires ic a to react quickly to developer edits and to iaresults.
whenever the developer makes an edit ic ashould be notified so that it can mark old results as stale terminate and restart ia or take other actions.
ic ashould react to fine grained changes in the developer s buffer without waiting until the developer saves the changes to the file system or commits them to a repository.
ic ashould also react quickly toiaresults making them promptly but unobtrusively available to the developer or to a downstream analysis.
most ides have a unique ui thread so simply executing iain a continuous loop would block the developer from interacting with the ide whenever iaruns.
unless iais nearly instantaneous this would render the ide unusable.
running iain a separate thread requires synchronizing with the ui thread which may interact with the code and may still block the developer.
as a consequence and to our best knowledge none of the existing continuous analysis tools follow this approach and neither does codebase replication.
codebase replication addresses the isolation challenge of convertingiaintoic aby creating and maintaining a copy of the developer s codebase.
the goal of this copy codebase is to provide a stable snapshot for iato use without affecting the developer and without being affected by the developer.
codebase replication addresses the currency challenge by providing notifications for events that occur in the developer s ide and in ic a these events can trigger terminating and restarting iaand updating the ui.
figure shows codebase replication s high level overview.
the ide api generates events for all developer actions including developer s changes to the code.
codebase replication keeps a queue of these events and applies them to the copy codebase.
meanwhile ic acan pause the queue run iaon the copy snapshot compute ia results resume the queue and modify the developer s editor ui based on the results.
codebase replication also notifies ic aabout new developer actions so that ic amay decide to interrupt alter or continue ia s execution.
figure a high level codebase replication overview.
codebase replication turquoise facilitates communication between ic a green and a developer s ide purple via asynchronous events.
codebase replication supports multiple ic ausing the same copy codebase managing locks and parallel execution.
however in this paper for exposition we focus on the simpler case of a single ic a running at a time.
codebase replication employs four principles to overcome the challenges of isolation and currency .replication instead of running iadirectly on the developer s snapshot codebase replication provides a separate copy of the snapshot by maintaining an in sync copy of the codebase.
this ensures that the developer s codebase is never affected by ia.
this principle is based on the idea of sandboxing.
if iamodifies the copy snapshot or crashes in the middle of the execution the effects are confined to the copy and the developer may continue to edit unaffected by the modifications and crashes.
further this approach separates the ui logic from the analysis logic which is a good design principle that improves the tool s maintainability.
.buffer level synchronization one of the goals of ic ais to provide feedback on the latest possible snapshot.
this snapshot often resides in the ide buffer and not on disk.
unfortunately most existing iaexecute on files or even on binaries.
codebase replication synchronizes the copy snapshot with the developer s ide s unsaved buffers allowing iato run on the latest snapshot or binary compiled from that snapshot without without affecting the developer s buffer files and binaries.
some iaare incremental computing results based on code changes since the last snapshot as opposed to on an entire snapshot.
for most ia creating an incremental version presents a significant obstacle and amounts to developing a brand new ia.
codebase replication s goal is to minimize the cost of building ic aby allowing developers to create continuous tools by using existing iaimplementations without modifying or redesigning those implementations.
while easing the process of building ic a section .
will empirically evaluate the effort required to develop ic ausing a prototype implementation of codebase replication we should note that one disadvantage of codebase replication over developing incremental iais the extra runtime overhead incurred by listening for buffer changes identifying and discarding duplicated file system changes and detecting discarded buffers.
meanwhile the incremental approach needs to only listen for file system changes.
nevertheless section .
will show that for our prototype codebase replication implementation this overhead is no more than .
milliseconds per developer action.
.exclusive ownership most iaassume the snapshot does not change while they execute.
thus changing the snapshot in the325figure high level solstice overview.
eclipse purple generates events for developer actions including edits.
solstice server turquoise listens for these events serializes them and sends them to solstice client turquoise and notifies ic aof the actions.
solstice client stores these actions temporarily in the event queue deserializes them applies the edits to the copy workspace notifies ic aof these actions and provides pause resume api for managing the exclusive ownership of the copy workspace.
an example ic a green interacts with the developer s editor solstice and the copy workspace by analysis client runs iaon the copy workspace generates and serializes the results and sends those results to analysis server .analysis server deserializes the results modifies developer s editor accordingly and implements invalidation logic.
middle of an execution may cause iato crash or fail in other ways.
the situation is worse if multiple iarun on the same code at once and at least one of them is impure.
codebase replication allows oneic aat a time to claim exclusive write access to a copy snapshot while its iaexecutes pausing all other analyses and synchronization updates with the developer s buffer.
this allows iato complete with expected behavior.
.invalidation detection developer s changes may invalidate theiaresults on an old snapshot.
if the change occurs while ia executes the result may already be invalid by the time iacompletes.
codebase replication allows ic ato terminate ia or to let if finish and to examine the change to determine whether the results or parts of the results are valid.
these principles allow codebase replication to convert iainto ic awhile ensuring isolation and currency.
multiple ic acan use a single copy snapshot amortizing the already low overhead see section .
.
multiple impure ic acan each take turns exclusively owning the copy snapshot to provide fast accurate results with buffer change level precision.
the changes the impure iamake to the copy snapshot remain completely hidden from the developer s copy.
codebase replication does require ic ausing impure iato implement a mechanism to revert the iachanges and the correctness of the copy synchronization is only guaranteed if the reverting works properly.
however most impure iaalready implement this logic.
for those that do not since the copy codebase issaved on the file system ic acan implement a simple revert mechanism using version control.
embedding such a mechanism in codebase replication is future work.
finally we impose three performance requirements on codebase replication first codebase replication must have nearly negligible computational overhead in maintaining the copy codebase.
ic a is already computation intensive and codebase replication should not consume more of that resource.
second the copy codebase should be synchronized with the developer s codebase as quickly as possible to facilitate iaexecuting on the most up to date version of the code.
third codebase replication should be easy to use tocreate ic avia a comprehensive api.
section will revisit how well our implementation satisfies these requirements.
.
solstice codebase replication for eclipse to evaluate codebase replication we have built solstice an eclipse based open source prototype.
solstice is publicly available at this section describes solstice section .
explains how to implement continuous analysis tools using solstice section .
and then demonstrates one such implementation with an example section .
.
later section .
will describe our experience using solstice to develop three continuous analysis tools.
.
solstice implementation this section explains the solstice implementation refines codebase replication with eclipse specific concerns and discusses solstice design choices.
figure details solstice s architecture and an example solsticebased continuous analysis tool.
solstice consists of two main parts solstice server runs on developer s eclipse and is responsible for listening to the developer actions.
solstice client runs on a background copy of eclipse and is responsible for keeping the copy codebase in sync and managing the ownership of the copy codebase.
solstice based continuous analysis tools use solstice client for their computation logic and solstice server for their visualization logic and to interact with the developer.
the eclipse api allows each instance of eclipse to be associated with and have access to only one workspace.
solstice manages two copies of eclipse running at once the developer s normal copy of eclipse manages the developer s workspace solstice serverdeals with this workspace and a second background copy of eclipse runs solstice client and maintains the copy workspace and with it the copy codebase .
the background eclipse is headless it has no ui elements and the developer never sees it.
the copy workspace also resides in a hidden folder on disk.
that folder name326includes a hash of the absolute path to the developer s workspace to guarantee uniqueness with high probability.
each time the developer starts eclipse solstice executes an initialization protocol that blocks the developer and makes sure that the copy workspace is in sync with the developer s workspace before the development begins.
first solstice client connects tosolstice server through localhost.
then the initialization synchronization protocol executes.
the first time the developer uses solstice initialization synchronization protocol acts as a full synchronization and creates a complete copy of the developer s workspace on disk.
the future executions on the other hand only verify the integrity of the files in the copy workspace through checksums and update the files that are added removed or changed in the developer s workspace outside the ide.
after the initialization synchronization protocol solstice serverattaches multiple listeners see figure to the developer s eclipse to keep track of all developer s events actions and edits to the source code.
currently in addition to all edits developers make to the code solstice listens to the following developer actions current cursor location current selected file current selected eclipse project invocations of quick fix the proposals offered for a quick fix invocation and selected quick fix proposals and completions and cancellations of quick fix.
solstice server catches the developer s events serializes them and sends them to the solstice client which in turn deserializes the incoming events makes them available to the continuous analysis tool through simplified observer patterns and applies developer edits to the copy workspace.
solstice client keeps track of all developer edits through the events sent by solstice server and applies them to the copy workspace in the order they are generated guaranteeing that the developer s workspace will always be in sync with the copy workspace with the exception of the events currently being processed.
instead of the localhost connection solstice could use either the java remote method invocation rmi 1or the file system for solstice server andsolstice client to communicate.
rmi abstracts away the underlying networking protocol which can allow for a cleaner design.
meanwhile using the file system enables higher flexibility for the serialization and communication protocols but requires these inter process protocols to be implemented from scratch.
solstice see architecture in figure has two requirements for inter process communication the ability to send messages events between the components running on different eclipses and the flexibility of pausing and resuming event processing for exclusive ownership within a component.
localhost connection abstracts the underlying inter process communication protocol and gives solstice the flexibility to implement the event based execution with the ability to pause and resume the event queue immediately over the java networking layer.
as a result solstice and the continuous analysis tool can completely abstract away the underlying event based execution leading to a cleaner logic.
we chose to use the localhost connection mechanism because of the combination of abstraction and flexibility it provides.
.
building solstice based tools this section explains how to use solstice to build a continuous analysis tool ic abased on an offline analysis implementation ia.
we refer to the author as the person developing ic a and to the developer as the person later using ic a. to implement ic a the author has to accomplish three tasks separate the ic acomputation and interaction logic formalize the ic a communication and write the result invalidation logic.
the author needs to separate ic acomputation logic how ia runs and produces results and interaction logic how ic ashows results and interacts with the developer.
the computation logic is implemented as a solstice client extension represented as analysis client in figure .
the interaction logic is implemented as asolstice server extension represented as analysis server in figure .
the same way eclipse manages the life cycle of its extending plug ins solstice manages the life cycle of the extending ic a they start after solstice starts when the developer opens eclipse and terminate before solstice terminates when the developer closes eclipse .
the author does not need to create and manage a thread foric aas solstice takes care of these low level details.
the computation logic always runs on the background eclipse and on the copy workspace and the interaction logic always runs on the developer s eclipse and workspace.
for the rest of the section we assume that ic ainteracts with the developer.
continuous analysis tools that do not interact with the developer e.g.
observational ic athat only log developer actions do not need a solstice server component as solstice client duplicates all developer edits and ic acan access all those events directly from solstice client via listeners.
next the author needs to formalize the communication between analysis client andanalysis server .
the analysis results generated by analysis client need to be sent to analysis server to be displayed to the developer as shown in figure .
however the communication does not have to be one sided although the example communication shown in figure is one sided .
for example the analysis server can allow the developer to modify ic asettings which it would then send to the analysis client .
as theanalysis client and the analysis server run on different eclipses all communication between them occurs through serializable objects.
solstice provides wrappers that reduce the inter process communication code.
the author needs to implement the analysis logic via the runanalysis .. method that returns a serialized analysisresult object which is then transparently sent to analysis server .
the sent object arrives as an event received via the processanalysisresult .. method.
finally the author needs to write the logic for invalidating an ia result based on developer edits.
solstice timestamps every developer action and edit iastart and iafinish to ensure that no event is lost and that solstice knows exactly to which snapshot an iaresult applies.
using these timestamps transparently analysis client may either kill the ongoing iacomputation and start a new one after applying the developer edits to the copy workspace or allow the current iacomputation finish possibly producing stale results.
the analysis server may erase the current iaresults or mark them as stale.
for common scenarios such as clearing ia results with each developer edit solstice provides built in apis that reduce the code that needs to be written for keeping track of developer changes.
for example if ic awants to immediately invalidate iaresults after all source code changes that ic aneeds to only implement the editinvalidator.invalidate .. method.
in contrast without solstice to get the same outcome through pure eclipse api ic awould need to implement one iresourcechangelistener to keep track of the resources being added and deleted oneidocumentlistener for the current editor file to keep track of the buffer changes and one ipartlistener to keep track of the current editor when using eclipse api.
at the very least a complete implementation without solstice would require implementing nine methods.
finally the implementation needs to process these events and decide whether the current event invalidates the results.
for example each keystroke generates a documentevent which should invalidate the results.
however when the developer saves the current file it generates a resourcechangedevent which needs to be327ignored as it is already subsumed by the previous documentevent s. solstice takes care of all these low level details.
.
example solstice usage suppose an author wants to use solstice to build an ic ausing an ia.
for simplicity the author decides that when the developer makes a change while iaexecutes iamight as well finish but ic ainvalidates stale results and does not display them to the developer.
the author would have to write the following interaction logic foric a analysis server class server extends analysisserver public server super true void processanalysisresult analysisresult r update results.
invalidation logic class invalidator extends editinvalidator void invalidate invalidate results.
server passes true toanalysisserver which represents that ic a only wants to process recent iaresults.
solstice pre processes all ia results received from analysis client compares their timestamps with the current timestamp and only propagates the recent results toprocessanalysisresult .. .
the author would also have to write the following computation logic for ic a analysis client class analysis extends resourcebasedanalysis analysisresult runanalysis analysisresult result compute the result.
return result analysis extends resourcebasedanalysis which tells solstice to call resumeanalysis .. each time it processes an event that modifies the copy workspace.
the resumeanalysis .. call is a no op while iais running.
however when iais paused invokingresumeanalysis .. wakes up the ic athread which eventually calls solstice.pause .. runanalysis .. and solstice.resume .. .
the author does not need to do anything special to manage the exclusive ownership of the copy solstice manages that transparently.
.
ev aluation to evaluate solstice we empirically measured its performance overhead section .
observed the ease of using solstice while implementing three proof of concept continuous analysis tools section .
and compared solstice to other methods of implementing ide integrated continuous analyses section .
.
.
solstice performance evaluation to be effective solstice has to meet the following requirements r1 the start up time should not block the developer for an unreasonable amount of time.
r2 the overhead to synchronizing developer actions with the copy codebase should be close to zero.workspace codebase sync time ms content size mb kloc kncsl full inc. crosswordsage .
.
.
asmx v oldemort .
jdt .
m .
s figure solstice initial synchronization protocol performance.
each cell is the mean of experimental executions.
full synchronization starts with an empty copy workspace whereas incremental synchronization starts with an in sync copy codebase and solstice only verifies the copies are in sync.
r3 while using the ide the developer should experience negligible delay in performing actions.
this section presents the results of solstice performance experiments addressing these three requirements.
we ran all experiments on a modern laptop macbook pro i7 .
ghz quad core gb ram ssd solstice ran with mb ram limitation for each of the server and client applications.
.
.
initial synchronization protocol cost as section explained when the ide starts solstice needs to either install file system level resource listeners or go through an initial synchronization protocol to make sure that the copy codebase and the developer s codebase are in sync.
without this precaution if the developer or some other application modifies the codebase when the ide is not running the copy codebase would become out of sync.
solstice makes the latter choice recall section .
to satisfy requirement r1 the blocking incurred by the initial synchronization protocol must be reasonable.
we have tested solstice s initial synchronization protocol on four different workspace settings figure .
for each setting we created a workspace with one program a program may consist of many eclipse projects for example jdt consists of and invoked the initial synchronization protocol for two extreme cases full and incremental.
in the full case the copy workspace is empty which requires solstice to copy the entire workspace.
in the incremental case the copy workspace is already in sync which requires solstice to only verify that the copies are in sync with checksums.
we expect the most common use case to resemble the incremental case with the full case only applying on the first time the developer runs solstice.
figure shows that solstice has negligible overhead for small programs crosswordsage asmx2 and v oldemort .
even for large programs such as jdt solstice s incremental synchronization overhead is several .
seconds which we believe to be reasonable considering jdt3has 10k files.
however for even larger programs the incremental synchronization may become an issue.
it is possible to make the initial synchronization protocol lazy only processing the active eclipse project and its dependencies.
for industrial products composed of many eclipse projects this approach would block the developer for only a few seconds each time the developer changes which project is active and only once for each project per ide restart.
consequently amortizing the incremental synchronization cost for the workspace to independent smaller components would improve the developer experience.
we leave this improvement to future work.
.
.
synchronization overhead 2extended asm a byte code manipulator 3our jdt evaluation includes four products eclipse.jdt.core eclipse.jdt.debug eclipse.jdt and eclipse.jdt.ui328operation initial file ide sync name size size chars overhead ms delay ms text insert10 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
text delete11 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
text edit1100 .
.
.
.
.
.
.
.
.
.
.
.
text edit summary file add1 .
.
file remove1 .
.
file edit summary grows linearly with size figure the solstice induced overhead on developer edits for keeping the copy workspace in sync.
text operations of size are single keystrokes and text operations of size represent cut paste and tool applications such as applying a refactoring.
file operations of size are manual file generation copy and removal and file operations of size and represent copying removing or importing a directory or an entire eclipse project.
ide overhead measures the overhead imposed on the responsiveness of the ide and sync delay measures the delay before the copy workspace to be up to date.
text operations are means over executions.
file operations are means over executions.
to satisfy requirement r2 and to allow ic ato access the most recent version of the developer s code solstice must quickly synchronize the copy workspace.
figure shows the delay solstice incurs during synchronization for the most common developer operations.
except for importing and deleting large eclipse projects synchronization takes no more than .
milliseconds.
thus solstice provides ic aaccess to the developer s code that is no more than .
milliseconds old.
since importing and deleting large eclipse projects is fairly rare and the operations already take several seconds for eclipse to execute the solstice delay should be acceptable.
.
.
developer action delay as solstice keeps track of all developer changes at the buffer level it listens to each keystroke.
to satisfy requirement r3 it is important that the overhead and delay experienced by the developer are close to zero so the developer is not adversely affected by sol stice.
figure shows for the most common developer actions the ide overhead that solstice introduces when the action is initiated programmatically.
one of the most common developer actions is editing a file with keystrokes.
figure represents such text edits as size .
the ides also support complex operations such as refactoring auto complete etc.
that execute multiple edits at once.
figure represents such text edits as size .
the results show that the overhead is independent of the edit size and even for large files characters the overhead is no more than .
milliseconds.
manually adding and removing files to an eclipse project are represented as and sized file operations.
results suggest that the overhead for file operations increase linearly with operation size as expected.
removals are faster than additions and even for large operations the overhead never exceeds a few seconds.
since eclipse already takes several seconds to import a project with files the results suggest that solstice introduces negligible ide overhead.
our performance analysis demonstrates that solstice introduces negligible overhead to the ide almost never interrupts the development process except during the initial synchronization protocol and provides access to a recent copy codebase with negligible delay.
.
solstice usability evaluation we have used solstice to build three proof of concept ic aeclipse plug ins each using one of three existing iaimplementations.
this section describes these implementations and reports on our experience.
sections .
.
.
.
and .
.
describe the continuous findbugs the continuous pmd and the continuous testing plugins respectively.
figure summarizes the implementation and evaluation details of each plug in.
.
.
continuous findbugs findbugs is a static analysis tool that finds common developer mistakes and bad practices in java code such as incorrect bitwise operator handling and incorrect casts.
findbugs has found bugs in open source software is useful to developers and is extensible with new bug patterns .
it is available as a command line and a gui tool an ant task extension and an eclipse plug in .
the findbugs ant task extension and eclipse plug in can automate findbugs invocations but both fall short of being e continuous recall definition in section the ant task extension executes only with each ant build.
meanwhile the plug in has a setting to run whenever eclipse s incremental build runs which typically happens when the developer saves the file and analyzes only that saved file.
both tools require the developer to perform an action to run either execute the build script or save a file and neither reacts to changes made only to the buffer.
further since changes to one file may affect the analysis results of another a solstice based implementation may find warnings missed by the findbugs plug in.
we have used solstice to build a proof of concept continuous findbugs eclipse plug in .
the plug in uses the command line findbugs to analyze the .class files for all the classes in the currently active eclipse project and of all the libraries on which they depend.
the plug in s simple visualization displays the findbugs warnings in an eclipse view4 which is a configurable window similar to the eclipse console.
the plug in invalidates the warnings whenever the developer makes an edit or makes another project active.
figure shows two continuous findbugs plug in screenshots one before left a developer makes a change that removes a findbugs warning and one right after.
reference extension points org eclipse ui views.html329analysislines of code dev.
evaluation subject program analysis ea ei ui ipc core other total time name version kloc kncsl runtime ms ms findbugs hoursv oldemort .
.
.
s pmd hours .
s testing hours commons cli .
.
.
ms figure summary of three solstice based proof of concept tools.
each tool consists of ui code for result visualization and pretty printing ipc code for serialization core code for setting up and running the ia and other code for extension points.
pmd iause is similar to findbugs and pmd ic awas implemented after findbugs ic a which led to a significant reduction in development time.
in calculating evalues we used pmd s java basic ruleset and all of commons cli s tests.
each evalue is the max observed value over at least executions.
figure summarizes the implementation and evaluation details for the continuous findbugs plug in.
the implementation is fewer than loc excluding the code for visualization.
it is also econtinuous with empirically computed values ea 59milliseconds and ei milliseconds.
.
.
continuous pmd pmd is a static java source code analysis that finds code smells and bad coding practices such as unused variables and empty catch blocks.
it is available for download as a standalone executable and as plug ins for several ides including eclipse.
like findbugs it is popular and well maintained.
unlike findbugs pmd works on source code and applies different kinds of analyses.
the existing eclipse plug in is not continuous the developer must right click on a project and run pmd manually.
we have used solstice to build a proof of concept continuous pmd eclipse plug in .
the plug in uses the command line pmd to analyze the .java files for the currently active eclipse project.
the plug in s simple visualization displays the pmd results in an eclipse view.
the plug in invalidates the results whenever the developer makes an edit or makes another project active.
figure shows two continuous pmd plug in screenshots one before left a developer makes a change that removes a pmd warning and one right after.
figure summarizes the implementation and evaluation details for the continuous pmd plug in.
the implementation is fewer than loc excluding the code for visualization.
it is also econtinuous with empirically computed values ea 67milliseconds and ei milliseconds.
.
.
continuous testing continuous testing uses otherwise idle cpu cycles to run tests to let the developer know as soon as possible when a change breaks a test.
continuous testing can reduce development time up to .
there are eclipse and emacs plug ins for continuous testing.
the eclipse plug in modifies eclipse core plug ins making it difficult to update the implementation for new eclipse releases in fact the plug in does not support the recent versions of eclipse.
by contrast solstice requires no modifications to the eclipse core plug ins and would apply across many eclipse versions.
we have used solstice to build a proof of concept continuous testing eclipse plug in .
the plug in runs the tests of the currently active eclipse project and invalidates the test results whenever the developer makes an edit.
the plug in s simple visualization displays the test results in an eclipse view.
figure shows two continuous testing plug in screenshots one before left a developer makes a change that breaks a test and one right after.
figure summarizes the implementation and evaluation details for the continuous testing plug in.
the implementation is fewer than loc excluding the code for visualization.
it is also econtinuous with empirically computed values ea 56milliseconds and ei milliseconds.
.
.
solstice continuous testing case study one of the authors used the solstice continuous testing plug in solstice ct in a personal b ibtex management project consisting of java kloc.
before starting using solstice ct the project was exhibiting runtimeexception crashes on a specific input.
the case study took place while removing the bug that was resulting in this crash by writing tests and using solstice ct. the bug turned out to figure continuous findbugs running on v oldemort.
both images show the top four warnings.
the left screenshot shows the original v oldemort implementation its first findbugs warning suggests that .equals .. is too restrictive.
the developer changes .equals .. with instanceof right screenshot and the top warning disappears without the developer saving the file or invoking findbugs.330figure continuous pmd running on v oldemort.
both images show the top four warnings.
the left screenshot shows the original v oldemort implementation its second pmd warning suggests that the parentheses around neware unnecessary.
the developer removes these parentheses right screenshot and the second warning disappears without the developer saving the file or invoking pmd.
be significant and required an extension to the project s architecture and writing more than loc.
the case study lasted for days and resulted in a successful removal of the bug.
at the start of the case study the subject program had no tests.
the author wrote two tests a regression test to validate that nothing was broken while fixing the bug and another test for the failing input to observe the presence of the bug.
the case study led to the following observations .solstice ctcan speed up discovering unknown bugs the subject program parsed several files specified as program arguments.
when the specified path did not exist the program threw a filenotfoundexception .
this behavior made the program fragile crashing on invalid or improperly formatted arguments instead of failing gracefully.
this bug was unknown prior to the case study.
the author discovered this bug early right after starting implementing the regression test by initially entering an invalid path and before encoding the rest of the test.
this intermediate step during writing the test caused the regression test to fail with a filenotfoundexception .
consequently the author was able to detect and fix this bug immediately as opposed to after implementing the entire test.
because the test needed to encode the expected output and that output was large solstice ctcaused the bug to be discovered much earlier than it would have been through traditional testing.
.solstice ctmakes debugging information available sooner while debugging developers often use print statements to view the intermediate program state and assist in understanding the behavior of faulty executions.
based on self discovered feedback during this case study we augmented solstice ctto make the continuous testing console output and error streams available to the developer.
as a result the developer was able to get near instant feedback on how changes to the code affected the print statements even if the changes did not affect the test result.
the author felt this information significantly simplified the debugging task.
.solstice ctis unobtrusive in the course of this albeit small case study the author never experienced a noticeable slowdown in eclipse s operation and never observed a stale or wrong test result.
.
discussion there are ways other than maintaining a copy codebase to convert offline analyses into continuous ones.
very fast offline analyses can run in the ide s ui thread.
while technically such an analysis would block the developer because of its speed the developer would never notice the blocking.
of course having a negligible running time is infeasible for many analyses.
it is possible to reduce the running time of offline analyses by making them incremental .
an incremental code analysis uses the analysis result on an earlier snapshot of the code and the editsmade since that snapshot.
there are many examples for incremental analyses such as differential static analyses differential symbolic checking and incremental checking of data structure invariants .
when the differences are small incremental analyses can be significantly faster.
with this speed increase incremental analyses may be used continuously by blocking the developer whenever the analysis runs.
incremental code compilation is one such popular incremental continuous analysis integrated into many ides.
however many analyses cannot be made incremental efficiently because small code changes may force these analyses to explore large distant parts of the code.
further making an analysis incremental can be challenging requiring a complete analysis redesign.
the process is similar to asking someone to write a greedy efficient algorithm that solves a problem for which only an inefficient algorithm that requires global information is known.
for some such analyses e.g.
analyses that solve np complete problems this task is likely impossible unless p np .
while many analyses cannot be made incremental or efficient enough to run continuously while blocking the developer those that can still benefit from being built using solstice.
an impure analysis is freed from the burden of maintaining a copy codebase manually or through working copies as solstice maintains the copy codebase and lets the analyses own it exclusively.
for many analyses the slightly stale results of recent development snapshots are useful.
for example the test results of a development snapshot from several minutes ago could help the developer realize a test failure that otherwise would not surface until the next scheduled test run.
for such slow analyses solstice allows processing recent snapshots and producing results whereas other approaches would invalidate the result with every edit.
.
related work ide integrated continuous analyses are not new.
incremental code compilation has been integrated in most modern ides such as eclipse5.
eclipse java compiler warnings and errors6 including the nullness type system are closely integrated into the incremental compiler.
these continuous analyses are implemented by the ide developers.
for third party analyses eclipse provides project builders an analysis author can implement the analysis logic as a project builder extension so that the analysis is executed with each incremental build.
eclipse findbugs checkstyle and metrics plug ins are example continuous analyses imple5 preferences java compiler ref preferences errors warnings.htm331figure continuous testing running on apache commons.cli.
the left screenshot shows the original commons.cli implementation for which all tests pass.
the developer defines the id of an option to be its second character right screenshot and immediately sees that this change causes an existing test to fail.
mented using project builders.
solstice and its api provides a richer alternative way to integrate third party analyses into the ide.
in addition to project builders eclipse and some other ides provide the analysis authors with a working copy7 the in memory state of a compilation unit e.g.
a java file .
working copies are useful for fast impure analyses that make small changes such as refactoring quick fix and auto complete.
the analysis authors can modify a compilation unit without changing the developer s copy.
the developer changes to the same compilation unit are reported to the working copy and the analysis author may reconcile the working copy with the developer s copy.
solstice in some sense elevates the working copy concept to the workspace level with other features such as being able to access a stable development snapshot.
speculative analysis is a general concept of an impure analysis that calculates actions a developer is likely to perform soon performs those actions in the background evaluates the consequences of those actions and reports on those consequences.
speculative analysis over version control can identify and prevent collaborative conflicts by creating and managing a copy codebase for the analysis to use.
meanwhile speculative analysis over eclipse quick fixes creates and maintains its copy codebase inside the developer s workspace.
solstice removes the burden of creating and maintaining the copy codebase and relying on external operations from such impure analyses.
similarly live programming focuses on providing continuous feedback to developers for the tasks they are working on by making the behavior of a program visible as that program is being developed .
solstice enables continuous analyses that facilitate live programming practices.
integrating continuous analyses into the ide facilitates continuous development.
continuous development is not a new concept a programming environment modeled on spreadsheets can continuously execute the program as it is being developed .
similarly continuous testing executes the tests available for a program as it is being developed.
meanwhile continuous data testing applies the same ideas to data debugging discovering system errors caused by well formed but incorrect data .
while continuous testing is integrated into eclipse and intellij solstice provides a generic framework for converting offline analyses into continuous ones integrated into the ide.
contributions codebase replication is a novel approach for converting offline analyses that developers must run manually into continuous analyses that run constantly and always provide the developer with up to date results.
codebase replication solves two major challenges of building continuous analyses isolation andcurrency .
isolation requires that the analysis does not prevent the developer from making new changes and code changes made by an impure analysis neither alter the code visibly nor functionally while the developer is working.
currency requires that analysis results are made available quickly and that stale results are marked as stale.
to solve these challenges codebase replication maintains an in sync copy of the developer s codebase allowing multiple analyses to use and even temporarily exclusively own the copy.
codebase replication tracks developer changes at the buffer level works with analyses that require either source code or compiled binaries to run and can even be used to convert impure offline analyses into continuous ones.
solstice our prototype implementations of codebase replication facilitates converting offline analyses into continuous analysis eclipse plug ins.
we have used solstice to build three such proofof concept plug ins.
each plug in on average required writing only loc ncsl and took hours to write.
the solstice based plug ins incurred .
milliseconds overhead on the developer s ide and experienced a .
milliseconds delay before synchronizing the copy codebase with the developer s latest edits.
overall the cost to converting offline analyses to continuous ones with codebase replication is low as compared to the alternative of redesigning the offline analyses to work continuously.
further the benefits of continuous analysis tools greatly outweigh the cost of building them with codebase replication.
since continuous analyses reduce the delay between the time when a developer makes a change and when the effects and implications of this change become known by reducing the cost to implement ide integrated continuous analyses we believe codebase replication will bring more continuous analyses into existence.
consequently developers will no longer need to interrupt development to get analysis feedback.
instead continuous analysis feedback will be integrated into the software development process.
.