hal id hal submitted on nov hal is a multi disciplinary open access archive for the deposit and dissemination of scientific research documents whether they are published or not.
the documents may come from teaching and research institutions in f rance or abroad or from public or private research centers.l archive ouverte pluridisciplinaire hal est destin e au d p t et la diffusion de documents scientifiques de niveau recherche publi s ou non manant des tablissements d enseignement et de recherche fran ais ou trangers des laboratoires publics ou priv s. counterexample guided abstraction refinement of product line behavioural models maxime cordy patrick heymans axel legay pierre y ves schobbens bruno dawagne martin leucker t o cite this version maxime cordy patrick heymans axel legay pierre y ves schobbens bruno dawagne et al.. counterexample guided abstraction refinement of product line behavioural models.
fse international symposium on f oundations of software engineering nov hong kong hong kong sar china.
pp.
.
.
.
hal counterexample guided abstraction refinement of product line behavioural models technical report maxime cordy precise research center university of namur belgium mcr info.fundp.ac.bepatrick heymans precise research center university of namur belgium.
phe info.fundp.ac.beaxel legay inria rennes france axel.legay inria.fr pierre yves schobbens precise research center university of namur belgium.
pys info.fundp.ac.bebruno dawagne precise research center university of namur belgium.
bdawagne student.fundp.ac.bemartin leucker university of l beck germany leucker isp.uniluebeck.de abstract the model checking problem for software products lines spls is harder than for single systems variability constitutes a new source of complexity that exacerbates the state explosion problem.
abstraction techniques have successfully alleviated state explosion in single system models.
however they need to be adapted to spls to take into account the set of variants that produce a counterexample.
in this paper we apply cegar counterexample guided abstraction re nement and we design new forms of abstraction speci cally for spls.
we carry out experiments to evaluate the e ciency of our new abstractions.
the results show that our abstractions combined with an appropriate re nement strategy hold the potential to achieve large reductions in veri cation time although they sometimes perform worse.
we discuss in which cases a given abstraction should be used.
categories and subject descriptors d. .
software program veri cation model checking keywords software product lines model checking cegar abstraction features .
introduction variability is ubiquitous in today s systems be it in the form of con guration options or extensible architectures.
by fnrs research fellow permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong .mastering variability developers can adapt their system to changing requirements without having to develop entirely new applications.
software product lines spls are a popular form of variability intensive systems.
they are families of similar software systems developed together to make economies of scale .
spl engineering aims to facilitate the development of the members of a family called products orvariants by identifying upfront their commonalities and di erences.
variability in spls is commonly represented in terms of features i.e.
units of di erence between products that appear natural to stakeholders.
each product of an spl is therefore de ned by its set of features.
hierarchies of features and dependencies between features e.g.
requires excludes are typically captured in a feature model fm i.e.a tree like structure that speci es which combinations of features are valid see figure in section for an example .
nowadays spl engineering is widespread in industry including critical areas like automotive and avionics.
the emergence and the increasing popularity of spls have raised the need for spl speci c quality assurance techniques.
indeed engineers have to provide solid evidence that allthe products they build satisfy their intended requirements.
moreover in case of failure they should identify which features or combinations of features are responsible for the errors in order to facilitate repair.
model checking is an automated technique to verify a behavioural model of a system against a property expressed in temporal logic .
it relies on an exhaustive exploration of the model in search for counterexamples i.e.
executions that violate the property to verify.
due to its exhaustiveness model checking is costly in time and memory.
when applied to real systems with a typically huge state space model checking faces a combinatorial blow up called state explosion .
the model checking problem is even harder for spls in this case the model checker must either prove the absence of errors or nd a counterexample foreach variant that can produce a violation.
given that the worst case number of products of an spl is exponential in the number of features variability dramatically exacerbates state explosion.
as a consequence it is not feasible to apply single system model checking to the thousands ofvariants that can compose real world spls.
in recent years many variability aware techniques have been designed to address the spl model checking problem .
these techniques keep track of variability information contained in an spl behavioural model to associate each execution path to the exact set of variants able to produce it.
by so they are able to identify the set of products that violate a given property and to report a counterexample of violation for each of them.
moreover being aware of variability allows them to check behaviour common to several products only once.
this is a clear improvement over an enumerative application of single system model checking which veri es a behaviour as many times as there are products that can exhibit it.
although earlier experiments suggest that these techniques bring substantial performance gains further improvements are required to verify industrial spls.
first spl model checking methods still su er from the state explosion problem inherent to model checking.
second their practical time complexity still grows more than linearly with the number of features .
in single system veri cation one of the most e ective answers to state explosion is model abstraction which creates more concise therefore easier to verify models of the system typically by merging similar states.
this reduced size often comes at the cost of inaccuracies in the models thereby a ecting the properties they satisfy.
a reported counterexample can therefore be spurious that is it exists within the abstract model but the not in the real concrete model.
in this case the abstraction must be re ned to eliminate this false positive.
common methods to achieve this re nement make use of the spurious counterexample itself.
they give rise to counterexample guided abstraction re nement cegar i.e.abstraction techniques that iteratively re ne an abstract model until either they nd a real counterexample or they can prove the absence of violation .
in spite of their success in single system model checking abstraction techniques for spls have received little attention see more in section .
in this paper we ll this gap and propose spl speci c abstraction procedures based on cegar.
applying cegar to spls is more tedious because a counterexample can be real for some products and spurious for others.
this observation leads us to two re nement strategies one re nes the model as soon as it nds a spurious counterexample whereas the other performs the spuriousity check and the re nement after the discovery of all the counterexamples.
as for the abstraction of the model we distinguish between state abstraction that only merge states as in single model abstraction feature abstraction that modi es only the variability information contained in the model and mixed abstraction that combines the previous two types.
this latter type is the most complicated to implement as spuriousness can originate from the merging of states the abstraction of features or both.
throughout the paper we systematically prove the correctness of our approach on the basis of mathematical relations such as simulation relations.
we implemented both abstractions and their combination in provelines an spl model checker we developed .
we carried out experiments to evaluate the e ciency of di erent combinations of re nement strategies and abstractions.
our results tend to show that state abstraction brings performance gains most of the time whereas feature abstraction generally results in small losses 87513closechangesodaservesoda2payopenfigure a ts modelling a vending machine of performance but achieve huge decreases of veri cation time in some cases.
preliminary experiments on mixed abstraction tend to show that its performance is comparable to that of state abstraction although slightly worse on average.
other abstractions of this kind could however be designed as part of future work and yield better results.
the structure of the paper is as follows.
section recapitulates essential background.
we present an overview of our cegar procedures and re nement strategies in section .
in section we show how to build the three forms of abstraction functions and to detect spurious counterexample in each case.
we describe our implementation and report evaluation results in section .
finally we discuss related work in section .
.
background in this section we recapitulate established concepts related to the veri cation and abstraction of single system behavioural models.
we also recall some de nitions of our previous work that are needed in this paper.
.
counterexample guided abstraction refinement model checking is an established technique for verifying both hardware and software against temporal properties .
basically given the model of a system mand a temporal property a model checking algorithm determines whether or notmsatis es written mj .
for single systems a transition system ts is commonly used as a model for the system.
it is de ned as follows.
de nition a ts is a tuple s act trans i ap l wheresis a set of states actis a set of actions trans s act sis the transition relation i sis a set of initial states apis a set of atomic propositions and l s!2ap is a labelling function that associates every state with the set of atomic propositions satis ed by this state.
we assume that every ts has no terminal state i.e.
a state without outgoing transition.
figure shows a ts representing a soda vending machine.
for clarity we did not display the atomic propositions satis ed by each state.
in what follows we also denote s s0 2trans bys !
s0.
an execution of the model is an alternating in nite sequence of states and actions that satis es the transition relation i.e.a sequence s0 0s1 withsi i !si 1for any i .
a trace also called behaviour of the system is the sequence of atomic propositions satis ed during one of its executions.
the semantics of a ts noted ts is then its set of behaviours ts fl s0 l s1 js02i si i !si g after building a ts one can verify it against a property expressed in temporal logic.
in this paper we particularly focus on linear time logic ltl .
for instance a desired property for the vending machine is that itwill eventually serve soda each time soda is ordered noted sodaordered sodaserved in ltl.
given a ts and a property a model checker reports either that the property holds in the model or a counterexample i.e.an execution of the model that violates the property.
in our example the ts indeed satis es the aforementioned property since it will necessarily reach state after state .
ts can model a software product at di erent abstraction levels.
if a more abstract that is smaller model preserves the properties of a larger model it is more e cient to check the properties on the abstract model.
it is therefore essential to relate two models from di erent abstraction levels.
for single systems this information is formally captured by a simulation relation .
de nition lettsi si transi ii ap li i2 f1 2gbe two ts over ap.
a simulation for ts1 ts is a binary relation r s1 s2such that .8s12i1 9s22i2 s1 s2 2r and .
s1 s2 2r it holds that l1 s1 l2 s2 and8s0 post s1 9s0 22post s2 s0 s0 2r.
wherepost s fs0j9 s !s0gdenotes the set of states that can be reached from s. then ts2simulatests1 denoted byts14tsts2i there exists a simulation for ts1 ts .
according to this de nition if ts2simulatests1 thents2 can reproduce any behaviour of ts1.
simulation can characterise the behaviour of an abstract transition system bts with regard to an original model ts.
informally an abstract transition system is obtained by merging states for which a so called abstraction function returns the same value.
the abstraction may add or remove behaviour depending on the chosen abstraction function.
however a relevant analysis requires to have either ts4tsbts bts4tstsor both.
under this condition the abstraction preserves the un satis ability of properties expressed in particular logics.
in particular an ltl formula satis ed by the simulating ts is preserved in the simulated one.
property letts1andts2be two transition systems and an ltl property.
then ts14tsts2 ts2j ts1j in other words if ts1does not satisfy neither does ts2.
in particular if ts2is an abstraction of ts1 proving that the abstract ts2veri es an ltl formula su ces to ensure that the formula holds for ts1.
therefore abstraction can drastically shorten the time and space cost of veri cation.
in this paper we consider existential abstraction functions.
de nition an existential abstraction his a surjectionh s!bssuch thath s h s0 l s l s0 .
an abstraction of a ts under histsh bs act transh ih ap lh wherebs fh s js2sg ih fh s0 js02ig lh h s l s andtranshis de ned such that s !s0 h s !h s0 .
existential abstractions can facilitate veri cation thanks to two interesting properties.
first tshis such that ts4ts tsh .
second they can be de ned such that bsis signi cantly smaller than s. therefore for a given ltl formula we can prove that the concrete ts satis es by 876513cancel creturn cclosechangefree fsoda sservesoda stea t24servetea tpay fopenfigure a fts modelling a vending machine spl proving that tshsatis es .
however if tshdoes not satisfy then tsmay still satisfy that is the reported counterexample is spurious .
this may occur when tshhas strictly more behaviour than ts.
in this case it is required tore ne the abstraction in order to eliminate the spurious counterexample.
from the re nement we obtain a new abstraction function h0which is less coarse than h that is ts4tstsh04tstsh.
counterexample guided abstraction re nement cegar is an established re nement method that consists in using a spurious counterexample to re ne the abstraction .
from the concrete ts we build an initial abstraction based on a given existential abstraction function.
we then feed the abstract model into the model checker together with the property to check.
if the abstraction satis es the formula then so does the concrete ts.
otherwise we replay the counterexample on the concrete system to determine whether it is spurious.
if it is not then the concrete ts violates the formula.
otherwise we re ne the abstraction on the basis of the counterexample and we repeat the process.
.
featured transition systems although ts are suitable to model the behaviour of individual systems they cannot represent the behaviour of an spl and link each behaviour to the exact set of products able to execute it.
to overcome this we de ned featured transition systems fts .
basically an fts is a ts where each transition receives an additional label that speci es which combinations of features are required to trigger the transition.
these features are declared in an fm that establishes the set of legal feature combinations i.e.
thevalid products of the spl.
for this paper it is enough to know that the semantics of a fm dde ned over a set of featuresfis the set of all the valid products that is a set of sets of features denoted by fm 2f.
for a more formal de nition of fms see schobbens et al.
.
formally fts are de ned as follows.
de nition an fts is a tuple s act trans i ap l d wheres act trans i ap l are de ned as in de nition dis a fm over features f and trans!b f is a total function labelling each transition with a feature expression i.e.
a boolean function over the set of features.
by t we denote the set of products that satisfy t .
figure shows an fts modelling a vending machine spl which includes the vending machine presented in figure .
we observe that transition 1free !
is labelled with feature f meaning that feature fis required to trigger the transition.
on the contrary 1pay !
is labelled with f meaning that feature fmust not be present to trigger the transition.
note that a feature model can also be regarded as a feature expression i.e.
the formula encoding all the constraints it expresses.
henceforth we use dto denote this feature ex vendingmachinevteatfreedrinksfcancelpurchasecsodasbeveragesblegend aa and ora optionalproducts from figure a basic v b s b tea and soda v b s t c cancel function v b s c d soda for free v b s f figure the fm modelling the variability of the vending machine spl pression as well.
thanks to the labelling function an fts encodes the behaviour of a set of products.
more precisely the ts modelling a given product p notedftsjp is obtained by removing all the transitions that pcannot execute.
this operator is called projection .
for instance the ts shown in figure is the projection of the vending machine fts onto product fv sg.
the semantics of an fts noted fts is therefore a function that associates each valid product with the semantics of the projection of the fts onto that product.
in this paper we use fts to model the behaviour of spls being a fundamental formalism it can be regarded as a uni ed semantics for higher level spl behavioural modelling languages.
the model checking problem for spls is di erent from its single system counterpart.
its objective is indeed to identify allthe product variants that can execute a counterexample.
we previously designed e cient algorithms to check an fts against ltl formulae .
during an exploration these algorithms keep track of the feature expressions met along the transitions.
this means that they separate the verication of di erent sets of products only if they discover a behavioural discrepancy between them.
this optimisation is called late splitting .
furthermore the accumulated feature expressions allow to associate a found counterexample to the exact set of products that execute it.
an immediate consequence is that the model checker may have to discover multiple counterexamples to identify all the violating products.
unlike single system model checking the search thus cannot stop after one counterexample is found.
this is a fundamental di erence that has a real importance in the design of abstraction methods for spl model checking.
it may happen that a property is relevant only to a subset of the products.
hence we extended ltl with a feature quanti er .
a formula of the resulting logic called fltl has the form where is a feature expression and is an ltl formula.
intuitively it means that has to hold only for valid products described by .
formally the set of products satisfying is fp2 fmjp2 ftsjpj g as a simulation relation is a prerequisite to prove the correctness of abstraction based model checking we need to extend this concept to make it applicable to fts and aware of variability.
this new relation named f simulation is de ned as follows.
de nition letftsi si acti transi ii ap li d i i2f1 2g be two fts.
then the set of valid products for whichfts 1is simulated by fts is fp2 fm fts 1jp4tsfts 2jpg fts 1is simulated by fts 2i fm.
iffts 2simulatesfts then for each valid product pevery behaviour of pinfts 1is also a behaviour of pinfts .
therefore any fltl formula satis ed in fts 2is also satis ed in fts .
e cient computation algorithms are found in .
for this paper we just need its de nition.
.
cegar strategies in spl model checking the only way to apply existing abstraction techniques to spls is to execute them either product by product or on a product simulator .
these methods thus cannot address the spl model checking problem as we de ned it in the previous section.
there are two fundamental di erences between single system and spl model checking.
first a model for multiple products viz.an fts is checked as opposed to a single system model viz.a ts.
this implies that an appropriate abstraction function must preserve the behaviour of all the products modelled by the fts and this function can modify the labelling function .
to produce fts abstractions we can thus either merge states as in single system abstraction weaken feature expressions to make transitions available to more products or both.
these three solutions shown in figure are respectively called state abstraction feature abstraction and mixed abstraction .
a second requirement is that the cegar process cannot stop after only one real counterexample is found if this counterexample is not executable by all products.
if it does stop the model checker could ignore violations performed by other products the spl model checking problem would thus not be answered appropriately.
to address these requirements we rst extend the de nition of existential abstraction a common abstraction method that does not remove existing behaviours and we provide property preservation proofs.
then we present two spl speci c cegar procedures that can verify all the products.
as before we consider existential abstraction functions as these guarantee behaviour preservation.
to transpose this concept to fts while maintaining the preservation property we add another requirement to the abstraction function any product that can execute a concrete transition must be able to execute the corresponding abstract transition.
this leads to the following new de nition of existential abstraction.
de nition an f abstraction is a surjection h s!bs such thath s h s0 l s l s0 .
an abstraction of a fts under hisftsh bs act transh ih ap lh d h wherebs act transh ih ap lhare as in de nition and his such that s2h bs s02h bs0 s !s0 s s0 h bs bs0 or equivalently s2h bs s02h bs0 s !s0 s s0 h bs bs0 87513cancel creturn cclosechangefree fsoda sservesoda stea t24servetea tpay fopen a state abstraction 876513cancelreturnclosechangefreesodaservesodatea24serveteapayopen b feature abstraction 87513cancelreturnclosechangefreesodaservesodatea24serveteapayopen c mixed abstraction figure examples of the three forms of abstraction.
intuitively his responsible for state abstractions whereas hcreates feature abstractions.
any fts obtained from an f abstraction simulates the concrete fts for all products.
theorem lethbe an f abstraction function.
then we have fm.
proof.
since existential abstractions from ts preserve the behaviour of the concrete ts modulo simulation see section any given transition of fts is also a transition of ftsh.
it thus remains to prove that this transition is available inftshfor at least the same set of products that is for any states s s0we have s s0 2transjp bs bs0 transh jp wheretransjpand transh jpdenote the transitions of ftsjp and ftsh jp respectively.
this property directly follows from the de nition of h s s0 s !s0 s s0 h bs bs0 s s0 s !s0 s s0 h bs bs0 s s0 s !s0p2 s s0 p2 h bs bs0 8s s0 s s0 2transjp bs bs0 transh jp withs2h bs ands02h bs0 .
hence fts4fts ftsh fm.
we are now ready to present our cegar procedures for fts.
given that an fts model checker may return several counterexamples two re nement strategies can be followed.
the rst strategy called find all before re ning fabr consists in waiting for the model checker to nd all the counterexamples it should return then checking the spuriousity of each of them and re ning the model if need be.
conversely the second strategy re ne when found one rwfo checks spuriousity and possibly re nes the model as soon as the model checker nds one counterexample.
build initialabstraction model checker satisfying products are spurious?
re f ine abstraction fmviolating products counterexamplesspuriouscounterexamplesupdate propertyreal violatingproducts is quanti f ier satis f iable?violating productsnoyes satisfying productsfigure overview of fabr figure gives an overview of fabr.
first we apply an initial f abstraction h h to obtain an abstract fts which is given to the model checker along with the fm and an fltl formula .
the initial abstraction is built according to a chosen abstraction technique see section .
the model checker returns the set of products satisfying the formula and the set of products violating the formula together with counterexamples.
we then check whether some of these counterexamples are spurious.
if that is the case we re ne the abstraction to build a new f abstraction h0 h0 such that fm 2a fm 2b fm 2c and we verify ftsh0against the property.
during this new search we can safely ignore the products that were previously recognized as satisfying.
indeed by de nition of f simulation any product that satis es inftshalso satis es the formula in ftsh0andfts .
we can also ignore products that can execute a realcounterexample since the new check will report them as violating as well.
to prevent the model checker to consider these products it su ces to transform the feature quanti er into where is the feature expression characterizing the products to ignore.
we repeat the process until the model checker returns no spurious counterexample or equivalently while the updated feature quanti er 0is satis able.
as a result we pinpoint the products that satisfy the formula and those that do not.
the rwfo strategy is illustrated in figure .
as before we build an initial abstraction and model check it.
if all the products satisfy the formula we stop.
otherwise we stop the veri cation as soon as the model checker nds a counterexample.
if this counterexample is spurious we re ne the abstraction and start the model checking again.
otherwise we update the formula to ignore the products that can execute the counterexample.
if the resulting feature quanti er 0is satis able we carry on the veri cation procedure from when the counterexample was found .
we repeat the process until there is no more counterexample or the feature quantier becomes unsatis able.
in the latter case it means thatbuild initialabstraction model checker satisfying products... fm is spurious?
re f ine abstractionnoyes counterexampleupdate propertyis quanti f ier satis f iable?
all products violatenoyes figure overview of rwfo all the products violate the formula.
the following theorem establishes the termination and the correctness of our cegar strategies.
theorem lethbe an existential abstraction function andh0be a re nement procedure.
for any fts if equations hold then the cegar strategies terminate are sound and are complete.
proof .
termination at the end of a veri cation the cegar procedures either terminate update the feature quanti er into or trigger a re nement.
given that the number of updates is nite.
by equations the number of re nement is also nite.
correctness letpbe a valid product.
after a veri cation three cases may occur .pis reported as satisfying the formula.
by de nitions and psatis es the formula in the concrete fts as well.
.pis associated to a real counterexample and thus violates the formula in the concrete fts as well.
.pis associated to spurious counterexamples only.
in this case pwill be checked again after the re nement.
furthermore the de nition of 0guarantees that only products that are known to satisfy or violate the formula are ignored in upcoming veri cations.
the strategies are agnostic to the actual abstraction and re nement functions being used as long as these satisfy definition and equations .
in the following section we show how to actually build di erent types of abstraction from a concrete model.
.
building fts abstractions existing abstraction techniques generally do not work directly on ts.
instead they rely on higher level representations that include an explicit notion of variable .
these are commonly named program graphs .
in the context of spls the products will be represented by a set of programs that share commonalities.
in order to specify all these programs in a single compact model one can borrow the concept of feature expression introduced in fts and apply it to program graphs .
de nition recalled from let v fv1 vngbe a set of variables v!types a type function pred v the set of predicates over v asgn v the set of assignments overv andeval v1 vn v1 vn the set of variable valuations.
a featured program graph fpg is a tuple loc v act loc init trans d whereloc is a set of locations act pred v asgn v is the set of actions loc 0is the initial location init eval v are the set of possible initial valuations trans loc act loc is the transition relation dis an fm over features f and trans!b f associates each transition with a feature expression.
one can de ne the semantics of an fpg in terms of fts see for details .
intuitively given an fpg the state space of the underlying fts is loc eval v that is an fts state is de ned as a location and a variable valuation.
the set of initial states is loc init.
transitions are determined according to the variable values of source state as well as to the predicates and assignments that label the transitions of the current fpg location.
formally the transition relation is the smallest relation satisfying lp !l0 vj p l v p !
l0 v lx expr !l0 v0 v l v x expr !
l0 v0 where visvafter assigning to xthe value given byexpr andpis a predicate over the variables.
given a formula to check the set apof atomic propositions is the set of predicates over vthat occur in the formula.
feature expressions are directly obtained from .
in what follows we interchangeably use to denote the transition labelling function of both an fpg and its underlying fts.
we now present two families of methods to build and re ne abstractions of fpg and discuss their implications on the cegar strategies presented above.
.
feature abstraction the rst abstraction type we propose consists in abstracting from the variability between the products.
concretely we replace each feature expression t labelling a transitiontby another feature expression h t such that t h t .
the set of states and transitions are however left untouched.
the existential abstraction is thus de ned as h s!s h s s. this transformation does not remove behaviours from the products by de nition and theorem .
for the initial abstraction we propose to completely abstract all the feature expressions of the fpg that is each of them is replaced by .
this comes down to associating to every product of the underlying fts s act trans i ap l d the semantics of the ts s act trans i ap l .
an undeniable advantage of this abstraction is that singlesystem model checking algorithms can perform the veri cation.
if the initial abstraction satis es a given formula then all the products satisfy it.
otherwise the model checker returns a counterexample.
given that the f abstraction did not modify the state space the counterexample is necessarily an existing execution in the aforementioned ts.
it may happen that no product can execute it e.g.
due to incompatible feature expressions though indeed the ts semantics subsumes the union of the semantics of the projection of the fts onto all valid products .
for instance an execution that triggers transitions tandt0 with t t0 would be executed in the abstract fts but not in the concrete fts.
even if at least one product can execute thecounterexample it does not mean that all the products can.
more generally if bh resp.b is the feature expression characterizing the set of products that can execute the counterexample in ftsh resp.fts then the counterexample is spurious for products in n .
if the counterexample is spurious for at least one product the abstraction must be re ned.
here the re nement consists in replacing the abstract feature expression of each fpg transition that is executed during the counterexample by its concrete feature expression.
this implies that for each fts transition t the feature expression labelling t noted h0 t is such that h0 t h t .
hence the resulting abstraction function h0guarantees that ftsh04fts ftsh fmand fmwhere his the initial f abstraction.
since we updated the feature expression of at least one transition it follows that fm.
equations are thus satised which guarantees the termination and the correctness of the aforementioned cegar procedures.
.
state abstraction unlike the rst one the second abstraction type relies on transposing the principles of classical abstraction functions to spl cegar.
more precisely we consider predicate abstraction one of the most applied methods for program abstraction .
let pred fp1 png pred v be the set of predicates that occur in the fdg or in the formula to check.
let h loc eval v !
loc 2pred be an existential abstraction function such that h l v l fpi2pred vj pig .
intuitively fdg locations are preserved in abstract states but a variable valuation is abstracted by the exact subset of predicates it satis es.
since the predicates of the formula to check are included in pred and thus contribute to the de nition of h we haveh s h s0 l s l s0 andl h s l s .
the abstract transition relation transhis de ned as the smallest relation satisfying lp !l0 p2p l p p !
l0 p lx expr !l0 wp x expr 6j ?
l p x expr !
l0 p0 where v p2pp v q2prednp qandwp x expr is with each occurrence of xreplaced by expr.
intuitively p0is the set of predicates that are satis able after assigning expr toxgiven that every predicate in pwas satis able before the assignment and that every predicate not in p was not satis able.
in this abstraction we do not change the feature expressions that is h t t for any transition t. therefore we have fm.
technically the de nition of state abstraction is very similar to state of the art predicate abstractions.
the di erence rather lies in the detection and the analysis of counterexamples which now depends on variability.
indeed the notion of spuriousness is more subtle in this case.
first a spurious counterexample may not correspond to an existing sequence of transitions in the concrete fts.
second it can be an existing execution but only for a subset of the products.
we thus propose a method to detect spurious counterexamples that can be represented as nite sequences.
this method is inspired by the splitpath algorithm used in single system cegar .
it consists in identifying a set of states whosemerging has yielded a spurious counterexample and then splitting this set so as to make the counterexample disappear.
we can also extend our technique with support for any kind of counterexample using unwinding techniques along the lines of clarke et al.
.
the key idea of our method is to remember while replaying the counterexample for which products we can execute each step of the replay.
formally let h s0 h sm be a counterexample and bthe feature expression characterizing the products able to execute it.
let s0 f i ji2igand si f s b 2h h si b f j s0 b0 2si b b0 s0 i !s s0 i s g intuitively if s b 2sithenscan be reached by products in by replaying the rst isteps of the counterexample.
if for a productpthere does not exist s b 2siwithp2 then pcannot execute the counterexample.
thus is spurious for productsfp2 j s b 2sm p2 g or equivalently b w s b 2smb .
we also name these products spurious.
the correctness of this detection procedure is derived from the proof of splitpath and the de nition of projection .
to re ne the abstraction we rst have to identify the execution steps during which products are discovered not to be able to execute the counterexample.
let b0 i present the products that can execute the counterexample in the concrete fts up to step i with b0 .
then for any i the feature expression b b0 i characterizes the products that are spurious at step i and b b0 i b0 i represents the products that became spurious exactly at step i. if the latter feature expression is satis able a re nement should be performed at step i. in predicate abstraction a re nement consists in adding a new predicate in the construction of the abstraction function.
an abstract state will therefore contain more information and the abstraction function will be able to produce ner abstractions.
the predicate to add can be determined by means of craig interpolation .
given two formulae and with j ?
a craig interpolant is a formula 0written using the intersection of the vocabularies of such that 0and j ?.
loosely speaking 0can be seen as an explanation of why is not satis able.
the occurrence of a spurious product means that the abstraction has created a transition between a state si2si and a state si 12si 1that does not actually exist.
to eliminate this spurious counterexample the new abstraction has to make the distinction between siand the states insithat actually have a transition to si .
we thus compute a craig interpolant betweenv v2vv eval si v andw sj sj !si v v2vv eval sj v .
this yields the new predicate to add as a re nement to the abstraction.
once the re ned abstraction is obtained we perform a new verication limited to the spurious products.
leth0be the re ned abstraction yielded by that method.
thenh0 s h0 s0 h s h s0 and the abstract transition relation in ftsh0is ner than in ftsh.
furthermore the re nement method removes from at least one product the ability to execute the ith step of the spurious counterexample.
hence equations hold.
.
mixed abstractiongiven that the above two abstraction methods do not modify the same constructs we can combine them to form coarser abstractions.
thereby we obtain an initial existential abstraction function has de ned in subsection .
together with an abstract labelling function has presented in subsection .
.
although the construction of the abstraction is straightforward the detection of spurious counterexamples and the re nement process become more complex.
indeed spurious products may originate from di erent factors viz.the abstraction of feature expressions the predicate abstraction or their combination.
this raises the questions of how to associate spuriousness cases with their appropriate origin s and how to guide the re nement process in case of multiple origins.
as before we will compute sets of states sithat give the states that can be reached upon the execution of the rst i steps of the counterexample together with the products able to reach them.
the actual de nition of siis as previously.
however since we have to take into account that feature expressions are abstracted as well the detection algorithm should determine the reason why a product became spurious and re ne either the labelling function or the state space abstraction.
procedure isspurious formalizes our detection and re nement method.
it consists in replaying the counterexample step by step and check during each step whether we discover spurious products lines .
at each iteration b represents the products that violate the property in ftsh and have not been discovered to be spurious whereas b0 represents the products that can execute the counterexample inftsup to the current step.
for a given step i we rst check whether there are new spurious products due to the abstraction of feature expression lines .
to achieve that we compute the feature expression that would label the abstract transition should the feature abstraction not have been applied add it to b0and compare the result with b. the condition at line means that any product in n is a spurious product.
if there is at least one such product a re nement of the feature abstraction function is needed.
accordingly we modify the feature expression labelling the abstract transition.
next we check whether predicate abstraction yielded additional spurious products at step iby using the method presented in subsection .
lines .
if it did lines we compute and register the interpolant that will act as a re nement of the current predicate abstraction.
the algorithm ends up returning either true if no re nement was needed or a new f abstraction together with the set of really violating products lines .
this f abstraction is built according to the re nement procedures of the previous two abstractions.
.
implementation and ev aluation in order to compare and evaluate the potential bene ts of our cegar procedures and our f abstractions we implemented them on top of our previous model checking algorithms .
in this section we describe our implementation present the results of experiments we carried out and attempt to infer general cases where it is particularly rewarding to apply cegar instead of standard fts algorithms.
provelines is a product line of model checkers for spls which constitutes the realization of a four year re input ftsandftshsuch that fm a quanti er bs0 csmand b2b f such that 2prefix ts for allp2 .
output true if 2prefix ts for all p2 h0 b0 such that equations hold and 2prefix ts for all p2 otherwise.
b0 d 2refined ?
3pred0 pred h0 h 5fori 1tomdo h0 dsi i bsi w si 12h dsi si2h bsi si i si b0 b0 h0 dsi i bsi if b6 b0then h dsi i bsi h0 dsi i bsi b b b0 11refined end b0 b0 w s b 2sib if b6 b0then 15pred0 pred0 fcraig dsi i bsi g b b b0 17refined end 19end 20ifrefined then h0 h0 abstract fts h pred0 h0 return h0 h0 23else return 25end procedure isspurious fts ftsh b search e ort.
it allows one to verify the behaviour of an spl modelled as an extension of fts against properties expressed in di erent logics.
the variants of provelines are semi symbolic model checkers they encode the spl products symbolically as feature expressions but explore the state space explicitly.
among the input languages accepted by provelines one nds fpromela a feature aware extension of promela .
fpromela provides constructs to declare variables and statements as well as to label the latter with feature expressions.
it can thus be regarded as a concrete syntax for featured program graphs and is consequently appropriate as an input to our cegar procedures.
on the basis of our implementation we carried out experiments to evaluate in which cases and to what extent our cegar based veri cation methods are more e cient than a plain application of the fts algorithms presented in our previous work .
the bene ts of cegar originate from two factors.
first the existential abstraction reduces the size of the state space and thus the number of states to explore before discovering a counterexample.
second the abstraction of feature expressions increases the commonality between the behaviour of the products and thereby augments the potency of spl speci c optimizations such as late splitting see section .
however the approximation due to abstraction and the consequent needs for re nement maycancel these bene ts or even worsen the veri cation time.
indeed after applying a re nement a completely new veri cation must be performed on the re ned model.
after several re nements the number of states explored by all the veri cations altogether can exceed that of the standard algorithms.
the performance of the cegar procedures thus depends on several factors including the topology of the model the chosen f abstractions and the property.
as an attempt to estimate the impact of these factors we computed the time needed by both cegar strategies combined with di erent f abstractions and implemented on top of the fts algorithms to verify three systems against a set of properties.
we systematically compare the results with the time needed by the fts algorithms without cegar to verify the same systems against the same properties.
the rst system is a minepump system spl which has to draw water from a mine while there is no methane within it see for more information .
this spl consists of features and valid products.
to explore the fts modelling its behaviour visiting states is required.
the second spl is an elevator model inspired from plath and ryan .
it is composed of eight features which can be combined into di erent products and its fts has states to explore.
the third and last spl is a case study inspired by the ccsds file delivery protocol cfdp which has been reengineered as a product line .
the fts modelling the protocol consists of states to explore and products.
we focus rst on the minepump spl.
we checked the corresponding fts against properties including deadlock freedom safety and liveness properties.
due to lack of space we do not display detailed results for the other properties and case studies.
however all the results together with our case studies and implementation are available on our website1.
all benchmarks were run on a macbook pro with a ghz intel core i7 processor and gb of ddr3 ram running mac os .
.
we coded an automated script to execute them.
to avoid random variations we repeated each experiment ve times and computed the average.
we discuss the results in terms of speedup i.e.
the veri cation time using a given abstraction divided by the veri cation time of the standard fts algorithm.
the veri cation time includes the time to parse the fpromela model to build the initial fts and to run the veri cation procedure.
the results are presented in figure which shows the speedup of each cegar strategy and abstraction with respect to the standard algorithm.
when feature abstraction is applied together with the fabr strategy the model checker performs signi cantly better than the standard fts algorithm i.e.
with a speedup comprised between .
and .
in ve cases out of it has almost no e ect speedup between .
and .
in eight cases and it performs slightly worse speedup between .
and .
in the last seven cases.
the results are very similar when the rwfo strategy is followed instead.
in both cases after an in depth analysis of the returned counterexamples we noticed that the cases where the abstraction does not improve the performance occur when every feature has to be known for the counterexamples to be triggered.
this means that after several re nements the model checker ends up verifying the original concrete fts.
the small loss of performance is to the veri cations performed before the last re nement.
an impressive speedup of more than nine is achieved when the property is satis ed by all products three cases when only a few features are needed to nd the counterexamples three cases the abstraction still brings nice performance gains speedup between .
and .
.
a change of strategy brings but small variations in the result this factor thus does not seem to impact the overall e ciency of feature abstraction.
the topology of the system however substantially a ects the e ciency of this form of abstraction.
in the elevator system each feature leads to behavioural variations that occur at the beginning of the execution of the system yet all the products have a lot of common behaviour.
this implies that late splitting occurs early in the veri cation and that the algorithm has to explore more than once a large part of the state space.
by abstracting feature expressions we can drastically reduce these re explorations.
concretely the abstraction performed signi cantly better when verifying six properties out of achieving impressive speedups .
and .
in the two cases where the property is satis ed by all products.
in these cases the veri cation time was reduced from .
and .
to .
and .
seconds respectively.
as for the remaining properties almost no variation with respect to the standard algorithm were reported.
on the contrary the cfdp case study gives a lot of trouble to feature abstraction.
the fts modelling the protocol is uncommon as a very large part of the state space is available to only one product.
abstracting feature expression results in the addition of such a large behaviour to all the other products which will be explored for each of them.
for one property out of six this inconvenience did not a ect the results.
however it led to a signi cant decrease in e ciency in the ve other cases with a speedup between .
and .
.
state abstraction appears more invasive than feature abstraction.
when combined with the fabr strategy it had no signi cant e ect on the performance for only four properties of the minepump spl it improved it nine times and worsened it seven times.
in the latter cases the loss in e ciency is substantial speedup between .
and .
whereas the improvements yield speedups between .
and .
.
our observations tend to indicate that rwfo is more appropriate for state abstraction.
indeed the performance of the abstraction is always increased when combined with this strategy.
with respect to the standard algorithm the veri cation is improved for properties speedup between .
and .
worsened for four properties speedup between .
and .
and almost unchanged for one property.
these conclusions are con rmed by the elevator and cfdp case studies from which we gathered similar results.
it is noteworthy that the above two abstractions have both a negative impact on veri cation time for only one property.
moreover it happened several times that one form of abstraction was very ine cient but not the other.
this implies that there almost always exists a good choice regarding the abstraction to apply and their combined e ects cannot be inferred from their individual performance results.
therefore we carried out additional experiments on mixed abstraction.
it turned out that the results follow the same trend as in the case of state abstraction although mixed abstraction is slightly less e cient on average.
state abstraction thus seems to cancel the e ect of feature ab img cegar minepump speedup.pdf figure speedups for the minepump case study.straction be it negative or positive.
this corroborates our previous observation that state abstraction has more impact on performance.
an in depth look at the execution times revealed that the computation of successor states in state abstraction is far more costly than the re exploration of already computed states.
since feature abstraction improves the latter but not the former its e ects are not apparent in mixed abstraction.
the other two case studies tend to con rm these conclusions.
in particular the negative e ects of feature abstraction on the cfdp model are o set by the bene ts of state abstraction although mixed abstraction remains seemingly less e cient than state abstraction alone in this case.
conclusions .
all these experiments allow us to draw conclusions regarding which abstraction to use.
state abstraction brings substantial bene ts in most cases and should be the preferred form of abstraction.
still feature abstraction can achieve dramatic reductions in veri cation time in particular situations notably when the property to check is expected to be satis ed by all products see e.g.
property .
the performance of our mixed abstraction is of the same order as state abstraction but is less e cient on average.
yet mixed abstractions o er the highest level of customization it could thus be possible to de ne other mixed abstractions that are more e cient than the one we used.
we leave that for future work.
.
related work this work is at the intersection of cegar and productline model checking.
clarke et al.
were the rst to introduce cegar.
they presented the principles we recapitulated in section designed the splitpath algorithm used to detect spurious counterexamples and proposed a re nement algorithm.
several model checkers make use of predicate abstraction to speed up the veri cation.
at the last tacas software veri cation competition ufo llbmc cpachecker and esbmc were nominated the fastest model checkers for product lines.
unlike us these tools do not treat features as rst class citizens.
this means that either they rely on an enumerative approach or their analysis procedure consists in verifying a model that includes the behaviour of all products i.e.
based on a product simulator or on con guration lifting .
in the rst case abstraction can be applied to the models of the individual products but the commonality between these is not exploited.
the second case o ers interesting perspectives regarding an e cient application of abstraction on all products.
however this approach can determine whether or not allproducts satisfy the property while we want to identify which products are error prone.
outside the scope of model checking liebig et al.
designed a type checking and dataow analysis procedure that abstracts from the validity of products.
this is also a form of feature abstraction although ours goes further by completely abstracting features.
regarding spl model checking there exist other methods that are not based on fts.
fischbein et al.
proposed to use modal transition systems mts to model the behaviour of spls.
mts are ts where transitions are either mandatory i.e.
executable by all valid products or optional i.e.executable by only a subset of valid products .
a fundamental di erence between mts and fts is that the former cannot link a given execution to the exact set ofproducts able to produce this execution.
it is thereby impossible to identify the exact set of products that violate a given property.
to overcome this limitation asirelli et al.
equipped mts with a modal logic which permits to restrain the execution of actions to speci c combination of features.
grumberg et al.
studied an abstraction re nement model checking procedure for modal calculus whose principles could be reused to design cegar methods for standard mts.
however such a method would not bene t from the modal logic of asirelli et al.
and would thus be inappropriate to address the spl model checking problem.
apel et al.
developed splveri er a tool chain for product line model checking.
features are speci ed in separate modules written in c or java.
like the advantage of their approach over fts is that they can verify actual code.
however the properties they can check do not extend to logics as expressive as ltl.
in they showed that approaches relying on symbolic interpretation of features are more e cient than sample based approaches thereby corroborating our previous results .
gruler et al.
showed that multi valued model checking can address the spl model checking problem.
multi valued ts generalise ts in that the transition relation is not binary and the atomic propositions are not boolean .
fts can be regarded as a particular type of multi valued ts.
there currently exists no algorithm to e ciently verify ltl formulae on multi valued models see for a thorough comparison .
given the close relation between fts and multi valued models the principles presented in this paper can be applied to design cegar procedures for multivalued model checking.
.
conclusion we presented spl speci c abstraction methods that tackle the state explosion problem in spl model checking.
our evaluation tends to show substantial performance gains in a majority of cases from which we derived general rules as to when our heuristics should be applied.
in the future we plan to design an automated method to build appropriate mixed abstractions given the topology of the model to check and a history of previous veri cations.
we will also combine this work with our fully symbolic spl model checking algorithms and implement the resulting approach on top of our nusmv extension .
this will allow us to assess whether or not our conclusions are still valid in that case.
.