a study of the uniqueness of source code mark gabel zhendong su department of computer science university of california at davis mggabel su ucdavis.edu abstract this paper presents the results of the first study of the uniqueness of source code .
we define the uniqueness of a unit of source code with respect to the entire body of written software which we approximate with a corpus of million lines of source code.
our high level methodology consists of examining a collection of software projects and measuring the degree to which each project can be assembled solely from portions of this corpus thus providing a precise measure of uniqueness that we call syntactic redundancy .
we parameterized our study over a variety of variables the most important of which being the level of granularity at which we view source code.
our suite of experiments together consumed approximately four months of cpu time providing quantitative answers to the following questions at what levels of granularity issoftware unique and at a given level of granularity how unique is software?
while we believe these questions to be of intrinsic interest we discuss possible applications to genetic programming and developer productivity tools.
categories and subject descriptors d. .
distribution maintenance and enhancement d. .
metrics general terms human factors languages measurement .
introduction most creative endeavors produce highly unique artifacts.
for example as authors writing a technical paper we expect this very sentence to have an extremely high probability of being unique that is we expect it to be the first use of these words in this exact order in the history of english prose.
we do not have the same intuition this research was supported in part by nsf career grant no.
nsf cybertrust grant no.
nsf ccf grant no.
nsf tc grant no.
and the us air force under grant fa9550 .
the information presented here does not necessarily reflect the position or the policy of the government and no official endorsement should be inferred.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.when we are programming however.
for all of its difficulty and subtlety the fundamentals of programming often seem rote.
there are several reasons why this may be true.
for one software source code necessarily shares many common syntactic elements.
programming languages tend to be fully defined by relatively simple formal grammars that specify structured and idiomatic source code.
as a simple example consider the java language the grammar dictates that statements be confined to method bodies which in turn must reside within class declarations each of which contains strictly defined sequences of tokens that include keywords and required punctuation.
software engineers impose further homogeneity through voluntary conformance to style conventions .
examples include naming conventions that restrict the space of available identifiers and design conventions that bound function and statement sizes.
commonality in software engineering tasks may lead to further similarity in source code.
for higher level tasks this phenomenon is pervasive and is evidenced by the plethora of reusable software libraries components and frameworks that engineers have created to minimize redundant development effort.
at a lower level of granularity repetitive and idiomatic code fragments are common programs written in c like languages are often full of simple indexed forloops over known bounds for example.
these traits are all evidence of a propensity for similarity in software which considering the sheer volume of software in existence and the continued growth of software engineering suggests the possibility of a singularity in software engineering s future a point of convergence at which all necessary software will have been produced.
taken at face value this proposition borders on futurist and is somewhat absurd clearly new requirements and domains will drive new software for the foreseeable future.
however examining the question in terms of granularity yields much more realistic scenarios.
for example consider the c programming language and its associated body of software.
at one extreme it is trivially true that every token type in the language has been used at least once and it is likely true that every legal two token sequence has been written as well.
once we reach the level of expressions or statements though the question becomes more subtle and interesting although the number oflegal statements in the language is theoretically infinite the number of practically useful statements is much smaller and potentially finite.
an excessively large arithmetic expression is usually written as a sequence of smaller statements of bounded size for example.
with this in mind it is entirely possible that every useful statement in the c language has already been written.
it is less likely that every useful block orfunction has been written though but a question of degree then arises what proportion of the set of practical blocks or functions have we written?
stated more generally just how close are we to writing all the source code we need?
147this paper presents the results of the first study that addresses this question.
our work consists of a large scale study of open source software written in three of the most widely used languages c c and java.
we approximate the body of all software with a corpus of million lines of source code.
our high level methodology consists of examining a collection of software projects and measuring the degree to which each project can be assembled solely from portions of the corpus thus providing a precise measure of uniqueness.
we parameterized our study over a variety of variables forming a suite of experiments that together consumed approximately four months of cpu time.
collectively our primary contribution is in providing a quantitative answer to the following question how unique is software?
while we believe that the answer to this question is of intrinsic academic interest there are several practical applications and consequences automation of programming recent research has demonstrated notable improvements in the application of genetic algorithms to software engineering tasks.
genetic programming gp involves the use of genetic algorithms to automate the act of programming a consequence of a lack of uniqueness of source code at least at certain levels of granularity is that the enormous search space for these algorithms could be significantly constrained.
while the full automation of system level development tasks is likely to remain elusive tasks at the levels of granularity at which software tends to lack uniqueness ideally the most menial and repetitive tasks may be quite accessible to gp systems.
development tool research modern development environments often provide a form of code completion which allows a developer to save time by typing a partial symbol name like str and receiving and accepting suggestions for the complete name like string and stringbuilder .
similarly predictive text input schemes on mobile devices allow the completion of natural language words with rich extensions in the form of phrase completion forthcoming .
a lack of uniqueness in source code would suggest the opportunity for research into analogous extensions for development tools we may be able to be extend standard code completion to allow for full statement code block or even function completion.
code reuse by quantifying the level of code sharing incidental or intentional across a large body of software our work can serve as a sort of limit study on the potential for code reuse.
a line of recent research has sought to provide advanced tool support for small scale code reuse our results provide a concrete measure of these tools applicability at various levels of granularity and may provide direction for future research.
this work is organized as follows in the following section section we survey related work and discuss this study s novelty.
in section we describe our methodology which is followed by our results section which suggest a significant lack of uniqueness of software at certain levels of granularity.
finally we discuss various threats to validity section and our plans for future work section .
.
related work while we believe our study of uniqueness to be the first of its kind other areas of software engineering research are related and share similar concepts.
clone detection clone detection is a research area concerned with detecting and studying the copying and pasting of source code fragments with the first major work being baker s duptool .
code clone detection is tied to the idea of intentional copying and pasting a deliberate action of a developer and the tools techniques andlanguage projects source files lines of code c c java table corpus summary tokens line avg.
median p75 p95 p99 language all non blank lines lines w token c .
.
c .
.
java .
.
table relating tokens to lines across the corpus studies are informed by this.
our study considers duplication of any kind but our focus is on incidental similarity or lack thereof .
the effect of intentional code clones on our results is minimal and we in fact consider them to be a minor nuisance that we explicitly control for cf.section .
that aside two studies of cloning are relevant to this study.
liveri et al.
present a large scale study of code clones within the freebsd ports collection a body of code similar in size to the subjects of our study .
they solve the related scalability problem with a parallel version of kamiya et al.
s ccfinder clone detection tool .
their results are dominated by file level code clones i.e.
copies of entire files.
in our study of uniqueness we consider these to be an artificial source of similarity that we also explicitly control for.
al ekram et al.
present a much smaller study of cloning between open source software projects that share similar functionality.
they find a general lack of these cross project clones but they note a nontrivial amount of incidentally similar code fragments that result from the use of similar apis.
this study hints at one source of a potential lack of uniqueness in software and serves as partial motivation for our study.
finally as a somewhat superficial difference we note that although we consider a variety of levels of granularity the bulk of our interesting results fall at levels of granularity squarely below those set as minimum thresholds in both past and recent clone detection tools in effect we have fully explored the space ignored by these tools.
studies of reuse mockus presents a study of large scale code reuse in open source software over a massive continuallygrowing dataset which is approximately five times larger than ours.
however this study only considers file level reuse which we explicitly control for and ignore rendering it complementary to our own.
research into reuse metrics seeks to quantify the time and resources saved by intentional reuse while our study focuses on incidental similarity which may indicate the potential for reuse.
most recently jiang and su present a new tool eqminer that locates functionally identical code fragments based completely on testing.
the authors motivation for the study is to explore the functional uniqueness of programs while ours is to explore syntactic uniqueness.
this semantics based study is complementary to our own and extending it to our scale would be especially interesting.
code search code search platforms often operate over collections of software at or in excess of the size of our own study with less scalable variants allowing for more flexibility through semantic search using test cases .
this line of research can benefit from our study by treating it as a form of limit study on various types of syntactic reuse levels of granularity at which software is 148highly unique would form ideal candidates for more advanced and flexible search techniques.
schleimer et al.
s moss uses a form of document fingerprinting to scalably characterize likely plagiarized software.
this work is based on the assumption of a certain level of uniqueness in software our study directly measures this value for a large sampling of software and our results may possibly lead to more accurate and complete plagiarism tools.
.
study design our study aims to answer the general question of the degree of uniqueness of software.
while simple conceptually this question is fraught with subtlety and complexity.
this section describes our methodology in detail with special attention given to the rationale for our various design choices that may affect the validity of our results.
we start with a high level summary of our methodology section .
and continue with a discussion of our experimental variables sections .
.
.
we then summarize with a complete inventory of our suite of experiments section .
.
.
high level methodology this study is based on a metric for uniqueness that we define in terms of a software project .
we begin our description with a simple thought experiment that illustrates our intuition you are a software engineer starting a new project requirements in hand.
unfortunately your keyboard has malfunctioned and your only method for entering program text is through copying and pasting existing code fragments.
fortunately perhaps you have oracle like access to allsource code that has ever been written.
how much can you accomplish?
this amount the proportion of the project that you are able to complete is the essence of our metric.
a low value for a specific project indicates that the project is unique low values for allprojects would indicate that software is unique.
when defined as the object of a thought exercise this metric is inherently impossible to calculate.
we take three steps in concretizing it as a computable value.
first we approximate all code that has ever been written with a large collection of source code which we call the corpus .
next we precisely define our representation our view of source code which then leads to a natural methodology for calculating uniqueness at various levels of granularity.
gathering a corpus our corpus consists of a collection of open source software in three languages c c and java.
we collected the bulk of our corpus from the complete source distribution of the current release of the fedora linux distribution.
a linux distribution like fedora has several properties that benefit our study size with a collection of software designed to accommodate the needs of a large user base a linux distribution contains a vast amount of source code.
diversity the large amount of source code is distributed among a proportionally large collection of software projects with diverse functionality.
lack of duplication fedora is distributed as a managed system of packages and is likely to contain little large scale duplication preferring package based dependencies in place of copies.
while copies of source code in the corpus would not taint our results a study of this scale must use cpu time economically and scanning duplicates is an obvious waste.
this collection contains an adequate amount of c and c code but we found java to be underrepresented.
to complete our corpus we supplemented it with a similarly diverse collection of java language project description size lines catlas linear algebra kernel ffdshow audio video codec freedroid arcade game grisbi personal accounting net snmp snmp library pnotes desktop notes sdcc small device c compiler tcl scripting language winscp scp client xbmc media center c 7zip compression tool audacity audio editor dvdstyler dvd video authoring hugin panoramic photo stitcher mediainfo media file identifier mumble v oice communication npp text editor ogre 3d engine postbooks erp crm and accounting scummvm adventure game engine javaadempiere erp crm business suite arianne multiplayer game engine freecol strategy game jedit development environment jmri model railroad interface jtds jdbc driver openbravo web based erp rssowl feed reader sweethome3d interior design tool zk ajax framework table target projects retrieved from sourceforge projects from .
a summary of our complete corpus appears in table .
source representation this study takes a lexical view of source code representing each source file as a simple sequence of tokens .
we found this to be a viable compromise between scalability and flexibility.
a simpler line based view would be inexpensive to compute but highly brittle a measure of uniqueness at the line level is liable to be an overestimate.
a more rich representation like syntax trees or dependence graphs would allow for more flexibility but would be expensive to compute for projects.
in addition overly abstract representations are increasingly disconnected from the actual act of programming which we would like our study to relate to as much as possible.
to more conveniently relate our lexically based study to more familiar measures we performed a brief study of the distribution of tokens over lines on our corpus the results of which appear in table .
the distributions are quite consistent across the three languages likely owing in no small part to style conventions.
for each language we report statistics for both all non blank noncomment lines and lines with more than one token.
methodology recall that our metric for uniqueness is conceptually based on the amount of a given project that can be assembled from already written code.
with a corpus and code abstraction selected we concretize this concept in a measure we call syntactic redundancy .
we calculate this metric for a specific software project with respect to a corpus and a given level of granularity which under our lexical view we define in terms of contiguous fixed length token subsequences token level n grams or shingles .
briefly a given token in the input project is syntactically redundant if it is enclosed in at least one sequence that is matched by some sequence in the corpus.
syntactic redundancy is the proportion 149in memory... while path dlen ... if path subpath dlen len dlen ...if path target project .
lexical analysis measured redundant corpus .
sequencing of target project .
linear scan of corpus for matching sequencesif path path path if path record matches .
tabulationfigure overview and example of our methodology for calculating syntactic redundancy of redundant tokens in a given project.
we illustrate this process graphically in figure and narrate the steps here.
input as input we have a target project and a corpus which are both collections of program source files and a positive integer grepresenting the level of granularity .
i. sequence the target project first we analyze each of the target project s source files according to the lexical specification of the target language.
we then enumerate every fixed length token subsequence of size g i.e.
the token level g grams and load them into memory a process we call sequencing.
ii.
scan sequence and process the corpus we then perform a linear scan of the corpus sequencing each corpus file under the same conditions.
for each corpus sequence we search for amatch in the target project.
if found we record the tokens in the target project that comprise the matching sequence as redundant reflecting the fact that we could have copied and pasted this corpus sequence to form this segment of the target project.
note that due to overlap tokens may be marked as redundant multiple times but each token will only be counted once.
iii.
collect results the process concludes with a final tabulation of the target project s sequences which are processed and residing in memory returning the ratio of redundant tokens to all tokens as a percentage.
with our basic methodology in place we continue with a description of our four main experimental variables.
.
first variable target projects the first variable in our experiments is the target project .
we chose two sets of target projects in an effort to compromise between depth and breadth of study our first small set of projects allows us to perform a large number of measurements with absolute precision while our second much larger set allows us to more accurately draw general conclusions about the uniqueness of software.
first set depth we retrieved our first set of targets from sourceforge1by walking the most active projects last week list and collecting the top primarily c c and java projects.
descriptions of these projects appear in table .
from list has several advantages.
first the ranking is in terms of site activity including bug tracker activity forum posts and releases which prevents us from considering abandoned projects.
second the scope of the ranking criteria is limited to a window of a single week providing an opportunity for both new and mature projects to appear.
third the list excludes downloads as a criterion lists that include downloads are dominated by peer to peer file sharing applications and would not have resulted in a diverse study.
second set breadth we increase the breadth of our study with a second set of projects the corpus projects themselves.
calculating syntactic redundancy for each project in this set would ordinarily be prohibitively expensive directly applying our technique from section .
would amount to a quadratic time scan of million lines of code.
fortunately our methodology lends itself to stochastic estimation.
our estimation technique is illustrated in figure and is largely straightforward.
we treat the syntactic redundancy of a token as a binary random variable and estimate its value by sampling uniformly from the population of tokens in a project.
we determine the number of necessary samples according to a desired margin of error confidence and project size using standard techniques .
in our experiments over these projects we calculated redundancy with a margin of error and confidence.
there is one subtlety which is reflected in figure to obtain correct results we must correctly compute the redundancy of each sampled token.
this involves generating allsequences that include each sampled token even if they include other non sampled tokens.
however these non sampled tokens are not to be counted when tabulating as they do not belong to the sampled project.
note also that sampling is limited to the target project after sampling we always perform a scan of the entire corpus.
though we believe our methodology to be sound we did validate it empirically on our sourceforge projects by comparing the precisely and approximately computed values.
we found the estimation to be quite accurate in all trials within a range of the true value despite using the above parameters.
.
second variable granularity our second experimental variable is the level of granularity g which controls the length of the token sequences our analysis gener2in practice enforcing these parameters requires sampling approximately tokens per project.
variations are due to differing project sizes.
150in memoryif path .
lexical analysis estimate redundant .
sequencing if if .
corpus scan matches marked .
sampling of tokens if with respect to desired margin of error and confidence dlen path path .
tabulationfigure scalable estimation technique for our breadth experiments ates during the sequencing phase.
put more plainly in terms of our earlier thought exercise grepresents the size of the code segments that we copy from the existing code to assemble a project.
we parameterize our experiments over a variety of token sequence lengths.
our goal is to view our study from two complementary perspectives atwhat levels of granularity issoftware unique and at a given level of granularity how unique is software?
we set our values for granularity by first selecting two critical values a functional minimum the median value of tokens in a single line and maximum determined through exploratory experiments that denote a range of relevant values.
the scale of our study prevents us from performing experiments on every value in this range we instead select gthrough a series of passes over this range in the first pass we perform experiments over a small fixed number of values in subsequent passes the number of which are limited by our computing resources we iteratively refine our information by performing experiments on the midpoints of previously computed values of g. .
third variable matching criteria in our methodology we mark a token as redundant when we find a matching sequence for it in the corpus.
while the most clear and obvious definition of match exact equality is the most intuitive we also explored alternate definitions that allow for some imprecision.
it may not be clear at first why approximate matches are worth exploring on the surface such an extension might seem to do little more than inflate the results.
note though that we are only interested in specific cases involving slight imprecision it may be the case that a trivial nudge causes the threshold for uniqueness in software to be significantly higher and it is precisely this idea the interplay between granularity and uniqueness that we wish to explore fully.
our intuition here is experiential as software engineers we hypothesize that many potential matchings may fail due to very slight differences like an operator in an expression the name of an identifier or the ordering of two parameters.
if path no abstraction if id if path renamed identifiers if id c renamed literals and identifiers iflblbidlkidrkoplitrbrb lexical classes only original program text used in majority of experimentsfigure possible levels of abstraction for token sequences we expand our experimental infrastructure with the ability to detect matches within a specified hamming distance .
briefly hamming distance is a metric defined over two sequences of equal length and it is calculated as the number of positions at which their elements differ.
implementing this extension in a scalable manner is certainly one of this study s more involved engineering tasks.
while finding all exactly matching sequences is fast and straightforward using hashing the na ve approach to finding all approximate matches involves a linear number of expensive hamming distance calculations per query.
we solve this problem with a new randomized hashing algorithm that is related to the concept of locality sensitive hashing .
the technical details and proofs are outside the scope of this paper we focus instead on the theoretical properties that affect the validity of our results precision as a randomized not an approximation algorithm our algorithm only returns truematches that is it returns no false positives.
recall the probability of missing an arbitrary match has provable bounds and is tunable.
we set this probability to 99in our experiments.
as applied to this study these properties can be summarized plainly any syntactic redundancy value we report that allows for imprecision is a sound underapproximation that is very likely near the true value.
in our experiments we measure syntactic redundancy with respect to a exact matches only and b matches allowing for a hamming distance of up to and separately reported .
.
fourth variable abstraction in our example depicted in figure the sequences consist entirely of concrete program text the only processing is in separating the tokens according to a lexical specification.
in programming however some aspects of concrete program text are arbitrary and do not affect semantics with a simple example being variable naming .
failing to account for this may result in our study reporting that software is overly unique.
we can control for this kind of variation by abstracting the individual token sequences from their concrete program text to a more normalized form.
various schemes are possible we present four 151methods in figure .
in the bulk of our experiments we limit ourselves to the two most conservative types none or no abstraction at all and renamed identifiers which involves a consistent alpha renaming of all identifier typed tokens but leaves all other tokens including the values of literals untouched.
.
summary we have defined a general methodology and four experimental variables.
our final set of experiments includes the calculation of syntactic redundancy under the product of the following conditions .two sets of target projects sourceforge projects under full precision depth and corpus projects under stochastic estimation breadth .
.
two levels of abstraction none andrenamed identifiers .
.exact matches and matches allowing for maximum hamming distances of and .
.as many levels of granularity as our computing resources will allow.
.
results this section presents the results of our study.
we begin with a brief description of the operation of our experiments including an overview of our implementation and the number and type of experiments we completed.
we then present the results of our depth experiments over the sourceforge projects which is followed by a discussion of the results of our breadth experiments over all corpus projects.
in the following sections our emphasis is on presenting our data in as raw clear and unbiased a form as possible.
.
implementation and operation our experimental infrastructure consists of an entirely new highly optimized java application running on a dual xeon server with gb of main memory.
notable features include the ability to calculate syntactic redundancy for multiple projects in parallel which was critical for our breadth experiments.
sound and efficient computation of approximate matches cf.
section .
.
in addition we can compute redundancy for multiple values of maximum hamming distance simultaneously with little marginal cost in both time and space.
simple extension to other languages by providing a lexical specification.
resource awareness our application expands to consume all available memory and cpus as efficiently as possible.
as a java application our infrastructure should run on any java supported platform.
in practice however we require a 64bit system and virtual machine and certain optimizations present in sun s .
reference implementation are essential to making reasonable progress at this scale.
as we described in the previous section we fix a set of values for all but one experimental variable granularity g expressed in tokens we instead perform what amounts to a systematic search over various values between a functional minimum and maximum.
at the time of this writing our experiments have consumed a total of approximately four months of cpu time and have completed redundancy measurements for the following levels of granularity depth breadth these cumulative results have provided a sufficient quantitative answer to our question of the uniqueness of software.
.
depth sourceforge projects the results of our experiments over the sourceforce projects appear as plots in figure .
the independent variable is the level of granularity in tokens g and the dependent variable is the syntactic redundancy of the project expressed as a percentage.
each line on each plot represents the redundancy value with respect to two variables abstraction section .
and matching criteria section .
.
we perform no estimation or approximation during these depth experiments and we present the results in as raw a form as possible.
we briefly summarize the extent our filtering and summarization a for clarity of presentation we omit lines for max hamming distance though the data are available b due to the dramatic drop off in redundancy after g we focus each graph on g and c the resolution of these graphs may give the illusion of smoothing on many of the lines but we did not perform any.
the most striking feature of these graphs is their similarity apart from a few outliers all appear to follow a similar trend.
first at the minimum level of granularity tokens or approximately one line between and of each project is redundant depending on matching and abstraction.
at this point the sets of lines take two paths the no abstraction set drops off and flattens quickly while the renamed identifiers set maintains a period of flatness at which redundancy is high.
after a more delayed decline they reach an inflection point at around tokens flatten out and finally join the no abstraction lines.
in all but one experiment we measured no significant amount of redundancy at levels of gover .
the convergence of all redundancy values to a common level highlights an ancillary benefit of our choice of abstraction levels control for clones and the resulting focus on incidental similarity .
at sufficiently high levels of granularity the no abstraction results can be interpreted as being generally composed of intentional copying while the renamed identifiers results are more likely to include incidental similarity.
note that this characterization is not perfect only probable code can be incidentally completely identical and intentional copies can be consistently renamed or otherwise adapted.
the extensive spread between the two sets of values between g andg consistent across all projects suggests a substantial amount of incidental similarity.
when the two sets of measurements finally meet at higher levels of granularity they have converged on the comparatively rare intentional copies the code clones.
controls for trivial redundancy the root causes of redundancy are important trivial cases like full file copies and intentional code clones are uninteresting as our goal is to study the intuitive idea of incidental similarity in source code.
in addition to the information provided by the two abstraction levels we implemented a small assortment of other controls for trivial redundancy.
though more properly described with our methodology we believe the current context provides more intuition.
we developed these controls after earlier exploratory experiments with a much less scalable version of our platform that provided full traceability information for every match.
first for the java language we do not measure the initial segment of every source file that contains import statements which control namespace resolution.
similarly for c and c we ignore the standard string of include directives and using statements at the start of each file and we ignore all header files which usually only contain declarations.
our focus is on studying the semanticsaffecting intentional aspects of programming and these controls allow us shift focus from the most egregiously spurious structurally induced matches.
second for all languages we do not allow matches from duplicated files determined by content orfiles with identical file names.
the latter somewhat aggressive filter allows us to conservatively 152c no abstraction renamed ids exact matches only hamming dist.
hamming dist.
hamming dist.
granularity tokens atlas granularity tokens ffdshow granularity tokens freedroid granularity tokens grisbi granularity tokens net snmp granularity tokens pnotes granularity tokens sdcc granularity tokens tcl granularity tokens winscp granularity tokens xbmc c no abstraction renamed ids exact matches only hamming dist.
hamming dist.
hamming dist.
granularity tokens 7zip granularity tokens audacity granularity tokens dvdstyler granularity tokens hugin granularity tokens mediainfo granularity tokens mumble granularity tokens npp granularity tokens ogre granularity tokens postbooks granularity tokens scummvm java no abstraction renamed ids exact matches only hamming dist.
hamming dist.
hamming dist.
granularity tokens adempiere granularity tokens arianne granularity tokens freecol granularity tokens jedit granularity tokens jmri granularity tokens jtds granularity tokens openbravo granularity tokens rssowl granularity tokens sweethome3d granularity tokens zk figure syntactic redundancy of sourceforge projects.
the dependent variable is the percentage of syntactically redundant tokens.
153control for the cases in which copied files are very slightly adapted e.g.a copyright header or are of different but similar versions.
before adding this filter we did measure its potential effect in all cases it reduces the relative size of the corpus with respect to a single project by less than one percent.
outliers the plot of nppfollows the standard trend but it converges on a much higher value of redundancy.
upon investigation we noted that over half of the project s source code consists of generated lexers used for syntax highlighting which at least one project in the corpus undoubtedly contains as well.
other interesting projects included atlas andhugin with the former showing an abnormally steep drop off in redundancy and the latter having an exceptionally low redundancy value at low levels of granularity.
we do not have a complete explanation for these phenomena but we hypothesize that they are a result of the projects specialized domains linear algebra solving and panoramic photo stitching respectively .
one minor effect is exhibited in a minority of the graphs at very low levels of granularity slightly increasing granularity counterintuitively increases redundancy.
this is an artifact of our methodology at a given level of granularity g only files with at least one g sized sequence are counted as part of the project.
we could have formulated our measurements either way either including or excluding tiny files but in any case the effect is negligible these files generally only contain between of any given project s code.
in summary we observe a substantial amount of incidental similarity between these projects and our corpus.
the bulk of the syntactic redundancy is exhibited at significant but still fairly low levels of granularity to tokens or approximately one to seven lines of code.
.
breadth corpus projects our breadth experiments involve calculating estimated syntactic redundancy values for all of our corpus projects.
summary statistics of the results appear in table and we have included density plots of the distributions of these values overlaid for each language in figure .
in this section we restrict the language of our observations to general and qualified terms other than basic summarization these data are raw and we have not formally formulated tested any hypotheses and we have not performed any statistical tests.
here our primary contribution is in the collection of a vast amount of previously unknown or perhaps unattainable data our interpretations are secondary and are suggestions of general trends.
atg approximately one line of code shown figure 5a the projects are nearly wholly redundant when measured under abstraction and their values of syntactic redundancy are over half when measured using no abstraction at all.
all three languages are apparently in agreement which suggests the possibility that individual lines of code are notunique.
the next level of granularity g figure 5b is more interesting.
in our depth experiments this level of granularity falls in the center of the range of values at which we observe a high redundancy values.
on the whole these aggregate redundancy measures are essentially in agreement with the individual values for our sourceforge experiments but the individual languages are less in agreement with each other the suggestion of a general trend is still there but we observe more variation.
the java projects for example appear to have a generally higher level of redundancy while the c and c measurements are much closer to each other in value.
once again we observe a substantial and consistent spread between the abstracted and non abstracted measurements suggesting a general trend of incidental similarity.
atg figure 5c our observations are again in line with our depth experiments we observe generally more uniqueness i.e.
median syntactic redundancy max hamming dist g abstraction c6none .
.
.
.
.
renamed ids .
.
.
.
.
20none .
.
.
.
.
renamed ids .
.
.
.
.
35none .
.
.
.
.
renamed ids .
.
.
.
.
77none .
.
.
.
.
renamed ids .
.
.
.
.
120none .
.
.
.
.
renamed ids .
.
.
.
.
c 6none .
.
.
.
.
renamed ids .
.
.
.
.
20none .
.
.
.
.
renamed ids .
.
.
.
.
35none .
.
.
.
.
renamed ids .
.
.
.
.
77none .
.
.
.
.
renamed ids .
.
.
.
.
120none .
.
.
.
.
renamed ids .
.
.
.
.
java6none .
.
.
.
.
renamed ids .
.
.
.
.
20none .
.
.
.
.
renamed ids .
.
.
.
.
35none .
.
.
.
.
renamed ids .
.
.
.
.
77none .
.
.
.
.
renamed ids .
.
.
.
.
120none .
.
.
.
.
renamed ids .
.
.
.
.
table median syntactic redundancy values for the corpus projects.
less redundancy and the spread between the abstracted and nonabstracted measurements significantly narrows.
at g figure 5d and no figure but displayed in table we observe near total uniqueness and we also observe a potential broad scale confirmation of the phenomenon of the redundancy measures converging on the more rare intentionally copied code fragments both the abstracted and non abstracted distributions appear centered around similar values.
across all runs our measurements are in agreement with our depth experiments redundancy is near total at the line level and remains significant through the range of approximately one to six lines.
.
threats to validity threats to the validity of our study fall under two main categories construct validity and external validity.
construct validity the construct validity of our study rests on our ability to accurately measure true syntactic redundancy a measure that we have approximated concretely in terms of a corpus in the hope that it provides an accurate estimation of the same value computed for all code in existence.
here the most obvious threat is that our corpus is insufficiently large or varied leading us to potentially under report redundancy.
we believe this to be unlikely the corpus is highly diverse and we report quite similar measurements for all three languages despite the fact that the majority of the java and c c portions of corpus are derived from wholly different sources.
154no abstraction renamed ids c c java .
.
.
.
.
redundancy .
.
.
redundancy .
.
.
.
redundancy a granularity tokens.
left exact matches.
middle hamming dist.
.
right hamming dist.
.
.
.
.
redundancy .
.
redundancy .
.
.
redundancy b granularity tokens.
left exact matches.
middle hamming dist.
.
right hamming dist.
.
.
.
.
redundancy .
.
.
redundancy .
.
.
.
redundancy c granularity tokens.
left exact matches.
middle hamming dist.
.
right hamming dist.
.
.
.
.
redundancy .
.
.
redundancy .
.
.
.
.
redundancy d granularity tokens.
left exact matches.
middle hamming dist.
.
right hamming dist.
figure density plots of the distribution of syntactic redundancy values for corpus projects.
we also performed a small experiment to provide limited evidence of the sufficiency of our corpus the results of which appear in figure .
in this experiment we fix all our standard experimental variables a single project freecol a single level of granularity and abstraction renamed identifiers and for simplicity exact matches only.
we instead vary the size of the corpus through sampling we first compute syntactic redundancy with respect to a sampled corpus of approximately files.
we then repeatedly double the size of the corpus and remeasure until we reach the original size files.
as expected the syntactic redundancy increases monotonically but the growth rate is highly variable strong at first but trailing off dramatically before even half the corpus has been sampled.
though only a single data point this experiment suggests that increasing the scope of our corpus may not yield substantially different measurements.
there are also potential threats due to errors in our implementation.
we did utilize end to end regression testing throughout our platform s development and optimization however and we are confident our measurements.
in addition we are willing to release our implementation on request and all raw data for that matter for inspection and or replication.
external validity the general trends apparent in our depth experiments may not generalize to most or all software.
our breadth experiments over projects do help in confirming a general trend but there is a potential threat from platform homogeneity ourcorpus which comprised the set of target projects in the breadth experiments is composed completely of open source linux software.
however we believe that this threat is mitigated by the abundance of cross platform software and the fact that only a small fraction of code in high level languages is likely to be truly platform specific.
in addition a selection of our sourceforge projects are actually windows only projects and our measurements for these projects are consistent with the rest despite being measured against a linuxbased corpus.
.
conclusions and future work in this paper we present the first study of the uniqueness of source code.
we have formulated a precise and intuitive methodology for measuring this value which we call syntactic redundancy .
we compute this value precisely for assorted sourceforge projects and approximately but with known error margins and confidence for other projects.
our experiments covering million lines of source code and consuming approximately four months of cpu time revealed a general lack of uniqueness in software at levels of granularity equivalent to approximately one to seven lines of source code.
this phenomenon appears to be pervasive crossing both project and programming language boundaries.
our most immediate line of future work is the exploration of the practical ramifications of our findings.
we are most interested in the consequences of this study on genetic programming which we corpus size files syntactic redundancy gggggggggfigure the syntactic redundancy of freecol with respect to sampled subsets of our corpus.
remarked on earlier a fitness function that ensures that a proposed program looks like software should look could greatly improve the performance of these systems possibly making many problems tractable for the first time.
we are also interested in repeating our study with different targets and or corpora.
when retrieving the depth targets from sourceforge we were encouraged by the fact that our chosen languages c c and java dominated the list of the most active projects.
however web languages php in particular came in a close fourth.
repeating our study for this and other non c like languages may yield quite different results.
we would also like to scan and tabulate commercial code as well though we doubt the results would be significantly different.
a natural complement to our quantitative line of work is a thorough investigation into the qualitative aspects of syntactic redundancy.
for example it may be the case that a particular set of common sequences software genes dominate the results which could drive tool support.
earlier versions of our measurement infrastructure did allow for the full tracing of every match but we ultimately had to drop this feature in favor of scalability.
as future work we intend to explore methods of reinstating this feature without compromising our ability to scan large amounts of source code.
.