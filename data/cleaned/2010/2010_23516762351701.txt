can i clone this piece of code here?
xiaoyin wang1 yingnong dang2 lu zhang1 dongmei zhang2 erica lan3 hong mei1 1key laboratory of high confidence software technologies peking university ministry of education beijing china 2microsoft research asia beijing china 3microsoft corporation one microsoft way redmond wa usa wangxy06 zhanglu meih sei.pku.edu.cn yidang dongmeiz erical microsoft.com abstract while code cloning is a convenient way for developers to reuse existing code it could potentially lead to negative impacts such as degrading code quality or increasing maintenance costs.
actually some cloned code pieces are viewed as harmless since they evolve independently while other cloned code pieces are viewed as harmful since they need to be changed consistently thus incurring extra maintenance costs.
recent studies demonstrate that neither the percentage of harmful code clones nor that of harmless code clones is negligible.
to assist developers in leveraging the benefits of harmless code cloning and or in avoiding the negative impacts of harmful code cloning we propose a novel approach that automatically predicts the harmfulness of a code cloning operation at the point of performing copy and paste.
our insight is that the potential harmfulness of a code cloning operation may relate to some characteristics of the code to be cloned and the characteristics of its context.
based on a number of features extracted from the cloned code and the context of the code cloning operation we use bayesian networks a machine learning technique to predict the harmfulness of an intended code cloning operation.
we evaluated our approach on two large scale industrial software projects under two usage scenarios approving only cloning operations predicted to be very likely of no harm and blocking only cloning operations predicted to be very likely of harm.
in the first scenario our approach is able to approve more than cloning operations with a precision higher than .
in both subjects.
in the second scenario our approach is able to avoid more than of the harmful cloning operations by blocking only of the cloning operations for the first subject and avoid more than of the cloning operations by blocking only of the cloning operations for the second subject.
categories and subject descriptors d. .
general terms reliability keywords code cloning harmfulness prediction programming aid the work was done when the author was an intern at microsoft research asia.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.
.
introduction software reuse can reduce the costs of software development.
when reusing a piece of code a developer may have two choices.
the first choice is to wrap the reused code into a module e.g.
a method and invoke the module wherever the code is used.
the second choice is to copy the code and paste it in the place where she wants to reuse the code making some revisions if necessary.
it is typically convenient for developers to reuse existing code via copy and paste.
a recent study shows that schedule pressure often prevents developers from spending much time on wrapping reused code to modules.
additionally for some reused piece of code wrapping them can be technically challenging or require change on the components that developers should not change.
as a result code clones which are mainly the results of applying software reuse based on copy and paste make up a large proportion of modern software code bases e.g more than of the code in eclipse jdt are involved in clones or near clones .
however developers may achieve this convenience at a cost.
maintenance of cloned code requires extra effort because developers need to consider consistency among the clone segments when they try to make a revision to one clone segment1.
failing to maintain consistency between clone segments may cause bugs .
however recent studies show that code clones are not always detrimental to software development and evolution .
in particular gode and koschke demonstrate that less than half of the code clones may change during their life cycle.
among those changes in code clones only about half are consistent changes i.e.
simultaneous changes of more than one segment in a code clone group while the others are inconsistent changes i.e.
changes to only one segment without touching the other segments .
for inconsistent changes2 in general developers do not need to consider other clone segments in the clone group and therefore do not need to make any extra effort when revising a clone segment.
for consistent changes in general developers may have to study all clone segments in the clone group and decide which other segments they should change and how to change them.
the preceding studies indicate that cloning operations can be generally divided into two categories according to whether consistency maintenance is required for the resulting clone segments.
the first category of cloning operations referred to as harmless cloning operations in this paper includes cloning operations whose 1in this paper when several pieces of code are clones of each other we use the term clone segment to represent one of such pieces of code and we use the term clone group to represent a group of clone segments that are clones of each other.
2here we use the term inconsistent changes for intentional inconsistent changes.
in reality there may exist unintentional inconsistent changes that lead to bugs but studies show that such cases are not common.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
resulting clone groups are never changed or always changed inconsistently.
for this category of code clones no maintenance of consistency is required so that developers can perform copy andpaste and benefit from the convenience for free.
the second category of cloning operations referred to as harmful cloning operations in this paper includes cloning operations whose resulting clone groups need to be changed consistently.
they are harmful because any consistent change will incur extra maintenance effort and even lead to code defects if consistency is not maintained.
for a harmful cloning operation wrapping the cloned code into a module would be a better choice.
it should be noted that code clones may have other kinds of harmfulness e.g.
bad readability .
however causing consistent changes is one of the most important kinds of harmfulness and has been widely studied.
therefore we focus on the harmfulness of causing consistent changes in this paper.
due to various reasons e.g.
lack of expertise or lack of supporting information developers may have difficulties in wisely determining the harmfulness of a cloning operation.
in fact the statistics on our evaluation subjects see table show that the developers of the subjects allow a non trivial number of harmful cloning operations which account for about of all cloning operations allowed.
therefore assistance in understanding the harmfulness of an intended cloning operation may help developers make a better choice of whether to reuse existing code.
in this paper we propose an automatic approach to predicting the harmfulness of intended cloning operations.
the intuition of our idea is that some characteristics of the code to be cloned and the context of a code cloning operation may indicate its potential harmfulness.
based on a number of features extracted from the cloned code and the context information of the code cloning operation we use bayesian networks a machine learning technique to predict the harmfulness of an intended code cloning operation.
specifically we extract three groups of features historical features that describe the change history related to the code to be cloned code features that describe syntactical characteristics of the code to be cloned and destination features that characterize the target place i.e.
the place where the developer intends to paste the code .
to evaluate our approach we considered two possible usage scenarios of our harmfulness predictor for intended cloning operations the conservative scenario for cautious developers who want to perform cloning operations only when they are sure that the cloning operations would be unlikely to incur harm for maintenance and the aggressive scenario for radical developers who want to block a significant proportion of harmful cloning operations while still being able to perform most intended cloning operations.
we evaluated our approach using two large scale microsoft software projects in the following way for the first scenario we used our approach to approve only cloning operations predicted to be very likely to be harmless while for the second scenario we used our approach to block only cloning operations predicted to be very likely to be harmful.
our evaluation results demonstrate that with precision higher than .
our approach is able to approve to of cloning operations for the two projects in the conservative scenario and by blocking only to of cloning operations for the two projects our approach is able to avoid to of harmful cloning operations in the aggressive scenario.
the main contributions of the this paper are as follows a demonstration of the feasibility of predicting the harmfulness of intended cloning operations.
a harmfulness predictor for cloning operations based on bayesian networks using three groups of features that characterize the code to be cloned and the context of the cloning operations.
an evaluation of the proposed harmfulness predictor on two industrial software projects under two usage scenarios.
we organize the rest of this paper as follows.
in section we provide two examples of harmful and harmless cloning operations.
in section we present our approach in detail.
in section we present an evaluation of our approach using industrial software projects.
we discuss some related issues in section .
we introduce related work in section and present future works in section .
finally we conclude this paper in section .
.
examples in this section we present two examplary cloning operations both of which are from the code base of the first project used in our evaluation.
the first example depicts a typical harmful cloning operation and the second example depicts a typical harmless cloning operation.
these two examples reveal some clues that harmful and harmless cloning operations may have different characteristics.
in the first example the developer copied lines of code i.e.
code snippet and pasted the copied code into the same method with slight revision i.e.
code snippet .
after the copy andpaste operation the two clone segments experienced four consistent changes which happened and months later respectively.
the first is to change variable cockpitservers in line and two other similar local variables in lines and to field variables.
the second is to change the constant ppe to blu to adapt to the change of naming rules on the server side.
the third is to add a function invocation to the configuration fetching part from line to line .
the fourth is to change the name of loglevel.warning in line .
from this example we can identify two factors for consistent changes.
first the copy and paste is local so that the copied and pasted code pieces share many local variables.
second the clone segments interact with the configuration and static fields so that changes in the configuration or static fields may impact both clone segments simultaneously.
code snippet try cockpitservers config.getparameter c iqmfile ppe cockpitserver c ppecockpitserver cockpitports config.getintparameter c iqmfile ppe cockpitport c ppecockpitport collectiondirs config.getparameter c iqmfile ppe collectiondir c ppecollectiondir if config.getintparameter c iqmfile ppe rankdataavailable c pperankdataavailable m numcollections rankdataavailable true if config.getintparameter c iqmfile ppe crawldataavailable c ppecrawldataavailable m numcollections crawldataavailable true catch logger.log logid.iqm loglevel.warning unable to get cockpitserver or cockpitport for ppe code snippet try cockpitservers config.getparameter c iqmfile prod cockpitserver c productioncockpitserver cockpitports config.getintparameter c iqmfile prod cockpitport c productioncockpitport collectiondirs config.getparameter c iqmfile prod collectiondir c productioncollectiondir if config.getintparameter c iqmfile prod rankdataavailable c productionrankdataavailable m numcollections rankdataavailable true if config.getintparameter c iqmfile prod crawldataavailable c productioncrawldataavailable m numcollections crawldataavailable true catch logger.log logid.iqm loglevel.warning unable to get cockpitserver or cockpitport for production in the second example the developer copied lines of code depicted below and pasted it into another method in another file without changes.
the clone group generated by the copy and paste operation remained unchanged for years until the module containing this clone group was completely removed.
from this example we may identify the following factors for harmless cloning operations.
first the copied code piece is pasted to another method in another file.
therefore the resulting clone segments do not share local methods and variables.
second the code piece contains only library function calls so that it has relatively less dependence on other modules and is unlikely to be affected by a change in other modules.
however this piece of code still has some dependence on the other part of the project.
for example ssource is a function parameter which depends on its calling modules.
if c ssource.length c ssource.length ssource break if ssource try if ssource q ssource stag.tolower q c else break catch exception e console.writeline e.message the preceding two examples demonstrate that there do exist some clues in cloning operations that relate to their harmfulness.
for example more dependence of the code to be cloned on other code may indicate more likelihood of being harmful.
therefore it should be feasible for us to determine the harmfulness of an intended cloning operation at the copy and paste stage.
however the preceding two examples also demonstrate that it might be difficult to obtain simple discriminative rules based on the clues.
as a result given that the version histories of existing software projects record a large number of cloning operations and the evolution of the resulting code clones over time it is a reasonable choice to leverage a machine learning based technique to learn an effective harmfulness predictor from the evolution histories of existing code clones.
.
approach in this section we first give an overview of our approach.
we then present how we extract features for code cloning operations and construct the predictor based on the historical code cloning operations extracted from version history.
we also present the scenarios that our prediction approach can be applied to help developers.
.
overview the basic idea of our approach is to transform the problem of predicting the harmfulness of intended cloning operations into a problem of learning a prediction model from existing data of performed cloning operations.
in particular we adopt a machinelearning technique named bayesian networks.
developed in the late 1980s bayesian networks provide a mathematical model to predict the probability of an event based on the happening ofother observable events.
formally a bayesian network is a directed acyclic graph in which each node represents an event and the weight on the edge from node ato node brepresents the conditional probability of event bprovided that event ahappens.
therefore given a bayesian network it is easy to calculate the probability of an event based on the parent nodes of the event s corresponding node if all the parent nodes are observable.
to build a bayesian network for predicting the harmfulness of cloning operations we need to decide the nodes the structure and the weights on the edges in the bayesian network.
in our problem the nodes correspond to the events that relate to the harmfulness of cloning operations.
to decide the nodes we collect a number of observable events i.e.
the features described in section .
that may be related to the harmfulness of intended cloning operations by observing existing cloning operations.
after deciding the nodes in the bayesian network we need to learn the structure and weights of the bayesian network from a number of training instances.
a training instance is a vector that indicates whether each event happens.
the typical algorithm for learning the structure of a bayesian network is the k2 algorithm which tries to maximize the maximal probability of the training instances for all possible weights.
the typical algorithm for learning the weights of a bayesian network is the maximum likelihood approach which tries to maximize the probability of the training instances.
in our approach we also rely on these two algorithms3 to construct the bayesian network from a number of cloning operations whose features and harmfulness are already known.
in section .
we present how we determine the features and harmfulness of already performed cloning operations via analyzing the historical versions of software projects.
after constructing the bayesian network we use it to predict the harmfulness of intended cloning operations.
in section .
we present the details of applying the constructed bayesian network.
we propose two scenarios in section .
where our predictor may help developers make decisions about code cloning operations.
.
considered features as mentioned in section .
our approach uses a set of features to predict the harmfulness of intended cloning operations.
specifically we use features in total which can be divided into three categories history features code features and destination features.
.
.
history features the reason for using history features is to consider the maturity of the copied piece of code.
intuitively when a developer performs copy and paste if the copied piece of code is mature and has few bugs the resulting clone segments will likely have few bugs and will not experience many bug fixing changes in the future.
the maturity of a piece of code can be related to the time and the number of changes it experienced.
therefore we consider the following six history features existence time denoted as et the period between the time of the appearance of the copied piece of code in the code base and the time of the cloning operation.
number of changes the number of changes that the copied piece of code has experienced in its evolution history.
number of recent changes the number of changes that the copied piece of code has experienced recently.
currently we deem of etto be recent.
file existence time denoted as fet the period between the time of the appearance of the file containing the copied piece of code and the time of the cloning operation.
3specifically our approach uses the implementation in weka .
number of file changes the number of changes that the file containing the copied piece of code has experienced in the evolution history of the file.
number of recent file changes the number of changes that the file containing the copied piece of code has experienced recently.
again we currently deem of fet to be recent.
among the six history features the first three features aim to characterize the changes to the copied piece of code itself and the other three features aim to characterize the changes to the file containing the copied piece of code.
.
.
code features the reason for using code features is to consider the impact of the syntactical characteristics of the copied piece of code on the harmfulness of the cloning operation.
as demonstrated in the examples in section if the copied piece of code does not depend on many other parts in the code base the clone group generated by the cloning operation will not be very likely to experience changes due to revisions in other parts of the code base.
therefore we consider the following eight code features.
number of lines the number of lines in the copied piece of code.
number of invocations the number of all method invocations in the copied piece of code.
number of library invocations the number of library method invocations in the copied piece of code.
number of local invocations the number of invocations of methods defined in the same class with the copied piece of code.
number of other invocations the number of invocations of methods that are neither from the library nor defined in the same class with the copied piece of code.
number of field accesses the number of field accesses in the copied piece of code.
number of parameter accesses the number of accesses to method parameters in the copied piece of code.
whether it is test code4 whether the copied piece of code belongs to test code.
the considered code features aim to characterize different ways the copied piece of code may depend on other parts.
as we do not know how each type of dependency impacts the harmfulness beforehand we consider all these features and rely on the construction algorithm of the bayesian network to weight these features.
.
.
destination features the reason for using destination features is to consider the similarity between the context of the copied piece of code and the context of the pasting destination.
intuitively if the context of the pasting destination is more similar to the context of the copied piece of code the clone group generated by the operation may be more likely to experience consistent changes in the future.
this is because the two clone segments may share more common dependencies and usages so that changing these dependencies and usages may impact both clone segments.
therefore we consider the following seven destination features5 4in microsoft the code base of a software project typically contains a large proportion of test code.
the dependence of test code on other code may typically be different from that of product code.
5it is possible that one cloning operation has multiple destinations.
in such a case for a boolean feature we set the value of the feature as true if the feature is true for at least one destinations and for a numeric feature we acquire the feature for each destination and use the maximal one as the feature of the cloning operation.
whether it is a local clone whether the pasting destination and the copied piece of code are in the same file.
file name similarity the similarity between the name of the file containing the copied piece of code and the name of the file containing the pasting destination.
currently we use the levenshtein distance based similarity .
in all the following features we also use levenshtein distance to measure similarities between strings.
masked file name similarity a variant of file name similarity.
when the clone is local the file name similarity has to be .
but the meaning is quite different from where the file name similarity is close to .
therefore we also use another feature for file name similarity.
for this feature the value is the same as the file name similarity when the cloning is not local but when the cloning is local.
method name similarity the similarity between the name of the method containing the copied piece of code and the name of the method containing the pasting destination.
sum of parameter similarities denoted as sps let us use m1andm2to denote the method containing the copied piece of code and the method containing the pasting destination respectively.
supposing that m1hasmparameters whose names are denoted as p1 p2 ... pm and m2hasnparameters whose names are denoted as q1 q2 ... qn we definesps as summationtextm i summationtextn j 1sim pi qj where pidenotes the name of the i th parameter of m1andqjdenotes the name of the the j th parameter of m2.
maximal parameter similarity denoted as mps we define mps asmax sim p i qj where i m j n andsim x y denotes the similarity between string xand string y. difference in only postfix numbers7 whether the name of the method containing the copied piece of code and the name of the method containing the pasting destination differ in only their postfix numbers.
again when selecting destination features we only consider whether each feature might be related to the harmfulness of cloning operations.
we rely on predictor construction to further sort out the relationships between the features.
.
constructing the harmfulness predictor we use the following three steps to construct our harmfulness predictor.
first we use a clone detector to identify a number of cloning operations performed in the version histories of existing software projects.
second for each cloning operation acquired in the first step we determine the values of the features of the cloning operation and whether the cloning operation is harmful or harmless thus forming a training instance.
third we construct the bayesian network based on the training instances.
.
.
collecting existing cloning operations to collect the cloning operations performed in the history of a software project we first download all the historical versions of the software project and perform clone detection on each of these versions.
then by mapping code location paths and file names of 6we further consider the maximal parameter similarity because usually one pair of very similar parameters may be more informative than several pairs of moderately similar parameters.
7we use this feature because developers often use a list of methods with different postfix numbers in their names to indicate different versions of a method.
this list of methods often contains many code clones but these clones seldom change consistently because only the method with the largest version number is going to change.173the code clones between each version and its previous version we build a clone evolution genealogy.
a clone evolution genealogy consists of a number of clone family trees each of which represents the history of one clone group.
each node in a clone family tree corresponds to a clone group in a certain version of the project.
in a clone family tree the root node corresponds to a clone group that cannot be mapped to any clone groups in the previous version.
if a clone group pin a version vican be mapped to another clone group p primein the previous version vi then the node corresponding to pis the child of the node corresponding to p primein a clone family tree.
after building the clone genealogy we collect all the clone groups that correspond to the root nodes of clone family trees.
since these clone groups cannot be mapped to any clone groups in the previous version we deem these clone groups as newly added by the developers through cloning operations.
we refer to these clone groups asoriginal clone groups in the rest of this paper.
this means that each original clone group corresponds to a cloning operation.
to precisely characterize a cloning operation we need to determine which clone segment in an original clone group is the copied piece of code and which clone segment contains the pasting destination.
specifically we use the following two heuristics if a clone segment segin an original clone group can be mapped to a code segment in the previous version we determine that segis a copied piece of code.
if none of the clone segments can be mapped to a code segment in the previous version we randomly choose a clone segment as the copied piece of code because in this case it is difficult to decide which segment is added first.
furthermore choosing any segment as the copied piece has relatively small effects to our approach because these code segments have exactly the same history features and usually have similar code features and target features.
note that it is unlikely that more than one clone segment in an original clone group can be mapped to a code segment in the previous version.
if so the two mapped code segments in the previous version should be a clone group in the previous version.
thus the existence of such a clone group is contradictory to our definition of original clone groups.
.
.
determining feature values and harmfulness of cloning operations to use the collected cloning operations as training instances for constructing our harmfulness predictor we also need to determine the values of the features and the harmfulness of each collected cloning operation.
to determine the values of the features we analyze the version that the cloning operation is performed on to extract the values of the features for the cloning operation.
since it is common for developers to make multiple changes between two continuous versions and it is difficult to decide the order of the changes we simply assume that any other changes will not impact the features of the cloning operations.
note that although our assumption for simplicity may introduce some noise into our training data the used machine learning technique can mitigate the impact of the noise in the training process.
as it is difficult to precisely measure the harmfulness of training instances we just classify the training instances into harmful cloning operations and harmless cloning operations for simplicity.
that is to say the harmfulness of a training instance is either for harmful or for harmless .
again this simplification may introduce some noise and we rely on the training process to deal with the noise.
specifically we automatically determine the harmfulness label of a training cloning operation based on the genealogy of the corresponding original clone group using the following heuristics if the clone group experiences no change or only inconsistent changes in the genealogy we deem the corresponding cloning operation to be harmless.
if the clone group experiences at least one consistent change we deem the corresponding cloning operation to be harmful.
based on the heuristics each code cloning operation will be labeled as either harmless or harmful.
the consideration behind our heuristic is that one consistent change can indicate extra maintenance cost caused by code cloning operation.
it is possible to apply our approach with other heuristics such as treating as harmful only the cloning operations whose resulting clone groups experience consistent changes more than twice.
to check whether and how a clone group changes in its genealogy we adopt a procedure used in existing empirical studies on code clones .
for cloning operation op our approach checks the nodes in the clone family tree t whose root node corresponds to the original clone group origin generated by op.
obviously except for the root node each node nintcorresponds to a clone group cg that is evolved from origin and cgcan be mapped to another clone group cg which corresponds to n s parent node in t in the version prior to the version containing cg.
thus we compare the clone segments in cgandcg 1to see whether at least two segments in cg are changed from their corresponding segments in cg .
if so we deem that a consistent change happens on cg .
otherwise we deem that there is no change or only an inconsistent change.
.
.
training the predictor after determining the values of the features and the label of harmfulness for each collected cloning operation we acquire a set of training instances.
based on the training set we construct a bayesian network which serves as our harmfulness predictor.
note that the training process automatically deals with noise irrelevant features and unorthogonal features.
.
prediction after constructing the harmfulness predictor we use it to predict the harmfulness of an intended cloning operation.
when a developer intends to perform a cloning operation our approach extracts the values of its features and uses the trained predictor to predict its harmfulness.
here our harmfulness predictor provides a prediction score that depicts the probability that the intended cloning operation is harmless.
this score can thus help the developers to decide whether to perform the cloning operation.
in practice there can be an application specific interpretation of the prediction scores to further help developers make the decision.
.
usage scenarios as mentioned in section we propose two scenarios where our approach may help developers make decisions on whether to perform a code cloning operation or not conservative scenario .
in this scenario developers are cautious and they only want to perform cloning operations when it is almost certainly safe.
they do not want to perform risky code cloning operations.
aggressive scenario .
in this scenario developers may want to perform as many cloning operations as possible for quick development due to a tight development schedule or other reasons.
therefore they want to block only a small proportion of the most risky cloning operations and avoid as many harmful operations as possible.
note that in these two scenarios our predictor provides suggestions to developers when they are going to conduct a code cloning operation.
this is a proactive way for preventing harmful cloning operations.
another possible way to check the harmfulness of a174code cloning operation is after it is made but before the cloned code is checked into the version control system.
in this way once a cloning operation is predicted as harmful the developer may either take actions immediately to remove it and then check in the revised code or check in the code and conduct code refactoring operation at an appropriate time in future.
in this way we may even use the information of possible edits the developer makes after the code cloning operation and thus enhance our approach.
in this paper we do not use the information from further edits for prediction to make our approach more general and applicable to both ways.
.
evaluation in this section we first introduce the methodology for our evaluation in section .
.
then we present the evaluation setup in section .
.
we present our evaluation results in sections .
.
and .
.
we discuss the threats to validity in section .
.
.
methodology we evaluate the effectiveness of our approach from the following four perspectives.
effectiveness of the conservative scenario .
in the conservative scenario we set a threshold close to and all the cloning operations with a predicted harmfulness value higher than the threshold are deemed as harmless cloning operations.
then we measure the effectiveness of our approach using the two metrics below approval rate the proportion of cloning operations that are predicted as harmless in all cloning operations for prediction.
precision the proportion of actually harmless operations in the cloning operations that are predicted as harmless in this scenario developers do not want to concede risky cloning operations while they can tolerate some potential harmless cloning operations being blocked so the precision is expected to be near and the approval rate is not expected to be so high.
effectiveness of the aggressive scenario .
in the aggressive scenario we set a certain threshold close to and all the cloning operations with a predicted harmfulness value lower than the threshold are deemed harmful cloning operations.
then we measure the effectiveness of our approach using the following two metrics blocking rate the proportion of cloning operations that are predicted as harmful in all cloning operations for prediction.
recall the proportion of harmful operations that are predicted to be harmful among all actually harmful operations in the cloning operations for prediction.
in this scenario since developers pay more attention to performing as many cloning operations as possible and blocking only those cloning operations predicted as harmful with high confidence it is expected that the recall value should be significantly higher than the value of the blocking rate.
contributions of the three types of features .
we studied the impact of different feature groups on the effectiveness of our approach.
this provides insight into how the underlying features contribute to the predictor.
we use the same metrics defined above to understand the contributions of the three groups of features.
feasibility for cross project prediction .
moreover developers may want to apply our approach on a new project that has too short a version history for our approach to collect training data.
in such a case one possible alternative solution would be cross project prediction in which the historical cloning operations of one project are used to predict the harmfulness of the cloning operations in another project.
therefore we further investigate whether our approach can help when performing cross project prediction.table subject software projects used in our evaluation project start date end date kloc xproj oct dec to yproj oct dec to .
evaluation setup we carried out our evaluation on two large industrial software projects from microsoft denoted as xproj and yproj in this paper respectively .
we chose the two projects for the following three reasons.
first both of the software projects have large code bases with millions lines of code.
therefore the evaluation results on these two projects may likely be generalizable to typical large industrial software projects.
second both of the software projects have relatively long version histories which enable us to extract enough cloning operations and precisely determine the harmfulness of the operations to build our training and testing sets.
third the two projects belong to different domains and are in different development phases.
xproj is a completely new project at microsoft launched in so its version history mainly records the initial development phase.
in contrast yproj is developed based on the code of a previous version of yproj so its version history mainly records the re engineering and maintenance phase.
therefore we can check the effectiveness of our approach on both phases.
the information about the two software projects is shown in table .
the second column of table presents the start date of each project.
the third column presents the date of the last version of each project used for our evaluation.
the fourth column presents the size range of each project in kloc i.e.
kilo lines of code between the start date and the end date in columns and .
for each software project we downloaded all the versions i.e.
weekly snapshots during the life time of the software project.
we used weekly snapshots because the number of code submissions for these two projects are extremely large and it is difficult to process them one by one in reasonable time.
then we extracted cloning operations using the process described in section .
.
from all the downloaded versions before december 31st .
we collected cloning operations from only these older versions which had existed in the software projects for more than two years because there may not be enough time for us to observe consistent or inconsistent changes in newly generated clone groups.
it should be noted that two years may not be a precise time slot and further investigation may be needed.
however our statistics show that the data between dec and dec only helps reveal .
of and of once viewed as harmless cloning operations to become harmful in xproj and yproj respectively.
so we believe that our labeling should induce very small error rates.
after that we extracted the harmfulness label and values of the features of all these collected cloning operations as described in section .
to build a data set which provides both the training data and the testing data.
finally we performed cross validation on the data set to acquire the effectiveness of our approach.
in our implementation we used weka .
to construct the bayesian network and set the weights.
table shows the detail about the data sets that we extracted from the two software projects.
in table columns present the project name the number of versions from which we extracted cloning operations the number of collected cloning operations the number of harmful cloning operations and the number of harmless cloning operations.
the numbers in the bracket in 8according to microsoft regulations we are unable to disclose the names and the application domains of the two projects.
9in the code clone detection step we used a near miss code clone detector from microsoft with the default setting of the tool i.e.
detecting code clones with no less than lines of code.175table details of the extracted data sets project versions cloning harmful harmless operations xproj .
.
yproj .
.
table effectiveness in the conservative scenario project threshold approval rate precision xproj .
.
.
xproj .
.
.
xproj .
.
.
xproj .
.
.
xproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
columns present the proportion of harmful and harmless operations in all cloning operations respectively.
from table we can make two observations.
first in both software projects the number of harmless cloning operations is much greater than the number of harmful cloning operations.
this observation is consistent with the findings of the empirical study by gode and koschke .
second yproj has fewer cloning operations compared with xproj.
the reason is that yproj is in the re engineering phase so there is less newly added code and thus fewer cloning operations.
note that we did not collect cloning operations from code clones that exist in the initial version of yproj because in such a case we were unable to accurately determine the harmfulness or the values of the features of those cloning operations.
.
effectiveness in the two scenarios table depicts the effectiveness of our approach for the conservative scenario using the following threshold values .
.
.
.
and .
.
in table column presents the combination of the project and the threshold value column presents the approval rate and column presents the precision of our approach.
from table we can make the following observations.
first with the threshold value of .
our approach is able to predict about to of the cloning operations as harmless with a precision higher than .
.
this demonstrates the value of our approach in the conservative scenario our approach provides a quite accurate suggestion of which cloning operations are safe while still allowing more than of the cloning operations.
without our approach it is difficult for developers to make such decisions confidently.
for example we can treat all cloning operations in proj x as approved cloning operations based on the judgement of developers of proj x since they have been already checked in to the version control system of proj x. however as shown in table the precision of prediction by developers is .
which is much lower than the precision of our approach.
therefore our approach provides conservative developers a guidance for approving only harmless cloning operations with high precision.
table shows the effectiveness of our approach for the aggressive scenario using the following threshold values .
.
.
.
and .
.
in table column presents the combination of the project and the threshold value column presents the blocking rate and column presents the recall.
from table we can make the following two observations.
first with all the threshold values our approach is able to avoid a large proportion of harmful cloning operations by blocking a much smaller proportion of cloning operations.
for example with thetable effectiveness in the aggressive scenario project threshold blocking rate recall xproj .
.
.
xproj .
.
.
xproj .
.
.
xproj .
.
.
xproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
yproj .
.
.
threshold value of .
our approach is able to avoid .
of the harmful operations in xproj by blocking only .
of all cloning operations and avoid .
of the harmful operations in yproj by blocking only .
of all cloning operations.
this demonstrates the value of our approach in the aggressive scenario with our approach developers may miss a small percentage of cloning operations while still blocking a significant percentage of harmful cloning operations.
without our approach the blocking rate and the recall should be about the same as the data used in our evaluation already reflects the practice of developers to perform cloning operations.
second the experimental results for the two projects have different blocking rate for the same threshold.
this indicates that a different threshold may be used for different projects to better utilize our approach.
.
impacts of feature groups as our approach uses three groups of features to predict harmfulness of cloning operations we removed each group of features at one time to check how each group of features contributes to the overall effectiveness of our approach.
we experimented with three variants of our approach each using two groups of features.
again we considered two scenarios the conservative scenario and the aggressive scenario .
with a fixed threshold it may be difficult to compare the different variants of our approach.
for example when under a certain threshold variant a can avoid of harmful cloning operations by blocking of cloning operations while variant b can avoid of harmful cloning operations by blocking of cloning operations.
it would be difficult to judge which variant is better.
therefore in the comparison we fixed the approval rate as and i.e.
in the approval rate range of our approach using thresholds between .
and .
for the conservative scenario and fixed the blocking rate as and i.e.
in the blocking rate range of our approach using thresholds between .
and .
for the aggressive scenario .
tables and show the results of comparing the three variants with our approach i.e.
using all three groups of features for the two projects.
from tables and we can make the following observations.
first removing the history features has small impacts on the prediction in both scenarios.
second removing the destination features results in significantly negative impacts on the effectiveness in both scenarios.
third removing the code features results in a small impact in the conservative scenario but a significantly negative impact in the aggressive scenario .
fourth removing some features may even slightly improve the results in some scenarios due to possible noise in those features.
these observations indicate that it may be feasible to use only the code features and the destination features to predict the harmfulness of intended cloning operations.
10note that blocking cloning operations is equivalent to approving cloning operations.176table precision of the three variants in the conservative scenario project all without without without approval rate history code destination xproj .
.
.
.
xproj .
.
.
.
xproj .
.
.
.
yproj .
.
.
.
yproj .
.
.
.
yproj .
.
.
.
table recall of the three variants in the aggressive scenario project all without without without blocking rate history code destination xproj .
.
.
.
xproj .
.
.
.
xproj .
.
.
.
yproj .
.
.
.
yproj .
.
.
.
yproj .
.
.
.
.
effectiveness of cross project prediction in section .
our cross validation is based on each project individually.
for each subject project we divided the collected cloning operations into the training set and the testing set.
then we used the training set to train a predictor and tested it on the testing set.
however if developers would like to leverage our approach at the beginning of their project there will not be enough training data from the project.
in such a case the developers may have to use a predictor trained from the data of another software project which we refer to as cross project prediction.
cross project prediction is notoriously difficult for many mining based software engineering approaches since software projects are often very different from each other in their usages structures programming rules etc.
what makes the situation even worse is that it is difficult to measure and handle such differences.
therefore it would be interesting to study whether our approach still provides help for cross project prediction.
to perform cross project prediction we evaluated our approach by training our predictor with the data from xproj and tested the predictor on yproj and vice versa.
tables and depict the results of cross project prediction in the two scenarios respectively.
in both tables we use xproj yproj to denote training on xproj and testing on yproj and yproj xproj to denote the opposite.
from table we can observe that with a threshold of .
for the setting of xproj yproj our approach can approve cloning operations with a precision of .
and for the setting of yprojxproj our approach can approve .
cloning operations with a table effectiveness for cross project prediction in the conservative scenario setting threshold approval rate precision xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
table effectiveness for cross project prediction in the aggressive scenario setting threshold blocking rate recall xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
xproj yproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
yproj xproj .
.
.
precision of .
.
compared with table we observe that the effectiveness of our approach on cross prediction drops.
however in yproj the proportion of harmless is and in xpoj the proportion is .
.
therefore our approach can still enhance the precision by .
for yproj and .
for xproj compared to random selection note that the improvement is not trivial considering that the precision is already very high .
furthermore with a threshold of .
our approach with the xproj yproj setting may approve more than of cloning operations with a precision of .
and with the threshold .
our approach with the yprojxproj setting may approve more than of cloning operations with a precision of .
.
this observation demonstrates that our approach has the potential to be used in cross project prediction in practice if developers can appropriately tune the threshold to maintain an appropriate blocking rate.
similarly comparing table and table we can observe that our approach is also significantly less effective in the aggressive scenario for cross project prediction than for inner project prediction.
with a threshold of .
for the setting of xproj yproj our approach blocks of cloning operations to avoid .
of harmful cloning operations and for the setting of yproj xproj our approach blocks .
to avoid .
of harmful cloning operations.
however for the setting of yproj xproj our approach still achieves a improvement over random selection and for the setting of xproj yproj our approach may achieve a similar improvement if the threshold is appropriately tuned.
in summary empirical results presented in this subsection indicate that our approach is able to provide help for cross project prediction and has a large space of enhancement if developers can appropriately tune the threshold.
furthermore it should be noted that as we used two quite different projects in our evaluation our crossprediction had to be based on training on one project and testing on the other project and thus concede significant negative impacts induced by project differences.
in practice we may use multiple projects similar to the target project for training so that the trained predictor is more suitable for the target project.
furthermore as our approach is based on machine learning it is also possible to gradually add cloning operations performed in the target project into the training set to make the training process adaptable to the target project.
we expect these enhancements to further boost our approach for cross project prediction.
.
threats to validity in our evaluation we applied our approach to the version histories of two software projects.
this factor may be a threat to external validity since it is possible that our empirical results are specific to the two software projects used in our evaluation and may not be applicable to other projects.
to reduce this threat we chose large industrial software projects as subjects from different domains.
the177main threats to internal validity are the unintentional inconsistent changes i.e.
inconsistency bugs that may lead us to erroneously mark a cloning operation as harmless.
however we believe that for developers the probability of bringing in inconsistency bugs is much less than the probability of correctly maintaining the consistency.
recent studies also support this belief.
another threat to internal validity is that we use a limited observation time slot to decide whether a code clone experiences inconsistent changes which also may lead us to erroneously mark a cloning operation as harmless.
to reduce this threat we use a relatively long observation time slot two years and our study in section .
shows that such a long time slot will bring in few errors in marking cloning operations.
the main threats to construction validity is that we used cloning operations recovered from the version histories as the training set and the testing set.
there might be slight differences between feature values of recovered cloning operations and feature values of intended cloning operations because there was some information loss in the version history e.g.
for simultaneously added clone segments we randomly choose one as the copied piece of code which may be not the case .
however we believe that this threat to construction validity should not have drastic impacts on the effectiveness of our approach since the resulting differences in feature values are typically small.
.
discussion kasper and godfrey classified cloning operations into three categories according to their purposes .
the three categories are forking clones templating clones and customization clones.
in forking clones developers clone a large component for a new environment or different users.
in templating clones developers clone a piece of code elsewhere to perform similar functions such as copying the sorting method from a class for the author list to a class for the paper list.
customization clones are similar to templating clones except that customization clones require revisions after the cloning.
actually the effectiveness of feature groups in our approach may differ for different categories of clones.
for example for forking clones history features and code features may be more important because in such clones instability and dependence on components unrelated to the environment are key factors for consistent changes.
by contrast for templating clones destination features may be important since similar contexts will enhance the likelihood of consistent changes.
for customization clones history features and code features sometimes may be misleading because the revisions in the cloned code affect the precision of these two features while destination features may remain discriminative.
therefore we may further improve our approach by considering kasper and godfrey s clone categories if we are able to automatically identify the category of cloning operations.
.
related work to the best of our knowledge the research presented in this paper is the first automated approach that predicts the harmfulness of intended cloning operations.
our research is motivated by the findings of recent empirical studies on code clones and we also use some existing techniques to process code clone genealogies.
kim et al.
first combined code clone detection tools and version history analysis tools to extract code clone genealogies.
based on clone genealogies they discovered that it is not always worthwhile to refactor code clones.
kapser and godfrey also studied code clones in existing software projects and classified clones into categories .
juergens et al.
studied a large number of code clones in software projects to find the reasons why developers prefer code clones .
gode and koschke conducted another empirical study on code clone genealogies.
in their study they dis covered that fewer than half of code clones will experience changes and even a smaller proportion will experience consistent changes that lead to extra maintenance cost.
thummalapenta et al.
performed an empirical study on the evolution patterns of code clones.
the major findings of their study include that in only a small number of cases developers forget to make consistent changes to code clones and failing to propagate bug fixes among code clone segments is the main reason for the forgotten consistent changes.
cai and kim empirically studied long lived code clones in software projects and identified some key features in the evolutionary history of a code clone that relate to the existing time of the code clone.
our research differs from the preceding research in the following two aspects.
first our approach aims to predict the harmfulness of intended cloning operations while existing research does not provide explicit support for the harmfulness prediction of code clones.
second our approach targets harmfulness prediction at copy and paste time and thus can utilize only features available at the time of copy and paste but existing research does not distinguish copy and paste features from clone evolution features and thus can hardly be applied to our problem.
code clone detection which is also closely related to our research has been a research focus for many years.
due to space limits we list only some of representative research in the area of code clone detection.
kamiya et al.
developed ccfinder which transforms a program into tokens and detect clones by performing token by token comparison.
li et al.
proposed cp miner which uses frequent sequence mining to identify similar sequences in the tokenized program.
jiang et al.
proposed deckard a syntax tree based code clone detection tool which discovers similar tree structures in the syntax tree of the code base.
later researchers also developed approaches to find similar structures in system dependence graph of a software .
gable et al.
simplified system dependence graphs of a software code base to trees and use an algorithm similar to deckard to detect similar dependence structures.
recently kim et al.
proposed an approach based on symbolic execution to detect semantic clones in the code base.
in our research we used the clonecodedetector from microsoft for data collection in our evaluation because clonecodedetector is scalable and stable enough to be efficiently applied in the huge code bases of the two projects used in our evaluation.
another area related to our research is machine learning based defect prediction.
defect prediction approaches try to predict the number of defects in a given software component.
similar to our approach machine learning based defect prediction also relies on features extracted from code and version histories.
menzies et al.
proposed using multiple classifiers to predict defects and evaluated their techniques on the nasa software defect data.
emam et al.
compared different case based classifiers and concluded that varying the combination of parameters of the classifier does not help to improve prediction precision.
kim et al.
further studied the impact of noise in the training data on the effectiveness of defect prediction approaches.
compared to defect prediction approaches our approach targets a different problem.
furthermore our approach uses a different set of features.
specifically among the three feature groups in our approach our history features are similar to history features used in defect prediction our code features focus on code dependence while code features in defect prediction focus on code complexity and bad smells destination features are specific to cloning operations.
.
future work we deem the research presented in this paper as the first step towards fully understanding the harmfulness of intended cloning178operations.
the following directions for further research may help overcome the limitations of our current research.
first although our evaluation indicates that our harmfulness predictor can provide practical help for developers there is still room to improve our approach.
in fact when the prediction score on the harmfulness of a cloning operation is between .
and .
it is still difficult for us to accurately predict whether the operation will be harmful or harmless.
we plan to consider adding more features and or varying existing features to improve the effectiveness of our approach.
for example we may use an absolute time threshold instead of a relative time threshold when computing the number of recent changes.
furthermore besides considering the dependence of the copied code piece it may also be helpful to consider the maturity and dependence of the code that the copied code piece depends on.
second our current evaluation is based on only two microsoft software projects written in c .
it would be interesting to evaluate our approach on more software projects such as open source software projects and or software projects written in other languages.
furthermore our current evaluation mainly considers two practical scenarios.
to evaluate our prediction in more general scenarios we plan to involve more metrics such as f score and cohen s kappa co efficient to further evaluate our approach.
third our evaluation includes a quantitative study on a number of cloning operations in the version histories of software projects.
to fully reveal the strength and weakness of our approach we plan to design and conduct a number of qualitative case studies involving developers so that we can further confirm whether the identified harmful harmless cloning operations are consistent with developers feelings and or identify more issues for developers to perform cloning operations.
.
conclusion in this paper we have proposed a novel approach that assists developers in understanding the harmfulness of intended cloning operations using bayesian networks.
our approach may provide guidance for developers on selectively performing cloning operations in a conservative or an aggressive way with a reduced cost of maintenance.
we have also evaluated our approach for both conservative and aggressive scenarios using two large scale industrial software projects from microsoft.
our empirical results demonstrate that our approach may be practically useful for both types of scenarios in the conservative scenario our approach can approve to of harmless cloning operations with precision higher than .
.
in the aggressive scenario our approach can block to of harmful cloning operations with the cost of blocking only to of cloning operations.
.