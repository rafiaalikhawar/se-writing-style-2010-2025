generating range fixes for software configuration yingfei xiong arnaud hubaux steven she and krzysztof czarnecki generative software development lab university of waterl oo canada yingfei shshe kczarnec gsd.uwaterloo.ca precise research centre university of namur belgium ahu info.fundp.ac.be abstract to prevent ill formed configurations highly configurable software often allows defining constraints over the available options.
as these constraints can be complex fixing a configuration that violates one or more constraints can be challenging.
although several fix generation approaches exist their applicability is limited because they typically generate only one fix failing to cover the solution that the user wants and they do not fully support non boolean constraints which contain arithmetic inequality and string operators.
this paper proposes a novel concept range fix for software configuration.
a range fix specifies the options to change and the ranges of values for these options.
we also design an algorithm that automatically generates range fixes for a violated constraint.
we have evaluated our approach with three different strategies for handling constraint interactions on dat a from five open source projects.
our evaluation shows that even with the most complex strategy our approach generates complete fix lists that are mostly short and concise in a fraction of a second.
i. i ntroduction a growing share of software exposes sophisticated configurability to handle variations in user and target platfo rm requirements.
large enterprise systems operating system s and embedded software need to be tailored to different user needs hardware and other requirements.
for example linux kernel can be configured to run on different hardware systems and the user typically selects the cpu architectur e e.g.
x86 or arm the type of filesystem e.g.
ext4 or jfs and the graphics driver e.g.
ati or nvidia .
these configuration options also known as features are usually described with variability modeling languages .
for instance the linux kernel uses kconfig and ecos an embedded configurable operating system uses cdl .
in academia a popular variability modeling language is featu re model which has an expressiveness comparable to that of kconfig and cdl .
configurators translate these models into interactive configuration interfaces such as the one in figure and assist users in arriving at a correct and complete configuration.
to do so configurators detect possible configuration errors and report them.
a configuration error is a decision that conflicts with some constraints.
satisfying these constrai nts can be non trivial.
variability languages often provide ad vanced constructs that introduce hidden constraints a nd constraint rules declared in different places of the variab ility model may have interactions.
the interplay of these factors often leads to very complex situations.
figure the ecos configurator some configuration tools like those based on kconfig implement an error avoidance mechanism that automatically deactivates an option when a certain constraint is violated .
inactive options are no longer available to the user unless the constraint is satisfied again.
other configurators like the ecos configurator for cdl figure add an interactive resolution mechanism on top of the avoidance mechanism.
this approach allows violating some constraints but proposes a fix for each violated constraint.
a fix denotes a set of changes that would restore the consistency of the current configuration.
to better understand what challenges are faced by the users of modern configurators we carried out two surveys respectively of linux and ecos users .
two questionnaires were submitted to forums mailing lists and experts with whom we collaborate.
in total we collected answers from 97linux users with up to 20years of experience and 9ecos users with up to 7years of experience.
we present here the two challenges that stand out most from this study and that are addressed in this paper activating inactive features.
of the linux users report that when they need to change an inactive option they need at least a few dozen minutes in average to figure out how to activate it.
of the ecos users also consider the activation of an inactive option to be a problem.
fix incompleteness.
existing configurators generate only one fix for an error.
however there are often multiple solutions to resolving an error and the user may prefer other solutions.
7out of 9ecos users have encountered situations where the generated fix is not useful .
that claim is corroborated by berger et al.
who report that ecos users complain about the incompleteness of fixes on the ecos mailing list.
since activating an inactive feature requires satisfying978 .
c ieee icse zurich switzerland 89an appropriate constraint activation is inherently the sa me as resolving a configuration error.
as a result a possible solution for the above two problems is to generate fixes for both resolving errors and activating features.
the set of fix es should be complete so that the user can choose the one he wants.
to achieve this goal two main challenges need to be addressed.
first our previous study of ecos models shows that non boolean operators such as arithmetic inequality and string operators are quite common in their constraints.
in fact the models contain four to six times mo re non boolean constraints than boolean ones.
non boolean constraints are challenging since there is often an infinite number of ways to satisfy them.
computing such infinite list of fixes is pointless.
thus a compact and intentional representation of fixes is needed.
second many existing approaches e.g.
fail to generate a complete list of fixes because they are built upon constraint solvers which returns only one result per call.
to get a complete list of fixes we need to find a new method to interact with constraint solvers.
this paper proposes a new approach to generating fixes for software configuration.
our contribution is threefold range fixes.
we propose a novel concept range fix section ii to address the first challenge.
instead of telling users what concrete changes should be made a range fix tells them what options should be changed and in what range the value of each option can be chosen.
a range fix can represent infinite number of concrete fixes and still retains the goal of assisting the user to satisfy constraints.
particularly we discuss the desired properties of range fixes which formalize the requirements on the fix generation problem.
in addition we also discuss how constraint interactions should be handled in our framework section iv .
fix generation algorithm.
we designed an algorithm that generates range fixes automatically section iii to address the second challenge.
our algorithm builds upon reiter s theory of diagnosis and smt solvers .
additionally our algorithm is designed for a general representation of constraints and variables which makes it potentially useful in other areas.
evaluation with ecos.
our algorithm is applied on ecos cdl section v and evaluated on constraint violations from five open source projects using ecos section vi .
the evaluation compares three different fix generation strategies.
even with the most complex propagation strategy our notion of range fix leads to mostly simple yet complete sets of fixes of the fix lists have sizes smaller than where the size is measured by summing up the number of variables in all the fixes in the list and our algorithm can also generate fixes for models containing hundreds of options and constraints in an average of 50ms and a figure option startup maximum of 245ms.
we discuss threats to validity in section vii and the related work in section viii.
we conclude the paper in section ix.
ii.
r ange fixes motivating example we now motivate our work with a concrete example based on the ecos configurator .
figure shows a small model for configuring an object pool.
the left panel shows a set of options that can be changed by the user.
the lower right panel shows the properties of the currently selected option defined by the ecos model.
particularly the flavor property indicates whether the option is a boolean option or a data option.
a boolean option can be either selected or unselected a data option can be assigned an integer or a string value.
in figure preallocation size is a data option use pre allocation is a boolean option.
besides the flavor each option may also declare constraints using requires property or active if property.
when a requires constraint is violated an error is reported in th e upper right panel.
in figure option pre allocation siz e declares a requires constraint requiring its value be small er than or equal to object pool size and an error is reported because the constraint is violated.
an active if constraint implements the error avoidance mechanism.
when it is violated the option is disabled in the gui and its value is considered as zero.
figure shows the properties of the startup option.
this option declares th at at most half of the object pool can be pre allocated.
since this constraint is violated the startup option is disabl ed and the user cannot change its value.
fixing a configuration error or activating an option requires satisfying the corresponding constraints.
in order to fix the error on pre allocation size in figure we need to look up the definition of object pool size .
in figure we see that object pool size declares a calculated property meaning that the value of the option is determined by the declared expression and cannot be modified by the user.
as a result the constraint declared on pre allocation size is in fact the following pre allocation size buffer size object size furthermore according to the cdl semantics when an option is inactive the constraints it declares are not considered by the error checking system.
an option is inactive when its active if constraint is violated or its parent opti on90figure option object pool size is deselected.
pre allocation size has a parent yieldin g the following complete constraint use pre allocation pre allocation size buffer size object size by analyzing the constraint we realize that we may fix the error by one of the following changes decreasing preallocation size or increasing buffer size or decreasi ng object size or more simply disabling the pre allocati on function.
now we could choose one of these possibilities and navigate to the respective option to make the change.
this example shows that there are three sub tasks for enabling a constraint.
first the user needs to figure out the complete semantic constraint according to the constraint l anguage.
since variability languages often have fairly compl ex semantics on visibility and value control it is very eas y to overlook some part of the constraint.
second users need to analyze the semantic constraint such as the complete constraint above and figure out how to change the options to make it satisfied.
in practice constraints can be very lar ge.
one semantic constraint we have found in a cdl model contains 55option