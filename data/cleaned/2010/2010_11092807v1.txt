leveraging software architectures to guide and verify the development of sense compute control applications damien cassou emilie balland charles consel julia lawall inria university of bordeaux diku inria lip6 first.last inria.fr julia diku.dk abstract a software architecture describes the structure of a computing system by specifying software components and their interactions.
mapping a software architecture to an implementation is a well known challenge.
a key element of this mapping is the architecture s description of the data and control flow interactions between components.
the characterization of these interactions can be rather abstract or very concrete providing more or less implementation guidance programming support and static verification.
in this paper we explore one point in the design space between abstract and concrete component interaction specifications.
we introduce a notion of interaction contract that expresses allowed interactions between components describing both data and control flow constraints.
this declaration is part of the architecture description allows generation of extensive programming support and enables various verifications.
we instantiate our approach in an architecture description language for sense compute control applications and describe associated compilation and verification strategies.
categories and subject descriptors d. .
software architectures domain specific architectures languages patterns general terms design languages verification keywords generative programming architectural conformance .
introduction a sense compute control scc application is one that interacts with the physical environment .
such applications are pervasive in domains such as building automation assisted living and autonomic computing.
developing an permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.sccapplicationiscomplexbecausetheimplementationmust address both the interaction with the environment and the application logic because any evolution in the environment must be reflected in the implementation of the application and because correctness is essential as effects on the physical environment can have irreversible consequences.
we have observed that scc applications can be defined according to an architectural pattern involving four kinds of components organized into layers sensorsat the bottom which obtain information about the environment then context operators which process this information thencontrol operators which use this refined information to control actuators at the top which finally impact the environment.
data and control flow interactions between these layers are restricted.
sensors may be proactive and initiate data flows when they detect changes in the environment while the other kinds of components are only reactive.
context operators may receive information from sensors or other context operators and may interrogate the same to obtain further information.
control operators can receive information only from context operators and actuators are only activated by orders such as turn on or send this email sent by the control operator layer.
while our experience shows that this scc architectural pattern captures the architecture of many kinds of scc applications the question remains of how to exploit it to guide an implementation.
when a software architecture is expressed formally using an architecture description language adl and is sufficiently concrete it may be possible to generate an implementation automatically.
but this requires providing a complete description of the application behavior in the architecture which mixes concerns obscures the interaction constraints and defeats reusability.
in particular the scc architectural pattern describes application design at a more abstract level in that it does not incorporate the application logic.
mapping such an abstract software architecture into an implementation and maintaining the relationship between the architecture and the implementation as they evolve are well known to be complex tasks .
several recent approaches have considered the relation between architecture and implementation focusing on the interaction between components.
one such approach is archjava that embeds an adl into a programming language to allow architectural concerns to be part of the application code .
this approach however entails a mixing of the architecture and implementation that may obscure both of them.
to regain separation of concerns between architecture description and implementation archface proposesarxiv .2807v1 sep 2011a new interface mechanism leveraging concepts from aspect oriented programming aop to describe component interactions.
aop pointcuts abstract the structure of implementations providing constraints such as when a particular method must be called during a given control flow.
such approaches make it possible to verify that an implementation conforms to an architecture description.
still both of these approaches blur the separation between architecture description and implementation making the architectural design phase more difficult.
in this paper we propose an approach to linking architecture and implementation that specifically targets scc applications.
our approach balances the abstraction and concreteness of the architecture description by introducing a notion of interaction contract .
an interaction contract declares what interactions a given component can perform expressing in high level terms both data and control flow constraints.
this declaration is part of the architecture description keeping this phase separated from the implementation.
yet our interaction contracts allow the architect to precisely specify the interactions between components without simultaneously having to reason about code structure.
interaction contracts furthermore can be used to generate extensive programming support ensuring the conformance between the architecture and the implementation and guiding the development phase.
the architect can also use the constraints expressed by interaction contracts to verify a range of properties beyond implementation conformance.
contributions.
in this paper we introduce an architecturedriven generative methodology that improves the design programming and verification of scc applications.
our contributions are as follows.
we introduce a language for interaction contracts dedicated to scc applications section .
we show that interaction contracts can guide the implementation of scc applications by enabling the generation of highly customized programming frameworks using a dedicated compiler section .
this approach ensures that the architecture conforms to the implementation while facilitating software evolution.
we show that such interaction contracts are precise enough to verify safety properties such as information flow reachability or interaction invariants section .
we extend our previously developed implementation of an adl targeting scc applications with interaction contracts and use this implementation to assess the benefitofinteractioncontractsataconceptualleveland in terms of metrics on the resulting code section .
.
our approach we first present the scc architectural pattern and then introduce the notion of interaction contract.
the scc architectural pattern is based on the sense compute control pattern presented by taylor et al.
and on the pattern presented by chen and klotz for ubiquitous computing systems.
interaction contracts enrich the scc architectural pattern to describe interactions among components.
.
scc architectural pattern we first introduce the terminology and concepts used throughoutthepaper.
thedataflowofthesccarchitecturalpattern is expressed by an oriented graph whose nodes are the architecture components and whose solid edges indicate data exchange between components see figure .
we say that thechildrenandparentsof a component are respectively the sources of the incoming edges and targets of the outgoing edges connected to the component.
there are two types of interactions a component can perform pushingdata to the parents or responding to a pullrequest from one of its parents.
pull requests are represented in the graph as dashed edges and can be parameterized.
the scc application pattern involves four layers sensors context operators control operators and actuators.
each layer corresponds to a separate class of components sensorssend information sensed from the environment to the context operator layer through data sources.
sensors can both push data to context operators and respond to context operator requests.
we use the term sensor both for entities that actively retrieve information from the environment such as system probes and entities that store information previously collected from the environment such as databases.
context operators refine aggregate and interpret the information given by the sensors.
context operators can push data to other context operators and to control operators.
context operators can also respond to requests from parent context operators.
control operators transform the information given by the context operators into orders for the actuators.
actuators trigger actions on the environment.
sensors are proactive orreactivecomponents whereas context operators control operators and actuators are always reactive.
these properties ensure that scc applications are reactive to the environment state.
that is all computation is initiated by a publish subscribe interaction with a sensor.
as the underlying architecture is component based the application can be fully distributed.
to prevent concurrent handling of events in a component all interactions of a component are queued and executed one at a time sequentially.
.
example as a running example we define the architecture of a web server monitoring application.
in this scc application the considered environment is a tier system consisting of a web server and associated network tools.
the two tasks that we want to implement are updating a log containing profiles of the web server s clients client name and ip address and sending an email to administrators in case of intrusions.
figure illustrates the component layers and the data flow interactions between the components of this application.
sensors.
the state of the environment is observed using three sensors.
the access log reader provides one information source named line.
this information source is updated when a new line is added to the log for an access to the server.
the nslookup tool returns the host name associated with an ip address via the information source named ip2host.
the ldap server returns the profile of a host name via the information source named host2profile .
context operators for profile identification.
the accessingprofile context operator in the middle of figure calculates which profile is accessing the web server.
this context operator is activated by the accesslogparser context operator which is itself activated by the informationaccessing profile accesslogparserintrusion detector host2profile ldapserverip2host nslookupline accesslogreaderip2profiledata flow pull requestprofilelogger intrusioninformersendmailer loglogger actuator control operator context operator sensor figure architecture of a web server monitor.
solid arrows represent data flow.
dashed arrows represent pull requests.
for simplicity the diagram does not show the types of the values calculated by the components and the types of the parameters required by pull requests.
source lineof the accesslogreader sensor.
when a new line is added to the log accesslogparser parses the line to create a higher level structure including the ip address of the person accessing the web server and the requested page.
this information is passed to accessingprofile which extracts the ip address from the structure and then asks the ip2profile context operator to compute a profile.
this profileisobtainedbyqueryingthe nslookup andthe ldapserver sensors.
pull requests on ip2profile and nslookup are parameterized by an ip address.
pull requests on ldapserver are parameterized by a host name.
context operators for intrusion detection.
the intrusiondetector context operator uses the context calculated by accessingprofile includingtheinformationaboutthemost recent access to the web server and the client profile associated with this access.
intrusiondetector only propagates accesses that are suspected to represent intruders.
control operators and actuators.
the monitoring tasks are implementedbythe intrusioninformer andprofilelogger control operators which respectively invoke the mailerand loggeractuators using the sendand logactions.
to notify the administrator of an intrusion intrusioninformer only needs to be informed by the intrusiondetector context operator of any new intrusion.
to update the profile log profilelogger only needs to be informed by the accessingprofile context operator of which profile is accessing the server.
in this example we can observe that the architecture description in figure is underspecified.
while it may be intuitively obvious that the ip2profile context operator reacts only to parent pull requests as ldapserver and nslookup neverpushdatabythemselves thisinformationisnotexplicit in the architecture description.
this underspecification may lead to different interpretations of the architecture description and incompatible implementations.
to address these issues we enrich the architecture description by annotating each context operator with an interaction contract .
.
interaction contracts the goal of an interaction contract is to describe the interactions that are allowed by the context operators of an scc application.
in a reactive system the most basic information is what makes a context operator react i.e.
acontext operator associated interaction contract accesslogparser angbracketleft line self angbracketright accessingprofile angbracketleft accesslogparser ip2profile self angbracketright ip2profile angbracketleft self ip2host host2profile angbracketright intrusiondetector angbracketleft accessingprofile self?
angbracketright table interaction contracts associated to the context operators of the web server architecture.
line ip2hostand host2profile abbreviate accesslogreader.line nslookup.ip2host and ldapserver.host2profile respectively.
data pull request from one of its parents or a data push from its children.
in this reaction a context operator may need to pull data from its child context operators or child sensor sources.
finally a reaction may or may not lead to the push of a new value.
we group the information about these three kinds of interactions into a basic interaction contract .
definition .a basic interaction contract angbracketlefta u e angbracketrightis a tuple where a uandeare named respectively the activation condition the data requirements list and the emission.
these elements are defined as follows a a1 ... a n self wheren aiis the name of a child of the current context operator a sensor source or a context operator or a disjunction of such names and self indicates the context operator itself.
a1 ... a n corresponds to the push of values from all the children a1 ... a n. if anyaiis a disjunction of names then the information associated with any of these names can be used.
selfcorresponds to a pull request from a parent of the context operator.
a pull request always returns a value to the calling parent.
u b1 ... b n wheren 0andbiis the name of a child of the current context operator a sensor source or a context operator .
this information is accessed by a pull request and the developer may choose to access it or not.
e self self?
indicates respectively whether the context operator always sometimes or never pushes a new value to all its parents.
when a self a value is always returned to the requesting parent regardless ofe.
an interaction contract defines how a context operator interacts with its parents and children and in this sense is related to interaction descriptions such as automata based models as analyzed in section .
table specifies the interaction contracts for the web server monitoring architecture.
for example the interaction contract of the intrusiondetector indicates via the notation self?
that when intrusiondetector receives a new profile from accessingprofile it might or might not push a profile.
in practice intrusiondetector only pushes a profile when the profile is suspected to correspond to an intrusion.
in contrast the emission of the interaction contract associated with ip2profile is .
when this component receives a pull request it returns the data to the parent that sent the request but it does not inform the other parents if any by publishing the data.
synchronization.
asequence a1 ... a n intheactivation condition of an interaction contract indicates the synchronization of multiple information sources.
suppose that thecontext calculated by the accesslogparser context operator were refined into two types of contexts the geographic location of the host and the web browser used for this access represented by the context operators localizationcalc and webbrowsercalc respectively see figure .
the information calculated by these context operators is then combined using a new context operator infocalc .
its interaction contract is angbracketleft webbrowsercalc localizationcalc self angbracketright which ensures that we obtain synchronised information from localizationcalc and webbrowsercalc .
accesslogparserlocalisation calcinfocalc webbrowser calc figure example of synchronization.disjunction.
a disjunction of names in an activation condition indicates that a context operator can use any one of multiple distinct contexts.
for example in a web server a dangerous access can be due either to an intrusion or to an sql injection.
the information about both conditions has the same type access.
suppose we have a new context operator sqlinjdetector that pushes accessdata when there is an sql injection.
then we can define adangerdetection context operator that abstracts over these two types of danger using the interaction contract angbracketleft intrusiondetector sqlinjdetector self angbracketright interaction contract composition.
as a context operator can be activated by different conditions possibly leading to different behaviors we introduce the bardbloperator that allows the combination of several basic interaction contracts.
a composition of basic interaction contracts is for example necessary when a context operator can be activated by both a data pull from one of its parents and a data push from one of its children.
for example the accessingprofile context operator could have a second interaction contract angbracketleft self angbracketrightthatallowsaccesstothemostrecentvalueofthis context at any moment in the execution of the application.
.
architecture consistency and determinacy an interaction contract of a context operator implies interaction requirements on the operator s parents and children.
for example given a context operator a the existence of some interaction contract whose data requirement is a implies that ahas an interaction contract whose activation condition is self.
an architecture is consistent when each of its interaction contracts respects the requirements imposed by all other interaction contracts of the architecture.
furthermore a given data flow should not trigger the activation of multiple basic interaction contracts of a single context operator.
this situation occurs for example if the activation conditions of two different interaction contracts of a single context operator are both pull requests.
an architecture isdeterministic if no context operator has a pair of basic interaction contracts that are activated by the same data flow.
given a basic interaction contract angbracketlefta u e angbracketright let names a bethesetofnamesofsensorsourcesorcontextoperators self included used in a. for example names p q r p q r and names self self .
definition contract consistency .
given an architecture an interaction contract is consistent relative to if one of the following conditions is satisfied if angbracketlefta b1 ... b m e angbracketrightthen for eachbithat is a context operator there is a behavioral contract angbracketleft self angbracketrightassociated with biin ifa ... then for each n names a that is a context operator there is an interaction contract angbracketleft self angbracketrightor angbracketleft self?
angbracketrightassociated with n in .
if 1 bardbl... bardbl nthen each iis consistent relative to .
definition architecture consistency .
an architecture is consistent if each interaction contract associated with its context operators is consistent relative to .
definition contract interference .
a basic interaction contract angbracketlefta u e angbracketrightinterferes with a basic interaction contract angbracketlefta prime u prime e prime angbracketrightifnames a names a prime negationslash .
definition contract determinacy .
an interaction contract 1 bardbl bardbl nis deterministic if each basic interaction contract idoes not interfere with any of the others.
definition architecture determinacy .
an architecture is deterministic if all its interaction contracts are deterministic.
to ensure consistency and determinacy of an architecture the architecture compiler should enforce these properties.
.
interaction contract semantics a context operator can be viewed as a function as it reacts to some inputs and potentially produces an output.
thus the denotational semantics of an interaction contract is a function type.
intuitively each possible implementation of a context operator whose interaction contract is c corresponds to a function of type jck as defined in table .
in this table orepresents a context operator and tits return type.
essentially the activation condition and the data requirements determine the types of the parameters of this function and the emission determines its return type.
each data requirement maps to the type of a callback function that takes the request parameters as arguments.
if a context operator is associated with several interaction contracts denotedc1 bardbl... bardblcn then the type of the context operator is represented as a tuple of functions jc1k ... jcnk.
the rules in table use the functions args publish typeof andaccess typeof defined as follows.
given an identifier n that is the name of a context operator or a sensor source the function typeof n mapsnto its type.
for example in the web server application typeof line string typeof accesslogparser access typeof accessingprofile profile note that typeof a1 a2 typeof a1 typeof a2 where denotes the operator for the union type in java for example t1 t2is the smallest common supertype of t1 andt2 which is at worst the type object .
the function access typeof n mapsnto the type of a data pull request access typeof n args n typeof n j angbracketleft a1 ... a n b1 ... b m self angbracketrightk n i 1typeof ai m i 1access typeof bi t j angbracketleft a1 ... a n b1 ... b m self?
angbracketrightk n i 1typeof ai m i 1access typeof bi publish t j angbracketleft a1 ... a n b1 ... b m angbracketrightk n i 1typeof ai m i 1access typeof bi j angbracketleft self b1 ... b m e angbracketrightk args o m i 1access typeof bi tife selfore j angbracketleft self b1 ... b m self?
angbracketrightk args o m i 1access typeof bi publish t t jc1 bardbl... bardblcnk jc1k ... jcnk table denotation of an interaction contract.
where args n returns the types of the parameters needed for a pull request on n. for example access typeof ip2host ipaddress string access typeof host2profile string profile finally given a type t we denote by publish t the type t which is the type of a function that publishes data of typet.
inthewebserverexample thedenotationoftheinteraction contract angbracketleft accesslogparser ip2profile self angbracketrightassociated to accessingprofile is the function type access ipaddress profile profile.
.
design support the architectural pattern presented here is to be used as a paradigm guiding the architect in the decomposition of an scc application into layers of components.
the interaction contracts enable an architect to describe the allowed interactions among components.
interaction contracts are limited to the kinds of interactions possible within the scc architectural pattern further guiding the architect.
.
programming support we have integrated interaction contracts into diaspec our domain specific adl for scc applications .
from a diaspec description a compiler produces a dedicated java programming framework that is both prescriptive andrestrictive it is prescriptive in the sense that it guides the developer and it is restrictive in the sense that it limits the developer to what the architecture allows.
in this section we describe the compilation strategies that achieve this.
.
structure of the generated code our compiler takes as input an architecture description written in the diaspec adl.
this specification describes textually an instance of the scc architectural pattern and the associated interaction contracts.
from this architecture description the compiler generates a dedicated programming framework containing support for sensors context operators control operators and actuators.
we focus on the code generated for interaction contracts as the other parts of the framework have been described previously .
for each context operator declared in the architecture description the compiler generates an abstract class.
the abstract methods in this class represent code to be provided by the developer to allow him to program the application logic e.g.
to answer a pull request .
to implement the context operator the developer implements these methods in a subclass of this abstract class.
for each basic interaction contract the generated abstract class contains an abstract method and a corresponding calling method.
the abstract method is to be implemented by the developer while the calling method is used by the frameworkto call the implementation of the abstract method with the expected arguments.
the translation of each interaction contract of the architecture into an abstract method is similar to the denotation found in table .
callbacks are used to encapsulate an optional interaction between the context operator and its parents or one of its children.
the developer may decide to invoke each callback depending on his needs.
a callback is only provided when an interaction is optional.
if the interaction is mandatory it is automatically done by the calling method.
if the interaction is forbidden the calling method does not provide the developer with any means to perform the interaction.
.
interaction contract compilation to illustrate the compilation process we consider the java code generated for some of the interaction contracts of the web server monitoring architecture see table .
the accessingprofile interaction contract is compiled into the following abstract method abstract identifiedaccess onnewaccesslogparser access newaccess pullfromip2profilecallback ip2profile the name of this abstract method starts with onnew reflecting the fact that the child is providing a new value.
the method s first parameter represents the new parsed line and the second parameter represents a callback function that permits a pull interaction with ip2profile .
this callback takes an ipaddress as argument and returns a correspondingprofile.
the return type of the onnewaccesslogparser abstract method forces the implementation of the abstract method to return a profile which is pushed automatically by the calling method upon method return.
ip2profile is a kind of database that can only be accessed through pull requests with an ipaddress as an argument.
from its interaction contract the following abstract method is generated abstract profile get ipaddress newipaddress pullfromnslookupcallback ip2host pullfromldapservercallback host2profile the name of this abstract method is get reflecting the fact thattheparentrequestedavalue.
theimplementationofthis abstract method may call two sources through corresponding callbacks.
because the emission is ip2profile returns a result only to its requesting parent i.e.
ip2profile does not push its value and has no way to do so.
from the interaction contract of intrusiondetector the following abstract method is generated abstract void onnewaccessingprofile identifiedaccess newidentifiedaccess publishcallback publish not all identified accesses arriving at intrusiondetector are necessarily intrusions.
the publish callback allows theapplication logic in the method implementation to decide whether to give an alert about an intrusion.
synchronization.
from the interaction contract of infocalc angbracketleft webbrowsercalc localizationcalc self angbracketright the following abstract method is generated abstract info onnewwebbrowsercalcandlocalizationcalc webbrowser newwebbrowser localization newlocalization thismethodistobecalledwithbothvaluesfromthechildren as soon as they are both present.
various strategies can be used to implement this kind of synchronization one approach is to remember only the most recent value from each source while another is to enqueue all values.
our default implementation uses a queue for each source.
when each queue has at least one value the framework consumes one value from each queue and invokes the abstract method on the resulting tuple of values.
this implementation may be changed by the developer.
disjunction.
from the interaction contract of dangerdetection angbracketleft sqlinjdetector intrusiondetector self angbracketright the following abstract method is generated abstract identifiedaccess onnewdisjunction identifiedaccess newidentifiedaccess this method has just one parameter to represent the disjunction.
the generated framework calls this method each time data is sent from either sqlinjdetector orintrusiondetector .
callbacks.
as noted above we use callbacks to implement optional interactions with parents and children.
each callback is implemented as an internal java class in the abstract class of the context operator and contains a single method.
for example pullfromip2profilecallback is defined as public abstract class abstractaccessingprofile ... protected class pullfromip2profilecallback ... public profile get ipaddress ipaddress pull the value from the instance of ip2profile through a call to the underlying middleware return ... callbacks are instantiated by the calling method which passes them to the abstract method.
to ensure that the declared interaction contracts are respected we have to ensure that a callback is not invoked after executing the code implementing the abstract method.
i.e.
the developer must not store the callback for later use.
currently this property is not enforced statically as it would require adapting a java compiler.
instead we provide a dynamic guard to prevent this situation at runtime.
this dynamic guard is implemented as a private boolean variable in the internal class whose value is checked before executing the callback.
the dynamic guard could also be extended to prevent the developer from calling a callback more than a given number of times e.g.
to limit resource usage.
.
programming support the generated programming framework guides the developer with respect to the architecture description.
implementing a declared component is done by subclassing thecorresponding generated abstract class.
in so the developer is forced to implement each abstract method.
to facilitate this process most ides such as eclipse for objectoriented languages generate class templates based on abstract super classes.
the generated framework passes each required piece of information as an argument to the method.
these arguments free the developer from having to guess method or class names.
the following code presents a partial implementation as could be written by the developer of the accesslogparser context operator.
public class lighttpdaccesslogparser extends abstractaccesslogparser override public access onnewline string newline access access new access access.setline newline access.sethost ip parseremotehostip newline ... parsing of the other fields return access private ipaddress parseremotehostip string newline pattern pattern pattern.compile matcher m pattern.matcher newline m.find return new ipaddress m.group the method onnewline is automatically called by the programming framework when a new line arrives from an instanceof accesslogreader .
thismethodistypicalofwhat has to be implemented by the developer.
because most of the interaction details are abstracted away by the generated framework the developer can concentrate on the application logic.
for example the decision of whether or not to publish anaccessvalue and which components are interested in this value is abstracted away from the implementation on line the developer simply returns the new value without having to know what will happen to it.
.
ensuring conformance animplementationmustconformtoitsarchitecture.
there arethreebasicconformancecriteria decomposition interface conformance and communication integrity .
decomposition.
for each component in the architecture there should be a corresponding component in the implementation.
this property is satisfied in the sense that at least an abstract class is generated for each component nevertheless the framework is not able to force the developer to implement the full set of abstract classes.
interface conformance.
each component in the implementation must conform to its architectural interface.
our compiler generates an abstract class that conforms by construction to the component description.
by extending the abstract class the component implementation automatically also conforms to this description.
communication integrity.
eachcomponentintheimplementation may only communicate directly with the components to which it is connected in the architecture.
this property is satisfied because an interaction only happens during the execution of an onneworgetmethod and only through the provided callbacks.
a component never gains a direct reference to another component and thus it can never give such a reference to another component.
.
support for evolution maintenance and evolution are important parts of the development of any software system.
our code generation strategy limits the number of code changes required when the architecture description changes.
when this happens the framework can be regenerated without overwriting the developer s implementation.
any mismatches between the existing code and the new programming framework are revealed by the java compiler.
this strategy contrasts with strategies based on generating source code skeletons to be filled by the developer which mix manually written and generated code.
in many of these strategies regenerating a skeleton overwrites the developer s implementation.
.
verification support in scc applications safety is a key requirement as unexpected behaviors can directly impact the environment and users through actuators.
interaction contracts make explicit valuable information about the data flow in the design and allow design time safety verifications.
for example with interaction contracts it is possible to know at design time all the context operators that will eventually be activated by the publication of a given source.
moreover our generative approach ensures that these properties will be preserved at the implementation level.
to illustrate the possible design time analyses we consider two kinds of properties data reachability can a component unexpectedly access critical data from a sensor or a context operator?
for example personal information about a customer should not be displayed on a screen in a public building.
interaction invariants does data sensed from a given sensor always lead to a particular action?
for example sensing a fire should always cause an alarm to go off.
.
data reachability in graph theory a vertex yis said to be reachable from a vertex xwhen there is a path from xtoy.
in our case data reachability properties are of type a must not access b or a may access b. checking such properties is required to ensure that for example private information cannot be compromised or to identify the potential impact of a sensor failure e.g.
a power outage on the rest of the application.
we define data reachability from a component in the scc architectural pattern by using the interaction contracts.
definition data reachability .
given a componentcand namenof a sensor source or a context operator the data associated with nis reachable from cif one of the following conditions is satisfied c nor cis a context operator and its interaction contract angbracketlefta u e angbracketrightis such that nis reachable from at least one of the names contained in names a names u or cis an actuator or a control operator and nis reachable from one of its children.
consider an extension of the web server monitoring example where a dedicated public web page displays the top five most visited urls.
this top five is calculated from the data provided by the accesslogparser .
by applying definition we check that the user profiles calculated by accessingprofile are not reachable from the actuator thatupdates the web page and thus these profiles cannot be published in this public web page.
when there does exist an undesirable reachability path the information in this path can guide the architect in fixing the interaction contracts.
.
interaction invariants interaction invariants are properties that are verified at any state of the scc application.
for example we would like to ensure that the profilelogger is always activated whenever someone accesses the web server.
we characterise the progress of an scc application by its data flow and we use ltl linear temporal logic formulae to characterise interaction invariants.
for example the property on the web server can be specified by the following ltl formula newline 3profilelogger activated where the predicate newline is true if a new value for the linesource of accesslogreader is pushed and the predicateprofilelogger activated is true if profilelogger is activated by a new profile.
this property can be understood as at any moment if a new line is pushed then the profilelogger willeventually be activated.
to check the ltl invariants we use the spin model checker associated with the promela modelling language .
if an invariant is not satisfied spin gives a counterexample in the form of an execution trace.
this counterexample can guide the architect in fixing his interaction contracts.
to check the above invariant we translate each interaction contract of the web server monitoring example into a promela process.
for example the interaction contract angbracketleft accesslogparser ip2profile self angbracketrightassociated to theaccessingprofile context operator is mapped into the following promela process specification active proctype accessingprofile byte newlog profile do accesslogparser?newlog ip2profile get!
ip2profile return?profile accessingprofile!
od each interaction contract is mapped into a process and each component interaction is mapped into a channel.
also each activation condition is mapped into a conditional expression line which is true if there is a new value in the channel.
each data requirement is mapped into a sequence of two instructions one for the transmission of the request line and one to receive the corresponding response line .
finally the emission is translated into a message send line .
the do odstatement is a loop construct that encodes the reactivity of context operators.1the promela specification is automatically generated from the interaction contracts.
currently we are working on the translation of counterexamples given by spin into high level explanations.
.
verification support data reachability and interaction invariants are two examples that show how the architecture specification makes core 1the full promela specification can be found at explicit and thus facilitates high level safety analyses on the data flow.
these design time analyses support the architect by giving counterexamples.
the same properties do not have to be checked again on the implementation because the implementation is guaranteed to conform to the design.
.
ev aluation this section gives an overview of the tool suite into which we have integrated interaction contracts and discusses the measured benefits of this integration.
.
a working tool suite previously we have developed a domain specific language dsl diaspec to express architecture descriptions that follow the scc architectural pattern .
this dsl is supported by a tool suite diasuite providing code generation and related functionalities.
the code generator translates a diaspec description into a java programming framework.
applications developed using this generated programming framework can be deployed using any of the communication protocols supported by the available back ends which currently comprise x10 upnp rmi and sip.
diasuitecompatible drivers have been implemented for hardware such as the ipod touch various types of rfid tags and the axis networked camera.
applications can furthermore be tested priortodeploymentusinga2dsimulator requiringnochange in the operator implementations.
diasuite has been used to develop applications in areas including home building automation tier system monitoring and avionics.
our experiences in using diasuite have motivated the development of interaction contracts.
integration of interaction contracts into diasuite requires extending the diaspec language and correspondingly extending the code generator to take into account the new constructs.
the resulting generated code follows the denotational semantics presented in section .
and the class structure presented in section .
.
benefits of interaction contracts to assess the interaction contracts we have conducted studies with groups of undergraduate computer science students each.
the students had no prior experience with our tool suite or scc.
we gave each group the original version of diasuite that did not include the interaction contracts.
we also gave all groups the same diagram similar to that of figure they had to translate it into diaspec and then implement the project.
all groups designed a working architecture and most completed the assignment with an implementation.
the experiment revealed some shortcomings in diaspec.
the rest of this section presents these shortcomings and how interaction contracts resolve them.
design support.
in the original version of diaspec the architect declared connections between components without specifying the permitted interactions as was illustrated with the solid arrows in figure .
in particular the architect did not specify whether a component is to be accessed through a push or a pull mechanism.
this imprecision lead to different interpretations of the same architecture and thus different implementations some outside of the original expectations of the architect.
with the introduction of interaction contracts the architect precisely expresses the allowed interactions.
support.
we intentionally did not give students any documentation about the generated framework to be able to determine to what extent this framework was in itself able to guide the implementation.
the students thus had to search in the generated code for the methods of interest to perform component interactions.
using the original version of diaspec there are twice as many of these methods as necessary because the code generator is unable to determine the intent of the architect and thus must generate code for both a push and a pull interaction between every pair of connected components.
our interaction contract compiler generates abstract methods that are self contained implementing them only requires using the arguments and returning a result.
furthermore the only abstract methods generated are those that support the interactions intended by the architect.
verification support.
without the interaction contracts the verification support is limited.
we first consider reachability properties.
data reachability is entirely determined by the parent child relationship in the data flow graph and thus the set of data reachable from a given component is not affected by the addition of the interaction contracts.
nevertheless the introduction of interaction contracts allows giving more precise counterexamples in the case of reachability property violations as the counterexample can include the precise sequence of activation conditions.
on the other hand most interaction invariants such as the one shown in section cannot be ensured without the interaction contracts as there is no guarantee that a component publishes a value.
.
measuring programming support to measure the impact of interaction contracts on the degree of programming support provided we use several metrics on a representative set of applications such as the web server monitor an anti intrusion system and a home remote control application.
these applications are implemented with and without interaction contracts.
to perform these measurements we use sonar 3a platform that uses various metrics to guide developers in improving source code quality.
as there is little variation in the measurements for the different applications we present only averages.
program size.
for each application we have compared both handwritten and automatically generated number of lines of code with the number of lines in the architecture description the implementation and the framework.
table presents these results.
the ratio of code for the architecture description column arch.
increases slightly because the architect must now write the interaction contracts.
the ratio of code for the implementation column implem.
decreases in part because methods corresponding to useless interactions do not have to be implemented and in part because some functionalities such as the handling of synchronization section .
are moved from the implementation to the generated code requiring less programming effort from the application developer.
finally the ratio of generated code column framew.
increases slightly reflecting the code that has been moved from the implementation to the generated programming framework.
execution coverage.
because the generated code can be arbitrarily large without impacting development time the measures in table are relevant only if the generated code is actually executed and thus has to be produced in some implem.
framew.
without interaction cont.
with interaction cont.
table the development effort for architecture descriptions without and with interaction contracts.
the figures indicate the distribution in percentage of the number of lines of code.
manner.
to assess this we measured the execution coverage of the programming framework code.
on average of the generated framework is actually executed.
we studied the parts that are not executed and found that all of them are either error handling code or features that may not be relevant to a given application such as entity discovery.
code quality.
we also used sonar to measure the code quality according to various criteria including code duplication rule compliance and code complexity.
the results given by sonar indicate an overall good quality of the code written by the developer.
for example the average code complexity of applications implemented with the interaction contracts is .
on a scale of to infinity indicating well structured code.
these code quality results associated with the small percentage of code that has to be manually written show that our generated programming framework guides the developer in producing well structured and easy to maintain code.
.
related work our work is related to software architectures formalisms for interaction specifications and model driven development.
.
software architectures to help in structuring scc applications dedicated architectural patterns have been proposed.
chen and klotz proposetodecomposeanapplicationintoinformationsources and context operators .
their pattern focuses on information processing and control but does not model the relation with the environment i.e.
how the environment is sensed and modified nor does it support implementation.
architecture description languages model systems to ensure various properties at compile time and at runtime.
most adls are dedicated to analysing architectures and provide little or no implementation support.
some adls like darwin and unicon generate runtime support but for components that have been developed separately with a generic programming framework.
these approaches provide generic abstract classes like component and connector that the developer must implement.
as a result component implementation cannot benefit from any support generated from the architecture description .
in general architecture based approaches that support implementation check conformance of the implementation to an architectural pattern e.g.
constraining the interactions between various variants of components and connectors but not conformance to a specific architecture description that is an instance of that pattern.
notable exceptions include acoel and archjava they connect adls and programming languages by proposing new syntactic constructs.
these constructs allow architectural concerns to be expressed inside the application.
our work goes beyond these approaches by separating architecture from implementation and generating a programming framework to bridge the two.to date archface is the work that is the most similar to ours.
archface leverages concepts from aspect oriented programming aop to describe component interactions.
by using implementation level mechanisms such as pointcuts architects can describe component interactions more accurately at the cost of anticipating the structure of the implementations.
as such the separation between architecture description and implementation becomes blurred making the architectural design phase more difficult.
as a general purpose design language archface can be used to describe any component oriented architecture which limits the support it can provide in a particular domain.
.
interaction specifications automata based models such as io automata and interface automata are commonly used for modelling interactions and actions within distributed and concurrent systems.
these approaches have been used to describe component interactions in adls .
interaction contracts are simpler in that they do not describe the full interaction sequence but only capture interaction constraints.
our objective is to specify only what can be enforced by the generated framework.
it is virtually impossible to completely enforce automata behaviors via the generated framework as we cannot guess how the developer will distribute the application logic within the sequences of messages.
we could choose to enforce it partially but in this case properties verified at the automaton level would not necessarily hold in the implementation.
moreover automata based models are a general solution and do not capture the specific properties of scc applications.
for example context operators are reactive and this characteristic must be checked on automata whereas it is syntactically ensured by interaction contracts.
.
model driven development model driven development uses models and model transformations as a way to specify software architectures and implementations.
the goal of these approaches is to raise the level of abstraction in program specifications through graphical notations and to generate a working implementation from such a specification.
uml .
unified modeling language has been widely accepted as an architecture modeling notation and as a second generation adl .
some approaches such as pervml relies on uml diagrams and ocl expressions to model domain specific concerns.
from such diagrams a dedicated suite of tools is able to generate a complete implementation of the described system.
by using uml diagrams these approaches leverage existing knowledge from developers and also existing tools such as the eclipse graphical modelling framework gmf .
even though such approaches propose a conceptual framework for developing applications they only provide the user with generic tools.
the pervml approach as well as other mdebased approaches require developers to directly manipulate ocl and uml diagrams which become enormous ambiguous and unwieldy .
in contrast diaspec abstracts away such technologies limiting the amount of expertise required from the developers.
thecalmframeworkusesmodelsastypesforcomponentoriented systems .
calm provides three modelling tiers where each tier constrains and guides activities in the tier below the upper tier allows the definition of domain specific adls the middle tier allows the definition of the systemcomponents and the lower tier allows the instantiation and combination of these components.
diaspec and its notion of interaction contracts could potentially be described in calm s upper tier leveraging calm s type checking capabilities.
however calm neither verifies that an implementation conforms to its architecture description nor does calm proposes an architect to verify safety properties.
.
conclusion in this paper we have introduced a notion of interaction contracts dedicated to describing scc applications.
we have shown how interaction contracts guide the architect in describing allowed context operator interactions.
we have also described how interaction contracts can be mapped into a generated programming framework and how this mapping guides the implementation of scc applications.
a key benefit of our approach is that the strategy for generating the dedicated programming framework guarantees conformance betweenthearchitectureanditsimplementation.
ourgenerative approach allows unlimited regeneration of the framework without overwriting the developer s code.
finally we have shown how interaction contracts guide analyses at the architecture level and how the properties checked by these analyses still hold at the implementation level.
we are currently expanding this work in several directions.
we want to further guide development by automatically generating a dedicated unit testing framework.
work is also in progress to add and compose non functional layers e.g.
fault tolerance safety and security on top of the scc architectural pattern and have automatically generated support .
finally we are investigating the applicability of interaction contracts to other scc component types and to other architectural patterns.
.