powering the static driver verifier using corral akash lal microsoft research india akashl microsoft.comshaz qadeer microsoft research usa qadeer microsoft.com abstract the application of software veri cation technology towards building realistic bug nding tools requires working through several precision scalability tradeo s. for instance a critical aspect while dealing with c programs is to formally de ne the treatment of pointers and the heap.
a machine level modeling is often intractable whereas one that leverages highlevel information such as types can be inaccurate.
another tradeo is modeling integer arithmetic.
ideally all arithmetic should be performed over bitvector representations whereas the current practice in most tools is to use mathematical integers for scalability.
a third tradeo in the context of bounded program exploration is to choose a bound that ensures high coverage without overwhelming the analysis.
this paper works through these three tradeo s when we applied corral an smt based veri er inside microsoft s static driver veri er sdv .
our decisions were guided by experimentation on a large set of drivers the total veri cation time exceeded well over a month.
we justify that each of our decisions were crucial in getting value out of corral and led to corral being accepted as the engine that powers sdv in the windows .
release replacing the slam engine that had been used inside sdv for the past decade.
categories and subject descriptors d. .
software program veri cation d. .
testing and debugging general terms reliability testing veri cation keywords software veri cation smt device drivers bitvector reasoning language semantics loop coverage permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction work on software veri cation usually focusses on the techniques and algorithms behind the veri ers and their evaluation in a controlled environment.
however when the veri er is applied in practice it is exposed to several sources of complexity and imprecision at which point it is important to consider the end to end veri cation system instead of just the exploration algorithms.
we experienced the challenges of a production environment when we applied the corral veri er inside the static driver veri er sdv .
sdv is a commercial o ering by microsoft that ships with the windows driver development kit.
its purpose is to help driver developers nd defects earlier in the development cycle and improve the reliability of windows device drivers.
internally sdv has used slam for statically exploring behaviors of programs.
the sdv slam system is one of the major success stories of veri cation technology .
corral accepts programs in an intermediate veri cation language called boogie .
in addition to the usual answers of veri ed or bug found corral can also give up when it hits a user supplied bound on the number of loop iterations and procedural recursion to be explored.
the original corral publication showed promise in out performing slam.
however when we applied sdv corral combination in a production environment the number of false defects and missed defects were both at an unacceptable level.
one challenge was de ning a memory model for c i.e.
a formal treatment of pointers and the heap in c programs.
a bit precise memory model of c is often intractable.
the common trend in many veri cation tools such as slam smack cbmc is to use a pointer analysis for disambiguating pointer dereferences to di erent memory locations.
this has the disadvantage that the semantics of the pointer analysis get imposed on the subsequent veri cation.
for instance most pointer analyses assume that environment pointers pointers allocated outside the scope of the program under test never alias.
this was not a reasonable assumption in our setting.
in fact we were able to nd many more defects than sdv slam simply by relaxing this assumption.
one option is to design the memory model based on a pointer analysis that will agree with the veri cation semantics.
however we do not attempt to go that route.
instead we present a simple pointer disambiguation based on syntactic rules leaving the semantic heavy lifting to the veri er.
our memory model does not force environment pointers to be distinct.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
202figure work ow of the sdv q system.
this paper s contributions are about the three colored boxes.
the second challenge was modeling of the inttype in c. on a bit machine which is assumed to be the case throughout this paper for simplicity an intis really a bit value.
arithmetic operations such as addition and subtraction are really bitvector operations implemented by circuits inside the hardware.
while bitvector level reasoning is possible most smt solvers support a bitvector theory it is often more expensive than reasoning over mathematical integers.
consistently using bitvector operations in our setting turned out to be too expensive.
instead we present a novel type constraint based analysis that focuses the precision of bitvector reasoning to only where it is needed whereas the rest of the program computes over mathematical integers.
our experiments validate that we were as precise as full bitvector reasoning while being almost as e cient as full integer reasoning.
the third challenge was to ensure coverage and avoid missing defects when present.
when corral is unable to nd a proof or defect even after fully exploring a bounded set of behaviors it terminates search with the verdict no bugs found .
corral accepts a user de ned bound on the number of loop iterations as is common in many bounded veri ers.
typically this bound is chosen upfront.
for instance in the software veri cation competition svcomp many bounded exploration tools chose a xed bound of perhaps because it was su cient to cross all loops in the svcomp benchmarks and this bound is applied to all loops in the program.
however most programs in our test suite had long running loops.
choosing a bound large enough to cross such loops and applying it to all loops in the program turned out to be too expensive.
we instead apply a di erent bound to each loop based on a lightweight analysis of the program.
interestingly in our experiments we found that slam even though it does not do bounded exploration would time out when the defect required crossing a long running loop indicating that our technique is more widely applicable than for bounded reachability veri ers.
the integration of corral with the improvements described in this paper is called q. we show that q retained much of the speedup that corral provided in a previous experiment but now it also nds more defects and reports fewer false defects than slam.
our evaluation convinced the sdv product team to adopt q in place of slam.
the contributions of this paper can be summarized as follows .we present a new memory model for c by de ning a translation to boogie section .
.we present a novel type constraint based analysis that selectively decides where bitvector reasoning is important section .
.we give heuristics that improve coverage across longrunning loops section .
.we carried out extensive experiments to validate that all of our techniques were necessary for q to outperform slam section .
our test suite consists of over veri cation checks on real drivers that cumulatively take more than hours to execute sequentially.
.
overview of q the operation of sdv integrated with q is shown in fig.
.
sdv comes packaged with a formal description of a driver s environment and properties in the form of harnesses os models and rules .
the harness is like a main method that describes how a driver can be invoked.
the os models are stubs for each external call that the driver can make to the kernel and the rules are properties that the drivers must satisfy .
sdv takes the source code of a driver as input and compiles it using a compiler called slamcl to produce a single le instance.li where the driver is closed using the harness and stubs and the rule is instrumented as assertions in the program.
the format of this le called li is a simpli ed c syntax.
in this paper we do not distinguish between liand c. this instance le is called a veri cation instance.
each rule results in a di erent veri cation instance thus a driver produces as many veri cation instances as the number of rules.
the responsibility of the engine is to nd an execution of instance.li that ends in an assertion violation.
q works by rst compiling c to boogie extension bpl .
the utility li2bpl is responsible for encoding the program s c semantics in the more logical language boogie.
the output of li2bpl is fed to another utility called bvencoder that performs a boogie to boogie transformation and decides where to introduce bitvector precision.
the resulting boogie le is fed to corral to nd assertion violations.
in addition to the boogie le corral also accepts loop bounds as input.
this is supplied as a map rfrom loops to positive integers.
corral then covers at least all executions in which a loop lexecutes forr l number of iterations.
corral additionally accepts a bound on the number of recursive calls not shown in the gure .
however recursion is not common in drivers and we ignore discussing about it in this paper.
the initial version of sdv corral used havoc forli2bpl did not support bitvector operations i.e.
overapproximated them as uninterpreted functions and used a consistent small loop bound for all loops.
while the raw performance of this tool compared favorably to sdv slam 203its accuracy in terms of false negatives missed defects and false positives false defects was far from satisfactory.
a more detailed discussion can be found in section .
the rest of the paper is organized as follows.
in section we improve on havoc s memory model in li2bpl by adding support for common programming idioms found in low level systems code.
in section we describe the design ofbvencoder .
in section we show how to compute relevant loop bounds.
in section we empirically show why each of these techniques were necessary for q to outperform slam.
section discusses related work and section concludes.
.
translating c to boogie fig.
shows a simpli ed c syntax for expressions and commands.
we introduce a bool type in c for convenience and assume that a pre processing step rewrites expressions involved in a boolean decision say if e toif e!
.
further we do not allow stack allocated structures.
instead they must be allocated on the heap.
constants are represented as bit bitvectors bv32 .
pointer dereferencing address of operator and eld indexing is standard.
expressions can be composed of operators.
we allow the usual boolean and arithmetic operators as well as bitwise and bitwise or and bitwise negation .
we use to represent other non linear operators in c such as multiplication division bit shifting etc.
commands can include assignments as well asassume andassert statements.
we leave out the treatment of control ow and other commands such as procedure calls their translation is straightforward.
other types like float andunion are either modeled using existing types or left uninterpreted.
array indexing is modeled using pointer arithmetic.
we deliberately do not discuss issues of dealing with the entire c syntax due to space constraints.
boogie is an imperative language with the usual controlow constructs of c however it does not have a notion of a heap or pointers.
the semantics of boogie is based in logic.
the operational semantics of the subset of boogie that we consider here can be encoded in smt.
the base constructs of boogie come from standard smt theories such as linear arithmetic bit vector operations uninterpreted functions and the theory of arrays.
a boogie program can only have a nite number of global variables as well as a nite number of local variables per procedure.
its expression and command syntax is shown in fig.
.
it has three basic types bool is the usual boolean type intrepresents mathematical integers and bv32 represents bit c integers.
boogie also supports map types.
for instance a variable of type intrepresents an unbounded map from inttoint.
such map type variables are crucial for encoding the unbounded heap of c programs.
for a map m select m e indexes the map at locatione and update m e e2 is a map that is identical to mexcept that its value at location e1ise2.
we sometimes shorthand select m e asm and the assignment m update m e e2 asm e2.
for each c operator op other than the boolean operators !
and equality we assume the existence of two operators bvopand intopin boogie where the in and out parameters of bvophave type bv32 and the in and out parameters of intophave type int.
for the purpose of analysis only some of these boogie operators can be interpreted precisely by the underlying smt solver in our case z3 .
others are treated as uninterpreted functions.
for instance types booljintjvoid j j struct sf 1f1 nfng variables x2 var declarations d x constants c2 f true falseg bv32 l expressions l xj ejl f expressions e cjxj ljlj op2 e1 e2 jop1 e j e operators op2 j j j j j j j j op1 !j commands cmd l ejassumeejasserte figure c expression and command language types base booljintjbv32 basej base variables x2 var declarations d x constants c2 f true falseg z bv32 expressions e cjxjop2 e1 e2 jop1 e j select x e jupdate x e1 e2 operators op2 j j jbvop2jintop2 op1 jbvop1jintop1 commands cmd x ejassumeejasserte figure boogie expression and command language for an arithmetic operator op2f g both intopandbvop are interpreted by the theory of linear arithmetic and the theory of bit vectors respectively.
both int and bv are uninterpreted.
for bitwise operations op2f g bvop is interpreted but intopis uninterpreted.
for simplicity we sometimes use opin place of bvoporintopwhenever the type of the operator is clear from the context.
the translation of c expressions to boogie is shown in fig.
using three mutually recursive routines d for declarations e for expressions and l forl values .
the function typeof returns the static type of an expression.
the function o set t f returns the o set of eld fin the structure typet.
the function addrtaken takes a c variable as input and returns false if the address of the variable was never taken.
the translation is parameterized using the functions hm heap map om operator map and tm type map that we describe next.
the translation of c commands to boogie commands is straightforward the command l e is translated to e l e e assumeeis translated to assumee e and asserteis translated to asserte e .
fig.
shows various options of de ning hm omand tm.
picking functions subscripted with intleads to an int only encoding whereas picking functions subscripted with bvleads to a more precise encoding where c integers are kept as bit bitvectors and computation is done via bitvector operations.
in this section we only focus on the int encoding bitvector modeling is discussed in section .
the function hmis responsible for encoding memory accesses.
using functions omint tmintand hmuni ed int lead to havoc s uni ed memory model umm .
the entire heap is represented using one map mem int.
we assume that maps subscripted with inthave type int and maps subscripted with bvhave type bv32 .
the subscripts are dropped when they are clear from the context.
204d x x tm e c c e l l l e x hm typeof x addrtaken x x o w e e hm typeof e e l f hm typeof l f l l om o set typeof l f e op1 e om op1 e e e op2 e1 e2 om op2 e e1 e e2 e e e e l x x l e e e l l f l l om o set typeof l f figure translation of c to boogie parameterized using the underlined functions hm omand tm tmint bool bool tmint int omint omint omint !
omint omint op intop hmuni ed int mem int hmuni ed int mem int hmsplit int t mem tint hmsplit int t f mem ftinttmbv bool bool tmbv bv32 ombv ombv ombv !
ombv ombv op bvop hmuni ed bv mem bv hmuni ed bv mem bv hmsplit bv t mem tbv hmsplit bv t f mem ftbv figure di erent translations to boogie an alternative is the split memory model smm de ned by selecting hmsplit intinstead of hmunified int .
this memory model uses a distinct map for each type and eld.
our standard way of modeling memory allocation is via the procedure malloc in boogie shown in fig.
.
it returns a strict monotonically increasing integer.
this ensures for instance that two allocated addresses are distinct.
an example of smm translation is shown in fig.
.
addrtaken x is false thus xis translated to a scalar variable in boogie.
addrtaken y holds thus yis translated to a boogie variable that actually represents its address.
we use the identi er name addr y in boogie to highlight this fact.
suppose s1is a structure type with eld fat o setof and s2is a di erent structure type with eld gat o setog.
then a write to x f translates to a write to mem.f s1 in boogie.
a read of y g translates to a read of mem.g s2 .
thus irrespective of the values ofx y of andog an assignment to x f cannot change the value of y g in the translated boogie program.
in other words an assignment via one eld cannot change the value read from another eld.
this splitting of the memory map statically enforces certain non aliasing in the program.
however it can also lead to imprecision because even well behaved c programs can violate this property.
our experiments section show that umm is not scalable whereas smm results in many false defects.
re ned memory model.
our re ned memory model rmm is derived from smm by selectively merging some of its maps into the same map.
in the worst case rmm 1while writing types inside identi ers we replace with p for example hmsplit l int ismem.pint lforl2fbv intg.1struct s int f 5void main 6int x y 7s z 8z malloc 9z f y y x 1var alloc int 2var mem.
f s int 3var mem.
int int 4procedure malloc size int returns ret int 6ret alloc 7alloc alloc size 8return ret 10procedure main 11var x addr y z int call addr y malloc call z malloc mem.
f s addr y mem.
int x figure memory allocation and the split memory model over int 1typedef struct int g int f s 5void main s x malloc sizeof s x f inc x f assert x f 12void inc int a a 1var mem.
f s int 2var mem.
int int 3procedure main var x int call x malloc mem.
f s inc x assert mem.
f s 11procedure inc a int mem.
int mem.
int figure the need for merging elds with types may end up merging all maps into the same map e ectively resulting in umm.
in this sense the rmm sits between smm and umm.
it tries to get the scalability of smm and the precision of umm.
we merge by de ning an equivalence over the map variables of smm.
let be a function that takes a map mas input and returns a unique representative in the equivalence class ofmunder .
we de ne hmre ned l t f hmsplit l t f andhmre ned l t hmsplit l t for alltandf andl2fbv intg.
the merging equivalence is decided by the following two rules.
rule taking the address of an expression .
fig.
shows a c program and its translation under smm.
the assertion in the c program holds but not in the boogie program.
the problem is that incupdates the map mem.int whereas main uses mem.f s .
to x this whenever the address of a eld is taken x f we merge the map for the eld with that for the type of the eld mem.f s mem.int .
passing elds by reference is very common in c programs including drivers.
for similar reasons whenever the address of a variable is taken via the assignment y x then we say mem typeof x mem typeof y .
rule structural subtyping .
fig.
shows a c program and its translation under the split memory model.
it illustrates a common idiom in c programs namely that of structural subtyping.
if one type s1is a pre x of another type s2 when they are laid out in memory then s2can be used as a subtype of s1.
for instance in fig.
the procedure inc is expecting a pointer to s1 but main is instead passing a pointer to s2.2051typedef struct int g s1 4typedef struct int g int f s2 7void main s2 x malloc sizeof s2 x g inc x assert x g 14void inc s1 a a g a g 1var mem.
g s1 int 2var mem.
f s2 int 3var mem.
g s2 int 5procedure main var x int call x malloc mem.
g s2 inc x assert mem.
g s2 14procedure inc a int mem.
g s1 mem.
g s1 figure the need for merging elds with other elds the assertion in the boogie program of fig.
can fail because main uses mem.g s2 whereas incuses mem.g s1 .
alg.
solves this problem by merging structures with their supertypes.
the procedure getfieldindex decorates a eld with its type and its o set in the containing structure.
we view a structure sas an unordered set of its elds decorated using getfieldindex .
for example structure s2of fig.
is the setfg int f int 4g.
then the structure ais structurally a subtype of bif and only if .
a na ve algorithm is to simply check for all structuresaandb.
ifnis the total number of structures andmis the maximum number of elds per structure then this algorithm is o n2m if the set operations are o m .
alg.
does slightly better.
it rst constructs a dictionary field2structset that maps a eld to all structures that have that eld then the loop on line nds all subtypes of a given structure.
once the subtypes are calculated we merge eldfof structure swith eldfof structure s whenever s is a subtype of s line .
if a eld appears in at most pstructures the complexity of alg.
is o nmp .
this is better than the na ve algorithm becausepis usually much smaller than n. structural subtyping is used commonly in drivers.
for instance drivers have an extension object for storing driverspeci c state.
this extension object is sometimes designed to mirror the driver stack.
an example from a parport driver is shown in fig.
.
the declarations of the types make the subtyping intent clear.
the common extension structure declaration is inlined into the declarations of the other structure using a c preprocessor trick.
we also veri ed that the code of the driver uses this subtyping methods that expect a pcommon extension are sometimes passed pfdo extension orppdo extension .
our algorithm infers such subtyping relationships.
we also note that in our experiments we inferred subtyping relationships that were perhaps never intended or used.
such extra relationships can only have a performance implication but rmm still retained much of the performance of smm.
.
bitvector operations the previous section re ned the memory model to better model the heap but it still used intas the basic type.algorithm detecting structural sub typing procedure getfieldindex f s return f typeof f s o set f s procedure structuralsubtyping struct2subtypes eld2structset for all structs2allstructs do for all field f in s do eld2structset .add s end for end for for all structs2allstructs do c allstructs for all field f in s do ifc then break c c eld2structset end for struct2subtypes c end for for all structs2allstructs do for all fields f in s do for all structss02struct2subtypes do mem.f s mem.f s end for end for end for 1typedef struct common extension ... common extension pcommon extension 5typedef struct fdo extension common extension ... fdo extension pfdo extension 10typedef struct pdo extension common extension ... pdo extension ppdo extension figure example of structural subtyping this can be imprecise because all bitwise operations are left uninterpreted.
one option is to convert every type to bv32 by selecting functions in fig.
with subscript bv.
as we show in section this option is not scalable.
bitvector reasoning in smt solvers tends to be much more expensive than integer reasoning.
our insight is that only some of the computation in a program requires bitvector precision.
most arithmetic including pointer arithmetic can be adequately handled using integer operations.
we manually inspected the code of some drivers and found that setting and removing of ags as bits of an integer to be an important idiom.
further these ags maintain important status information about the driver.
such ags are manipulated via bitwise and or and negation and are sometimes involved in arithmetic comparisons.
the procedure foo1 in fig.
shows an example of 2this idiom is common to almost all drivers.
see the description of the flags eld of a device object structure windows hardware ff543147 v vs. .aspx206p x e x tx e te tx te assign select x e t1 x t2!t3 e t4 t2 it1 t3 read e1 e2 bool ei ti t1 t2 equality intop ei t ei tiop2f g ti bt ti bvop update x e1 e2 t1!t2 x t3!t4 e1 t5 e2 t6 t1 t3 it2 t4t4 t6 write intop ei t op62f g t i intop figure generating type constraints for a boogie program.
x b varx int7!varx bv32 declscalar x i!b varx int7!varx bv32 declmap e t select x e !select x coerce e t read e1 t update x e1 e2 !update x coerce e1 t e2 write intop ei t ei tiop2f g 8i ti b intop ei !coerce bvop ei t bvopsuccess intop ei t ei tiop2f g 9i ti i intop ei !intop coerce ei ti bvopfail ei tiop62f g intop ei !intop coerce ei ti intop figure rewriting the boogie program 1void foo1 t x ... 3x flags f2 ... 5assert x flags f3 6assert x flags f4 9void foo2 r y g g ... y data f2 ... y data g 1var mem.
flags t bv32 2var mem.
data r int 4procedure foo1 x int ... mem.
flags t bv mem.
flags t f2 ... assert bv mem.
flags t f3 !
assert bv2int mem.
flags t f4 16procedure foo2 y int g g ... mem.
data r int mem.
data r f2 ... mem.
data r g figure converting types to bitvector manipulating ags.
each of the fiin the gure are constants powers of .
this section presents bvencoder a boogie to boogie transformation that takes an int only program and selectively lifts some types to bv32 when the precision is needed.
the result is a mixed intand bv32 typed program which may additionally use a function bv2int that converts a bitvector value to an integer value.
such an operation can be supported precisely we implement it by a power of expansionof the bitvector.
bvencoder does not rely on any conversion from integer to bitvector value.
bvencoder works on the following idea.
whenever it sees a bitwise operation say int e1 e2 it tries to change the type ofe1ande2tobv32 so that the operator can become bv .
however it does not perform the conversion if say e1 is the result of an arithmetic computation.
we now make the analysis more formal.
we introduce three new base types for the purpose of our analysis fn b ig.bvencoder which takes an int only program erases the intand then re types the program using these new types.
intuitively nstands for no preference b stands for preferably bv32 and istands for must be int .
these base types satisfy a subtyping relationship n b i. we say that t1 t2ift1 t2ort1 t2.
for map types t1!t2 t3!t4only ift3 t1andt2 t4.
we make use of a type coercion method bv2int frombtoi.
every variable and expression in the program is associated with a type variable that can take values from fn b ig or map types constructed from these base types.
we write e twhen the expression eis associated with type variablet.
type constraints are generated by applying the rules from fig.
on all commands and expressions in the boogie program.
the rule assign equates the types of right hand and left hand sides of an assignment.
the rule equality is similar.
read enforces that the domain types of maps must be i. this is because only pointers can ow in to domains of maps we wish to keep pointers in the integer domain.
note that read does not generate a constraint for t4.
even if the index expression eis typed as b we can still coerce it to iusing bv2int .
the rule write is similar toread .
the rule intop forces the result of arithmetic2071var a b c int 2var x y z w int 3var m int 5a int x y 6b int y z 7c int b w 8m update m x a ta tint x y tint x y tx tint x y ty tx b ty b tb tint y z tint y z i tc tint b w tint b w tb tint b w tw tb b tw b tm targ m!tres m targ m i tres m ta n tz b tx ty ta tw tres m i tb tc targ m1var b c z int 2var a x y w bv32 3var m bv32 5a bv x y 6b int bv2int y z 7c int b bv2int w 8m update m bv2int x a figure example showing a boogie program snippet left the type conversion constraints generated for it center top their optimal solution center bottom and the converted boogie program right .
operations to be i. this prevents the need for linear arithmetic over bitvector values.
the rule bvop enforces that the arguments of bitwise operators must be at least b. if the arguments get typed to be i because say they are the result of arithmetic operations then we cannot convert this operator to its bitvector counterpart.
fig.
presents a running example for bvencoder .
once the type constraints are generated we nd the least solution of the constraints.
solving such constraints is standard and very e cient.
note that a solution to the type constraints always exists because forcing all type variables to be iis always a valid solution.
once an assignment of the type variables is generated we re write the input boogie program back to use intand bv32 types using the rewrite rules shown in fig.
.
let coerce e t beeift6 band bv2int e otherwise.
thus the type of coerce e t is always int.
further for convenience we say coerce e1 e2 t1 t2 coerce e1 t1 coerce e2 t2 .
fig.
shows a c program and its translated boogie program after li2bpl and bvencoder .
the resulting boogie program captures precisely the setting and reading of ags infoo1 but over approximates in foo2.
our experiments section indicate that this strategy of lifting inttobv32 is precise enough for sdv and in fact improves the running time.
.
improving loop coverage consider the program shown in fig.
.
the main procedure has a failing assertion but constructing a path to the assert requires iterating through the loop 28times.
if corral is given a bound k 28for this loop it would not be able to nd this defect.
such loops occur commonly in drivers our experiments show that q would miss more than defects with a small loop iteration bound.
the loop shown in fig.
is a real example driver objects have a eld majorfunction that is an array of function pointers consisting of the dispatch routines that the driver supports for servicing di erent operations.3it is common for drivers to initialize such arrays by iterating through them.
on the other hand using a consistently large bound for all loops is not scalable.
our solution is to preferentially assign a larger bound to some loops while using a default small bound for other loops.
we use two techniques to improve coverage across loops.
letkbe the default iteration bound xed to 3in our experiments .
let nbe a xed constant chosen heuristically to be .
the two techniques are as follows.
hardware ff551985 v vs. .aspx1 define irp mj maximum function 2void main ... for i i irp mj maximum function i driverobject majorfunction rspassthrough ... assert false figure program with a loop 1procedure foo ... 3mem.
int 4while mem .int mem.
int mem.
int call bar ... 11procedure bar mem.f e1 mem.g e2 1var t int 2procedure foo 3t ... 5mem.
int 6while mem .int t mem.
int mem.
int havoc mem.f havoc mem.g assert t ... figure estimating minimum loop iterations .increasing bound per loop if a loop executes for at leastmiterations before exiting then we assign it an iteration bound of k min m n .
.abstracting long running loops if a loop requires at leastmiterations and m n then we abstract its n stiteration to simply havoc the variables i.e.
assign them non deterministic values in the loop body and exit the loop.
ideally we would have liked to keep n but in practice some loops require a very large number of iterations.
instead of unrolling these loops we chose to abstract them instead.
this adds the possibility of false defects because we are overapproximating the loops but we have not seen any such false defects in practice.
we estimate the value of musing corral itself.
let lbe a loop in procedure p. we abstract all procedure calls in p by replacing them with a summary of the called procedure.
the default summary is that the call can arbitrarily modify any variable that it can touch.
then we run corral on p with an iteration bound of n. we ask corral to nd a path from the beginning of pto an exit of l. if corral nds a path withriterations then we say m r. one example is shown in fig.
.
we estimate minimum iterations for the loop in procedure fooby converting it to208table various con gurations of the q veri cation engine.
engine description q re ned memory model bvencoder loop bound estimation and loop abstraction q rmm q but without rmm uses smm q la q but without loop abstraction q la lb q but without loop bound estimation and loop abstraction q bv q but without bvencoder uses int only encoding q base split memory model int only encoding no loop bound estimation no loop abstraction qwintumm q with uni ed memory model and int only encoding qwintsmm q with split memory model and int only encoding qwallbv q with bv only encoding qwallopsbv q where bvencoder is applied to all operators qwlb50 q without loop bound estimation but with loop iteration bound of for each loop the procedure foo shown on the right of the gure.
the call to baris abstracted away and an assertion is added at the end of the loop.
corral will nd a path to the assert in foo only after unrolling the loop 15times thus we will set the loop iteration bound for this loop to be .
abstracting procedure calls limits corral s analysis to a single procedure making it very e cient.
the time spent in estimating bounds for all loops was negligible mostly less than 5seconds compared to the time spent analyzing the original program.
we note that our analysis only provides an estimate of the minimum number of iterations required.
it would not be precise for instance if the number of iterations is bound to an input parameter of the procedure and it so happens that all call sites pass a xed constant for the parameter.
in this case the value of minferred would be lower than required and would lead to a loss of coverage.
it is possible to perform an interprocedural analysis to infer more precise value of m however we did not feel the need for a more complicated analysis in our experiments.
.
experiments we performed experiments to validate the usefulness of each of our techniques the re nement memory model section bvencoder section and loop bound estimation and loop abstraction section .
let q refer to the integration of corral with the various features described in this paper.
di erent con gurations of q are listed in table .
it is worth noting that the most important result of sdv is a valid defect trace.
finding more defects adds directly to the bottom line value provided by sdv.
also reporting a false defect i.e.
one that doesn t reveal a bug in the driver comes with a high cost because sdv is part of the driver certi cation process.
this is why we put emphasis on the number of missed and false defects in our evaluation.
test suites .
we conducted our experiments over two test suites.
the rst test suite consists of 4drivers on which properties were checked.
the properties mostly assert that the driver correctly invokes the kernel api .
the number of veri cation instances with non trivial running time is with of them classi ed as buggy .
we use this test suite for quick performance testing.
the second test suite is a set of 59drivers and 180properties put together by the sdv team as some of the hardest drivers that sdv comes across in the eld.
the number of instances with non trivial running time is with of them classi ed as buggy .
we refer to the rst test suitetable comparison of various memory models using int only encoding on subitp.
qwintumm qwintsmm q bv time s .
.
.
nurs as subitp and the second as ntp following internally used names .
the ntp suite is fairly exhaustive the running time of a single engine on this test suite excluding compilation is around days when run sequentially.
the experiments were run in parallel on 4identical servers.
each of the servers had intel xeon cpus .
ghz 64gb ram and 16logical processors and ran at most 16veri cation instances in parallel one per core .
memory models .
we rst compare the uni ed split and re ned memory models on subitp test suite.
the results are shown in table .
nur stands for not useful result which is either a timeout or a spaceout of the veri cation engine.
we consistently use a timeout of seconds and a spaceout of 2500mb.
also we report the running time only over instances where the engines reported identical results.
table clearly shows that the uni ed memory model has very poor performance whereas the re ned memory model is comparable to the split memory model in terms of the running time.
of course the issue with split memory model is the inaccuracy in modeling c semantics.
in the evaluation with ntp we also calculated the number of false and missed defects.
the results are shown in table compare the columns for q and q rmm.
it is clear that smm results in many more false defects.
figs.
and capture the reasons for these false defects.
moreover none of the 7false defects of q were because of inaccuracies in the re ned memory model.
we also note that on an average rmm produced fewer maps than smm with eld referencing and structual subtyping contributing almost equally to the merging.
the small percentage of map merging is one reason why the performance of rmm was still closer to smm than umm.
bit vector analysis .
table shows a comparison of various integer bitvector encodings under the re ned memory model.
we also created a version qwallopsbv that uses a variant of bvencoder that also tries to lift arithmetic to be over bitvector values but still forces pointer arithmetic and pointer dereferences to be over integers.
we use qwallopsbv to evaluate if the arithmetic really needs to be over integers or not.209table performance of various tools on ntp benchmarks.
speedups are relative to the running time of q. slam q q bv q rmm q la q la lb q base speedup over q .
.
.
.
.
.
false defects missed defects nurs table comparison with di erent loop bounds on subitp.
q bv q qwallopsbv qwallbv time s .
.
.
.
nurs table comparison of bitvector encodings using the re ned memory model on subitp.
q qwlb50 time s .
.
nurs from table it is clear that an all bv encoding is not scalable.
in fact we noticed that as soon as we allowed maps with bv32 type domain i.e.
maps of type bv32 or int the performance of corral and z3 decreased dramatically.
this is a topic for separate investigation.
note that bvencoder never produces maps of such types.
the performance of qwallopsbv is much better than qwallbv but still does not compare to the performance of q. surprisingly q was slightly faster than q bv even though q bv is purely integer based.
this is perhaps because the less precision of q bv forced it to carry out a larger exploration of program behaviors than q. the ntp suite reveals that q bv results in many false defects compare columns for q and q bv .
none of the 7false defects of q were because of less precise bitvector reasoning meaning that bvencoder was su cient for dealing with bitvector operations on the benchmarks.
the percentage of maps whose type was changed by bvencoder was3 on an average.
for qwallopsbv this number was .
loop coverage.
recall that the limit used for loop bound inference was after which loop abstraction if enabled would abstract the loop.
each of q la and q la lb are strict under approximations of q i.e.
they explore strictly less amount of the state space of a program than q. first table shows that consistently using a bound of 50is not scalable.
the ntp suite shows that q la lb has a large number of missed defects .
many of them except are found using loop bound inference.
a further 10were found using loop abstraction.
interestingly in all of these cases slam timed out indicating that the loop abstraction heuristic could have bene ted slam as well.
furthermore the performance of q is comparable within to the time taken by q la or q la lb.
corral vs. slam .
table shows that q was times faster than slam for veri cation instances on which slam and q returned the same and non nur answer slam took seconds and corral took seconds.
moreover q reported only half as many nurs had fewer false defects and reported 158more true defects.
thus q outperforms slam on all metrics.
the con guration q base is what was used for experimentation in an earlier corral paper .
while we retained much of the performance improvemento ered by corral q performs signi cantly better on other metrics.
from the 158new defects found by q 88of them were found because q s memory model unlike slam does not assume that environment pointers are distinct.
on the ip side the false defects of q were because the aliasing that it assumed in the environment was indeed unreasonable in that setting.
to illustrate a real example consider dispatchroutine1 of fig.
.
the intention is to check if the dispatch routine deletes the device object passed to it a shorthand fordeviceobject .
indeed it does the self eld is always expected to point back to the containing device object.
however not all elds including self of the device extension shorthand de are initialized by the sdv harness for various reasons outside the scope of this paper .
slam believes that because de self is uninitialized it cannot alias the device object.
as a result it misses this valid defect.
consider dispatchroutine2 in fig.
.
it checks that the irpsent to the dispatch routine is not completed twice.
the twoirps that are completed come from uninitialized elds of the device extension object.
it is not immediately obvious if this is a true defect or not.
experts in the sdv team ag this as a false defect because it is expected that the flushirp andblockirp are always distinct irps.
we have shortened the identi er names from their actual names in the drivers .
slam does not report this false defect because of its distinctness assumption but q reports this defect.
the assertion violation in both dispatchroutine1 and dispatchroutine2 requires aliasing among environment uninitialized pointers.
however the fact that one is a true defect while the other is false purely depends on domain knowledge.
our experiments reveal that we nd new defects and report only extra false defects.
this was an interesting side e ect of the change from slam to q we did not have prior knowledge that slam s environment non aliasing was actually too strong in many cases.
in65of the new defects found by corral slam timed out before returning an answer.
the rest seem to be because of loss of coverage or bugs in slam we did not investigate this further.
comparison with yogi .
yogi is another veri cation engine compatible with sdv.
q outperformed yogi on all metrics as well but we avoid going into details due to space constraints.
we also note that the version of q that shipped with sdv includes yogi as backup engine.
yogi is executed if corral returns nur.
training and validation .
we note that all of our debugging and training of heuristics was performed on the itp suite of drivers superset of subitp .
the ntp suite was reserved for validation.
threats to validity and limitations.
the hardest part of our experiments was classifying defects as true or false.
this is a manual e ort and very challenging for a large test suite like the ntp.
the quality assurance team2101enum init deleted 2int t 3do global devobj 5void dispatchroutine1 do devobj t init global devobj devobj de de devobj deviceextension ... iodeletedevice de self ... assert t !
deleted 15void iodeletedevice do d if d global devobj t deleted ... aliasing among environment pointers devobj deviceextension self devobj1int completed 2irp global irp 4void dispatchroutine2 do devobj irp irp completed global irp irp de de devobj deviceextension ... iocompleterequest de flushirp ... iocompleterequest de blockirp ... 14void iocompleterequest irp p if p global irp assert completed !
completed aliasing among environment pointers devobj deviceextension flushirp irp and devobj deviceextension blockirp irp figure examples demonstrating environment aliasing of sdv put in this manual e ort to provide us with the defect classi cation of slam and q. classi cation for other con gurations of q was carried out by us.
it is possible that we may have missed classifying some defects as false.
however note that such false defects would only make q look better.
all of the techniques presented in this paper were inspired by looking at device drivers.
while we believe that the fundamentals behind these techniques will generalize to other settings it is possible that the speci c details might not apply to other programs.
for instance the choice of which bitvector operations to support in the bvencoder or choosing n before we abstract loops might be speci c to drivers.
in other settings these choices may be made di erently but the techniques can still be useful.
.
related work memory model .
the translation of c to boogie in havoc smack and now sdv q encodes the heap using one or more map variables.
havoc uses the split memory model whereas smack uses a pointer analysis for the splitting and borrows the semantics of the pointeranalysis on environment pointers .
both of these were inadequate in our setting prompting us to design the re ned memory model.
there are other tools that encode c s operational semantics without using maps.
for instance cbmc uses a pointeranalysis to identify the set of all possible targets of a pointer and replaces the dereferences of that pointer with an if thenelse that writes directly to the target locations.
in this way cbmc ends up with a program with only scalar variables.
because of the heavy use of pointer analysis cbmc has been most successful in the context of embedded systems that are usually not heap intensive and doesn t scale as much on the drivers in our test suite.
bitvector analysis .
our design of bvencoder is a novel way of using type constraint based analysis to mix integer and bitvector reasoning.
type constraint based analyses and type inference has a rich history of proving program properties.
for instance cqual re nes c types with quali ers such as non null .
then proving the absence of null dereferences reduces to a type inference problem.loop coverage .
unrolling a loop for a xed number of times has been the most common approach used with bounded model checkers.
there has been recent work to address loss of coverage.
in the authors under approximate a loop using a quanti ed constraint that captures the mutations performed on the loop and then replace the loop with this constraint.
however in their case the target solver was a sat solver and quanti cation of boolean formulas is still decidable.
in corral adding quanti ers in the presence of maps and arithmetic leads to undecidability.
nonetheless it would be interesting to try their approach in our setting.
work on estimating worst case complexity of a program also infers bounds on the number of loop iterations.
however that work mostly focusses on nding the maximum number of iterations for a loop in an execution whereas we are interested in nding the minimum number of iterations before the loop can exit.
in other words worst case complexity infers the big ocomplexity whereas we want the small o complexity.
in that sense our heuristic on loop bound inference is unique.
.
conclusion this paper gives a thorough walkthrough of the sdv q veri cation system.
the act of replacing slam with corral led to many interesting challenges that had to be solved before sdv q reached production quality.
we used a large set of sdv benchmarks to experiment and learn ways of solving the challenges.
traditionally the veri cation community has focussed on the core algorithms while the end to end details of the veri cation system as a whole get ignored.
we believe that it is very important to present and understand such details for wider deployment of veri cation tools.
.