heap cloning enabling dynamic symbolic execution of java programs saswat anand georgia institute of technology atlanta u.s.a. saswat cc.gatech.edumary jean harrold georgia institute of technology atlanta u.s.a. harrold cc.gatech.edu abstract the dynamic symbolic execution technique can automatically perform symbolic execution of programs that use problematic features of java such as native methods.
however to compute precise symbolic execution the technique requires manual effort to specify models for problematic code.
furthermore existing approaches to perform symbolic execution either cannot be extended to perform dynamic symbolic execution or incur significant imprecision.
in this paper we present a novel program transformation technique called heap cloning.
heap cloning transforms a program in such a way that dynamic symbolic execution of the transformed program results in the same path constraints as dynamic symbolic execution of the original program.
however symbolic execution of the transformed program produces feedback on where imprecision is introduced and that feedback can reduce the manual effort required to build models.
furthermore such transformation can enable existing approaches to perform symbolic execution systems to overcome their limitations.
in this paper we also present a system called cinger that leverages heap cloning and that we used to perform an empirical evaluation.
the empirical evaluation shows that cinger can compute precise path constraints and requires little if any manual effort for a set of large real world programs.
i. introduction symbolic execution is a program analysis technique that interprets a program using symbolic inputs along a path and computes a constraint called a path constraint for that path over those symbolic inputs.
if the path constraint is satisfiable any solution of the constraint represents a program input that exercises the path.
although in theory computing path constraints is well understood in practice it is still challenging to automatically compute precise1path constraints for real world programs.
to be able to automatically compute path constraints for any program written in a particular programming language a symbolic execution system must support every feature of that language.
if a symbolic execution system does not support some language features manual effort is required to specify models for those parts of a program that use those features.
for java native methods and features such as reflection that are dependent on the internals of a java virtual machine jvm complicate the implementation of a symbolic execution system.
however these features are widely used in real world java programs.
one study shows that the number of times 1a path constraint of a path pisprecise if any solution of the path constraint represents program inputs that cause the program to take path p.native methods are called by programs in the spec jvm98 benchmark ranges from thousand to million.
native methods are written in languages such as c and thus they do not have java bytecode representations.
one approach to implementing a symbolic execution system that supports those features extends a standard jvm e.g.
oracle s jvm that already supports all features of java.
however none of the existing symbolic execution systems for java are based on this approach.
this approach is difficult to implement and also difficult to maintain because the addition of new language features to the java language and changes or additions to java s standard library may require modifications to the jvm and the symbolic execution system.
to address the difficulty of implementing a symbolicexecution system researchers have developed the dynamic symbolic execution dse technique also known as concolic execution .
under the dse technique the problematic code of a program which cannot be symbolically executed is executed only concretely 2and the rest of the program is executed both symbolically and concretely.
for java problematic code such as native methods and code that uses reflection can be executed concretely on a standard jvm that already supports those features.
however two problems arise in dse.
the first problem arises because native methods are executed only concretely.
this concrete execution leads to the computation of imprecise path constraints because the effects of those methods on the path constraint and the program state are ignored.
whenever a native method updates the value of a memory location failure to update the symbolic value corresponding to that memory location can introduce imprecision.
in general manuallyspecified models which model effects of native methods are necessary for eliminating such imprecision.
however an automatic method for identifying native methods whose side effects may introduce imprecision and thus need to be modeled can significantly reduce the required manual effort.
existing approaches for implementing dse do not address this problem.
the second problem arises from limitations of the two current approaches that are used to implement dynamic 2concrete execution refers to normal execution of a program with nonsymbolic values.
.
c ieee ase lawrence ks usa33 symbolic execution systems for java.
these approaches either cannot incorporate the dse technique or incur imprecision.
the first approach uses a custom interpreter that interprets a program according symbolic execution semantics.
under this approach a standard jvm cannot execute the problematic code of a program because the program s state which is managed by the interpreter is unfamiliar to the jvm.
the second approach instruments a program and executes the instrumented code on a standard jvm such that the instrumentation code computes the path constraints.
under this approach although the program can be executed concretely by the jvm computed path constraints can be imprecise because of problems in instrumenting java s standard library classes.
these problems are illustrated in section ii.
to address the two above mentioned problems we developed and present in this paper a novel programtransformation technique which we call heap cloning .
the heap cloning technique transforms the subject program pso that the transformed program p primehas two properties.
first p primeuses copies of the original classes produced by the heapcloning technique.
second during execution of p prime the heap consists of two partitions a concrete heap consisting of objects of the original classes and a symbolic heap consisting of objects of the copied classes.
native methods of the original classes operate on the concrete heap and java methods of the copied classes operate on the symbolic heap.
one important benefit of heap cloning is that it can determine the side effects of native methods by comparing the value of a memory location in the symbolic heap with the value of the corresponding location in the concrete heap.
thus a system that leverages heap cloning can reduce the manual effort required to specify models of native methods by automatically identifying the subset of methods that must be modeled.
another important benefit of heap cloning is that it addresses the problems that arise in implementing dseusing custom interpreter and instrumentation approaches.
under the custom interpreter approach heap cloning enables execution of native methods on a standard jvm using the concrete heap.
in the instrumentation approach heap cloning eliminates the imprecision that arises due to problems with instrumenting java s standard library classes because the transformed program use copies of library classes.
in this paper we also present c inger concolic in put generator a system we developed that implements heap cloning along with the results of empirical studies we performed using c inger to evaluate the effectiveness of the heap cloning technique.
c inger uses the programinstrumentation based approach to symbolic execution and leverages another technique which we developed in our prior work that aims to improve the efficiency of computing path constraints.
we performed our studies on five real world example programs that extensively use java s standard library classes and other language features such as reflection and native methods.
the first study shows that the imprecision that arises in the instrumentation approach can be eliminated by leveraging heap cloning.
the second study shows that1class l intf l intv this.f v native void complex 6class a l l a intv this.l new l val public static void main string args init inti intinput a a new a i l x a.l intj x.f if j x.complex if x.f error fig.
.
example java program.
heap cloning can reduce the manual effort required to specify models for native methods that possibly introduce imprecision and that a symbolic execution system that uses the custominterpreter approach can be applied automatically to a larger set of programs by leveraging heap cloning.
the main contributions of the paper are a novel program transformation technique heap cloning that reduces the manual effort required to write models for native methods and addresses the problem that arise in implementing dse using the two existing approaches.
a practical dse system c inger that leverages the heap cloning technique and an optimized instrumentation approach developed in our prior work .
an empirical evaluation of the technique that demonstrates that it is possible to efficiently compute precise path constraints for programs which may use native methods and java s standard library classes with little if any manual effort.
ii.
b ackground and motivation in this section we first introduce the example that we use throughout the paper.
we then illustrate the problems that arise in dse using the example.
example.
figure gives an example java program p which consists of two classes aandl.pinputs an integer line and performs several simple operations.
the native method complex which is invoked in line of figure reads the current value of the field f and stores its corresponding absolute value back into field f. for the purpose of discussion suppose that the following java code is equivalent to the code of the complex method.
void complex int i this.f if i i i this.f i effects of native methods on precision.
suppose the program is executed with input .
the intraprocedural path through34themain method that is executed with this input is the sequence of all statements in that method.
in dse suppose we introduce a symbol ito represent the symbolic program input and symbolically execute along the path.
as the concrete input value i.e.
propagates through the program variables the symbolic value is propagated similarly.
for example because the concrete input value is stored in the field fat line the memory location corresponding to the field is mapped to symbolic value i. x x x is the correct path constraint for this path.
the first and third conjuncts3correspond to the branching statements of lines and respectively.
the second conjunct corresponds the branching statement inside the complex method.
note that the third conjunct accounts for the side effects of the native method complex which on the current path reads the value i.e.
of the fieldfat the time of its invocation and then stores the absolute value i.e.
into the field f. however it is difficult to automatically compute the correct path constraint because symbolic execution of native methods is challenging if not impossible.
as a result a dse engine would ignore the update to field fthat is made inside complex and incorrectly compute the path constraint x x .
this path constraint is incorrect because it is missing the conjunct corresponding to the branch incomplex method and the second conjunct in this path constraint is different from the third conjunct of the correct path constraint even if both conjuncts are added to the respective path constraints as a result of execution of the statement in line .
to eliminate this imprecision the user must provide a model for the complex method.
although writing such models cannot be automated because it requires manual analysis of native methods in many cases it is possible to automatically identify methods whose side effects introduce imprecision in computed path constraints.
in this example an automatic technique such as heap cloning can determine that ignoring the update to field finside complex method can introduce imprecision because the memory location corresponding to the field is mapped to some symbolic value.
custom interpreter approach for dse.this approach which is used in jfuzz symbolic pathfinder kiasan and symbolic execution systems used in