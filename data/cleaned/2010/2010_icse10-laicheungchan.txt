detecting atomic set serializability violations in multithreaded programs through active randomized testing zhifeng lai and s.c. cheung department of computer science and engineering hong kong university of science and technology kowloon hong kong zflai scc cse.ust.hk w.k.
chan department of computer science city university of hong kong tat chee avenue hong kong wkchan cs.cityu.edu.hk abstract concurrency bugs are notoriously difficu lt to detect because there can be vast combinations of interleavings among concurrent threads yet only a small fraction can reveal them.
atomic set serializability characterizes a wide range of concurrency bugs including data races and atomicity violations.
in this paper we propose a two phase testing technique that can effectively detect atomic set serializability violations.
in phase i our technique infers potential violations that do not appear in a concrete execution and prunes those interleavings that are violation free.
in phase ii our technique actively controls a thread scheduler to enumerate these potential scenarios identified in phase i to look for real violations.
we have implemented our technique as a prototype system a ssetfuzzer and applied it to a number of subject programs for evaluating concurrency defect analysis techniques.
the experimental results show that a ssetfuzzer can identify more concurrency bugs than two recent testing tools racefuzzer and a tomfuzzer .
categories and subject descriptors d. .
software program verification reliability d. .
testing and debugging testing tools .
general terms languages algorithms reliability verification keywords software testing atomicity serializability dynamic analysis .
introduction multithreaded programs have gained more prominence since the advent of multi core architectu re.
at the same time they incur concurrency bugs that do not exist in sequential programs.
these bugs are widespread in both proprietary software and opensource software .
concurrency bugs are difficult to detect because failures of these bugs often manifest themselves only under specific thread interleavings.
however the number of possible interleavings for a multithreaded program is often myriad.
researchers have proposed various criteria for analyzing concurrency defects.
one such criterion is data race freedom.
this criterion is unsatisfactory because some data races can be intentional and beni gn .
recently a number of serializability criteria have been proposed for multithreaded programs including atomicity causal atomicity and conflict view serializability .
however they commonly ignore the correlations among shared variables such as invariants and consistency properties.
these criteria therefore do not accurately reflect correct program behaviors resulting in missed bugs and false warnings.
more recently vaziri et al.
proposed another criterion called atomic set serializability.
this criterion assumes that a consistency property exists between memory locations which are grouped into an atomic set .
code fragments expected to preserve the consistency of an atomic set are called units of work .
atomic set serializability requires that units of work must be serializable for all the atomic sets that they operate on.
this criterion characterizes a wider range of concurrency bugs than many previously proposed criteria.
errors due to data races high level data races and violations of standard notions of serializability can all be treated as violations of atomic set serializability.
besides previous experiences of using this criterion show that it can be more accurate in discerning real concurrency bugs than other existing ones .
the atomic set serializability criterion is useful but verifying whether a program satisfies this criterion is challenging.
hammer et al.
proposed a runtime monitoring technique to detect atomic set serializability violations based on a set of problematic access patterns proposed in .
this approach reports a violation when the execution being monitored matches any such patterns.
although the approach is precise it suffers from at least one crucial problem from the viewpoint of bug detection.
suppose that a program has a bug that can result in an atomic set serializability violation.
the ability of this approach to detect the violation highly depends on the thread scheduling strategy of the underlying operating system or virtual machine.
if the execution being monitored does not exhibit any violations the approach cannot detect the bug even though other executions may exhibit such a violation.
repeating the monitoring without cautiously controlling thread schedules does not warrant producing a this research was partially supported by the research grants council of hong kong under grant number s national science foundation of china under grant number national basic research of china under grant number 2006cb303000 and a grant of city university of hong kong under grant number cityu .
correspondence author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on ser vers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.
235violating execution.
worse still the chance of hitting certain serializability violations is empirically low even under stress testing .
one can alternatively use model checking techniques to enumerate all interleavings.
however model checking techniques for atomic set serializabil ity are not scalable even for medium sized programs because the number of possible thread interleavings often grows exponentially with the length of an execution.
in this paper we propose an active randomized testing technique called fuzz testing for atomic set serializabili ty or assetfuzzer to detect atomic set serializability violations.
active randomized testing was originally introduced by racefuzzer to detect real data races in two phases.
first it uses an imprecise race detection algorithm to derive pairs of statements in a multithreaded program that may potentially be in race.
these statement pairs are then used to guide a randomized scheduler to create real data ra ces.
in this paper we extend the active randomized testing te chnique to detect atomic set serializability violations.
our extension needs to address two new challenges how to infer potential violations from an execution that exhibits no serializability violations and how to manipulate executing threads so that we can generate effective thread schedules to detect real violations.
in the first phase a ssetfuzzer derives a relaxed partial order execution trace from a concrete execution.
the relaxed partial order execution trace captures interleavings that respect the control flows of the concrete execution .
if a ssetfuzzer infers that no interleavings in the same relaxed partial order may violate atomic set serializability then these interleavings must satisfy this criterion.
note that existing techniques need to fully explore all these interleavings to discover this fact.
if assetfuzzer infers that there are potential violations in these interleavings it records problematic access patterns that capture these violations.
in the second phase a ssetfuzzer controls a thread scheduler to explore only these potentially violating interleavings.
this search is efficient because a large portion of violation free executions have been pruned in the first phase.
further since access events of a potential violation have been identified a ssetfuzzer can concentrate on manipulating threads to discover their undesirable occurrence sequences.
the combination of violation inference and thread manipulation enables a ssetfuzzer to detect interleavings that violate atomicset serializability earlier than existing techniques.
we have implemented our techniques in a tool called assetfuzzer and applied it to java subjects that have been commonly used to evaluate concurrency defect analysis techniques .
the experimental results show that assetfuzzer can detect ten times more atomic set serializability violations than a runtime monitoring algorithm running on top of a randomized scheduler .
on average a ssetfuzzer increases the rate of detecting atomic set serializability violations by at least threefold.
results of these experiments also show that assetfuzzer discovers more concurrency bugs than two recent active testing tools r acefuzzer and a tomfuzzer .
not all of these bugs can be discovered even by a combination of these two tools due to the use of atomic set serializability.
in summary this paper makes the following contributions g121 we develop a dynamic analysis technique that can infer potential atomic set serializability violations from a concrete execution.
not only does the technique look for violations in the execution being monitored but it also infers potential violations in other executions.
g121 based on the potential violations derived from the dynamic analysis we propose an active randomized testing technique which can effectively explore executions that violate atomic set serializability.
since assetfuzzer actually creates executions that violate atomic set serializability it does not report false positives.
g121 we implement the techniques in a prototype system and have applied it to a number of java subjects.
the experimental results show that a ssetfuzzer can effectively detect a larger number of real atomic set serializability violations than a runtime monitoring technique over a randomized scheduler .
the rest of the paper is organized as follows.
section uses an example to motivate our work.
section presents the foundation of our techniques.
section describes the dynamic analysis technique and the active randomized testing technique.
section evaluates the techniques on recently used java subjects for benchmarking.
section reviews related work and section summarizes this paper.
.
motivation in this section we use an example f igure to illustrate the challenge of detecting atomic set serializability violations and the rationale of a ssetfuzzer to quickly explore violating executions from a violation free execution.
the example is adapted from which illustrates that defect anal ysis techniques for atomicity and conflict view serializability can report false warnings that do not reflect real concurrency bugs while techniques for analyzing atomic set serializability can filter out such warnings.
.
an example figure .
an example program of account system.
the example program is an account system containing a class account which declares two instance fields checking and savings .
this class has two constructors and several methods operating on the two fields.
the method islegal validates the legality of an account instance.
the method creditinterest public class account double checking denoted as c double savings denoted as s account double c double s constructor setchk c setsav s account account acc constructor bug seteqchk acc seteqsav acc boolean islegal return getchk getsav synchronized void creditinterest double rate setchk getchk .
rate setsav getsav .
rate synchronized void seteqchk account acc setchk acc.getchk synchronized void seteqsav account acc setsav acc.getsav l1 synchronized double getchk return checking l2 synchronized double getsav return savings l3 synchronized void setchk double c checking c l4 synchronized void setsav double s savings s g1872 g2869 g483 g3 g3 g3 g21 g2869 g4666 g1876 g484 g1855 g4667 g21 g2869 g4666 g1876 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4587 g2919 g2929 g2896 g2915 g2917 g2911 g2922 g4666 g4667 g3117 g21 g2870 g481 g2871 g4666 g1876 g484 g1855 g4667 g26 g2870 g481 g2871 g4666 g1877 g484 g1855 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2887 g2918 g2921 g4666 g4667 g3119 g21 g2870 g481 g2872 g4666 g1876 g484 g1871 g4667 g26 g2870 g481 g2872 g4666 g1877 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2903 g2911 g2932 g4666 g4667 g3120 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2885 g2913 g2913 g2925 g2931 g2924 g2930 g4666 g4667 g3118 g1872 g1870 g4666 g1845 g883 g4667 g1872 g1870 g4666 g1845 g884 g4667 g1872 g1870 g4666 g1845 g885 g4667 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 y.c y.s figure .
a serial execution.
g1872 g2869 g483 g3 g3 g3 g3 g21 g2869 g4666 g1876 g484 g1855 g4667 g21 g2869 g4666 g1876 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4587 g2919 g2929 g2896 g2915 g2917 g2911 g2922 g4666 g4667 g3117 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1792 g2779 g481 g2780 g4666 g2206 g484 g2185 g4667 g26 g2870 g481 g2871 g4666 g1877 g484 g1855 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2887 g2918 g2921 g4666 g4667 g3119 g1792 g2779 g481 g2781 g4666 g2206 g484 g2201 g4667 g26 g2870 g481 g2872 g4666 g1877 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2903 g2911 g2932 g4666 g4667 g3120 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2885 g2913 g2913 g2925 g2931 g2924 g2930 g4666 g4667 g3118 g3 g1872 g1870 g4666 g1845 g883 g4667 g1872 g1870 g4666 g1845 g884 g4667 g1872 g1870 g4666 g1845 g885 g4667 y.c y.s figure .
another serial execution.
g1872 g2869 g483 g3 g3 g3 g3 g21 g2869 g4666 g1876 g484 g1855 g4667 g21 g2869 g4666 g1876 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4587 g2919 g2929 g2896 g2915 g2917 g2911 g2922 g4666 g4667 g3117 g1792 g2779 g481 g2780 g4666 g2206 g484 g2185 g4667 g26 g2870 g481 g2871 g4666 g1877 g484 g1855 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2887 g2918 g2921 g4666 g4667 g3119 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1792 g2779 g481 g2781 g4666 g2206 g484 g2201 g4667 g26 g2870 g481 g2872 g4666 g1877 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2903 g2911 g2932 g4666 g4667 g3120 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2885 g2913 g2913 g2925 g2931 g2924 g2930 g4666 g4667 g3118 g3 g1872 g1870 g4666 g1845 g883 g4667 g1872 g1870 g4666 g1845 g884 g4667 g1872 g1870 g4666 g1845 g885 g4667 y.c y.s figure .
a non serial execution that violates atomic set serializability.
g1872 g2870 g483 g3 g3 g3 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1872 g1870 g4666 g1845 g886 g4667 g1872 g1870 g4666 g1845 g887 g4667 g1872 g1870 g4666 g1845 g888 g4667 g21 g2873 g4666 g1876 g484 g1855 g4667 g26 g2873 g4666 g1876 g484 g1855 g4667 g21 g2873 g4666 g1876 g484 g1871 g4667 g26 g2873 g4666 g1876 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g3 g2913 g2928 g2915 g2914 g2919 g2930 g2893 g2924 g2930 g2915 g2928 g2915 g2929 g2930 g4666 g4667 g3121 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g1872 g2870 g483 g3 g3 g3 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1872 g1870 g4666 g1845 g886 g4667 g1872 g1870 g4666 g1845 g887 g4667 g1872 g1870 g4666 g1845 g888 g4667 g21 g2873 g4666 g1876 g484 g1855 g4667 g1797 g2782 g4666 g2206 g484 g2185 g4667 g21 g2873 g4666 g1876 g484 g1871 g4667 g1797 g2782 g4666 g2206 g484 g2201 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2913 g2928 g2915 g2914 g2919 g2930 g2893 g2924 g2930 g2915 g2928 g2915 g2929 g2930 g4666 g4667 g3121 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g1872 g2870 g483 g3 g3 g3 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1872 g1870 g4666 g1845 g886 g4667 g1872 g1870 g4666 g1845 g887 g4667 g1872 g1870 g4666 g1845 g888 g4667 g21 g2873 g4666 g1876 g484 g1855 g4667 g1797 g2782 g4666 g2206 g484 g2185 g4667 g21 g2873 g4666 g1876 g484 g1871 g4667 g1797 g2782 g4666 g2206 g484 g2201 g4667 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2913 g2928 g2915 g2914 g2919 g2930 g2893 g2924 g2930 g2915 g2928 g2915 g2929 g2930 g4666 g4667 g3121 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 models crediting interests.
the method seteqchk sets the checking balance of the current instance to that of the formal parameter.
the method seteqsav has similar functionality to that of seteqchk .
the remaining methods are setters and getters for the two fields.
g3 figure .
a test case for the account system.
the test case figure for this example creates an account instance x and starts a thread t1.
thread t1 first checks whether x is legal or not.
if x is legal t1 starts another thread t2 creates another account instance y from x and then executes a sequence of statements si g100 i g100 that do not access the fields of x and y. once t2 is started it invokes the method creditinterest on x after executing another statement sequence si g100 i g100 .
running the test case may reveal a bug in the class account .
developers of this class do not guarantee the second constructor to be executed atomically.
such a bug is common in multithreaded programs and similar bugs are found in the jdk library .
owing to this bug t2 can interleave with t1 when t1 partially updates the state of x. such interleavings cause the state of y to be inconsistent with that of x. figures g164 explain the conditions under which the bug manifests itself.
each line in these figures corresponds to a sequence of memory access events in a thread and time advances from left to right.
there are two types of memory access events namely read r and write w which operate on fields checking and savings .
for brevity let c and s denote these two fields respectively.
each method invocation e.g.
seteqchk in figure is uniquely labeled by an integer e.g.
seteqchk .
each access event made by a method invocation is labeled by a sequence of integers corresponding to the calling context of that method invocation.
for instance r x.c denotes a read event made by seteqchk in the calling context account g111 seteqchk .
this read event accesses the field checking of instance x. to simplify the presentation we do not draw the invocations of setter getter methods and use the notation tr si to denote the set of events generated by executing the statement si.
the executions in figure and figure are serial because account and creditinterest execute contiguously without being interrupted.
the execution in figure is non serial because execution of creditinterest interleaves the execution of account .
this execution results in an error because the state of y after the execution is different from that of either of the two serial execution s as shown in these figures.
this error corresponds to an atom ic set serializability violation which can be characterized by a problematic access pattern r2 x.c w5 x.c w5 x.s r2 x.s .
that is when an execution exhibits such a pattern the result of the execution can be different from any serial execution.
the chance of hitting such a violation using a randomly chosen schedule is low.
it decreases exponentially with the number of statements following w y.s in t1.
the runtime monitoring technique detects an atomic set serializability violation only for the execution being monitored but does not leverages information of the current execution to increase the chance of finding such a violation subsequent test runs.
this approach is unfavorable to hunting concurrency bugs because certain serializability violating executions seldom occur even under stress testing .
.
outline of a sset fuzzer although no violations occur in the execution in figure we observe that it provides hints on how to find one.
the execution contains an access pattern w x.c w5 x.s r2 x.c r2 x.s which is a permutation of the problematic access pattern r2 x.c w5 x.c w5 x.s r2 x.s .
a ssetfuzzer exploits this information to explore one violating execution.
public class accounttest account x y thread t1 new thread public void run if x.islegal t2.start y new account x s1 s2 s3 stmts not accessing x y thread t2 new thread public void run s4 s5 s6 stmts not accessing x y x.creditinterest .
public void testcase x new account t1.start 237concrete execution traceconcrete execution active randomized testingtest input t program ppotential violations real violationsvulnerable window locksetrelaxed partial order execution tracerelaxed happedbefore analysis hybrid analysisvulnerable window lockset analysis phase i phase ii figure .
a sset fuzzer s two phase testing approach.
as shown in figure a ssetfuzzer first conducts a relaxed happens before analysis to derive from the concrete execution figure a relaxed partial order execution trace which captures a set of thread interleavings that share the same control flows of the given execution in phase i. a ssetfuzzer then uses a hybrid analysis to check whether there are linearizations of the relaxed partial order execution trace matching the problematic access pattern.
such an access pattern specifies a subset of executions in a relaxed partial order execution trace.
in phase ii a ssetfuzzer controls a thread scheduler to explore executions in this subset.
focusing only on this subset the size of the search space is reduced from to which represents the total number of possible thread interleavings and the number of possible thread interleavings that match the pattern respectively.
however not all linearizations in this subset are feasible.
for instance creditinterest cannot interleave between r x.c and w y.c because t1 and t2 hold the same lock x after entering seteqchk and creditinterest .
exploring such infeasible executions not only wastes time but may also make the whole system reach a deadlock.
such a deadlock due to active thread control is referred to as thrashing .
a ssetfuzzer conducts a vulnerable window lockset analysis in phase i and then uses the computed lockset information to prune these infeasible executions in phase ii.
in this way a ssetfuzzer effectively reduces the search space to merely four interleavings and each of them violates the atomic set serializability criterion.
assetfuzzer explores all such interleavings in turn and reports real violations that it comes across in the produced executions.
one such violating execution is shown in figure .
assetfuzzer discovers the bug by exploring an execution that violates atomic set serializability.
however this bug is missed by two recent active testing tools r acefuzzer and atomfuzzer .
r acefuzzer uses potential data race information derived from an imprecise race detection algorithm and generates thread schedules to find real data races.
since all accesses to shared fields are protected by the synchronized keywords there are no data races in this example.
r acefuzzer therefore fails to discover the bug.
a tomfuzzer controls a thread scheduler to find an atomicity violating locking pattern where a thread acquires and releases a lock while it is inside an atomic block another thread subsequently acquires and releases the same lock and then the first thread again acquires the same lock while inside the same atomic block.
a tomfuzzer uses the heuristics that any code block declared as synchronized is atomic.
for instance seteqchk in t1 is inferred as atomic.
since seteqchk seteqsav and creditinterest hold the same lock x they cannot interfere with one another.
therefore no executions in the example exhibit the locking pattern and atomfuzzer also fails to discover the bug.
.
preliminaries this section introduces the background of our work.
we assume that each statement in a concurrent thread accesses at most one memory location.
this can be achieved by transforming a program into a three address form.
an execution of a statement changes a program from one state to another and generates different types of events including memory access events lock acquisition events and lock releas e events.
these events are described in detail in subsequent sections.
an execution of a program thus outputs a sequence of events.
.
atomic set serializability table .
problematic access patterns .
access pattern description ru m w u g99 m w u m value read is stale by the time an update is made in u. ru m w u g99 m ru m two reads of the same memory location yield different values in u. wu m ru g99 m w u m an intermediate state is observed by u g99.
wu m w u g99 m ru m value read is not the same as the one last written in u. wu m w u g99 m w u m value written by u g99 is lost.
wu m1 w u g99 m w u g99 m g16m w u m2 memory is left in an inconsistent state.
wu m1 w u g99 m2 w u m2 w u g99 m1 same as above wu m1 ru g99 m ru g99 m g16m w u m2 state observed is inconsistent.
ru m1 w u g99 m w u g99 m g16m ru m2 same as above ru m1 w u g99 m2 ru m2 w u g99 m1 same as above wu m1 ru g99 m2 w u m2 ru g99 m1 same as above a set of memory locations m is grouped into an atomic set if there exists a consistency property between the memory locations in m .
a unit of work u declared on a set of atomic sets is an event sequence that is expected to preserve the consistency for each declared atomic set.
units of work can be nested.
if an event e appears in u and u is not nested in another unit of work then e belongs to u. if u is nested in another unit of work then e belongs to the outermost unit of work where u is nested.
a memory access event belonging to a unit of work u is of the form mem m a u which indicates that u performs an access of type a either r or w to memory location m. for brevity an event that reads m and belongs to u is denoted as r u m .
similar notation w u m is defined for events of access type w. a trace is a sequence of events.
an execution trace e is a sequence of events from an actual program execution.
given an execution e and an atomic set m the projection of e on m is a sequence of memory access events such that events in the projection access memory locations in m and for each pair of events their order in the projection is the same as that in e. the atomic sets of an execution e atomicsets e consists of all atomic sets whose elements are accessed by events occurring in e i.e.
atomicsets e m m g143 m and m is accessed by an event in e .
an execution e is atomic set serializable if the projection of e on each atomic set in atomicsets e is conflict serializable otherwise the execution is considered non serializable .
238an access pattern is a sequenc e of memory access events specifying a subset of executions.
a trace matches an access pattern if a substitution of the units of work and memory locations in the pattern can be found such that the trace contains events in the pattern instance and the order of these events is the same as that of the pattern instance.
for example the trace ru1 x ru1 y wu2 x wu2 y wu1 z wu1 x matches the access pattern r u m wu g99 m wu m with the substitution u u1 u g99 u2 m x .
vaziri et al.
identified eleven problematic access patterns such that an execution is atomic set serializable if and only if it does not match any of these patterns.
in table if m denotes one of m m1 m2 the notion m g16m denotes the other memory location in m. .
methodology as shown in figure a ssetfuzzer consists of two phases.
phase i section .
computes a set of potential atomic set serializability violations from a concrete execution.
phase ii section .
uses the elements of this set to guide a thread scheduler to explore executions that have real violations.
we illustrate our techniques by finding a non serializable execution that matches the th problematic access pattern in table .
.
phase i inferring potential violations tid u ... ...ei ru m1 ej ru m2 ek wu g99 m1 el wu g99 m2 temporal order of executiontid u tid u g99 ... ... ... ...ei ru m1 ej ru m2 ek wu g99 m1 el wu g99 m2 tid u g99 inferexecution g3 x execution g3 x g99 figure .
visual illustration of a sset fuzzer .
our first challenge is how to infer potential violations from a concrete execution exhibiting no serializability violations .
we illustrate how a ssetfuzzer addresses this challenge in figure which represents two executions x and x g99.
each of them is enacted in two threads tid u and tid u g99 where tid u returns the thread that executes u. x is a given violation free execution and x g99 is an inferred execution that violates serializability according to the 9th pattern in table .
.
.
relaxed happens before analysis figure .
an rpoet of the execution in figure .
traditionally the happens before relation induces a partial order structure which characterizes a set of mazurkiewiczequivalent traces .
to address the challenge we relax the happens before relation by removing the happens before relations of memory access events lock acquisition and release events across threads in a concrete execution.
on one hand this relaxation allows the exploration of more classes of mazurkiewicz equivalent traces.
on the other hand checking explicit synchronization constraints can still prune large amounts of infeasible interleavings that do not respect these constraints imposed on a program.
in other words we only need to track explicit synchronization events such as start join wait and notify in a java program execution.
the relaxed happensbefore relation denoted by g1372 g3557 is therefore a subset of the traditional happens before relation.
the resulting structure induced by a relaxed happens before relation is called a relaxed partial order execution trace rpoet .
an rpoet of a concrete execution facilitates the exploration of those thread interleavings that respect the control flows of the concrete execution .
an example rpoet of the execution in figure is shown in figure where events tr si irrelevant to serializability violations are omitted.
basically if one linearization of an rpoe t matches a problematic access pattern the program may violate the atomic set serializability in those thread interleavings that share the same rpoet.
such detection can be achieved by checking the relaxed happens before relation between events in the rpoet.
for instance if the four events ek el ei and ej of execution x can be reordered to become x g99 in figure they must satisfy the following formula frhb .
.
lockset analysis the relaxed happens before analysis is useful to infer potential violations but it can be imprecise and generate many false positives.
this is because the relaxed happens before analysis does not consider the following locking discipline each atomic set is protected by a common lockset in the sense that every unit of work holds the lockset when it accesses the atomic set.
for instance execution x g99 of figure is infeasible if the two units of work u and u g99 hold the same lock during their entire execution periods.
our second challenge is thus on how to prune infeasible executions that do not comply with the locking discipline .
to eliminate such false positives deduced by the relaxed happensbefore analysis we conduct a lockset analysis.
determining whether an execution comply with this locking discipline requires computing the set of locks held by a thread at any given point.
given a lock l and a thread t let acq l t and rel l t denote a lock acquisition event and a lock release event respectively.
let events be uniquely labeled by their indices in an ascending order according to their order of occurrences.
the locks held by thread t before the occurrence of event ei in an execution can be given by lt ei l g7x x i g154 ex acq l t g154 g5y x y i g154 ey g122 rel l t .
if two units of work do not comply with this locking discipline consistent accesses to memory locations in the same atomic set cannot be guaranteed.
for instance if the units of work u and u g99 in execution x of figure do not comply with the locking discipline it is possible to reorder ek and el so that they interleave between ei and ej as depicted by execution x g99.
non compliance can occur in two situations.
first units of work u and u g99 do not hold any common locks during their entire execution periods.
second units of work u and u g99 hold common locks before the occurrence of ei ej ek and el but u releases the common locks between ei and ej.
the lock releases cr eate a window for events ek and el to occur between ei and ej.
to eliminate these false positives algorithmically we formalize the two situations as fls t1 t2 r1 x.c r1 x.s r5 x.c w5 x.c r5 x.s w5 x.s r2 x.c w2 y.c r2 x.s w2 y.s t2.start .
.
hybrid analysis the relaxed happens before analysis and the lockset analysis capture different synchronization constraints imposed on a program.
the use of lockset analysis alone can therefore also be imprecise and generate false positives.
for illustration let us consider the execution in figure .
the method islegal which r x.c and r x.s belong to does not hold any locks during its execution.
according to the lockset analysis the events w5 x.c and w x.s in t2 can be shifted earlier so that they occur between r x.c and r x.s .
if so the resultant execution is nonserializable because it matches the 9th problematic access pattern.
however this execution is infeasible because t2 is started after islegal .
fortunately such false positives can be eliminated by the relaxed happens before analysis.
this suggests that we need to combine both the relaxed happens before analysis and the lockset analysis by forming a logical conjunction of the two preceding formulae frhb and fls.
we refer to such an analysis based on the conjunction of frhb and fls as hybrid analysis .
to illustrate the hybrid analysis let us consider events w x.c w5 x.s r x.c and r x.s in figure .
w x.c and w x.s belong to the unit of work creditinterest r x.c and r2 x.s belong to the unit of work account .
they access the same atomic set x.c x.s .
in the derived rpoet figure w5 x.c and w x.s are concurrent to r x.c and r x.s .
although threads t1 and t2 hold the common lockset x before the occurrence of these events t1 releases x between r x.c and r2 x.s when seteqchk exits.
the hybrid analysis therefore reports a potential violation with respect to the problematic access pattern r x.c w5 x.c w5 x.s r2 x.s .
.
phase ii detecting real violations the objective of phase ii is to explore executions that refine the potential violations detected by the hybrid analysis.
we achieve this by exploiting the potential violation information to direct a thread scheduler.
this task further poses two challenges.
first how to match events between the two phases so that we can suspend threads when relevant events occur ?
second how to choose proper suspension points in threads so as to alleviate the thrashing problem ?
.
.
matching contexts although the concept of finding violating executions by manipulating a thread scheduler has been proposed by racefuzzer our thread manipulation technique needs to handle additional difficulties.
the thread manipulation of racefuzzer is achieved by bringing two racing statements next to each other without considering the calling contexts of these statements.
however this mechanism is inadequate for exploring executions that violate atomic set serializability.
this is because finding such non serializable executions requires identifying the units of work whose access events match some problematic access patterns.
if we cannot map an access event in phase i to the corresponding event in phase ii the executions found in phase ii may not exhibit the intended violations derived in phase i. for instance suppose that the hybrid analysis in phase i infers from the execution in figure that the program can potentially match the problematic access pattern r x.c w5 x.c w5 x.s r2 x.s .
the events in this pattern are generated by executing statements l1 l3 l4 and l2 respectively.
in phase ii if we simply find an execution that matches this statement sequence the execution may not correctly instantiate the inferred violation.
consider the serial execution in figure the events r x.c w2 y.c w y.s and r x.s are also generated by l1 l3 l4 and l2 respectively.
however this execution does not violate atomic set serializability.
in other words the calling contexts of the events in a potential violation in phase i need to match those of the concrete executions identif ied in phase ii.
we use an md5 hash algorithm to codify calling contexts and match an access event in phase i with another in phase ii if both their statement labels and their codified calling contexts are equal.
this approach alleviates the tracing costs and speeds up the matching process.
.
.
alleviating thrashing event reordering requires us to carefully suspend and resume thread executions.
r acefuzzer as well as some other testing tools e.g.
contest suspends a thread whenever a suspicious access event occurs.
this mechanism presents a problem for detecting atomic set serializability violations.
g1872 g2869 g483 g3 g3 g3 g3 g21 g2869 g4666 g1876 g484 g1855 g4667 g21 g2869 g4666 g1876 g484 g1871 g4667 g4585 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4587 g2919 g2929 g2896 g2915 g2917 g2911 g2922 g4666 g4667 g3117 g21 g2870 g481 g2871 g4666 g1876 g484 g1855 g4667 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2929 g2915 g2930 g2889 g2927 g2887 g2918 g2921 g4666 g4667 g3119 g4585 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4589 g4587 g2885 g2913 g2913 g2925 g2931 g2924 g2930 g4666 g4667 g3118 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g1872 g2870 g483 g3 g3 g3 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g152 g1872 g1870 g4666 g1845 g886 g4667 g1872 g1870 g4666 g1845 g887 g4667 g1872 g1870 g4666 g1845 g888 g4667 g491 g491 g491 g491 g491 g491 g491 g491 g491 g4585 g4589 g4589 g4589 g4586 g4589 g4589 g4589 g4587 g2913 g2928 g2915 g2914 g2919 g2930 g2893 g2924 g2930 g2915 g2928 g2915 g2929 g2930 g4666 g4667 g3121 figure .
a problematic thread manipulation.
for instance the hybrid analysis reports that a violation occurs if events w x.c w x.s r x.c and r x.s in figure can be reordered so that an execution of the program matches the problematic access pattern r x.c w5 x.c w5 x.s r2 x.s .
now let us consider a thread manipulation in figure .
the thread execution is switched from t1 to t2 at the point after executing r2 x.c .
the switching attempts to make the execution match the pattern.
unfortunately the thread scheduler could not fire the target event w x.c after thread t2 executes s4 s5 and s6.
this is because the lock x required to enter creditinterest is still being held by thread t1.
consequently the thread scheduler could not make any progress.
such a deadlock due to active thread manipulation is referred to as thrashing .
r acefuzzer uses a daemon thread to break the tie by randomly selecting a thread that is suspended by the testing engine to execute t1 in this example .
although this mechanism resolves thrashing in this case it increases testing time because the thread scheduler needs to wait for some timeouts before breaking the tie.
the mechanism may also miss some non serializable executions.
for instance the resumption of t1 may cause t1 to execute r x.s before t2 executes w x.c .
as a result an execution refining the problematic access pattern is missed.
missing such executions reduces the effectiveness of testing techniques to detect atomic set serializability violations.
we address the thrashing problem by conducting a lockset analysis.
if the hybrid analysis reports a potential violation that involves events ei and ej belonging to unit of work u and events ek and el belonging to unit of work u g99 c.f.
execution x in figure a vulnerable window lockset is computed as follows.
the vulnerable window lockset vwls contains locks that are released between ei and ej and these locks belong to the common lockset ls held by threads when these four events occur.
intuitively when thread tid u releases locks in vwls it creates a window for events ek and el to occur between ei and ej.
such interleaving causes an atomic set serializability violation.
we 240discuss how to utilize the vulnerable window lockset to choose proper context switching points for alleviating the thrashing problem in the next section.
.
.
description of thread manipulation algorithm in this section we informally de scribe the thread manipulation algorithm for detecting atomic set serializability violations.
details of this algorithm can be found in our technical report .
given a violation free execution x in figure if the hybrid analysis infers that events ei and ej belonging to unit of work u and events ek and el belonging to unit of work u g99 can be reordered to match the problematic access pattern ei ek el ej the thread manipulation algorithm explores a concrete execution c.f.
execution x g99 in figure which matches the pattern.
the algorithm accepts two inputs from the hybrid analysis a sequence of statement label and codified calling context pairs that generate events e i ej ek and el and a vulnerable window lockset vwls .
the algorithm runs iteratively.
in each iteration it randomly selects an enabled thread to execute.
if the next event does not match any of the events ei ej ek and el the algorithm simply executes the event.
the algorithm identifies events ei ej ek and el by their statement labels and codified calling contexts from the hybrid analysis.
in order to find an execution that matches the pattern ei ek el ej the algorithm manipulates a randomized schedule as follows.
it suspends thread tid u and resumes thread tid u g99 after executing event ei.
similarly it suspends thread tid u g99 and resumes thread tid u after executing event el.
however the points for thread suspension and resumption must be chosen judiciously to avoid creating thrashing.
as discussed in the preceding section if tid u holds locks in vwls after executing ei thrashing can occur if the algorithm switches thread execution from tid u to tid u g99 at that point.
to avoid thrashing in this case the algorithm chooses a switching point according to vwls .
if vwls is empty the algorithm suspends tid u immediately after executing e i. this operation is safe because tid u g99 does not require locks held by tid u .
if vwls is nonempty the algorithm performs the thread suspension and resumption after tid u releases locks in vwls .
this mechanism prevents thrashing because tid u has released the common locks that tid u g99 needs to acquire before event ek can occur.
thrashing may also occur when the algorithm needs to switch thread execution from tid u g99 to tid u after executing event el.
based on vwls a similar thread manipulation mechanism is employed in that case.
in the other cases when the algorithm encounters thrashing it relies on the default mechanism of r acefuzzer to resolve the problem at any point of the execution if the program gets into a deadlock due to thread manipulation the algorithm randomly selects a suspended thread to break the tie.
when the algorithm encounters event ej it actually detects a real atomic set serializability violation.
at that point it executes the event reports the violation and resumes tid u g99 if it is suspended.
after that the algorithm runs the program using a randomized schedule expecting to catch some program failures such as uncaught exceptions due to atomic set serializability violations.
note that if event e k occurs before event ei the algorithm can suspend thread tid u g99 instead of executing ek to create the correct event order for exploring violating executions.
.
evaluation we implemented a ssetfuzzer on top of the testing framework calfuzzer .
we instrumented java bytecode to monitor events and control thread schedules.
the instrumentation adds additional methods to support the hybrid analysis and the thread manipulation algorithm.
we used the heuristics similar to to infer atomic sets and units of work.
specifically we assume that all non final instance fields of a class and those of its super classes form a per instance atomic set.
all instance methods of that class and those of its super classes are considered the initial units of work declared on these per instance atomic sets.
all nonfinal static fields of a class form a per class atomic set.
all methods of that class are considered the initial units of work for this atomic set.
we instrumented method entry and exit points to keep track of dynamic call graphs which are used to determine what unit of work each access event belongs to.
a dynamic call graph is essentially the stack traces of the methods visited by a thread.
an access event in an atomic set belongs to the outermost unit of work declared on that atomic set.
we conducted experiments to study the effectiveness of a ssetfuzzer in detecting atomic set serializability violations.
the experiments also studied a ssetfuzzer s ability in revealing failures and in discovering concurrency bugs.
.
benchmarking subjects we evaluated a ssetfuzzer using java multithreaded subjects which have been recently used to benchmark concurrency defect analysis techniques .
the first six subjects are open libraries from sun s jdk .
.
and the last seven subjects are closed programs.
these subjects include jigsaw .
.
which is w3c s leading edge web server platform with lines of code.
.
experimental setup we compare a ssetfuzzer asf with several other testing strategies.
the first strategy rm combines a runtime monitoring technique with a randomized scheduler to detect atomicset serializability violations.
the second strategy r acefuzzer rf uses a biased randomized scheduler to find real data races .
the third strategy a tomfuzzer atf controls a randomized thread scheduler to detect an atomicity violating locking pattern .
we used the implementation of r acefuzzer available from the c alfuzzer repository .
we implemented a tomfuzzer the runtime monitoring technique and the randomized scheduler because they are not publicly available.
for each subject we use profiling runs under phase i of asf to build an initial set of potential violations .
we chose profiling runs because we observed that for most subjects the potential violations inferred from profiling runs are almost the same as those inferred from profiling runs.
for each inferred viol ation in the set we ran phase ii of asf times to estimate its effectiveness following .
to compare the effectiveness of asf with that of rm we ran rm the same total number of times as asf for each subject.
to study bug detection ability we ran rf in the same manner as asf.
since atf has only one phase we ran atf the maximum number of times used by rf and asf for each subject.
.
experimental results table summarizes the results of the experiments.
column reports the total lines of code for each subject.
the column headed average runtime reports the average runtime of normal executions without employing any testing strategies as well as the average runtime of executions employing each of the four testing strategies rm rf atf and asf respectively.
for rf and asf the time of the profiling runs in phase i is also included to 241compute the average.
rm has the highest overhead.
for the jigsaw subject rm could not finish within one hour for each test run and was terminated to let the experiments complete in a reasonable time.
for the other subjects its slowdown factors range from .77x .55x.
the slowdown factor is given by the ratio of the average runtime incurred by rm over that of normal executions.
the overhead of rm is high because the runtime monitoring algorithm needs to check each pair of units of work each pair of memory locati ons and each pattern for every execution.
the overhead of asf is much lighter than rm with slowdown factors ranging from .45x .60x.
this is because asf needs to perform the checking only for the profiling runs in phase i. in phase ii it just monitors memory access events and suspends threads upon an occurrence of the events relevant to a potential violation.
the slowdown factors of rf and atf range from .56x39.35x and .86x .72x respectively.
generally atf has low overhead because it just monitors lock acquisition and release events.
the slowdown factor of atf for the stringbuffer subject is less than one because atf causes the subject to raise uncaught exceptions and the subject can terminate earlier than normal executions.
the overheads of atf for the raytracer and jigsaw subjects are quite high because atf encounters thrashing problems.
additional time is required to resolve these thrashings.
the column headed of violations reports the number of real atomic set serializability violations detected by rm and asf.
in the experiments asf is able to detect ten times more real violations than rm.
asf finds real violations in the jigsaw subject while rm cannot finish and report any violations within one hour.
rm cannot detect any violations in the subjects treeset and hedc because violating executions rarely occur in these two subjects under randomized schedules.
we measured the effectiveness of asf rm in detecting atomic set serializability violations by detection rate which is given by the ratio of the number of test runs that asf rm detects any violation over the total number of test runs.
this metrics is si milar to fault detection rate which is used to measure the effectiveness of test selection strategies.
the column headed rviolation reports the detection rates of rm and asf.
the average detection rates of rm and asf are .
and .
respectively.
rm has high detection rates in the subjects moldyn and montecarlo because these two subjects contain customized synchronization primitives that exhibit intentional races .
the violations in these two subjects are therefore considered benign.
if we exc lude the results of these two subjects the average detection rate of rm is about .
.
asf increases the detection rate to .
excluding the two subjects.
these results show that asf is more effective in detecting atomicset serializability violations than randomized testing.
the column headed of exceptions reports the number of distinct uncaught exceptions detected by rf atf and asf.
on average asf detects the largest number of uncaught exceptions.
for each subject the number of uncaught exceptions detected by asf is greater than or equal to those of rf and atf.
in the jigsaw subject asf detects two previously unknown uncaught exceptions of type nullpointerexception in the httpd class.
these exceptions are missed by rf and atf.
we made an aggregation of all the uncaught exceptions detected by rf atf and asf for each subject.
we observed that asf does not miss any uncaught exceptions with respect to these aggregations.
we categorized the testing reports from rf atf and asf according to the problematic memory locations identified.
we classified all access to shared memory locations without proper synchronizations as a malign bug .
for violations that are caused by the same bug we only report the problem once.
we aggregated all the distinct bugs discovered by rf atf and asf for each subject.
the column headed of bugs reports the number of bugs detected by rf atf and asf in these aggregations.
overall asf detects the largest number of bugs except for the subjects arraylist and linkedhashset .
it does not miss any bugs in the closed subjects with respect to the aggregations.
atf detects the least number of bugs and cannot detect any bugs in the closed subjects.
the number of bugs detected by rf is ranged between those of atf and asf.
.
discussion atomfuzzer misses the largest number of bugs.
one major reason is that many concurrency bugs exhibit as asymmetric races which occur when some well behaved threads consistently access a shared memory location with a lock while some illbehaved threads improperly access the memory location due to synchronization errors such as forgetting to use a lock.
these bugs do not have the atomicity violating locking pattern that atomfuzzer looks for.
a tomfuzzer misses such bugs in subjects raytracer weblech etc.
a ssetfuzzer detects these bugs because they exhibit improper access sequences that can be captured by the problematic access patterns in table .
table .
experimental results.
normal rm rf atf asf rm asf rm asf rf atf asf rf atf asf stringbuffer .
.
.
.
.
.
arraylist .
.
.
.
.
.
.
linkedlist .
.
.
.
.
.
.
hashset .
.
.
.
.
.
.
treeset .
.
.
.
.
.
linkedhashset .
.
.
.
.
.
.
moldyn .
.
.
.
.
.
.
raytracer .
.
.
.
.
.
.
montecarlo .
.
.
.
.
.
.
cache4j .
.
.
.
.
.
.
hedc .
.
.
.
.
.
weblech .
.
.
.
.
.
.
jigsaw .
.
.
.
.
of bugsprograms loc of violations real of exceptions average runtime sec rviolation 242assetfuzzer misses some bugs in the open libraries.
we used the test drivers from the repository and they randomly invoke methods of these subjects and may not exercise all buggy code in the profiling runs.
the hybrid analysis thus cannot infer potential violations in phase i. owning to this a ssetfuzzer misses some bugs in the subjects arraylist hashset treeset and linkedhashset .
for the same reason r acefuzzer misses several bugs in all the open subjects.
being dynamic in nature assetfuzzer cannot detect all atomic set serializability violations in a multithreaded program.
it detects a real violation if the violation can be produced with the given test harness for some thread schedules.
this can be alleviated by combining assetfuzzer with techniques like stateless model checking to explore more thread interleavings.
programs that are free from low g882level data races can contain high g882level data races which do not guarantee two correlated memory locations to be accessed atomically e.g.
the bug in section .
r acefuzzer fails to detect such bugs in the subjects stringbuffer hedc and weblech but these bugs can be detected by a ssetfuzzer because atomic set serializability violations subsume high level data races .
a tomfuzzer also misses these bugs in the subjects hedc and weblech because it cannot find atomicity violating locking patterns in these subjects.
figure .
a high level data race in the jigsaw subject.
even though some high level data races are caused by lowlevel data races a ssetfuzzer provides useful information to diagnose the bugs.
for instance consider a high level data race in the jigsaw subject figure .
the variable raw is a shared buffer and the variable rlen indicates the length of the buffer.
these two variables are correlated but the subject fails to let them be updated atomically.
the bug manifests itself when a thread writes to raw and then another thread overwrites raw and updates the variable rlen yet the first thread sets rlen according to the depleted contents of the original buffer.
in this scenario the correlated variables raw and rlen are not consistent.
although racefuzzer reports that s2 and s4 as well as s3 and s5 are in race conditions separately reporting them may not be useful for developers to effectively diagnose the bug.
on the contrary assetfuzzer directly reports that the program does not guarantee these two variables to be accessed atomically.
.
related work researchers have proposed various techniques to detect data races .
however a large fraction of data races may not reflect real concurrency bugs .
recently lots of research efforts have focused on atomicity serializability violations .
however the underlying criteria of these techniques do not respect correlations between shared variables and thus can cause these techniques to miss detecting bugs or reporting false warnings.
to address this problem vaziri et al.
proposed a new criterion called atomic set serializability.
this criterion characterizes a wider range of concurrency bugs.
not only do data races high level data races and standard serializability violations fall into atomic set serializability violations but violations of access invariants mined from machine learning algorithms can also be captured by the problematic access patterns .
meanwhile this criterion is accurate in discerning real concurrency bugs .
a ssetfuzzer is based on atomic set serializability and is thus more effective and accurate in detecting concurrent bugs.
kidd et al.
proposed to verify atomic set serializability by model checking techniques.
although this approach is able to explore all executions it is not scalable even for medium sized programs .
hammer et al.
proposed a runtime monitoring technique to detect atomic set serializability violations.
however this approach may not be able to effectively detect violations without cautiously controlling thread schedules.
a ssetfuzzer increases the rate of detecting atomic set serializability violations by directing a thread scheduler using information collected from a hybrid analysis.
randomized testing techniques have been proposed for multithreaded programs.
these techniques randomly seed sleep yield and priority primitives in java programs.
however these primitives can only advise a scheduler to make a thread switch but cannot accurately force a thread switch.
our results show that a ssetfuzzer is more effective in detecting atomic set serializability violations than a randomized testing strategy.
active randomized testing has recently been proposed as a promising technique to detect concurrency defects.
r acefuzzer controls a thread scheduler to creat e real data races based on potential race conditions derived by an im precise race detection algorithm .
r acefuzzer cannot detect some atomicity violations that are not caused by data races .
a tomfuzzer is another active testing system that detects a special class of causal atomicity violations characterized by an atomicityviolating locking pattern.
however some atomicity violations such as the one in section do not match the locking pattern.
on the contrary the underlying atomic set serializability criteria of assetfuzzer enable it to detect a wider range of concurrency bugs including malign data races and atomicity violations.
chess utilizes a context bounded search strategy for systematic testing of multithreaded programs.
to apply chess to detecting atomic set serializability violations chess needs to combine with a dynamic detect or which can have high runtime overhead.
ctrigger is a two phase testing tool for detecting atomicity violations that involve one shared variable.
a ssetfuzzer does not have such a restriction.
ctrigger uses heuristics to estimate how long to delay a thread whereas assetfuzzer directly identifies proper switching points for thread manipulation.
.
conclusion we have proposed a ssetfuzzer a two phase testing technique to detect atomic set serializability violations.
a ssetfuzzer uses a hybrid analysis technique to infer potential violations from a concrete execution and controls a randomized thread scheduler to detect real violations.
if atomic sets and units of work are correctly specified a ssetfuzzer gives no false positives because it actually brings out executions that match one of the problematic access patterns in table .
the experimental results on a number of java subjects show that a ssetfuzzer effectively detects more atomic set serializability violations than a runtime monitoring s1 if raw null ... s2 raw updatebytevalue ... s3 rlen raw.length ... s4 raw buf.getbytecopy ... s5 rlen raw.length ...thread g31 thread g32 basicvalue.java httpinteger.
g3java buggy interleaving 243technique running on top of a randomized scheduler.
the results also show that a ssetfuzzer detects more distinct failures and concurrency bugs than two recent active testing tools racefuzzer and a tomfuzzer .
in the future we plan to study how to synergize a ssetfuzzer and stateless model checker e.g.
to increase a ssetfuzzer s ability to detect atomic set serializability violations.
.
acknowledgment we thank the icse reviewers for their insightful and constructive comments.
we thank koushik sen and chang seo park for their help on setting up the jigsaw subject.
we thank chang xu for proofreading a previous version of this paper.
.