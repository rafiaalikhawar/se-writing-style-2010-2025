development of auxiliary functions should you be agile?
an empirical assessment of pair programming and test first programming ot avio augusto lazzarini lemos fabiano cutigi ferrari f abio fagundes silveira and alessandro garcia science and technology department federal university of sao paulo at s. j. dos campos brazil otavio.lemos fsilveira unifesp.br computing department federal university of sao carlos brazil fabiano dc.ufscar.br informatics department pontifical catholic university of rio de janeiro brazil afgarcia inf.puc rio.br abstract a considerable part of software systems is comprised of functions that support the main modules such as array or string manipulation and basic math computation.
these auxiliary functions are usually considered less complex and thus tend to receive less attention from developers.
however failures in these functions might propagate to more critical modules thereby affecting the system s overall reliability.
given the complementary role of auxiliary functions a question that arises is whether agile practices such as pair programming and test first programming can improve their correctness without affecting time to market.
this paper presents an empirical assessment comparing the application of these agile practices with more traditional approaches.
our study comprises independent experiments of pair versus solo programming and test first versus test last programming.
the first study involved novice programmers who applied both traditional and agile approaches in the development of six auxiliary functions within three different domains.
our results suggest that the agile practices might bring benefits in this context.
in particular pair programmers delivered correct implementations much more often and test first programming encouraged the production of larger and higher coverage test sets.
on the downside the main experiment showed that both practices significantly increase total development time.
a replication of the test first experiment with professional developers shows similar results.
keywords pair programming test first programming tdd experimental software engineering agile methods i. i ntroduction auxiliary functions are supportive actions of a software system that comprise lines of code loc .
since these functions are relatively simple they are supposedly less critical with respect to the main development path of a project.
as a consequence they are often assigned to less experienced developers .
despite this these functions tend to be used by important modules of the system and their failures can easily propagate to critical components thereby affecting the application s overall reliability .
there are many examples of failures originated in auxiliary functions causing significant problems throughout the history of software development.
to name a few in the unmanned ariane rocket exploded due to a failure caused by a wrong number conversion located at a supportivefunctionality1 .
more recently in microsoft s zune media player presented a bug that caused thousands of devices to crash worldwide for an entire day .
the fault was located at a loc fragment of a day conversion auxiliary function2 .
apple s iphone and sony s playstation presented similar problems in two auxiliary functions daylight savings time update and leap year detection.
in apple s case several users missed appointments because of incorrect triggering of alarms .
for sony hundreds of thousands of players were unable to use their consoles for many hours .
some studies have recently evaluated the application of agile practices within different contexts and with respect to a number of variables e.g.
.
however none of them have concentrated on auxiliary functionality.
according to a recent investigation system complexity and by extrapolation its functions complexity is one of the not yet well studied factors that seem to impinge on the effectiveness of pair programming .
in fact the same study stresses that subsequent investigations should tackle such an aspect .
this also holds for other practices such astest first programming i.e.
developing test cases prior to and to drive the implementation of functional code .
considering the characteristics of auxiliary functions an important question to be investigated is whether applying agile practices during their implementation can improve the system s reliability without affecting time to market.
pair programming demands allcode written within a project to be developed by two people working together at a single computer and test first programming is suggested to be applied to every new piece of code .
therefore a developer may wonder whether or not to resort to these practices in the development of auxiliary functions.
to obtain evidence about this question we have conducted two independent experiments one to compare pair with solo programming and the other to compare test first with 1in fact the function was not useful for ariane but for earlier versions and was only maintained for commonality reasons .
2the function splits total days into year month and day.
its source code can be found at .
c circlecopyrt2012 ieee icse zurich switzerland 529test last programming.
the experiments considered reliability and effort factors and involved novice programmers and six auxiliary functions within three domains namely array manipulation basic mathematics and string manipulation .
the novice programmers conservatively represent theless experienced developers who are natural candidates to develop supportive functionality .
we also intentionally selected narrowly scoped functionality to conservatively represent auxiliary functions.
to evaluate the reliability of the implemented functions the subjects implementations were executed on systematically developed test sets and to evaluate the effort required to implement functions for each subject we recorded the time taken to complete tasks.
as a complementary reliability measurement we evaluated the size and coverage of the test sets produced in the test first experiment.
moreover this experiment was replicated with professionals in order to obtain more practical evidence.
our goal was also to understand how the programmers experience would impact the results.
we focused the replication on the test first experiment because previous investigations indicate that less experienced programmers tend to benefit more from pair programming .
results show that while developing auxiliary functions both agile practices might bring benefits to developers.
for instance compared with solo programmers more than twice more pair programmers delivered correct implementations and test first programming caused the implementation of larger and higher coverage test sets.
on the other hand both agile practices seem to impact negatively on effort in this context.
the test first experiment replication with professionals shows similar results.
this evidence shows that taken the right cautionary measures the agile practices seem to be a valuable option in the development of auxiliary functionality.
the remainder of this paper is structured as follows.
section ii presents fundamental concepts about software testing and the target agile practices and section iii presents how our study was set up in terms of subjects experimental design metrics and statistical procedures.
section iv presents the results and analysis of our experiments.
in the sequence section v presents our study limitations and section vi summarizes some related research.
finally section vii concludes the paper.
ii.
b ackground a. software testing and testing techniques for the purposes of this paper a test case is a set of inputs execution conditions and expected output for a program .
the expected output is evaluated based on an oracle which determines the correct result of the program given an input .
in our case the oracle is a tester supported by junit3assertions.
a test case can be more formally defined as an ordered tuple i1 ... in eo 2011whereeo is the expected output of the program when i1 ... inis used as the set of inputs.
to evaluate the implementations produced in an experiment a software testing technique can be applied.
software testing can be defined as the execution of a program against test cases with the intent of revealing faults .
the different testing techniques are defined based on the artifact used to derive test cases.
functional or black box testing derives test cases from the specification or description of a program.
in this paper we use functional testing as the basis to construct test cases to evaluate the correctness of the implemented programs in the experiments.
two of the most well known functional based testing selection criteria areequivalence partitioning and boundary value analysis .
equivalence partitioning divides the input domain of a program into a finite number of valid and invalid input equivalence classes .
it is then assumed that a test case with a representative value within a given class is equivalent to testing any other value in the same class.
this criterion requires a minimum number of test cases to cover the valid classes and an individual test case to cover each invalid class.
boundary value analysis complements equivalence partitioning by requiring test cases to cover values at the boundaries of equivalence classes .
structural or white box testing is a technique that complements functional testing.
it derives test cases from the internal representation of a program .
some of the well known structural testing criteria are statement branch ordefinition use coverage which require that all commands decisions or pairs of assignment and use locations of a variable be covered by test cases.
in this paper we use the basic statement coverage to evaluate test sets produced while applying test last and test first programming.
the coverage of of statements of a program is considered to be a minimum requirement for adequate test sets.
b. pair programming and test first programming agile development methods have been around since the late 1990s .
extreme programming xp scrum and feature driven development are some examples of methods that call themselves agile .
xp one of the most popular agile methods focuses on developmental practices.
pair programming is one of the core practices of xp and requires that all code developed within a project be created by two people working together at a single computer.
pair programming allegedly increases software quality without impacting time to deliver .
another popular agile development technique is test driven development tdd .
tdd guides programmers to write test cases before production code.
with respect to tdd the practice of writing the tests before production code is our focus in this paper referred to astest first from now on .
it is important to note that test first does not require the use of any testing technique test cases are developed only to drive the implementation.
however a consequence of this practice is ensuring that the source code 530is thoroughly unit tested .
the reference technique to be compared to test first in this paper is the more conventional practice of writing the tests after production code referred to as test last from now on .
iii.
s tudy setup our goal is to investigate the impact of using agile practices against traditional practices to develop auxiliary functions.
we evaluate such practices in terms of reliability and effort factors.
in this endeavor we are interested in the following research questions reliability related .in the development of auxiliary functions r1.
can pair programming help obtain more correct implementations than solo programming?
r2.
can test first programming help obtain more correct implementations than test last programming?
r3.
does test first programming encourage the implementation of more test cases than test last programming?
r4.
do test cases produced by test first programmers attain higher coverage than the ones produced by test last programmers?
effort related .in the development of auxiliary functions r5.
do pair programmers spend more time than solo programmers?
r6.
do test first programmers spend more time than test last programmers?
note that r4 complements r3 because larger test sets do not necessarily imply higher coverage test sets i.e.
there can be redundant tests .
our investigation develops in terms of six hypotheses derived from these research questions.
the null and alternative a definitions of each hypothesis are described in table i. note that we have one hypothesis for each research question hypothesis h iis related to research question r i. table i hypotheses formulated for our experiments .
null hypothesis alternative hypothesis a h1correctness pp correctness sp correctness pp correctness sp h2correctness tf correctness tl correctness tf correctness tl h3 testsize tf testsize tl testsize tf testsize tl h4testcoverage tf testcoverage tltestcoverage tf testcoverage tl h5 effort pp effort sp effort pp effort sp h6 effort tf effort tl effort tf effort tl legend h hypothesis sp solo programming pp pair programming tf test first tl test last a. subjects target functions test sets and tools subjects.
the main study involved computer science undergraduates.
were in the second semester of the program and were in the sixth.
the second semester students were invited to perform the pair programming experiment while the sixth semester students were invited to perform the test first experiment.
the choice was motivated by the fact that auxiliary functions tend to be natural candidates tobe assigned to less experienced developers .
moreover a meta analysis of several pair programming experiments indicates that junior programmers tend to benefit more from the agile practice in terms of increased correctness .
with respect to the test first experiment more knowledge about software engineering and software testing was required and these skills are typically acquired at later stages of a computer science degree program.
in our case the sixth semester students had a fair amount of knowledge of agile practices software testing and software development.
such knowledge was acquired during the software engineering and software testing courses.
the second semester students received basic training in pair programming that comprised a minutes module given during an object oriented programming course.
the sixth semester students received advanced training in test first that comprised two junit tdd modules of around minutes each and several exercises.
these exercises comprised programming tasks in which students should drive implementations with test cases.
it is also important to note that the sixth semester students had good knowledge about software testing techniques.
since the second semester students did not have knowledge about software testing the pair programming experiment did not take into account the testing approach.
also for the test first experiment only solo programming was applied.
therefore it should be clear that the experiments and analysis reported here were independent i.e.
they do not take into account the compound effect of pair programming and test first programming.
we also invited professionals that were taking a course on advanced software engineering topics to participate in a replication of the test first experiment.
a tally of subjects completed all assigned tasks and were considered in the replication.
the sample included professionals in different programming and agile development levels professionals had years of experience with java development whereas the other had basic java programming skills professionals had years of experience in agile development in general professionals had experience with pair programming whereas the other had basic knowledge about agile development.
the professionals were working for companies developing software in different domains including financial military and health systems.
target functions.
to select representative functions for our study functions that fall into the category of auxiliary functions as commented in section i we looked into the apache commons project which provides libraries of reusable java components4.
we also selected functionality that could easily be found through searches issued to google code search that is we tried to identify commonly used auxiliary functions that were not readily available in the java api.
we categorized these functions into three domains array manipulation array basic mathematics math and string manipulation string .
to obtain a richer set we selected two functionalities within each domain.
the auxiliary functions used in our study are listed in table ii.
another characteristic of our functions is that they are intentionally narrowly scoped.
the idea here is to perform a conservative evaluation if a practice can impact on the development of simpler auxiliary functions we can expect them to impact on more complex ones.
with respect to size and scope the selected functions are similar to the day conversion function that presented a fault in microsoft s zune media player5 .
another advantage is that this type of function enables the application of more systematic test case selection techniques such as functional testing.
test sets.
to evaluate the programs implemented by the subjects we developed a full functional test set for each of the selected functions.
the last column of table ii shows the number of test cases developed for each.
to construct the test sets we applied the equivalence partitioning and boundary value analysis criteria.
these criteria were used to select representative test cases for each test set trying to cover as many functional specificities of the functions as possible.
to show an example of how test cases were developed table iii presents the equivalence classes and boundary values when applicable for the a1functionality.
ar1andar2are the a1input arrays ar represents the array size and arx represents an element of the array.
int.min and int.max correspond to the minimum and maximum integer values.
since the study was conducted using the java language the highest and lowest possible integers were used as boundary values for that data type.
a similar rule was applied to other types for other functions.
here we do not use the specific values to represent the test cases independently of language.
tools.
eclipse6was the ide used to develop functions and junit was the framework used to develop test cases.
the students received some instructions in order to make sure they would concentrate their effort only on realizing the intended auxiliary functionality using the assigned techniques.
for instance the students were instructed to implement functions as static methods in a class with a predefined name.
we did this because static methods are easier to implement since they do not require object instantiation.
moreover auxiliary functions usually rely only on parameter values to fulfill their responsibility.
to evaluate the coverage attained by the developed test sets we used the cobertura tool7.
b. experimental design and procedure for the conducted experiments we adopted the repeated measures with cross over experimental design where each subject implemented functions using both traditional and 5we mention this function because its source code is available online.
however one can expect that the other functions mentioned in section i are also similar in size.
for instance a leap year detection function such as playstation s does not require more than a few lines of code to be implemented.
2011agile techniques.
such type of design supports more control to the variability among subjects .
to minimize the variability of the difference among functions and approaches we randomized the assignments among students.
finally to cancel function asymmetry each function was assigned to be implemented using both the traditional and agile approaches.
all experiments were conducted in two sessions.
in the first session part of the students applied the traditional approaches solo or test last programming and the other part applied the agile practices pair or test first programming and in the second session they switched.
this was done to cancel order effects e.g.
it might be that applying first solo programming and second pair programming could benefit one of the approaches similarly for the test first experiment.
moreover students had to implement functions from different domains in the first and second sessions.
for instance a student implementing a 1in the first session would implement a math or string function in the second session.
this also applies for the pair programming experiment.
we did this to cancel the impact of function domains on each other while implementing the functionalities in the first and second sessions.
to help understanding the adopted experimental design table iv present part of the assignments used for the pair programming and test first programming experiments.
note that the subjects are not the same for the two experiments we only maintained the first column to save space.
the same procedures were applied for the test first experiment with professionals.
c. metrics we adopted metrics to evaluate the reliability of the developed functions and the effort of the subjects while each approach was being applied.
reliability measurement.
one of the metrics we adopted to measure reliability in our experiments was the correctness in terms of the functional test set success level ftssl .
ftssl grades implemented functions in accordance with a scale composed of three values incorrect all test cases fail .
neither correct nor incorrect some test case fail but not all and correct all test cases pass .
we adopt such scale because in our context a failure is very significant since we are using functional test sets each test case covers an important part of the functionality.
in this way we are more interested in functions that do not fail at all but we also want to look out for functions that are completely incorrect.
functions that fail one or more test cases but not all receive a middle score since they can not be classified as correct but at least implement correctly some part of the functionality.
we then assign the highest score only to functions that pass all test cases.
the ftssl is an ordinal variable since there is a natural ordering among the values having all test cases passing is better than having less test cases passing which in turn is better than having all test cases failing .
a similar scale was adopted by canfora et al.
in a pair designing experiment.
532table ii auxiliary functions used in the experiment .
domain f description sample test case test casesarraya1array equality given two arrays the program should return true true 20orfalse according to the contents of the arrays being equal or not.
a2first index with different value given an array and a number the program should return the first index of the array that contains a value different from the number.mathm1power of two given a number the program should return true true 6orfalse according to it being or not a power of two.
m2 factorial given a number the program should return its factorial.
7strings1capitalization of phrases given a string the program should one two one two 7return the same string with the first letters of words capitalized.
s2maximum common prefix given two strings the program should pref suf pref fus pref 11return the maximum common prefix between them.
legend f function table iii equivalence classes and boundary values considered for testing array equality a1 .
input cond.
valid classes invalid classes boundary values ar1 ar1 c1 ar1 b1 ar1 is null no c2 yes c3 ar2 ar2 c4 ar2 b2 ar2 is null no c5 yes c6 ar1 ar2 ar1 ar2 c7 a1 a2 b3 ar2 ar1 c8 a2 a1 b4 ar1 int.min ar1 int.max c9 ar1 int.min b5 ar1 int.max b6 ar2 int.min ar2 int.max c10 ar2 int.min b7 ar2 int.max b8 table iv partial task assignments to subjects .
spair programming exp.
test first exp.
1stsession 2ndsession 1stsession 2ndsession a f a f a f a f solo s 1pair a 1test first a test last s solo s test first a test last s 3pair a1solo s test last a test first s solo m test last a test first s ... ... ... ... ... legend s subject a approach f function as an additional reliability measure we evaluate the test sets developed while using test last and test first programming.
the two metrics we adopted were size and coverage .
the size is calculated as the number of test cases contained in the test set.
for code coverage we adopted the well known statement coverage criterion which requires every statement in the code to be executed by at least one test case.
effort measurement.
the effort metric adopted in our experiment was the total development time tdt which is defined as the total number of programmers minutes taken to develop a given function.
thus such as in arisholm et al.
sinvestigation in the pair programming experiment the effort was equal to the duration for the individuals and twice the duration for the pair programmers.
this is a common measure that was also used in other studies .
d. statistical analysis from a statistical standpoint a simple observation of the means or medians from sample observations is not enough to infer about the actual populations.
this happens because the reached differences might be a coincidence caused by random sampling.
to check whether the observed differences are in fact significant statistical hypothesis tests can be applied.
in our study each subject applied each approach separately to develop the functions.
in this case the paired statistical hypothesis tests compare measures within subjects rather than across them.
paired tests are considered to greatly improve precision when compared to unpaired tests .
before choosing the more adequate test to be applied we must verify the normality of our observations.
a shapiro wilk test indicated that most of the continuous data observations in our experiments did not follow a normal distribution.
therefore considering that we are also dealing 533table vi results of the main test first experiment .
subj.ftssl tdt cov tcsubj.ftssl tdt cov tcsubj.ftssl tdt cov tc tl tf tl tf tl tf tl tf tl tf tl tf tl tf tl tf tl tf tl tf tl tf tl tf n n n n n n n n n i n n n n n n n c n n n n c n n n n n n n n n n n n n n n n n n n n n c n n n n n n n n i n c n n n n c c n n n n n n c c i n i n n n c n mean considering all subjects .
.
.
.
table v results of the pair programming experiment .
subj.ftssl tdtsubj.ftssl tdtsubj.ftssl tdt sp pp sp pp sp pp sp pp sp pp sp pp n n nc13 cn n n n n n n n n n n nc in10 cn20 n n n n n n n n n n nc13 nc n n n n n n in5 n n n n n n n n n n n n n n n n n n nc22 n n ic23 n n cn n n n n n n n n n n n n n n nc33 nc30 n n mean time considering all subjects .
.
with ordinal data in some cases we decided to apply the wilcoxon mann whitney non parametric signed rank paired test which does not assume normal distributions .
for statistical significance we adopted the traditional confidence level of thus our analyses consider p values below .
significant.
for all statistical tests we used the r language and environment8.
iv.
r esults and analysis tables v and vi present the results of our experiments with novice programmers and tables vii and viii present the statistics for the pair programming and test first experiments with respect to correctness.
these last tables show the compared outcomes of subjects while using the 11traditional and agile approaches.
for instance the cell in row sp i column pp i of table vii contains the number of subjects that produced an incorrect function while using solo programming and another incorrect function while using pair programming.
the frequency columns and rows show the number of implementations produced at each functional test set success level i n or c for each approach.
for instance the cell in row freq.
column pp i of table vii shows that a total of pair programmers produced incorrect functions in the experiment.
with respect to the test first experiment replication with professionals table ix shows the results.
table vii correctness statistics for the pair programming experiment .
pp i n c freq.
spi .
n c .
freq.
table viii correctness statistics for the test first experiment .
tf i n c freq.
tli n c freq.
a. reliability evaluation for the pair programming experiment with respect to correctness soloists implemented functions that were completely correct and that were incorrect .
.
on the other hand pair programmers implemented functions that were correct more than twice as more as solo programmers and incorrect ones.
the remainder 534table ix results of the test first experiment with professionals .
subj.tdt ftssl cov tc tl tf tl tf tl tf tl tf n n n n i n n n n n n n n n mean .
.
.
implementations failed on at least one test case but not all.
we believe this happened mainly because few students implemented functions that handled exceptional inputs such asnullobjects.
since our test cases also covered such inputs most implementations failed on at least one of them.
to check whether the observed difference in terms of correctness was significant we ran the wilcoxon test which indicated a statistically significant difference at confidence level df p value .
.
such result favors thealternative hypothesis h1 a that pair programming outperforms solo programming with respect to the correctness of auxiliary functions.
we believe this is a key finding since even for supportive functionality it appears that pair programming can bring benefits to developers.
moreover the higher number of completely correct implementations for pair programmers shows that they tend to be more careful while implementing auxiliary functions taking into account exceptional inputs that were included in the test sets.
because we are considering reliability as the system s quality driver a failing test case in our scenario is very critical.
this is particularly true for our experimental setting since we applied functional testing each test covers an important part of the functionality i.e.
either an input or output equivalence class or a boundary value therefore a failing test case impacts significantly on the correctness of the system.
in this sense our results indicate that the application of pair programming could even prevent problems like the ones reported by major companies discussed in section i. with regard to the test first main experiment note that both approaches performed almost exactly equally with respect to correctness.
the only difference was that test last programmers delivered an additional correct implementation comparing to test first programmers.
at confidence level the wilcoxon test did not indicate a statistically significant difference df p value .
.
this result favors the null hypothesis h2 that test last and test first programming impact similarly on the correctness of auxiliary functionality.
such evidence indicates that developers should be cautious here.
even though test first motivated subjects to come up with more and higher coverage test sets as will be discussed in hypothesis h5 and h6 functional correctness was not significantly influenced bythis agile practice.
other studies have reported that even though test first might increase development time it also generally increases correctness .
the development of auxiliary functions with lower complexity might also have impacted this time.
it might be the case that since developers perceive functions as easy to be implemented they tend to overlook their subtleties.
this problem however occurred less in the context of pair programming as one of the developers might be more careful than the other about such nuances.
it must also be noted that test first programming does not prescribe any testing technique or criterion to be followed and even though the programmers already had knowledge about functional testing and other testing techniques they might have developed test cases only to drive the implementation.
also note that other properties of the implemented functions were not analyzed e.g.
design quality factors which are sometimes pointed out to be enhanced by test driven development .
it should also be noted that our results are conservative in the sense that the functions selected for our experiments are narrowly scoped.
test first programming might be more effective for more complex functionality.
test set size and coverage.
with respect to the size of the produced test sets note that the means are higher for test first programming.
at confidence level the statistical test shows a significant difference df p value .
.
such result favors the alternative hypothesis h3 a that test first outperforms test last programming with respect to test set size.
it is interesting to mention that the difference continues to be significant even when we remove results from test last programmers that did not develop any test cases test last mean test set size .
test first mean test set size .
wilcoxon test p value .
.
this is an important result in favor of the agile approach since it encouraged the implementation of more test cases than test last programming.
the fact that some test last programmers did not test their implementations can be seen as a negative effect of that approach.
in fact beck even affirms that any program feature without an automated test simply does not exist .
in the long run the mindset of having to develop at least a minimum set of test cases might compensate the extra effort required to develop them even when there are no directly observable improvements on correctness.
the absence of regression tests for some functions for instance can break the confidence feel targeted by tdd.
this promoted safety net helps alleviating the fear that added code might have broken other parts of the system and can also improve its reliability.
our results are also consistent with the argument of test first promoters that if you leave the task of testing programs to the end of the developmental cycle you might end up not testing them at all.
it is interesting to see that this can also hold for the development of auxiliary functions such as the ones selected for our experiments.
with respect to test coverage note that the agile approach outperformed the traditional approach covering more 535statements.
the statistical test shows a significant difference at confidence level df p value .
.
such result favors the alternative hypothesis h4 a that test first outperforms test last programming with respect to test set coverage.
note that even though the test sets produced with test first programming were significantly larger and attained better coverage they did not seem to impact directly on the correctness of functions i.e.
test last and test first programming performed similarly with respect to that factor .
however having larger and higher coverage test sets might be beneficial for other reasons.
for instance in regression testing better test sets can improve the chance of finding faults at the integration of auxiliary functions with other parts of the system when these parts are changed later in a project.
lower coverage test sets can fail to reveal the introduced faults because the paths in the program that could be sensitized by the changes might not be executed.
b. effort evaluation with respect to effort note that the mean total development time for pair programming was higher than for solo programming.
one of the reasons that might explain such outcome is that subjects were novice programmers and target functionalities were narrowly scoped.
it might be the case that pair programming starts to be more productive after some development time improved for instance by pair jelling .
since the target functions required little time to develop subjects might not have had time to take advantage from the technique from an effort perspective.
for these outcomes at confidence level the wilcoxon test confirms a statistically significant difference between the means df p value .
.
such result favors thealternative hypothesis h5 a that solo programming outperforms pair programming with respect to effort.
some of the previous pair programming investigations reached different conclusions with pairs developing sometimes faster than solo programmers.
in williams et al.
s experiment however only programmers with long standing industry experience were included and not novice programmers.
canfora et al.
s experiment on the other hand addressed pair designing and maintenance tasks of models such as use cases and class diagrams and not programming.
these differences and more importantly the fact that we targeted narrowly scoped functionality might explain the results reached in our experiment.
for the test first experiment the mean value for the total development time while using test first programming was higher than for the test last approach.
at confidence level the wilcoxon test again showed a statistically significant difference df p value .
.
such result favors the alternative hypothesis h6 that test last outperforms test first programming with respect to effort.
our conclusion is similar to other studies that have also reported that test first programming seems to impactnegatively on effort .
this is probably due to the additional effort of having to develop test cases first.
we noticed that even though we encouraged subjects to test their implementations while using the test last approach many did not develop any test cases.
in fact when we remove their results from the data set the difference between the means becomes non significant test last mean development time .
test first mean development time .
wilcoxon test p value .
.
since test first programming requires developers to drive the implementation with tests differently from test last programming all subjects developed test cases while applying that approach.
as discussed earlier this advantage might compensate the extra effort observed.
c. test first experiment replication and further discussions for the replication with professionals since the sample was small we do not present statistical tests but only analyze the outcomes descriptively.
note that with respect to correctness the approaches again performed similarly.
however the sensible difference at this time is that only a test last programmer produced an incorrect function while no test first programmers produced such outcome.
with respect to effort the approaches also performed very similarly with test last programmers taking on average only additional minutes to complete their tasks.
in terms of test set completeness test first programmers performed slightly better both with respect to size and coverage.
these results are consistent with all outcomes produced by the novice programmers so we believe they reinforce the evidence for the favored hypotheses in the main experiment.
it should be clear that our experiments take into account two main factors while developing software reliability in terms of functional correctness and test set size and coverage and effort in terms of total development time.
the agile practices might also impact positively on other aspects such as quality in terms of design metrics knowledge dissemination and programmer satisfaction .
this should also be taken into account while considering the application of pair programming and test first programming to develop auxiliary functionality.
one might argue that the functions targeted in our experiments could be reused from libraries such as apache commons see section iii instead of being developed from scratch.
we agree that this is a feasible solution when auxiliary functions come up in a given project.
however there are some auxiliary functions that are harder to be adapted to a specific context.
these should not be easily found in general purpose code libraries or adapted from them and so reuse would not be an option.
moreover it is clear that a function like sony s playstation leap year detection discussed in section i for instance could also be found at some general purpose code library but sony decided to develop it themselves.
this is an evidence that the situation simulated in our experiment is not unrealistic.
536for pair programming a point for further investigation is whether pairing novice and experienced programmers would yield better results in our context.
in the case of auxiliary functionality the different backgrounds might help to better address the involved nuances.
for instance novice programmers might help softening the impact of programming vices presented by experienced programmers and experienced programmers might help overcoming skill deficiencies presented by novice programmers.
since pair programming seems to impact positively in the correctness of auxiliary functions and test first programming on the test set quality the use of both practices in conjunction might be a good choice in this context.
moreover our results also indicate that it might be interesting to apply some formal testing technique along with test first programming.
since the agile practice appears to produce larger and higher coverage test sets that do not impact directly on the correctness of functions a testing technique such as functional testing might be of help in this case.
v. s tudy limitations this section discusses the study limitations based on three categories of threats to validity described by wohlin et al.
.
each category includes several possible threats for an experimental study.
for each category we list all possible threats measures taken to reduce each risk and suggestions for improvements in future evaluations.
a. internal validity an internal validity threat that may have affected our experiments was the lack of control of the following variables the subjects skill other than all being in the same semester of the course and how the pairings took place they were simply randomized .
with respect to the repeated measures design decreases the probability of this threat affecting our outcomes because the same students played the roles of solo and pair programmers and performed both test last and test first.
threat has possibly affected the pair programming experiment.
in regard to it we believe the sample size which was not small subjects performing solo and pair programming reduces the extent of this threat s effect i.e.
different types of pairings with respect to skill might have occurred .
in this case we followed the rule of thumb block what you can randomize what you cannot since if we were to block pairs by skill we might not have had sufficient subjects.
in any case for future evaluations we suggest that pairings should be blocked with respect to skill such as in a recent study by arisholm et al.
to cancel this threat even though this might require larger samples .
another internal validity aspect to be considered in our experiments is the mortality .
since we had students invited to participate in the main experiments in the beginning the actual tasks that took place did not follow the initial assignments.
this could affect the balance of the assignments that was taken care in the experiment design.however since in both experiments we had a considerable sample size pair programming experiment test first experiment we believe an adequate balance could still be maintained.
this is reinforced by the fact that to help in the event of some drop outs the initial assignment set contained some redundancies.
b. external validity a characteristic of our experiment that might reduce its external validity is the use of students as subjects for the larger experiments.
in fact some studies have shown opposite trends for students and professionals e.g.
arisholm and sjoberg .
however according to other authors students can play an important role in experimentation in the field of software engineering specially for an initial evaluation like ours .
for instance canfora et al.
have conducted a pair programming experiment in academia and replicated the same experiment in industry.
according to the authors the experiments produced similar results from both samples.
since the experiment evaluated aspects of agile practices similar to ours we believe our results might also be generalizable in that sense.
in any case to minimize the influence of such nuisance factor we also replicated the test first experiment with a sample of professionals which provided results similar to the main experiment.
another threat to the external validity of our experiments is the representativeness of the selected functions.
one might argue that the functionalities do not represent the population of auxiliary functions due to their lack of complexity.
however as commented earlier it was our intention to select narrow scoped functionality to conduct a conservative evaluation.
since in some cases the agile practices did impact on the development of the selected functions we can expect them to impact on more complex ones as well.
in any case conducting more experiments using larger auxiliary functions is one way to further reduce this threat.
in the future we plan to replicate our experiments with more complex auxiliary functionality present in open source systems.
c. construct validity a characteristic of our pair programming experiment that might have affected its construct validity is that students had little or no previous experience with pair programming and in most cases had not programmed with their partners before.
therefore similarly to arisholm et al.
s study our results might be conservative with respect to the effects of pair programming.
subsequent experiments should consider programmers that have more experience with this development approach.
moreover it should be noted that we analyzed the agile practices separately that is we do not study the compound effect of pair programming and test first programming.
vi.
r elated work in a recent work hannay et al.
carried out a meta analysis of the effectiveness of pair programming when 537compared to solo programming.
all selected primary studies presented quantitative data regarding at least one of the three measures quality and reliability mostly in terms of correctness duration and effort.
the subjects could be either students or professional software developers.
in total studies were selected to compose the dataset to which a series of statistical procedures was applied.
the results indicate that pair programming i slightly outperforms solo programming with respect to quality ii has a medium positive overall effect regarding duration and iii has a medium negative overall effect on effort.
some other interesting observations made by hannay et al.
regard the expertise of the subjects involved in the selected studies.
considering junior intermediate and senior pairs the most noticeable gains and losses compared to individual subjects are gain increase in quality and loss increase in effort for junior pairs gain decrease in duration and loss increase in effort for intermediate pair and loss increase in effort and surprisingly no overall gains for senior pairs.
salleh et al.
presents the results of another systematic literature review concerning pair programming effectiveness.
differently from hannay et al.
salleh et al.
analyzed compatibility factors e.g.
the feel good personality and skill level factors and their effect on pair programming effectiveness as a pedagogical tool in computer science and software engineering education.
four measures were analyzed academic performance technical productivity program design quality and learning satisfaction.
the general findings of salleh et al.
are that when compared to solo programming pair programming is more effective in terms of technical productivity learning satisfaction and academic performance while no significant differences were found in regard to program design quality.
studies that applied internal and external quality metrics revealed a slight positive effect of pair programming over solo programming.
desai et al.
investigated tdd experiments in the academic environment.
in general they observed that when the control group in a controlled experiment used iterative test last programming i.e.
continuous testing no significant differences were noticed regarding the quality of the produced software.
however when all code was written before the tests started to be implemented test first programming outperformed the test last approach in terms of fault counts reduction between and .
slight gains in productivity in favor of test first were also reported in the analyzed studies.
to the best of our knowledge the study presented in this paper is the first that evaluates agile practices in the development of auxiliary functions.
moreover compared to other similar studies ours is the first to apply the repeated measures with cross over experimental design.
most investigations make use of two group experimental designs where a control group applies for instance a traditional approach and a treatment group applies the agile approach.
this kind of design is less powerful than repeated measures becausecomparisons are made across and not within subjects.
with repeated measures extraneous error variance is reduced because each subject serves as his her own control .
our study is also one of the few that applies systematic test case design to evaluate the correctness of implementations produced by the subjects.
most studies use test cases developed in an ad hoc manner which might introduce bias to the analysis.
with respect to the achieved results previous evidence regarding the effectiveness of pair programming and test first is generally contradictory.
the aforementioned surveys show that varied scenarios lead to different effectiveness measures sometimes favoring the agile practices sometimes not.
our results show that to implement auxiliary functionality both agile practices required substantial increase in the development effort but offered a counterpart in terms of significant correctness improvement and larger and higher coverage test sets.
vii.
c onclusions recent studies have reported on evaluations of pair programming and test first programming with respect to a number of characteristics .
however none of them have tackled the development of auxiliary functionality with respect to the correctness gain and impact on time to market.
our study investigated the following factors reliability in terms of functional correctness and test set size and coverage and effort in terms of total development time.
results show that pair programming tends to increase reliability in terms of correctness while test first programming tends to increase reliability in terms of test set size and coverage.
our study also shows that the agile practices seem to impact negatively on effort.
the replication of the test first experiment with professionals shows similar results.
we believe these results may aid developers in choosing among practices while implementing auxiliary functionality and considering their impact on the overall reliability of the system.
in particular pair programming seems to be effective in improving the system s correctness.
even though it seems to impact negatively on effort the benefit might compensate in the end.
as shown by recent events involving companies such as microsoft and apple see section i problems in auxiliary functions can bring damages to the rest of the system affecting users lives.