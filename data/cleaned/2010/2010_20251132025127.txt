the onion patch migration in open source ecosystems corey jergensen anita sarma computer science and engineering department university of nebraska lincoln lincoln ne usa cjergens asarma cse.unl.edu patrick wagstrom ibm tj watson research center skyline drive hawthorne ny usa pwagstro us.ibm.com abstract past research established that individuals joining an open source community typically follow a socialization process called the onion model newcomers join a project by first contributing at the periphery through mailing list discussions and bug trackers and as they develop skill and reputation within the community they advance to central roles of contributing code and making design decisions .
however the modern open source landscape has fewer projects that operate independently and many projects under the umbrella of software ecosystems that bring together projects with common underlying components technology and social norms.
participant s in such an ecosystems may be able to utilize a significant amount of transferrable knowledge when moving between projects in the ecosystem and thereby skip steps in the onion m odel.
in this paper we examine whether the onion model of joining and progressing in a standalone open source project still holds true in large project ecosystems and how the model might change in such settings .
categories and subject descriptors d. .
management programming teams d. .
metrics process metrics general terms human factors management and measurement.
keywords open source software project ecosystem contribution model.
.
introduction open source projects have been widely studied by researchers in the fields of software engineering computer supported cooper ative work and management .
research has included studies of motivational factors that drive volunteers to contribute time and code towards the common public good the socializ ation process through which newcomers become active community members the sustainability of open source projects given their high rates of turnover and barriers to contribution and the underlying social organizations in open source projects .
one of the overarching attributes of open source i s that it draws expertise and contributions from a pool of volunteers.
because these volunteers often exhibit high turnover rates there is a need to understand how projects continue to recruit educate and s ocialize volunteers to maintain vibrancy .
the past chara c terization of the development or socialization process maintains that new comers start at the periphery with low technical skill requirements for example b y posting to project mailing lists or participating in project chat rooms.
as the skills and experience of the user evolves they may choose to report bugs which requires a small amount of technical skill.
through their contributions users continue to build their reputation in the community and some may migrate toward more technical and central roles such as code co ntribution and moderation.
this model called the onion model depicts roles as concentric layers with high skill high reputation roles at the center and low technical skill and reputation at the periphery .
variations on the model have been qualit atively and empirically validated in a number of projects e.g.
apache freenet netscape mozilla python and others .
these studies form the foundation of our understanding of open source software.
the existing characterization of open source projects is based on studies of large individual projects.
however these char acterizations may be somewhat outdated in light of recent changes.
many modern open source projects strongly resemble large enterprise products that comprise numerous smaller related projects engage individuals as wells as corpor ations and involve contr ibutions from volunteers as well as paid members .
this new genre of open source termed oss .
by fitzgerald is significantly different from its standalone individual antecedents.
earlier lessons and insights about open source projects might not hold true i n this new collaborative lan dscape populated by complex software ecosystems and fur ther studies to characterize this emergent oss .
phenomenon are required .
for example the eclipse foundation which has its roots in the eclipse integrated development environment ide which was released as open source by ibm has expanded to encompass a wide variety of end user tools based on a common set of technologies beyond just the ide experience and include tools f or developing complex web applications on the client and server version control tools and identity management.
the fou ndation has numerous and significant contributions from some of the largest players in technology including ibm intel and oracle in addition to substantial participation from volunteers and unive rsity students .
open source ecosystems may have a variety of different focuses such as gnome and kdes efforts to create desktop environments developer tools and web infrastructure from apache and support for open source programming languages among others.
while past studies provided insight into how open source communities function most do not address the interconnected nature of modern oss .
style ecosystems.
since projects in an ecosy stem share underlying technical infrastructure and often follow similar social norms members can participate in multiple projects or move across projects in an ecosystem with relative ease.
the socialization process of the onion model may not hold true if d evelopers can easily move from one project to another and utilize permis sion to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.
much of their knowledge and reputation from elsewhere in the ecosystem.
this leads to our first research question rq1 to what extent do members migrate across projects in software project ecosystems ?
when a developer joins a project from elsewhere in the ecosy stem rather than starting the socialization and technical knowledge acquisition process from scratch it is likely that some of their reputation and technical skill will allow the developer to bypass portions of the basic socialization process.
the manifestation of this knowledge transfer process however is unknown.
does e xisting knowledge allow a developer to bypass the socializations process or merely compress the duration?
this gives rise to our second research question rq2 when members migrate across project s can they use know ledge common across projects to jumpstart their contribution to a new project ?
finally previous research has suggested that experience and te nure in an individual project is a driving force in moving develo pers toward the center or core of a project .
this is pred icated on developers taking time to learn the code and build up reputation in the community.
however developers in an oss .
ecosystem are not only able to transfer general process info rmation and reputation from one project to another but may be able to reuse their technical expertise in shared code components or s ocial expertise in enhancing a particular area.
this can improve their ability to directly contribute to the core of a proj ect.
in such an environment where developers can fluidly move from one project to another related project it is not known whether exper ience and tenure within a project are the primary factors affecting the centrality of contributions or if other factors overshadow these.
this brings us to our third research question rq3 in an interconnected software ecosystem what factors affect the contribution type and quality?
we answer these questions through a longitudinal analysis of a selection of projects in th e gnome ecosystem.
t hese are stable and mature open source projects that have attracted significant contributions from volunteer and commercial developers.
these projects provide a rich data source because they all have between six to ten years of project archival history.
the projects also have a significant overlap of developers that is there are many developers who have contributed to multiple projects in the period of our study .
for each of these projects we analyzed mail messages from project mailin g lists comments and actions from the project bug trackers and code contributions made through the project version control systems.
we further refined contributions through the version control system into source code contributions and other types of cont ributions such as translation documentation and media.
this allows a further differentiation of project me mbers and a more robust analysis of developer progression paths and the centrality of developer contributions.
we find that within our sample there is a significant population that is active on multiple projects within the ecosystem.
based on an analysis of patterns that developers follow in joining individual projects and when participating in the entire ecosystem we find that there is little evidence of individuals following the pure onion model.
rather we identify multiple patterns that are contradictory to the model or otherwise compress the model.
for example a large majority of developers only made technical contributions to the project.
in t he subset of the six projects that we analyzed we found .
of members participating in only technical medium of which .
were active only in source code repositories.
we also note that in most cases prior experience in a project ec osystem does n ot have an effect on the centrality of contribution when controlling for tenure within a project.
in fact the longer a developer is associated with a project the lower the centrality of their contributions.
after further generalization of this behavior we find that new developers and those who have been active for between and releases both have about the same level of ce ntrality for contributions to project source code while very exper ienced developers tend to move away from direct code creation tasks leading to lower centrality of contributions.
finally we attempt to uncover broader trends that may lead to a higher centrality of contribution.
we find that there are certain very specific domains specifically translation and international ization wh ere there appears to be transferrable knowledge across projects in the ecosystem that allows a developer to quickly make high centrality contributions to project source code.
the rest of the paper is organized as follows in section we discuss some of the background on the socialization process in open source projects and build our hypotheses.
sections and describe our data and present our analysis.
in section we di scuss our findings.
sections and close out the paper with a di scussion of poss ible threats to research validity and our concl usions.
.
socialization process in oss prior studies have identified a variety of barriers that newcomers face in the course of immigrating to a new open source project .
open source projects typically do not provide formal mentoring an d training for newcomers and it is the responsibility of the newcomer to identify the appropriate technical tasks and start contributing .
most projects have a public list of open bugs and issues and newcomers are encouraged to start their i nvestigations there or by addressing a concern the individual d eveloper has identified.
it is rare that newcomers are s pecifically directed to technical tasks.
for example in an analysis of the freenet project von krogh et al.
found that only in newco mers were given specific technical tasks to work on .
instead a majority of newcomers were given general encouragement after expressing an interest in joining the community through the mai ling list.
further many projects lack an explicit architecture or system design making it difficult for newcomers to understand the system be fore they can start contributing .
finally irr espective of the depth of technical knowledge that a user may p ossess making significant technical contributions to a community requires social standing and identity in the community.
in most projects commit access is only given after a newcomer has proved their worth and potential to the active community me mbers a process that limits the overall potential contributions of newcomers to the project .
the process through which newcomers gain access rights and become code contributors have been studied by many researchers .
the most common open source development model is called the onion mode l. this model postulates that members in an open source community have different roles ranging from p eripheral users to core contributors and these roles are arranged as concentric layers forming layers in the onion.
more specifically the following role s have been suggested progressing from most central and most technical layer to outer layers that are the least technical project leader core developer active developer bug fixer bug reporter documenters users active in mail messages and periph eral user.
von krogh et al.
conducted a qualitative study of the transition of roles in open source and proposed the concept of a joining script for new developers joining a community .
they cat egorized members into three broad groups joiners are members who are active only in mailing lists newcomers are members who have just gained commit access and developers are active me mbers with commit access who have shown strength of contrib utions and a technical abil ity.
potential developers joiners start by joining project mailing lists that allow them to converse about the project and learn some of the social norms and technical capabil ities of the project.
as they participate for extended periods of time potentia l developers learn how to properly participate in the community by submitting bugs triaging bugs and eventually working to track down the technical details of bugs by submitting small patches.
after a joiner has shown competence with mana ging bugs they m ay be offered the ability to become a committer newcomer to a project which allows them to directly modify the project source code without the need of an intermediary.
after an intermediary trial period newcomers are considered to have trans itioned to developer if no major concerns were raised .
in a complimentary study duchenaut identified trajectories for individuals based on successful stories of open source developers .
one such trajectory has the following stages peripheral monitoring of activity bug reporting and patch suggestions commit rights and bug fixing module level leadership becoming vested in the community and gaining approval of core members for far reaching architectural changes.
his study suggests that to succeed in becoming a part of the community there are social rites of passage at each stage in which periph eral members must gain the acceptance of core members and that political maneuverings are often needed to create an identify for oneself and gain acceptance from the community leaders.
while no consistent naming scheme has arisen for roles in open source projects e.g.
maintainers instead of core member patc hers instead of bug fixers a consistent finding is that members near the center of the model exert more influence over the technical decisions of the project as well as other factors affecting the community .
for example in linux the project leader linus torva lds has the final say regarding techn ical directions .
in apache the board of directors forms the core layer and is responsible fo r making final decision s regarding pr oject plans and features .
the onion model of role progression is considered meritocratic and as members gain experience and make larger contributions to the project they migrate to more ce ntral roles in the community .
this general model of immigr ation and participation in open source projects as a process of moving from non technical to technical processes provides a foundation to our first hypothesis hypothesis new comers to project communities will begin by participating in the least technically challenging medium before moving to more technical mediums.
othe r studies have also shown the importance of social factors for the success in open source projects.
oh and jeon found that the social network and the strength of the ties in the community was a good indicator for retention of members in the community in the face of exter nal factors such as other projects monetary incentives etc.
bird et al.
found that in the open source comm unities that they studied apache postgres attaining developer status was dependent on the tenure of that individual in the project and that the social status of an individual was a stronger criterion for success .
they identified the inherent social s tructures in the community based on mail messages and found that successful members were also social hubs.
in their seminal study von krogh et al.
found that developers who had generational knowledge a ctive across multiple releases made more far reaching changes whereas new developers largely made localized changes .
this leads to our second hypothesis hypothesis as developers gain more experience in a project they will contribute more to the core of the project source code.
the central premise of the onion model is that the progression from a passive user to an active developer entails a learning pro cess both from a social and technical perspective.
however when projects are interrelated the time needed to learn the social culture or technology might be lower.
project ecosystems often constitute projects that are heavily interrelated.
for example eclipse hosts a multitude of projects that all are built on a common technology and utilize a common developmen t infrastructure .
similarly apache contai ns numerous common libraries that are shared amongst projects written in both java and c. it also has a formal process for development and participation the apache way which describes how developers are to communicate and manage projects .
gnome a successful desktop environment for linux and unix systems likewise has a consistent infrastructure across projects th at contain common libraries and widgets that allow developers to leverage knowledge gained in related projects .
such common infrastructure therefore should reduce the amount of new technical and social knowledge that must be a cquired when moving between projects.
this is the premise of our third hypothesis hypothesis developers who have been active on related pr ojects in the same ecosystem will be able to transfer knowledge and reputation to short circuit the onion model of participation and contribute to the c ore of a project sooner than those who have not.
in summary the immigration process in open source projects has a strong social component.
however the majority of these studies have been performed on individual projects.
to the best of our knowledge we a re the first to study the development process model in an open source ecosystem.
prior work by dagenais et al.
investigates how newcomers get on board new projects within a corporate environment by studying how they learn about the technical landscape and the social culture of individual pr ojects.
findi ngs from the study recommend mentoring guidance frequent feedback and creating a project landscape with techno logy markers to make it easier for newcomer to understand the system.
although this study is for a commercial project it relates to our work since it investigates migration across projects in a community.
however its findings are not fully applicable to open source ecosystems which have very different characteristics with much less hands on training and feedback provided to newco mers.
.
data collection for our analysis we examined the ecosystem around the gnome project an effort to create a robust and usable desktop enviro nment for linux and other open source operating systems.
founded in gnome has a fairly open policy of accepting new projects into the ecosystem which gives the project the abi lity to use gnome servers for infrastructure needs.
throughout the history of gnome there have been more than different projects many of which are smaller projects that never made it into the official distribution of gnome.
.
background of gnome gnome is built on a set of common technologies and libraries that include among others a common graphical user interface toolkit with associated user interface guidelines components for common ta sks such as displaying images libraries for managing program configuration and processing xml files and mech anisms for translation across the ecosystem.
these shared tec hnologies do not however enforce a required programming la nguage or set of programm ing paradigms.
the project uses a nu mber of different programming languages for key components i ncluding c c python c and in some older cases scheme .
in addition to common technical interfaces the ecosystem also has a shared e nvironment for managing the technical and social parts of a project.
it provides a common hosting framework for project source code originally cvs later subversion an d now git defect and request management bugzilla and discu ssion and decision making mailing lists and real time chat .
the project has an overall foundation board that manages the major directions and business aspects of the ecosystem but individual projects are given significant amounts of autonomy.
individuals within the community are elected or appointed to major roles in the ecosystem that cross project boundaries such as release ma nager .
to make our analysis tractable and test our hypotheses we had to filter the community down to a subset of projects that have mult iple releases as part of the official gnome desktop and have a significant number of developers bug reporters and people active on project mailing lists.
further to understand immigration across projects we needed to select those projects that have a significant overlap in project membership.
.
data collected we collected data for the gnome project from to including data from mailing list archives bug tracking system and source code repository.
in total more than developers made nearly .
million changes to files grouped into approx imately commits.
we worked with the project administr ators to obtain a copy of the complete bug database for the project which contained comments on bugs reported by different people.
this data was loaded into a large dat abase with a single schema that inte grates all of these data streams.
as is common with many long running open source projects the different data streams were not seamlessly integrated with one another with individuals using different account names for pr oject mailing lists bug trackers and source code repository.
one of the authors worked with members of the community and utilized information from norms and practices such as referencing bug numbers in source code commit messages to link together all the elements.
the most difficult p art of cross linking the gnome data was in normalizing user names across databases.
while a large part of the normalization process was automated matching performed by comparing email addresses and provided user names across data sources it was necessa ry to consult with ind ividuals in the community to correctly identify and validate the names and identities for about of the participants.
the openness of the community also means that it is easy for an yone to sign up for project mailing lists and report bugs yielding thousands of individuals with only peripheral interest in the co m munity.
as we are concerned with the immigration process through which a member becomes a committer we examine only those individuals who eventually obtained direct commit access to the project source code.
furthermore as the community keeps almost all file based artifacts in project code repositories inclu ding translations and other non code related files we had the o pportunity to investigate whether members whose contr ibutions are non source code e.g.
translators documenters and artists follow a different path to become a committer.
we therefore separately analyze contributions made to the project source code repository according to the type of artifact contribute d. that is we differe ntiate between source code project documentation project build scripts translations and other artifacts.
for the purpose of our study we are most interested in the two largest categories of art ifacts actual project source code e.g.
c c python etc and project translations and documentation.
for our analysis we selected a subset of six projects.
these pr ojects were selected on the basis of their extensive history avai lability of archival artifacts prominence in the ecosys tem and the overlap of developers between these projects.
three projects are end user applications and three are utility or library packages project an end user application for viewing and ligh tweight graphics manipulation.
project a web browser that is customized to integrate into the desktop environment.
project a library and several tools for applications to manage settings in a standard and unified method.
most end user applications in the ecosystem rely on this library as a critical piece of infrastructure.
all projects in the subset we examine utilize this library as a key component.
project a collection of utilities for developers and end users alike to make the most out of their desktop experience.
project a system level library for the transparent manip ulation of files and other file like resources on the local machine and across network connections.
the use of this library is not required by all end user applications however all applications in this subs et utilize this library.
project an extensible end user spreadsheet application.
.
analysis to understand the effect of ecosystems and interconnectedness of projects on the joining script of members we began by analy zing the overlap of individuals who committed code to multiple projects in the ecosystem.
in the matrix show n in table the diagonal shows the total number of unique individuals who were identified as contributing source code as opposed to trans lations documentation and media to the project source code repository during the period of study and other cells show the number of developers in common between the two projects.
table overlap of source code committers between projects in study despite the broad spectrum of projects in our study we see that there is a significant overlap of individuals contributing source code to the projects.
in fact we see deve lopers who are co mmon across projects numbered and .
when we expand our observations to inclu de all those who made contributions to the project source code repository in cluding documentation and translations we see that indeed there is a much greater overlap between projects as se en in table .
table overlap of all committers between projects in study going beyond project source code repositories and including other major project archival mediums mailing lists and bug tracker we see that each of these projects attracted significant numbers of contributors a nd engaged users many of whom were also active in other projects within the ecosystem as sho wn in table .
table overlap of participants in mailing lists bug tracker and source code repository between projects havi ng established that each of these projects within the gnome ecosystem have a significant number of c ontributors and that there is significant overlap between individuals working on each pr oject in th e remainder of this section we analyze our research que stions first by examining the pattern of int eraction that leads a new contributor to become a developer in section .
followed by an analysis of how project tenure affects the centrality of develop er contri butions in section .
an evaluation of ecosy stem tenure in section .
and a principle component analysis to identify diffe rent factors that effects centrality of de veloper contribution in se ction .
.
.
introductory interaction patterns we begin by analyzing the progression paths of members across the project archives.
we performed two different levels of anal ysis to examine the evolution of developers.
at the first level we examine how developers join individual projects and at the next level we take the pool of developer contributions as a whole across the entire set of six projects that we are examining.
for each level we build a pattern of the developer s contributions by identifying the first appearance of a developer s contributions in each of the three archival mediums mails bug tracking and source code.
the release of the first contribution in each medium is recorded and a prog ression path is established.
we grouped the progression paths into five major categories based on their relationship to the socialization process in the sof tware ecosystem.
in the most literal sense we consider that a d eveloper followed the onion model if they first contributed to pr o ject mailing lists then in a subsequent release contributed to the project bug tracker and in a yet later release contributed to project source code.
we note that many developers may not spread these actions over three or mo re six month release cycles so we ide ntify a similar accelerated progres sion.
table provides a brea kdown of the number of individuals in each progression path.
table .
progression across social and technical mediums.
individual projects ecosystem subset category members percent members percent social tech .
.
accelerated .
.
tech social .
.
technical .
.
source only .
.
social technical path this includes members who start in social medium mail and then progress to technical mediums in subs equent releases.
we expanded this category from the original onion model where members progress from mailing lists to bug tracker activities and then to code commits to also include members who started in mailing lists but then received commit access and then were found to participate in the project bug tracker.
we did so because it might be possible that members contributed to technical discussions of patches through the mailing list as opposed to rel ying on the project bug tracker.
a key criterion for this category is that members are active in only one medium during a release p eriod.
accelerated path this c ategory includes members who start in mailing list social medium and then participate in either techn ical medium e.g.
bug tracker or code but have multiple kinds of contribution during the same release.
for example we found ind ividuals who appear in both mailing lists and bug tracker in the same release.
we also found individuals who participated in all three mediums in the initial release.
we combined all paths that involved members who first started with a social process and then moved to technical contributions into one group since it is poss ible that our analysis at the release stage might miss members who follow the traditional model but where each stage lasts for weeks.
technical social path this path is contrary to what has been proposed in the onion model.
we found members who started by participating in bug tracker or project source code repositories and then moving to mailing list participation.
while in total this path contributes a relatively small percentage the interesting fact is that these members participated in the social medium only after at least one release of participating in the technical medium.
technical only path this category includes members who have participated only in technical me dium.
table further subdivides this category into members who had only contributed to project source code repositories and members who had contributed source code and participated in the bug tracker in any order code contr ibution followed by bug track er activity or vice versa .
this d irectly contradicts the onion model and shows that members in a project ecosystem can start by directly contributing to code wit hout prior socialization.
our analysis shows that very few project members follow the social ization process as predicted by the onion model even when we combine the social and accelerated categories .
when we combine the social tech and the accelerated pa tterns .
we only found a small percentage of users .
partic ipating in soc ial medium after making technical contributions.
our largest group consisted of users who directly contributed to tec h nical medium .
when we combine the technical and the source only patterns .
we therefore conclude that there is little support for our first hypothesis that newcomers to project communities begin by participating in the least technically challenging medium before moving to more technical mediums.
next we wanted to test whether a r eason for the high percentage of users directly contributing to a project could arise because these members have experienced the socialization process in another project within the ecosystem.
we tracked user contributions and their progression across all t he six projects see table .
by d oing so we see a near tripling of people who follow some portion of the onion model individual projects .
.
.
which increased to .
.
.
an increase by .
while the number of developers contributing only to the technical mediums has fallen to .
combining the technical and source only paths .
this shows that within the broader ecosystem developers tend to follow a socialization process more similar to those proposed in hypothesis but still only a quarter of developers follow a variation of the pattern.
therefore at the ecosystem level we also reject hypothesis .
.
project tenure and code centrality after identifying the overlap of developers in projects and general paths that developers take after joining a project we evaluated the effect tenure has on participation in a project specifically with respect to code centrality.
that is we investigate whether the number of releases during which a participant is active in a project affects whether they make core contributions.
von krogh et al.
found that members with generational knowledge active across multiple releases made changes that spanned multiple files whereas new developers typically made changes that involved a smaller set of localized files .
simil arly duchenaut claimed that developers need certain social status before they can impl ement high impact changes .
to evaluate the centrality of a developer s contributions we needed a method to score the centrality of each commit made to the project source code repository.
source code can be thought of as forming a network of different files that are related to each other.
there are a variety of ways to construct such a network for example one can use call graphs or package imports in languages such as jav a or use the concept of logical commits .
we chose to use the latter since it is not dependent on a particular programming language and works for projects that use multiple programming languages.
briefly this method infers connections between two differe nt files in the source code repository when they are committed together.
for example if a developer commits files a b and c to the repository at the same time and as part of the same commit we infer that there is some common thread b etween files a b and c and create a triad in the network between those files.
the more times that files are committed together the higher the weight that is placed on the edges.
as a project evolves this slowly creates a more complete network based view of the project hi story and source code.
once a network of source code is created it is possible to use various social network analysis metrics to generate a numeric centrality score for each file in the network at each time period thus identifying the files that are cons idered to be most central to the project.
although there are a variety of different candidate metrics many are not applicable on disconnected networks or make assumptions about the structure of disconnected networks that are not appropriate for our analys is.
one metric that is robust and avoids issues with network structure while maintaining a consistent implementation is eigenvector centrality .
mathematically eigenvector centrality is the first eigenvector of the adjacency matrix formulati on of the network.
in general terms the interpretation of eigenvector centrality is such that nodes with high eigenvector centrality tend to be connected to many other nodes with high eigenvector centrality while nodes with low e igenvector centrality ten d to have few connections that are prima rily to other low scoring nodes.
when we refer to the centrality of a file at a particular release we refer to the eigenvector centrality of that file based on the network of logical commits generated from all commit s up to and including that release cycle.
in this way we preserve relationships from the past while building the network for future changes.
for the purposes of this work we consider only source code files contained in the project source code repos itory a nd exclude other files such as those that support translation and documentation.
since we are interested in the centrality of a developer s contrib ution the file level centralities need to be translated into developer centrality.
this requires attributing the centrality score of the file to the developer who committed it.
however note that commits made by developers often touch multiple files and developers typically make numerous commits during each community release cycle.
therefore for an individual d eveloper s commit we define the centrality as the mean of the eigenvector centrality of each of the files that comprises the commit.
from this we generate an overall source code centrality score for each developer which is the sum of the centralities for each of the commits.
in our calculations a developer can become prominent in a project either through making many commits to files with low or medium ce ntralities or by making many fewer commits to files with high centrality scores both of which are val uable measures about the importance of developers contributions.
in addition to the centrality of files and developers we collect other pieces of information for each developer in the community to assist us in understanding how a developer progresses wi thin the community.
unless otherwise specified these metrics are collected for each developer on each project on which they worked during each time period in which they were active.
source code commits total number of commits containing source code docu mentation and translation.
mail count number of messages posted to project mailing lists and the number of responses obtained from those messages.
tracker activity number of comments created in project bug tracker and total number of actions in the bug tracker.
these discussions are often technical in nature and focus on a specific defect or feature.
project experience number of releases since the developer s first activity on the project.
project active experience total number of releases in which the developer was active on the project.
this is project exper ience minus the number of releases for which the developer made no contributions to the project.
in the process of building a regression model it is necessary to evaluate predictor variables fo r independence from one another and also whether or not there is an undue reliance on the depen dent variable.
we examined the correlation of the various variables to the outcome metric source code centrality and the other co llected variables.
we found three variables that had sufficient i ndependence for use as control variables in a regression model mail count tracker activity and project experience .
we could not use source code commits in the regression because the d ependent variable source code centrality is a construct that relies on a multiplicative transform of source code commits and ther efore had a very high correlation.
project active experience could not be used because it had a very high correlation approximately .
with project expe rience .
we selected project experience as our variable of choice as it is the best depiction of the fact that tenure accrues over the entire time a member is involved in a pr oject.
instead of performing a simple regression with a single intercept we ackno wledge that there is significant variance between the projects in the ecosystem and instead create a regression model with multiple intercepts one for each project.
the output of this regression model can be se en in table .
table base regression model illustrating relationship between project experience and source code centrality variable estimate significance mail count .
.
tracker activity .
.
project experience .
.
adj r squared .
f .
on and df p .
in this basic model we find that as expected social activities such as posting messages to project mailing lists and combination of social and technical activities such as being active on a project bug tracker increase the source code centrality for a developer as shown by the positive sign on the estimates from the regression model.
this indicates a relationship between general project acti vity and source code centrality but w e also find that the number of releases that a developer has been active on the project which has a negative sign on the regression estimate decreases the ove rall source code centrality for the developer.
in essence while controlling for other social and socio technical activities the longer a developer remains active on a project the lower the e xpected level of source code centrality.
this may appear in co ntrast to other findings that show that tenure increases importance in a project but we note that we are examining source code centrality and not an overall metric for importance in the project.
a developer with significant experience on a project may have shifted to a different r ole that involves more leadership and less actual development.
our analysis shows that our second hypothesis as developers gain more technical experience in a project they will contribute more to the core of project source code is not supported.
to gai n further insight into the lack of effect of a developer s tenure in a project we performed additional analyses.
additional explorations utilizing mathematical manipulations of p roject e xperience provided little insight however a simple binning alg orithm that grouped develope rs into three categories new first release normal second through fifth release and experience d sixth or more release provided additional insight when used in a regression model as sho wn in table .
we once again find that the centrality of commits to the project source code repository decreases the longer a developer has been contributing to a project as seen by the low estimate and non significance in results for experienced developers .
howe ver there is only a slight difference between new developers and d evelopers who have been active for between total releases e stimates of .
and .
with significant values .
this su g gests that centrality for developers slightly increase for n ormal developers and then reduces for experienced developers.
table enhanced model illustrating relationship between project experience and source code centrality variable estimate significance mail count .
.
activity count .
.
new developer .
.
normal developer .
.
experienced developer .
.
adj r squared .
f .
on and df p .
it is unclear what happens to the fate of experienced developers.
a random examination of six developers who were active for six or more releases on a single project showed that three of the deve lopers remained central to the project in core leadership roles two of the developers made many fewer contributions to projec t source code because they had adopted broader leadership roles in the community e.g.
release manager and member of the found ation board and the sixth developer stopped contributing to deve loper source code entirely instead focusing on bugs and shepher ding the process of evaluating new feature requests for the project.
additional explorations with different combinations and numbers of bins for developer experience yielded no additional insight.
these results suggest that experienced developers can foll ow se veral diff erent paths some remain active code contributors while others may transition into more managerial or leadership roles focusing instead on managing the community.
because of this dispersion of roles we do not see a net effect of tenure in a project on developers code centrality and therefore reject hypothesis .
.
ecosystem tenure and code centrality in the next part of our work we evaluated whether overall tenure in the ecosystem had an impact on developers code centrality.
if it is true that there is substantial transferrable knowledge between different projects in the ecosystem then developers with exper ience on other projects in the ecosystem should achieve higher levels of source code centrality at an accelerated rate.
to assist in th is model in addition to the metrics collected in the previous section we also collect the following metrics prior experience number of releases the developer was active on other projects before their first contribution to the project in question calcul ated once per developer per project .
total experience number of releases since the developer was first active in the ecosystem.
total active experience number of previous releases for which the developer made contributions in the ecosystem.
functionally this is the total experience minus the number of releases for which the developer made no contributions to pr ojects in the ecosystem.
for a developer who is completely new to the entire ecosystem their prior experience will be and their total experi ence and total active experience will be the same as in the previous section.
in most cases we found that developers were active without any major breaks in participation.
the correlation between total e xperience and total active experience was .
pre venting their mutual use in a single regression model.
the correlation between total experience and project experience was .
indicating that in most cases it is inappropriate to use both variables in a regre s76 sion model.
we select prior experience as th e more relevant add itional metric for depicting experience in the ecosystem.
thus building on the models in the previous section we add the additional variable of prior experience to evaluate to what degree a developer s experience on projects in the ecosystem prior to joining this project affects the centrality of their contribut ions.
the results of this regression are sho wn in table and indicate that a developer s prior experience in the ecosystem does not play a role in the centrality of source code commits as evidenced by the negative es timate and non significance of the result.
therefore we reject hypothesis .
table regression model relating project experience ecosystem experience and source code centrality variable estimate significance mail count .
.
activity count .
.
project experience .
.
prior experience .
.
adj r squared .
f .
on and df p .
.
broad factors that affect code centrality as we found that prior experience was not indicative of code ce ntrality we examined the data to find other factors that may be related to increased developer centrality.
further a major problem that we faced in the analysis of this community is the fact that many of the variables related to developer participation that can be collected from the archives were highly correlated making their use inappropriate in a regression model.
however it is pos sible to gain additional insight into which variables have the greatest effect on our dependent variable by performing a principal component analysis and using those components as predictors for source code centrality.
this also allows for broader general ization of attributes that lead to an increase in source code centra lity.
table column lists the variables that we collected from the archives c c java code commits documentation related commits translation commits total number of mail messages number of messages started by a developer number resp onses to the original message by a developer bug tracker activity e.g.
bugs opened closed statuses changed comments left in the bug tracker and the five experience variables previously discussed.
there were four components that had a standard deviat ion of greater than one and ten factors with a standard deviation of less table major component loadings from principal component analysis component std dev .
.
.
.
source commits .
.
doc commits .
.
trans commits .
.
.
message count .
.
message started .
.
.
message responses .
.
.
bug tracker activity .
.
bug tracker comments .
prior experience .
.
.
total experience .
.
total active experience .
.
.
project experience .
.
project active experience .
.
.
than one.
in keeping with convention we selected the four co mponents with greatest explanatory power for further analysis.
the interpretations of the factors as present ed in table are as fo llows component the inve rse of artifacts created by the developer which translates to the inverse of total participation.
developers who score very low on this component have created numerous artifacts in any of the archival mediums.
component the inverse of the time that a d eveloper has spent on the project.
new developers will score higher on this comp onent than developers who have been active in the community or project for a significant amount of time.
component broad social experience.
developers who score high on this component have been active on mailing lists and have been in the ecosystem for a long time.
in contrast developers who score lower are newer to the ecosystem and project.
note that translators can fall in the latter group since translation is often a more solitary role within the community and translators frequently pop in and out of projects.
component technical medium expertise.
developers scoring high in the component have been active in both the bug tracker and source code repositories but less active on project mailing lists.
they typically have significant amounts of experience in the ecosystem but may be new to a project.
an expert translator who enters a project to improve its support for internationalization would score high on this compone nt.
as before we create a regression model to evaluate the relatio nship between these generated components and source code ce ntrality.
we again allow the intercept for each project to vary to account for differences in code structure in the ecosystem.
the results can be se en in table .
table regression model illustrating relationship between generated components and source code centrality variable estimate significance component .
.
component .
.
component .
.
component .
.
adj r squared .
f .
on and df p .
unsurprisingly we find that developers who create the most art ifacts as shown by a low score in component typically have the highest source code centrality negative regression estimate and highly significant .
this is to be expected from our definition of source code centrality.
we also find that individuals with more experience in the project as shown by a lower score in component will have lower overall source code centrality on account of the component loadings being the inverse of overall experience and the positive s ign on the estimate in the regression model .
this reinforces our find ings from earlier in se ction .
and .
that experience in the comm unity leads to a lower level of source code centrality.
component shows that individuals with broad social experience typically ha ve lower amounts of source code centrality.
remember developers with high social experience rate high in the co mponent loading and the component has a negative estimate in our regression which leads to the above conclusion.
this could be as a result of a distribution of work within the projects e.g.
some people write code some people manage aspects of the project on the mailing lists .
the reverse interpretation is that developers with little experience in the ecosystem and few social contrib u77 tions on m ail messages may be more likely to contribute centra lized source code.
component indicates that developers with expertise in the tec hnical mediums particularly those involved in translation and i nternationalization and those who also have prior experie nce in the ecosystem but may be new to the project have the ability to achieve high levels of source code centrality.
in this narrow co ntext we see some of the only evidence that prior experience in the project ecosystem may allow an individual to sidestep some of the standard learning processes and begin to commit directly to core elements of the project.
therefore we see that while hypothesis can generally be r ejected across the ecosystem there are some small niches where it may hold true.
in particular this appears to hold true for the sp ecialized case of translators migrating across projects in the ecosy stem as evidenced by component .
.
discussion from our analysis of developers in the selected projects we found significant overlap in the populat ion of developers between pr ojects.
this held true not only for developers who wrote the code for the projects but also individuals who documented translated created other media and even the engaged users who were only active on project mailing lists.
this established the strong possibility that developers would have a shared body of transferrable knowledge that they can take from one project to another and answers research question by showing that developers do move between and participate in multipl e projects in an ecosystem o ften times in significant numbers.
surprisingly however when we analyzed the progression paths of individual developers both within individual projects and across the projects in the ecosystem we found many individuals who eschewed social communication mediums and focused only on the technical mediums in strong contrast to what was predicted by the onion model of open source participation.
at the individual project level fewer than in developers follows the onion mode l predicted pattern of moving from social to socio technical to technical mediums.
when we broadened our analysis to include the entire ecosystem we found slightly stronger signs of the onion model as .
of the members followed the onion model sug geste d progression from social to technical mediums.
in contrast to the onion model a majority of participants were found to have participated only in technical medium .
per project and .
when looking at all six projects .
this is co ntrary to most c urrent studies that have analyzed the development process in open source projects albeit these were conducted on single standalone projects.
one explanation for these results could be that developers who jump right in with code contrib utions might have u ndergone a socialization process in another project in the ecosystem that helped them jumpstart their contrib ution or there might be other social communication medium such as direct person person email or real time chat irc that were used by these techn ical contributors for which we do not have archival data.
the lack of support for the onion model and for our first hypothesis suggests that the joining script for developers especially in the new category of oss .
projects is still a fertile field of research.
particularly the interaction of additional co mmunication mediums such as blogs twitter real team chat social software development sites su ch as github and bitbucket2 and social networking sites in combination with the increased partic ipation of commercial firms means that open source has evolved significantly in the last ten years and that previous models of s ocial participation may need to be updated for the current state of the art in open source software development.
the next step was t o analyze whether prior experience either on a single project or in the broader ecosystem had any effect on the contribution of developers.
as opposed to simply summing up the number of commits that an individual made we calculated the centrality of each developer s contribution as a proxy for the i mportance or depth of contribution.
in this way an individual who changes files that are considered to be central to the project will score higher than a developer who is highly active but focuses all of their work on a peripheral component such as a plugin.
in contrast to our expectations and hypothesis and we found that experience in communities both in individual projects and the ecosystem as a whole play little role in the centrality of co ntributions to project source code.
in fact new developers were slightly more likely to have central contributions than experienced developers and those developers with extensive experience were found to have widely varying levels of centrality.
there are many possi ble reasons for this phenomenon.
first it is possible that experienced developers such as those who have been active for six or more releases are venturing into project management and leadership roles which require more time focusing on management or a rchitecture than actual development.
while it is likely that these developers have a deep and robust understanding of the project source code and architecture it may be that their skills and experience are better utilized in managing and shepherding other users a finding that was partially echoed by a random examina tion of experienced developers.
a possible cause for the lack of effect of prior experience across projects in the ecosystem could be as a result of the structure of the projects themselves.
t he bulk of the code for most of the pr ojects was written in c a language that isn t always as amenable to modular code structures as managed languages such as java and python.
if developers migrate across projects in the ecosystem and bring with them a fe ature gift to the new project it is possible that the architecture of the new project requires substantial mod ifications to core elements of the project therefore increasing the centrality of the new developer s contributions by virtue of the number of modifications made and the location of those modific ations.
when we attempted to identify additional factors that played a role in source code centrality as per research question we found one group of developers who appeared to benefit from learning in the ecosystem translators.
a major influencing factor of this is likely the very standard method for internationalization across all projects.
a translator can introduce internationalization features to a project with modifications to only a handful of header files and by modifying