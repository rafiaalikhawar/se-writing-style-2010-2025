an empirical study on reducing omission errors in practice jihun park korea advanced institute of science and technology daejeon korea jhpark se.kaist.ac.krmiryung kim the university of texas at austin austin tx usa miryung ece.utexas.edudoo hwan bae korea advanced institute of science and technology daejeon korea bae se.kaist.ac.kr abstract since studies based on mining software repositories sparked interestsinthefieldofguidingsoftwarechanges manychangerecommendation techniques have been proposed to reduceomission errors.
while these techniques only used existing software commit data sets to evaluate their effectiveness we use the data set of supplementary patches which correctinitial incomplete patches to investigate how much actualomission errors could be prevented in practice.
we find thatwhile a single trait is inadequate combining multiple traits is limited as well for predicting supplementary change locations.
neither does a boosting approach improve accuracysignificantly nor filtering based on developer or package spe cific information necessarily improves the accuracy.
devel opers rarely repeat the same mistakes making the potentialvalue of history based change prediction less promising.
we share our skepticismthatomission errors are hardtoprevent in practice based on a systematic evaluation of a supplemen tary patch data set.
categories and subject descriptors d. .
distribution maintenance and enhancement keywords omission error supplementary patch mining version history .
introduction about ten years ago zimmermann et al.
and ying et al.
sparked interests in the promise of guid ing software changes based on version histories.
over the past decade many change recommendation systems have been proposed to identify additional change locations to re duce omission errors.
for example fixwizard identified additional change locations using cloning based similarity and hassan and holt investigated several change propa gation heuristics finding that historical change coupling is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributedfor pro fit or commercial advantage and that copi es bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or re publish to post on servers or to redistribute to lists requires prior speci fic permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
accurate than structural dependency relationships for predicting co changed program entities.
in addition to theaforementioned approaches many change recommendationsystems havebeendeveloped tofindadditionalchange locations based on version histories.
these approaches suggested ways to predict supplementary change locations however they evaluated their accuracy on existing software commit data only.
they groupedcommits into a set of transactions and then predicted theremaining entities of a transaction based on a subset of thetransaction.
we use a supplementary patch data set to predict additional change locations for real world omission errors.
the supplementary patch data set was created in our prior work to study the feasibility of reducing omissionerrors where developers applied supplementary patches tocorrect or complete original incomplete bug fixes.
we investigate how the supplementary change locations can be predicted based on the initial change locations.
to represent the relationship between them we propose a newgraphrepresentationcalled change relationship graph crg .
the crg uses packages classes and methods as graph nodes and represents the relationship between graph nodesbased on structural dependency historical co change code clone and name similarity relationships.
we then develop a path generalization algorithm based on the crg to findthe frequently occurring relationship between the initial andsupplementary change locations.
based on a comprehensivestudy wehavedetermined that it is inherently challenging to predict supplementary change locations based on initial change locations and then we share our skepticism that reducing omission errors based on a sys tematic evaluation of a supplementary patch data set is verydifficult in practice.
our comprehensive study on the sup plementary patch data set finds that neither a specific rela tionship nor a pattern exists between the initial and supplementary change locations.
.
related work zimmermann et al.
and ying et al.
showed the early promise for guiding software changes based on version histories.
they used association rule mining to identify additional change locations.
they evaluated whether their tool could identify the other entities based on one entity ofa transaction.
zimmermann et al.
s approach showed of precision and of recall on average.
the precision andrecall of ying et al.
s approach were in the range of to50 and to respectively.
even though they evaluated their approaches according to whether the approach was able to guide software changes of the transaction data set during the implementation phase they did not evaluate how the approach could prevent omission errors basedon a real world supplementary patch data set.
in addition the overall accuracy was not high enough to be pragmatic our investigation findsthat theaccuracy becomes even lowerwhen the historical co change pattern analysis is applied to a real world supplementary patch data set.
robillard and saul et al.
used structural dependency in order to make a suggestion set for program investigation.
these two approaches showed that structuralrelationships can identify relevant program entities but the portion of omission errors that structural dependency can identify was not evaluated using a real data set.
fixwizard of nguyen et al.
identified a group of program entities code peer that should be changed together.
to find the code peers they identified methods that share similar object usages.
because only a few supplementarypatches have a content similar to the initial changes the tool cannotbe generalized to real world omission errors from the supplementary patch data.
herzig and zeller mined cause effect chains from version histories which are represented in ctl computationtree logic .
the change coupling which is generalized byctl can represent a causal relationship between two locations within a predefined time interval.
they evaluated how well their approach could predict additional change lo cations.
our investigation results show that only a smallportion of omission errors can be predicted using this kindofmining technique the majority of the patterns between initial and supplementary change locations appear only once.
hassan and holt assessed different kinds of change propagation heuristics andthensuggested ahybridapproach.
the hybrid approach combined historical co change patternand code layout based methods and it showed averageprecision and average recall.
malik and hassan improved hassan and holt s work using adaptive change heuristics based on the best heuristic table showing the possibility that managing prior prediction information for each entity can improve the predic tion accuracy.
precision and recall their hybridapproaches showed high recall and precision at predicting co changed entities however the evaluation was only conducted on a transaction data set.
we also find that a boost ing technique based on past prediction accuracy informationdoes not significantly improve the prediction accuracy.
park et al.
investigated the characteristics of supplementary changes and how omission errors can be reduced.
they found that a significant portion of bugs required supplementary patches.
they also found that structural de pendency and code clone analysis were limited at predictingsupplementary change locations.
in this paper our investi gation based on a graph representation crg includes not only a single relationship between the program entities but also a combination of the relationships a boosting approachbased on the past prediction accuracy package or developerfiltering based predictions and repeated patterns betweeninitial and supplementary change locations.
.
background .
supplementary patch data set the supplementary patch data set was created in our prior work to study the characteristics of supplementarypatches and how we could reduce omission errors.
in this paper we use the supplementary patch data set to study the feasibility of several prediction approaches for reducingreal world omission errors.
the supplementary patch dataset comprisesinitial patchesandsupplementarypatches.
aninitial patch represents an initial fix attempt to fix a bug the fix then turned out to be incomplete or incorrect later.
supplementary patches are applied later to complete or correct theinitial patch.
this data set and analysis source codeare available on the first author s web page.
we use three open source projects as study subjects eclipse jdt core eclipse swt and equinox p2.
we identify the supplementary patch data set in the same way as we did in our prior work .
we connect commit logs with bug ids by parsing the logs considering every integer sequenceas potential bug ids.
we then ignore if the number is out ofa pre defined range the minimum value is to ignoresmall numbers and the maximum value is and corresponding to bug id at and in the three projects respectively.
after connecting commits with bug ids we categorize the bugs into two groups.
type i bugs are the bugs that are fixed only once and type ii bugs are the bugs that are fixed more than once in the study period.
we call the first fix of type ii bugs the initial patch the subsequent fixes are supplementary patches.
we consider the bugs reported in to to and to to make sure that the bugs are completely resolved.
among and of bugs we find that and of them require supplementary patches in eclipse jdt core eclipse swt and equinox p2 respectively.
.
building a change relationship graph to express a path between the initial and supplementary change locations we develop a graph representationcalled the change relationship graph crg .
the crguses packages classes and methods as graph nodes andstructural dependency historical co change code clone andname similarity relationships as graph edges.
the crg is the first representation that allows reasoning about multiple traits of change relationship the multipletraits include structural dependency historical co change code clone and name similarity relationships.identifying graph nodes.
we define program entities such as packages classes and methods as graph nodes.
we extract structural information from each version of the program filesusingtheppa partial program analysis tool .we utilize the ppa tool to generate ast only from changedfiles not from the whole program corresponding to each re vision.
we track the version history of each program entityto identify the added revisions and deleted revisions.
identifying structural dependency relationship edges.
weuse containment inheritance and method invocation re lationshipedgesasstructuraldependencyrelationshipedges.they are created based on the ast generated by the ppatool.
identifying historical co change relationship edges.
wecreateco changerelationshipedgesbetweenmethodnodesthatarechangedwithinthesamerevision.
byparsingpatchescorrespondingtoeachrevision weidentifyco changedmethod 122nodes and then we create a co change edge between every pair of the methods.
identifying code clone relationship edges.
we create code clone relationship edges between method nodes that have similar content in their method body.
the similar con tents are identified using ccfinderx with a minimumtoken size of .
we identify code clones every revisions andthenwemapthecodeclonepairstomethodnodes by parsing patches to make a code clone relationship edge.identifying name similarity relationship edges.
we create name similarity relationship edges between methodnodes that have similar names.
we use the same similaritymeasure as that used in umldiff .
because calculating the name similarity between every method node takes too much time and makes the number of name similarity edgeshuge we make a name similarity edge when the followingconditions hold two method nodes belong to the samepackage.
the containing classes of two method nodes havename similarity larger than .
.
the names of two methods have name similarity larger than .
.
.
evaluating a prediction method we evaluate how accurately a prediction method predicts supplementary change locations based on initial change locations.
our measures for assessing a prediction method areits precision recall and feedback.
precision andrecallare common accuracy metrics.
precision evaluates whether thesuggestion set accurately predicts actual supplementary lo cations recall evaluates whether the actual supplementarylocations are covered by the predicted set.
where prepresents the predicted suggestion set and srepresents the actual supplementary change locations excluding the initial change locations precision and recall are defined as follows precision p s p recall p s s .i fo n eo f pandsis an empty set we do not count the prediction in the result for the calculation.
because we disregard cases in which a prediction method suggestsanemptysetasacandidateofsupplementarychange weshouldcompensatetoassess what portion of initial changes can obtain at least one suggestion.
we use the feedback measure introduced by zimmermann et al.
to evaluate whether aprediction method or arule can be generally used.
where the predicted suggestion set pm b is derived using a prediction method mfor bug b the feedback is defined as follows feedback b typeiibugs pm b typeiibugs the numerator represents the number of type ii bugs for which the prediction method suggests at least one candi date of supplementary change location.
the denominatorrepresents the total number of type ii bugs.
.
observations .
observation while a single trait is inadequate combining multiple traits is limited as well.
to investigate whether repeated patterns of relationship exist between the initial and supplementary change locations we identify frequently occurring paths between them which can generalize the relationship.
for bugs that are fixed more than once type ii bugs we parse the initialand supplementary patches to identify corresponding loca tions at the method level granularity to match them to corresponding method nodes in the crg.
for the initial and supplementary change locations we first investigate whether they can be connected with one hop of structural historical code clone or name similar ity relationships.
the one hop relationships can represent existing change recommendation approaches.
for example two locations connected by a code clone edge means thatthe relationship between the two locations can be identifiedby code clone analysis.
we find that only and of supplementary change locations can be reached within one hop from the initial changelocations.
thisresultsindicate thatremaining and of supplementary change locations arenot predictable using existing approaches in eclipse jdtcore eclipse swt and equinox p2 respectively.
we also investigate the accuracy of prediction rules that are made using one relationship edge predicting supplementary change locations.
we calculate the feedback precision and recall values of the rules made by one relationship edge by applying them to the initial change locations of typeii bugs in order to predict corresponding supplementarychange locations.
table shows the results.
overall thehighest precision is only and and the highest recall isonly and9 in eclipsejdt core eclipse swt and equinox p2 respectively.
these low accuraciesindicate that a single trait is not adequate for predictingsupplementary change locations.
table feedback precision and recall of prediction rules made by one relationship edge relationshipeclipse jdt core feedback precision recall calls .
.
.
called by .
.
.
code clone .
.
.
name similarity .
.
.
co change .
.
.
relationshipeclipse swt feedback precision recall calls .
.
.
called by .
.
.
code clone .
.
.
name similarity .
.
.
co change .
.
.
relationshipequinox p2 feedback precision recall calls .
.
.
called by .
.
.
name similarity .
.
.
co change .
.
.
the relationship between the initial and supplementary change locations also can be represented using a combination of the crg edges.
for example when an initial changelocation calls method x and the method x has a code clonewith a supplementary change location the crg can rep resent the relationship between them with a callsedge and acode clone edge.
to investigate whether the combination of relationship edges can connect the initial and supplementary change locations we study the number of supplemen tary change locations that are covered within nedges from corresponding initial change locations.
table shows that our crg can identify to to to and to of supplementary change locations with two three four and five relationship edges respectively.
al123table the portion of supplementary change locations that are covered within nedges from corresponding initial change locations.
of edges eclipse jdt core eclipse swt equinox p2 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
over .
.
.
though there are and of supplementary change locations that cannot be connected within five edges from initial change locations and of them can berepresented within five edges in eclipse jdt core eclipseswt and equinox p2 respectively.
we investigate the feedback precision recall and f score of the rules made by one to three relationship edges.
fscore is a common measure assessing the predictive power which considers both precision and recall and it is definedby precision recall precision recall .
we apply the rulestotheinitialchangelocationsoftypeiibugstopredictcorresponding supplementary change locations.
overall thef score is at most and with the precision value of and and the recall value of and in eclipse jdt core eclipse swt and equinox p2 respectively.
these low f scores indicate that combining ofmultiple traits does not predict supplementary change loca tions based on initial change locations any more accuratelythan single traits.
.
observation a boosting approach does not signi ficantly improve the accuracy.
to improve the prediction accuracy we hypothesize that combining the past accuracy information may improve the accuracy of future prediction.
we divide the supplementarypatch data set into a training set and an evaluation set astable shows.
the training set is used to calculate theprediction accuracy of each rule.
based on the accuracy information of the training set we use a boosting approach to predict supplementary change locations.
table the period of the training set and evaluation set training period evaluation period eclipse jdt core eclipse swt equinox p2 boosting is a machine learning technique that combines weak learners to create a strong learner .
to classify a new item the boosting technique combines a set of resultsthat are generated from weak learners by weighting them based on the accuracy of the weak learners in the training set.
we develop a boosting approach that uses predictionrules as weak predictors.
for a given initial change location our boosting approach calculates a prediction score for each connected node within three edges of the initial change loca tion.
the prediction score is calculated by summing up the trained precision of theprediction rulescorresponding tothe pathstoeachnodefromtheinitialchangelocation.
thecan didate locations are ranked with the prediction score then our boosting approach suggests top nnodes.
table shows the accuracy of the boosting approaches with different top nvalues.
the results show that the precisions are and and the recalls are and in eclipse jdt core eclipse swt and equinox p2 respectively even when we suggest only the three nodes that have the highest prediction score.
we conclude thatthis boosting approach based on the past prediction accu racy also cannot accurately predict supplementary changelocations.
table the accuracy of a boosting approach top n eclipse jdt core eclipse swt equinox p2 value prec.
recall prec.
recall prec.
recall .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
observation there is no package or developer speci fic pattern.
we hypothesize that filtering prediction approaches using package or developer specific information can improve the accuracy of the prediction.
package specific rules canimprove the prediction accuracy when the packages have arepeated pattern of relationships between initial and supple mentary change locations.
similarly if a developer makessimilar types of mistakes repeatedly developer specific rules can improve the prediction accuracy.
we define package specific rules using a pre condition and a relationship as shown in the example below pre condition if the initial change location is in org .eclipse.jdt.core.util relationship suggest locations that have been cochanged with the initial change location.
developer specific rules are defined in the similar way the pre condition forms if the initial change is committed by the developer tom.
we firstly identify every package and developer specific rule that appears at least once in the training set.
to make package and developer specific prediction rules we gatherthe pre conditions of the initial changes package names and committer names and identify the relationship between the initial and supplementary change locations of type ii bugsin the training set.
we then calculate the accuracy of theprediction rules in the training set.
figure1plotsthefeedbackandprecisionofthethreekinds of prediction rules in eclipse jdt core.
we find that general rules show high feedback but low precision and developer package specific rules show low feedback but highprecision in all of the study subjects.
this is quite natu ral because when we filter the information according to aspecific package or developer the rules can precisely predict supplementary change locations for fewer applicable initial change locations.
based on the trained accuracies we develop boosting approaches similar to those in the previous section.
we find that the boosting approaches based on package and devel oper specific rules do not improve the prediction accuracy indeed their accuracy is even lower than that of the boosting approach based on general rules in some cases.
over all the highest improvements of the accuracy in terms off score compared to the boosting approach based on gen eral rules are .
.
and .
for the boosting ap proach based on package specific rules and .
.
and1.
for theboostingapproachbased on developerspe124general rules package specific rules developer specific rules0 precision feedback figure feedback vs. precision on three kinds of prediction rules in eclipse jdt core cific rules in eclipse jdt core eclipse swt and equinox p2 respectively.
our sub conclusion here is that no developer or package specific pattern between initial and supplementary changelocations exists.
.
observation there is no repeated mistake.
although we cannot find a repeated pattern of relationship between initial and supplementary change locations ba sed on existing structural dependency historical co change code clone and name similarity relationship there might be an uncovered relationship which can result in repeated pat terns.
in this section we investigate the patterns betweeninitial and supplementary change locations.
in a similar association rule mining approach of previous work but applying them to the supplementary patch data set we can represent the pattern between initial and supplementary change locations as a rule ifmethoda is changed in an initial change then testmethoda is changed in the supplementary change.
we investigate whether there is a repeated pattern of the initialandsupplementarychangelocationpairs.
iftheinitial change locations are a b and the supplementary change locations are x y we can make the following pattern rules a x a y b x b y .
we identify the number of occurrence for each pattern.
the results shown in table indicate that the majority of patterns and in eclipse jdt core eclipse swt and equinox p2 respectively appear only once andunder of patterns appear more than three times in thestudy subjects.
this result indicates that we cannot gener ate an appropriate suggestion based on the majority of thepatterns because they have occurred only once.
in addition we also find that the same location does not require supplementary fixes repeatedly.
table shows the portion of initial change locations appearing ntimes.
and of initial change locations appear only once in the version history in eclipse jdt core eclipse swt andequinox p2 respectively.
these results indicate that developers rarely make repeated mistakes at the same location version history based pattern mining cannot be accurate atfinding supplementary change locations.
table the number of patterns between initial and supplementary change locations appearing ntimes number eclipse jdt core eclipse swt equinox p2 .
.
.
.
.
.
.
.
.
.
.
.
over .
.
.
table the number of initial change locations appearing ntimes number eclipse jdt core eclipse swt equinox p2 .
.
.
.
.
.
.
.
.
.
.
.
over .
.
.
.
discussion we consider how the supplementary change locations can be identified when the initial change is given.
the accuracy predictingthesupplementarychangelocation is already low but the problem can be more difficult in practice because we need to identify the changes that require supplementary patches.
we can identify incomplete patches based on ma chine learning techniques e.g.
svm by investigating thecharacteristics of the incomplete patches e.g.
date com mitter contents of the patch etc.
.
we do not compare prediction rules to see which one is superior to the others because the overall accuracies of therules are low.
we find that called by relationship is more accurate than the other relationships see table .
this result implies that called by relationship is harder for programmers to detect than theother relationships.
for a given initial change location developers should trace the call hierarchy to find caller method of a method in an initial changelocation.
becausedevelopersaremorelikelytomisstheenti ties connected by called by relationship to the initial change the relationship occurs more frequently between initial andsupplementary changes than other relationships.
regarding threats to validity different experimental settings can affect our prediction accuracy.
for example instead of using all history data as a training set of the boost ing approach we can use only recent information as a train ing set to limit the effect of the old data.
in addition fuzzylogic random forests or neural network can be used instead of a boosting approach.
furthermore we use only sub projects of the eclipse project as our study subjectswhich are written mostly in java.
different experimentalsettings might improve prediction accuracy but we doubtthat there is a silver bullet that can resolve this problem ofreducing omission errors.
.
conclusion since about ten years ago when guiding software changes basedonminingversionhistoriesshowedearly promise many changerecommendationsystemshavebeenproposedtoiden tify additional change locations given an existing changeset.
our study is the first systematic and comprehensiveinvestigation of a real world supplementary patch data set where developers missed updating the entities together with the initial change.
in this paper using the supplementary 125change data set we develop a novel representation called change relationship graph crg that allows us to investigate the relationship between two program locations based on a combination of structural historical name similarity and code clone relationships.
based on the crg we inves tigate why it is inherently challenging to predict supplemen tary change locations given initial change locations.
through a comprehensive study we observe that while no single rule is adequate combining multiple rules is limited as well.
a boosting approach using the rules does not showa high accuracy rather it shows that past accuracy infor mation on a training set does not improve future predictionaccuracy in the evaluation set.
beyond this neither developernorpackagespecificinformation isfound toimprovethe accuracy.
moreover there is no repeated pattern betweeninitial and supplementary change locations and developersdo not make omission errors at the same locations repeat edly.
as researchers who participated in the communityof mining software repository we share our skepticism that reducing real world omission errors based on a systematic evaluation of a supplementary patch data set is inherentlychallenging.
.
acknowledgement this work was partly supported by the it r d program of msip keit .
this work was supported in part by the national sci ence foundation under gra nts ccf ccf shf ccf ccf cns and a google faculty award.
.