counter play out executing unrealizable scenario based specifications shahar maoz school of computer science tel aviv university israelyaniv sa ar dept.
of computer science weizmann institute of science israel abstract the scenario based approach to the specification and simulation of reactive systems has attracted much research efforts in recent years.
while the problem of synthesizing a controller or a transition system from a scenario based specification has been studied extensively no work has yet effectively addressed the case where the specification is unrealizable and a controller cannot be synthesized.
this has limited the effectiveness of using scenario based specifications in requirements analysis and simulation.
in this paper we present counter play out an interactive debugging method for unrealizable scenario based specifications.
when we identify an unrealizable specification we generate a controller that plays the role of the environment and lets the engineer play the role of the system.
during execution the former chooses environment s moves such that the latter is forced to eventually fail in satisfying the system s requirements.
this results in an interactive guided execution leading to the root causes of unrealizability.
the generated controller constitutes a proof that the specification is conflicting and cannot be realized.
counter play out is based on a counter strategy which we compute by solving a rabin game using a symbolic bddbased algorithm.
the work is implemented and integrated with playgo an ide for scenario based programming developed at the weizmann institute of science.
case studies show the contribution of our work to the state of the art in the scenariobased approach to specification and simulation.
i. i ntroduction the scenario based approach to the specification and execution of reactive systems has attracted much research efforts over the last decade .
the approach is based on two main ideas.
the first is that scenarios short stories of interaction between system entities and their environment provide an intuitive and natural way to think about and capture complex reactive behavior.
each scenario typically focuses on a specific feature or concern from the requirements of the system under development.
the scenarios are often extended with modalities distinguishing mandatory optional and negative interactions.
the second idea is that simulating a specification by synthesizing a transition system or a controller that meets its requirements provides useful and effective means for requirements analysis and rapid prototyping.
several different scenario based languages have been proposed and the problem of synthesizing a controller from a scenario based specification has been studied extensively by many authors .
however no work has yet effectively addressed the case where the scenario based specification is unrealizable and acontroller cannot be synthesized.
for effective debugging of unrealizable scenario based specifications one should not only identify unrealizability but also present its causes using the abstractions defined by the scenarios.
to better understand the challenge of handling an unrealizable specification in the case of synthesis one may contrast it with the case of model checking.
in a model checking setup an implementation or a representation thereof is checked against a specification.
if the implementation does not satisfy the specification a counter example is provided illustrating how the given implementation can violate the specification.
in a synthesis setup however the implementation is not part of the input.
if the specification is realizable a correct byconstruction implementation can be generated.
however if the specification is unrealizable there is no implementation one could check against and thus no direct way to finding the causes of unrealizability.
in this work we present a debugging method for unrealizable scenario based specifications.
we do this in the context of live sequence charts lsc a visual formal and expressive scenario based specification language and its play out execution mechanism .
first we show how to identify an unrealizable specification and compute a counter strategy a strategy that shows how an adverse environment may force any system to eventually fail in satisfying the specification.
this statically computed counter strategy constitutes a proof that the specification is unrealizable.
we compute it by reducing the lsc specification into a rabin game and then solving this game using a bdd based symbolic algorithm based on .
second we use the computed counter strategy to develop an interactive debugging method we term counter play out .
when an unrealizable specification is identified we generate a reversed roles controller that plays the role of the environment and lets the engineer play the role of the system.
during its execution the controller chooses environment s moves such that the engineer is forced to eventually fail in satisfying the system s requirements.
this results in an interactive guided execution leading to the root causes of unrealizability i.e.
to the specific scenarios whose violation is unavoidable.
thus while we statically compute a complete counter strategy and present it to the engineer in a textual and visual tree like formats understanding it is difficult.
to address this difficulty counter play out demonstrates the unrealizability978 .
c ieee icse san francisco ca usa242 of the specification to the engineer in an interactive direct experiential way.
note that in debugging a reactive system a single execution path does not suffice to prove unrealizability instead guided interactivity is an advantage as it allows to simulate and examine the choices made by both system and environment over time.
moreover since we deal with scenariobased specifications during execution we present all information about progress and violations to the engineer using the abstractions defined by the scenarios which scenarios were activated in the execution which scenarios are violated etc.
.
we consider this to be a key contribution of our work.
counter play out is implemented in playgo an eclipsebased ide for scenario based specification and programming developed at the weizmann institute of science.
at the back end playgo computes the counter strategy using j tlv .
code generation from lscspecifications is implemented using the s2a compiler .
in addition to a textual output graphical interface which shows the scenarios progress in sequence diagram format and the counter play out session itself in an annotated tree like format assists the engineer in tracing the execution and pointing to the causes for unrealizability.
we tested our implementation and its performance on many example specifications and validated its feasibility see sect.
v. finally on a more general note one may refrain from using synthesis to create a final implementation perhaps due to concerns about the scalability of the synthesis algorithm and the efficiency of the synthesized controller.
yet checking for unrealizability and its causes may be done with very partial specifications and already with raw ideas during early design.
thus the potential applicability of identifying unrealizable specifications and addressing them with an interactive debugging approach is not limited to setups where one plans to use synthesis to create a final implementation.
we consider this to be an important feature of our work.
the next section provides background on lsc play out and synthesis.
sect.
iii explains how we compute counter strategies.
sect.
iv presents the counter play out method using a running example.
we discuss implementation and evaluation in sect.
v. sect.
vi discusses related work.
sect.
vii concludes.
ii.
p reliminaries a. live sequence charts live sequence charts lsc is a scenario based specification language which extends classical message sequence charts msc mainly with a universal interpretation and a distinction between mandatory and possible behavior.
importantly lsc has an operational executable semantics termed play out .
we give a simplified language overview emphasising the parts most relevant to our present work.
more detailed descriptions are available in .
an lsc consists of lifelines messages and conditions.
a lifeline represents an interacting entity controlled either by the system under development or by its environment other systems users etc.
.
a message represents a call between one entity and another.
a message is a system message resp.
environment message if it is sent from a lifeline controlled fig.
.
the lscinsertcoins of the vending machine specification by the system resp.
the environment .
the lsc defines a partial order on its messages induced by the vertical ordering of messages sent and received along the lifelines.
as an example fig.
shows the lscinsertcoins taken from a specification of a vending machine which we use later in this paper as a running example .
this lsc has one environment lifeline controlled by the user and two system lifelines representing the system s panel andcashier insertcoin is an environment message and inccoins is a system message.
the current state of an lsc is represented by a system cut marking the progress of events along the lsc s lifelines.
a cut induces a set of enabled and violating messages and conditions a message is enabled in a cut if it appears immediately after the cut in the partial order defined by the chart a message isviolating in a cut of a chart if it appears in the chart but is not enabled in the cut.
messages have a hot or a cold temperature red line or blue line syntax a hot enabled message must eventually occur while a cold enabled message may or may not eventually occur.
a cut is hot if at least one of its enabled system messages is hot and is cold otherwise.
when an enabled message occurs the chart progresses to the next cut.
when a violating message occurs progress depends on the temperature of the cut if the cut was cold the chart closes gracefully the cut is set to be the minimal cut if the cut was hot it is a violation of the requirements which should have never occurred.
in the lscinsertcoins the first message is cold and the second is hot.
conditions have a hot or a cold temperature too and they are evaluated as soon as they are enabled.
a hot enabled condition must be evaluated to true while a cold enabled condition may or may not be evaluated to true.
when a condition hot or cold is evaluated to true the chart progresses to the next cut.
when a condition is evaluated to false progress depends on its temperature if it was cold the chart closes gracefully the cut is set to be the minimal cut if is was hot it is a violation of the requirements which should have never occurred.
system messages can be marked for either execution solid line or monitoring dashed line .
all environment messages are marked as monitoring.
a chart is considered to be active if its current cut has an enabled system message for exe 243fig.
.
the lscprepareteafail of the vending machine specification cution.
similarly a chart is considered to be expecting if its current cut has an enabled environment message.
in the lsc insertcoins of fig.
the first message is marked for monitoring while the second message is marked for execution.
as another example fig.
shows the lscprepareteafail taken from the same vending machine specification.
this lsc has three lifelines.
the condition coins is a cold condition.
the two hot messages printerrormessage and beep are not ordered.
b. lsc semantics the complete semantics of lsc and its formulation in the gr form is available in .
we give here an overview.
the semantics of a single lsc uses the partial order on messages and conditions defined by the chart adds a universal interpretation and relates to the hot mandatory and cold optional elements in the chart.
messages that do not appear in a chart are not constrained by the chart to occur or not to occur at any time including in between the occurrence of messages that do appear in the chart.
for example the semantics of the chart insertcoins of fig.
specifies that whenever the environment sends the message insertcoin to the system s panel the user has inserted a coin eventually the system s panel must send the message inccoins to the system s cashier .
implicitly this also means that after insertcoin occurs the system message inccoins must come before another insertcoin message is sent by the environment.
as another example the semantics of the chart prepareteafail of fig.
requires that whenever the user asks to prepare tea sends thepreparetea message to the panel the cold condition coins is immediately evaluated.
if it is true the system should eventually play a beep sound and show an error message in no specific order .
if it is false nothing more is required note that if the condition was a hot condition the semantics would have required that it is evaluated to true .
the semantics of an lscspecification consisting of a set of lscs is defined using a two player streett game between the environment and the system.
in order to win the game assuming the environment meets the assumptions specified in the scenarios the system is required to fulfil all the guarantees specified in the scenarios.
more formally the semantics of an lsc specification has three parts the superstep semantics which defines the encapsulation of finite series of messages sent by the system between two messages sent by the environment the application specific system s semantics which guarantees that the system starts from a minimal initial state where all charts are not active follows its transition semantics the progress of events along the charts lifelines system safety and is always eventually stable reaching an inactive or an expecting cut infinitely often system liveness and the application specific environment s semantics which represents the assumptions that the environment will not send certain sequences of messages environment safety and that if the chart is in an expecting cut in which the environment promises to send a certain message the message will eventually be sent environment liveness .
as we showed in these three parts of the semantics can be presented in the form of a single gr formula defined below.
definition gr letv fv1 v ngbe a finite set of boolean variables x v a set of input variables and y vnx a set of output variables.
the class of generalized reactive specifications of rank gr is defined to be ltlformulae of the form e a e t e g !
s a s t s g where i e aand s aare boolean formulae that characterize the initial values that are assumed of the environment and guaranteed by the system respectively.
ii e tand s tare formulae of the formv i2igbiwhere eachbiis a boolean combination of variables from x y and expressions of the form xvwherev2x andv2x y respectively.
intuitively e tcharacterizes possible input to the controller and s tcharacterizes possible transition of the controller.
iii e gand s gare formulae of the formv i2igfbiwhere eachbiis a boolean formula.
the formula e gcharacterizes liveness assumptions on the environment input and the formula s gcharacterizes liveness guarantees on the controller.
for example the semantics of prepareteafail is reflected in the gr formula as follows.
s acharacterises the initial minimal cut on the three lifelines beforepreparetea .
s tcharacterises the transitions specified by the chart e.g.
when the system is in the cut just after the condition the formula will restrict either beep or printerrormessage to occur before any other messages that appear in the chart may occur.
finally s gcharacterises the liveness property of the chart that is that whenever the system reaches the cut just after the condition both messages beep andprinterrormessage should eventually occur and the chart should be completed.244c.
play out strategies play out is the direct execution of lscspecifications.
as the specification may contain various kinds of underspecification due to the partial order of events within and between charts the core of play out is a strategy mechanism responsible for choosing the next message to send.
several play out mechanisms exist with increasing expressive power.
na ve and smart play out na ve play out arbitrarily chooses a non violating message from among the current set of messages that are enabled for execution in at least one chart and are not violating in any chart if any such message exists .
smart play out considers not only the current set of enabled non violating messages but also looks ahead and picks up a finite sequence of messages that will lead to a successful non violating superstep if any such sequence exists a series of system messages leading to a state with no system messages enabled for execution.
however both na ve and smart play out may be viewed as unsound because following them may result in executions that cannot be continued to form infinite executions satisfying the semantics oflsc for concrete examples of the limitations of na ve and smart play out see .
synthesis based play out synthesis based play out uses a synthesized controller to guide the system s actions during execution.
synthesis from lsc specifications has been studied before see sect.
vi .
unlike na ve and smart play out synthesis based play out is sound and complete with respect to the defined semantics if the synthesis process is successful then it is guaranteed that in every state of the system and for every environment action play out would respond with a series of actions that will result in an ongoing behavior that satisfies the specification.
specifically the solution we use for synthesis is a winning strategy.
given a gr specification computing a winning strategy for the system is done by solving a streett game where the system tries to either satisfy all its guarantees or constantly falsify one of the environment s assumptions following the symbolic fixpoint algorithms described in .
roughly the algorithm starts from the set of all states and iterates backwards by removing states from which the system is unable to force the execution to either reach all of the system s liveness guarantees or constantly violate one of the environment s assumptions each set of states where the assumption is constantly violated is computed using another nested fixpoint .
the fixpoint is reached when no additional states can be removed.
if to every environment initial choice there exists a system initial choice in the fixpoint set then the specification is realizable.
a controller that implements the system s winning strategy is constructed from the intermediate values of the fixpoint computation see .
if the specification is realizable then the construction of such a controller constitutes a solution to the synthesis problem.
if the specification is unrealizable then the synthesis computation fails.
handling this case is the challenge we address in this paper.iii.
h andling unrealizable specifications we are now ready to present the first contribution of our work that is handling of unrealizable specifications by computing a counter strategy.
a controller that implements a winning strategy for the system does not always exists.
in such a case as the games involved are determined a counter strategy must exist which shows how an adverse environment can force the system into not satisfying the requirements.
a. problem formulation given a gr specification as defined in def.
we define its dual rabin counterpart as follows definition dual gr e a e t e g s a s t s g where e a e t and e g are defined as in def.
and i s ais a boolean formula that characterizes states in which the system violates its initial guarantees.
ii s tis a formula of the formw i2ifbiwhere each biis a boolean combination of variables from x y and expressions of the form xvwherev2 x y .
intuitively s tcharacterizes states from which the computation eventually reaches a deadend for the system.
iii s gis a formula of the formw i2ifgbiwhere each biis a boolean formula.
intuitively the formula s gis a disjunction of persistence properties each of which characterizes states from which the computation eventually reaches a cycle that constantly falsifies one of the system s liveness guarantees.
to understand def.
it is best to contrast it with def.
.
note that the implication from environment assumptions to system guarantees in def.
is replaced in def.
with a conjunction where the guarantees on the right hand side appear in negated form.
that is equ.
is the negation of equ.
.
b. computing a counter strategy a controller that implements a winning counter strategy for the environment is a controller in which in every step of the execution the environment s action is such that for every system reaction the resulting ongoing behavior falsifies the specification.
intuitively such a controller can roughly be viewed as a tree where all leaves represent safety violations of the system s behavior and every level of the tree allows cycles that constantly violate one of the system s liveness guarantees and whenever the guarantee is satisfied the execution is bound to continue to the next descending level of the tree.
we compute a counter strategy by solving a rabin game where the environment can force the execution to satisfy def.
.
that is the environment can force the execution to satisfy all of its assumptions while falsifying at least one of the system s guarantees.
our solution to this game is based on a symbolic fixpoint algorithm described in .
roughly the algorithm starts from the set of states from which the system has no valid possible successors all possible245successors lead to states that violate one of the safety guarantees .
it then iterates backwards by adding states from which the environment can either force the execution to previously found losing states or force the execution to constantly violate one of the system s guarantees.
each set of states where the guarantee is constantly violated is computed using another nested fixpoint and saved in a vector of intermediate values.
the fixpoint is reached when no additional losing states can be found.
if there exists an environment initial choice such that every system initial choice is in the computed set of losing states then the specification is unrealizable.
a controller that implements the winning counter strategy can be constructed from the intermediate values saved during the fixpoint computation as each set of such values represent a set of states where one of the guarantees is constantly violated.
note that the intermediate values of the fixpoint computation are the real reason to define and solve the dual game.
if a simple boolean answer is enough then there is no need for anything other than the gr formulation.
in this work we use the resulting counter strategy trees to construct counter play out an interactive debugging method for lsc specifications described in the next section.
iv.
c ounter play out we now present the second contribution of our work that is the interactive debugging method for unrealizable specifications.
given a counter strategy we define counter play out to be an interactive lsc execution with reversed roles a generated controller plays the role of the environment and lets the engineer play the role of the system.
the generated controller uses the counter strategy to choose its environment s moves such that the engineer is forced to eventually fail in satisfying the requirements.
we define positions in a counter play out execution.
recall that according to the semantics for superstep see the environment can send only one message at a time and can send a message only when the system is ready to receive one.
we partition the states of the reversed controller during counter play out execution into three kinds of states.
the controller is in a i system position if the current state of the execution is a state in which either the system or the environment just performed an action i.e.
either the system did not complete its superstep and is not ready to receive an environment message yet or the environment has just performed an action that should be answered with a system reaction.
in a system position the engineer is required to choose a message from the set of messages that are enabled in the cut.
ii environment position if the current state of the execution is a state in which both the environment and the system did not perform any action i.e.
the system has completed its superstep and is ready to respond to a new environment action and the environment did not perform its action yet.
in an environment position the fig.
.
the lscprepareteaok of the vending machine specification controller needs to send an environment message that is predetermined and embedded within its strategy.
iii violating position if the current state of the execution is a state in which the system just performed an action that violates at least one of the charts in the given lsc specification.
each state of the reversed roles controller represents the global cut the cuts of all lscs the state of each of the scenarios active or inactive and the value assigned to each of the properties.
this allows us to easily interpret the state of the controller and present it as it executes in terms of the scenarios i.e.
using the abstractions known to the engineer.
a. example specification we demonstrate counter play out using a running example a specification of a simple vending machine consisting of five lscs two of which were already mentioned in sect.
ii.
while the specification is rather small we have carefully designed it to fit into a paper and demonstrate the need for counter playout and the resulting debugging method.
additional examples are available with the playgo tool.
lscinsertcoins specifies the basic scenario of coin insertion whenever the user inserts a coin the user sends an insertcoin message to the panel the panel should eventually send inccoins message to the cashier this increases the cashier s coins property .
lscprepareteafail describes the use case where the user asks the system to prepare tea but the number of coins is less than whenever the user asks to prepare tea sends the preparetea message to the panel if coins 246fig.
.
the lscmaketea of the vending machine specification fig.
.
the lscretrievecoins of the vending machine specification 3then the system should eventually play a beep sound and show an error message in no specific order .
if it is not the case that coins then the chart closes gracefully the condition is cold not hot thus there is no violation .
lscprepareteaok describes the use case where the user asks the system to prepare tea and the number of coins is exactly .
whenever the user sends a preparetea message the cold condition coins is evaluated.
if it is false the scenario exits gracefully.
otherwise the chart continues the system s panel must eventually ask the heater controlled by the environment to heat the water followed by an assumption that the heater will eventually send a reachmax message back to the panel.
when a reachmax message is eventually received the panel should eventually reset its enabled property send a maketea message to the dispenser and set its enabled property back to true .lscmaketea describes the behavior the system should follow whenever the panel sends the dispenser a maketea message.
in this case the dispenser should send a self message to servetea an abstraction of a different scenario that entails the proper way to serve the tea.
the chart continues to specify that the cashier s coins property must be exactly it is a hot condition and be followed by a deccoins message that will consume coins decrease the coins property by .
the last lsc retrievecoins enables a cancellation functionality.
if the user sends a retrievecoins message to the panel and if the panel is enabled note a cold condition then the system must send the user a takecoins message give back the coins to the user and follow with a setcoins message that sets the cashier s coins property to .
furthermore the chart also specifies that during the process of cancellation the dispenser cannot send aservetea message sending this message would make the hot false condition on the right hand side of the chart enabled and thus result in a hot violation of the requirements .
finally the specification includes initial values for two properties coins is set to 0andenabled is set to true .
b. first counter play out session an attempt to synthesize a controller for the vending machine specification reveals that it is unrealizable.
even though the specification is rather small it is not easy for an engineer to identify the cause of unrealizability.
what s wrong?
to answer this we compute a counter strategy generate a reversed controller and begin an interactive debugging session of counter play out as follows.
at first the controller inserts a coin playing the role of the environment and the engineer playing the role of the system must follow lscinsertcoins and send inccoins message to increase the cashier s coins property.
the engineer could of course choose not to follow this obvious step to increase the cashier s coins property and do something else or just yield control back to the controller.
in such a case however the controller would immediately insert another coin leading to a hot violation of the lscinsertcoins .
thus in the remaining descriptions of counter play out sessions below we leave out such cases of obvious immediate failures.
coin insertion repeats three times.
after the third time apreparetea message is sent by the controller and the cold condition in prepareteaok is satisfied while the cold condition in prepareteafail message is falsified and the chart closes gracefully .
so the engineer again playing the role of the system must send a heat message to the heater and idle wait to expect the reachmax message that the controller playing the environment role must eventually send.
however before sending reachmax as it has to eventually our generated reversed controller invokes the cancellation functionality described in retrievecoins by sending a retrievecoins message.
since the panel is enabled lsc retrievecoins forces the system s cashier as played by the engineer to send a takecoins message and set the247cashier s coins property to by sending a self setcoins message.
only when the lscretrievecoins closes gracefully due to the false cold condition after setcoins the controller sends the reachmax message it has to eventually do that in order to satisfy the environment assumption and the engineer is forced to reset the panel s enabled property and send a maketea message.
finally following lscmaketea the engineer must now send a servetea message that leads the system to a violation in which the hot condition in this lsc which states that the coins property must be is false.
as part of counter play out the interactive executions described here are accompanied by visualizations that show the progress of lsccuts on the charts themselves as well as a tree showing an overview of the execution as it unfolds during the counter play out session according to the choices made by the counter strategy and the engineer s actions.
information about charts progress values of properties and violations is shown on top of the nodes of this tree see sect.
v .
screen capture from this interactive debugging session appears in fig.
.
c. first fix and second counter play out session the above counter play out session reveals that having the coins retrieval functionality enabled available for the environment to invoke while waiting for the reachmax message from the heater may lead an adverse user to abuse the system and prevent it from satisfying its requirements.
this suggests to fix the problem by moving the enabled lock implemented in prepareteaok to wrap the heat request and response.
thanks to the cold condition at the beginning of lscretrievecoins this fix would disable the coins retrieval functionality during heating.
unfortunately however an attempt to synthesize a controller for the fixed vending machine specification fails again and reveals that it is unrealizable.
what s wrong now?
again to answer this question we compute a counter strategy generate a reversed controller and begin a second interactive debugging session of counter play out as follows.
to begin the generated controller playing the role of the environment starts as in the previous debugging session it inserts three coins and then calls the preparetea message.
as the cold condition in lscprepareteaok is satisfied the engineer must set the panel s enabled property to false following her fix in the previous debugging session and send aheat message to the heater.
after so it idles to wait for the expected reachmax message.
now rather than invoking the cancellation functionality as in the previous counter play out session the controller playing the role of the environment sends another insertcoin message which again forces the engineer playing the role of the system to follow the lscinsertcoins and increase its cashier s coins property.
only then the reversed controller chooses to satisfy its assumption as it has to eventually by sending reachmax message.
to continue following lscprepareteaok the engineer as she must sends a maketea message to the dispenser.
thismakes lscmaketea active and forces the engineer to follow with the servetea message and inevitably reach a violation the hot condition coins is evaluated to false.
note that during the counter play out sessions described above at any stage of the execution the reversed roles synthesized controller playing the role of the environment user could have asked the system to prepare tea and activate scenarios prepareteafail andprepareteaok or ask the system to retrieve coins and activate the lsc retrievecoins before inserting three coins.
if the controller would have done that the system played by the engineer should have responded with the expected reactions according to these lscs.
yet our generated reversed controller does not choose to do this specifically because these are not necessary steps on the way to proving unrealizability.
d. second fix and closure at the end of the second counter play out session described above one can immediately see that the conditions in both prepareteaok andmaketea may be too restrictive.
thus the engineer may attempt to fix this bug in the specification by specifying that the system should not be forced to hold exactly coins but rather to hold at least coins in the specific stages during the execution of these two scenarios.
thus the engineer applies a second fix and changes these two conditions to read coins .
indeed now after the second fix the specification is realizable and we are finally able to synthesize a system controller rather than a reversed roles controller .
the system s strategy allows the user to insert coins ask the system to prepare tea and retrieve coins all with no risk of violation.
when at least coins are inserted and the user continues with a preparetea message the system sets the panel s enabled property to false before the panel sends a heat message to the heater.
thus the environment user cannot initiate the coins retrieval functionality of retrievecoins if the user asks to retrieve coins at this state nothing happens .
when the reachmax message is eventually sent the system sends a maketea message followed by a servetea message and the three coins are consumed when adeccoins message is sent.
note that after maketea is called lscprepareteaok andmaketea do not explicitly define an order between the completion of maketea serving the tea decreasing the coins and the completion of prepareteaok re enabling the panel .
that is in this case any order chosen by the strategy would work and make sure both charts are indeed completed without violation.
v. i mplementation and evaluation links to download playgo related technical documentation the example specifications mentioned in the paper and a standalone implementation to run synthesis and reproduce the tests mentioned below are all available from .
we have implemented our ideas using j tlv apis and integrated them into playgo .
j tlv is a javabased framework for the development of formal verification248algorithms providing developer friendly high level apis for symbolic bdd based algorithms.
playgo is an eclipse based ide built around the language of lsc and the play in playout approach .
it includes a compiler that translates lscs given in a uml compliant form using a profile see into aspectj code based on and provides means for visualization and exploration of lsc executions.
we extended playgo s ide to support a counter playout mode where a reversed roles controller is generated and executed so that the engineer can play against it.
a. performance in the vending machine specification where the number of lscs is the state space is the size of the controller for realizable specifications is about 8k states and the size of the reversed roles controller for the unrealizable specifications ranges from to states.
computing counter strategies and generating the controller took only up to seconds on a regular laptop .
ghz using javabdd .
to further test and demonstrate our work we have created additional example specifications unrealizable and realizable where the number of lscs ranges from to the state space ranges from 217to239 and the controller or reversed controller size ranges from to 28k states.
computing counter strategies and generating the controller took from milliseconds up to about seconds on a regular laptop .
ghz using javabdd .
note that our example specifications are much larger than ones presented in recent comparable works on synthesis .
the scalability and applicability of our work to mid size systems is due to the use of symbolic bdd based algorithms as shown in .
in our current implementation the entire computation is done once before the execution of the interaction.
if performance was our main focus then a better approach was to solve the game symbolically but evaluate each concrete step only on demand.
in all our examples mentioned above solving the game ranges from milliseconds to at most seconds.
b. the counter play out view fig.
shows a screen capture from playgo taken during the first counter play out session of the vending machine specification.
during execution lsccuts are visually shown as horizontal lines on top of the charts in the specification fig.
top .
property values are shown in playgo s system model tree fig.
left .
most importantly a counter play out view shows a graph representation of part of the counter play out strategy as it unfolds in the session according to the choices made by the controller and the engineer fig.
bottom .
the graph visualization distinguishes three types of positions during counter play out execution system environment and violating defined earlier in sect.
iv .
each system position e.g.
state is represented by a node that is annotated with a question mark icon the state id the description of the active cuts and the values of the properties.
each system node has its own popup menu which allows the engineer to select and execute each of the enabled messages in the cut.each environment position e.g.
state is represented by a node annotated with a user icon and like system nodes contains the state id the description of the active cuts and the values of the properties .
during execution states that represent environment positions are not controlled by the engineer and thus environment nodes do not provide a popup menu for interactive selection of the next message to execute.
instead an environment message as selected by the reversed controller is immediately executed and the tree unfolds.
finally each violating state e.g.
state is represented by a node that is annotated with an x error icon and displays the name of the violated chart.
this provides the engineer with exact information about the reason for unrealizability.
the main window pane shows the lsc specification and presents the cut after performing the last message in the execution using a horizontal red line fig.
presents the cut corresponding to state .
vi.
r elated work handling unrealizable scenario based specifications controller synthesis from lsc specifications has been studied before using different approaches by larsen et al.
by harel and kugler by kugler et al.
by harel and segall by bontemps et al.
and by greenyer .
except the last two none discussed unrealizability.
while bontemps et al.
suggested to address the unrealizable case using a counter strategy their solution to the synthesis problem uses an inefficient double exponential algorithm unlike our use of the efficient algorithms from .
while greenyer describes the ability to synthesize a counter strategy he suggests the extension of his tool to support the simulation of the environment as future work.
thus both works do not use the counter strategy to construct a controller to guide an actual reversed roles execution that explains the root causes of unrealizability as done in our work.
other authors have suggested different scenario based specification languages almost all of which like lsc are variants of message sequence charts mscs .
some have been used for various kinds of synthesis.
we discuss them in chronological order focusing on the context of unrealizability.
krueger et al.
consider a translation of mscs into a state based model in particular statecharts.
a case where the specification cannot be realized is not discussed.
uchitel et al.
use an exact existential interpretation similar to .
they discuss how the generated labeled transition system can be checked for dead locks etc.
but a case where the specification cannot be realized is not discussed.
whittle et al.
generate statecharts from scenarios.
the scenarios are labeled with additional state information in ocl that is used by the synthesis algorithm so some explicit state conflicts which prevent synthesis may be detected during analysis.
the user is responsible for fixing these conflicts.
sibay et al.
present a conditional existential branchingtime semantics for lsc with an algorithm to synthesize a modal transition system mts characterizing all possible conforming implementations.
a case where the specification249fig.
.
a screen capture from playgo taken during the first counter play out session of the vending machine specification.
the lscs appear at the upper part with a cut as horizontal line showing their progress and current state.
note the three types of nodes in the graph in the lower part system marked by a question mark environment marked by a user icon and violation marked by an x sign .
the edges are labeled with the messages that have been sent sender name receiver name and the message name.
the nodes are annotated with explanatory information which scenarios are active what are the values of properties which scenarios are violated etc.
that is explaining the execution using the abstractions known to the engineer.
see sect.
v b. cannot be realized is not discussed.
in a related work uchitel et al.
present synthesis of an mts from a combination of existential scenarios and safety properties.
the work mentions that two mtss may be inconsistent have no common refinement however this case is not addressed.
to conclude almost no work on synthesis from scenarios discusses unrealizability.
this may be in part because the expressive power of some of these scenario languages is limited to existential positive examples where conflicts cannot happen.
also some variants do not explicitly distinguish between the system and the environment.
the need to address unrealizability is the price one has to pay for choosing to use an expressive scenario based language such as lsc.
dealing with inconsistent specifications outside the scenarios domain two related works that deal with inconsistencyin declarative specifications should be mentioned.
sassolas et al.
use a pseudo merge operation to explore and explain inconsistencies between two mtss.
shlyakhter et al.
show how to take advantage of sat solvers unsatisfiable core to debug alloy modules.
these two works are close to ours in terms of the motivation to identify and explain inconsistencies in our case unrealizability in specifications.
however the technical setups and solutions are entirely different.
counter strategies for ltl specifications counter strategies for synthesis from ltlin general and from its gr fragment in particular have been studied in .
in we used these algorithms in the context of aspectltl .
in the present paper we reduce the lsc specification into a dual gr form and compute counter strategies by using the algorithms described in these papers.250vii.
c onclusion and future work we have presented counter play out an interactive debugging method for unrealizable scenario based specifications.
counter play out allows an engineer to play against a synthesized adverse environment controller that forces her to fail in satisfying the system s requirements and leads the execution to the specific scenarios whose violation is unavoidable i.e.
to the root causes of unrealizability.
it is based on a counter strategy computed by solving a rabin game and is implemented and demonstrated in this paper using a running example.
scalability and applicability to mid size systems is due to the use of symbolic bdd based algorithms as shown in .
the work advances the state of the art in the scenariobased approach to specification and simulation.
one future work direction deals with the computation of unrealizable cores i.e.
minimal unrealizable subsets of the specification.
for some unrealizable specifications especially ones consisting of many scenarios it may be the case that there are strict subsets of the specification that are unrealizable.
for example in our unrealizable vending machine specification before fixing the lscprepareteafail is not part of an unrealizable core the specification without it is unrealizable too.
identifying unrealizable cores can be useful as it may enable the generation of smaller reversed controllers.
of course we could find unrealizable cores by checking all subsets of the specification.
however this would be inefficient.
some recent works have considered the computation of unrealizable core in the context of ltl gr synthesis see e.g.
.
in the case oflscspecifications however we would like the unrealizable core to be computed and presented using the abstractions defined by the scenarios rather than at the granularity of the ltl formulae they induce.
moreover lsc specifications are not monotonic adding an lsc to an unrealizable specification may render it realizable.
thus we leave the definition and efficient computation of unrealizable cores for lsc as challenges for future work.
another future work direction relates to the usability of counter play out in the presence of large reversed roles controllers where the interaction required to reach violation is long.
in these cases we would like to use a summarized representation of the counter strategy and a timetravel feature to jump between sets of states that are close to violating ones such sets may be computed symbolically .
we leave this interesting topic for future work.