variability bugs in the linux kernel a qualitative analysis iago abal iago itu.dkclaus brabrand brabrand itu.dkandrzej w asowski wasowski itu.dk it university of copenhagen rued langgaards vej copenhagen s denmark abstract feature sensitive veri cation pursues e ective analysis of the exponentially many variants of a program family.
however researchers lack examples of concrete bugs induced by variability occurring in real large scale systems.
such a collection of bugs is a requirement for goal oriented research serving to evaluate tool implementations of feature sensitive analyses by testing them on real bugs.
we present a qualitative study of variability bugs collected from bug xing commits to the linux kernel repository.
we analyze each of the bugs and record the results in a database.
in addition we provide self contained simpli ed c99 versions of the bugs facilitating understanding and tool evaluation.
our study provides insights into the nature and occurrence of variability bugs in a large c software system and shows in what ways variability a ects and increases the complexity of software bugs.
categories and subject descriptors d. .
general d. .
software engineering testing and debugging keywords bugs feature interactions linux software variability .
introduction many software projects have to cope with a large amount of variability.
in projects adopting the software product line methodology variability is used to tailor development of an individual software product to a particular market niche.
a related but di erent class of projects develops highly con gurable systems such as the linux kernel where con guration options here referred as features are used to tailor functional and non functional properties to the needs of a particular user.
highly con gurable systems can get very large and encompass large sets of features.
reports of industrial systems with thousands of features exist and extensive open source examples are documented in detail .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
in a con gurable system interact in non trivial ways in order to in uence each others functionality.
when such interactions are unintended they induce bugs that manifest themselves in certain con gurations but not in others or that manifest di erently in di erent con gurations.
a bug in an individual con guration may be found by analyzers based on standard program analysis techniques.
however since the number of con gurations is exponential in the number of features it is not feasible to analyze each con guration separately.
family based analyses a form of feature sensitive analyses tackle this problem by considering all con gurable program variants as a single unit of analysis instead of analyzing the individual variants separately.
in order to avoid duplication of e ort common parts are analyzed once and the analysis forks only at di erences between variants.
recently various family based extensions of both classic static analysis and model checking based techniques have been developed.
most of the research so far has focused on the inherent scalability problem.
however we still lack evidence that these extensions are adequate for speci c purposes in realworld scenarios.
in particular little e ort has been put into understanding what kind of bugs appear in highly con gurable systems and what are their variability characteristics.
gaining such understanding would help to ground research on family based analyses in actual problems.
the understanding of complexity of variability bugs is not common among practitioners and in available artifacts.
while bug reports abound there is little knowledge on what of those bugs are caused by feature interactions.
very often due to the complexities of a large project like linux and the lack of feature sensitive tool support developers are not entirely conscious of the features that a ect the software they work on.
as a result bugs appear and get xed with little or no indication of their variational program origins.
the objective of this work is to understand the complexity and nature of variability bugs including feature interaction bugs occurring in a large highly con gurable system the linux kernel.
we address this objective via a qualitative in depth analysis and documentation of cases of such bugs.
we make the following contributions identi cation of variability bugs in the linux kernel including in depth analysis and presentation for nonexperts.
a database containing the results of our analysis encompassing a detailed data record about each bug.
these bugs comprise common types of errors in c software and cover di erent types of feature interactions.
we intend to grow the collection in the future with the help of the research community.
the current version is available at .
self contained simpli ed c99 versions of all bugs.
these ease comprehension of the underlying causes and can be used for testing bug nders in a smaller scale.
an aggregated re ection over the collection of bugs.
providing insight on the nature of bugs induced by feature interactions in a large project like linux.
we adopt a qualitative manual methodology of analysis for three reasons.
first family based automated analysis tools that scale for the linux kernel do not exist.
in fact without this study it was unclear what tools should be built.
second using conventional not family based analysis tools on individual variants after preprocessing does not scale if applied exhaustively or yields low probability of nding bugs if applied by random sampling .
third searching for bugs with tools only nds cases that these tools cover while we were interested in exploring the nature of variability bugs widely.
re ecting on the collected material we learn that variability bugs are very complex they involve many aspects of programming language semantics they are distributed in most parts of linux project involve multiple features and span code in remote locations.
detecting these bugs is di cult for both people and tools.
once feature sensitive analyses that are able to capture these bugs are available it will be interesting to conduct extensive quantitative experiments to con rm our qualitative intuitions.
we direct our work to designers of program analysis and bug nding tools.
we believe that the collection of bugs can inspire them in several ways i it will provide a set of concrete well described challenges for analyses ii it will serve as a benchmark for evaluating their tools and iii it will dramatically speed up design of new techniques since they can be tried on simpli ed linux independent bugs.
using realistic bugs from a large piece of software in evaluation can aid tuning the analysis precision and incite designers to support certain language constructs in the analysis.
we present basic background in sect.
.
the methodology is detailed in sect.
.
sections 5describe the analysis rst the considered dimensions then the aggregate observations.
we nish surveying threats to validity sect.
related work sect.
and a conclusion sect.
.
.
background we use the term software bug to refer to both faults and errors as de ned by ieee standard glossary of software engineering .
a fault defect is an incorrect instruction in the software introduced into the code as a result of a human mistake.
faults induce errors that are incorrect program states such as a pointer being null when it should not be.
in this work we collected errors that manifested as runtime failures typically a kernel panic as well as defects spotted when building a speci c kernel con guration.
while the latter might look harmless for instance an unused variable we assume that they might be side e ects of serious misconceptions potentially leading to other bugs.
afeature is a unit of functionality additional to the core software .
the core base variant implements the basic1 include stdlib.h void foo int a !
printf d n a error int main void start int x ifdef config incr disabled j x x j endif j ifdef config decr enabled x x endif foo x !
figure example of a program family and a bug.
functionality present in any variant of a program family.
the di erent selections of features con gurations de ne the set of program variants.
often two features cannot be simultaneously enabled or one feature requires enabling another.
feature dependencies are speci ed using a feature model or a decision model denoted here by fm e ectively a constraint over features de ning legal con gurations.
preprocessor based program families associate features with macro symbols and de ne their implementations as statically conditional code guarded by constraints over feature symbols.
the macro symbols associated to features con guration options are often subject to naming conventions for instance in linux these identi ers shall be pre xed byconfig .
we follow the linux convention through out this paper.
figure 1presents a tiny preprocessor based c program family using two features incr anddecr .
statements at lines and are conditionally present.
assuming an unrestricted feature model fm true the gure de nes a family of four di erent variants.
apresence condition of a code fragment is a minimal by the number of referred variables boolean formula over features specifying the subset of con gurations in which the code is included in the compilation.
the concept of presence condition extends naturally to other entities for instance a presence condition for a bug speci es the subset of congurations in which a bug occurs.
concrete con gurations denoted by can also be written as boolean constraints conjunctions of feature literals.
a code fragment with presence condition is thus present in a con guration i .
as an example consider the decrement statement in line which has presence condition decr thus it is part of con gurations incr decr and incr decr .
features can in uence the functions o ered by other features a phenomenon known as feature interaction which can be either intentional or unexpected.
in our example the two features interact because both modify and use the same program variable x. enabling either incr ordecr or both results in di erent values of xprior to calling foo.
as a result of variability bugs can occur in some con gurations but not in others and can also manifest di erently in di erent variants.
if a bug occurs in one or more con gurations and does not occur in at least one other con guration we call it a variability bug.
figure 1shows how one of the program variants in our example family namely will crash at line when we attempt to divide by zero.
because this bug is not manifested in any other variant it is a variability bug with presence condition incr decr .
422program family implementations are usually conceptually strati ed in three layers the problem space typically a feature model a solution space implementation e.g.
c code and the mapping between the problem and solution spaces the build system and cpp in linux .
we show how the division by zero bug could be xed depending on the interpretation in our running example in each layer separately.
we show changes to code in uni ed di format diff u0 .
fix in code.
if function fooshould accept any intvalue then the bug is xed by appropriately handling zero as input.
printf d n a if a !
printf d n a else printf nan n fix in mapping.
if we assume that function fooshall not be called with a zero argument a possible x is to decrement x only when both decr and incr are enabled.
ifdef config decr if defined config decr defined config incr fix in model.
if the bug is caused by an illegal interaction we can introduce a dependency in the feature model to prevent the faulty con guration .
for instance let decr be only available when incr is enabled.
assuming feature model fm decr!incr forbids .
.
methodology objective.
our objective is to qualitatively understand the complexity and nature of variability bugs including featureinteraction bugs occurring in a large highly con gurable system the linux kernel.
this includes addressing the following research questions rq1 are variability bugs limited to any particular type of bugs error prone features or speci c location?
rq2 in what ways does variability a ect software bugs?
subject.
we study the linux kernel taking the linux stable git1repository as the unit of analysis.
linux is likely the largest highly con gurable open source system.
it has about ten million lines of code and more than ten thousand features.
crucially data about linux bugs is available freely.
we have free access to the bug tracker2 the source code and change history3 and to public discussions on the mailing list4 lkml and other forums.
there also exist books on linux development valuable resources when understanding a bug x. access to domain speci c knowledge is crucial for the qualitative analysis.
we focus on bugs already corrected in commits to the linux repository.
these bugs have been publicly discussed usually on lkml and con rmed as actual bugs by kernel developers so the information about the nature of the bug x is reliable and we minimize the chance of including ctitious problems.
methodology.
our methodology has three parts rst we identify the variability bugs in the kernel history.
second fid configuration config option iffid is ?set whenfid is ?set iffid is abled whenfid is abled a message lters.
if else elif endif select fid config fid depends on fid b content lters.
figure regular expressions selecting con guration related commits in a message b content fid abbreviates matching feature identi ers.
bug fix oops warn error unsafe invalid violation end trace kernel panic a generic bug lters.void unused overflow undefined double lock memory leak uninitialized dangling pointer null ?dereference .
.
.
b speci c bug lters.
figure regular expressions selecting bug xing commits a generic b problem speci c we analyze and explain them.
finally we re ect on the aggregated material to answer our research questions.
part finding variability bugs.
we have settled on a semiautomated search through linux commits to nd variability bugs via historic bug xes.
as of april the linux repository has over commits which rules out manual investigation of each commit.
we have thus searched through the commits for variability bugs using the following steps .selecting variability related commits.
we retain commits matching regular expressions of fig.
.
expressions in fig.
a identify commits in which the author s message relates the commit to speci c features.
those in fig.
b identify commits introducing changes to the feature mapping or the feature model.
we reject merges as such commits do not carry changes.
this step selects in the order of tens of thousands of commits.
.selecting bug xing commits.
we narrow to commits that x bugs matching regular expressions that indicate bugs within the commit message see fig.
.
depending on the keywords of interest this step may select from thousands of commits to only a few tens or less.
.manual scrutiny.
we read the commit message and inspect the changes introduced by the commit to remove obvious false positives.
we order commits by the number of hits in the rst two searches and down prioritize very complex commits given the information provided in the commit message and the number of lines modi ed by the patch .
part analysis.
the second part of the methodology is signi cantly more laborious than the rst part.
for each variability bug identi ed we manually analyze the commit message the patch x and the actual code to build an understanding of the bug.
when more context is required 423we nd and follow the associated lkml discussion.
code inspection is supported by ctags5and the unix grep utility since we lack feature sensitive tool support.
.the semantics of the bug.
for each variability bug we want to understand the cause of the bug the e ect on the program semantics and the relation between the two.
this often requires understanding the inner workings of the kernel and translating this understanding to general programming language terms accessible to a broader audience.
as part of this process we try to identify a relevant runtime execution trace and collect links to available information about the bug online.
.variability related properties.
we establish what is the presence condition of a bug precondition in terms of con guration choices and where it was xed in the code in the feature model or in the mapping .
.simpli ed version.
last but not least we condense our understanding in a simpli ed version of the bug.
this serves to explain the original bug and constitutes an interesting benchmark for evaluating tools.
we analyzed linux bugs from the previous step following this method and stored the created reports in a publicly available database.
we were looking for a su ciently diverse sample and stopped at bugs once it became possible to answer our two research questions.
the detailed content of the report is explained in sect.
.
part data analysis and veri cation.
we re ect on the collected data set in order to nd answers to our research questions.
this step is supported with some quantitative data but importantly we do not make any quantitative conclusions about the population of the variability bugs in linux such conclusions would be unsound given the above research method .
it purely characterizes diversity of the data set obtained.
this allows to present the entire collection of bugs in an aggregated fashion see sect.
.
finally in order to reduce bias we confront our method ndings and hypotheses in an interview with a full time professional linux kernel developer.
.
dimensions of analysis we begin by selecting a number of properties of variability bugs to understand analyze and document in bug reports.
these are described below and exempli ed by data from our database.
we show an example record in fig.
a null pointer dereference bug found in a driver which was traced back to errors both in the feature model and the mapping.
type of bug type .in order to understand the diversity of variability bugs we establish the type of bugs according to thecommon weakness enumeration cwe a catalog of numbered software weaknesses and vulnerabilities.
we follow cwe since it was applied to the linux kernel before .
however since cwe is mainly concerned with security we had to extend it with a few additional types of bugs including type errors incorrect uses of linux apis etc.
the types of bugs in the obtained taxonomy are listed in tbl.
our additions lack an identi er in the rightmost column.
the types directly indicate what kind of analysis and program veri cation techniques can be used to address the bugs identi ed in the kernel.
for instance the category of memory errors tbl.
maps almost directly to various program analyses for null pointers bu er overruns memory leaks etc.
bug description descr .understanding a bug requires rephrasing its nature in general software engineering terms so that the bug becomes understandable for non kernelexperts.
we obtain such a description by studying the bug in depth and following additional available resources such as mailing list discussions available books commit messages documentation and online articles .
whenever use of the linux terminology is unavoidable we provide links to the necessary background.
obtaining the description is often non trivial.
for example one bug in our database commit eb91f1d0a53 was xed with the following commit message fixes the following warning during bootup when compiling with config slab warning at kernel lockdep.c lockdep trace alloc 0x91 0xb9 hardware name modules linked in pid comm swapper not tainted .
.
call trace ?
lockdep trace alloc 0x91 0xb9 ... it is summarized in our database as warning due to a call to kmalloc with ags gfp wait and interrupts enabled theslab allocator is initialized by start kernel with interrupts disabled.
later in this process setup cpu cache performs the per cpu kmalloc cache initialization and will try to allocate memory for these caches passing the gfp kernel ags.
these ags include gfp wait which allows the process to sleep while waiting for memory to be available.
since as we said interrupts are disabled during slab initialization this may lead to a deadlock.
enabling lockdep and other debugging options will detect and report this situation.
we add a one line header to the description here shown in bold to help identi cation and listing of bugs.
program con gurations config .in order to con rm that a bug is indeed a variability bug we investigate under what presence condition it appears.
this allows to rule out bugs that appear unconditionally and enables further investigation of variability properties of the bug for example the number of features and nature of dependencies that enable the bug.
our example bug is present when decr is enabled butincr is disabled.
the linux bug captured in fig.
b requires enabling twl4030 core and disabling of irq in order to exhibit the erroneous behavior see config entry in the left part .
bug fix layer layer .we analyze the xing commit to establish whether the source of the bug is in the code in the feature model or in the mapping.
understanding this can help direct future research on building diagnostics tools are tools needed for analyzing models mappings or code?
where is it best to report an error?
the bug of fig.
4has been xed both in the model and in the mapping cf.
fig.
.
the xing commit asserts that rst twl4030 core should not depend on irq domain xed in the model and second that the assignment of the variable opsto irq domain simple ops is part of the irq domain code and not of of irq xed in the mapping .
error trace trace .we manually analyze the execution trace that leads to the error state.
slicing tools cannot easily 424type null pointer dereference descr null pointer on !
of irq gets dereferenced if irq domain .
intwl4030 driver attempt to register an irq domain with a null ops structure ops is de referenced when registering an irq domain but this field is only set to a non null value when of irq .
config twl4030 core !of irq bugfix repo git git.kernel.org pub ... linux stable.git hash 6252547b8a7acced581b649af4ebf6d65f63a34b layer model mapping trace .
dyn call drivers mfd twl core.c twl probe .
irq domain add domain .. call kernel irq irqdomain.c irq domain add ... call include linux irqdomain.h irq domain to irq ... error if d ops to irq links a bug record.
include stdlib.h ifdef config twl4030 core enabled define config irq domain endif ifdef config irq domain enabled int irq domain simple ops void irq domain add int ops !
int irq ops error endif ifdef config twl4030 core enabled void twl probe !
int ops null ifdef config of irq disabled j ops irq domain simple ops j endif j irq domain add ops !
endif int main void ifdef config twl4030 core enabled twl probe !
endif b simpli ed version.
figure bug 6252547b8a7 a record example and a simpli ed version.
include stdlib.h ifdef config twl4030 core define config irq domain endif ifdef config irq domain int irq domain simple ops ifdef config twl4030 core void twl probe ifdef config irq domain int ops null ifdef config of irq ops irq domain simple ops irq domain add ops endif irq domain add ops endif figure fix for simpli ed bug 6252547b8a7 .
the patch is given in uni ed di format diff u2 .
be used for these purpose as none of them is able to handle static preprocessor directives appropriately.
constructing a trace allows us to understand the nature and complexity of the bug.
a documented failing trace allows other researchers to understand a bug much faster.
there are two types of entries in our traces function calls and statements.
function call entries can be either static tagged call or dynamic dyn call if the function is called via a function pointer.
a statement entry highlights relevant changes in the program state.
every entry starts with a nonempty sequence of dots indicating the nesting of function calls followed by the location of the function de nition le and line or statement only the line .
the statement in which the error is manifested is marked with an error label.
in fig.
a the trace starts in the driver loading function twl probe .
this is called from i2c device probe at drivers i2c i2c core.c the generic loading function fori2c7drivers through a function pointer driver probe .
a call to irq domain add passes the globally declared struct domain by reference and the ops eld of this struct now aliased as d is dereferenced d ops to irq .
the ops eld of domain is not explicitly initialized so it has been set to null by default as dictated by the c standard .
thus the above error trace unambiguously identi es a path from the loading of the driver to a null pointer dereference when of irq is disabled.
had of irq been enabled the ops eld would have been properly initialized prior to the call to irq domain add .
simpli ed bug.
last but not least we synthesize a simpli ed version of the bug capturing its most essential properties.
we write a small c99 program independent of the kernel code that exhibits the same essential behavior and the same problem .
the obtained simpli ed bugs are easily accessible for researchers willing to try program veri cation and analysis tools without integrating with the linux build infrastructure huge header les and dependent libraries and most importantly without understanding the inner workings of the kernel.
furthermore the entire set of simpli ed bugs constitute an easily accessible benchmark suite derived from real bugs occurring in a large scale software system which can be used to evaluate bug nding tools in a smaller scale.
simpli ed bugs are derived systematically from the error trace.
along this trace we preserve relevant statements and controlow constructs mapping information and function calls.
we keep the original identi ers for features functions and variables.
however we abstract away dynamic dispatching via function pointers struct types void pointers casts and any linux speci c type when this is not relevant for the bug.
when there exist dependencies between features we force valid con gurations with define .
this encoding of feature dependencies has the advantage of making the simpli ed bug les self contained.
7a serial bus protocol used in micro controller applications.
425figure b shows the simpli ed version of our running example bug with null pointer dereference.
lines encode a dependency of twl4030 core onirq domain in order to prevent the invalid con guration twl4030 core irq domain .
we encourage the reader to study the execution trace leading to a crash by starting from main at line .
this takes a mere few minutes as opposed to many hours necessary to obtain an understanding of a linux kernel bug normally.
note that the trace is to be interpreted under the presence condition from the bug record decisions are speci ed in comments next to the ifconditionals .
traceability information.
we store the url of the repository in which the bug x is applied the commit hash and links to relevant context information about the bug in order to support independent veri cation of our analysis.
.
data analysis in order to address the research questions we have re ected on the entire body of information gathered arriving at detailed observations presented below.
in the following we sometimes aggregate data with numbers.
the numbers are used solely for descriptive purposes no statistical conclusions should be drawn from them we emphasize this using a gray font .
we start by presenting the observations that support our rst research question rq1 observation variability bugs are not limited to any particular type of bugs.
table 1lists the type of bugs we found along with occurrence frequencies in the collection.
for example bugs have been classi ed under the category of memory errors four of which are null pointer dereferences.
we note that variability bugs cover a wide range of qualitatively di erent types of bugs from table types of bugs among the bugs.
the rst column gives the frequency of these bugs in our collection.
memory errors cwe id null pointer dereference 3bu er over ow 3read out of bounds 2insu cient memory 1memory leak 1use after free 1write on read only compiler warnings cwe id uninitialized variable 2incompatible types 1unused function dead code 1unused variable 1void pointer dereference 7type errors cwe id unde ned symbol 1undeclared identi er 1wrong number of args to function 7assertion violations cwe id fatal assertion violation 2non fatal assertion violation 2api violations cwe id linux sysfs api violation 1double lock 1arithmetic errors cwe id numeric truncation 197drivers 0m arch 0m fs 801k sound 595k net 583k include 372k kernel 139k lib 66k mm 63k crypto 62k security 49k block 21k smaller virt 8k ipc 4k init 0k and usr 6k .
infrastructure tools 102k scripts 44k and samples 1k .
figure location of the bugs in the main linux directories as of march .
each square represents thousand lines of code.
the precise number of loc and its percentage of the total is given below the squares.
a red dark square symbolizes the occurrence of one of the bugs.
type errors through dataow errors such as uninitialized variables to locking policy violations double locks .
we found bugs type errors and compiler warnings caught by the compiler at build time.
despite the compiler checks the bugs had been admitted to the repository in the rst place.
since compiler errors cannot easily be ignored we take this as evidence that the author of the commit and the maintainer who accepted it could not nd the bug because they compiled the code in con gurations that do not exhibit it compiler checks are not family based .
observation variability bugs appear to not be restricted to speci c error prone features.
table 2shows the complete list of features involved in the bugs a total of qualitatively di erent features ranging from debugging options e.g.
quota debug and lockdep todevice drivers e.g.
twl4030 core andandroid to network protocols e.g.
vlan 8021q and ipv6 to computer architectures e.g.
parisc and 64bit .
three features are involved in three of the bugs nine features occur in two bugs and the remaining are involved in only a single bug.
table features involved in the bugs.
64bi t ipsct p s390 acpi vid eo jffs2 fswbu fveri fy s390 prng a cpiwmi k gdb sctp db gms g amiga z2ram k probes security android ktime sca lar shmem arch omap lbdaf slab arch opam lockdep slob arm lp ae mach omap h4 sm p backlight clas sdevi ce module unlo ad snd fsiak4642 b cm47xx netpoll snd fsida7210 b diswi tch numa ssbdri ver exti f bf60x of stub poul sbo blk cgr oup ofir q sysfs crypto bl kcipher parisc tcp md5 sig crypto tes t pci tmpfs devpts mul tiple ins tances pm trace ir qflags discontigmem ppc64 tracing drm i915 p pc256k pa ges tree rc u ep93xx eth p reempt twl4030 core e xtcon proc pa gemoni tor unix98 ptys f orce max zone order prove lock ing vlan 8021q hig hmem quota deb ug vortex hotplug rcu cpu st allinf o x86 i2c rcu fas tnohz x8 ios ched cfq re gulator max86 xmon ipv6 reiserfs fssec urity zone dma 426observation variability bugs are not con ned to any speci c location le or kernel subsystem .
figure 6shows in which subsystems the bugs are located and the relative size of each subsystem as of march we approximate subsystems by directories.
the size of each subsystem is measured in lines of code loc we take the sum of loc for any language as reported by cloc8 version .
.
e.g.
with six squares the kernel subsystem has approximately kloc and represents about of the linux code.
superimposed onto the size visualization the gure also shows in which directories the bugs occur.
with ve red dark squares the directory kernel thus houses ve of the bugs of our collection.
we found bugs in ten of the main linux subsystems showing that variability bugs are not con ned to any speci c subsystem.
these are qualitatively di erent subsystems of linux ranging from networking net to device drivers drivers block to lesystems fs or encryption crypto .
note that linux subsystems are often maintained and developed by di erent people which adds to diversity of our collection.
we found no bug in nine directories representing less than the of the linux kernel code in total.
further three of them tools scripts and samples contain example and support code build infrastructure diagnostic tools etc.
that does not run on a compiled kernel.
we are now ready to answer rq1 conclusion variability bugs are indeed not con ned to any particular type of bug error prone feature or location in the linux kernel.
we have found variability bugs falling in di erent types of semantic errors involving qualitatively di erent features and located in major subsystems of the linux kernel.
we now turn to evidence regarding research question rq2 observation we have identi ed bugs that involve non locally de ned features i.e.
features that are remotely de ned in another subsystem than where the bug occurred.
understanding such bugs involves functionality and features from di erent subsystems while most linux developers are dedicated to a single subsystem.
for example bug6252547b8a7 occurs in the drivers subsystem but one of the interacting features irq domain is de ned inkernel .
bug 0dc77b6dabe which occurs in the loading function of the extcon class module drivers is caused by an improper use of the sysfs virtual lesystem api feature sysfs infs .
we con rmed with a linux developer that cross cutting features constitute a frequent source of bugs.
observation variability can be implicit and even hidden in alternative con guration dependent macro function or type de nitions speci ed in potentially di erent header les.
hidden variability signi cantly complicates the identi cation of variability related problems.
for example in bug 0988c4c7fb5 function vlan hwaccel do receive is called if a vlan tagged network packed is received.
this function however has two di erent de nitions depending on whether feature vlan 8021q is present or not.
variants without vlan 8021q support are compiled with a mockupimplementation of this function that unconditionally enters codemappingmodelcodemappingmodelcodemappingmodelcodemappingmodelcodemappingmodel bugs figure in which layer s are the bugs xed.
an error state.
another example is bug 0f8f8094d28 which can be regarded as a trivial out of bounds access to an array except that the length of the array kmalloc shift high is architecture dependent and only the powerpc architectures for a given virtual page size are a ected.
both vlan hwaccel do receive and kmalloc shift high have alternative de nitions at di erent locations.
observation variability bugs are xed not only in the code some are xed in the mapping some are xed in the model and some are xed in a combination of these.
figure 7shows whether the bugs in our sample were xed in the code mapping or model .
even though we only documented bugs that manifested in code bugs in our sample were xed in the mapping in the model or in two layers.
examples of simple xes in the mapping and in the model are commits 472a474c663 and 7c6048b7c83 respectively.
the former adds a new ifndef to prevent a double call to apic init uniprocessor which is not idempotent while the latter modi es stub poulsbo skconfig entry to prevent a build error.
bug x 6252547b8a7 removes a feature dependency twl4030 core no longer depends on irq domain and changes the mapping to initialize the struct eld ops when irq domain rather than of irq is enabled.
an example of multiple x in mapping and code is commit 63878acfafb which removes the mapping of some initialization code to feature pm power management and adds a function stub.
this strati cation into code mapping and model may obscure the cause of bugs because an adequate analysis of a bug requires understanding these three layers.
further each layer involves di erent languages in particular for linux the code is c the mapping is expressed using both cpp andgnu make and the feature model is speci ed using kconfig.
presumably this complexity may cause a developer to x a bug in the wrong place.
for instance the dependency oftwl4030 core onirq domain removed by our bug x 6252547b8a7 was added by commit aeb5032b3f8 .
apparently aeb5032b3f8 introduced this dependency into the feature model to prevent a build error so to x a bug but this had undesirable side e ects.
according to the message provided in commit 6252547b8a7 the correct x to the build error was to make a variable declaration conditional on the presence of feature irq domain .
observation we have identi ed as many as feature interaction bugs in the linux kernel.
we de ne the feature interaction degree of a bug or just degree of a bug as the number of individual features occurring in its presence condition.
intuitively the degree of a bug degree degree degree degree degree bugs variability bugs feature interaction bugs figure numbers of features involved in a bug feature interaction degree .
indicates the number of features that have to interact so that the bug occurs.
a bug present in any valid con guration is a bug independent of features or a degree bug.
bugs with a degree greater than zero are variability bugs thus occurring in a nonempty strict subset of valid con gurations.
particularly if the degree of a bug is greater than one the bug is caused by the interaction of two or more features.
a software bug that arises as a result of feature interactions is referred to as a feature interaction bug.
feature interaction bugs are inherently more complex because the number of variants to be considered is exponential in the degree of the bug.
bug 6252547b8a7 cf.
fig.
b is the result of a two feature interaction.
the code slice containing the bug involves three di erent features and represents four variants corrected for the feature model but only one of the variants presents a bug.
the opspointer is dereferenced in variants with twl4030 core enabled but it is not properly initialized unless of irq is enabled.
a developer searching for this bug needs to either think of each variant individually or consider the combined e ect of each feature on the value of the opspointer.
none of these are easy to execute systematically even in a simpli ed scenario and outright infeasible in practice as con rmed by a professional linux developer.
feature interactions can be extremely subtle when variability a ects type de nitions.
commit 51fd36f3fad xes a bug in the linux high resolution timers mechanism due to a numeric truncation error that only happens in bit architectures not supporting the ktime scalar feature.
in these particular con gurations ktime t is a struct with two bit elds instead of a single bit eld used to store the remaining number of nanoseconds to execute the timer.
the bug occurs on attempt to store some large bit value in one of these bit elds causing a negative value to be stored instead.
interestingly one of the linux developers we interviewed also mentioned the di culty to optimize for cache misses due to variability in the alignment of struct elds.
observation we have identi ed bugs involving three or more features.
an example of a degree bug is ae249b5fa27 caused by the interaction of discontigmem e cient handling of discontiguous physical memory support in pa risc architectures feature parisc and the ability to monitor memory utilization through the proc virtual lesystem feature proc page monitor .
we also found degree bugs such as commit 221ac329e93 caused by bit powerpc architectures not disabling kernel memory write protection when kprobes isenabled a dynamic debugging feature that requires modifying the kernel code at runtime.
figure 8summarizes the degree of our bugs.
to the best of our knowledge this is the rst documented collection of feature interaction bugs in the operating systems domain.
so far most feature interaction bugs have been identi ed documented and published in telecommunication domain .
observation presence conditions for variability bugs also involve disabled features.
table 3lists and groups the structure of the presence conditions for our sample.
we observe two main classes of bug presence conditions some enabled where one or more features have to be enabled for the bug to occur and someenabled one disabled where the bug is present when enabling zero or more features and disabling exactly one feature.
we identi ed bugs in some enabled con gurations and another bugs in some enabled one disabled .
note that one of the presence conditions has the form a a0 b but since it is implied by either a b ora0 b we include it in the some enabled one disabled class.
testing of highly con gurable systems is often approached by testing one or more maximal con gurations in which as many features as possible are enabled in linux this is done using the prede ned con guration allyescon g .
this strategy allows to nd many bugs with some enabled presence conditions simply by testing one single maximal con guration.
but if negated features occur in practice as often as in our sample then testing maximal con gurations only will miss a signi cant amount of bugs.
in our experience the implementation of features in linux is crosscutting many code locations and features code is intermixed.
as a result disabling a feature can both add or delete code from another feature and we expect negated features to be often part of bugs presence conditions.
bug 6252547b8a7 is such an example.
disabling of irqcauses the null pointer dereference because this feature is responsible for initializing the opsstruct eld.
another example is bug 60e233a5660 where the implementation of a function add uevent var when feature hotplug is disabled fails to preserve an invariant causing a bu er over ow.
observation e ective testing strategies exist for the observed bug presence conditions.
given the observed patterns some enabled andsome enabledone disabled in tbl.
we can think of a better testing table the structure of the presence conditions i.e.
in which con gurations the bugs occur .
some enabled 6a 8a b 5a b c 0a b c d 1a b c d e some enabled one disabled a 13a b one of which is a a0 b 3a b c 0a b c d 1a b c d e 2other con gurations a b 1a b c d e 428strategy than maximal con guration testing.
we propose aone disabled con guration testing strategy where we test con gurations in which exactly one feature is disabled corresponding to the formulas 8g2f v f2fnfg gf g. table compares the two strategies maximal con guration testing and one disabled con guration testing.
we also add an entry for exhaustive testing of all con gurations serving as a baseline the cost is exponential there .
maximal con guration testing has constant cost ideally only one con guration has to be tested and thus scales to program families with an arbitrarily large number of features f .
it appears to be a fairly good heuristic of bugs in our sample out of could be found this way.
onedisabled con guration testing has a linear cost on jfj thus it is reasonably scalable even for program families with thousands of features like linux.
remarkably of our bugs out of could be found by testing the jfjonedisabled con gurations.
note that these con gurations also nd the bugs with a some enabled presence condition except for hypothetical cases requiring allfeatures enabled .
in practice we must consider the e ect of the feature model in the testing strategy.
due to mutually exclusive dependencies between features there is often no maximal con guration but many locally maximal con gurations.
moreover because some features depend on others to be present we often cannot disable features individually.
the practical consideration of having a feature model is that enumerating the con gurations to test requires selecting valid con gurations only which is a np complete problem itself.
yet we expect that enumerating valid one disabled con gurations would be tractable given the scalability of modern sat solvers hundreds of thousands of variables and clauses and the size of real world program families only thousands of features .
let us answer rq2 now.
it is a well known fact that an exponential number of variants makes it di cult for developers to understand and validate the code but conclusion in addition to introducing an exponential number of program variants variability additionally increases the complexity of bugs in multiple ways.
our analysis indicates that variability a ects the complexity of bugs along several dimensions.
let us summarize them bugs occur because the implementation of features is intermixed leading to undesired interactions for instance through program variables interactions occur between features from di erent subsystems demanding cross subsystem knowledge from linux developers table maximal vs one disabled con guration testing.
the cost is the number of con gurations satisfying the formula disregarding the feature model.
bene t shown as bug coverage for our sample.
test formula s cost bene tv f2ff o 8g2f v f2fnfg gf g o jfj o 2jfj variability may be implicit and even hidden in alternative macro function and type de nitions speci ed at spare locations variability bugs are the result of errors in the code in the mapping in the feature model or any combination thereof further each of these layers involves di erent languages c cpp gnu make andkconfig not all these bugs will be detected by maximal con guration testing due to interactions with disabled features the existence of compiler errors in the linux tree shows that conventional feature insensitive tools are not enough to nd variability bugs.
.
threats to validity .
internal validity bias due to selection process.
as we extract bugs from commits our collection is biased towards bugs that were found reported and xed.
since users run a small subset of possible linux con gurations and developers lack featuresensitive tools potentially only a subset of bugs is found.
further our keyword based search relies on the competence of linux developers to properly identify and report variability in bugs.
note however that in linux variability is ubiquitous and often hidden .
for instance the ath3k bluetooth driver module le contains no explicit variability yet after variability preserving preprocessing and macro expansion we can count thousands of cppconditionals involving roughly features.
it is then unlikely that developers are always aware of the variability nature of the bugs they x. in order to further minimize the risk of introducing false positives we do not record bugs if we fail to extract a sensible error trace or if we cannot make sense of the pointers given by the commit author.
this may introduce bias towards reproducible and lower complexity bugs.
because of inherent bias of a detailed qualitative analysis method we are not able to make quantitative observations about bug frequencies and properties of the entire population of bugs in the linux kernel.
note however that we are able to make qualitative observations such as the existential con rmation of certain kinds of bugs cf.
sect.
.
since we only make such observations we do not need to mitigate this threat interestingly though our collection still exhibits very wide diversity as shown in sect.
.
false positives and overall correctness.
by only considering variability bugs that have been identi ed and xed by linux developers we mitigate the risk of introducing false positives.
we only take bug xing commits from the linux stable branch the commits of which have been reviewed by other developers and particularly by a more experienced linux maintainer.
in addition our data can be independently veri ed since it is publicly available.
the risk of introducing false positives is not zero though for instance commit b1cc4c55c69 adds a nullity check for a pointer that is guaranteed not to be null9.
it is tempting to think that the above indicates a variability bug while in fact it is just a conservative check to detect a potential bug.
the manual analysis of a bug to extract an error trace is also error prone especially for a language like c and a 429complex large system such as linux.
ideally we should support our manual analysis with feature sensitive program slicing if it existed.
a more automated approach based on bug nders would not be satisfactory.
bug nders are built for certain classes of errors so they can give good statistical coverage for their particular class of errors but they would not be able to assess the diversity of bugs that appear.
we derive simpli ed bugs based on manual slicing ltering out irrelevant statements.
we also abstract away c language features such as structs and dynamic dispatching via function pointers.
while the process is systematic it is performed manually and consequently error prone.
.
external validity small number of bugs.
the size of our sample speaks against the generalizability of the observations.
the process of collecting and especially analyzing these bugs costed several man months being unfeasible the study of a larger number of bugs.
we expect that our database will continue to grow also from third party contributions in the near future.
single subject study.
we decided to focus exclusively on linux so our ndings do not readily generalize to other highly con gurable software.
yet the size and nature of linux make it a fair worst case representative of software with variability.
the type of bugs we found especially memory errors are expected in any piece of con gurable system software implemented in c. in addition the signi cance of the linux kernel project itself justi es investigation of its errors even if it limits generalizability.
.
related work bug databases.
claburedb is a database of bug reports for the linux kernel with similar purpose to ours albeit ignoring variability.
unlike claburedb we provide a record with information enabling non experts to rapidly understand the bugs and benchmark their analyses.
this includes a simpli ed c99 version of each bug were irrelevant details are abstracted away along with explanations and