behavioral validation of jfsl specifications through model synthesis carlo ghezzi politecnico di milano deepse group dei p.za l. da vinci milano mi italy ghezzi mocci elet.polimi.itandrea mocci massachusetts institute of technology csail vassar st. cambridge ma usa am csail.mit.edu abstract contracts are a popular declarative specification technique to describe the behavior of stateful components in terms of pre post conditions and invariants.
since each operation is specified separately in terms of an abstract implementation it may be hard to understand and validate the resulting component behavior from contracts in terms of method interactions.
in particular properties expressed through algebraic axioms which specify the effect of sequences of operations require complex theorem proving techniques to be validated.
in this paper we propose an automatic smallscope based approach to synthesize incomplete behavioral abstractions for contracts expressed in the j fsl notation.
the proposed abstraction technique enables the possibility to check that the contract behavior is coherent with behavioral properties expressed as axioms of an algebraic specifications.
we assess the applicability of our approach by showing how the synthesis methodology can be applied to some classes of contract based artifacts like specifications of data abstractions and requirement engineering models.
keywords contracts specifications model synthesis behavioral validation i. i ntroduction and motivations abstraction is a fundamental conceptual tool in software design it is a many to one mapping activity that separates at a given level of analysis relevant aspects from the irrelevant ones.
in particular abstraction by specification decouples the description of the behavior of a software artifact the specification from the details concerning its implementations.
declarative specifications are a popular approach to describing software behavior through properties formally expressed in logic.
for example j ml is a declarative specification language for j ava classes based on first order logic.
a more recent one the jf orge specification language jfsl is based on relational logic.
both are based on the concepts of pre post conditions andinvariants .
pre and post conditions are very suitable for the specification of procedural abstractions such as array sorting.
a pre condition states the conditions on which the procedural abstraction is defined.
a post condition describes a condition that is guaranteed after the execution of the procedure if the precondition holds before the invocation.
a pre postcondition pair constitutes a contract for the procedural abstraction.
pre and post conditions can be also used to specify data abstractions that is components that hide the specfield elems seqobject size int invariant this.size this.size this.elems public class stack requires len ensures this.size this.elems len throws exception len public stack intlen ... requires this.size this.elems ensures this.size old this.size this.elems old this.elems old this.size i modifies this.elems this.size throws exception this.size this.elems public void push object i ... requires this.size ensures this.size old this.size modifies this.size throws exception this.size public void pop ... requires this.size returns this.elems throws exception this.size pure public object top ... requires true returns this.size pure public int size ... requires true returns this.elems pure public int len ... figure .
a j fslspecification for a stack of object internal state which is only visible through the invocation of methods .
in a contract based specification of a data abstractions every method is seen as a procedural abstraction and specified through pre and post conditions.
however since data abstractions are stateful components contracts must take into account how the internal state affects the behavior of methods.
the common solution is to represent the state by using an abstract model composed of mathematical entities like sets or sequences.
furthermore invariants are used to define the constraints on the abstract model that define legal data abstractions.
for a given data abstraction its contract is the set of invariants and methods pre and post conditions.
figure shows a contract specification for a bounded stack of elements written in the j fsl notation represented as a sequence of elements and an integer value representing the stack size.
contract based specifications are easy to produce because they use mathematical entities that are similar to programming entities like variables and arrays.
unfortunately however they are hard to validate in terms of the prescribed effects of operation interactions.
the mutual relations among methods are hard to understand in particular how they affect each other the order in which they must be executed and the data they return.
for example given the contract in figure .
c ieee icse zurich switzerland stack size top squigglerightexception len stack stack size top a len 2stack size top b len stack size top b len 2stack size top a len 2stack size top b len stack size top a len 2pop push a push b push a push b push a push b push a push b push a push b push a pop pop pop push b push b push a pop pop pop figure .
a b emof stack.
quote marks are omitted from string literals.
it is not straightforward to prove that after a push invocation it is always possible to invoke pop.
moreover it is even harder to validate the contract against its main behavioral property that is the expected lifo behavior.
this property can be easily represented in an equational style for example by using an axiom of an algebraic specification stating that for every possible non full stack sand every possible object to be inserted invoking popmafterpush m both denoting the modifier behavior of respective methods produces a stack which is equivalent to s s stack e object popm push m s e a1 ifsizeo s len o s thenselsepopm s in a1 observe that since a method may modify the internal state i.e.
be a modifier likepush and or return a value i.e.
be an observer likesize we use subscripts mand oto indicate the kind of behavior.
a difficulty here is that the semantics of the operator in axioms like a1 makes it hard to perform behavioral validation.
in fact equality refers to the abstract state defined by the data abstraction not to the abstract implementation used in the contract for which the property does nothold.
for example popm push m stack a andpopm push m stack b represent the same abstract stack the empty one but the states of the abstract implementation after the invocations are different respectively angbracketleftelems size angbracketrightand angbracketleftelems size angbracketright.
in this paper we propose a technique to enable validation of behavioral properties like the ones in axiom a1 for contracts expressed in the j fsl notation.
the level of abstraction we adopt is the one induced from behavioral equivalence .
intuitively behavioral equivalence abstracts two possible legal states c1andc2to the same abstract state if their externally observable behavior is equivalent that is no sequence of methods ending with an observer returns a different value if it is invoked starting from c1or from c2.
considering the previous stack example all states where size andelems contains any tuple of objects would be behaviorally equivalent and would represent the abstract notion of an empty stack.
the behavioral equivalence definition given above does not provide an efficient constructive method to check algebraic axioms against declarative specifications.
to check equivalence of two states one should in fact enumerate all possible sequences of operations explicitly and thus all reachable abstract states which is unfeasible.
in a previous work we proposed a method to check algebraic axioms against a particular class of behavior models called behavioral equivalence models bems whose states exactly represent behaviorally equivalent classes of states.
the approach we propose here builds on our past work and validates a contract by first synthesizing a b emand then validating it against the algebraic axioms.
figure shows a b emfor the s tack contract.
in a bem every state is labeled with observer return values and transitions represent method invocations with concrete values for parameters.
the level of abstraction of this model is exactly the one needed to check axiom a1 .
in fact by interpreting axiom equality as behavioral equivalence we can check if the sequence of push andpopin the b emis a loop.
however b ems are not complete they describe in a precise way a subset of all the possible behaviors of the component.
this is a common trade off we lose the ability to model every possible behavior of the component in favor of an adequate level of precision that enables behavioral analysis such as the check of axiom a1 .
in this paper we leverage our knowledge about b em synthesis for black box components through dynamic analysis b emvalidation the theory of hidden algebraic specifications and the analysis within small scopes to show how b ems can be synthesized via static analysis on j fsl specifications and how these models can be used for automatic behavioral validation.
in particular we show how to extract synthetic but precise models of contracts expressed with the j fsl notation and how these models can be automatically checked against behavioral properties expressed by algebraic axioms.
the paper is structured as follows.
section ii illustrates background concepts that is j fsl contracts and outlines the hidden algebraic approach for the specification of data abstractions whose theoretical results are the basis for our synthesis approach.
section iii illustrates the behavioral abstraction technique and the construction of b ems while section iv briefly illustrates the b emvalidation approach we proposed in .
section v outlines related work and identifies approaches that can be used together with the proposed one.
as an assessment of the presented method section vi shows how it can be used to validate contracts937that specify data structures and requirement artifacts.
finally in section vii we present the conclusions and future work.
ii.
b ackground concepts this section introduces the background concepts used within the proposed validation approach.
we start by describing the j fsllanguage then we formally introduce some concepts borrowed from the hidden approach to algebraic specifications and finally we describe and formalize b ems.
a. jfsl contracts the jf orge specification language jfsl can be viewed as an application of a lloy s relational logic to specify j ava programs by means of contracts.
j fsl is the notation we use for our contract abstraction approach.
we assume the reader to be familiar with the basic concepts of relational logic and the a lloy language .
in the following we will focus on the most important aspects of jfsland the related a lloy analysis.
since they are both based on first order logic with relational operators j fsl and a lloy are inherently undecidable .
the typical kind of analysis supported by both approaches is incomplete but leverages the small scope hypothesis to justify its practical validity.
essentially they both support instance finding .
this analysis consists of either checking the consistency of the declared facts or checking them against an external assertion by looking for a refutation against a finite set of possible assignments to variables which constitute the scope of the analysis.
if a particular assignment is found it is reported as a counterexample obviously if the counterexample is not found within the given scope one cannot be sure that the assertion also holds outside the considered scope.
the small scope hypothesis provides a practical justification that notfinding a counterexample inside an analysis scope gives some relevant confidence on the validity of the checked assertion in the whole state space.
essentially the hypothesis states that most bugs have small counterexamples that is if the checked assertion is invalid it is very likely that it has a small counterexample namely a counterexample that can be found in a small scope.
the j fslspecification approach is reminiscent of e iffel contracts and the j mllanguage .
it provides a set of j ava annotations that decorate class and method declarations.
the two main class annotations are the following i specfield declares a specification field that is a field modeling the state of the data abstraction ii invariant an expression that declares which specification field values are legal for the data abstraction.
essentially a specification field can be of any type supported by a lloy like integer tuple or sequence of objects.
for each method the specification can be provided with the following annotations i requires and ensures that specify the method pre and post condition respectively ii modifies which specifies the method frame conditions that is it contains a list of specification fields that can be modified by the method and pure which declares that the method has no side effects iii throws which declares exceptional results its argument format is exceptionname cond where cond is the condition on which the exception is thrown.
for exceptional behaviors we assume that the values of specification fields are not changed iv returns which declares the return value the argument describes the value to be returned.
if a method modifies a field x the post condition can refer to its value in the prestate with the old x notation.
expressions contain the special this variable which refers to the instance on which the method is called.
the behavior specified by the returns clause imposes that a special variable called return is bounded to the specified expression.
similarly a special variable throw models the possible thrown exception as specified by the throws clause.
b. hidden algebraic signatures we now introduce the essential concepts of the hidden algebraic approach to software specification upon which we base our method to synthesize b ems from j fsl contracts.
in the field of algebraic specifications a data abstraction is a mathematical entity that corresponds to an algebra i.e.
one or more sets closed under a set of operations .
the syntactic part of the data abstraction is defined by an algebraic signature which defines the domain and codomains of the operations.
a data abstraction is used to define a new data type that represents the component to be specified.
in this context there is a very important distinction between the kind of data to be defined and the data used to communicate with the component s clients.
usually the communication from the component to its clients occurs through operations that return data values whose semantics is shared between the client and the component.
following the hidden algebraic approach for software specification data types used for interaction are called visible data types .
we assume the reader to be familiar with basic algebraic notions like sorted set signature term and algebra .
let be the set of visible data types where vis a set of sorts defining the types.
a hidden signature over defininghis a pair h angbracketlefth angbracketrightwherehis the hidden type defined by the signature and is a set of functional symbols describing the signatures of operations.
each functional symbol identifies an operation of the data abstraction each operation has a domain and a range .
in this paper we consider a particular class of signatures the linear signatures that can be easily used as signatures for state machines.
within this class the set of operations can be split in three different disjoint sets that is k wherekis the set938ofconstructors is the set of modifiers and is the set of observers .
an operation is a constructor when the range is h moreover we restrict the signature to contain exactly one constructor.
another requirement is that only the first type in the domain of observers and modifiers is h all the other types are the parameters of the operation.
this constraint explicitly excludes operations that have has a parameter.
we define a modifier as an operation where the range is h and an observer as an operation where the range is in .
when an operation plays both the role of an observer and a modifier we consider those behaviors as two different functional symbols in .
moreover we model exceptions as special values of the range of observers.
given a hidden signature h acontext is a term with a single occurrence of a variable usually called z in place of an argument that would be of type h and whose last operation is an observer.
for example given the signature of stack as specified in figure pop push stack a is a term while top pop z is a context.
behavioral equivalence can be defined using contexts as follows.
given a hidden signature h and a hidden algebra aover h then the behavioral equivalence on a denoted asb is defined as i the identity on visible data types that is ab biffa bwhena bare of a sort vinv ii ab b iffac a ac b for all contexts c whena bare of type h whereacis a function interpreting the context cas an operation on the algebra a. a relationb similarequalis a hidden congruence on aif it is a congruence with respect to the operations on hand it is identity on the visible data types.
an important theoretical result presented in is that if two possible states aandb are such that ab similarequalbunder some hidden congruenceb similarequal then they are behaviorally equivalent that is ab b. moreover if we construct a relationo such thatao biff observer return values are equal if invoked for aandb ando is a congruence on modifiers thus we have the guarantee that o b .
the problem is that ofteno is not a congruence with respect to modifiers that is for a modifier m it could be thatao b m a negationslasho m b .
for example by invoking pop on two states of stack that expose the same values for the observers size andtop we could reveal part of the state which was hidden.
thus o must be refined to include context observations that discriminate the behavior that is a set of additional experiments used just for the behavioral abstraction that eventually will constitute a congruence.
the framework of hidden algebra is inherently incomplete .
derivingb in the general case is very hard and requires theorem proving techniques whose automation is difficult.
however since in our case the hidden structure is specified in relational logics and the typical analysis of this kind of structures is instance finding which is incomplete but decidable we can resort to a finite scope analysis to derive a behavioral equivalence relationb .
to perform suchcontract scope build state signature b similarequal o isb similarequala congruence?isclikely iterable?build iterated context abstractionrefineb similarequal b b similarequalbuild b emno context cno yes yes figure .
outline of the synthesis algorithm analysis we formulate the congruence relation synthesis as an a lloy problem.
this is possible and reasonable because j fsland a lloy share the same relational semantics.
in section iii we discuss how the congruence relation relation can be built by analyzing the contract by analyzing specific a lloy problems built from the contract.
iii.
bem s ynthesis from contracts given the theoretical premises illustrated in previous section our research problem has two sources of undecidability i relational logic as supported by j fsl is in general undecidable and ii the framework of hidden algebra that is algebras where equivalence is behavioral equivalence is incomplete.
to overcome this issue we propose an approach that can be classified as a kind of bounded analysis that is an analysis which focuses on a specific finite small scope thus making the analysis decidable.
the small scope hypothesis if taken as an assumption gives a reasonable justification to perform a bounded analysis.
in our case we interpret it as follows i if an algebraic axiom is not valid in a contract a counterexample can be found within a small scope ii it is thus safe to focus on a small scope to derive a behavioral congruence modulo scope synthesize a bem and check it against an algebraic axiom if no counterexample is found then the axiom is likely to be valid.
we do not discuss how to choose the scope for our approach mainly for space reasons and also because it has already been widely discussed in the literature.
in fact we adopt the same guidelines given for a lloy and j fsl .
we can now introduce our algorithm to synthesize a b em from a contract specification expressed in the j fslnotation.
figure illustrates the synthesis algorithm.
first an input to the algorithm is the scope of the analysis.
similar to instance finding approaches like a lloy we require the user to specify i the set of possible values for method parameters ii a bound for integers which specifies the maximum number of bits to represent them iii the maximum length of sequences.
second the signature of the data abstraction defined by the contract is derived from method signatures as follows i every pure observer is an operation in ii every method with void return type and no exceptional behavior is an operation in iii every method with a non void return type or a possible exceptional behavior is modeled by two symbols an observer in and a modifier in .
as for iii the observer behavior can be extracted from the modifier behavior by ignoring the effects on specification fields i.e.
the ensures clause and considering just the returns and or throws clauses of the method specification.
the rationale behind the choice of extracting an observer behavior from an exceptional void method is that this information is something the client could externally observe.
moreover consistently with j fsl semantics we consider operations to be total a violation of specified preconditions is usually modeled as a particular exceptional result called clientfailure .
when a method is specified it is usually meant to terminate possible nonterminating computations can be accommodated by partial methods.
we can now describe how to compute a behavioral congruenceb similarequalstarting fromo that is the equality on observers see figure .
our algorithm computes a candidate congruenceb similarequalstarting from the observer equalityo and then refines it incrementally by computing particular contexts and imposing their equality until a congruence is found.
in the end the resulting congruence is used to build a b em.
since we propose a bounded analysis from now on the derived relations must be intended modulo scope .
for example behavioral equivalence modulo scopeb s denotes behavioral equivalence when method parameters belong to the scope and when contexts are limited to a certain length.
the relationship betweenb andb sdepends on the significance of the scope.
letb sbe defined over the possible abstract states constructible with the given scope s. ideally we want that a b s ab sb ab b that is for every possible context c even outside the scope a b s ab sb a c a ac b .
however such check can be performed only with theorem proving.
in the following we will intend each relation to be implicitly modulo scope.
hereafter we briefly describe how we model a possible state as an a lloy signature.
in the following we illustrate how the congruence check is performed as an a lloy problem and how the candidate relation is refined through the steps of the algorithm.
a. alloy state signature starting from the contract and the scope the algorithm first builds the basic a lloy state signature modeling the behavior of contract specification fields and observers.
an abstract signature state is created whose fields are the specification fields of the contract to be analyzed.
the contract invariant is added as a fact to the state signatureby substituting the variable this with a fresh variable and by universally quantifying it for every possible state .
a similar approach is performed for observer symbols in .
each observer return value and thrown value by an associated exception can be represented as an observer field ofstate signature and the respective values are bound as specified by the observer postconditions.
for example for the topobserver of stack we introduce two observer fields toprandtopt.
thetop postcondition is translated as a fact for state by i quantifying this for allstate ii substituting return andthrow variables asthis.toprandthis.topt.
for example the top observer postcondition is translated as the following fact facttopo allthis state this.size this.topr this.elems this.size this.toptinexception .
additional facts keep normal and exceptional behaviors mutually disjoint if the precondition for normal behavior is true then the throws field is constrained to null and viceversa if the precondition for exceptional behavior is true thenreturn is constrained to null.
b. congruence synthesis the first step of our algorithm initializes the candidate congruenceb similarequalto observer equality relationo .
we formulate the check for a congruence as a sequence of a lloy problems.
suppose a bare two contract states such that ab similarequalb whereb similarequalis the candidate congruence to be checked.
then for every possible context obs mod z we need to check thatobs mod a b similarequalobs mod b if it is true thanb similarequalis a behavioral congruence.
please note that method parameters in context must be bound to actual values.
thus in the following when we refer to obsandmod components of a context of type obs mod z we refer to instantiated observers and modifiers.
let us consider the check for the congruence ofb similarequalwith respect to a context of type obs mod z .
to perform the congruence check we first define two abstract signatures prestate andpoststate which extend the state signature and model the contract state before and after the application of mod .
then we define two singleton signatures for pre states pre1and pre2 extendingprestate and two singleton signatures for post states post 1andpost extendingpoststate .post models the state of the contract after the application of mod topre1 andpost 2models the state of the contract after the application of mod topre2.
to check if the candidate relationb similarequalis a congruence we check that the following a lloy problem is unsatisfiable i we assert observer equality as a fact that for every observer field obs ii we impose the postconditions of mod to hold inpost andpost by substituting pre state old variables appropriately to refer to pre1andpre2 iii we produce frame conditions to bind specification fields that cannot be modified iv we assert post .obs negationslash post .obs.
example let us consider the context top pop z for thestack contract.
the postcondition of pop is translated to the following fact binding post 1objects factpost1conds allp pre1 q post p.size q.size p.size .
the frame condition as specified by the modifies clause is instead translated to the following fact factpost1fc allp pre1 q post p.size q.elems p.elems p.size q.size p.size q.elems p.elems .
if the above a lloy problem is unsatisfiable for every possible context of type obs mod z thenb similarequalis a congruence thus we can start building the b em section iii c .
otherwise the context for which the problem is satisfiable can be used to refineb similarequalto a more precise relation.
hereafter we discuss exactly how to perform such refinement.
identifying distinguishing contexts if the problem above is satisfiable that is we find an instance such that post .obs negationslash post .obs then we say that the context obs mod z is a distinguishing context since it reveals a part of the contract state that is not directly exposed by the observers.
for example if in the first stepo is not a congruence from the results of the congruence check we obtain a set of distinguishing contexts that are the new basis to build the candidate behavioral congruence b similarequal.
every distinguishing context is then abstracted as a new context abstraction as follows.
given a distinguishing contextobs mod z the following fields are added to state i a field of type state calledmodreachable ii a field of type univ calledobsmodabstr .
please note that univ denotes the universal set.
the first field is a relation to another state which is bound to mod postconditions this bound is realized by adding adequate facts as illustrated in example above.
thus the resulting values ofobs s return value and throw fields are then bound toobsmodabstr ifobs s behavior is exceptional then s.obsmodabstr s.modreachable.obs t otherwise we imposes.obsmodabstr s.modreachable.obs r. with this technique we have added a new fictitious observer which corresponds to a part of the contract state which was hidden.
the new observer called context abstraction is then used to refine the candidate congruenceb similarequal.
example consider the context top pop z for the stack contract the corresponding context abstraction is built by adding two fields toppopabstr and popreachable .
four new singleton signatures pre1pop pre2pop post 1pop andpost 2popmodel the state reached withpop for the pre and post states.
with an appropriate fact we impose the correct values for the popreachable field that is pre1.popreachable pre1pop nopre1pop.popreachable .
similar facts are generated for pre2andpre2pop.
the following fact expresses thepoppostcondition factpre1reachable alls state s.size s.popreachable.size s.size .
similar facts impose the frame condition for pop.
finally we impose the value fortoppopabstr with the following fact factpre1reachable alls state s.toppopabstr ifs.popreachable.top tinexception then s.popreachable.top telses.popreachable.top r .
for each new context abstraction added the congruence check is repeated.
in this case the only difference is that it might happen that a new distinguishing context is found from a modifier and an introduced context abstraction.
for example considering the stack contract toppopabstr after apopis a new distinguishing context because a further popmight expose another part of the state which was hidden.
if the modifier is shared between the new distinguishing context and the context abstraction then it is very likely that there actually exists a sequence of distinguishing contexts that is an iterated context of the form obs mod z that we treat as a particular case.
in the case of stack an iterated context istop pop z .
iterated context abstraction iterated contexts correspond to unbounded but finite sequences of modifier applications ending with an observer.
the corresponding abstraction we would like to build is the sequence of possible return and throw values in other words the context abstraction for an iterated context is a sequence of values.
within a small scope the possible length of a sequence is bounded and thus the iterated context will have a maximum bound of the number of modifier applications.
consider an iterated contextobs mod z .
the iterated context abstraction is built by introducing the following fields to state i obsmoditstep of type int ii obsmoditreachable of typestate representing the state after the application of mod iii obsmoditabstr of type seq univ representing the iterated context abstraction.
the difference is that the number of reachable states in this case is bound to the maximum length of sequences as specified in the small scope.
we impose mod postconditions for all the reachable states and we impose that for the last state there is no reachable further state.
the step field starts from 1and it is incremented in every reachable state it is used then to bind the observer return and throw values to the right element in the iterated context abstraction sequence.
in fact the first state obtained by traversing the obsmoditreachable will have step equal to and with a proper predicate we can bind obsmoditabstr to the values ofobsin the reachable state.
the following fact builds the iterated context abstraction alls r state rins.
obsmoditreachable 941s.obsmoditabstr ifr.obstinexception thenr.obstelser.obsr.
the above fact takes for a given state s every state rwhich is reachable by a sequence of mod applications that is a state rwhich belongs to the reflexive transitive closure of the obsmoditreachable relation.
thus it imposes that the value of the iterative context abstraction at positionr.step is equal to the value of obsreturn value or thrown exception .
in most cases of data abstractions the iterated context abstraction is sufficient to build an adequate behavioral congruenceb similarequal.
in the case of stack the iterative context abstraction built from top pop z corresponds to a sequence of values that can be extracted with popoperations ending with top.
if the sequence is greater or equal to the maximum length of elems in the contract then this abstraction is a behavioral congruence.
c.bemconstruction once we have built the behavioral equivalence relationb by performing analysis within a small scope the relation can be used to build a b em.
a b emis essentially a finite state machine where each transition is labeled with modifier invocations each state is identified by observer return values and the context abstractions built in the previous steps and the constructor determines the initial state.
the model is finite state because we constrain the specification in a limited scope.
the scope of a b emis defined by fixing a finite set of values for method parameters that is by defining the so called instance pools to define every possible object belonging to the visible data types.
the other scope limitation is determined by limiting the maximum number of states of the b em.
considering the b emin figure the scope is defined by using the strings a and b as two possible object values.
the limitation on the possible number of states is implicitly defined by the finite scope of the relational analysis as in a lloy .
in fact by defining a maximum length of sequences and possible elements in sets the possible number of states will be finite.
starting from the constructor we can compute the unique state of the b emby identifying it with the value of observer and context abstractions.
in fact the values of the abstractions correspond to a single state in the b emwhich represents classes of behaviorally equivalent states.
the construction algorithm computes the value of the abstraction assuming that the invariant and the postcondition of the constructor hold.
thus it takes a generic state and imposes the value of abstraction as obtained by the constructor postcondition.
for each modifier it considers the reached state by imposing its postcondition and retrieves the new abstraction in this way it is possible to add transitions to the b em.
since the scope is finite the algorithm terminates with a b emwhich precisely describe the behavior of the data abstraction in the specified small scope.iv.
b emvalidation in this section we provide a brief and intuitive description of the foundations of the validation approach we proposed in .
the aim of that method is to validate an algebraic specification against a b em.
in the context of this paper it can be used to validate a contract against a behavioral property expressed as an algebraic axiom through the synthesized behavior model.
the foundations of the validation approach rely on a consideration we discussed in that is the fact that a b emis apartial algebra of a hidden signature h. by interpreting a b emas an algebra of a hidden signature h we have a formal framework to compare it against an axiom of an algebraic specification defined over the same signature.
intuitively axioms become properties of the transition function of the b em.
consider the simple b em on figure and consider a simplified version of axiom a1 that is s stack e object popm push m s e s that does not take into account the fact that the stack is bounded.
as in the b em the set a b is the instance pool for the push method.
with such instance pools and the given interpretation the axiom becomes s q e ip push s push e pop s whereipis a function mapping an operation to its instance pool in the bem is the transition function of the b emandqis its set of states.
since ip push is finite the axiom can be instantiated for every visible sort s q s push a pop s s push b pop s the only quantified values in this case can be elements of the specified sort that is states of the b em thus the axiom can be easily checked by considering every possible state of the b em.
however since the b emis finite the transition function might be partial and thus most of the axioms could have counterexamples just because the model is finite.
instead we would like to verify that in all the cases on which is defined the axioms hold.
for example the axiom above cannot hold in any finite b emof s tack since there does not exist a finite b emwhere thepush operation is defined in every state.
thus our problem reduces to verifying the axioms in all the valuations of the variables for which the transition function is defined and we consider the axiom holding precisely in these cases.
further details on the problem of validity and how this is checked can be found in where we show how the problem of checking algebraic axioms within the b emcan be reduced to a model checking problem.
v. d iscussion and related work the work presented in this paper describes a model synthesis technique that can be used to automatically validate contracts of stateful components.
such artifacts are usually hard to validate because the number of states of942 specfield elems seq object wp int rp int invariant this.rp this.rp this.elems this.wp this.wp this.elems this.elems public class cbuffer requires len ensures this.elems len this.rp len this.wp throws exception len public cbuffer intlen requires this.wp this.rp this.wp this.elems this.rp this.wp this.elems this.rp this.wp ensures this.wp old this.wp this.elems this.elems old this.elems old this.wp i modifies this.elems this.wp public void write object i requires this.rp this.wp this.rp this.elems this.wp this.rp this.elems this.wp this.rp ensures this.rp old this.rp this.elems return this.elems modifies this.rp public object read requires true returns this.len public int len figure .
a jf orge contract for a circular buffer such component is in general case infinite.
the typical solution of this problem is to derive a finite state model that enables the validation.
in principle there are two mainstream approaches to derive such models analysis of a sound abstraction a sound abstraction includes all the possible behaviors of the artifact to be analyzed but it may also include spurious behaviors introduced by the finite state abstraction small scope analysis under the small scope hypothesis one can reduce the possible states to analyze and derive within the given scope a model that precisely represents the artifact s behavior.
both the approaches have their own advantages and disadvantages and they are based on two different assumptions.
for example the c ontractor approach presented in derives a sound abstraction for contracts expressed in first order logic.
the implicit assumption in this case is that the spurious behaviors introduced by the abstraction technique and the incompleteness of the supported logic do not invalidate the property to be checked.
if a given property is validated c ontractor ensures that the artifact exhibits that property.
instead if a counterexample is found inspection is needed to check if the counterexample is really part of the artifact behavior or it is caused by the abstraction mechanism.
counterexample based abstraction and refinement cegar approaches provide a technique to refine the abstraction in case of property violation.
abstractions can be used for many validation activities such as testing.
such use of abstractions is for example discussed in instead of using enabledness the authors use boolean queries that split the contract state space.
a similar approach used for testing is presented in in this case the state space is abstracted by considering a partitioning derived from predicates on observer return values and transitions are built through dynamic analysis by using an initial test suite so the finite state extracted machine is not a sound abstraction.
the small scope analysis approach takes a different stand point .
the hypothesis upon which it is based states that most bugs have small counterexamples that is if the artifact violates a given property this is very likely to be found within a small scope.
thus an exhaustive analysis can focuspushpush poppoppushpush pop poppush pop figure .
a f sca for the stack contract on a small scope and if no counterexample is found it is very unlikely that the artifact violates the property.
in this case if the property is not violated we have only gained some confidence that the property holds but if the counterexample is found we are sure that indeed the artifact is flawed.
our approach focuses on this kind of analysis.
an important kind of small scope analysis of contract based artifacts can be performed by using d ynalloy .
however it cannot be used to verify that a contract exhibits complex properties as method interactions specifiable with algebraic axioms with the hidden semantics.
as far as we know our approach is the first towards this direction.
a related finite scope analysis of requirement artifact contracts has been presented in mainly used for simulation of operational models of requirements.
however the analysis is not exhaustive so it is not properly a small scope analysis as defined in .
several methods involve the use of contracts for testing between the ones leveraging the small scope hypothesis the t estera approach uses a lloy as a language to specify test correctness properties.
in the end we identify c ontractor as the most similar approach and as a source of contract examples that can be used to assess the validity of our technique.
contractor synthesizes finite state contract abstractions f scas using an smt solver.
the abstraction provided by this approach collapses contract states into abstract states when the same set of operations are enabled that is their preconditions are satisfiable.
instead transitions model how the enabled operations change after the postcondition of the transition is guaranteed.
figure shows the abstraction produced by the approach in the case of the stack contract.
the abstraction approach is conservative i.e.
it is guaranteed to include all the possible behaviors of the contract 943cbuffer write squigglerightexception read squigglerightexception len cbuffer read cbuffer read a len 5cbuffer read b len cbuffer read a len 5cbuffer read a len 5cbuffer read b len cbuffer read b len 5write a write a read write b write b write a write b read read read read read figure .
a b emof cbuffer.
quote marks are omitted from string literals.
but the extracted models describe also many other possible behaviors that actually are not described by the contract.
for example the f sca for the stack contract as shown in figure cannot be used to validate axiom a1 .
this is mainly due to the fact that models are built for manual validation thus their conciseness and relative simplicity are fundamental for manual tractability.
from this abstraction it is possible to check simple behavioral properties such as the fact that the container can be full but no hint is given about the precise lifo behavior of push andpop.
while being conservative f scas lack the necessary precision to validate contracts against algebraic axioms.
given the considerations above we view c ontractor as a complementary rather than competitive approach since the kind of analysis sound abstraction vs. small scope its assumptions and the use of models manual vs. automatic validation are completely different.
vi.
m ethodology assessment in this section we provide an assessment of the proposed validation methodology.
we explicitly refer to the same set of examples used in and we show what kind of additional validation can be performed with b ems.
to illustrate the practical use of the approach and validate it we introduce two significant examples a data abstraction the circular buffer section vi a and a contract specifying a requirement artifact an atm model taken from section vi b .
the two examples are also used in for space reasons we cannot add further examples in this paper.
additional material and experiments can be found in the project s web page .
a. circular buffer a relatively complex example taken from is given in figure .
in this case the contract which specifies a circular buffer is close to a concrete implementation ofwritewrite readreadwritewrite readread writewrite read read figure .
a f sca for cbuffer.
the data abstraction in fact even the name refers more to the implementation technique a circular buffer than to the data abstraction it represents .
this example has been used as a motivating example to show the need of abstractions from contracts in .
in this case it would be reasonable to validate the complex specification against the expected fifo behavior it should have in fact the circular buffer is essentially a limited size queue.
in other words this behavioral property can be represented by this axiom b cbuffer e int read m write m b e a2 ifb cbuffer leno b thenb else ifwrite o b e negationslash squigglerightexception thenwrite m read m b e elseread m b figure shows a b emthat can be synthesized with our approach by selecting a length of 5for the circular buffer and a b as contained elements.
this configuration is the minimal one that shows f ifobehavior because i read always returns the first element inserted by a write and ii transitions labeled with read show a behavior coherent with axiom a2 in particular by considering the two states of size 2on the lower part of the b em.
a further kind of validation is possible by comparing the fsca with the b emfor the data abstraction.
while the f ifo behavior is not verifiable with the f sca the f sca admits some unusual behavior that is not present in the b em and that corresponds to a wrong specification of the invariant in thecbuffer contract as shown in figure .
in fact by inspecting the f sca on figure the contract abstraction admits the possibility that after a successful read operation the data abstraction reaches a state where it is not possible to invoke write .
in principle with the only inspection of f sca it is possible to manually identify this issue not to derive any possible likely cause.
instead by comparing the f sca with the b em it is possible to automatically find that the behavior described above is not present in the b em.
this absence could be due to two factors either the scope of the b emis not sufficient to show the issue or since the scope is significant assuming the small scope hypothesis the wrong behavior is not reachable that is there does not exist any sequence of operations in the data abstraction that exhibits the wrong behavior.
in fact the wrong behavior shown by the f sca is due to a relaxed invariant which does not include the condition wp negationslash rp.
however given the944state canceledmsg dispmainscr ejcard enterpwd p inscard c reqpwd reqtakecard takecard s1 f t squigglerighte t f squigglerighte s2 f t squigglerighte squigglerighte f f squigglerighte s3 t f squigglerighte squigglerighte f f squigglerighte s4 f f squigglerighte squigglerighte f f s5 t f squigglerighte squigglerighte f t s6 t f squigglerighte t f squigglerighte s7 f f squigglerighte t t s8 t f squigglerighte t t a state labelings1 atm s2 s6s3s4 s7 s8s5 inscard c inscard c inscard c ejcard inscard c ejcard enterpwd p enterpwd p enterpwd p enterpwd p ejcard ejcard takecard takecard takecard takecard b transition function figure .
a b emof the a tmmodel.
t fdenote true andfalse constants while edenotes exception .
initial state prescribed by the constructor and any possible sequence of operations as specified by the contracts of read andwrite this situation cannot be reached.
b. atm model as a second example we consider the validation of a requirement engineering artifact specified by a contract based on pre post conditions and invariants.
the example is taken from and it discusses the protocol of a singleuser interaction with an automatic teller machine a tm .
for space reasons we cannot include the whole contract the reader can find it in .
figure shows the b emfor the atmmodel.
the model describes single user interaction so there is no interest in using instance pools for inscard and enterpwd operations with size greater than since all the operations would be independent of the parameter values.
complex properties can be correctly verified in the b em for example it is possible to invoke some pair of operations in any order a atm c card p pwd inscard m enterpwd m a p c ifenterpwd o a p negationslash squigglerightexception thenenterpwd m inscard m a c p a atm p pwd ejcard m enterpwd m a p ifenterpwd o a p negationslash squigglerightexception thenenterpwd m ejcard m a p another important axiom that is not verified in the b em prescribes the fact that from every state if it is possible to take the card this action resets the a tmto the initial state a atm takecard m a a3 iftakecard o a negationslash exception thenatm as in we can identify that there are two possible states reached from a takecard operation this is due to a wrong post condition of takecard which does not reset the value of a contract field passwordgiven that models the fact that the client has previously entered the password.
a hint onthis problem can be for example obtained by checking a property involving the reqpwd observer which models the fact that the a tmis requesting the password a atm reqpwd o takecard m a true a4 since the axiom above is falsified because reqpwd s2 false one could inspect the post condition of reqpwd requires true returns passwordgiven false pure public boolean reqpwd this inspection together with a4 is an hint on a problem with the update of the passwordgiven contract variable.
vii.
c onclusions and future work in this paper we presented a small scope static analysis of contracts that produces operational models based on the concept of behavioral equivalence.
the technique enables the validation of complex properties about method interactions that can be expressed as algebraic axioms.
the approach has been evaluated on a set of pre and postcondition based contracts describing relatively complex data abstractions and requirement artifacts.
we illustrated how model synthesis can be used to enable automatic check of behavioral properties.
in this paper we contrasted the kind of models extracted with a small scope analysis with the ones built via a sound abstraction as a f sca.
we believe that integrating these different kind of analysis can provide more insightful results that can be used for both manual and automatic validation this integration is left as a future work.
we also illustrated how it is possible to manually identify in the contract which is the cause of a property violation expressed through a counterexample.
another useful important future work involves the automatic or semi automatic identification of these causes for example by exploiting unsatisfiability cores.