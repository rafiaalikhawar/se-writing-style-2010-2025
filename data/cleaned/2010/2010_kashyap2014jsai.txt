jsai a static analysis platform for javascript vineeth kashyapykyle deweyyethan a. kuefnery john wagnerykevin gibbonsyjohn sarracino?
ben wiedermann?ben hardekopfy yuniversity of california santa barbara usa?harvey mudd college usa abstract javascript is used everywhere from the browser to the server including desktops and mobile devices.
however the current state of the art in javascript static analysis lags far behind that of other languages such as c and java.
our goal is to help remedy this lack.
we describe jsai a formally speci ed robust abstract interpreter for javascript.
jsai uses novel abstract domains to compute a reduced product of type inference pointer analysis controlow analysis string analysis and integer and boolean constant propagation.
part of jsai s novelty is user con gurable analysis sensitivity i.e.
context path and heap sensitivity.
jsai is designed to be provably sound with respect to a speci c concrete semantics for javascript which has been extensively tested against a commercial javascript implementation.
we provide a comprehensive evaluation of jsai s performance and precision using an extensive benchmark suite including real world javascript applications machine generated javascript code via emscripten and browser addons.
we use jsai s con gurability to evaluate a large number of analysis sensitivities some well known some novel and observe some surprising results that go against common wisdom.
these results highlight the usefulness of a con gurable analysis platform such as jsai.
categories and subject descriptors f. .
program analysis general terms languages algorithms veri cation keywords javascript analysis abstract interpretation .
introduction javascript is pervasive.
while it began as a client side webpage scripting language javascript has grown hugely in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.scope and popularity and is used to extend the functionality of web browsers via browser addons to develop desktop applications e.g.
for windows and server side applications e.g.
using node.js and to develop mobile phone applications e.g.
for firefox os .
javascript s growing prominence means that secure correct maintainable and fast javascript code is becoming ever more critical.
static analysis traditionally plays a large role in providing these characteristics it can be used for security auditing errorchecking debugging optimization program understanding refactoring and more.
however javascript s inherently dynamic nature and many unintuitive quirks cause great di culty for static analysis.
our goal is to overcome these di culties and provide a formally speci ed well tested static analysis platform for javascript immediately useful for many client analyses such as those listed above.
in fact we have used jsai in previous work to build a security auditing tool for browser addons and to experiment with strategies to improve analysis precision .
we have also used jsai to build a static program slicing client and to build a novel abstract slicing client.
these are only a few examples of jsai s usefulness.
several important characteristics distinguish jsai from existing javascript static analyses which are discussed further in section jsai is formally speci ed.
we base our analysis on formally speci ed concrete andabstract javascript semantics.
the two semantics are connected using abstract interpretation we have soundness proof sketches for our most novel and interesting abstract analysis domain.
jsai handles javascript as speci ed by the ecma standard sans eval and family and various language extensions such as typed arrays .
jsai s concrete semantics have been extensively tested against an existing commercial javascript engine and the jsai abstract semantics have been extensively tested against the concrete semantics for soundness.
jsai s analysis sensitivity i.e.
path context and heap sensitivity are user con gurable independently from the rest of the analysis.
this means that jsai allows arbitrary sensitivities as de ned by the user rather than only allowing a small set of baked in choices and that the sensitivity can be set independently from the rest of the analysis or any client analyses.
jsai s contributions include complete formalisms for concrete and abstract semantics for javascript along with implementations of concrete and abstract interpreters basedon these semantics.
while concrete semantics for javascript have been proposed before ours is the rst designed specifically for abstract interpretation.
our abstract semantics is the rst formal abstract semantics for javascript in the literature.
the abstract interpreter implementation is the rst available static analyzer for javascript that provides easy con gurability as a design goal.
all these contributions are available freely for download as supplementary materials1.
jsai provides a solid foundation on which to build multiple client analyses for javascript.
the speci c contributions of this paper are the design of a javascript intermediate language and concrete semantics intended speci cally for abstract interpretation section .
.
the design of an abstract semantics that enables congurable sound abstract interpretation for javascript section .
.
this abstract semantics represents a reduced product of type inference pointer analysis controlow analysis string analysis and number and boolean constant propagation.
novel abstract string and object domains for javascript analysis section .
.
a discussion of jsai s con gurable analysis sensitivity including two novel context sensitivities for javascript section .
an evaluation of jsai s performance and precision on the most comprehensive suite of benchmarks for javascript static analysis that we are aware of including browser addons machine generated programs via emscripten and open source javascript programs section .
we showcase jsai s con gurability by evaluating a large number of context sensitivities and point out novel insights from the results.
we preface these contributions with a discussion of related work section and conclude with plans for future work section .
.
related work in this section we discuss existing static analyses and hybrid static dynamic analyses for javascript and discuss previous e orts to formally specify javascript semantics.
javascript analyses.
the current state of the art static analyses for javascript usually take one of two approaches an unsound2data ow analysis based approach using baked in abstractions and analysis sensitivities or a formally speci ed type system requiring annotations to existing code proven sound with respect to a speci c javascript formal semantics but restricted to a small subset of the full javascript language .
no existing javascript analyses are formally speci ed implemented using an executable abstract semantics tested against a formal concrete semantics or target con gurable sensitivity.
under downloads .
2most examples of this approach are intentionally unsound as a design decision in order to handle the many di culties raised by javascript analysis.
unsound analysis can be useful in some circumstances but for many purposes e.g.
security auditing soundness is a key requirement.the closest related work to jsai is the javascript static analyzer tajs by jensen et al .
while tajs is intended to be a sound analysis of the entire javascript language sans dynamic code injection it does not possess any of the characteristics of jsai described in section .
the tajs analysis is not formally speci ed and the tajs papers have insu cient information to reproduce the analysis also the analysis implementation is not well documented making it di cult to build client analyses or modify the main tajs analysis.
in the process of formally specifying jsai we uncovered several previously unknown soundness bugs in tajs that were con rmed by the tajs authors.
this serves to highlight the importance and usefulness of formal speci cation.
various previous works propose di erent subsets of the javascript language and provide analyses for that subset.
these analyses range from type inference to pointer analysis to numeric range and kind analysis.
none of these handle the full complexities of javascript.
several intentionally unsound analyses have been proposed while other works take a best e ort approach to soundness without any assurance that the analysis is actually sound.
none of these e orts attempt to formally specify the analysis they implement.
several type systems have been proposed to retro t javascript or subsets thereof with static types.
guha et.
al.
propose a novel combination of type systems and ow analysis.
chugh et.
al.
propose a owsensitive re nement type system designed to allow typing of common javascript idioms.
these type systems require programmer annotations and cannot be used as is on real world javascript programs.
combinations of static analysis with dynamic checks have also been proposed.
these systems statically analyze a subset of javascript under certain assumptions and use runtime checks to enforce these assumptions.
sch afer et al.
use a dynamic analysis to determine information that can be leveraged to scale static analysis for javascript.
these ideas are complementary to and can supplement our purely static techniques.
javascript formalisms.
none of the previous work on static analysis of javascript have formally speci ed the analysis.
however there has been previous work on providing javascript with a formal concrete semantics.
ma eis et.
al give a structural smallstep operational semantics directly to the full javascript language omitting a few constructs .
lee et.
al propose safe a semantic framework that provides structural bigstep operational semantics to javascript based directly on the ecmascript speci cation.
due to their size and complexity neither of these semantic formulations are suitable for direct translation into an abstract interpreter.
guha et.
al propose a core calculus approach to provide semantics to javascript they provide a desugarer from javascript to a core calculus called js which has a smallstep structural operational semantics.
their intention was to provide a minimal core calculus that would ease proving soundness for type systems thus placing all the complexity in the desugarer.
however their core calculus is too lowlevel to perform a precise and scalable static analysis for example some of the semantic structure that is critical for a precise analysis is lost and their desugaring causes a largecode bloat more than on average .
we also use the core calculus approach however our own intermediate language called notjs is designed to be in a sweet spot that favors static analysis for example the code bloat due to our translation is between on average .
in addition we use an abstract machine based semantics rather than a structural semantics which as described later is the prime enabler for con gurable analysis sensitivity.
con gurable sensitivity.
bravenboer and smaragdakis introduce the doop framework that performs owinsensitive points to analysis for java programs using a declarative speci cation in datalog.
several context sensitive versions of the points to analysis are expressible in this framework as modular variations of a common code base.
their framework would require signi cant changes to enable ow sensitive analysis especially for a language like javascript which requires an extensive analysis to compute a sound ssa form like ours and they cannot express arbitrary analysis sensitivities including path sensitivities modularly the way that jsai can.
.
jsai design we break our discussion of the jsai design into three main components the design of an intermediate representation ir for javascript programs called notjs along with its concrete semantics the design of an abstract semantics for notjs that yields the reduced product of a number of essential sub analyses and also enables con gurable analysis and the design of novel abstract domains for javascript analysis.
we conclude with a discussion of various options for handling dynamic code injection.
the intent of this section is to discuss the design decisions that went into jsai rather than giving a comprehensive description of the various formalisms e.g.
the translation from javascript to notjs the concrete semantics of notjs and the abstract semantics of notjs .
all of these formalisms along with their implementations are available in the supplementary materials.
.
designing the notjs ir javascript s many idiosyncrasies and quirky behaviors motivate the use of formal speci cations for both the concrete javascript semantics and our abstract analysis semantics.
our approach is to de ne an intermediate language called notjs along with a formally speci ed translation from javascript to notjs.
we then give notjs a formal concrete semantics upon which we base our abstract interpreter.
figure shows the abstract syntax of notjs which was carefully designed with the ultimate goal of making abstract interpretation simple precise and e cient.
the ir contains literal expressions for numeric boolean values and for undef and null.
object values are expressed with the newconstruct and function values are expressed with the newfun construct.
the ir directly supports exceptions via throw and try catch n it supports other non local control ow e.g.
javascript s return break and continue via the jump construct.
the ir supports two forms of loops while and for.
the forconstruct corresponds to javascript s re ective for..in statement which allows the programmer to iterate 3guha et al use a similar approach but our ir design and formal semantics are quite di erent.
see section for a discussion of the di erences between our two approaches.over the elds of an object.
a method takes exactly two arguments self and args referring to the this object and arguments object all variants of javascript method calls can be translated to this form.
the toobj tobool tostr tonum and isprim constructs are the explicit analogues of javascript s implicit conversions.
javascript s builtin objects e.g .
math and methods e.g.
isnan are properties of the global object that is constructed prior to a program s execution thus they are not a part of the ir syntax.
n2numb2bool str2string x2variable 2label s2stmt sijife s1s2jwhile e sjx eje1 e2 e3 jx e1 e2 e3 jx toobjejx dele1 e2 jx newfunmnjx newe1 e2 jthrow e jtry catch n s1xs2s3j sjjump ejforxes e2exp njbjstrjundefjnulljxjmje1 e2j e d2decl decl !xi eiins m2meth self args dj self args s 2binop j j j j j j j j j j j0j0jyjandjorj j j j j j jinstanceofjin 2unop j j j typeofjisprimjtobool jtostrjtonum figure the abstract syntax of notjs provides canonical constructs that simplify javascript s behavior.
the vector notation represents by abuse of notation an ordered sequence of unspeci ed length n whereiranges from to n .
note that our intermediate language is notbased on a controlow graph but rather on an abstract syntax tree ast further distinguishing it from existing javascript analyses.
javascript s higher order functions implicit exceptions and implicit type conversions that can execute arbitrary user de ned code make a program s controlow extremely di cult to precisely characterize without extensive analysis of the very kind we are using the intermediate language to carry out.
other javascript analyses that do use a ow graph approach start by approximating the controlow and then ll in more controlow information in an ad hoc manner as the analysis progresses this leads to both imprecision and unsoundness for example one of the soundness bugs we discovered in tajs was directly due to this issue .
jsai uses the smallstep abstract machine semantics to determine controlow during the analysis itself in a sound manner.
an important design decision we made is to carefully separate the language into pure expressions e2exp that are guaranteed to terminate without throwing an exception and impure statements s2stmt that do not have these guarantees.
this decision directly impacts the formal semantics and implementation of notjs by reducing the size of the formal semantics4and the corresponding code to onethird of the previous size compared to a version without this separation and vastly simplifying them.
this is the rst ir for javascript we are aware of that makes this design choice it is a more radical choice than might rst be apparent because javascript s implicit conversions make it 4speci cally the number of semantic continuations and transition rules.di cult to enforce this separation without careful thought.
other design decisions of note include making javascript s implicit conversions which are complex and di cult to reason about involving multiple steps and alternatives depending on the current state of the program explicit in notjs the constructs toobj isprim tobool tostr tonum are used for this leaving certain javascript constructs unlowered to allow for a more precise abstract semantics e.g.
the for..in loop which we leave mostly intact as forxes and simplifying method calls to make the implicit this parameter and arguments object explicit this is often but not always the address of a method s receiver object and its value can be non intuitive while arguments provides a form of re ection providing access to a method s arguments.
given the notjs abstract syntax we need to design a formal concrete semantics that together with the translation to notjs captures javascript behavior.
we have two main criteria the semantics should be speci ed in a manner that can be directly converted into an implementation allowing us to test its behavior against actual javascript implementations looking ahead to the abstract version of the semantics which de nes our analysis the semantics should be speci ed in a manner that allows for con gurable sensitivity.
these requirements lead us to specify the notjs semantics as an abstract machine based smallstep operational semantics.
one can think of this semantics as an in nite state transition system wherein we formally de ne a notion of state and a set of transition rules that connect states.
the semantics is implemented by turning the state de nition into a data structure e.g.
a scala class and the transition rules into functions that transform a given state into the next state.
the concrete interpreter starts with an initial state containing the start of the program and all of the builtin javascript methods and objects and continually computes the next state until the program nishes.
we omit further details of the concrete semantics for space and because they have much in common with the abstract semantics described in the next section.
the main di erence between the two is that the abstract state employs sets in places where the concrete state employs singletons and the abstract transition rules are nondeterministic whereas the concrete rules are deterministic.
both of these di erences are because the abstract semantics over approximates the concrete semantics.
testing the semantics.
we tested the translation to notjs the notjs semantics and implementations thereof by comparing the resulting program execution behavior with that of a commercial javascript engine spidermonkey .
we rst manually constructed a test suite of over programs that were either hand crafted to exercise various parts of the semantics or taken from existing javascript programs used to test commercial javascript implementations.
we then added over one million randomly generated javascript programs to the test suite.
we ran all of the programs in the test suite on spidermonkey and on our concrete interpreter and we veri ed that they produce identical output.
because the ecma speci cation is informal we can never completely guarantee that the notjs semantics is equivalent to the spec but we can do as well as other javascript implementations which also use testing to establish conformance with the ecma speci cation.
.
designing the abstract semanticsthe javascript static analysis is de ned as an abstract semantics for notjs that over approximates the notjs concrete semantics.
the analysis is implemented by computing the set of all abstract states reachable from a given initial state by following the abstract transition rules.
the analysis contains some special machinery that provides con gurable sensitivity.
we illustrate our approach via a worklist algorithm that ties these concepts together algorithm the jsai worklist algorithm put the initial abstract state 0on the worklist initialize map partition trace!state to empty repeat remove an abstract state from the worklist for all abstract states 0innext states do ifpartition does not contain trace then partition trace put 0on worklist else old partition trace new oldt if new6 oldthen partition trace new put newon worklist end if end if end for until worklist is empty the static analysis performed by this worklist algorithm is determined by the de nitions of the abstract semantic states 2state the abstract transition rules5next states2 state !p state and the knob that con gures the analysis sensitivity trace .
abstract semantic domains.
figure shows our definition of an abstract state for notjs.
an abstract state consists of a term that is either a notjs statement or an abstract value that is the result of evaluating a statement anenvironment that maps variables to sets of addresses a store mapping addresses to either abstract values abstract objects or sets of continuations to enforce computability for abstract semantics that use semantic continuations as per van horn and might and nally a continuation stack that represents the remaining computations to perform one can think of this component as analogous to a runtime stack that remembers computations that should completed once the current computation is nished.
abstract values are either exception jump values evalue jvalue used to handle non local controlow or base values bvalue used to represent javascript values.
base values are a tuple of abstract numbers booleans strings addresses null and unde ned each of these components is a lattice.
base values are de ned as tuples because the analysis over approximates the concrete semantics and thus cannot constrain values to be only a single type at a time.
these value tuples yield a type inference analysis any component of this tuple that is a lattice ?represents a type that this value cannot contain.
base values do not include function closures because functions in javascript are actually 5omitted for space available in supplementary materials.
n2num cstr2string a2address 2unop 2binop 2state term env store kont t2term decl stmt value 2env variable!p address 2store address !
bvalue object p kont cbv2bvalue num p bool string p address p fnullg p fundefg o2object string !bvalue p string string!
bvalue class p closure c2class ffunction array string boolean number date error regexp arguments object g cclo2closure env meth cev2evalue excbv bjv2jvalue jmp cbv v2value bvalue evalue jvalue 2kont haltkj seqk si j whilek e s jdlblk jdfork !cstrix s j retk x ctorj retk x call j tryk x s s j catchk s jd nk v j addrk a figure abstract semantic domains for notjs.
objects.
instead we de ne a class of abstract objects that correspond to functions and that contain a set of closures that are used when that object is called as a function.
we describe our novel abstract object domain in more detail in section .
.
each component of the tuple also represents an individual analysis the abstract number domain determines a number analysis the abstract string domain determines a string analysis the abstract addresses domain determines a pointer analysis etc.
composing the individual analyses represented by the components of the value tuple is not a trivial task a simple cartesian product of these domains which corresponds to running each analysis independently without using information from the other analyses would be imprecise to the point of being useless.
instead we specify a reduced product of the individual analyses which means that we de ne the semantics so that each individual domain can take advantage of the other domains information to improve their results.
the abstract number and string domains are intentionally unspeci ed in the semantics they are con gurable.
we discuss our speci c implementations of the abstract string domain in section .
.
together all of these abstract domains de ne a set of simultaneous analyses controlow analysis for each callsite which methods may be called pointer analysis for each object reference which objects may be accessed type inference for each value can it be a number a boolean a string null undef or a particular class of object and extended versions of boolean number and string constant propagation for each boolean number and string value is it a known constant value .
these analyses combine to give detailed control and dataow information forming a fundamental analysis that can be used by many possible clients e.g.
error detection program slicing secure information ow etc .current state next state 1hs si i h s seqk si i 2hcbv seqks si i hs seqk si i 3hcbv seqk i hcbv i 4hifes1s2 i hs1 iiftrue2 b jek 5hifes1s2 i hs2 iiffalse2 b jek figure a small subset of the abstract semantics rules for jsai.
each smallstep rule describes a transition relation from one abstract state to the next state .
the phrase b jek means to evaluate expression eto an abstract base value then project out its boolean component.
abstract transition rules.
figure describes a small subset of the abstract transition rules to give their avor.
to compute next states the components of are matched against the premises of the rules to nd which rule s are relevant that rule then describes the next state if multiple rules apply then there will be multiple next states .
the rules and deal with sequences of statements.
rule says that if the state s term is a sequence then pick the rst statement in the sequence to be the next state s term then take the rest of the sequence and put it in a seqk continuation for the next state pushing it on top of the continuation stack.
rule says that if the state s term is a base value and hence we have completed the evaluation of a statement take the next statement from the seqk continuation and make it the term for the next state.
rule says that if there are no more statements in the sequence pop the seqk continuation o of the continuation stack.
the rules and deal with conditionals.
rule says that if the guard expression evaluates to an abstract value that over approximates true make the truebranch statement the term for the next state rule is similar except it takes the false branch.
note that these rules are nondeterministic in that the same state can match both rules.
con gurable sensitivity.
to enable con gurable sensitivity we build on the insights of hardekopf et al .
we extend the abstract state to include an additional component from a trace abstract domain.
the worklist algorithm uses the trace function to map each abstract state to its trace and joins together all reachable abstract states that map to the same trace see lines of algorithm .
the de nition of trace is left to the analysis designer di erent de nitions yield di erent sensitivities.
for example suppose trace is de ned as the set of program points and an individual state s trace is the current program point.
then our worklist algorithm computes a ow sensitive contextinsensitive analysis all states at the same program point are joined together yielding one state per program point.
suppose we rede ne trace to be sequences of program points and an individual state s trace to be the last kcall sites.
then our worklist algorithm computes a ow sensitive kcfa context sensitive analysis.
arbitrary sensitivities including path sensitivity and property simulation can be dened in this manner solely by rede ning trace without a ecting the worklist algorithm or the abstract transition rules.
we explore a number of possibilities in section .
.
novel abstract domains jsai allows con gurable abstract number and string do snotspl snotnum snum snotnumnorspl sspl foo bar valueof ?
figure our default string abstract domain further explained in section .
.
mains but we also provide default domains based on our experience with javascript analysis.
we motivate and describe our default abstract string domain here.
we also describe our novel abstract object domain which is an integral part of the jsai abstract semantics.
abstract strings.
our initial abstract string domain string was an extended string constant domain.
the elements were either constant strings or strings that are de nitely numbers or strings that are de nitely not numbers or a completely unknown string .
this string domain is similar to the one used by tajs and it is motivated by the precision gained while analyzing arrays arrays are just objects where array indices are represented with numeric string properties such as etc but they also have non numeric properties like length .
however this initial string domain was inadequate.
in particular we discovered a need to express that a string isnotcontained within a given hard coded set of strings.
consider the property lookup x obj where yis a variable that resolves to an unknown string.
because the string is unknown the analysis is forced to assign to xnot only the lattice join of all values contained in obj but also the lattice join of all the values contained in all prototypes of obj due to the rules of prototype based inheritance.
almost all object prototype chains terminate in one of the builtin objects contained in the global object object.prototype array.prototype etc these builtin objects contain the builtin values and methods.
thus all of these builtin values and methods are returned for any object property access based on an unknown string polluting the analysis.
one possible way to mitigate this problem is to use an expensive domain that can express arbitrary complements i.e.
express that a string is notcontained in some arbitrary set of strings .
instead we extend the string domain to separate out special strings valueof tostring etc xed ahead of time from the rest these special strings are drawn from property names of builtin values and methods.
we can thus express that a string has an unknown value that is notone of the special values.
this is a practical solution that improves precision at minimal cost.
the new abstract string domain depicted in figure that separates unknown strings into numeric non numeric and special strings was simple to implement due to jsai s congurable architecture it did not require changes to any other parts of the implementation despite the pervasive use of strings in all aspects of javascript semantics.
abstract objects.
we highlight the abstract domain object given in figure as a novel contribution.
previous javascriptanalyses model abstract objects as a tuple containing a map from property names to values and a list of de nitely present properties necessary because property names are just strings and objects can be modi ed using unknown strings as property names .
however according to the ecma standard objects can be of di erent classes such as functions arrays dates regexps etc.
while these are all objects and share many similarities there are semantic di erences between objects of di erent classes.
for example the length property of array objects has semantic signi cance assigning a value to length can implicitly add or delete properties to the array object and certain values cannot be assigned to length without raising a runtime exception.
non array objects can also have a length eld but assigning to that eld will have no other e ect.
the object s class dictates the semantics of property enumerate update and delete operations on an object.
thus the analysis must track what classes an abstract object may belong to in order to accurately model these semantic di erences.
if abstract objects can belong to arbitrary sets of classes this tracking and modeling becomes complex error prone and ine cient.
our innovation is to add a map as the third component of abstract objects that contains class speci c values.
this component also records which class an abstract object belongs to.
finally the semantics is designed so that any given abstract object must belong to exactly one class.
this is enforced by assigning abstract addresses to objects based not just on their static allocation site and context but also on the constructor used to create the object which determines its class .
the resulting abstract semantics is much simpler more e cient and precise.
.
showcasing configurability analysis sensitivity path context and heap sensitivity hsa a signi cant impact on the usefulness and practicality of the analysis.
the sensitivity represents a tradeo between precision and performance the more sensitive the analysis is the more precise it can be but also the more costly it can be.
the sweet spot in this tradeo varies from analysis to analysis and from program to program.
jsai allows the user to easily specify di erent sensitivities in a modular way separately from the rest of the analysis.
a particularly important dimension of sensitivity is contextsensitivity how the potentially in nite possible method call instances are partitioned and merged into a nite number of abstract instances.
the current state of the art for javascript static analysis has explored only a few possible context sensitivity strategies all of which are baked into the analysis and di cult to change with no real basis for choosing these over other possible strategies.
we take advantage of jsai s con gurability to de ne and evaluate a much larger selection of context sensitivities than has ever been evaluated before in a single paper.
because of jsai s design specifying each sensitivity takes only lines of code previous analysis implementations would have to hard code each sensitivity from scratch.
the jsai analysis designer speci es a sensitivity by instantiating a particular instance of trace all abstract states with the same trace will be merged together.
for context sensitivity we de ne trace to include some notion of the calling context so that states in the same context are merged while states in di erent contexts are kept separate.
we implement six main context sensitivity strategies eachparameterized in various ways yielding a total of different forms of context sensitivity.
all of our sensitivities are ow sensitive javascript s dynamic nature means that ow insensitive analyses tend to have terrible precision .
we empirically evaluate all of these strategies in section here we de ne the six main strategies.
four of the six strategies are known in the literature while two are novel to this paper.
the novel strategies are based on two hypotheses about context de nitions that might provide a good balance between precision and performance.
our empirical evaluation demonstrates that these hypotheses are false i.e.
they do not provide any substantial bene t. we include them here not as examples of good sensitivities to use but rather to demonstrate that jsai makes it easy to formulate and test hypotheses about analysis strategies each novel strategy took only minutes to implement.
the strategies we de ned are as follows where the rst four are known and the last two are novel context insensitive.
all calls to a given method are merged.
we de ne the context component of trace to be a unit value so that all contexts are the same.
stack cfa.
contexts are distinguished by the list of callsites on the call stack.
this strategy is k limited to ensure there are only a nite number of possible contexts.
we de ne thetrace component to contain the top kcall sites.
acyclic cfa.
contexts are distinguished the same as stackcfa but instead of k limiting we collapse recursive call cycles.
we de ne trace to contain all call sites on the callstack except that cycles are collapsed.
object sensitive.
contexts are distinguished by a list of addresses corresponding to the chain of receiver objects corresponding to full object sensitivity in smaragdakis et al.
.
we de ne trace to contain this information klimited to ensure nite contexts .
signature cfa.
type information is important for dynamically typed languages so intuitively it seems that type information would make good contexts.
we hypothesize that de ning trace to record the types of a call s arguments would be a good context sensitivity so that all k limited call paths with the same types of arguments would be merged.
mixed cfa.
object sensitivity uses the address of the receiver object.
however in javascript the receiver object is often the global object created at the beginning of the program execution.
intuitively it seems this would mean that object sensitivity might merge many calls that should be kept separate.
we hypothesized that it might be bene cial to de ne trace as a modi ed object sensitive strategy when object sensitivity would use the address of the global object this strategy uses the current call site instead.
.
evaluation in this section we evaluate jsai s precision and performance for a range of context sensitivities as described in section for a total of distinct sensitivities.
we run each sensitivity on benchmarks collected from four di erent application domains and analyze the results yielding surprising observations about context sensitivity and javascript.
we also brie y evaluate jsai as compared to tajs the most comparable existing javascript analysis.
.
implementation and methodology we implement jsai using scala version .
.
we provide a model for the dom event handling loop handled as non deterministic execution of event handling functions and other native apis used in our benchmarks.
the baseline analysis sensitivity we evaluate is fs ow sensitive contextinsensitive all of the other evaluated sensitivities are more precise than fs.
the other sensitivities are k.h stack h acyclic k.h obj k.h sig andk.h mixed wherekis the context depth fork limiting and his the heap sensitivity i.e.
the context depth used to distinguish abstract addresses .
the parameterskandhvary from to and h k. we use a comprehensive benchmark suite to evaluate the sensitivities.
most prior work on javascript static analysis has been evaluated only on the standard sunspider and v8 benchmarks with a few micro benchmarks thrown in.
we evaluate jsai on these standard benchmarks but we also include real world representatives from a diverse set of javascript application domains.
we choose seven representative programs from each domain for a total of programs.
we partition the programs into four categories described below.
for each category we provide the mean size of the benchmarks in the suite expressed as number of ast nodes generated by the rhino parser and the mean translator blowup i.e.
the factor by which the number of ast nodes increases when translating from javascript to notjs .
the benchmark names are shown in the graphs presented below the benchmark suite is included in the supplementary material.
the benchmark categories are standard seven of the largest most complex benchmarks from sunspider and v8 mean size nodes mean blowup addon seven firefox browser addons selected from the o cial mozilla addon repository mean size nodes mean blowup generated seven programs from the emscripten llvm test suite which translates llvm bitcode to javascript mean size nodes mean blowup and nally opensrc seven real world javascript programs taken from open source javascript frameworks and their test suites mean size nodes mean blowup .
.
our goal is to evaluate the precision and performance of jsai instantiated with several forms of context sensitivity.
however the di erent sensitivities yield di ering sets of function contexts and abstract addresses making a fair comparison di cult.
therefore rather than statistical measurements such as address set size or closure set size we choose a client based precision metric based on a error reporting client.
this metric is a proxy for the precision of the analysis.
our precision metric reports the number of static program locations i.e.
ast nodes that might throw exceptions based on the analysis ability to precisely track types.
javascript throws a typeerror exception when a program attempts to call a non function or when a program tries to access update or delete a property of nullorundef .
javascript throws a rangeerror exception when a program attempts to update the length property of an array to contain a value that is not an unsigned bit integer.
fewer errors indicate a more precise analysis.
the performance metric we use is execution time of the analysis.
to gather data on execution time we run each experimental con guration times discard the rst result then report the median of the remaining trials.
we set atime limit of minutes for each run reporting a timeout if execution time exceeds that threshold.
we run all experiments on amazon web services aws using m1 xlarge instances each experiment is run on an independent aws instance.
these instances have 15gb memory and ecus where each ecu is equivalent cpu capacity of a .
.
ghz opteron or xeon processor.
we run all analyses on each of the benchmarks for a total of trials multiplied by an additional executions for each analysis benchmark pair for the timing data .
for reasons of space we present only highlights of these results.
in some cases we present illustrative examples the omitted results show similar behavior.
in other cases we deliberately cherry pick to highlight contrasts.
we are explicit about our approach in each case.
a addon benchmarkstryagainodesk job wat...less spam ple...live pagerankcoffee pods d...chesspinpoints b generated benchmarksfastallubenchmarkfourinarowahasgefahashtestfannkuch c opensrc benchmarksrsalinq aggregateaeslinq enumerablelinq functionallinq actionlinq dictionary d standard benchmarkscrypto sha1richardssplay3d cubeaccess nbody3d raytracecryptobench .
stack .
stack acyclic .
obj .
obj .
sig .
sig .
mixed .
mixed fs figure a heat map to showcase the performance characteristics of di erent sensitivities across the benchmark categories.
the above gure is a two dimensional map of blocks rows correspond to benchmarks and columns correspond to analysis run with a particular sensitivity.
the color in a block indicates a sensitivities relative performance on the corresponding benchmark as compared to fastest sensitivity on that benchmark.
darker colors represent better performance.
completely blackened blocks indicate that the corresponding sensitivity has the fastest analysis time on that benchmark while completely whitened blocks indicate that the corresponding sensitivity does not time out but has a relative slowdown of at least .
the remaining colors are of evenly decreasing contrast from black to white representing a slowdown between to .
the red grid pattern on a block indicates a timeout.
.
observations for each main sensitivity strategy we present the datafor two trials the least precise sensitivity in that strategy and the most precise sensitivity in that strategy.
this set of analyses is fs .
stack .
stack acyclic .
obj .
obj .
sig .
sig .
mixed .
mixed .
figures and contain performance results and figure contains the precision results.
the results are partitioned by benchmark category to show the e ect of each analysis sensitivity on benchmarks in that category.
the performance graphs in figure plot the median execution time in milliseconds on a log scale giving a sense of actual time taken by the various sensitivity strategies.
lower bars are better timeouts extend above the top of the graph.
we provide an alternate visualization of the performance data through figure to easily depict how the sensitivities perform relative to each other.
figure is heat map that lays out blocks in two dimensions rows represent benchmarks and columns represent analyses with di erent sensitivities.
each block represents relative performance as a color darker blocks correspond to faster execution time of a sensitivity compared to other sensitivities on the same benchmark.
a completely blackened block corresponds to the fastest sensitivity on that benchmark a whitened block corresponds to a sensitivity that has slowdown relative to the fastest sensitivity and the remaining colors evenly correspond to slowdowns in between.
blocks with the red grid pattern indicate a timeout.
a visual cue is that columns with darker blocks correspond to better performing sensitivities and a row with blocks that have very similar colors indicates a benchmark on which performance is una ected by varying sensitivities.
figure provides a similar heat map with similar visual cues for visualizing relative precisions of various sensitivity strategies on our benchmarks.
the nal column in this heat map provides the number of errors reported by the fs strategy on a particular benchmark while the rest of the columns provide the percentage reduction relative to fs in the number of reported errors due to a corresponding sensitivity strategy.
the various blocks except the ones in the nal column are color coded in addition to providing percentage reduction numbers darker is better precision that is more reduction in number of reported errors .
timeouts are indicated using a red grid pattern.
breaking the glass ceiling.
one startling observation is that highly sensitive variants i.e.
sensitivity strategies with highkandhparameters can be far better than their less sensitive counterparts providing improved precision at a much cheaper cost see figure .
for example on linq dictionary .
stack is the most precise andmost e cient analysis.
by contrast the .
stack analysis yields the same result at a three fold increase in cost while the .
stack analysis is even more expensive and less precise.
we see similar behavior for the sgefa benchmark where .
stack is an order of magnitude faster than .
stack and delivers the same results.
this behavior violates the common wisdom that values of kandhabove or are intractably expensive.
this behavior is certainly not universal 6but it is intriguing.
analysis designers often try to scale up their contextsensitivity in terms of kandh linearly and they stop when it becomes intractable.
however our experiments suggest that pushing past this local barrier may yield much better 6for example linq aggregate times out on all analyses with k .
.
stack5.
stack4.
acyclic1.
obj5.
obj1.
sig5.
sig1.
mixed5.
mixedfs crypto sha1richardssplay3d cubeaccess nbody3d raytracecryptobench tryagainodesk job wat...less spam ple...live pagerankcoffee pods d...chesspinpointsexecution time ms a addon benchmarks fastallubenchmarkfourinarowahasgefahashtestfannkuchexecution time ms b generated benchmarks rsalinq aggregateaeslinq enumerablelinq functionallinq actionlinq dictionaryexecution time ms c opensrc benchmarks crypto sha1richardssplay3d cubeaccess nbody3d raytracecryptobenchexecution time ms d standard benchmarks figure performance characteristics of di erent sensitivities across the benchmark categories.
the x axis gives the benchmark names.
the y axis log scale gives for each benchmark the time taken by the analysis in milliseconds when run under di erent sensitivities.
lower bars mean better performance.
timeout minutes bars are ush with the top of the graph.
results.
callstring vs object sensitivity.
in general we nd that callstring based sensitivity i.e.
k.h stack andh acyclic is more precise than object sensitivity i.e.
k.h obj .
this result is unintuitive since javascript heavily relies on objects and object sensitivity was speci cally designed for objectoriented languages such as java.
throughout the benchmarks the most precise and e cient analyses are the ones that employ stack based k cfa.
part of the reason for this trend is that of the benchmarks are machine generated javascript versions of procedural code whose structure yields more bene ts to callstring based context sensitivity.
even among the handwritten open source benchmarks however this trend holds.
for example several forms of callstring sensitivity are more e cient and provide more precise results for the open source benchmarks than object sensitivity which often times out.
bene ts of context sensitivity.
when it comes to pure precision we nd that more context sensitivity sometimes increases precision and sometimes has no e ect.
the opensource benchmarks demonstrate quite a bit of variance for the precision metric.
a context sensitive analysis almost always nds fewer errors i.e.
fewer false positives than a context insensitive analysis and increasing the sensitivity in a particular family leads to precision gains.
for example .
stack gives the most precise error report for linq enumerable and it is an order of magnitude more precise than a contextinsensitive analysis.
on the other hand the addon domain has very little variance for the precision metric which is perhaps due to shorter call sequence lengths in this domain.
in such domains it might be wise to focus on performance rather than increasing precision.summary.
perhaps the most sweeping claim we can make from the data is that there is no clear winner across all benchmarks in terms of javascript context sensitivity.
this state of a airs is not a surprise the application domains for javascript are so rich and varied that nding a silver bullet for precision and performance is unlikely.
however it is likely that within an application domain e.g.
automatically generated javascript code one form of contextsensitivity could emerge a clear winner.
the bene t of jsai is that it is easy to experiment with the control ow sensitivity of an analysis.
the base analysis has already been speci ed the analysis designer need only instantiate and evaluate multiple instances of the analysis in a modular way to tune analysis sensitivity without having to worry about the analysis soundness.
.
discussion jsai vs.tajs jensen et al.
s type analysis for javascript tajs stands as the only published static analysis for javascript whose intention is to soundly analyze the entire javascript language.
jsai has several features that tajs does not including con gurable sensitivity a formalized abstract semantics and novel abstract domains but tajs is a valuable contribution that has been put to good use.
an interesting question is how jsai compares to tajs in terms of precision and performance.
the tajs implementation in java has matured over a period of ve years it has been heavily optimized and it is publicly available.
ideally we could directly compare tajs to jsai with respect to precision and performance but they are dissimilar enough that they are e ectively noncomparable.
for one tajs has known soundness bugs that can arti cially decrease its set of reported type errors.
also a addon benchmarkstryagain0 16odesk job wat... 18less spam ple... 62live pagerank15 13coffee pods d... 5chess17 24pinpoints2 b generated benchmarksfasta92 36llubenchmark99 287fourinarow88 24aha67 27sgefa99 287hashtest91 35fannkuch91 c opensrc benchmarksrsa29 34linq aggregate88 267aes0 4linq enumerable95 374linq functional73 335linq action92 169linq dictionary81 d standard benchmarkscrypto sha10 0richards0 42splay0 303d cube8 53access nbody0 63d raytrace29 48cryptobench27 .
stack .
stack acyclic .
obj .
obj .
sig .
sig .
mixed .
mixedfsfigure a heat map to showcase the precision characteristics based on number of reported runtime errors of di erent sensitivities across the benchmark categories.
the above gure is a twodimensional map of blocks rows correspond to benchmarks and columns corresponds to analysis run with a particular sensitivity.
the rightmost column corresponds to the context insensitive analysis fs and the blocks in this column give the number of errors reported by the analysis under fs which is an upper bound on the number of errors reported across any sensitivity .
the color which ranges evenly from black to white in the remaining blocks indicate the percentage reduction in number of errors reported by the analysis under the corresponding sensitivity compared to fs on the same benchmark.
darker colors represent more reduction in errors reported and hence better precision.
in addition to the colors the percentage reduction in errors is also given inside the blocks higher percentage reduction indicates better precision .
the red grid pattern on a block indicates a timeout.
vwdfn vwdfn rem rem iv figure precision vs.performance of various sensitivities on theopensrc linq dictionary benchmark.
interestingly .
stack the most sensitive stack cfa analysis is not only tractable it exhibits the best performance and the best precision.tajs does not implement some of the apis required by our benchmark suite and so it can only run on a subset of the benchmarks.
on the ip side tajs is more mature than jsai it has a more precise implementation of the core javascript apis and it contains a number of precision and performance optimizations e.g.
the recency heap abstraction and lazy propagation that jsai does not currently implement.
nevertheless we can perform a qualitative ballpark comparison to demonstrate that jsai is roughly comparable in terms of precision and performance.
for the subset of our benchmarks on which both jsai and tajs execute we catalogue the number of errors that each tool reports and record the time it took for each tool to do so.
we nd that jsai analysis time is .
to .
that of tajs.
in terms of precision jsai reports from nine fewer type errors to more type errors compared to tajs.
many of the extra type errors that jsai reports are rangeerrors which tajs does not report due to one of the unsoundness bugs we uncovered.
excluding rangeerrors jsai reports at most more errors than tajs in the worst case.
.
conclusion we have described the design of jsai a con gurable sound and e cient abstract interpreter for javascript.
jsai s design is novel in a number of respects which make it stand out from all previous javascript analyzers.
we have provided a comprehensive evaluation that demonstrates jsai s usefulness.
the jsai implementation and formalisms are freely available as a supplement and we believe that jsai will provide a useful platform for people building javascript analyses.