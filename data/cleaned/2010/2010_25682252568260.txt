an exploratory study of the pull based software development model georgios gousios delft university of technology delft the netherlands g.gousios tudelft.nlmartin pinzger university of klagenfurt klagenfurt austria martin.pinzger aau.atarie van deursen delft university of technology delft the netherlands arie.vandeursen tudelft.nl abstract the advent of distributed version control systems has led to the development of a new paradigm for distributed software development instead of pushing changes to a central repository developers pull them from other repositories and merge them locally.
various code hosting sites notably github have tapped on the opportunity to facilitate pull based development by offering workflow support tools such as code reviewing systems and integrated issue trackers.
in this work we explore how pull based software development works first on the ghtorrent corpus and then on a carefully selected sample of projects.
we find that the pull request model offers fast turnaround increased opportunities for community engagement and decreased time to incorporate contributions.
we show that a relatively small number of factors affect both the decision to merge a pull request and the time to process it.
we also examine the reasons for pull request rejection and find that technical ones are only a small minority.
categories and subject descriptors d. .
distribution maintenance and enhancement version control d. .
management programming teams general terms management keywords pull based development pull request distributed software development empirical software engineering .
introduction pull based development is an emerging paradigm for distributed software development.
as more developers appreciate isolated development and branching more projects both closed source and especially open source are being migrated to code hosting sites such as github and bitbucket which provide support for pullbased development .
a unique characteristic of such sites is that permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.they allow any user to clone any public repository.
the clone creates a public project that belongs to the user that cloned it so the user can modify the repository without being part of the development team.
furthermore such sites automate the selective contribution of commits from the clone to the source through pull requests.
pull requests as a distributed development model in general and as implemented by github in particular form a new method for collaborating on distributed software development.
the novelty lays in the decoupling of the development effort from the decision to incorporate the results of the development in the code base.
by separating the concerns of building artifacts and integrating changes work is cleanly distributed between a contributor team that submits often occasional changes to be considered for merging and a core team that oversees the merge process providing feedback conducting tests requesting changes and finally accepting the contributions.
previous work has identified the processes of collaboration in distributed development through patch submission and acceptance .
there are many similarities to the way pull requests work for example similar work team structures emerge since typically pull requests go through an assessment process.
what pull requests offer in addition is process automation and centralization of information.
with pull requests the code does not have to leave the revision control system and therefore it can be versioned across repositories while authorship information is effortlessly maintained.
communication about the change is contextspecific being rooted on a single pull request.
moreover the review mechanism that github incorporates has the additional effect of improving awareness core developers can access in an efficient way all information that relates to a pull request and solicit opinions of the community crowd source about the merging decision.
a distributed development workflow is effective if pull requests are eventually accepted and it is efficient if the time this takes is as short as possible.
advancing our insight in the effectiveness and efficiency of pull request handling is of direct interest to contributors and developers alike.
the goal of this work is to obtain a deep understanding of pull request usage and to analyze the factors that affect the efficiency of the pull based software development model.
specifically the questions we are trying to answer are rq1 how popular is the pull based development model?
rq2 what are the lifecycle characteristics of pull requests?
rq3 what factors affect the decision and the time required to merge a pull request?
rq4 why are some pull requests not merged?permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
our study is based on data from the github collaborative development forge as made available through our ghtorrent project .
using it we first explore the use of almost million pull requests across all projects in github.
we then examine carefully selected ruby python java and scala projects in total pull requests and identify using qualitative and quantitative analysis the factors that affect pull request lifetime merging and rejection.
.
background since the appearance of the first open source implementations in distributed version control systems dvcs notably git have revolutionized the way distributed software development is carried out.
driven by pragmatic needs most dvcs s were designed from scratch to work as advanced patch management systems rather than versioned file systems the then dominant version control paradigm.
in most dvcs s a file is an ordered set of changes the serial application of which leads to the current state.
changes are stamped by globally unique identifiers which can be used to track the commit s content across repositories.
when integrating changes the change sets can originate from a local filesystem or a remote host tools facilitate the acquisition and application of change sets on a local mirror.
the distributed nature of dvcs s enables a pull based development model where changes are offered to a project repository through a network of project forks it is up to the repository owner to accept or reject the incoming pull requests.
the purpose of distributed development is to enable a potentialcontributor to submit a set of changes to a software project managed by a core team .
the development models afforded by dvcs s are a superset of those in centralized version control environments .
with respect to receiving and processing external contributions the following strategies can be employed with dvcs shared repository.
the core team shares the project s repository with read and write permissions with the contributors.
to work contributors clone it locally modify its contents potentially introducing new branches and push their changes back to the central one.
to cope with multiple versions and multiple developers larger projects usually adopt a branching model i.e.
an organized way to inspect and test contributions before those are merged to the main development branch .
pull requests.
the project s main repository is not shared among potential contributors instead contributors fork clone the repository and make their changes independent of each other.
when a set of changes is ready to be submitted to the main repository they create a pull request which specifies a local branch to be merged with a branch in the main repository.
a member of the project s core team is then responsible to inspect the changes and pull them to the project s master branch.
if changes are considered unsatisfactory more changes may be requested in that case contributors need to update their local branches with new commits.
furthermore as pull requests only specify branches from which certain commits can be pulled there is nothing that forbids their use in the shared repository approach cross branch pull requests .
an overview of the pull request process can be seen in figure .
pull requests in github.
github supports all types of distributed development outlined above however pull requests receive special treatment.
the site is tuned to allow easy forking of projects by contributors while facilitating the generation of pull requests through automatic comparison of project branches.
github s pull request model follows the generic pattern presented above in addition it provides tools for contextual discussions and in line figure the pull request process.
code reviews.
an example pull request on github can be seen in figure .
a github pull request contains a branch local or in another repository from which a core team member should pull commits.
github automatically discovers the commits to be merged and presents them in the pull request.
by default pull requests are submitted to the base upstream in git parlance repository for inspection.
the inspection is either a code review of the commits submitted with the pull request or a discussion about the features introduced by the pull request.
any github user can participate to both types of inspection.
as a result of the inspection pull requests can be updated with new commits or be closed as redundant uninteresting or duplicate.
in case of an update the contributor creates new commits in the forked repository while github automatically updates the displayed commits.
the code inspection can then be repeated on the refreshed commits.
when the inspection process finishes and the pull requests are deemed satisfactory the pull request can be merged.
a pull request can only be merged by core team members.
the versatility of git enables pull requests to be merged in three ways presented below sorted by the amount of preservation of the original source code properties .
through github facilities.
github can automatically verify whether a pull request can be merged without conflicts to the base repository.
when a merge is requested github will automatically apply the commits in the pull request and record the merge event.
all authorship and history information is maintained in the merged commits.
.
using git merge.
when a pull request cannot be applied cleanly or when project related policies do not permit automatic merging a pull request can be merged using plain git utilities using the following techniques branch merging the branch in the forked repository containing the pull request commits is merged into a branch in the base repository.
both history and authorship information are maintained but github cannot detect the merge in order to record a merge event .
cherry picking instead of merging all commits the merger picks specific commits from the remote branch which then applies to the upstream branch.
the unique commit identifier changes so exact history cannot be maintained but authorship is preserved .
a technique that complements both of the above is commit squashing if the full history is not of interest to the project several346figure an example github pull request from junitteam junit edited for space .
the participants first interact in a code review the result of which is a new commit.
the second reviewer then merges the pull request consecutive commits are combined into a single one on the pull request branch which can then be merged or cherry picked to the upstream branch.
in this case the author of the commit is different from the person that applied the commit .
both cherry picking and commit squashing are by products of git s support for re ordering commits rebase .
.
committing the patch.
the merger creates a textual difference between the upstream and the pull request branch which she then applies to the upstream branch.
both history and authorship information are lost.
as the project branches are updated in a distributed manner the changes in a pull request may interfere with new changes in the project s main branch.
merging such a pull request will result in conflicts .
github automatically detects conflicting pull requests and marks them as such.
conflicts can be resolved by either the contributor or a core team member however pull request etiquette dictates that the contributor takes care of bringing the pull request back into a state where there are no conflicts.
the conflict resolution process involves pulling new commits from the project s main repository making changes to eliminate the conflicts and extending the pull request with the resulting conflict eliminating commits.
issues and pull requests are dual on github for each pull request an issue is opened automatically.
commits can also be attached to issues to convert them to pull requests albeit with external tools .
this duality enables the core team to treat pull requests as work items which can be managed using the same facilities used for issues.
moreover issue discussions can include links to pull requests and vice versa while specific commit message formats can be usedto automatically close issues or pull requests when commits are merged to the project s main branch.
the open nature of github s pull requests lends itself to a variety of usage patterns.
except from basic patch submission pull requests can be used as a requirements and design discussion tool1 or as a progress tracking tool towards the fulfillment of a project release.2in the first case a pull request serves as a discussion board for soliciting the opinions of other developers while a new feature is being implemented.
in the second case pull requests are associated with milestones in github s issue tracker.
.
research design the main focus of this study is to understand and explain how pull requests are used by projects to enable collaboration.
to answer our research questions we use a sequential mixed methods approach a procedure for collecting analyzing and integrating both quantitative and qualitative data at some stage of the research process within a single study for the purpose of gaining a better understanding of the problem .
for specific research questions we first explore the domain quantitatively and then highlight interesting cases by exploring cases qualitatively.
below we present how we approached each research question.
rq1 to assess the popularity of the pull based development model we provide and analyze descriptive statistics on the use of pull requests in github.
in particular we investigate such questions as how many projects actually make use of pull requests how many of the projects are original repositories versus e.g.
forks and how pull requests relate to github s issue tracking facilities.
the outcomes are presented in section .
rq2 and rq3 identifying the lifecycle characteristics of pull requests and determining the factors that affect them calls for a dedicated dataset of projects that have a sufficiently long history of using pull requests.
this dataset is described in section .
.
given this dataset we answer rq2 and rq3 by determining a set of suitable candidate features through consultation of related work in the fields of patch submission bug triaging code reviewing and distributed collaboration.
then we clean it up through cross correlation analysis to obtain a set of features with maximum predictive power.
using the data from the extracted features we perform a detailed statistical analysis of pull request characteristics to answer rq2 section .
next we use machine learning to retrieve the dominant features.
prior to running the classification algorithms we automatically labeled each pull request with an outcome factor in the case of the merge decision classification task the label signifies whether the pull request has been merged.
for the merge time task we first filter out pull requests that have not been merged and then split the remaining data points into three classes hour day more than a day according to the time required to merge the pull request.
the split points were chosen to reflect the results of rq2 and split the available data points into roughly equally sized bins.
at a high level the process to retrieve the dominant features for both classification tasks consists of two steps.
first we run each dataset through classification algorithms namely random forests randomforest variants of logistic regression logregr binary for the merge decision task multinomial for the merge time task and na ve bayes naivebayes support vector machines svm decision trees dtree and adaboost with decision trees adaboost .
we used those algorithms as they 1github uses this internally known to perform well in large datasets and have been used in previous work involving prediction models .
we do not perform any additional tuning to the classification algorithms.
we only report results on the first three as those performed best.
then we select the best classifier and apply a classifier specific process to rank features according to their importance in the classification process.
to evaluate the classification performance we use the accuracy acc and area under the receiver operating characteristic curve auc metrics.
to select the appropriate classification algorithm we run a fold random selection cross validation and aggregate the mean values for each classification metric.
at each iteration the algorithm randomly samples half of the available data points trains a classifier with percent of the input and uses it to predict the remaining .
the fold run results also allowed us to evaluate the metric stability across runs section .
rq4 to examine why some pull requests are not merged we qualitatively analyze a set of randomly chosen non merged pull requests in depth.
we use open coding a grounded theory tool to come up with an inclusive set of reasons of why pull requests are not merged as follows the first author read the pull request discussion on github for randomly selected pull requests and summarized the reasons for closing them into one sentence per sample during a second pass the descriptions were aggregated and codes were extracted.
to validate the identified codes all three authors applied them on a different set of pull requests compared results identified inconsistencies and retrofitted the initial selection of codes.
the final set of codes was then applied on a third sample which we used to draw results from.
the sampling process is described in section .
.
.
data .
github data we used github data as provided through our ghtorrent project an off line mirror of the data offered through the github api.
the github apidata come in two forms a streaming data flow lists events such as forking or creating pull requests happening on repositories in real time while a static view contains the current state of entities.
to obtain