model checking distributed systems by combining caching and process checkpointing watcharin leungwattanakit c y r i l l ea r t h o m a s a m ih a g i y a y o s h i n o r it a n a b e and mitsuharu yamamoto graduate school of information science and technology the university of tokyo tokyo japan email watcharin hagiya is.s.u tokyo.ac.jp research center for information security aist tsukuba j apan email c.artho aist.go.jp national institute of informatics tokyo japan email y tanabe nii.ac.jp chiba university chiba japan email mituharu math.s.chiba u.ac.jp abstract verification of distributed software systems by model checking is not a straightforward task due to interprocess communication.
many software model checkers only explore the state space of a single multi threaded process.
recent work has proposed a technique that applies a cache to capture communication between the main process and its peers and allows the model checker to complete state space explorati on.
although previous work handles non deterministic output i n the main process any peer program is required to produce deterministic output.
this paper introduces a process checkpointing tool.
the com bination of caching and process checkpointing makes it poss ible to handle nondeterminism on both sides of communication.
pe er states are saved as checkpoints and restored when the model checker backtracks and produces a request not available in t he cache.
we also introduce the concept of strategies to contro l the creation of checkpoints and the overhead caused by the checkpointing tool.
index terms software model checking caching software verification distributed systems checkpointing i. i ntroduction networked software is usually implemented as a concurrent program using multiple threads to handle connections.
threads are execution units within a given process .
the interleaving among threads i.e.
thread scheduling is tak en care of by an operating system thus it is beyond the control of programmers.
as a result software testing may miss some failures under a certain sequence of interleaving because it cannot cover all possible thread schedules in one run.
chess remedies this disadvantage by executing a test case repeatedly to find concurrent failures and ensurin g that every run takes a different interleaving.
more program behaviors are tested by this technique.
model checking is a more powerful verification technique that takes every possible schedule into account.
some software model checke rs such as java pathfinder jpf execute real application code at runtime and are applied in the implementation phase of a software development.
in this paper the main process to be verified is called the system under test sut .t h e system under test is backtracked by a model checker duringverification to analyze multiple outcomes of non determini stic decisions such as thread scheduling and variable input dat a. the combination of decisions increases exponentially over the number of instructions.
as a result the program state space is usually too large to be explored exhaustively withi na reasonable amount of time.
this limitation is called the state explosion problem w h i c hi so n eo ft h ef u n d a m e n t a lp r o b l e m s for model checking.
partial order reduction is a techniq ue to relieve the state explosion by atomically executing a gro up of program instructions that do not affect any other threads .
this method reduces the number of thread interleavings and thus the size of the state space.
verifying a distributed system with a model checker is not a straightforward process.
the distributed system is composed of several computational entities that exchange d ata and interoperate with one another through a network.
each process may run on a different environment increasing syst em complexity.
most software model checkers only handle a single process at a time and cannot be applied simulatenousl y to all processes of the distributed system.
when a process in the system is executed as the sut by the model checker the other processes are running as peer processes in the normal execution environment.
since the peer processes are not und er model checker control they cannot be backtracked in tandem with the sut.
after the sut backtracks it may try to interact with the peers which are not in a state to respond correctly.
several techniques have been established to automate the verification of such systems.
some of them are briefly introduced in section ii.
our previous work has shown that an i o cache can interact with the sut on behalf of the peer.
a. cache based verification fundamentally dynamic software verification can be carried out by two approaches testing and model checking.
figures a and 1b compare the configurations of both approaches in the verification of a distributed application.
testing execute sb o t h the sut and peers in the normal execution environment.
onlysut peer 1peer a software testing setup.model checkerpeer peer 2c a c h esut b cache based model checking setup.model checker check pointing environmentpeer peer 2c a c h esut c checkpointing support setup.
figure three configurations testing cache based model checking and model checking with checkpointing support.
one execution path of the sut is exercised for each run in this configuration.
on the other hand model checking executes the sut inside an environment where the program state may be rolled back.
thus the sut can be systematically driven through every possible execution path.
in case of a multiprocess application the i o cache is required to interact w ith the sut on behalf of the peers .
the i o cache intercepts every request packet ad a t ap a c k e ts e n tb yt h e sut and stores it in an internal data structure.
similarly response packets coming back from the peers are stored in the i o cache as well.
each request packet is matched with its corresponding response packet if any.
the i o cache use s this information to imitate peer behaviors.
as a result the sut experiences the same interaction with the i o cache that wou ld encounter with the actual peers.
the single process model checker then can complete the exploration of the sut state space.
in so it avoids an expensive analysis of the ful l state space of each peer.
similar to a partial order reducti on this reduces the state space significantly.
by analyzing the full state space of the sut combined with only a few rather than all peer executions cache based verification allows syst ems to be analyzed that were previously out of reach for model checking .
in this research determinism of programs is defined to be based on the output they produce with respect to input on acommunication channel .n o t et h a tm u l t i t h r e a d e dp r o g r a m s whose thread schedules are non deterministic can still pro duce deterministic output by this definition.
we do not impose a restriction on internal non determinism of programs.
fu r thermore the term deterministic output means that the output solely depends on the input trace of the communicatio n peer.
a program with deterministic output may still produce ad i f f e r e n to u t p u tp a t t e r ni fi tr e c e i v e sad i f f e r e n ti n p u tt race.
the initial implementation of the i o cache assumed determinism of the sut output .
however this assumption is not always true.
some kinds of programs serve clients with dynamic data e.g.
web servers and database servers.
their outcomes do not only depend on the response from a peer but also on their internal state.
therefore the i o cache may ob serve multiple patterns of request packets from such progra ms running as sut.
we can say that the sut behaves in a nondeterministic way from the perspective of the i o cache.
to handle programs with non deterministic output the i o cac he creates for each distinct request pattern a new instance o ft h e peer.
each instance of the peer is responsible for one reques t pattern.
while non determinism on the sut side is taken into account previous work assumes deterministic out put from peers.
previous work restores a peer state by replaying previously recorded communication to a new instance of the peer non deterministic peer systems cannot be handle d in this way.
b. extension for non deterministic peers this paper proposes a method to support non deterministic output from both sut and peers with the help of process checkpointing .p r o c e s sc h e c k p o i n t i n gi sat e c h n i q u et h a tr u n s ag r o u po fp r o c e s s e si na ne n v i r o n m e n tt h a tk e e p st r a c ko f the process states.
this environment is called a checkpointing environment .f i g u r e1 cs h o w st h ec o n fi g u r a t i o no fc a c h e based model checking with a checkpointing environment.
the checkpointing environment creates a checkpoint of the peer s when requested by the i o cache.
when the i o cache needs to synchronize the state of the sut and peers the checkpointin g environment restarts the peers from an appropriate checkpo int.
this avoids replaying peer actions that may cause the previously executed non deterministic transition to be repea ted.
thus the sut only observes one peer behavior for each sut output trace.
this method eliminates false positives cause db y different instances of peers interacting with the sut under one execution path.
nondeterminism inside a peer can be divided into two types by its source thread scheduling and external input.
thread scheduling is controlled by an operating system.
even thoug h ap e e ri sl o a d e df r o mac h e c k p o i n t t h e r ei sn og u a r a n t e e that the peer will execute under the same thread schedule.
accordingly we assume peer output of each communication channel is independent of thread scheduling.
checkpointing a process is an expensive operation.
it naively would incur extremely high overhead.
we propose strategies to prevent the model checker from creating unnec essary checkpoints.
the contribution of this work is as follow s the application of process checkpointing to software model checking.
support for distributed applications that produce nondeterministic output.
introducing checkpointing strategies.
am o d e lc h e c k e re x t e n s i o nt h a ti m p l e m e n t st h ep r o p o s e d algorithm.
c. outline section ii shows related work to verify distributed applications.
section iii presents how to make use of process checkpointing in software model checking.
section iv gives the implementation details of the model checker extension that supports peers with non deterministic output.
sectio nv presents and analyzes experimental results of the checkpoi ntsupported i o cache on several systems under test.
section v i concludes the paper and proposes future work.
ii.
r elated work several approaches have been presented to automate verification of distributed systems.
the centralization technique offers automatic unification of processes.
it collects a ll processes in an application and transforms each process to a thread.
all threads start inside a process called a centralized process w h i c hc a nb ea u t o m a t i c a l l yg e n e r a t e db yat o o l .a single process model checker runs the centralized process which starts all threads at the beginning and verifies the entire system at once.
since all processes must be wrapped into one process they must be written in the same programming language and be compiled on the same platform.
these requirements are not always fulfilled.
the centraliza tion approach does not scale well since exploring the interleavi ngs of all processes in the system yields very large state space.
implementing a multi process model checker is one of the solutions.
this idea was proposed in .
the extension of user mode linux called scrapbook can save and restore the state of a system running inside a virtual environment.
a sut is executed inside the virtual environment.
note that th ere is no peer process in this approach because every process is inside the virtual environment.
each process of the applica tion is controlled by an instance of gdb gnu debugger .
given a set of breakpoints gdb suspends the process.
a user specifies these breakpoints beforehand.
scrapbook works as am o d e lc h e c k e ri nt h es e n s et h a ti tc a ns a v ea n dr e v e r tt h e system state.
since the state of the entire system must be sav ed and restored during verification this approach is not scala ble as well.
verisoft is another model checking tool that verifies concurrent processes.
it deals directly with the implement ation of a target system which may comprise multiple processes.
however it could not handle multi threaded processes and d id not maintain states of file descriptors for files and sockets that the system would open.
therefore modern applications composed of multiple threads cannot be directly verified by the tool.
net iocacheiii.
p rocess checkpointing support this section explains how process checkpointing is applied to verification of distributed systems.
this idea is built on the concept of the i o cache which is reviewed in section iii a. some checkpointing tools are briefly introduced in section iii b. we use process checkpointing to capture consist ent behaviors of peer processes.
without process checkpointin g the i o cache may store inconsistent data which causes the model checker to report false positives.
such a situation is shown in section iii c. we propose an optimization method in section iii d in order to reduce the number of checkpoints and control the overhead caused by the checkpointing tool.
a. fundamentals of the i o cache the i o cache is a software module that controls data packets transferred between a sut and a peer.
it captures the messages sent by the sut and matches them to the corresponding messages from the peer.
a message from the sut is called a request message while one from the peer is called a response message .ar e q u e s tm e s s a g ew i l lb es t o r e d in an internal data structure if the i o cache receives it for the first time.
in this case the i o cache will poll the peer process for a response message.
if a response message is available the i o cache will match it with the most recent request message .
on the other hand if the i o cache receives a request message it has received before it will se nd the response message associated with that request message t o the sut.
figure demonstrates how the i o cache works on a two thread sut.
let wandrbe threads that produce an output trace and receive an input trace respectively.
thre ad wrandomly produces string or .
in the first schedule thread wwrites denoted by w .t h ec a c h em e m o r i z e s the data block transferred and shades the block to indicate t hat the sut has passed through.
then the i o cache sends the request message to the peer and polls a response message.
the response message is saved in the next block figure 2a .
note that the response message is not shaded because the sut has not read it yet.
in the next step thread rattempts to read a message and receives the previously cached response message.
the i o cache shades the read block to mark that the sut has already received this message figure 2b .
suppose that thread wproduces in the next step the i o cache becomes like figure 2c.
when the sut backtracks to state the i o cache restores the shade position but the cached dat a remains permanent figure 2d .
the model checker executes another possibility in which wproduces .
at this time the peer is restarted from the beginning to handle the new request messages figure 2e .
the sut backtracks to state .
thread wmay execute at this point with two options writing or .
suppose that it writes the i o cache in fact does not write this message to the peer since the message is already in the cache.
instead it only shades the associated data block to remember the state of the data strea m figure 2f .
the model checker continues running until the end3w w r b r a 4w r c 5w end3 c d e f 1w root a a 2root b 0w r a w w r b a r a root a0 b0 end3w w r b r a 4w root a0 b end3w w r b r a 4w r c root a0 b2 croot a0 b2 cfigure evolution of the partial state space and cached tra ces.
two different communication traces are represented by solid lines and dashed lines.
rectangular nodes represent reques tm e s s a g e s .c i r c l e dn o d e sr e p r e s e n tr e s p o n s em e s s a g e s .
whole state space is explored with the help of the i o cache which interacts with the sut as a peer.
b. checkpointing environments process checkpointing is a technique to create a snapshot of a group of processes.
the snapshot stored in non volatile memory is referred to as a checkpoint .ac h e c k p o i n tc a nb e loaded later on to recreate the process group in a certain sta te.
after checkpointing the recreated processes can continue running from where they were suspended as if they had not stopped running.
most virtualization tools provide checkpointing functions save and restore .h o w e v e r v i r t u a l ization consumes a large amount of system resources since it applies those functions on the entire system.
initially we implemented our approach by using kernel based virtual machine kvm .
it took a few seconds merely to create one snapshot of a system rendering it impractical.
al i g h t w e i g h tc h e c k p o i n t i n gp a c k a g es u c ha s mtcp can be used as a replacement in certain circumstances where ap e e ri sas i n g l e p r o c e s sp r o g r a m .t h ec h e c k p o i n t i n gp a c k a ge takes care of the state of a single process unlike the virtua lization tools.
it approximately takes millisecond so naverage in order to create a checkpoint which is acceptable .
distributed multithreaded checkpointing dmtcp is an extended version of mtcp which manages a group of processes connected by network connections or parent chil d relations.
this work employs dmtcp as the checkpointing environment to support the i o cache.
all peer processes are controlled by dmtcp.
checkpointing environments introduce a new method to synchronize a sut and a peer.
model checkers save sut states in order to backtrack it to any previously visited poi nt in the state space.
a checkpointing tool can do the same with peer processes.
when the i o cache has detected a new communication trace from the sut it restores the peer proce ss from a checkpoint saved prior to the equivalent state instea d of restarting the peer from the beginning.
in the extreme case we may create a peer checkpoint for each sut state.
in practice the peer does not have to be checkpointed as often as the sut.
some peer checkpoints may be omitted under ac e r t a i nc o n d i t i o n .a no p t i m i z a t i o nm e t h o di sd i s c u s s e di n section iii d. 4root a c fs00 a b1 c e d fs s1 2b?root a c efigure left state transition diagram of a peer that prod uces non deterministic output.
middle one possibility of inc orrect cached data.
right correct cached data.
c. support for non deterministic peer output in this paper we propose an approach to cope with nondeterministic peer output.
an example of such a peer is shown in figure left .
the peer may change state and produce output differently a and b in each run although it rec eives the same data as shown in the transitions from s0to s1ands2.t h ei oc a c h ea p p r o a c hw i t h o u tc h e c k p o i n t i n g restarts the peer process when the sut produces a different trace after backtracking .
this technique does not work if the peer also produces non deterministic output which may cause inconsistency in the cached data.
suppose that the pee r moves from s0tos1 t h ei oc a c h er e c e i v e s a a n d c from the peer.
after backtracking the sut produces a new trace request message is added into a new branch forcing the peer to restart.
the new peer may move from state s0to state s2after receiving message .
the transition to s2emits b which differs from the existing cache content a .
the i o cache may handle a mismatch by aborting the process or giving a warning and continuing.
if it contin ues it will receive f as a response for .
the cache contents in figure middle indicate that the sut receives response message af for request message which is an incorrect behavior.
according to the state transition diagram in figu re left the peer obviously never produces a and f in the same run.
the i o cache may return an incorrect response message because the new peer does not stay in the same state as its previous instance did.
as a result the model checker would report a false positive due to the communication trace that the sut never receives in a normal environment.
this inconsistency can bring about a serious problem if the communication between two programs depends on the results of non deterministic peer operations.
for example a sut an d ap e e rm a yp e r f o r m key exchange by generating random values required to build a shared secret key.
if the i o cache restarts the peer later the peer will generate a new random value for building the key.
the key obtained from the new random value is different from what the sut is holding.
as ar e s u l t b o t hp r o g r a m sc a n n o td e c r y p tm e s s a g e sf r o mt h e opponent after the peer has restarted.
this issue can be solved by running a peer in a checkpointing environment which can save and revert the peer state.
as0 5c s s s s s s0 c c c2 c5c1 c4 figure left sut state space.
dashed lines represent transitions without network i o operations.
right peer c heckpoint space.
solid line circles represent physical checkp oints.
dashed line circles represent logical checkpoints.
peer checkpoint is created as the sut changes state.
states s0ands1are saved for the example in figure .
when the sut needs the peer in a certain state the peer is restarted in a way that it will produce outcomes consistent with the cached contents.
in this case the peer is restarted from state s1.t h e peer continues running from that point and correctly sends response message e for request message .
the correct cache contents are shown in figure right .
by this method only one behavior of the peer is revealed to the sut as if the peer produced deterministic output.
d. checkpointing strategies checkpointing every single peer state is not always necessary and not efficient since the i o cache can replay cached messages in most cases.
instead we introduce a concept of logical checkpoints w h i c hd on o to c c u p yd i s ks p a c e .t h e y are created as the model checker discovers new states of a sut.
figure shows checkpoint space as compared to sut state space.
state siassociates with logical checkpoint ci.
acheckpointing strategy defines how to maintain the balance of the checkpoint creation overhead with the possibili ty of restoring a previous state directly.
it decides whether t o create a physical checkpoint w h i c ho c c u p i e ss t o r a g es p a c e over the corresponding logical checkpoint.
when the sut needs the peer at a specific state the model checker restores the corresponding logical checkpoint.
if it lacks a physica l checkpoint the peer will be instead restored from the mostrecent physical checkpoint on a path to that logical checkpo int.
after that the model checker must replay communication data from there up to the designated logical checkpoint.
generally creating two identical checkpoints is pointles s. we assume that a peer does not change state significantly if it performs no network i o operation e.g.
connect accept send a n d recv .f o l l o w i n gt h i sa s s u m p t i o n t h e peer should be checkpointed only after a network i o operati on is performed.
using this strategy an example of the resulti ng checkpoint space is shown in figure .
states s1 s4 a n d s5come from transitions without network i o operations so physical checkpoints are not created at c1 c4 a n d c5.i f the sut needs the peer at c5 w em u s ts t a r tf r o mp h y s i c a l checkpoint c0and replay network i o operations by using the cache contents until it reaches c5.av a r i a n to ft h i ss t r a t e g y is to only checkpoint after operation connect oraccept .
5s2t1 loading checkpoint peer restarts3t2t0 ss ct10 32c1 c3t2c1t0c0 figure two options loading a checkpoint or starting a new peer.
in this case the i o cache must replay i o operations from the beginning of the connection up to point where the peer is synchronized with the sut again.
ac h e c k p o i n t i n gs t r a t e g yt a k e se f f e c ta f t e re a c hs u ts t a t e transition to decide whether the current peer state should be saved.
in addition to that if the i o cache receives a notification from the checkpointing environment about a non deterministic operation it will always saves the state of t he peer.
the i o cache must do this in order to preserve the resul t of the non deterministic operation.
this method requires a way to detect non deterministic peer actions at runtime.
our solution is to build wrapper functions for standard functio ns that may cause non determinism such as time andread see section iv.
when one of these functions is called with a certain argument the wrapper function sends a notification to the i o cache.
receiving the notification the i o cache save s the peer state after the current sut transition is completed .
note that we must wait until the transition is completed in order to create a checkpoint synchronized with the sut state as shown in figure .
when a sut needs a peer in one of the previous states the i o cache may either restore a peer from a checkpoint or start a new peer from the beginning.
figure compares these options .
the sut moves from state s1tos3 p r o d u c i n gah i t h e r t o unseen request message.
ciis the peer state associated with sut state si.l o a d i n gac h e c k p o i n tt a k e st i m ei nc r e a t i n g ap r o c e s sa n dt h ee x e c u t i o no ft r a n s i t i o n t2.r e s t a r t i n gt h e peer takes time in creating a new process and the execution of transitions t0andt2.c h e c k p o i n t i n gs t r a t e g i e ss h o u l dp r o v i d ea way to estimate and compare cost in each choice.
in the curren t implementation the model checker always restores the peer from a checkpoint assuming that loading the program space from a checkpoint is faster.
in this case the initial peer st ate c0 m u s ta l w a y sh a v eap h y s i c a lc h e c k p o i n ts i n c ei tc a nb ea starting point to go to any logical checkpoints.
implementa tion of other checkpointing strategies constitutes future work .
e. restrictions ac h e c k p o i n t i n gt o o lc a n n o tf o r c eap e e rp r o c e s st op r o d u c e output in a specific non deterministic branch.
the i o cache uses the checkpointing tool only to make sure that the sutreceives peer output from a certain branch.
however the pee r output captured by the i o cache may be different in each run.
as a result only part of the sut state space of the sut is checked.
in figure once the peer moves to state s1 t h es u tw i l ln e v e rr e c e i v em e s s a g e b d o r b f d u r i n g the verification although these messages are possible in a r eal run.
the introduction of checkpointing technology intervenes i n the execution of a peer process in the sense that the peer must run in a special environment.
in contrast to the pure cache based approach the behavior of the peer process in th e new environment may differ from the original behavior.
this limitation also implies that one must have a permission to se t up a checkpointing environment on the machine that runs the peer process.
iv .
i mplementation architecture java pathfinder jpf is a model checker for programs written in java.
it is used as the model checker and the run time environment for sut in this work.
the pure i o cache approach without checkpointing functions was developed as an extension of jpf called net iocache for verifying networked applications.
this work introduce s process checkpointing support by applying the tool called dmtcp to suppress non deterministic behaviors of peer processes.
dmtcp runs a group of connected nodes i .
e .
peer processes in a special environment where some standar d functions are wrapped in order to gain information to create system checkpoints.
dmtcp has the dmtcp coordinator process that manages the execution of all nodes and handles external commands.
when the dmtcp coordinator receives acheckpoint command it captures the state of each node in the group including connection information in checkpo int files.
one checkpoint file represents the state of one node so for each checkpoint command the number of checkpoints created is equal to the number of nodes currently running.
the checkpoint files contain sufficient information to resta rt the group of processes at a state where each process is communicating with one another.
in order to make dmtcp work with the i o cache we modify some part of dmtcp and register callback functions to capture the events insid et h e peer process.
a. connection with the model checker dmtcp is a checkpointing tool for a group of connected processes.
users can add a process into the group by starting it with command dmtcp checkpoint .a n o t h e rw a yt oa d da process into the process group is creating a new process usin g thefork family functions.
every child created by a process in the group automatically becomes a member of the group.
dmtcp saves the entire state of the process group including connections among the internal processes when receiving th e checkpoint command.
similarly it restarts all processes i n ag r o u pf r o mag i v e nc h e c k p o i n tw h e nr e c e i v i n gt h er e s t a r t command.
the sut state is controlled by jpf while the peer state is controlled by dmtcp as shown in figure .
since the 6dmtcp model checkercheckpoint restart figure the state of a sut and a group of peers is managed by the model checker and dmtcp respectively but the connection between them is not subject to checkpointing.dmtcp model checkerproxyc a c h e dmtcp wrapper functions nd notificationcommand result fd proxy command channel nd notification channelsutpeerpeer peerfigure the proxy process represents the sut inside the dmtcp environment.
the i o cache has two communication channels connected to dmtcp.
sut is not a process in the group the connection between the sut and peers is not subject to checkpointing.
as a result the connection is closed when the i o cache kills the group of peers before loading a new one from a checkpoint.
when restarting the i o cache must provide a way to restore this connection so that the sut and peer can communicate with each other again.
in our implementation we create a proxy process that represents a sut in the dmtcp environment.
the proxy process runs similar to other peer processes as shown in figure .
when the sut performs an operation that establishe s ac o n n e c t i o n t h ei oc a c h es e n d st h ec o r r e s p o n d i n gc o m mand to the proxy process.
currently the proxy supports five commands create socket connect accept bind andclose .t a b l eis h o w sam a p p i n gb e t w e e nt h en e t w o r k operations called by sut and the proxy commands.
the proxy performs the requested operation and sends the result back t o the i o cache.
some operations may return a file descriptor that represents a network socket.
the i o cache can use the fil e descriptor it receives to communicate with the peer directl y. in order to transfer file descriptors between processes the su t and proxy use a pair of unix domain sockets to communicate with each other.
table i supported java methods and their associated proxy commands.
java method proxy command fd returned?
new socket create socket yes socket.connect connect no socket.close close no new serversocket bind no serversocket.accept accept yes b. dmtcp modification our checkpointing based approach requires a mechanism that notifies the i o cache whenever a peer executes an instruction that causes non deterministic behaviors.
in o rder to implement such a mechanism we need to watch calls to some functions of the peer program.
in the current implementatio n functions time andread are specially treated as they may produce non deterministic results.
function time may be called obtain the current time which varies across executi ons.
this value is often used as a seed to generate a sequence of pseudo random numbers such as function srand .w h e nf u n c tiontime is called the i o cache is notified.
as for function read t h ei oc a c h ew i l lb en o t i fi e di ft h efi l ed e s c r i p t o ra r g u ment is associated with the system random number generator device dev random or dev urandom .t h e s ed e v i c e s are non deterministic data sources supplied by the operati ng system.
dmtcp provides a set of wrapper functions that collects necessary information for checkpointing before calling th er e a l version of the functions.
the wrapped functions include bot h standard c libraries and system calls.
in a similar way we add one wrapper function time a n dm o d i f ya ne x i s t i n g one read .
when either of these functions detects nondeterminism nd it sends a nd notification to the i o cache.
c. cache dmtcp private communication during verification the i o cache and dmtcp must have aw a yt oc o m m u n i c a t ew i t he a c ho t h e r .t h ei oc a c h es e n d s commands to the proxy process inside the dmtcp environment as mentioned in section iv a. in addition to that it must be ready to receive a notification when a peer process performs a non deterministic operation.
we set up two communication channels between the i o cache and dmtcp the proxy command channel and the non determinism notification channel i l l u s t r a t e di nf i g u r e7 .
when verification starts the proxy process connects to the i o cache using a unix domain socket which allows the proxy to transfer file descriptors to the i o cache.
this connection i s called the proxy command channel.
it must be cut off before checkpointing otherwise dmtcp will try to save the state of the process at the other side of the connection i.e.
the mod el checker.
jpf does not run inside the dmtcp environment and should never be dumped into a checkpoint.
the proxy command channel is re established after checkpointing resta rting.
we register the pre post checkpoint callback functions to dmtcp that are responsible for cutting off and repairing thi s connection respectively.
the i o cache recognizes non deterministic operations on the peers by creating a worker thread that waits for nd notifications.
the worker thread binds a tcp server socket to a fixed port number.
every time a peer executes a nondeterministic function the corresponding dmtcp wrapper function asynchronously sends a nd notification packet to the worker thread as shown in figure .
if the i o cache receives a notification during a transition it will create a peer checkpoint at the end of the transition.
note that we must wai t 7group of peers pipei o cacheshell scriptdmtcp coordinatorfigure communication between the model checker and dmtcp during checkpointing and restarting.
until the current transition is completed in order to genera te the checkpoint state space that maps on the sut state space one to one as shown in figure .
when the i o cache dispatches the checkpoint restart command to dmtcp it must be blocked until the peers are ready again.
in the current implementation the proxy process not ifies the i o cache via a named pipe fifo as shown in figure .
the i o cache executes a shell script that dispatches a command to the dmtcp coordinator an interface of the peer processes .
after the operation has been completed dmtcp notifies the i o cache by putting a message in ap i p e .w a i t i n go nt h ep i p e t h es h e l ls c r i p tr e c e i v e s the message and returns the control to the i o cache .
this procedure makes sure that the i o cache only continues running when the peer side is ready.
all processes must run on the same linux machine in order to use the named pipe.
otherwise another synchronization method must be provide d. currently dmtcp supports only linux based operating systems so our implementation adds no extra limitation.
v. e xperiments and discussion this section compares the time and the number of states generated in the model checking process between the pure i o cache approach and the checkpointing approach with several checkpointing strategies.
the experiment was run on an co re mac pro workstation with 24gb of physical memory running ubuntu .
jpf changeset 4f9c3fc91a2f and dmtcp revision .
the time limit for each case was set to one hour.
table ii shows the experimental results2.c o l u m n no cp denotes the i o cache approach with no checkpointing support.
three checkpointing strategies were applied in th e experiment.
always save c r e a t eac h e c k p o i n ti ft h ep e e ri sa l i v e .
after i o c r e a t eac h e c k p o i n ta f t e rat r a n s i t i o ni n v o l v e d an e t w o r k e di oo p e r a t i o n .
after nd c r e a t eac h e c k p o i n ta f t e rat r a n s i t i o nd u r i n g which a nd notification is received.
in the alphabet application a multi threaded client sends numbernto the server and receives the nth letter of the english alphabet as a response for a specified number of times.
the alphabet client randomly sends a number of messages from set ... while the alphabet server randomly sends either small or capital letters.
deterministic versions of the pee rs 2the verification time and the number of states are higher than the results in a previous publication due to a change in jpf to cover m ore thread schedules.were used in the no cp case.
non deterministic versions were used in the other cases.
note that the number of states explored by jpf is the same regardless of determinism of peer output since our approach captures one of the possible responses of the peer.
the model checking process then runs as if the peer produced deterministic output.
the http client simply requests a file from a server via http.
it generates worker threads to request multiple files i n parallel.
thttpd is a small size http server used in th e experiment without modification.
it sends static contents thus deterministic output according to client requests.
jget creates multiple threads that each download a portion of a fil e in parallel from a server.
scpto is an example program in the java secure channel jsch package which copies a local file to a remote host via a secure channel.
both the client and server can produce non deterministic output.
scpto and the server generate a random value in the process of building a secret shared key .
as explained in section iii checkpointing suppor t is essential in this case.
the gui code in the program is removed before the experiment with dropbear a ssh server.
the i o cache with checkpointing has found a fault in scpto that involves a race condition.
scpto creates as e s s i o nt h r e a dt or e c e i v ep a c k e t sf r o mt h es e r v e rw h i l et h e main thread sends packets to the server.
both threads are not synchronized properly so that a race condition happens unde r ac e r t a i nt h r e a ds c h e d u l e .i ft h em a i nt h r e a dm a k e sp r o g r e s s much faster than another thread and reaches the point where a required packet has not been received it throws an exceptio n3.
another version of scpto is bug fixed and further abstracted in order to finish the verification within reasonable time.
an abstract ssh server runs as a peer for this version of scpto.
both versions were verified in the experiment together with other applications.
the performance of the checkpointing approach with the nd strategy is not much different from the pure cache approach no cp since it only creates a checkpoint if necessary.
it also provides support for non deterministic pee rs making it more powerful than the previous version of the i o cache.
the i o strategy is slightly slower than nd because it creates more checkpoints.
however it would be useful when the peer takes a long time in i o operations since it prevents re execution of those operations.
the always strategy excessively creates checkpoints so its performa nce is not practically useful.
its results are presented for the sake of comparison.
vi.
c onclusions and future work software model checkers cannot be applied directly to a program that interacts with external processes.
cache bas ed model checking allows a single process model checker to ver ify such a program against an external process.
this approac h scales well but imposes some requirements on the target system.
in particular previous work required peer process es to 3this bug has been acknowledged by the developer.
8table ii experimental results sut peer conn msg time mm ss states checkpoints always i o nd no cp always i o nd h .3k nd alphabet nd alphabet .5k client server .3k .9k h nd alphabet nd alphabet h server client .5k .8k .1k .2k .4k .1k .8k http client thttpd h .5k h jget n a h .8k scpto1 dropbear .
scpto abstract bug fixed ssh server h .7k t h ei oc a c h ew i t h o u tc h e c k p o i n t i n gd o e sn o ts u p p o r tt h e s e cases.
1ab u gi sf o u n di nt h i sc a s e .
be deterministic.
in this work the class of verifiable progr ams has been expanded to cover non deterministic peers which are controlled by process checkpointing.
our extension cre ates checkpoints of a peer program according to a checkpoint strategy.
the experiment has shown that the overhead caused by the checkpointing tool is acceptable if an appropriate strategy is used.
future work includes development and analysis of checkpointing strategies.
the shell scripts that communicate wi th dmtcp will be replaced with a library in the i o cache to eliminate the platform dependency.
we also have a plan to run each peer process under a model checker.
the model checker could be modified so that it controls low level peer behavior s such as thread scheduling.
furthermore the model checker may store peer states in memory rather than non volatile storage reducing the i o operation overhead.
being able to control thread scheduling we could analyze the peer behavi ors and selectively perform the ones that would potentially rev eal faults in the sut.
we will consider how the model checker engines communicate with each other as well.
acknowledgment this work was supported by kakenhi and .