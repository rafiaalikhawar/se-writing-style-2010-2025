synthesis of component and connector models from cr osscutting structural views shahar maoz school of computer science tel aviv university israeljan oliver ringert bernhard rumpe software engineering rwth aachen university germany abstract we present component and connector c c views which specify structural properties of component and connector models in an expressive and intuitive way.
c c views provide means to abstract away direct hierarchy direct connectivity port names and types and thus can crosscut the traditional boundaries of the implementation oriented hierarchical decomposition of systems and sub systems and reflect the partial knowledge available to different stakeholders involved in a system s design.
asaprimaryapplicationforc cviewsweinvestigatethe synthesis problem given a c c views specification consisting of mandatory alternative and negative views construct a concrete satisfying c c model if one exists.
we show that the problem is np hard and solve it in a bounded scope using a reduction to sat via alloy.
we further extend the basic problem with support for library components specification patterns and architectural styles.
the result of synthesis can be used for further exploration simulation and refinement of the c c model or as the complete final model itself for direct code generation.
a prototype tool and an evaluation over four example systems with multiple specifications show promising results and suggest interesting future research directions towards a comprehensive development environment for the structure of component and connector designs.
categories and subject descriptors d. .
requirements specifications d. .
design tools and techniques general terms design languages keywords component and connector models synthesis1.
introduction componentandconnector c c modelsareusedinmany applicationdomains fromcyber physicalandembeddedsystems to web services to enterprise applications.
the structure of a c c model consists of components at different containment levels their typed input and output ports and the connectors between them.
a system s c c model is typically complex it is not designed by a single engineer and is not completely described in a single document.
moreover some c c models may be bound to reuse library or third party components designed anddocumentedelsewhere.
thus weconsiderasetupwhere many different incomplete relatively small fragments of the model are provided by architects responsible for subsystems for the implementation of specific features use cases or functionality which crosscut the boundaries of components.
such fragments may be developed by separate distributed teams each focusing on only some aspects of the system and its development and having only partial knowledge of the system as a whole.
moreover a team may have several alternative solutions that address the same concern and some knowledge about designs that must not be used.
to move forward in the development process and enable implementation these partial models and the intentions behind them should be integrated and then realized into a single complete design.
however such an integration is a complex and challenging task.
in this paper we present component and connector views which specify structural properties of component and connectormodelsinanexpressiveandintuitiveway.
c cviews provide means to abstract away direct hierarchy direct connectivity port names and types.
specifically c c views may not contain all components and connectors and typically indeed contain only a small subset of the set of all components and connectors of the system related only to a specific use case or set of functions or features .
they may contain abstract connectors between components at different non consecutive containment levels and they may provide incomplete typing information that is components ports may be un typed.
while the standard structural abstraction and specification mechanisms supported by existing languages and tools for c c models rely on the traditional implementation oriented hierarchical decomposition of systems to sub systems we have defined c c views to allow one to specify properties that crosscut the boundaries of sub systems.
most importantly this makes them especially suitable to reflect the partial knowledge available to different stakeholders involved in a system s design.
s. maoz j. o. ringert b. rumpe synthesis of component and connector models from crosscutting structural views.
joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering esec fse eds.
b. meyer l. baresi m. mezini pages acm new york .
synthesis problem given a c c views specification consisting of mandatory alternative and negative views construct a concrete satisfying c c model if one exists.
we show that the synthesis problem for c c views specifications is np hard and solve it in a bounded scope using a reduction to sat via alloy since the problem is nphard the use of alloy sat to solve it is justified .
the generated alloy module is translated to a boolean formula and solved by a sat solver.
if a satisfying assignment is found we translate it back to a complete c c model and present it to the engineer this design is ready for code generation.
all analysis is fully automated and is internally done using alloy s apis and embedded sat solver.
the engineer need not see the generated alloy module.
the input for the synthesis is a c c views specification.
its output is a single c c model that satisfies the specification and is complete to allow implementation.
when more than one solution exists the engineer can explore different alternatives.
when no solution exists within a bounded scope the technique reports that the input specification is unsatisfiable.
as a concrete language for c c models we use montiarc a textual adl developed using monticore with support for direct java code generation including interfaces factories etc.
.
its expressive power is comparable to that of other adls e.g.
mathworks simulink aadl and uml component diagrams.
the c c views are defined as an extension to general c c models.
the concrete syntax used in our implementation is an extension of montiarc.
to further increase the usefulness of c c views synthesis in practice we have extended the basic synthesis problem with support for three advanced features.
first support for integration with pre defined or library components.
second support for several high level specification patterns.
third support for synthesis subject to several architectural styles.
we report on these advanced features in sect.
.
we have implemented c c views synthesis including the more advanced extensions mentioned above and evaluated it by applying it to four example systems.
we report on our implementation and evaluation in sect.
.
the implementation and example specifications reported on are available in supporting materials .
some previous work deal with the analysis and synthesis of component and connector structures mainly in the context of architectures .
other work deal with synthesizing behavior rather than structure .
we discuss these and other related work in sect.
.
sect.
gives a semi formal overview of c c views and synthesis using examples.
sect.
provides formal definitions and sect.
describes our solution.
advanced support for integration of library components specification patterns and several architectural styles is described in sect.
.
the implementation and evaluation are presented in sect.
.
sect.
discusses related work.
sect.
concludes.
.
overview we present an overview of c c views synthesis using an example adopted from an industrial model of a robot arm1 which is typical to a cyber physical or an embedded system.
1we thank ali muhammad remote operation and virtualwe focus here on a single joint of this arm.
the example is discussed semi formally.
formal definitions are given in sect.
.
.
example i fig.
shows the c c views specification s1 consisting of six views.
the c c view rjfunction describes the system architecture from the point of view of the team responsible for its function the rotationaljoint contains a cylinder and asensorthat is connected to an actuator .
as a c c view rjfunction ispartial soitmaynotcontainallthesystem s components.
moreover while the components shown inside the joint must actually be inside the joint they may be nested within some of its subcomponents not shown in this model .
on the other hand the c c view specifies that the three subcomponents cylinder sensor andactuatorare not nested within one another.
finally sensor andactuator must be connected but their connection is not necessarily direct and the port names and types are not given in the view.
the c c views bodysensorin andbodysensorout describe two alternatives for the c c model from the point of view of the team responsible for a component named body and focus on its internal structure.
the first specifies four subcomponents of body not necessarily direct sub components not necessarily all of them and the connections between them again not necessarily all connections not necessarily direct ones .
the second suggests an alternative wheresensoris outside body.
the c c view sensorconnections describes the point of view of the engineer responsible for sensor.
it shows that sensoris connected to cylinder and to a component named jointlimiter .
again the c c view is partial thus in the complete model the connections shown may be indirect and sensormay be connected to additional components.
the c c view rjstructure provides a high level description of the rotationaljoint structure some of the components it contains and the connections between them.
it describes the knowledge of the senior engineer responsible for the joint.
it also shows the name angleand type float of an incoming port of the cylinder for a connection not necessarily direct coming from body.
finally the c c view asdependence shows the actuatorand thesensorinsidebody.
it describes some domain knowledge concerning a requirement for independence betweenactuator andsensor.
thus it is used in the specification see below in a negated form to not allow an architecture where actuator andsensorare both inside the same component in our case body.
the boolean expression for the c c views specification s1isrjfunction bodysensorin bodysensorout sensorconnections asdependence rjstructure .
is thereacompletec cmodelthatsatisfiesthisspecification?
our work provides a fully automated and constructive answer to this question.
specifically given this specification our tool provides a positive answer and outputs the complete c c model shown in fig.
.
for readability we omit some port names types and internal connectors from the diagram.
reality group vtt tampere finland for allowing us to use this model.
figure a c c views specification s1.
note that the specification states that bodysensorin andbodysensorout are alternatives at least one needs to be satisfied and that asdependence is negated so it must not be satisfied by the model.
figure a c c model with ports satisfying the c c view specification s1.
.
example ii consider now the additional c c view olddesign and revised specification s2shown in fig.
.
the view specifies thatactuator is connected to cylinder and that both components are contained inside body although not necessarily directly .
it also shows the name angleand type intof the cylinder s incoming port for a connection not necessarily direct coming from actuator .
is there a complete c c model that satisfies the revised specification s2 consisting of s1after adding olddesign as another conjunct ?
ourtoolidentifiesthat s2isunsatisfiableandinformsthat a complete c c model that satisfies it does not exist.
one reason relates to the containment relation between bodyand cylinder according to the structure c c view the two components are not contained within one another according to theolddesign c c view the latter is contained within figure a c c views specification s2extends specification s1 with the additional view olddesignshown here added as another conjunct.
the former.
another reason is the type conflict floatvs.
intfor thecylinder s incoming port angle.
.
definitions we define the structure of c c models and views as used in this paper we give shortened definitions for complete definitions see the technical report available from .
.
component and connector models a c c model is a structure cncm an bracketle tcmps ports cons types subs ports type an bracketri htwhere cmpsis a set of named components each of which has a set of ports ports cmp portsand a possibly empty set of immediate subcomponents subs cmp cmps portsis a disjoint union of input and output ports ports portsin portsout where each port p portshas a name a type type p types and belongs to exactly one component p ports cmp consis a set of directed connectors each of which connects two ports of the same type which belong to two sibling components or to a parent component and one of its immediate subcomponents and typesis a finite set of type names.some additional well formedness rules apply e.g.
that the subcomponents relation is a strict partial order that every port has at most one incoming connector and that port names are unique within their component.
in addition without loss of generality we consider only c c models with exactly one top component.
.
c c views a c c view is a structure view an bracketle tcmps ports abscons types subs ports type an bracketri htwhere cmpsis a set of named components each of which has a possibly empty set of ports ports cmp ports and a possibly empty set of subcomponents subs cmp cmps portsis a disjoint union of sets of input and output portsports portsin portsout where each port p portshas a possibly unknown name a possibly unknown type type p types and belongs to exactly one component p ports cmp abscons is a set of abstract connectors each of which connectscomponents optionally viaportsofthesame type or an unknown type and typesis a finite set of type names.
note that in a c c view abstract connectors are not required to connect only two sibling components or a parent component and one of its immediate subcomponents.
again the subcomponents relation is a strict partial order but we do not restrict c c views to have exactly one top component.
we are now ready to define the semantics of our c c view and c c model and specifically when does the second satisfy the first.
a c c model satisfies a c c view iff the types components and ports mentioned in the second are contained in the first the first respects the subcomponent relation induced by the second two ports connected by an abstract connector in the second are connected by a chain of connectors in the first respecting direction names and types and all ports of a component in the second belong to the same component in the first with corresponding name type and direction.
more formally definition cncm view .a c c model cncmsatisfies an c c view viewiff view.types cncm.types view.cmps cncm.cmps view.ports cncm.ports cmp1 cmp2 view.cmps cmp1 view.subs cmp2 iffcmp1 cncm.subs cmp2 we use to denote the transitive closure ac view.abscons chain of connectors in cncm c1 ... c nwithac.srccmp c1.srccmp and ac.tgtcmp cn.tgtcmp with matching port names and types if specified and cmp view.cmps view.ports cmp cncm.ports cmp and p view.ports cmp p view.portsin iffp cncm.portsin view.type p cncm.type p similarly for unknown and given port names .
definition viewsemantics .
the semantics of a c cviewconsists of the possibly infinite set of c c models that satisfy it.
formally sem view cncm cncm view .a c c views specification sconsists of a boolean expression over a set ofc c views v. by simple extension a c c modelcncmsatisfies a specification s denoted cncm s iff replacing each view vinswith the value of cncm v makesstrue cncm s s v v. .
problem definition the c c views synthesis problem is defined as follows given a c c views specification s find a c c model cncm s.t.cncm sif such a model exists.
.
c c views synthesis .
is c c views synthesis hard?
we show that the c c views synthesis problem even withoutconnectors isnp hard usingareductionfrom3sat.
we give an overview below.
given a 3sat formula over variables x1 ... x nin clauses c1 ... c mwe construct the following c c views specification.
first for each variable xiwe define two components xtiandxfiand two c c views vtiandvfisuch that in vti xficontains xti and in vfi xticontains xfi.
intuitively vti vfi represents a positive negative valuation forxi.
obviously a given c c model can only satisfy one of them.
second for each clause cjwe create an c c views clausecvjthat includes a disjunction of three c c views vtiorvfifor each variable xiincj ifxiappears positive incjwe usevti if it appears negative we use vfi.
we create a boolean expression for the c c views specification consisting of a conjunction of xti xfifor all i n and c c views clauses cvjfor all j m. it is easy to see that the 3sat formula has an assignment iff the c c views specification has a satisfying c c model.
.
formulating the problem in alloy our solution is based on a reduction to alloy.
the alloy module is analyzed using a sat solver.
if an assignment is found we translate it back to a satisfying c c model.
the formulation of the c c views synthesis problem in alloy consists of four parts a fixed set of signatures and facts describing a meta model for c c models a fixed set of predicates used as a language to specify the semantics of c c views a set of signatures and predicates derived from the specific input c c views and the specification s boolean expression.
list.
shows part of the alloy code describing the metamodel for c c models.
for example note the signatures component andport.
a component has a set of ports a set of sub components and at most one parent.
the fact subcomponentsandparents specifies the value for the field parent and the fact subcomponentsacyclic specifies that thesubcomponentrelationisacyclic.
finally thefact portsofcomponenthaveuniquenames specifies that no two ports of the same component have the same name.
list.2shows partof thealloycodeusedasalanguageto specify the semantics of c c views.
for example the predicatecontains istrueifthechildisinthetransitiveclosureof the parent s sub component relation and the predicate independentset defines the semantics of a set of components where no two components contain each other.
the predicateconnected defines directed connectedness based on the transitive closure of the receiving port relation.
the remain 1abstract sig component 2ports setport 3subcomponents setcomponent 4parent lonecomponent 6factsubcomponentsandparents 7allch par component chinpar.subcomponents iffch.parent par 10factsubcomponentsacyclic 11nocomp component compincomp.
subcomponents 14sigport 15type onetype 16name oneportname 17direction onedirection 18receivingports setport 19owner onecomponent 20sendingport loneport 22factportsofcomponenthaveuniquenames 23allc component alldisj p1 p2 c.ports p1.name !
p2.name listing excerpts from the meta model for c c models in alloy see sect.
.
ing predicates in list.
are used to express the semantics of abstract connectors and untyped ports.
for the third part we collect from the input c c views thecomponentnames portnames andtypesintosignatures extending component portname andtype.
we then derive a set of predicates each of which expresses the semantics of one of the views using the language defined earlier.
as an example list.
shows the predicates for the c c views rjfunction andrjstructure taken from specification s1 .
finally we construct a predicate specrepresenting the specification sbooleanexpressionoverthec cviews predicates.
.
synthesis we run the module defined above with a command that tries to satisfy the specpredicate.
note that alloy analysis must be done within a user defined given scope which specifies an upper bound for the number of instances per signature.
in our case the upper bound for the number of components is derived from the specification.
the upper bound for the total number of ports and the maximal number of ports per component however cannot be derived from the specification.
we thus let the user choose the scope for ports we can only derive a lower bound for the number of necessary ports .
if an alloy instance is found we translate it back to the problem domain that is to a complete c c model.
the translation back is straightforward and is linear in the size of the solution.
however if an alloy instance is not found in the general case we do not know whether the specification could be satisfiable in a larger scope that is using more ports.
as stated before our solution is indeed sound but incomplete althoughitiscompletewithinthegivenscopes .
.
adv anced features .
library components most c c models reuse library components pre defined or existing components adopted from other systems.
thus 1predcontains parent component child component 3childinparent.
subcomponents 5predindependentset 6alldisj c1 c2 components noc1.subcomponents or notcontains 10predconnected sender component receiver component 12somep receiver.ports pinsender.ports.
receivingports 15predconnectedwithportnames sender component sendname portname receiver component recvname portname 18somesp sender.ports somerp receiver.ports rp.name recvname and rpinsp.
receivingports and sp.name sendname and spinrp.
receivingports 25predconnectedwithreceiverportname sender component receiver component recvname portname 28somesendname sender.ports.name connectedwithportnames sender sendname receiver recvname 32preduntypedport cmp component dir direction portname portname 34someport cmp.ports port.direction dirand port.name portname listing excerpts from the language for c c views semantics see sect.
.
it is crucial that our technique would allow the engineer to import such components and apply an integrated synthesis solution.
specifically c c views synthesis supports the integration of library components or similar components at two levels.
first the engineer can extend the specification with a list of imported library component definitions.
a component definition is complete it specifies the complete interface port names and types of the component.
if a component definition for component cmpis imported we check that none of the c c views mentioning cmpexplicitly specifies a subcomponent for cmp and we add its interface and the requirement that it is complete as an additional constraint to the generated alloy module.
this ensures that a synthesized design that uses cmp if any would be consistent with its interface and use it as is.
as an example consider the servovalve component in specification s1from fig.
to be an imported library component.
in the library the complete interface of servovalve is given.
importing it to the specification s1ensures its interface is used as is in the synthesized design and rules out solutions that put other components that are mentioned in the c c views as its subcomponents.
for example a solution where servovalve contains sensorwill not be possible.
the additional alloy predicates we use to support library components are shown in list.
and list.
.
we instantiate these predicates with every library component in the specification as shown in list.
for the servovalve .
note that the synthesis considers an imported component as a black box it uses its interface and needs no knowledge of its subcomponents.
this is meant to support encapsula 1predrjfunction 2onerotationaljoint 3and one actuator 4and one sensor 5and one cylinder 6andindependentset 7andcontains rotationaljoint sensor actuator cylinder 9andconnected 11predrjstructure 12onerotationaljoint 13and one body 14and one servovalve 15and one cylinder 16andindependentset 17andcontains rotationaljoint servovalve body cylinder 19andportofcomponent cylinder in my float angle 21andconnected 22andconnected 23andconnectedwithreceiverportname body cylinder angle 25andconnected listing predicates for two c c views rjfunction and rjstructure from specification s1 see sect.
.
1predlibrarycomponent 2nocmp.subcomponents listing predicate to specify that a library component must have no subcomponents see sect.
.
tion and modularity as long as the interface is kept fixed the implementation of imported library components can be replaced without affecting the synthesized design.
second thedesignercanstrengthenac cviewbydeclaring some of the components mentioned in it as interface complete technically using a stereotype .
this is useful when the designer knows the complete interface of a component she is using although this component is not a black box librarycomponent.
forexample consideraddingthestereotype interface complete to the sensorin thesensorconnectionsmodel .
this would mean that in the synthesized design sensormust have exactly the set of ports and corresponding types shown in this model.
as sensoris not imported as a library component it is still possible that in the synthesized solution it will include subcomponents from the set of components already mentioned in the models.
the additional alloy predicate we use to support interface completecomponentsisshowninlist.
.
weinstantiatethis predicate with every component that is specified as interface complete in a model in the specification.
.
specification patterns the use of a boolean expression in c c views specifications makes them very expressive.
however for the engineer who constructs the specification using only low level basic boolean connectives may be inconvenient and error prone.
thus we look for higher level specification patterns which can be used to express the required semantics more intuitively and can be reused across different specifications.
basedonourexperiencewithcreatingspecifications some examples of simple patterns are given a set of c c views specifying that the synthesized design must satisfy at least one of the models in the set given a set of views specifying that the synthesized design must satisfy1predinterfacecomplete cmp component portnames setportname 3cmp.ports.name portnames listing predicate to specify that a component s interface is complete technically by stating that the set of its port names as appearing in the model is exactly its complete set of port names see sect.
.
1factlibrarycomponents 2librarycomponent 3someservovalve implies 4portof 5andportof 6andinterfacecomplete servovalve portin portout listing a fact stating that servovalve is a library component see sect.
.
.
if servovalve is used in the design its interface is completely specified.
exactly one of the views in the set given two views if the design satisfies the first it should also satisfy the second and a given component should not be present in the synthesized design.
note that the last three patterns depend on the use of negation in the language.
as an example recall specification s1 .
assume that the engineer responsible for sensorknows that if it is located outside body then it must use an inner amplifier amplifier .
toexpressthisknowledge thearchitectcancreate the c c view sensorhasamp shown in fig.
left and add the implication imp bodysensorout sensorhasamp to the specification s boolean expression as another conjunct .
to make sure the amplifier is not used when it is not necessary the engineer can create the view ampshown in fig.
right and add the implication imp bodysensorin amp since the model ampconsists of the single component amplifier the expression ampused here is an instance of the patternnocompmentioned above .
as another example the choice between bodysensorin andbodysensorout ins1can be strengthened by the engineer toxalt bodysensorin bodysensorout without loosing or adding possible implementations that is as a form of refactoring.
the semantics of the two views entails that no design can satisfy both and their use in the specification s1 entails that at least one of them must be satisfied.
specificationpatternsdonotaddexpressivepower.
rather they are only meant to improve the readability and usability of c c views specifications.
indeed as part of our prototypeimplementation wehavedevelopedgraphicalinterfaces to add and edit the specification s boolean expression including support for several patterns.
our ideas on specification patterns for architecture structures are inspired by previous works on patterns of temporal specifications e.g.
.
figure the additional c c views sensorhasamp andamp to be added to the specification s1with the implications imp bodysensorout sensorhasamp and imp bodysensorin amp see sect.
.
.1facthierarchicalarchitecture 2noc component 3cin talker.talksto .c 5one sig talker 6talksto component component allc1 c2 component 8c2intalksto.c1 iffendtoendconnection 10predendtoendconnection senderc onecomponent receiverc onecomponent 12somesenderp senderc.ports somereceiverp receiverc.ports nosenderp.sendingport and no forward noreceiverp.receivingports and no forward receiverp insenderp.
receivingports listing excerpts from the alloy code for the hierarchical style see sect.
.
.
c c views synthesis with styles architectural styles systematize successful architectural design practices in terms of constraints on architectural elements and their composition into systems .
some examples of well known architectural styles that are relevant to c c models include the pipe and filter style the clientserver style and the layered style an overview can be found in chap.
of .
we have extended c c views synthesis with support for three architectural styles.
as applicable style specific constraints are added to the synthesis input so that the synthesized design if any is found obeys the rules of the style.
we give three examples below.
first a hierarchical style whose essence is to forbid the c c models from having directed cycles of connected components.
this style is important because hierarchical architectures are suitable for behavioral synthesis while the problem of synthesizing a finite state distributed reactive system over a given architecture is in general undecidable it is decidable for the class of hierarchical architectures .
to enforce the hierarchical style of the synthesized model we add to the generated alloy module a fact that requires that no directed cycles exist see list.
.
more technically this is implemented using the helper relation talksto of the signature talker.
a pair of components c1 c2is in this relation iff there exists a connection that starts at c1 not only forwarded and ends at c2.
if a hierarchical solution exists it will be found.
if no solution exists it might be possible to find a solution that is not hierarchical.
second a client server style whose essence is to identify one of the components as a single server and to forbid any direct communication between clients.
also the server and the clients are assumed all to be independent in terms of containment a client is not contained within the server or another client etc.
to integrate this style with our synthesis solution we add the identities of the server and the client components as defined by the engineer as additional input to the specification.
we replace the constraint of a single top component see sect.
.
with a constraint that specifies that the server and the clients are the top components.
we then use a fact to enforce additional style constraints on the synthesized design see list.
.
more technically the fact uses a parametrized predicate that defines when two components are directly connected and two generated functions myserver andmyclients returning the server component and the client components resp.
again if a design that satisfies the specification together with the additional restric tionsexists itisfound.
ifnot itmeansthatthesemanticsof the specification cannot be satisfied within the client server style e.g.
without direct client to client connectors or that it cannot be satisfied at all .
third a layered style which forces a partition of the components into a sequence of layers and allows direct connectors only within layers and between consecutive layers.
to integrate this style with our synthesis solution we add the partition of the components into layers as defined by the engineer as additional input to the specification.
as in the client server style we replace the constraint of a single top component with a constraint that specifies that the layers are the top components.
we then use several parametrized predicates to enforce the style s constraints on the synthesized design.
if a design that satisfies the specification together with the additional restrictions induced by the partition of the layers exists it is found.
if not it means that the partitionintolayers conflicts with the semantics of the specification orthatthespecification evenwithoutthestyleconstraints is not satisfiable at least within the given scope .
it is important to note that each of the c c views in the specification is independent of and does not have to be compliant by itself with the constraints induced by the architectural style.
for example even though a layered architecture is enforced abstract connectors in a view may connect components from nonconsecutive layers.
the synthesis is responsible to implement these abstract connectors through chains of concrete connectors that obey the layered architecture.
as another example what looks like a communication cycle in a given view and thus apparently violates a hierarchical style may end up implemented in the synthesized design without creating a cycle.
for example recall specification s1of fig.
where view structure seems to contain a cycle between bodyandcylinder .
in the synthesized design shown in fig.
we see that the implementation contains no concrete end to end cycle.
thus the c c views and the architectural style are specified independently.
the synthesis is responsible for finding a design that satisfies both if one exists.
finally the use of architectural styles adds expressive power to c c views specifications and makes it applicable to a wide range of systems.
in our prototype plug in for c c views synthesis we have added graphical user interfaces to select a style and edit its properties including support for the three styles described above.
1factclientserverarchitecture 2allclient myclients immediatelyconnectednoorder and no c myclients client immediatelyconnectednoorder 7predimmediatelyconnectednoorder c1 component c2 component 9somep c1.ports pinc2.ports.receivingports or pinc2.ports.sendingport listing excerpts from the alloy code for the client server style.
myserver andmyclients are generated alloy functions returning the server component and the client components resp.
see sect.
.
.
implementation and ev aluation theplug inimplementationandallspecificationsreported on below are available in supporting materials together with screen captures and relevant documentation.
all specifications can be inspected and all experiments can be reproduced.
we encourage the interested reader to try it out.
.
implementation we implemented c c views synthesis in an eclipse plugin prototype.
the input consists of a c c views specification.
the specification selection of c c views and components definition of the boolean formula scope and optional parameters about styles is edited using a dedicated graphical ui.
the concrete syntax used is adapted from montiarc .
at the back end the plug in implements the translation to alloy using monticore apis and freemarker .
the sat solver we use is minisat .
when a design is synthesized it is presented as a montiarc document to the engineer who can inspect it andfurther use it for code generation to java or to mathworks simulink .
we tested the implementation over c c views specifications for four systems from different sources and of different domains.
we experimented with several different specifications for each system in order to test and evaluate the use of different features e.g.
library components specification patterns architectural styles .
for validation we have also implemented a polynomial algorithm that checks whether a given c c model satisfies a given c c view.
as part of our experiments we ran this algorithm on the results of all successful synthesized designs and their source views.
this check is available with the prototype plug in too.
.
evaluation we evaluated c c views synthesis on four systems taken from different sources.
avionics system.
we evaluated c c views synthesis on an aadl architecture of an avionics system taken from specifically avionics system.aadl of the osate aadl project .
the avionics system architecture is a high level model of several avionics system subsystems.
based on various use cases related to interactions between system s components we created c c views components each.
for example one view gives an overview of the complete data flow in the system declared using abstract connectors.
this view does not provide additional information such as port names or types.
another view provides more details about the communication between the pilot display and it spage content manager showing incoming and outgoing ports with their names and connectors.
we defined satisfiable and unsatisfiable c c views specifications using to views some extended with styles.
pump station.
we further experimented with a pump station design taken from an example system provided with the autofocus tool developed at tu munich .
the physical pump station system consists of two water tanks connected by a pipeline system with a valve and a pump.
the water level in the first water tank can rise this is controlled by the environment .
when the water level of the first tank rises to a critical level the water has to be pumped to the the second water tank.
the second water tank has a drain.
2the supporting materials have been successfully evaluated by the esec fse artifact evaluation committee and found to meet expectations.based on several design decisions and relations we wanted to highlight and document we created c c views each with components.
for example one view gives an overview of the basic structure of the system and omits details about interfaces and connectors.
another view documents partoftheconnectionsbetweentheactuatorsandtheirenvironment hiding hierarchies and omitting elements not connected to the actuators.
an additional c c view shows an undesired design where the simulation component is placed inside the pumping system.
wedefined8satisfiableandunsatisfiablec cviewsspecifications.
two specifications specify the optional existence ofanemergencysystemanditsimplications usingthe and patterns.
anotherspecificationprohibitsanemergency system.
other specifications combine models of the function of the pump station with ones that specify the separation of the pumping system from the simulation part.
robotic arm.
we evaluated c c views synthesis on a robotic arm architecture specifically a rotational joint taken from an industrial system by vtt tampere finland the system used as running example in this paper .
the main components of the rotational joint s model are a cylinder a servo valve a sensor a joint limiter and an actuator.
the rotational joint is a subsystem of a robotic arm containing rotational identical copies and translational joints.
based on several requirements and partial knowledge or particular features we created c c views each with components.
some views highlight the components necessary for the function of the joint while others document design alternatives on the placement of sensor and actuator components.
some of the views give an overview over related components with only few details of their interfaces or connectedness.
other views document complete interfaces of relevant components and some of their connections.
moreover we created c c views specifications each combining c c views to express design alternatives pattern undesired designs and implications of design decisions pattern .
lunar lander.
we evaluated c c views synthesis on the lunar lander model which is used by taylor et al.
as a running example in their book on software architecture and presented in a related work by bagheri and sullivan .
the lunar lander is space ship with various sensors a controller and actuators.
the objective of the lunar lander is to land safely on the surface of the moon.
based on the natural language description of the lunar lander consisting of three components presented in pp.
we have created c c views each with components.
each c c view covers parts of the natural language description.
since this description is formulated positively the c c views specification is a conjunction of the views.
based on a shorter natural language description of the same lunar lander with components sensors one controller and actuators from we have created views and again the c c views specification is a conjunction of these views.
both original examples from and contained neither port names nor types and no hierarchy.
we introducedportnamesinthec cviews of the3component lunar lander example.
.
observations and lessons learned performance.
for some specifications synthesis took only a few seconds while for others it took up to a minute tocomplete on a regular laptop computer .
our experience shows that relatively minor changes in a specification such as ones that add no c c views or components but only further constrain the specification with library components or statements of interface completeness and even ones that do not affect the semantics such as different ordering of the models in the boolean formula sometimes have a significant effect on performance.
indeed it is known that alloy s performance and sat solvers performance in general are sensitive to the order of variables in their input.
since c c views synthesis is np hard one cannot expect it to be instantaneous.
thus we consider the resulting times to be reasonable.
as we have not made special efforts to optimize the implementation we believe there is much room for improvement in this regard.
also interestingly deciding that a specification is not satisfiable was typically but not always much faster than deciding that it is satisfiable and providing the synthesized design.
language expressiveness.
we found that the use of a boolean formula over c c views together with the patterns in particular the use of alternatives negations and implications is both expressive and easy to read and write.
we thus believe that c c views by example characteristics is attractive to engineers our belief is supported also by the analogous use of scenarios in behavioral specifications .
on the other hand the use of c c views to specify some properties was not always natural and intuitive.
instead sometimes we wished to have a more fine grained flexible and powerful language that allows one to write symbolic succinct specifications e.g.
using quantification .
we leave this topic for future work.
multiple solutions.
a c c views specification may have more than one satisfying design.
for example consider the specification s1of fig.
.
fig.
shows a possible solution.
an alternative satisfying design may be an architecture which is identical to the first except that servovalve contains sensor.
if this is not an acceptable design the architect can disallow it e.g.
by adding it or a smaller c c views consisting of the servovalve and the sensor in a negated form to the specification and run synthesis again.
most of our specifications had many satisfying solutions.
so we found that it may be useful to have a better way of choosing between solutions e.g.
by optimizing some cost functions hierarchy depth ports number connector chains length .
this however cannot be efficiently done using our current technique.
we leave this issue for future work.
handling unsatisfiable specifications.
a c c views specification may be unsatisfiable.
in addition to identifying unsatisfiability one may be interested in presenting the root cause of conflicts to the engineer i.e.
to identify a minimal subset of the specification boolean formula that is unsatisfiable.
note that unsatisfiability may have more than one cause for example as explained earlier in sect.
.
the specification s2is unsatisfiable both because of a conflict in component s containment and a port type mismatch.
heuristics may be used to detect some simple patterns of unsatisfiability in linear or polynomial time.
a complete but inefficient solution to find a minimal subset would require an exponential number of synthesis runs.
we believe that providing tools to handling unsatisfiable specifications efficiently is an important direction for future work.
one may be able to build these on top of existing technologies for unsat core as supported by some sat solvers.
however in order to be effective the identified core must be lifted and presented to the engineer back using the abstractions defined by the c c views.
.
related work we discuss related work in the areas of component and connector modeling and analysis and in the area of behavioralspecifications.
theuniquefeaturesofourworkonc c views and synthesis are its support for hierarchy its support for abstraction of direct hierarchy direct connectivity names and types its focus on structure and its goal to automatically construct a satisfying c c model from a given set of constraints which are expressed as views and crosscut the implementation oriented decomposition of systems to sub systems.
some previous works deal with the analysis or synthesis of component and connector structures mainly in the context of architectures .
we discuss these works and compare them to our work below.
bagheri and sullivan present an approach to synthesize style specific architecture descriptions from a style independent application description.
our work includes support for architecture styles too see sect.
.
.
unlike our work the input of their alloy based synthesis is a single and complete application description and not a specification over multiple incomplete and crosscutting models like c c views.
in the application description is mapped to multiple possible architecture descriptions in a specific style.
it is unclear whether the mapping synthesis can fail besides from choosing too small an alloy scope .
finally unlike our support for hierarchical structures the application description and architecture styles presented in do not support hierarchy.
bagheri and sullivan use the lunar lander example as a case study.
although this example is small and flat and thus does not take advantage of the unique features of our approach we use it in our evaluation too for the purpose of comparison see sect.
.
kim and garlan present formal analysis of c c models within architectural styles using alloy.
unlike our work however their work does not support hierarchical decomposition of components their configurations are flat .
one analysis supported is checking the constructability of specific architectural configurations sect.
.
the input is a partial architecture configuration and the output is an instance of an architecture in the given style that contains the input configuration.
the input in consists of a single configuration and not a set of separated views as supported in our work.
moreover does not support abstraction of hierarchy or connectivity as is available in our work.
issarny et al.
present a development environment for the composition of middleware architectures.
the input for composition are two c c models.
the output of the directed composition operator is a single c c model where possibly multiple copies of components of the second model are connected with components of the first.
a valid composition preserves communication order of the input models and ctl properties checked against promela implementations of components both specified by the user.
the work may be viewed as similar to ours as it translates a c c model composition problem into a model checking problem.
it differs significantly since the input in consists of concrete models without common elements with out hierarchies they are flat or abstraction mechanisms as supported by c c views.
moreover their composition is binary and directed while ours supports boolean specifications over c c views including negation alternatives etc.
bouck e et al.
present composition operators for c c modelstoavoidtherepetitionofelementsinintegratedmodels.
the integration of sets of architecture models is based on a user specified unification relation marking identical elements across input models and a submodel relation e.g.
a component is detailed in another model .
this model composition is thus an imperative composition of concrete c c models rather than a declarative one as in our approach.
we believe that our work may benefit as well from a more complex and maybe user specified unification relation across c c views as suggested in .
giese and vilbig discuss separation of non orthogonal concerns in software architecture and design.
the work deals with composition of structure as well as of behavior from architectural views.
architectural views are defined as directed graphs representing components and connectors extended with behavior contracts.
according to the structural part of their architectural view synthesis can be handled by superposition of these directed graphs.
in contrast the synthesis problem for our c c views specifications is more complex because of its rich abstraction mechanisms of direct hierarchy and connectivity and its support for the specification of negative or alternative designs which prohibit simple superposition.
aadl includes under specification mechanisms similar to the ones available in our work.
for example aadl supports specifications with incomplete information of port types and with abstract flows which show the source and sink of flows but not their complete path through the system.
in feiler et al.
explain that the motivation behind aadl s support for partial specifications is to allow some analysis e.g.
computing some metrics checking syntactic correctness already during early design before all implementation details are known.
however a synthesis of a complete architecture from a set of partial specifications as is done in our work is not discussed.
acme allows one to specify first order predicates on the structure of architectures dealing e.g.
with connectedness between components.
in acmestudio these predicates are automatically evaluated against the architecture.
the predicates are written as logical formulas not as abstract models such as c c views.
moreover we have not seen any work that suggests to use these predicates as input for synthesis of a satisfying architecture.
aspectualacme extends acme with the modular representation of architectural aspects and their multiple composition forms.
the extension allows special aspectual components to be connected to other components via special aspectual connectors characterized by aspectual glues of before after and around types with a semantics similar to that of advice composition in aspectj .
this work and ours are remotely related specifically in the idea of crossing the hierarchical boundaries of components and subcomponents.
however the works are also very different as aspectualacme deals with the extension of a given base architecture and its fixed structure with crosscutting concerns while our work focuses on using declarative views as specification for the structure of the model and on the use of these views for its synthesis.previous work in our group by gronniger et al.
described the use of views in the context of product lines with a focus on the automotive domain using sysml internal block diagrams.
like aadl these provide underspecification mechanisms e.g.
to specify abstract connectors.
synthesis from views was not discussed in these works.
finally from a broader higher level perspective variants of synthesis from partial views have been extensively studied in the area of behavioral specifications see e.g.
the works of harel and segall.
maoz and sa ar uchitel et al.
and whittle and schumann on synthesizing behavior models from scenarios .
most importantly however these works assume the structure of the systems to be given only the behavior is synthesized!
our work on c c views deals with the synthesis of structures not behaviors and may be viewed as complementing some of these works.
as future work one may develop integrated structural and behavioral synthesis techniques.
.
conclusion wepresentedcomponentandconnectorviews whichspecify structural properties of component and connector models in an expressive and intuitive way.
c c views provide means to abstract away direct hierarchy direct connectivity port names and types and thus can crosscut the traditional boundaries of the implementation oriented hierarchical decomposition of systems and sub systems and reflect the partial knowledge available to different stakeholders involved in a system s design.
as a primary application for c c views we investigated the synthesis problem given a c c views specification consisting of mandatory alternative and negative views construct a concrete satisfying c c model if one exists.
we showed that the problem is np hard and solved it in a bounded scope using a reduction to sat via alloy.
we further extended the basic problem with support for library components specification patterns and architectural styles.
the result of synthesis can be used for further exploration simulation and refinement of the c c model or as the complete final model itself for direct code generation.
several future research directions arise from our evaluation in sect.
including strengthening the expressiveness of c c views with parametrized component instantiation or quantification and better handling the case where the specification is unsatisfiable by providing directions to the root cause of unsatisfiablity as is done in the behavioral case when a set of scenarios is unrealizable see .
we believe that all the above can be defined and implemented on top of the c c views language and the synthesis solution presented in our work.
our ultimate future work goal is to integrate structural and behavioral synthesis into a single comprehensive solution for c c models specification and implementation.
.