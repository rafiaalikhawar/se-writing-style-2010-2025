detecting spurious counterexamples efficiently in abstract model checking cong tian and zhenhua duan ictt and isn laboratory xidian university xi an p.r.
china fctian zhhduan g mail.xidian.edu.cn abstract abstraction is one of the most important strategies for dealing with the state space explosion problem in model checking.
with an abstract model the state space is largely reduced however a counterexample found in such a model that does not satisfy the desired property may not exist in the concrete model.
therefore how to check whether a reported counterexample is spurious is a key problem in the abstraction refinement loop.
particularly there are often thousands of millions of states in systems of industrial scale how to check spurious counterexamples in these systems practically is a significant problem.
in this paper by re analyzing spurious counterexamples a new formal definition of spurious path is given.
based on it efficient algorithms for detecting spurious counterexamples are presented.
by the new algorithms when dealing with infinite counterexamples the finite prefix to be analyzed will be polynomially shorter than the one dealt by the existing algorithm.
moreover in practical terms the new algorithms can naturally be parallelized that makes multi core processors contributes more in spurious counterexample checking.
in addition by the new algorithms the state resulting in a spurious path false state that is hidden shallower will be reported earlier.
hence as long as a false state is detected lots of iterations for detecting all the false states will be avoided.
experimental results show that the new algorithms perform well along with the growth of system scale.
index terms model checking formal verification abstraction refinement parallel algorithm.
i. i ntroduction model checking is an important approach to improve the reliability of hardware software multi agent systems communication protocols embedded systems and so forth.
the term model checking was coined by clarke and emerson as well as sifakis and queille independently.
the earlier model checking algorithms explicitly enumerated the reachable states of the system in order to check the correctness of the system.
this restricted the capacity of model checkers to systems with a few million states.
since the number of states can grow exponentially with the number of variables early implementations were only able to handle small designs and did not scale to examples with industrial complexity.
to combat this various methods such as abstraction partial order reduction robdd and bounded model checking etc.
techniques are applied to model checking to reduce the state space for efficient verification.
thanks to these efforts model checking has been one of the most successful verification approaches which is widely adopted in industrial community.
among the techniques for reducing the state space abstraction is certainly one of the most important ones whichhas been widely used in software model checking.
in several software model checkers slam and blast for instance counter example guided abstraction refinement cegar based abstract model checking has been well implemented.
abstraction technique preserves all the behaviors of a concrete system but may introduce behaviors that are not present originally.
thus if a property i.e.
a temporal logic formula is satisfied in the abstract model it will certainly be satisfied in the concrete model.
however if a property is unsatisfiable in the abstract model it may still be satisfied in the concrete model and none of the behaviors that violate the property in the abstract model can be reproduced in the concrete model.
in this case the counterexample is said to be spurious.
thus when a spurious counterexample is found the abstraction should be refined in order to eliminate the spurious behaviors.
this process is repeated called abstraction refinement loop until either a real counterexample is found or the abstract model satisfies the property.
in the abstraction refinement loop how to check whether a reported counterexample is spurious is a key problem.
in a lgorithm split path is presented for checking whether a counterexample is spurious and a sat solver is employed to implement it .
in s plit path whether a counterexample is spurious can be checked by detecting failure states in the counterexample.
if a failure state is found the counterexample is spurious otherwise the counterexample is a real one.
however whether a state say si is a failure state relies on the whole prefix of the counterexample h s0 s1 sii.
therefore to check a counterexample h s0 s1 sni each state in should be checked sequentially.
moreover to check a counterexample with infinite length a polynomial number of unwinding of the loop in the infinite path is required .
for systems with a small state space the polynomial number of unwinding of the loop is tolerable.
however for systems with large state space i.e.
a common software system the polynomial growth of the number of the states to be checked might lead to the exhaustion of memory.
therefore effective algorithms for checking spurious counterexamples are significant in making abstract model checking to be practical.
in this paper based on the definition of false states spurious paths are re analyzed and a new approach for checking spurious counterexamples is proposed.
with this approach whether a counterexample is spurious depends on the existence offalse states in the counterexample.
there are several merits978 .
c ieee icse san francisco ca usa202 of the new approach.
first instead of the prefix to check whether a state siisfalse is only up to si s previous and successor states in the counterexample.
based on this for an infinite counterexample the polynomial number of unwinding of the loop can be avoided.
second the algorithm can easily be improved by detecting the heaviest false state such that a number of model checking iterations can be saved in the whole abstract refinement loop.
thirdly the algorithm can naturally be parallelled.
this will largely improve the efficiency for checking spurious counterexamples with thousands of millions of states in big examples with industrial scale.
finally the algorithms analyze each state in the counterexample gradually by considering its previous and successor states.
thus some false states that are hidden shallower will be detected easier.
this will be useful in practise since in the whole abstract refinement loop anytime one false state is enough for the refinement of the counterexample.
we have developed a counterexample checker containing both the new proposed algorithms and the existing one.
the tool is implemented on randomly generated models in different scales.
experimental results show that the new algorithms perform well along with the growth of system scale.
the rest part of the paper is organized as follows.
the next section briefly presents the preliminaries in abstractionrefinement.
in section why spurious counterexamples occur is analyzed intuitively and a lgorithm split path is explained briefly.
in section a new formal definition of spurious counterexample is given with respect to the definition offalse states .
further in section algorithms for checking whether a counterexample in the abstract model is spurious are presented.
experimental results are given in section .
finally conclusions are drawn in section .
ii.
r elated work we focus on the counter example guided abstraction refinement cegar framework which was first proposed by kurshan .
based on the basic cegar some variations were given in the past years.
most of them use a model checker and try to get rid of spurious counterexamples to achieve a concrete counterexample or a proof of the desired property.
recently cegar was also improved for the purpose of abstract model checking of shared variable concurrent programs .
the closest works to ours are those where the abstract models are obtained by making some of the variables invisible.
to the best of our knowledge this abstraction method was first proposed by clarke etc.
.
with their approach abstraction is performed by selecting a set of variables or latches in circuits to be invisible.
in each iteration a standard ordered binary decision diagram obdd based symbolic model checker is used to check whether or not the abstract model satisfies the desired property which is described by a formula in temporal logic.
if a counterexample is reported by the model checker it is simulated with the concrete system by a sat solver.
it tells us that the model is satisfiable if the counterexample is a real one otherwise the counterexampleis a spurious one and a failure state is found which is the last state in the longest prefix of the counterexample that is still satisfiable.
subsequently the failure state is used to refine the abstraction by making some invisible variables visible.
in the method given by clarke etc.
a lgorithm split path is used to check whether a counterexample is spurious and a sat solver is employed to implement it .
s plit path is carried out by detecting failure states in the counterexample.
if a failure state is found the counterexample is spurious otherwise the counterexample is a real one.
with this method to check a counterexample with infinite length a polynomial number of unwinding of the loop in the infinite path is required .
iii.
a bstraction and refinement loop as usual a kripke structure is used to model a system.
letv fv1 vngranging over a finite domain d f?g be the set of variables involved in a system.
for any vi2v i n a set of the valuations of viis defined by vi fvi djd2d f?gg where vi ?means viis undefined.
further the set of all the possible states of the system is defined by v1 vnfor each vi2v.
let apbe the set of propositions.
a kripke structure over apis a tuple k s i r l where s is the set of states i.e.
a state insis a valuation of variables in v i sis the set of initial states r s sis the transition relation l s!2ap is the labeling function.
for convenience s v is employed to denote the value of vat state s. a path in a kripke structure is a sequence of states hs1 s2 i where s12s0and si si 2rfor any i .
for convenience we use r s to denote the set of direct successors of a state s2s r s0 the set of direct successors of all states in s0.
more generally ri s means the set of states reachable from safter itimes of transitions and ri s0 the set of states reachable from all states in s0after itimes of transitions.
there are several techniques for obtaining the abstract models .
we follow the counterexample guided abstraction and refinement method proposed by clarke et al.
where abstraction is performed by selecting a set of variables which are insensitive to the desired property to be invisible .
following the idea given in we separate vinto two parts vvandvisuch that v vv vi.vvstands for the set of visible variables while videnotes the set of invisible variables.
invisible variables are those we do not care about and will be ignored when building the abstract model.
in an original model k s s0 r l all variables are visible vv v vi .
to obtain an abstract model k s s0 r l some variables e.g.
vx v are selected to be invisible vv vnvx vi vx .
thus the set of all possible states in the abstract model will be v1 vk where k jvvj and for each i k vi2vv.
for a state s2sand a state s2 s sis called the mapping of sin the abstract model by selecting vvas the set of visible variables iff s v s v for all v2vv.
formally s h s vv is used to denote that sis the mapping of sin the abstract model by selecting vvas the set of visible variables.203inversely sis called the origin of s and the set of origins of sis denoted by h s vv .
therefore given an original model k s s0 r l and a selected set of visible variables vv an abstract model k s s0 r l can be obtained by algorithm a bstract as shown below.
algorithm abstract k vv input an original model k s s0 r l and a set of selected visible variables vv output an abstract model k s s0 r l s f s2 jthere exists s2ssuch that h s vv sg s0 f s2 sjthere exists s2s0such that h s vv sg r f s1 s2 j s1 s22 s and there exist s1 s22 ssuch that h s1 vv s1 h s2 vv s2and s1 s2 rg l s s s2s h s vv sl s return k s s0 r l example as illustrated in fig.
the concrete model is a kripke structure with four states.
initially the system s1 s2 s3 s4 v1 v2 0v1 v2 1v1 v2 0v1 v2 v3 v4 0v3 v4 1v3 v4 0v3 v4 1v v1 v2 v3 v4 vv v1 v2 vi v3 v4 s1 s2v1 v2 1v1 v2 originalabstract q p r q p p q p q r fig.
.
abstraction function has four variables v1 v2 v3andv4.
suppose that v3andv4 are selected to be invisible.
by a lgorithm abstract an abstract model with two states is obtained.
in the abstract model s1is the mapping of s1ands2 while s2is the mapping ofs3and s4.
s1 s2 2 rsince s2 s3 2r and s1 s1 s2 s2 2 rbecause of s1 s2 and s3 s4 2r.
after the abstract model is obtained a model checker is utilized to check whether the abstract model can satisfy the desired property.
if the property is satisfied the original system can satisfy the property.
nevertheless if the property is unsatisfiable in the abstract model it may still be satisfied in the concrete model and none of the behaviors that violate the property in the abstract model can be reproduced in the concrete model.
in this case the counterexample is spurious.
thus when a spurious counterexample is found the abstraction should be refined in order to eliminate the spurious behaviors.
this process is repeated abstraction refinement loop until either a real counterexample is found or the abstract model satisfies the property.the abstraction refinement loop is depicted in fig.
.
initially the abstract model m0is obtained by the abstracabstract h model checker p m m no errors counterexample check spuriousreal counterexample spurious refinementm fig.
.
abstraction refinement loop t algorithm.
then a model checker is employed to check whether or not the abstract model satisfies the desired property.
if no errors are found the model is correct.
otherwise a counterexample is reported and rechecked by a spurious checker which is used to check whether a counterexample is spurious.
if the counterexample is not spurious it will be a real counterexample that violates the system property otherwise the counterexample is spurious and a refining tool is used to refine the abstract model .
subsequently the refined abstract model is checked by the model checker again until either a real counterexample is found or the model is checked to be correct.
in this paper we concentrate on the how to check whether a counterexample is spurious the green part in fig.
.
several methods about how to refine an abstract model can be found in .
iv.
s purious paths to check a spurious counterexample efficiently we first show why spurious paths occur intuitively by an example.
then we briefly present the basic idea of a lgorithm split path which is used in for checking whether a counterexample is spurious.
a. why spurious paths?
abstraction technique preserves all the behaviors of the concrete system but may introduce behaviors that are not present originally.
therefore when checking the abstract model using a model checker some reported counterexamples might not be real counterexamples that violate the desired property.
this problem can intuitively be illustrated by the traffic lights controller example .
example for the traffic light controller system in the l.h.s of fig.
involving variables color andstate by making variable color to be invisible an abstract model can be obtained as shown in the r.h.s of fig.
.
we want to prove state stop any time the state of the light will be stop sometimes in the future .
by implementing a model checker on the abstract model a counterexample h s1 s2 s2 s2 iwill be reported.
however in the concrete model such a behavior cannot be found.
so this is not a real counterexample.
204color redstate stop color yellow state go color green state gostate stop state gooriginal model abstract model s1 s2 s3 s1 s2fig.
.
traffic light controller b. exposition of algorithm split path in a lgorithm split path is presented for checking whether a finite counterexample is spurious.
we present it formally below.
let h s0 s1 snibe a finite counterexample in an abstract model.
the basic idea of a lgorithm split path is to compute the set of reachable states miin each h si vv i n from iunder the following two conditions for each i i n any state s2miis reachable from each mk k i and for each i i n any state s2mi and s0 s 2r it has either s02miors02mi .
formally mk k can be computed by m0 i h s0 vv m1 r m0 h s0 vv m2 r m1 h s0 vv mk r mk h s0 vv then we have m0 1s k 0mk .
similarly for each i n mk i k can be computed by m0 i r mi h si vv m1 i r m0 i h si vv m2 i r m1 i h si vv mk i r mk i h si vv accordingly mi 1s k 0mk i. note that there must exist a natural number m such that m 1s k 0mk i ms k 0mk isince h si vv is finite.
intuitively each state inmiis reachable from i m0 mi and cannot pass through any state outside of m0 mi and mi.
for some state sk k ifmk sk 1is called a failure state .
to check whether a finite counterexample is spurious m0 m1 m2 are computed in turn until the first state skwhere mk is found or the last state in the counterexample is reached.
the following example illustrates how a lgorithm split path works.
example fig.
depicts a kripke structure and a counterexample h s0 s1 s2 s3 s4i in the abstract model.
in this s0 s1 s2 s3 s4 3110fig.
.
algorithm s plit path counterexample i f0g.
m0 i h s0 vv f0g m1 r m0 h s0 vv f1 2g m2 r m1 h s0 vv f3g m3 r m2 h s0 vv thus m0 m0 m1 m2 m3 f0 3g.
m0 r m0 h s1 vv f6g m1 r m0 h s1 vv f8g m2 r m1 h s1 vv it has m1 m0 m1 m2 f6 8g.
further m0 r m1 h s2 vv f11g m1 r m0 h s2 vv f10 12g m2 r m1 h s2 vv so m2 m0 m1 m2 f10 12g.
m0 r m2 h s3 vv f20 21g m1 r m0 h s3 vv f23g m2 r m1 h s3 vv hence m3 m0 m1 m2 f20 23g.
m0 r m3 h s4 vv so m4 m0 .
therefore m4is an empty set and s3is a failure state .
in fig.
m0 m1 m2 m3 and m4are the set of blue nodes in s0 s1 s2 s3 and s4 respectively.
the failure state is depicted in red circle.
for infinite counterexamples it is more complicated to dealing with since the last state in the counterexample can never be reached.
thus a polynomial number of unwinding of the loop in the counterexample is needed .
that is an infinite counterexample can be reduced to a finite one by unwinding the loop for a polynomial number of times.
accordingly s plit path can be used again to check whether this infinite counterexample is spurious.
in a counterexample there may exist more than one states that make the path to be spurious.
in fact by a lgorithm split path always the only failure state if it exists is detected.
however in abstraction refinement loop the elimination of any state that makes the counterexample to be spurious will be enough for the refinement of the abstract model.
therefore it is unnecessary to detect only the failure state in the counterexample for the refinement.205c.
algorithm analysis for a finite counterexample a lgorithm split path is linear in the size1of the counterexample.
nevertheless for an infinite counterexample a lgorithm split path is polynomial in the size2of the counterexample since an infinite counterexample is reduced to a finite one by unwinding the loop for polynomial number of times.
moreover in the verification of systems with industrial scale it is possible that a counterexample contains thousands of millions of states.
so how to make a lgorithm split path more practical is significant in abstract model checking.
v. y etanother definition of spurious counterexamples in a spurious counterexample is described by a counterexample in the abstract model which does not exist in the concrete model.
by the analysis in the previous section it can be preciously defined by a counterexample with one failure state .
in this section we redefine spurious counterexamples from another aspect.
for convenience in0 si in1 si and inn siare defined in0 si fsjs2h si vv s02h si vv and s0 s 2rg in1 si fsjs2h si vv s02in0 siand s0 s 2rg inn si fsjs2h si vv s02inn siand s0 s 2rg then we have in si 1s i 0ini si.
here in0 sidenotes the set of states in h si vv with inputting edges from the states in h si vv and in1 sistands for the set of states in h si vv with inputting edges from the states in in0 si and in2 simeans the set of states in h si vv with inputting edges from the states in in1 si and so on.
thus in sidenotes the set of states in h si vv that are reachable from some state in h si vv as illustrated in the lower irregular shape in fig.
.
note that there must exist a natural number n such thatn 1s i 0ini si ns i 0ini si since h si vv is finite.
particularly for state s0 in0 s0 fsjs2 h s0 vv i g in1 s0 fsjs2h s0 vv s02in0 s0and s0 s 2rg inn s0 fsjs2h s0 vv s02inn s0and s0 s 2rg that is only in0 s0is defined differently since s0has no previous states.
symmetrically out0 si out1 si and outn siare also defined.
1the size of a finite counterexample can be measured by the length of the counterexample as well as the number of states in the original model that are involved in the counterexample.
2the size of an infinite counterexample is measured by the number of individual states in the counterexample as well as the number of states in the original model that are involved in the counterexample.
fig.
.
in siandout si out0 si fsjs2h si vv s02h si vv and s s0 2rg out1 si fsjs2h si vv s02out0 siand s s0 2rg outn si fsjs2h si vv s02outn siand s s0 2rg thus out si 1s i 0outi si.
here out0 sidenotes the set of states in h si vv with outputting edges to the states in h si vv andout1 sistands for the set of states in h si vv with outputting edges to the states in out0 si and out2 simeans the set of states in h si vv with outputting edges to the states in out1 si and so on.
thus out sidenotes the set of states in h si vv from which some state in h si vv are reachable as depicted in the higher iregular shape in fig.
.
similar to in si there must exist a natural number n such thatn 1s i 0outi si ns i 0outi si.
it is also pointed out that for the last state snin a finite counterexample out0 sn fsjs2h sn vv fg out1 sn fsjs2h sn vv s02out0 sn and s s0 2rg outn sn fsjs2h sn vv s02outn sn and s s0 2rg where fis the set of states without any successors in the original model.
based on the definitions of in siandout si ifin si out si is spurious obviously since si 1cannot reach to si 1through si.
example fig.
shows a spurious counterexample where in 2 f9g out 2 f7g and in 2 out 2 .
obviously h 0 1 2 3i is a spurious counterexample that does not exist in the original model.
however for each state siin a counterexample such thatin si out si may still be spurious.
for instance fig.
shows a counterexample without any state si i or such that in si out si in s0 out s0 fs1 s2g in s1 out s1 fs5g and in s2 out s2 fs6g .
nevertheless this counterexample is obviously a spurious one because green states are not reachable from the red ones.
12 0 1 2 3fig.
.
a spurious path where in 2 out 2 s1s2s3 s4 s5 s6 s0 s1 s2 in s0 s1 s2 out s0 s1 s2 s3 in s1 s4 s5 out s1 s5 in s2 s6 out s2 s6 in s0 out s0 s1 s2 in s1 out s1 s5 in s2 out s2 s6 fig.
.
a spurious path letei in si out sifor each i n. as illustrated in fig.
given a counterexample with in si out si for si in si out si ei si in si 1out si ei 1 si in si out si ei fig.
.
checking spurious counterexamples each state siin to check whether is spurious we need to further checkhe0 e1 eniagain similar toh s0 s1 sniby treating each of e0 e1 enas a state.
this process will be repeated until in ei out ei i.e.ei in ei out ei will keep unchanged for each i orin ei out ei for some i. in case in ei out ei for each i the counterexample is a real one otherwise if there exists some isuch that in ei out ei the counterexample is a spurious one.
for instance for the counterexample in fig.
we need to further checkhe0 e1 e2ias illustrated in fig.
.
note that here e0 s1s2 s5 s6e0 e1 e2 in e0 s1 s2 out e0 in e0 out e0 in e1 out e1 s5 in e1 out e1 in e2 s6 out e2 s6 in e2 out e2 s6 fig.
.
a spurious path e1 and e2equals to in s0 out s0 fs1 s2g in s1 out s1 fs5g andin s2 out s2 fs6gin fig.
respectively.
by computing in ei out ei i or it can be obtained that the counterexample is spurious since in ei out ei for both i 0and1.
the above procedure for checking whether a counterexample is spurious is intuitively illustrated in fig.
.
for clarity we use ej i j as a temporal variable to record the result ofin ej i out ej i .
here the superscript j 0indicates the times of the run.
in the 0th run for each i n e0 iis assigned with h si vv .
e0 0e0 1e0 2e0 e0 n e1 0e1 1e1 2e1 e1 n e2 0e2 1e2 2e2 e2 n 0th run 1st run 2nd rune0 i h si e1 i in e0 i out e0 i e2 i in e2 i out e1 i fig.
.
checking spurious counterexamples for convenience a state siwith in ej i out ej i is called a false state .
further given a false state siin a counterexample the set of the origins of si h si vv is divided into three sets d inej i the set of dead states b outej i the set of bad states and i h si vv n d b the set of the isolated states .
for instance state 2in fig.
is a false state .
inh 2 vv i.e.f7 9g f9gis the set of dead states f7gthe set of bad states and f8gthe set of isolated states.
in a counterexample h s0 sni suppose siand sjare twofalse states with en i andem j m n respectively.
we call the false state siis hidden shallower than si.
by the above procedure always the shallowest false state is detected if it exists.
armed with these notations a spurious counterexample is formally defined below.
definition spurious counterexamples a counterexample in an abstract model kis spurious if and only if there exists at least one false state in .
to confirm the equivalence of the new definition of spurious counterexamples with the original one the following theorem is proved.
theorem a counterexample is spurious if and only if there exists at least one false state in .
proof by the definitions of false states if there exists a false state in does not exist in the concrete model.
if there exist no false states in it has e0 e1 and en for each i n by the definition of false states .
thus for each state s2ei sis reachable from ei and can access to ei 1since sis in both in ei 1andout ei .207so for each state in en it is reachable from e0 through e0 e1 and en .
accordingly h s0 s1 sniexists in the concrete model.
vi.
a lgorithms for checking spurious counterexamples based on the new definition of spurious counterexamples algorithms for checking whether a counterexample is spurious are presented in this section.
generally speaking to check whether a counterexample is spurious can be determined by detecting the existence of false states in the path.
if a false state is found the counterexample is spurious otherwise the counterexample is a real one.
a. detecting false states on he0 eni by the definition of spurious counterexamples based on false states to check whether a counterexample is spurious we need to detect the false states onhe0 eni recursively.
we first present a lgorithm check false i for checking false states onhe0 eniin one run.
a lgorithm check false i takeshe0 enias input and outputs the first detected false state if it exists.
algorithm ch e c k fa l s e i he0 eni input he0 eni output the first detected false state sfin the counterexample initialization int i while i ndo ifin ei out ei i i else return sf si break end while in a lgorithm check false i to check whether a state siis a false state only relies on ei s previous and successor states ei 1and ei while in a lgorithm split path to check state siis up to checking the whole prefix h s0 si 1i of si.
therefore compared with a lgorithm split path check false i can be parallelized naturally as presented in algorithm check false ii.
in c heck false ii anytime if a false state is detected by a processor all the processors will stop and the false state is returned.
that is the algorithm always reports the first detected false state obtained by the processors.
note that a boolean array c is used to indicate whether a state in the counterexample is a false one.
initially for all i n c is?
c is undefined .
c f alse means state siis afalse state .
b. checking spurious counterexamples based on the algorithms for detecting false states algorithm check spurious i is presented to check whether a given finite counterexample is spurious.
in check spurious i initially e0 enis initialized by h s0 vv h sn vv respectively then c heck false ii is called recursively until each of e0 enkeeps unchanged orafalse state is detected.
to perform it a boolean array cwith length n 1is utilized to memorize the situation of each ei.
ifc ?
it means that currently neither inek out eknor inek out ek .
that is ekneeds to be further updated with inek out ek and then inek out ekshould be recalculated.
ifc true it indicates that ekwill keep unchanged skcannot be a false state .
any time if inek out ek the algorithm will stop and a false state is returned.
in case c true for each k h s0 sniis reported to be a real counterexample.
algorithm check false ii input he0 eni n the number of processors k processor id output a false state sf initialization bool c f?
?g fork 0tondo in parallel do ifin ek out ek then c f alse return sf sk stop all processors end if end for algorithm ch e c k sp u r i o u s i input h s0 sni n the number of processors k processor id output a false state sf initialization e0 h s0 en h sn bool c f?
?g check false fork 0tonin parallel do ifc ?then ifinek out ek then return sf sk stop all processors end if ifinek out ek ek then c ture end if ifinek out ek ekand inek out ek then ek inek out ek end if end if end for iffor all i n c ture return has no false states elsegoto check false note that a counterexample may be a finite path hs0 s1 sni n or an infinite path hs0 s1 si sj !i i j with a loop suffix a suffix produced by a loop .
for the finite one it can be checked directly with a lgorithm check spurious i while for an infinite one we need only to check its complete finite prefix cfp hs0 s1 si sji since whether or not a state siis a false state only relies on its previous and successor states.
it is pointed out that in the208cfphs0 s1 si sjiof an infinite counterexample out0 sj fsjs2h sj vv s02h si vv and s s0 2rg out1 sj fsjs2h sj vv s02out0 sjand s s0 2rg since the successor state of sjis si.
c. algorithm for detecting the heaviest false state in a lgorithm check spurious i always the first detected false state is returned.
then further refinement will be done based on the analysis of this false state .
possibly several false states may occur in one counterexample so which one is chosen to be refined is not considered.
obviously if a false state shared by more paths is refined a number of model checking iterations are hopefully to be saved in the whole abstract refinement loop.
under this consideration we will check the state shared by more paths first.
to do so for an abstract state sas illustrated in fig.
ein s andeout s are defined.
ein s equals to sein eout fig.
.
in and out edges the number of edges connecting to the states in h s vv from the states outside of h s vv and eout s is the number of edges connecting to the states out of h s vv from the states inh s vv .
accordingly ein s eout s is the number of the paths where soccurs.
for convenience we call ein s eout s the weight of the abstract state s. in c heck spurious ii the counterexample is recursively checked until each eikeeps unchanged or is detected as a false state .
then the heaviest false state is returned for further refinement.
that is all the false states are detected out first and then the heaviest one is returned.
d. algorithm analysis compared with a lgorithm split path for detecting failure states to check whether a state is a false state by algorithm check spurious i only relies on its previous and direct successor states.
thus when dealing with infinite counterexamples by a lgorithm check spurious i the finite prefix to be checked will be polynomially shorter than the one dealt by a lgorithm split path.
that is given an infinite counterexample by a lgorithm check spurious i the number of the states to be analyzed will be polynomial less than the one to be considered by a lgorithm split path.
further for the finite counterexamples in each iteration e0 e1 en are checked in parallel.
also the algorithms analyze each state in the counterexample gradually by considering its previous and successor states.
thus some false states that are hidden shallower will be detected earlier and lots of iterations can be avoided in practise.algorithm ch e c k fa l s e iv input a counterexample h s0 s1 sniin the abstract model k s s0 r l and the original model k s s0 r l in shared memory n the number of processors k processor id output a false state sf initialization e0 h s0 en h sn bool c f?
?g check false fork 0tonin parallel do ifc ?then ifinek out ek then c f alse end if ifinek out ek ek then c ture end if ifinek out ek ekand inek out ek then ek inek out ek end if end if end for iffor each i n c ?
then ifc ture for each ithen return has no false states end if ifc f alse and siis the heaviest one among the false states then return si end if else goto check false end if vii.
e valuation to evaluate the proposed approach we implemented a counterexample checker called cc for short xidian.edu.cn home ctian files .zip that contains both algorithm c heck spurious i and s plit path for checking spurious counterexamples.
note that here we do not compare the results of algorithm c heck spurious ii with check spurious i and s plit path since its advantages can only be presented in the whole abstraction refinement loop.
to make the results more general we randomly generate the original models by providing the numbers of states and transitions achieve the abstract models by providing the insensitive variables and select a path i.e.
counterexample randomly in the abstract model.
subsequently we implement algorithm c heck spurious i and s plit path on the same selected path respectively and record the time consumed by both the two algorithms.
we use graphviz .
to display the original and abstract models.
fig.
a and b shows a randomly generated model and its abstract model respectively.
we just present small models since for the ones containing several thousands of states the graphs are unclear.
the following experiments are performed on core pc.
we randomly generate five models with the size209 a original model b abstract model fig.
.
original and abstract models illustrated by graphviz s t being and respectively.
here smeans the number of states while tthe number of transitions in the original model.
by selecting counterexamples at random algorithms check spurious i are compared with algorithm s plitpath.
the experimental data are recorded in table vii and the curves depicting the time consumed by the two algorithms on different models are presented in fig.
.
the vertical axis depicts the size of the model and the horizontal axis describes the time ms used for checking whether or not the selected path is spurious.
from the table and the curves it can be seen that in case the scale of the model is small because of the expense in creating and destroying threads the merit of parallel algorithm is not obvious.
however as the scale of the model grows the advantages of the new algorithm turn out to be evident.
table i results of experiment model size split path check spurious i states transitions models average models average number number ms ms ms ms .
.
.
.
.
.
.
.
.
.
.
.
.
.
viii.
c onclusion based on the formal analysis of spurious paths a new approach for detecting spurious counterexamples is presented in this paper.
with this approach for an infinite counterexample 210fig.
.
comparation between algorithm checkspurious i and splitpath the polynomial number of unwinding of the loop is avoided.
that is the finite prefix to be checked will be polynomially shorter than the one checked by the existing algorithm.
besides for a given finite counterexample or finite prefix of an infinite counterexample the new algorithm still performs well.
the reasons are two the algorithm is parallelized in each run for detecting false states the shallowest false state is always detected such that many iterations in the algorithm will be avoided in practise.
the presented algorithms are useful in improving efficiency of abstract model checking especially cegar based abstract model checking.
in the near future together with our previous results for refining abstract models the new proposed algorithms will be implemented and integrated into several model checkers such as slam and blast where cegar is implemented.
in addition we will also investigates how these algorithms can be applied in abstract model checking of shared variable concurrent programs.
acknowledgment zhenhua duan is the corresponding author.
this research is supported by the nsfc grant no.
and program grant no.
2010cb328102 and isn lab grant no.
isn1102001.
we thank wenqiang fan in implementing the counterexample checker cc.