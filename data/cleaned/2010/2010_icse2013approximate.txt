efficient construction of approximate call graphs for javascript ide services asger feldthaus max sch fery manu sridharanz julian dolbyz and frank tipx aarhus university denmarkynanyang technological university singapore asf cs.au.dk schaefer ntu.edu.sg zibm t.j. watson research center usaxuniversity of waterloo canada msridhar dolby us.ibm.com ftip uwaterloo.ca abstract the rapid rise of javascript as one of the most popular programming languages of the present day has led to a demand for sophisticated ide support similar to what is available for java or c .
however advanced tooling is hampered by the dynamic nature of the language which makes any form of static analysis very difficult.
we single out efficient call graph construction as a key problem to be solved in order to improve development tools for javascript.
to address this problem we present a scalable field based flow analysis for constructing call graphs.
our evaluation on large real world programs shows that the analysis while in principle unsound produces highly accurate call graphs in practice.
previous analyses do not scale to these programs but our analysis handles them in a matter of seconds thus proving its suitability for use in an interactive setting.
i. i ntroduction over the past decade javascript has turned from a niche language for animating html pages into an immensely popular language for application development in many different domains.
besides being the enabling technology for web .
applications such as google mail it is becoming a popular choice for server side programming with node.js for writing cross platform mobile apps with frameworks like phonegap and even for implementing desktop applications.
this increase in popularity has led to a demand for modern integrated development environments ides for javascript providing smart code editors software maintenance tools such as automated refactorings and code analysis tools.
while a variety of mature ides exist for languages like java and c such tools have only just begun to appear for javascript existing ides such as eclipse komodo ide and netbeans are starting to support javascript while new ides specifically targeted at web programming such as webstorm and cloud9 are also gaining traction.
compared with their java counterparts however these ides are fairly bare bones.
code navigation and completion use heuristics that sometimes fail unexpectedly while refactoring and analysis is all but unsupported.
there has been some work on more principled tools and analyses but these approaches do not yet scale to real world applications.
a key impediment to advanced tooling for javascript is the difficulty of building call graphs that is determining this paper was written while the authors were with ibm research.the functions that a given call may invoke at runtime.
such reasoning is required in ides both for basic features like jump to declaration and also for refactoring or analysis tools that need to reason interprocedurally.
to be useful in an ide a call graph construction algorithm must be lightweight andscalable modern programmers expect ide services to be constantly available so it should be possible to quickly compute call graph information on demand even for large framework based javascript applications.
demands on precision and soundness may vary between clients for jump to declaration listing many spurious call targets is perhaps even worse than occasionally missing one while analysis tools may prefer a fairly conservative call graph.
achieving absolute soundness is however almost impossible in javascript due to widespread use of eval and dynamic code loading through the dom.
a useful compromise could be an unsound call graph construction algorithm that can to some extent quantify its degree of unsoundness for instance by indicating call sites where some callees may be missing the ide can then pass this information on to the programmer.
in java call graphs can be efficiently constructed using class hierarchy analysis which uses type information to build a call graph.
however since javascript is dynamically typed and uses prototype based inheritance neither class hierarchy analysis nor its more refined variants that keep track of class instantiations are directly applicable.
additionally these analyses cannot easily handle first class functions.
an alternative are flow analyses such as cfa or andersen s points to analysis that statically approximate the flow of data including first class functions to reason about function calls.
while typically not fast enough for interactive use such analyses could still be used for non interactive clients like analysis tools.
however while state of the art flow analyses for javascript can handle small framework based applications they do not yet scale to larger programs.
in this work we present a lightweight flow analysis specifically designed to efficiently compute approximate call graphs for real world javascript programs.
its main properties are the analysis is field based meaning that it uses a single abstract location per property name.
thus twofunctions that are assigned to properties of the same name will become indistinguishable as call targets.
it only tracks function objects and does not reason about any non functional values.
it ignores dynamic property accesses i.e.
property reads and writes using javascript s bracket syntax.
these design decisions significantly reduce the number of abstract locations and objects thus dramatically improving scalability.
while precision could in principle suffer we show in our evaluation that this does not happen in practice.
clearly ignoring dynamic property reads and writes makes the analysis unsound but this is a consequence of the first two design decisions since we only track function objects we cannot reason about the possible string values of pin a dynamic property access e and using a field based approach means that imprecision cannot be contained by reasoning about aliasing.
however previous work has shown that many dynamic property accesses are correlated i.e.
they copy the value from property pin one object to property pof another.
with a field based approach such a copy is a no op since the analysis uses a single representation for all pproperties anyway.
our evaluation indicates that in practice very few call targets are missed due unsoundness.
like any flow analysis our analysis faces a chicken and egg problem to propagate abstract argument and return values between caller and callee we need a call graph yet a call graph is what we are trying to compute.
we explore two analysis variants that tackle this problem in different ways.
the first is a standard optimistic analysis in the terminology of grove and chambers that starts out with an empty call graph which is gradually extended as new flows are discovered until a fixpoint is reached.
the second variant is a pessimistic analysis that does not reason about interprocedural flow at all and simply gives up on call sites whose call target may depend on such flow except in cases where the callee can be determined purely locally.
we have implemented both of our techniques and performed an extensive empirical evaluation on ten large real world javascript web applications many of them based on popular frameworks.
to show the feasibility of using our analyses in an ide the implementation operates on abstract syntax trees asts as ide based tools normally do rather than on an intermediate code representation as is typical for flow analyses.
both analyses scale very well and are able to build call graphs for even fairly large programs in a few seconds.
as expected the pessimistic analysis is faster than the optimistic one since it does not need to iterate to a fixpoint.
to evaluate precision and scalability we compared our analysis results to dynamic call graphs that we obtained by manually exercising instrumented versions of our subject programs.
the optimistic analysis achieves high precision and very high recall with respect to these dynamic call graphs but what is perhaps surprising is that the pessimistic analysis does just as well.
this suggests that in many cases the pessimistic analysis may be preferable not only is it faster but it also clearly a b fig.
.
test page before a and after b applying the plugin indicates which call sites it cannot reason about precisely whereas the optimistic analysis gives a result for every call site that may sometimes be very imprecise.
finally we evaluate several possible client applications of our algorithms we show that the call graphs they generate are much more complete than what current ides offer and could be used to significantly improve the jump to declaration feature.
moreover our call graphs also facilitate the implementation of bug finding and smell detection tools that check for common programming mistakes.
contributions to the best of our knowledge this paper presents the first static analysis capable of computing useful call graphs for large javascript applications.
specifically we make the following contributions we propose two variants of a field based flow analysis for javascript that only tracks function objects and ignores dynamic property reads and writes.
we show that both scale to large real world programs.
comparing against dynamic call graphs we find that the analyses while in principle unsound produce accurate call graphs in practice.
we demonstrate several client applications to show the usefulness of our approach.
the remainder of the paper is organized as follows.
section ii motivates our techniques on a simple but realistic javascript program.
section iii explains our analyses in detail and section iv evaluates them on real world applications.
section v surveys related work and section vi concludes.
ii.
m otivating example as an example to introduce our techniques we present a simple plugin to the popular jquery framework that can be used to highlight alternating rows of html tables for easier on screen reading as shown in fig.
.
we discuss some challenges for call graph construction illustrated by this example and explain how our analysis handles them.
a. example walkthrough the jquery framework provides a wide variety of functionality to simplify cross browser application development.
most of its features are exposed through the global jquery function which can be used to register event handlers parse snippets of html or perform css queries over the dom.
function 2function jquery n 3var res object.create jquery.fn 4var elts document.getelementsbytagname n 5for var i i elts.length i res elts 7res.length elts.length 8return res 11jquery.fn 12extend function ext obj for var pinobj jquery.fn obj 18jquery.fn.extend 19each function cb for var i i this .length i cb this i 25window.jquery jquery fig.
.
a small subset of jquery the result of such a query is a special jquery result object which provides array like access to the result elements through numerical indices and offers many utility methods some of them defined by jquery itself and others defined by plugins.
our simplified version of jquery shown in fig.
implements a jquery function as well.
following a common pattern it is first defined as a local function within a surrounding closure lines and later stored in a global variable to make it accessible to client code line .
our jquery function only provides a very simple form of querying when passed a string argument it finds all dom elements with this tag name line stores them into the result object sets its length property to indicate how many elements were found and returns it.
for instance jquery tbody returns all table body elements in the document.
the result object itself is created on line using the builtin function object.create which takes as its argument an objectpand returns a new object othat haspas its prototype.
in this case the prototype object will be jquery.fn which is defined on line .
thus any property defined on jquery.fn is available on all jquery result objects via javascript s prototype based inheritance mechanism.
initially the jquery.fn object contains a single property a method extend that adds all property value pairs of its argument object obj tojquery.fn .
this is done through a for inloop lines that iterates over all properties p ofobj and uses dynamic property reads and writes to copy the value of property ponobj into a property of the same name on jquery.fn .
if no such property exists yet it will be created otherwise its previous value will be overwritten.
function .fn.highlightalt function c 29this .each function elt for var i i elt.children.length i elt.children .style.backgroundcolor c 35window.highlightaltrows function tbody .highlightalt a9d0f5 jquery fig.
.
a jquery plugin to highlight alternating children of dom elements on line the extend method is used to add a method each tojquery.fn which iterates over all elements contained in a result object and invokes the given callback function cbon it passing both the element and its index as arguments.
the plugin shown in fig.
uses the each method passing it a callback that in turn iterates over all the children of every result element and sets the background color of every second element to a given color c line .
this functionality is exposed as a method highlightalt added to the jquery.fn object and hence available on every jquery result object.
the plugin also defines a global function highlightaltrows that clients can invoke to apply highlighting to all tables in the document it uses the jquery function to find all table bodies and then invokes highlightalt on each of them.
notice that a closure is used to make the global jquery variable available as a local variable .
our example illustrates several important features of javascript variables have no static types and may in general hold values of different types over the course of program execution.
objects in javascript do not have a fixed set of properties instead properties can be created simply by assigning to them e.g.
the plugin adds a method highlightalt tojquery.fn and can even be deleted not shown in the example .
functions are first class objects that can be passed as arguments as with the each function stored in object properties to serve as methods and even have properties themselves.
finally dynamic property reads and writes allow accessing properties by computed names.
b. challenges for call graph construction as discussed in section i call graphs are widely useful in ides for example to implement jump to declaration or to perform lightweight analysis tasks.
unfortunately neither standard coarse approaches nor more precise flow analyses work well for building javascript call graphs as we shall explain using our running example.
java ides take a type based approach to call graph construction the possible targets of a method call are simply those admitted by the program s class hierarchy.
since variables and properties are not statically typed in javascript typebased call graph construction algorithms are not immediately applicable.
while prototype objects are superficially similarto java classes properties can be dynamically added or overwritten.
for instance the jquery.fn object in our example starts out with only one property extend to which two others each andhighlightalt are later added defeating any simple static type inference.
type inference algorithms for javascript that can handle such complications have been proposed but do not yet scale to real world programs.
an very na ve way to construct call graphs would be to use name matching and resolve a call e.f ... to all functions named f. this approach which is used by eclipse jsdt fails when functions are passed as parameters or stored in properties with a different name like the extend function on line .
consequently jsdt is unable to resolve any of the call sites in our example.
other ides employ more sophisticated techniques but we do not know of any current ide that can handle callbacks and discover targets for the call on line .
a more conservative approach suggesting any function with the right number of parameters as a call target would likely be too imprecise in practice yet still fails to be sound since javascript allows arity mismatching the call on line passes two parameters while the callback only declares one.
a flow analysis like an andersen style pointer analysis or an inter procedural data flow analysis can avoid these issues.
such analyses work by tracing the flow of abstract values through abstract memory locations based on the relevant program statements primarily assignments and function calls .
a call graph is then derived by determining which function values flow to each invoked expression.
however building a precise flow analysis that scales to large javascript programs is an unsolved challenge.
in the example of fig.
the flow of functions to invocations is non trivial due to the use of the extend function to modify the jquery.fn object.
precise modeling of dynamic property accesses like those in extend and other complex constructs is required to obtain a useful flow analysis result but this precise modeling can compromise scalability see for a detailed discussion.
in particular we know of no javascript flow analysis that can analyze real world jquery based application.
c. our approach in this paper we show that a simple flow analysis suffices to construct approximate call graphs that are in practice sufficiently accurate for applications such as ide services.
our analysis only tracks the flow of function values unlike most previous flow analyses which track the flow of all objects.
ignoring general object flow implies that for a property access e.f the analysis cannot reason about which particular abstract object s fproperty is accessed.
instead a field based approach is employed in which e.f is modeled as accessing a single global location f ignoring the base expression e. our analysis uses a standard flow graph capturing assignments of functions into variables and properties and of one variable into another.
for instance the function declaration on 1the analysis in could only analyze a manually rewritten version of jquery with handling of certain javascript features disabled.line adds a flow graph edge from the declared function to the local variable jquery while the assignment on line adds an edge from that variable to the abstract location prop jquery representing all properties named jquery .
the function call on line in turn establishes a flow from prop jquery into the parameter leading the analysis to conclude that the call on line may indeed invoke the jquery function.
details of how to construct the flow graph and how to extract a call graph from it are presented in the next section.
at first glance dynamic property accesses present a formidable obstacle to this approach for a dynamic property access e the analysis cannot reason about which names pcan evaluate to since string values are not tracked.
a conservative approximation would treat such accesses as possibly reading or writing any possible property leading to hopelessly imprecise analysis results.
however we observe that dynamic property accesses in practice often occur as correlated accesses where the read and the write refer to the same property as on line in our example.
a fieldbased analysis can safely ignore correlated accesses since like named properties are merged anyway.
our analysis goes further and simply ignores alldynamic property accesses.
this choice compromises soundness as seen in this example inspired by code in jquery arr for var i i arr.length i .fn function ... .fn.outerwidth the dynamic property write inside the loop corresponds to two static property writes to .fn.outerwidth and .fn.outerheight which the analysis ignores hence it is unable to resolve the call to outerwidth .
but as we shall show in our evaluation section iv such cases have little effect on soundness in practice.
furthermore unlike more precise flow analyses our approach scales easily to large programs which makes it well suited for use in an ide where a small degree of unsoundness can be tolerated.
iii.
a nalysis formulation we now present the details of our call graph construction algorithm.
we first explain the intraprocedural parts of the analysis and then present two contrasting approaches to handling interprocedural flows one pessimistic and one optimistic.
a. intraprocedural flow our algorithm operates over a flow graph a representation of the possible data flow induced by program statements.
the vertices of the flow graph represent functions variables and properties while the edges represent assignments.
to emphasize the suitability of our techniques for an ide we show how to construct the flow graph directly from an ast as is done in our implementation.
abstracting from a concrete ast representation we write for the set of all ast positions and use the notation t to mean a program element t such as an expression a function declaration or a variable declaration at position .node at edges added when visiting r1 l r v r !v l v r !exp r2 l r v l !exp v r !exp r3 t?l r v l !exp v r !exp r4 l r v r !exp r5 f e v ei !prop fi r6 function expression fun !exp if it has a name fun !var r7 function declaration fun !var fig.
.
intraprocedural flow graph edges generated for ast nodes we assume a lookup function for local variables such that x for a position and a name xreturns the position of the local variable or parameter declaration if any that xbinds to at position .
for any position denotes the position of the innermost enclosing function excluding itself .
there are four basic types of vertices v exp value of expression at jvar variable declared at jprop f property of name f jfun function declaration expression at we define a function vthat maps expressions to corresponding flow graph vertices v t var ift xand x prop x ift xand x undefined prop f ift e f exp otherwise to build the flow graph we traverse the ast and add edges as specified by the rules in fig.
.2for our example by rule r7 the declaration of jquery on line yields an edge fun !var jquery where we use line numbers as positions and refer to local variables by name for readability.
likewise the function expression on line yields two edges fun !var ext and fun !exp by r6 .
some of the other edges generated for our example are shown as solid arrows in the partial flow graph in fig.
.
b. interprocedural flow to handle interprocedural flow the set of vertices needs to be extended as follows v jcallee callee of call at jarg i ith argument of call at jparm i ith parameter of function at jret return value of function at jres result of call at the function vmapping expressions to vertices is likewise extended if x is theith parameter of the function declared at thenv x parm i andv this parm i.e.
this is considered to be the 0th parameter.
rules for connecting arg and ret vertices with exp vertices are given in fig.
.
r4 is somewhat subtle in javascript the result of l r can only be liflevaluates to a false value but in this case it is not a function and thus does not have to be tracked.returning to our example the function call on lines yields by rule r8 an edge prop jquery !arg .
this edge and some of the other edges that are generated by the rules of fig.
are shown as dotted arrows in fig.
.
we now introduce two approaches for connecting parm to arg andrettores vertices to track interprocedural flow.
algorithm pessimistic call graph construction output call graphc escaping functions e unresolved call sitesu ci f jt is a one shot call to a function f 0g ei f 0j 2cig ui f j 2cig g addinterprocedural edges g ci ei ui add edges from fig.
and c f jfun opt gcallee g e f jfun gunknowng u f junknown gcallee g c. pessimistic approach the pessimistic call graph construction algorithm alg.
only tracks interprocedural flow in the important special case ofone shot calls i.e.
calls of the form function x ... e where an anonymous function the one shot closure is directly applied to some arguments.
in all other cases interprocedural flow is modeled using a special unknown vertex.
we start call graph construction from an initial call graph cithat only contains edges from one shot calls to one shot fun var jquery prop jquery arg parm callee fun var ext exp prop extend callee fun exp arg unknown parm callee parm fig.
.
partial flow graph for fig.
and .
solid edges are added by the rules of fig.
dotted edges by the rules of fig.
and dashed edges by alg.
.
node at edges added when visiting r8 f e ornewf e v f !callee v ei !arg i res !exp r9 r p e as r8 plus v r !arg r10 returnev e !ret fig.
.
flow graph edges generated for calls and returnsclosures.
all other functions are considered escaping functions setei and all other call unresolved call sites setui .
the flow graphgis initially empty.
algorithm addinterprocedural edges input flow graphg initial call graph c escaping functions e unresolved call sites u for all 2cdo add edges arg i !parm i tog add edge ret !res tog for all 2udo add edges arg i !unknown tog add edge unknown!res tog for all 02edo add edges unknown!parm i tog add edge ret !unknown tog now we add interprocedural edges to gas described in alg.
arg vertices are connected to parm vertices along the edges in ci and similar for retandres thus modeling parameters and return values.
argument values at unresolved call sites flow into unknown and from there into every parameter of every escaping function.
conversely the return value of every escaping function flows into unknown and from there into the result vertex of every unresolved call site.
in fig.
this step adds the dashed edges.
note that arg is connected to parm precisely modeling the one shot call at line whereas arg is conservatively connected to unknown since this call site is unresolved.
intraprocedural edges are now added as per fig.
and .
to extract the final call graph we need to compute the transitive closure of gto determine all function vertices fun from which a call site 0is reachable.
however if we consider flows through unknown the resulting call graph will be very imprecise.
instead we want to produce a call graph that gives reasonably precise call targets for many call sites and marks sites for which no precise information is available.
writing gfor the transitive closure of g andopt gfor theoptimistic transitive closure which does not consider paths through unknown we define the call graph c the seteof escaping functions and the set uof unresolved call sites a call may invoke any function that directly flows into its callee vertex without going through unknown ifunknown flows into a site then that site is unresolved and the information in c may not be complete and if a function flows into unknown it may be invoked at call sites not mentioned in c. in the partial flow graph in fig.
we can see that fun opt gcallee so the call at line may invoke the function at line and likewise fun opt gcallee .
however fun 6opt gcallee and since there are no other flows into callee the pessimistic call graph does not provide a call target for this call.d.
optimistic approach the pessimistic approach produces a call graph triple c e u from an initial triple ci ei ui which could be done repeatedly.
this is what the optimistic approach does but instead of starting from a conservative triple that considers all calls unresolved and all functions escaped unless they are one shot the optimistic approach starts with the empty triple .
the flow graph is built using the same rules as for the pessimistic approach and a new triple is extracted in the same way but then the whole procedure is repeated until a fixpoint is reached.
for our example this leads to a more complete call graph in particular the optimistic approach can show that the call on line may invoke the function passed on line .
e. discussion one would expect the pessimistic approach to be more efficient but less precise than the optimistic approach and past work on call graph construction for other languages supports this conclusion .
as we will show in our evaluation however the loss in precision is actually fairly minor in practice hence the pessimistic approach may be preferable for some applications.
many call graph algorithms only produce call graphs for code that is deemed reachable from a given set of entry points which can improve precision particularly for optimistic call graph construction.
we choose not to do so for two main reasons.
firstly we want our algorithms to be usable in an ide while developing a program at this point some code may not yet have been integrated with the rest of the program and hence appear to be dead but a programmer would still expect ide services to be available for this code.
secondly reasoning about reachability requires a fairly elaborate model of the javascript standard library and the dom for instance event handlers should always be considered reachable and reflective invocations using call and apply must also be accounted for.
by analyzing allcode instead we can make do with a very coarse model that simply lists all known methods defined in the standard library and the dom.
for a standard library function such as array.prototype.sort we then simply introduce a new vertex builtin array sort with an edge to prop sort .
iv.
e valuation we have implemented both the pessimistic and the optimistic call graph algorithm in coffeescript 3a dialect of javascript.
in this section we evaluate our implementation with respect to the following three evaluation criteria ec1 how scalable are our techniques?
ec2 how accurate are the computed call graphs?
ec3 are our techniques suitable for building ide services?
to evaluate these criteria we run both our algorithms on ten real world subject programs and measure their performance.
i subject programs program underlying loc num.
of num.
of dyn.
cg framework functions calls coverage 3dmodel none .
beslimed mootools .
coolclock jquery .
flotr prototype .
fullcalendar jquery .
htmledit jquery .
markitup jquery .
pacman none .
pdfjs none .
pong jquery .
to measure accuracy we compare the resulting static call graphs against dynamic call graphs obtained by manually exercising the programs.
finally we informally compare our analyses with existing ides and report on experiments with two client analyses implemented on top of our call graphs.
a. subject programs table i lists our subjects which are ten medium to large browser based javascript applications covering a number of different domains including games beslimed pacman pong visualizations 3dmodel coolclock editors htmledit markitup a presentation library flotr a calendar app fullcalendar and a pdf viewer pdfjs .
as shown in the table all but three of them rely on frameworks these frameworks are the three most widely used ones according to a recent survey which found that of all surveyed websites used jquery used mootools and used prototype.
in many cases the framework libraries included in the subject programs were in minified form.
to aid debugging we replaced these by their unminified development versions which also more closely matches the development setting in which we envision our techniques to be used.
since minifiers typically do not rename properties however our analyses should not be significantly less precise for minified code.
for each program we list three size measures the number of non blank non comment lines of code as determined by thecloc utility as well as the number of functions and of call sites.
the coverage number in the last column will be explained below.
for the framework based subjects framework code contributes between and of code size.
b. scalability ec1 to evaluate scalability we measured the time it takes to build call graphs for our subject programs using both of our algorithms.
as javascript s built in time measurement functions turned out to be unreliable we used the standard unix time command measuring user time.
this includes both time for parsing and for the analysis so we separately measured the time it takes just to parse every program.
the results of these measurements are given in fig.
.
all experiments were performed on a lenovo thinkpad w520 with an intel core i7 2720qm cpu and 8gb ram using version .
.
.
of the v8 javascript engine running on 4our experimental data is available online at 5s10s15s20s 3dmodelbeslimedcoolclockflotrfullcalendarpacmanhtmleditmarkituppdfjspongparsing pessimistic optimisticfig.
.
time measurements for parsing and analysis averaged over ten runs error bars indicate standard deviation linux .
.
bit version .
timings are averaged over ten runs with error bars indicating standard deviation.
both analyses scale very well with even the largest program analyzed in less than seconds using the optimistic and less than nine seconds using the pessimistic approach including about three seconds of parsing time in both cases .
the pessimistic analysis in particular already seems fast enough for use in an ide where an ast would already be available.
c. call graph accuracy ec2 measuring the accuracy of our call graphs is not easy since there is no existing analysis that can handle all our subject programs against which to compare our results.
instead we compare against dynamic call graphs and measure precision and recall with respect to dynamically observed call targets.
to obtain dynamic call graphs we instrumented our subject programs to record the observed call targets for every call that is encountered at runtime and manually exercised these instrumented versions.
additionally we measured the function coverage achieved this way i.e.
the percentage of non framework functions that were executed while recording the call graphs which is shown in the last column of table i. in all cases but one coverage is above indicating that the dynamic call graphs are based on a reasonable portion of the code and hence likely to be fairly complete.
we manually investigated the low coverage on 3dmodel and found that most of the uncovered code does in fact seem to be dead.
next we used our two analyses to generate call graphs for all our subject programs and computed precision and recall for every call site that is covered by the dynamic call graph.
writingdfor the set of targets of a given call site in the dynamic call graph and sfor the set of targets determined by the analysis the precision is computed asjd sj jsj i.e.
the percentage of true call targets among all targets while recall isjd sj jdj i.e.
the percentage of correctly identified true targets .
averaging over all call sites for a given program we obtain the results in fig.
.
both analyses achieve almost the same precision on most programs with the pessimistic analysis performing slightly60 3dmodelbeslimedcoolclockflotrfullcalendarpacmanhtmleditmarkituppdfjspongprecision pessimistic optimistic 3dmodelbeslimedcoolclockflotrfullcalendarpacmanhtmleditmarkituppdfjspongrecallfig.
.
precision and recall measurements for optimistic and pessimistic call graphs compared to dynamic call graphs better.
only on beslimed andflotr the two non jquery programs is the difference more marked and we only achieve a relatively modest precision of between and while on the others the precision is at least .
for both approaches the main sources of imprecision are functions that are stored in properties of the same name which a field based analysis cannot distinguish as call targets.
additionally the optimistic approach may resolve callback invocations imprecisely.
the pessimistic approach would give up on such call sites returning zero call targets which accounts for its better precision measure.
both analyses achieve very high recall in every case more than of dynamically observed call targets are also found by the analysis with recall above for the jquerybased programs and close to for the framework less programs.
missing call targets are due to the unsoundness of our approach with respect to dynamic property writes.
these are often used in frameworks to define a group of closely related functions or to do metaprogramming which is rare in non framework code.
on flotr the optimistic analysis does significantly better than the pessimistic one this seems to be due to a liberal use of callback functions which are not handled by the pessimistic analysis.
d. suitability for ide services ec3 we now evaluate the suitability of our analyses for three typical client applications.
jump to declaration java ides typically offer a jump to declaration feature for navigating from a field or method reference to its declaration.
in javascript there are no method declarations as such but several javascript ides offer a similar feature to navigate from a function call to the function or in general functions that may be invoked at this place.
our call graph algorithms could be used to implement such a feature.
the pessimistic algorithm seems to be particularly well suited since it gives a small set of targets for most call sites.
while no call target may be available for unresolved call sites this is arguably better than listing many spurious targets.
to test this hypothesis we measure the percentage of call sites with a single target excluding native functions.
the results along with the percentage of call sites with zero two 3dmodel beslimed coolclock flotr fullcalendar pacman htmledit markitup pdfjs pong0 callees callee callees callees calleesfig.
.
number of non native call targets per site with pessimistic analysis three and more than three targets are given in fig.
on all benchmarks more than of call sites have at most one target have at most two and at most three targets.
this suggests that the pessimistic algorithm could be useful for implementing jump to declaration.
the relatively large percentage of call sites without targets is due to excluding native call targets.
if they are included the pessimistic analysis is on average able to find at least one callee for more than of calls.
the maximum number of non native call targets is callees for a small number of sites onbeslimed if native targets are considered several call sites can have up to callees these are calls to tostring with of the suggested callees being dom methods.
we now compare our approach against three current javascript ides eclipse jsdt komodo ide and webstorm.
the eclipse jsdt plugin we tested version .
.
on eclipse .
.
provides a jump to declaration feature which does not seem to handle method calls severely limiting its practical usefulness across all our subject programs it can only find targets for about call sites less than .
komodo ide version .
.
uses fairly intricate heuristics to resolve function and method calls that works well on our smaller subject programs such as 3dmodel .
however it seems unable to handle larger framework based programs where its jump to declaration feature usually fails.webstorm version .
.
is closed source precluding examination of its implementation.
it seems to maintain a representation of variable and property assignments similar to our flow graph.
no transitive closure is computed hence jump to declaration only jumps to the most recent definition and it may take several jumps to find the actual callee.
webstorm has built in support for the most popular frameworks so it can understand commonly used metaprogramming patterns that foil our analyses.
however it performs no interprocedural reasoning at all not even for one shot closures so it is impossible to jump to the declaration of a callback function.
smell detection as an example of a more complicated client we implemented a simple tool for detecting global variables that are used like local variables suggesting a missing var declaration.
while this may not necessarily be a bug it is considered bad practice and makes code less robust.
we check whether all functions using a global variable x definitely assign to xbefore reading it.
additionally call graph information is used to check whether one function using xcan call another.
if so the functions might see each others updates tox indicating that it may not be possible to turn xinto a local variable without changing program behavior.
with pessimistic call graphs the tool suggests missing var declarations on our subject programs.
one of these is a false positive due to unsoundness but in all other cases the global variable could indeed be turned into a local.
with optimistic call graphs there are only true positives and the same false positive.
without interprocedural analysis the number of false positives rises to nine in all eight new cases the global variable is a flag that is indeed modified by a callee and hence cannot be made local highlighting the importance of interprocedural reasoning for this analysis.
bug finding we implemented a tool that looks for functions that are sometimes called using new but as normal functions at other times.
while there are functions that can be used either way this is often indicative of a bug.
using pessimistic call graphs the tool reports such functions.
one of these is a true positive indicating a bug in flotr four are true but harmless positives in jquery and nine are false positives due to imprecise call graph information.
using optimistic call graphs the number of false positives increases to with no additional true positives.
e. summary and threats to validity our evaluation shows that both call graph construction algorithms scale very well.
even though our current implementation is written in coffeescript and does not use highly optimized data structures it is able to build call graphs for substantial applications in a few seconds.
the faster pessimistic algorithm may be more suitable for ide use but further optimizations to the optimistic algorithm are certainly possible.
comparing against dynamic call graphs we found that the vast majority of dynamically observed call targets are predicted correctly by our analyses and on average the number of spurious call targets is low.
our analyses resolve most call sites to at most one callee up to on some programs and compute no more than three possible targets for almost all sites.
the only extreme outliers are calls to tostring which have more than callees due to our field based approach.
an informal comparison of our analyses with existing ides suggests that the pessimistic analysis outperforms most of them while the optimistic analysis can handle cases that exceed the capabilities of all surveyed tools.
we also discussed two examples of analysis tools that need call graphs.
while these tools could be useful for developers they did not find many bugs on our subject programs which seem quite mature.
finally we discuss threats to the validity of our evaluation.
first our subject programs may not be representative of other javascript code.
we only consider browser based applications so it is possible that our results do not carry over to other kinds of javascript programs.
most of our subject programs use jquery with only two programs using other frameworks.
we have shown that our approaches perform particularly well on jquery based and framework less applications and slightly less so on other frameworks.
on the other hand recent data suggests that less than of websites use a framework other than jquery so our approach should be applicable to most real world browser based javascript code.
second our accuracy measurements are relative to an incomplete dynamic call graph not a sound static call graph.
hence the recall should be understood as an upper bound i.e.
recall on a more complete call graph could be lower whereas precision is a lower bound i.e.
precision could be higher .
given the difficulty of scaling sound call graph algorithms to realistic programs dynamic call graphs are the best data we can compare ourselves against at the moment.
moreover the relatively high function coverage of the dynamic call graphs suggests that they are representative of the entire programs.
v. r elated work existing flow analyses for javascript generally do not scale to framework based programs.
some of them such as gatekeeper do not reason statically about dynamic property accesses just like our analysis.
gatekeeper recovers soundness however by performing additional runtime instrumentation.
all these systems track general object flow and use a more precise heap model than we do.
recently madsen et al.
presented an analysis that sidesteps the problem of analyzing complex framework code and modeling native apis by inferring their behavior from uses in client code .
our approach is scalable enough to directly analyze frameworks and since we only track functions and do not reason about reachability no elaborate models for native code seem to be necessary.
we could however adopt their approach in cases where such modeling becomes important.
wei and ryder propose a combined static dynamic taint analysis of javascript programs.
in their work a number of traces is collected that contain information about method calls and object creation.
this information is used to assist a static taint analysis with the construction of a call graph that includes code that is executed as the result of calls to eval and excludes code in uncovered branches.
in addition thenumber of arguments supplied to methods calls is captured and used to counter some of the loss of precision due to function variadicity by creating multiple distinct nodes in the call graph for certain methods.
like ours their analysis is unsound but it is likely to be less scalable than ours because of its reliance on a traditional static pointer analysis.
an in depth comparison of cost and accuracy of the two approaches is future work.
agesen et al.
presented a number of type inference techniques for self a language with many similarities to javascript.
they essentially compute highly context sensitive flow graphs from which call graphs could be extracted to statically prove the absence of message not understood errors where a method is not found on the receiver object or its prototypes.
our technique cannot do such reasoning since it does not track the flow of most objects.
tracking general object flow for javascript leads to scalability and precision issues due to heavy usage of reflective idioms that seem not to be as frequently used in self.
grove and chambers present a general framework for call graph construction algorithms.
our analysis does not fit directly in their framework since they do not discuss prototypebased languages but roughly speaking our analysis can be viewed as a variant of cfa where only function values are tracked field accesses are treated as accesses to correspondingly named global variables and all code is assumed to be reachable.
our key contribution is in showing that such an analysis works well for javascript in practice.
previous work has studied the effectiveness of field based flow analysis for c and java .
they exploit static type information to distinguish identically named fields of different struct class types which is impossible in javascript.
vi.
c onclusions we have presented a fast practical flow analysis based approach to call graph construction for javascript.
our analysis i is field based i.e.
identically named properties of different objects are not distinguished ii only tracks function values ignoring the flow of other objects and iii ignores dynamic property reads and writes.
we have proposed two variants of this analysis a pessimistic variant that makes conservative assumptions about interprocedural flow and an optimistic variant that iteratively builds an interprocedural flow graph.
both analyses scale extremely well and can handle far larger programs than any other static analysis for javascript that we are aware of.
while unsound in theory they produce fairly complete call graphs in practice.
these properties make our approach well suited for use in an ide.
in such a setting it would be wasteful to build a call graph from scratch every time it is needed since large parts of the program typically remain unchanged.
instead flow graphs could be precomputed and cached on a per file basis and then combined into a graph for the whole program when needed.
as future work we plan to apply our approach in other settings besides ides such as taint analysis .
here soundness is much more important so we need to handle dynamic property accesses.
conservatively treating them as potentiallyaccessing all properties will in general result in too much imprecision so some form of string analysis for reasoning about property names is likely needed.
introducing this and other features such as tracking of non function objects into our analysis while still keeping it scalable is an interesting challenge which could provide valuable insights into the cost and benefit of different analysis features for javascript.