interface decomposition for service compositions domenico bianculli dimitra giannakopoulou corina s. p as areanu faculty of informatics nasa ames research center and university of lugano carnegie mellon silicon valley lugano switzerland moffett field ca usa domenico.bianculli usi.ch dimitra.giannakopoulou corina.s.pasareanu nasa.gov abstract service based applications can be realized by composing existing services into new added value composite services.
the external services with which a service composition interacts are usually known by means of their syntactical interface.
however an interface providing more information such as a behavioral speci cation could be more useful to a service integrator for assessing that a certain external service can contribute to ful ll the functional requirements of the composite application.
given the requirements speci cation of a composite service we present a technique for obtaining the behavioral interfaces in the form of labeled transition systems of the external services by decomposing the global interface speci cation that characterizes the environment of the service composition.
the generated interfaces guarantee that the service composition ful lls its requirements during the execution.
our approach has been implemented in the ltsa tool and has been applied to two case studies.
categories and subject descriptors d. .
requirements speci cations d. .
software program veri cation f. .
speci cation techniques h. .
information storage and retrieval online information services web based services general terms veri cation keywords behavioral interface interface decomposition services service compositions this work was carried out while the author was an intern at mission critical technologies inc. on site at nasa ames research center.
copyright association for computing machinery.
acm acknowledges that this contribution was authored or co authored by a contractor or affiliate of the u.s. government.
as such the government retains a nonexclusive royalty free right to publish or reproduce this article or to allow others to do so for government purposes only.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction service oriented computing is a paradigm that promotes the construction of software applications by means of basic components called services which make available a speci c functionality through a set of operations accessible over a network infrastructure.
software engineers use composition mechanisms such as bpel orchestrations to assemble complex added value services called service compositions out of existing services possibly o ered by thirdparty providers and thus called external orpartner services .
in previous work some of the authors emphasized the need for achieving continuous lifelong veri cation for this new class of software which belongs to the realm of openworld software .
they proposed a methodology providing an integrated approach for design time and run time veri cation with an assume guarantee avor and they showed how to realize continuous lifelong veri cation by adopting a veri cation oriented life cycle .
at the basis of these proposals there is the de nition of a set of correctness properties that the service composition should manifest.
these properties usually depend on a certain behavior or on some quality of service attributes of the external services with which the composite service interacts.
the aforementioned work made the working assumption that behavioral descriptions were available for the external services interacting with a composite service.
these descriptions were then used as assumptions for performing the assume guarantee style model checking of the service composition behavior and as models to synthesize run time monitors.
however in the dynamic and evolvable settings that characterize open world software it is unrealistic to assume the availability of the interface descriptions of third party services.
in general service providers make available to service integrators only the syntactical interface of the services they provide.
it is then clear that an automated technique for deriving from the requirements speci cation of a composite service the required interface of its partner services could improve the process followed by service integrators to assemble service compositions.
in this paper we focus on the automatic generation of the behavioral interfaces of the partner services by decomposingthe requirements speci cation of a service composition.
our technique generates behavioral interfaces that constitute required speci cations for the partner services these speci cations guarantee that the composite service will ful ll its required safety properties at run time while it interacts with the external services.
since we assume that the behav ioral descriptions of external services are not available our technique is based on the purely syntactical knowledge of their interfaces.
in particular the speci c contributions of the paper are i the formulation of the interface decomposition problem for service compositions ii a sound heuristicbased technique for decomposing the global interface specication of the environment into the behavioral interfaces in the form of labeled transition systems ltss of the individual partner services iii the implementation of this technique in the ltsa tool and its application to two case studies.
once the behavioral speci cations of the external services have been inferred they can serve multiple purposes.
for example they can be used with semi automatic composition mechanisms for selecting the services that ful ll in the best way the functional requirements of the composite service.
moreover they can become clauses of the service level agreements slas negotiated with service providers.
furthermore they can be translated into veri able run time assertions which can be monitored while the system is operating to check if the external services behave as expected i.e.
to check if the service providers meet the obligations they signed in the slas.
the rest of this paper is structured as follows.
section provides background material on ltss.
section introduces the running example used to show how our approach works.
section presents our formal models for service compositions and their interface speci cation.
section presents the interface decomposition problem illustrates our technique to solve it and shows its correctness.
section discusses the application of our approach to two case studies.
section reviews the related work and section concludes the paper outlining future research directions.
.
preliminaries we use labeled transition systems ltss to model the behavior of service compositions the global speci cations of the environment with which a composite service interacts and the behavioral interfaces of the individual services.
in the rest of this section we formally de ne ltss and the operations that can be performed over them.
labeled transition systems letactbe the universal set of observable actions and let denote an internal action that cannot be observed by the environment of a component.
let denote a special error state which models safety violations in the associated transition system.
a labeled transition system mis a tuplehq a q 0iwhereqis a nite non empty set of states a m f g with m actis the actions alphabet q a qis a transition relation q02q is the initial state.
moreover let denote a special lts hf g act ?
i. an ltsm hq a q 0iisnon deterministic if it contains transitions or if q a q0 q a q00 such that q06 q00.
otherwise misdeterministic .
an lts is complete if in each state a transition is dened upon each action of the alphabet more formally m hq m f g q 0iis complete iff8q2q 8a2 m 9q02 qj q a q0 .
if an lts mis not complete it can be completed with a sink state and the transitions leading to it the resulting lts is denoted as m. formally given an lts m hq m f g q 0i its complete by construction variant is m hq f qg m f g q0i where m m f q a q ja2 mg f q a q ja2 m 9q02qj q a q0 g. for an lts m hq a q 0i there is a path from state qto stateq0 withq q02q if there exists a set of states fq1 qng qand a sequence of actions ha1 an 1i with eachai2a such thatq q1 q0 qn 8i i n qi ai qi .
the sequence of actions ha1 an 1i where the transitions are ignored is called the trace dened by the path .
a trace of an lts mis a trace de ned by a path that originates in the initial state i.e.
it is a nite sequence of observable actions that label the transitions that mcan perform starting at its initial state.
the set of traces of mis denoted as tr m .
for an lts m errtr m tr m is the set of traces ft2tr m j 9a path fromq0to andtis de ned by g errtr m is called the set of error traces ofm.
furthermore given a tracetand a seta act the expression t a denotes the trace obtained from tby removing all occurrences of actionsa62a is the restriction operator for traces.
in some cases it might be useful to explicitly indicate that an lts has the error state reachable from the initial state.
for an lts m hq a q 0i we use the notation m iff 2qand errtr m ?.
this notation can be combined with the one denoting the completion by construction as in m to identify an lts that is complete and that contains the error state reachable from the initial state .
operators letm hq a q 0iandm0 hq0 a0 q0 0i withq0 .
mtransits intom0with action a denotedma !m0 if q0 a q0 withq q0 a a0 .
moreover we say that mtransits into with action a ma !
if q0 a .
the interface operator is used to make unobservable some actions of an lts.
given an lts m hq a q 0i and a set of observable actions a act m ais de ned as follows.
if m m a .
form6 m a hq m a f g q0 0i where 0is described by the rules shown in fig.
1a.
the semantics of this operator ensures that errtr m ?ifferrtr m a ?.
two ltss can be combined by means of the parallel composition k operator which is commutative and associative.
given two ltss m1 q1 a1 q1 andm2 q2 a2 q2 the parallel composition m1km2is de ned as follows.
if either m1 orm2 thenm1km2 .
otherwise m1km2is an lts m hq a q 0iwhere q q1 q2 q0 q1 q2 a a1 a2and is described by the rules shown in fig.
1b.
the traces of a parallel composition are de ned as follows tr m1km2 ftj t m tr m1 t m 2tr m2 t2 m m g. as for error traces a parallel composition has an error trace if at least one of its components has an error trace.
in symbols errtr m1km2 ft2tr m1km2 j t m errtr m1 t m 2errtr m2 g. safety properties a safety property can be speci ed as a deterministic lts that contains no state.
the set of traces tr p of a propertypde nes the set of acceptable behaviors over p. an ltsmsatis esp denoted as mj pifftr m p tr p .
for a property lts pwe can de ne thema !m0 a2a m aa !m0 ama !m0 a62a m a !m0 a a rules for the interface operator m1a !m0 m1km2a !m0 1km2m2a !m0 m1km2a !m1km0 a62 m a62 m m1a !m0 m 2a !m0 m1km2a !m0 1km0 a2 m m b rules for the parallel composition operator figure rules for the lts operators error ltsperras follows given p hq p q 0i perr hq f g p err q0i where perr p f q a j q a 2q p 9q02qj q a q0 g. note that the error lts is complete by construction1.
letmbe an lts such that errtr m ?.
we detect possible violations of a property pby the component mby computing mkperr.
as shown in the execution of m leads to a violation of a property pifferrtr mkperr ?
i.e.
iff the state is reachable in mkperr.
.
example our running example is a simpli ed version of the car rental agency one presented in we call it simple car rental scr .
the example illustrates a service composition that is run at a car rental o ce branch.
the composite service interacts with a car broker cb service which controls the operations of the branch with a user interaction ui service through which customers can make car rental requests with a car information ci service which maintains a database of cars availability and allocates cars to customers with a car parking sensor cps service which exposes as a service the sensor that senses cars as they are driven in or out of the parking lot of the branch.
the workow of the composite service is sketched in fig.
using the notation presented in boxes with a right arrow correspond to onmessage events while the ones with two opposite arrows indicate an invoke activity.
the scr service starts when it receives the startrental message from the cbservice.
it then enters an in nite loop at each iteration it can receive one of the following messages findcar .
a customer requests to rent a car the scr service checks the availability of a car by invoking the lookupcar operation on the ciservice.
the lookupcaroperation returns its result which can be either a negative answer or an identi er corresponding to the digital key to access the car in the result variable which is then passed as parameter to the findcarcb operation a callback invoked on the uiservice.
carenter and carexit .
these two messages are sent out by the cps service when a car enters respectively 1since an error lts models a safety property violation it is customary not to include self loops for which are implied.
onmessageonmessageonmessageonmessage carinformationservice car parking sensorservice carbrokerservice userinteractionservicestartrental markcaravailablemarkcarunavailablestoprentallookupcarfindcarstoprentalcarentercarexit findcarcbfigure the simple car rental example exits the parking lot.
the process reacts to this information by updating the cars database invoking respectively the markavailable and markunavailable operations on the ciservice.
stoprental .
the cbservice stops the operations of the branch terminating also the composite service.
to keep the example compact we assume that a single car is available in the branch and that the ciservice is accessed only by the scr service instance running in the branch.
the correct execution of the scr service depends on the functionalities provided by the ciandcps services.
therefore in the next two sections we show the application of our interface decomposition technique to derive the behavioral interfaces of these two services.
.
service composition and global interface specification models in this section we present the formal model of service compositions and describe how we can infer the global interface speci cation of the environment i.e.
the set of partner services with which a composite service interacts.
we refer the reader to fig.
for mapping symbols onto components.
.
service composition a service composition cinteracts with a set of external services denoted as e fe1 eng.
each service ei2 emakes available a set of operations oi foi oi mg which constitute its syntactical interface.
we assume that 8i j i n i j n oi oj ?
since each operation can be unambiguously identi ed by its name combined with the name of the service it belongs to e.g.
by means of the interface andservice elements of a wsdl .
description .
we assume that service compositions are implemented as bpel processes which can be formalized in terms of labeled transition systems as shown in with tools such as ws engineer .
for a service c letmcbe the corresponding lts.
the safety requirements on the behavior of the composite servicec when it interacts with the external services e can be modeled by a property lts p. this lts can be synthesized for example from a speci cation in a temporal logic formalism such as ltl or fluent ltl .
note that the property pimplicitly de nes the unwanted behaviors by means of the corresponding error lts perr.modeling the running example in the example we are interested in the environment constituted by the services ciandcps so we have e fci cpsg oci fmarkavailable markunavailable lookupcargand ocps fcarenter carexitg.
in the rest of this paper we use the fsp textual notation to compactly represent lts models.
in fsp identi ers beginning with a lowercase letter denote actions while identi ers beginning with an uppercase letter denote processes states in the underlying lts the symbol denotes the action pre x operator while the vertical bar denotes the choice operator.
the following code snippet corresponds to the lts model of the scr service range key .. means car not available scr startrental main main findcar lookupcar findcarcb main carexit markunavailable main carenter markavailable main stoprental end .
note that each operation invoked on the scr service and on its partner services is modeled as an action.
moreover since the variable result ranges over the domain key the lookupcar action is internally represented as lookupcar and lookupcar the same applies to findcarcb .
service behavior the expected behavior of the scr service is expressed by the following requirement if the car enters the parking lot and it does not exit until a customer requests it for renting then this request should not return a negative answer.
this requirement can be formalized in fluent ltl as the formula g carin where carin is a uent that changes value when the car is in the parking lot and it is de ned as carin hcarenter carexitiinitially false is the auxiliary formula findcar findcarcb wfindcarcb .
here gand ware respectively the ltl temporal operators globally and weak until .
this fluent ltl formula represents a safety property and thus can be translated automatically into an error lts model whose textual description is shown below perr q0 q0 carexit findcar findcarcb q0 carenter q1 q1 carexit q0 carenter findcarcb q1 findcar q2 q2 findcarcb error findcarcb q1 carenter findcar q2 carexit q3 q3 findcarcb error findcarcb q1 carenter q2 carexit findcar q3 .
.
global interface specification in this work we want to characterize the global expectations from ein order for cto ful ll its requirement p i.e.
we want to infer the global interface speci cation of the environment ewith which cinteracts.
by following the technique introduced in and summarized below we can i operationo11operationo1ioperationo1moperationoi1operationoiioperationoimoperationon1operationonioperationonmserviceenserviceeiservicee1 o1oionbaperrq0q1 i1 ii in decompositione mccompositeservicecpropertypfigure notation and general model of the service interface decomposition problem determine the global interface speci cation by computing the lts i with i buildinterface mckperr o whereo sjej i 1oi.
the pseudo code of function buildinterface is shown in fig.
.
the function receives as rst parameter an lts model the actual parameter that is passed mckperr contains all the traces that violate the property p. the actual value of the second parameter actions is the set of all the operations provided by the external services and is used on line as an operand of the interface operator to get the lts named geninterface .
this lts is further processed with a special determinization step line provided internally by ltsa.
this determinization step performs elimination and subset construction but unlike standard automata theory algorithms it handles in a special way the state.
since during the subset construction the states of the deterministic lts correspond to set of states of the original nondeterministic lts if any of the states in the set is then the entire set becomes a state in the deterministic lts.
this means that a trace that non deterministically may or may not lead to the error state has to be considered an error trace.
in practical terms it means that performing a certain sequence of actions on the external services does not guarantee that the service composition will not reach an error state.
subsequently the lts geninterface is completed line with a sink state and the transitions leading to it by invoking an auxiliary function.
the missing transitions in the original lts represent behaviors of the external services that are never exercised by the service composition with the completion they are made sink behaviors and thus no restriction is imposed on them.
function buildinterface model actions geninterface model actions determinize geninterface completewithsinkstate geninterface return geninterface figure pseudo code of the buildinterface functionthe notation used for the resulting lts i denotes that it contains the error state deriving from the error lts perr and that it has been completed with a sink state.
hereafter we use the notation ito refer to the variant of i that does not contain the error state without the transitions leading to it.
in symbols given i hq f g i q 0i i hq i q0i where i i nf q a ja2 i g. application to the running example the rst parameter passed to the buildinterface function is scr perr .
as for the second parameter the list of actions passed to the function is composed by markavailable markunavailable lookupcar and lookupcar from ci and by carenter and carexit from cps .
the resulting interface i is de ned as follows ipi q0 q0 lookupcar q0 carexit q1 carenter q2 markunavailable markavailable sink q1 markunavailable q0 carexit carenter markavailable lookupcar sink q2 markavailable q3 carexit carenter markunavailable lookupcar sink q3 lookupcar error carexit q1 carenter q2 lookupcar q3 markunavailable markavailable sink sink carexit carenter markunavailable markavailable lookupcar sink .
.
decomposing interface specifications the method described in section .
computes the global interface speci cation of a service composition i.e.
the behavior that its partner services considered as a whole should manifest in order for the composite service to ful ll its requirements speci cation.
however this centralized solution is not realistic for the domain of service based applications since each service is operated independently by its own provider and has no knowledge of the other services with which its client service i.e.
a composite service interacts.
therefore we argue it is necessary to de ne a more distributed approach which generates the individual behavioral interfaces for the partner services.
to this end we de ne the interface decomposition problem as follows refer to fig.
for mapping symbols onto components given a service composition c which interacts with a set of external services e fe1 engwhose behavior as a whole is represented by i we decompose i into interface speci cations for the individual partner services denoted as ii i jej.
the individual interface speci cations obtained by means of the interface decomposition technique should guarantee that the composite service ful lls its requirement speci cation.
this correctness requirement can be formally stated as fjej i 1ii kmcj p.in the rest of this section we illustrate our technique for decomposing interface speci cations and show its application to the running example.
we rst present a basic approach to the problem and observe that it generates over constraining interfaces.
subsequently we propose our heuristic based technique which generates less constraining but still correct behavioral interfaces.
we conclude by discussing some approaches for the validation of the decomposition technique as well as its shortcomings.
.
basic decomposition approach a rst approach to the problem of interface decomposition can be based on the intuition that each external service can contribute to the global interface speci cation only through the operations that it provides.
formally this means the interface speci cation ii of an external service eican be computed as ii buildinterface i oi .
note that ii contains the error state as done for the case of the global interface speci cation we use the notation ii to refer to the variant of ii that contains neither the error state nor the transitions leading to it.
however simple experimentation with this technique reveals that such an approach generates interfaces that are too restrictive.
for example its application to the running example generates the following interface speci cations.
for the ciservice we restrict the global interface speci cation over the alphabet fmarkunavailable markavailable lookupcar lookupcar g. the resulting lts is ci q0 q0 lookupcar markunavailable q0 markavailable q1 q1 lookupcar error markunavailable q0 lookupcar markavailable q1 .
it states that after a markavailable operation when the computation is in state q1 the lookupcar operation will return successfully i.e.
a value di erent from .
essentially state q1denotes the fact that the car is in the parking lot.
as for the cps service the global interface speci cation is restricted over the alphabet fcarenter carexitg.
the resulting lts is cps q0 q0 carenter error carexit q0 .
this interface is too restrictive since it disallows a car from ever entering the parking lot.
furthermore considering that according to the de nition of the uent carin in section the car is initially out of the parking this interface in practice blocks any behavior from the car.
in fact we can make a stronger observation about the individual interfaces built in this way proposition .let ii buildinterface i oi and i0 i buildinterface mckperr oi .
then ii and i0 i are isomorphic.
proof.
by construction function buildinterface generates a canonical deterministic lts whose error traces are equal to the error traces of its rst argument projected to the alphabet represented by its second argument .
since i buildinterface mckperr o it followsthat errtr i errtr mckperr o .
in a similar way errtr ii errtr i oi .
from these two statements we derive that errtr ii errtr mckperr o oi .
sinceoi o we conclude that errtr ii errtr mck perr oi .
additionally i0 i buildinterface mck perr oi implies that errtr i0 i errtr mckperr oi .
since the error traces of ii and i0 i are equal we conclude that the canonical representations ii and i0 i generated by function buildinterface are isomorphic and therefore so are iiand ii0.
as a result each interface that we compute in this fashion is su cient by itself to guarantee the global property on the system meaning that 8i iikmc j p which implies that fjej i ii kmcj p. however imposing such interfaces would be overly constraining.
moreover a solution that assigns the entire responsibility for achieving the global property to every single service is not desirable.
ideally we would like a solution that distributes the responsibility to the partner services in a way that allows as much participation from each service as possible in the behavior of the service composition.
to this end in the next section we propose a heuristic that avoids to unnecessarily constrain the interface of partner services that cannot lead to error behaviors of the system.
.
heuristic based decomposition technique the heuristic we propose to use is based on inspecting the actions that label the transitions that lead to the error state in the global interface speci cation.
it may be the case that none of these actions corresponds to one of the operations provided by the partner service hereafter referred to as ei for which we want to compute the behavioral interface.
this means that service eiwill never cause an error behavior in the system constituted by the composite service and its partner services.
in this case the behavioral interface of eican be obtained by decomposing a simpli ed model of the global interface speci cation which does not include the error behaviors that are not directly ascribable to ei.
more formally for a service eiwith actions oi given a global interface speci cation i hq i q oi the heuristic builds an auxiliary global interface speci cation denoted withiheu i .
this heuristic based auxiliary global interface speci cation is computed as iheu i hq i qoi where nf q a ja62oig.
the de nition of 0shows that the heuristic removes the transitions to the error state labeled with actions operations not provided by ei.
note that as a result of removing such transitions iheu i may not be complete note also the error state may be removed in case the error transitions were ascribable only to the other services di erent from ei.
the interface speci cation of the serviceei denoted with ii can then be computed as ii buildinterface iheu i oi .
correctness before showing that this technique is a correct solution of the interface decomposition problem we introduce and prove some helper propositions.
proposition .given i and ii de ned as above the relation errtr fjej i ii errtr i holds.proof.
the proof is by contradiction.
suppose there is a tracet such thatt2errtr i and thatt62errtr fjej i ii .
letabe the last action in t and q a q0 the corresponding transition that leads to the error state in i .
since there must exist a ksuch thata2ok we know that transition q a q0 will not be removed from iheu k .
from the semantics of the interface operator we can then conclude that t ok 2errtr ik .
since for all i ii is complete we also know that t2tr fjej i ii .
but since tleads to the error state with at least one component of this we conclude thatt2errtr fjej i ii which is a contradiction.
proposition .given iand iide ned as above the relation tr fjej i ii tr i holds.
proof.
consider the set oof all the operations made available by the external services let o represent its kleene closure.
similarly let oi be the kleene closure of the set of operations provided by an individual external serviceei.
by construction iis obtained from i by removing the error state and the transitions leading to it.
hence since no trace of the iinterface leads to the error state we know that tr i o nerrtr i similarly 8i i jej tr ii oi nerrtr ii .
moreover we know that a composite process has an error trace if at least one of its constituent processes has an error trace.
in symbols errtr fjej i ii n t2tr fjej i ii j t o1 2errtr i1 t o2 2errtr i2 t ojej 2errtr ijej o .
hence o nerrtr fjej i ii n t2tr fjej i ii j t o1 62errtr i1 t ojej 62errtr ijej o n t2tr fjej i ii j t o1 o1 nerrtr i1 t ojej ojej nerrtr ijej o n t2tr fjej i ii j t o1 2tr i1 t ojej 2tr ijej o tr fjej i ii .
since errtr fjej i ii errtr i holds from proposition o nerrtr fjej i ii o nerrtr i also holds.
hence tr fjej i ii tr i .
we can now show the correctness of our heuristic based decomposition technique by stating and proving the following proposition.
proposition correctness .
given the model of a service composition mcand the speci cation of its desired behaviorpwhen interacting with a set of external services e the interfaces of the individual external services ii i jej when computed applying the aforementioned heuristic satisfy the following relation fjej i ii kmcj p. proof.
from we know ikmcj p. furthermore from proposition fjej i ii j i. it follows that fjej i ii kmcj p.application to the running example by analyzing the global interface speci cation ipishowed in section .
we notice that the error state can be reached by executing in state q3 the transition labeled with lookupcar which is an operation provided by the ciservice.
the heuristic described above can then be applied to compute the interface for the cps service.
we rst create a re ned model of the global interface by removing the transitions that lead to the error state and that are not labeled with actions belonging to the alphabet of the cps service ipi cps q0 q0 lookupcar q0 carexit q1 carenter q2 markunavailable markavailable sink q1 markunavailable q0 carexit carenter markavailable lookupcar sink q2 markavailable q3 carexit carenter markunavailable lookupcar sink q3 carexit q1 carenter q2 lookupcar q3 markunavailable markavailable sink sink carexit carenter markunavailable markavailable lookupcar sink .
next the global interface speci cation is restricted over the alphabetfcarenter carexitg the resulting lts is cps q0 q0 carenter carexit q0 .
as expected this new interface obtained for the cps service with the application of the heuristic allows for more behaviors than the one computed with the basic technique.
more speci cally in this case the interface represents the universal interface of service cps i.e.
the interface that allows any of its operations.
since the error behaviors of the system are prevented by the interface of the other service ci there is no need to constrain the interface of cps.
as for the interface speci cation of service ci the application of the heuristic does not a ect its generation i.e.
it coincides with the one shown in section .
.
.
discussion validation of the generated interfaces although the de nition of the interface decomposition problem includes a correctness requirement which guarantees that the generated interfaces will not lead the system into the error state this is not enough to characterize the quality of the generated interfaces.
ideally they should be validated by using some kind of oracle such as descriptions of good and bad behaviors usually de ned by domain experts or encoded in a certain model.
for example assuming the availability of the implementation of a partner service ei we could check if eij ii where iiis derived from ii which is the interface speci cation computed for ei.
this check can be performed with a modelchecker such as javapathfinder for java based implementations or ws engineer for services implemented in bpel.
however this approach may rarely be feasible in the realm of services since usually the implementations of the external services are not publicly available.
violations identi ed during such checks may signify either that a partner service is not appropriate for the desired composition or that the interface generated may need to be re ned.
a domain expert would therefore need to inspect violations and decide on a course of action.
domain expertise can also be used to validate directly the generated interfaces to assess if they are either too strict or too weak by analyzing the allowed or disallowed behaviors.
in this sense in section .
we used our domain knowledge to informally claim that the interface generated for the cps service was too restrictive.
speci c to the interface decomposition problem is to check if some behaviors originally allowed by the global interface speci cation are lost by the decomposition process.
the lost behaviors can be discovered by checking the following relation tr i tr fjej i ii .
this check can be performed with a model checker such as ltsa.
we expect this relation to not always hold since some behaviors will be lost as said above.
however when the check does not hold the user can iteratively inspect each counterexample to discriminate if it represents a sink behavior which cannot be realized in the actual system and thus can be ignored or if it is actually a missing behavior which can then be added to the interface speci cation which is thus re ned.
limitations of the heuristic in our running example the interfaces we obtained for the partner services were satisfactory however our experimentation has shown that this may not always be the case.
for example consider an environment consisting of two services e1ande2 withe1providing operation c ande2 providing operations aand b. assume the following lts model represents the global interface s0 c s0 b s1 a s2 s1 a s0 b s1 c s1 s2 c error b s0 a s2 .
by decomposing this interface to compute i1and i2 we notice that our heuristic blocks e1completely no operation can be performed on it while generates the universal interface fore2.
more generally our heuristic may block some good behaviors of the individual services which instead could be safely allowed.
this may happen because an operation of a service that directly leads to the error state which is the one considered by our heuristic may be actually triggered by an operation of another service.
in the example above the transition c error is actually performed only after the transition a s2 occurs another heuristic could then allowe1to perform c while the interface of e2could mandate the execution of band ain this order.
.
ev aluation the interface speci cations decomposition technique has been implemented in the ltsa tool here we report about the evaluation of our approach on two case studies.
each case study consisted of a service composition in the formof a bpel process of the syntactical interfaces wsdl description of the partner services of the composition and of an informal description of the requirements that the composition had to ful ll.
the bpel processes have been translated into the input format of the ltsa tool by means of ws engineer the requirements have been rst formalized in a temporal logic and then translated into an lts description.
the experiments have been executed on a computer running apple mac os x .
.
with a ghz intel core duo processor and gib of memory.
.
car rental full version this case study is the fulledged version of the example described in section with which it also shares the same requirements speci cation.
the main di erence lies in a ne grained description of the bpel process which leads to more re ned and sometimes verbose interface descriptions.
for example the two single transitions lookupcar that in the running example correspond to invoking the lookupcar operation of the ciservice and receiving as output parameter either or are expanded in a sequence of four operations hcr ci invoke lookupcar cr ci receive lookupcar cr ckr.condition.read.false cr ckr.condition.read.true i. if we consider this kind of expansion we easily conclude that the interfaces generated are equivalent to but bigger in term of size of the model than the ones built obtained for the running example.
for example the interface of the ciservice is the following cis q0 q0 cr ci invoke markcarunavailable q0 cr ci invoke lookupcar q2 cr ci invoke markcaravailable q3 q2 cr ci receive lookupcar q4 q3 cr ci invoke markcarunavailable q0 cr ci invoke markcaravailable q3 cr ci invoke lookupcar q5 q4 cr ckr.condition.read.
false true q0 q5 cr ci receive lookupcar q6 q6 cr ckr.condition.read.false error cr ckr.condition.read.true q3 .
the interface of the cps service as before remains the universal interface.
in this example the lts model of the service composition contains states and transitions the global interface speci cation contains states and transitions and was built in ms the interface speci cations of the services ci and cps were built respectively in ms and ms. validation against original specifications the original example de nition contained a set of logical speci cations of the behavior expected from the external services manually written by the authors of the paper.
we consider these speci cations as a possible oracle for evaluating how well our technique performs and thus we compared these speci cations with the ones generated by the tool.
the speci cation of the ciservice was if the car is marked as available in the ci service and the car is not marked as unavailable until a lookupcar operation is invoked then the lookupcar operation should return successfully .
it is clear that this behavior is captured by the interface speci cation generated for the ciservice.for the cps service the speci cation was between two events signaling that the car exits the parking lot an event signaling the entrance for the same car must occur basically it states the two events car enter and car exit should alternate.
the interface speci cation obtained for this service however is the universal interface.
in our opinion this result is still correct even if less useful because the cps service cannot be responsible for violations of the expected requirement.
in ltsa we have also implemented the possibility to search for and analyze lost behaviors by checking tr i tr fjej i ii .
this check failed revealing one lost behavior whose trace is cr ci invoke markcaravailable cr ci invoke lookupcar cr ci receive lookupcar c r ckr.condition.read.false.
this trace can be interpreted as if the car is marked as available in the parking lot then a request for the car will return a negative result which is an incorrect behavior.
note that this behavior is disallowed by the structure of the composite service since cr ci invoke markcaravailable will never be executed as the rst action.
therefore we can safely state that this behavior has been added to the global interface speci cation through the completion with the sink state it will never occur in the real system.
this is the reason for which it is also missing from the interfaces derived for the partner services.
.
order booking this case study has been taken from the sample processes distributed with the oracle soa suite 10gr3.
it consists of a process that is started when a customer places an order from a client web application.
the process rst inserts the order information in a database through the erpservice then it retrieves customer information by invoking the customerservice .
the process checks the customer s credit card by invoking the creditservice and then determines if the order requires manual approval by invoking the decisionservice ds which applies some business rules that take into account the status platinum or not of the customer.
for orders that require manual approval the process invokes the requiresapproval operation on the manager web service.
when an order is approved the process requests in parallel quotes from the suppliers selectmanufacturer and rapidservice and then selects the supplier that responded with the lower quote.
afterwards a shipping method is chosen by checking the amount of the order.
after updating the order status on the database through the erpservice the project sends a con rmation email to the customer by invoking the emailservice and then terminates.
a possible requirement speci cations for this composite service is if a platinum customer places an order it must be automatically approved otherwise it must be approved manually .
this speci cation indirectly requires a certain behavior of the dsservice which we picked as the service for which to compute the interface speci cation.
we translated this speci cation into a property lts and then applied the interface decomposition method based on the heuristic to obtain the interface for the dsservice.
we omit its textual representation for space reasons but in essence it states that if a platinum customer places an order then the return value will not be manual approval and equivalently if a non platinum customer places an order then the return value will not be automatic approval .this speci cation matches the one informally described in the documentation of the example.
since we were not interested in getting an individual interface speci cation for each of the other partner services we generated an interface for them when considered as a whole and as expected we obtained the universal interface.
the lts model of the composite service contains states and transitions the global interface speci cation contains states and transitions and was built in ms the interface speci cation of the dsservice contains states and transitions and was built in ms. the interface for the rest of the components contains only one state allowing all possible behaviors i.e.
it encodes the universal environment .
a search for lost behaviors reveals two behaviors which a manual inspection shows to be sink.
.
related work this work is closely related to the problem of synthesizing individual service behaviors from a choreography specication such as conversation protocols ws cdl models and collaboration diagrams .
these works de ne aprojection operation that derives the implementations of the participating peers by ltering the global speci cation on the actions alphabet of each peer which is similar in spirit to the basic decomposition approach described in section .
additionally in extra communication actions among the generated peers are added in case some behaviors may not be realizable in a distributed fashion.
the di erence with our work lies in the point of view adopted the aforementioned works consider a superset of the possible behaviors and narrow it down to achieve the exact behavior dictated by the choreography speci cation.
in our work we view the global interface as the maximum behavior that could be allowed for the composition based on a property and we generate a subset of the possible behaviors.
our process is driven by the error behaviors that have to be blocked error traces guide us in the heuristic to assign to partner services the responsibility of blocking those behaviors.
still related to the synthesis problem reference shows in the context of veri cation of choreographies expressed in bpel4chor how a single participant of a choreography can be synthesized starting from the description of the choreography and from the bpel models of the other participants.
besides the limitation of synthesizing at most one participant this work makes the assumption that the bpel models of the other participants are available this assumption is unrealistic in the context of open world services.
the problem of generating the interface of the environment of a system given a property it should satisfy has been originally dealt with in in the context of model checking.
however the approach generates only the global interface not the interfaces of the individual components of the system.
other work describes a compositional reasoning approach for the veri cation of middleware based software architecture descriptions.
given a graphical scenario of the architecture of a generic application in terms of message sequence charts mscs the approach tries to verify the global property by verifying local properties of the architectural components.
this last step requires to decompose the global property into local properties the decomposition is based on the analysis of the structure of the mscs which is similar to our heuristic that considers the structure of the global interface speci cation.the use of a description of the system requirements to generate behavioral models of the system components is also common in the context of behavioral model synthesis.
one approach proposes to inductively synthesize the lts models of each system component from a set of endusers scenarios both positive and negative in the form of mscs.
the approach operates at the stage of requirements where users can interactively re ne the scenario based description by answering questions in our work we assume the requirements are xed and thus rely on the accuracy of the speci cation to get expressive interfaces.
the approach presented in derives operational requirements in the form of pre and trigger conditions from goal models using a combination of model checking inductive learning and manual elaboration of scenarios however the approach does not support learning the operational requirements for an individual component of a system.
in behavioral models in the form of modal transition systems are generated at the component level from a set of scenarios and property speci cations.
the algorithm assumes that domain variables are used for de ning the pre and post conditions of component operations however for service components pre and post conditions are usually not available.
another technique constructs behavioral models in the form of modal transition systems from both safety properties and scenario based speci cations however the models generated are at the system level not at the component level.
while the main motivation behind this work is to decompose a global speci cation of a system to obtain the individual speci cations of the system components which would otherwise be unknown other approaches perform decomposition of a global speci cation either to reduce the size of the model to verify as in with the application of slicing or to support compositional veri cation for systems that are not structured into parallel components .
inferring the speci cations of components is also a goal shared with program speci cation miners such as adabu and gk tail .
these approaches usually perform static analysis code instrumentation and analysis of the execution traces to derive the usage patterns of components and thus need to access the code of the components for which you want to discover the speci cation.
this latter step is not feasible in the domain of service oriented computing.
in the context of web services the strawberry approach derives the behavioral model of a service by analyzing its syntactical interface and applying a combination of graph synthesis heuristics and testing.
however all these approaches consider the behavior of a single service component in isolation while we are interested in discovering the behavioral interfaces of components that guarantee the requirements of the composite application.
the work in presents a generic theoretical assumeguarantee framework for adaptable systems that guarantees that adaptation related changes do not a ect the global invariant of the system.
it assumes the availability of existing techniques to perform assumptions generation and system and property decomposition.
the last one is a direction toward which this work can contribute.
.
conclusion and future work the correct behavior of a service composition with respect to its requirements speci cation depends on a certain expected behavior of its partner services.
however most ofthe times the behavioral descriptions of the partner services are unknown.
in this paper we have presented our novel technique to automatically generating the behavioral interfaces of the partner services of a service composition by decomposing the requirements speci cation of the composite services.
we have formalized this problem proposed a heuristic based technique to solve it implemented this technique in the ltsa tool and applied it to two case studies.
we plan to further develop and improve the technique presented in this paper.
first we will consider alternative heuristics to address the limitations of the current one.
for example we want to assess precisely to which extent a partner service contributes to ful ll or not the global requirements.
this is particularly important in the case in which multiple partner services have operations that could possibly lead to the error state.
secondly we will support the re nement of the generated speci cations by extending the analysis of the counterexamples to lter missing behaviors for example by performing behavior realizability analysis as suggested in .
last we will add support for timed property speci cations.