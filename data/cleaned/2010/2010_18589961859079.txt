search carrying code ali taleghani david r. cheriton school of computer science university of waterloo ontario canada ataleghani uwaterloo.cajoanne m. atlee david r. cheriton school of computer science university of waterloo ontario canada jmatlee uwaterloo.ca abstract in this paper we introduce a model checking based certification technique called search carrying code scc .
scc is an adaptation of the principles of proof carrying code in which program certification is reduced to checking a provided safety proof.
in scc program certification is an efficient re examination of a program s state space.
a code producer who offers a program for use provides a search script that encodes a search of the program s state space.
a code consumer who wants to certify that the program fits her needs uses the search script to direct how a model checker searches the program s state space.
basic scc achieves slight reductions in certification time but it can be optimized in two important ways.
when a program comes from a trusted source scc certification can forgo authenticating the provided search script and instead optimize for speed of certification.
the search script can be partitioned into multiple partial certification tasks of roughly equal size which can be performed in parallel.
using parallel model checking we reduce the certification times by a factor of up to n fornprocessors.
when certifying a program from a trusted source we reduce the certification times by a factor of up to n fornprocessors.
categories and subject descriptors d. .
software program verification model checking k. .
testing certification and licensing general terms verification keywords software certification model checking .
introduction component based software engineering promises rapid development and extension of systems through the assembly of pre existing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.and third party components.
however before a code consumer uses an acquired component in her software product she must certifythat the component fits her needs.
if a component comes from a non trusted source then the code consumer will want to check that the component is safe and performs as advertised.
even if a component comes from a trusted source the code consumer may still want to assess whether the component exhibits additional desired properties beyond those claimed by the code producer.
proof carrying code pcc has been advanced as a means to ease certification.
the premise of pcc is that proof checking is faster and simpler than theorem proving.
in pcc the code producer verifies via theorem proving that his program satisfies a set of predefined safety properties and provides as evidence a safety proof .
the code consumer certifies the program by checking the validity of the accompanying safety proof against the code.
however pcc certification can only re verify the properties that are substantiated by the safety proof.
also because reasoning about general properties of programs is complex pcc has so far focused on program independent security properties e.g.
memory safety type safety resource bounds .
in this paper we introduce the concept of search carrying code scc in which we apply the goals of pcc to programs and properties that can be model checked.
specifically we explore whether information collected during successful verification of a program via explicit state model checking could be used to ease subsequent certification via explicit state model checking of the same program.
our approach focuses on paths through a program s reachability graph.
a reachability graph is a graphical representation of a program s set of possible executions in terms of execution states i.e.
program counter variable values etc.
and transitions i.e.
program statements between execution states.
as a code producer s model checker explores a program s reachability graph it records its search path as a search script which effectively acts as a certificate of the verification.
the code consumer s model checker takes the script as input and uses it to speed up the task of re examining the program.
basic scc achieves slight reductions in certification times.
both traditional model checking and scc certification check properties in every state of a program s state space.
however whereas traditional model checking must ascertain a program s reachable state space scc certification can simply confirm that the provided script truthfully reflects the state space.
we take advantage of this distinction and modify the data structures that the model checker uses to keep track of visited states thereby realizing a small up to speed up in certification time.
in the special case where a code consumer trusts the code producer but wants to check additional properties and the veracity of the search script is not in question scc certification need not au367 thenticate the script and can instead be optimized for speed.
in trustful scc the provided search script encodes a perfect search of a program s state space that visits each program state exactly once avoiding paths that lead back to already visited states.
the resultant speed up in certification time depends on the structure of a program s reachability graph in particular it depends on the ratio of the number of transitions to the number of states.
more significantly scc certification can be parallelized more effectively than traditional model checking tasks can.
the main challenge in parallel model checking is balancing the workload among parallel processors.
however in scc the search task is known in advance and is encoded in the search script.
the search script can be partitioned into multiple tasks each covering a cohesive region of the search space that a processor can explore independently thereby avoiding the inter processor communication that is usually necessary to balance workloads dynamically.
the contributions described in this paper are as follows we propose a model checking based certification technique called search carrying code scc in which a code producer provides a search script that a code consumer uses to direct the search of its model checker.
we discuss how the technique verifies the veracity of a provided search script.
we also show how scc certification can be optimized in cases where the source of a component is trusted and the goal is simply to check additional properties.
we present a greedy algorithm to partition an scc search script into several scripts which can direct several partial certifications of a program in parallel.
we discuss requirements for the code producer s and consumer s model checkers.
while we have embedded our scc algorithm into java pathfinder jpf we expect that scc can be applied to other explicit state model checkers.
we evaluate the performance of scc on a suite of java programs.
by combining scc and parallel model checking we achieve an average speed up of up to nusing nprocessors.
when certifying a program from a trusted source and employing parallel model checking we report an average speedup of up to 6nusing nprocessors.
this paper is organized as follows.
in section we describe the basic algorithms and technologies needed to support scc based certification including the special case of trustful scc.
section describes how to parallelize scc to take advantage of parallel model checking and presents the results of our evaluation.
section discusses outstanding issues and known limitations of scc and section presents related work.
we conclude with section .
.
search carrying code software model checking exhaustively examines a program s state space checking conformance with desired properties.
during verification of a program the emphasis is on finding bugs and ultimately showing that a program is error free.
for certification the goal is to confirm that a program behaves as advertised and possibly to check for additional non advertised properties.
ideally it is faster to certify a program than it was to verify it in the first place.
the goal of search carrying code scc is to use information collected during model checking based verification of a program to speed up model checking based certification of the program.
a code producer s model checker performs a traditional exhaustive search and verification of a program s state space.
at thesame time it constructs a search script that represents its search of the state space.
the search script is a sequence of transitions i.e.
program statements and their resultant execution state ids i.e.
not state encodings the script corresponds to a depth first search of the program s reachability graph.
during certification a code consumer s model checker uses the provided search script to direct its search of the program s state space and certifies that the program satisfies its advertised properties plus any additional desired properties.
in general scc can be used to certify safety properties of programs where the properties are expressed as program invariants or assertions and to confirm absence of deadlocks.
we discuss properties in more detail in section .
search carrying code possesses many of the same benefits of proof carrying code.
first the burden of verifying the program is borne by the code producer whereas the code consumer simply re checks the program.
second the search script can be generated automatically by the code producer s model checker as we show in the next section.
third scc certification can detect accidental or malicious deviations between a program and associated search script.
there are three types of deviation the script includes nonexistent transitions the script omits a transition or the script incorrectly claims that a transition leads to an already visited state.
the first two types of deviation are easily detected in the first case the program has no program statement that matches the script s transition instruction and in the second case the script says to end the examination of a state before all of its transitions have been explored.
in both cases the model checker detects the discrepancy and the certification fails.
the third type of deviation is more menacing because if undetected it results in a partial search of the program s state space the mislabelled state is deemed to have already been visited so the model checker does not test the state and does not explore the state space that is reachable from it.
to detect this third type of deviation scc certification must in addition to visiting and testing all of the program s states explore all of the transitions emanating from these states to see if they lead to new unvisited states.
thus the search script encodes the program s entire reachability graph.
given that scc certification entails re exploring a program s entire reachability graph it might seem surprising that scc achieves any savings at all.
as will be seen small savings come from being able to confirm the script s encoding of the reachability graph rather than determining the reachability graph as is the case in traditional model checking.
more significant savings come from parallelizing scc certification.
we describe parallel scc in section .
in the special case of trustful scc certification the code producer and the verification results are trusted.
however the code consumer wants to certify additional properties of the program and the code producer is unable or unwilling to check these.
because the code producer is trusted the code consumer may choose not to check the veracity of the script.
as a result we can aggressively optimize the certification task for speed.
we describe trustful certification in section .
.
.
search script construction an scc search script records all transitions in a program s reachability graph and the state id of each transition s destination state.
consider figure which depicts the reachability graph of an artificially simple program.
transition labels abstractly represent the program statements being executed.
the script for this program is trans instr t1t1bt2t1bt2t1bbt3t1bbbbt2b state id s1s2s1s2s3s1s3s4s2s4s3s5s4s5s3s2s1s4s1 where the tis encode program statements e.g.
the byte code instruction or a combination of byte code and thread id and bs rep368s1 s4s5s2 s3t1 t2 t3 t1t1 t1t1 t2t2figure sample reachability graph of a program resent backtracks.
reading the script from left to right the search starts in the program state labelled s1 it explores the program statement represented by transition t1 which results in a program state labelled s2 and so on.
scc uses encodings of program statements in the script rather than transition ids so that different model checkers interpret the script in the same way and search the state space in the same order.
below is an example partial script in which transition instructions are expressed as byte code instructions trans instr aload 0aload 1bgetfield state id s1 s2 s1 s2 s3 for the remainder of this paper we will abstract instructions to transition ids for the clarity of presentation.
to minimize the size of the search script destination states are represented by state id rather than by explicit state encodings.
state ids are unique identifiers that the code producer s model checker creates and assigns to states during the course of the verification search starting with identifier s1and incrementing by each time a new state is discovered.
a transition that leads to a new state is referred to as a productive transition its destination state has an id that is larger than the largest state id encountered so far.
.
search script usage during scc certification the model checker follows the instructions given in the provided search script checking properties and authenticating the search script on the fly.
any discrepancy causes the certification to fail.
discrepancies are identified in three ways .
the script instructs the model checker to explore a nonexistent transition i.e.
a nonexistent program statement .
.
the script instructs the model checker to backtrack when the state still has unexplored transitions.
.
the script asserts that two transitions have the same destination state with the same state id but the model checker determines that the two program states have different fingerprints.
to facilitate this check the model checker maintains during certification a mapping fp from state ids to fingerprints.
a each new state is reached in order of state id its id and fingerprint are entered into fp.
when a state is revisited indicated in the script by a destination state whose id that is lower than the highest id its previous fingerprint is retrieved from fp and compared against the new fingerprint.
a mismatch is a discrepancy.
our map fpis slightly more efficient than a hash table of visited states because it grows more gracefully.
.
trustful certification in cases where a program comes from a trusted source and the code consumer trusts the results of the code producer s verification t2t1 t3 backtracks1 s2 s3 s4s5 t2figure perfect search of a program s state space scc can still be useful especially to check additional properties.
perhaps the code consumer found the program in a trusted software repository and is interested in using the program but only if some additional properties are met.
the code producer might not be available or willing to perform additional checks.
when the code consumer trusts the source of the program he might also trust the veracity of the search script.
if so the certification need only examine the program s states to test properties.
it need not explore all of the transitions in the program s reachability graph checking whether any reachable state has been missed.
to see the difference consider again the reachability graph in figure .
an exhaustive search of the graph explores all nine transitions visiting the same states multiple times.
in contrast a perfect search traverses a spanning tree of a program s state space it explores only productive transitions and visits each state exactly once1.
figure depicts a depth first perfect search of the graph from figure .
solid lines represent productive transitions and dashed lines represent backtracks to parent states.
the corresponding search script is trans instr t1t2t2bt3 the script does not record the transitions target state ids because trustful certification does not check the veracity of the script.
trustful scc effects a perfect search of a program s state space.
the code producer provides a program and matching trustful search script.
during certification the code consumer s model checker uses the search script to direct its search of the program s state space.
neither state fingerprints nor hash tables of visited states are created or maintained resulting in additional speedup.
.
evaluation of scc we implemented scc certification in java pathfinder jpf .
jpf is an explicit state model checker for java byte code programs.
we refer to the resulting model checker as jpf scc .
for convenience we implemented scc verification and certification in the same model checker but in practice these tasks might be performed by separate tools.
jpf and our modified variants employ partial order reduction and two types of symmetry reduction states that are identical except for unreferenced objects i.e.
garbage are considered to be equivalent and states that are identical except for the order in which classes and objects are loaded are considered to be equivalent.
we discuss the compatibility of scc with various state space reduction techniques in section .
we evaluated our work on a suite of nine java programs that have been used in previous empirical studies.
table lists each program including its source the parameter values that we used e.g.
instantiating dining philosophers the numbers of invariants and assertions that we checked for each program the number of states in the reachability graph the ratio of transitions to states and the 1backtracking does not constitute visiting a state because the work of constructing and testing the state is already done.
369table java programs used for evaluation src program parameters properties states trans time inv assert states sec dining philosopher philosophers .
bounded buffer buffersize prod cons .
nasa ksu pipeline stagesize listeners .
nested monitor buffersize prod cons .
pipeline stagesize .
rwvsn readers writers .
replicated workers workers items .
sleeping barber barber customers chairs .
elevator elevators floors people .
table results for scc verification and certification scc certification trustful scc certification program size verification sec script size kb certification sec speed up script size kb certification sec speed up dining philosopher 4kb .
.
bounded buffer 6kb .
.
nasa ksu pipeline 2kb .
nested monitor 7kb .
.
pipeline 5kb .
.
rwvsn 9kb .
.
replicated workers 15kb .
.
sleeping barber 8kb .
.
elevator 29kb .
time to model check the program using jpf.
we also checked each program for deadlock violations.
we ran our experiments on an intel pentium .2ghz machine with .5gb of memory running windows xp.
we ran each experiment ten times and report the average of the ten runs.
we evaluate the utility of scc on the basis of how long it takes to perform scc certification compared to the time it would take a code consumer to reverify a program.
table shows the results for scc certification using jpf scc.
column verification shows the time incurred by the code producer to model check the program and create the search script including the time to write the script to disk.
column certification reports the time incurred by the code consumer to certify each program including the time to read the search script from disk.
column speed up shows the speed up of a certification search compared to a traditional jpf search as reported in table .
for example the time to certify the sleeping barber program and to check the script is seconds which is .
times faster than jpf verification of the same program.
the speed ups of scc are very small and are mainly due to keeping a map of fingerprints fp instead of a hash table.
for our set of programs we report an overhead of to for keeping and maintaining a hash table.
scc saves this small cost.
because of the way that jpf maintains hash tables and resizes tables as needed the savings increase with the size of the program s state space.
table also shows the runtime performance of trustful scc certification.
for example the time to certify the pipeline program is seconds which is .
times faster than traditional jpf verification of the same program.
the speed up of trustful scc certification is proportional to the ratio of the number of transitions to the number of states in the program s reachability graph this is also the ratio of unproductive to productive transitions.
the speedup is slightly better than the ratio because of the savings from not creating and comparing fingerprints.
.
search script size the feasibility of scc depends not only on runtime performance but also on the size of the search script.
given a program whosereachability graph has sstates and ttransitions scc will produce a search script containing at most 2tinstructions tforward transitions and at most tbacktracks and trustful scc will produce a search script that has at most 2sinstructions.
because the number of states and transitions are exponential in the size of the program one might expect that script size is an issue.
fortunately search scripts contain lots of replication e.g.
byte code instructions backtrack commands which makes them good candidates for compression.
zip data compression reduced the sizes of our search scripts by factors of to .
table shows the size in kb of the compressed search script for each program for both scc and trustful scc certification.
it also shows the size of each program s class files along with the program name.
the sizes of compressed scripts are on the order of t kb for scc and s kb for trustful scc.
extrapolating to larger programs with million states and a billion transitions the script sizes might be on the order of 100mb for scc and 10mb for trustful scc.
such script sizes are large but are manageable.
.
parallel scc the promise of parallel model checking is that we can reduce search times by distributing the search among multiple parallel processors.
in general it is difficult to balance a model checking task evenly among processors because the size of the search space is not known in advance.
attempts to partition the workload in advance e.g.
assigning states to processors based on state information have resulted in substantial communication overheads due to the need to transfer new states to their designated processors.
even on a shared memory architecture this style of parallel model checking can suffer considerable overhead because processors need to coordinate their shared access to each others worklists.
in scc the certification workload is known in advance in the form of a search script.
as such it is possible to partition the workload into multiple search tasks of roughly equal size.
in the following sections we first describe how to partition an scc search script and then explain the optimizations for trustful certification.
370s2 s3 s4 s5 s6s7s8 s9 s10s1 t1 t1 t1 t1t1t1t2 t1 t1t2 t1 t2 t2t2t3 t316 1574021411s1 s2s3s4s5s6s7s8s9 s10 subgraphs s1 s10s7 s10s2s8s9s5s9s8s4s8s3s8s2s3s7s6s7s3s4s6s3s6s5s6s4s5s4s3s2 s1s2t2 bt1 t1 t1 t1 t1 t1 t1t1t1 t2 t2 t2 t2 t3 t3 b b bbb bbb b b bb b b b script figure reachability graph with its script and subgraphs .
partitioning the state space the goal of parallel scc is to partition the search script into multiple non overlapping search tasks each of which covers a contiguous region of the program s reachability graph that can be searched separately.
letscript be the full search script of a program as described in section .
and let jscriptjbe the size of the script in terms of the number of transitions.
prior to certification the certifier s model checker constructs a partition p fp1 p kgofscript intok search tasks.
each partition region pi2pcorresponds to a subgraph in the program s reachability graph andto a partial search script script ithat is a substring of script .
a subgraph piconsists of all states that can be reached via productive transitions from pi s root and all transitions productive and unproductive originating from those states.
for example consider the reachability graph in figure in which thick edges represent productive transitions.
in this example the subgraph rooted at state s4consists of the states s4 s5ands6 the subgraph would not include s3because it is reached via an unproductive transition from s6.
the size of each piis the number of transitions emanating from states in pi.
to facilitate script partitioning scc verification generates along with the search script a list subgraphs that records for each program state sthe number of transitions in the subgraph rooted at s. basically during verification the model checker performs a depthfirst search of the program state space.
as each new state sis encountered an entry indexed by state id is added to subgraphs .
ass s child states are explored and the sizes of their subtrees are computed the size of sis updated.
the subgraphs list is provided to the code consumer along with the program and search script.
in scc certification the size of a subgraphs list is less than of the size of the search script and in trustful scc certification the size of subgraphs is less than of the size of the search script.
figure shows an example reachability graph with its corresponding script andsubgraphs .
the subgraphs table shows for each state s left column the size of the subgraph right column rooted at s. for example the subgraph rooted at state s4 consists of the states s4 s5 s6and has size four i.e.
the four transitions originating from those states .
the value in parentheses below each state identifier in the reachability graph in figure shows the same information.
figure gives an overview of our partitioning algorithm.
it takes as inputs the search script script and the subgraphs list that are provided by the code producer and the number of partitions kto generate based on the number of available parallel processors .
in theith iteration the algorithm searches subgraphs for a subgraph whose size is closest to k iof the number of transitions not yet assigned to a partition region line this subgraph becomes a1 i n p u t script s e a r c h s c r i p t e n c o d i n g r e a c h a b i l i t y graph i n p u t subgraphs r o o t and s i z e o f subgraphs i n script i n p u t k number o f p a r t i t i o n r e g i o n s t o g e n e r a t e 4i while i k s e a r c h subgraphs f o rpiwhose s i z e i s c l o s e s t t ojscriptj k i remove s e a r c h s c r i p t f o rpifrom script remove a l l s t a t e s i n pifrom subgraphs update t h e s i z e s of s u b g r a p h s l e f t i n subgraphs compute p a t h t o i n i t i a l s t a t e of pi i figure partitioning algorithm new partition region pi.
next the partial search script script ifor partition region piis extracted from script line .
the algorithm also removes all states in pifromsubgraphs line .
we describe both processes in section .
.
.
the algorithm then updates the sizes of the remaining subgraphs in subgraphs line .
note that only the sizes of ancestor states of pineed be modified and their sizes are reduced by the size of pi.
we describe how ancestor states are identified in section .
.
.
finally the algorithm constructs the path from the program s initial state to the initial state of search taskscript i line .
we discuss the rationale and process for constructing this initialization path in section .
.
.
figure shows the result after one iteration of our partitioning algorithm as applied to figure for k .
the subgraph p1 rooted at state s4 is selected for extraction and its subscript is removed from script the dark line in script shows from where the subscript was extracted .
the states in p1have been removed from subgraphs and the sizes of s4 s ancestors s1 s2 s3 have been reduced by s4 s size.
the initialization path for p1is a sequence of transitions from the program s initial state to the subgraph s initial state.
dashed states in each of the resulting partition regions represent states that do not belong to the region but that are still reached as part of that region s search task they are reached when exploring transitions that emanate from states within the region.
figure shows the final partition of the graph from figure into three regions.
the scripts for p1andp2contain initialization paths to their respective root states.
the resultant search scripts represent the certification tasks to be distributed among parallel processors.
the complexity of our partitioning algorithm is o k s t steps and each have running times of o s for a reachability graph with sstates and steps and each have running times of o t .
in our experiments we noticed that this overhead translates into approximately .
to of the total certification time.
.
.
updating data structures in this section we discuss how script andsubgraphs are updated as our partitioning algorithm extracts each partition region pi.
we remove from script the subscript that represents the search of region pi.
let sibe the id of the root state of pi.
because script records a depth first search of the reachability graph and because state ids reflect the order in which the states are discovered in this search the subscript to be removed starts after the leftmost instance of siand ends before the subsequent backtrack from si to a state id less than si .
thus the subscript for region p1in figure with start state s4 is p1 t1bt2t1bt2bb s5s4s6s5s6s3s6s4 after discarding trailing backtrack commands we obtain a search script script 1that specifies the search of region p1 starting from the initial state of p1 371s2 s3 s7s8 s9 s10s1 t1 t1 t1t1t2 t1 t1t2 t1 t2t2t3 t312 1131411s1 s2s3s7s8s9 s10 subgraphs s1 s7 s10s2s8s9s5s9s8s4s8s3s8s2s3s7s6s7s3s4s3s2t2 t1 t1 t1 t1 t1t1t1 t2 t2 t3 t3b b bbb b bb b script 1s4 s5 s6t1 t1t2 s3s6s5s6s4s5t1 t1 t2 t2 b bp1 script initialization t t1 t1 s3 s6 s4 s5figure result of partitioning after one iteration of algorithm p1 s4 t1bt2t1bt2 s5s4s6s5s6s3 given a partition region pi updating subgraphs entails removing all entries that correspond to states in the region line in our partitioning algorithm .
again let sibe the id of the root state ofpi.
any state in script iwhose id is greater than or equal tosirefers to a state in the region piand must be removed from subgraphs .
for example in script states s4 s5 ands6are removed from subgraphs .
each iteration of the partitioning algorithm produces a script for a different partition region.
when the algorithm terminates what remains of script forms a search script for the kth region.
figure shows the search scripts for each partition region.
s2 s3 s4 s5 s6s7s8 s9 s1p2 p1p3 s10t3 t3t1 t1t1 t2t1t2 t1t1t1 t2 t1t1 t2t2 s3 s5 s4 s3 s6 s4 s8 s3s6s5s6s4s5t1 t1 t2 t2 b b initialization t t1 t1s5s9s8s4s8s3t1 bt t2b initialization t t2t3 s1 s7 s10 s2s3s7s6s7s3s4s3s2t1 t1 t1t1t1 t2 t3 bbb b t2 s8b s2 figure subgraphs with scripts and initialization paths .
.
constructing initial states eachscript istarts at the root state of a partition region pi.
we could attempt to construct the corresponding initial program state for each search task but jpf program states are complex and are difficult to construct and restore they comprise not only the variable valuation but also information about threads and the progress of the search.
instead we prefix each search script with an initialization path a sequence of transitions from the program s initial state to the start state of the search task.
we discuss in section .
the overhead incurred by this decision.
to construct the initialization path the original script is scanned from start to end.
every time a transition is reached it is pushed onto a stack.
every time a backtrack command is read the top transition is popped off the stack.
when a state id sis first encountered the transitions in the stack make up the initialization path from the program s initial state to state s. for example the initializationpath to p1 s root state is t1t1t1.
note that this algorithm does not construct the shortest path to a given state but it does construct the shortest path with respect to the given script.
the states along the initialization path are all ancestor states of sin the reachability graph.
thus we can use the same process to update the sizes of the subgraphs remaining in subgraphs after removing all states of pifromsubgraphs line of the algorithm .
.
.
correctness our partitioning algorithm divides a search script in such a way that the resultant subscripts cover all states and transitions of the original script.
each iteration of the partitioning algorithm extracts a search subscript that corresponds to a leaf subgraph piof a program s reachability graph the subgraph is rooted at state si it include all states that are reachable from sivia productive transitions and includes all transitions originating from those states.
thus the corresponding subscript is a contiguous substring of the original search script starting with the first occurrence of initial state si and ending before the first backtrack from state si.
because the extracted subscripts correspond to leaf subgraphs in the original reachability graph their extractions do not affect the continuity of what remains of script .
when the algorithm terminates what remains of script is a search subscript for a contiguous kth subgraph the subgraph is rooted at the program s initial state s1 includes states that are reachable from s1via productive transitions up to and excluding the root states of the extracted partition regions and all transitions originating from those states.
in this manner the algorithm splits script without removing any states or transitions except backtrack transitions .
if the provided subgraphs is not accurate with respect to the program s reachability graph the partitioning algorithm will still produce sub script that cover disjoint regions and taken together cover the program s entire reachability graph.
for example if one or more entries in subgraphs list incorrect sizes of subgraphs then the algorithm will simply produce partitions whose sizes have a larger standard deviation.
alternatively if one or more states are missing from subgraphs this will be detected in line when the states of a region are removed from subgraphs .
ifsubgraphs contains extra entries this will be discovered if the algorithm ever chooses one of those states to be the root of a region otherwise it will have no effect on the algorithm.
.
parallel certification the program and search scripts are distributed to parallel processors which run the certifier s model checker.
each processor keeps its own local copy of fp mapping state ids to program state fingerprints.
if a processor detects any discrepancy between its search 372table results for parallel scc certification scc certification trustful scc certification sub scripts program max task speed up max task speed up max task speed up max task speed up max task speed up max task speed up dining phil bounded buffer nasa ksu pipe nested monitor pipeline rwvsn replicated workers sleeping barber elevator average s2 s3s4 s5 s6s7s8 s9 s1p2 p1p3 s10 p3 t1 t1 t3 b b t 3p2 t1 t2 t3 p1 t1 t1 t1 t1 b t 2t3t3 t3t1 t1 t1 t2 figure script partition for trustful scc script and the program it raises an error.
in addition once all processors have finished their certification tasks the processors fp maps are compared to ensure that all processors map state ids to the same fingerprints.
any mismatch is reported as an error.
this final check on the veracity of the search scripts performs at most nscomparisons where nis the number of processors and sis the total number of states.
.
parallel trustful certification the algorithm for partitioning a search script for trustful certification is similar to the algorithm presented in figure but is applied to a trustful script which contains no unproductive transitions .
the only difference between the algorithms is that the partitioning algorithm for trustful certification removes the productive transitions that span regions e.g.
the transition from s3tos4 in figure .
figure shows the partitions that we obtain for parallel trustful certification of the sample reachability graph given in figure .
the regions represent spanning subtrees of the original reachability graph.
.
implementation and evaluation we implemented parallel scc in java pathfinder and refer to the resulting model checker as jpf pscc .
for convenience jpf pscc supports both verification and certification modes.
in the verification mode jpf pscc generates a search script to be used during certification.
in certification mode jpf pscc can be used to partition the search script into kscripts or to model check the program using one of kscripts to direct its search.
at the end of a certification task jpf pscc outputs its fp map.
at present a separate program is needed to compare the fps from all certification tasks.
to evaluate the performance of parallel scc we used jpf pscc to partition each program s state space into and certification tasks i.e.
sub search scripts .
because the sizes of the resulting scripts are not exactly equal we report for each program the time it takes to examine the largest sub script.
to this time we have added the time it takes to partition the search script andtable avg.
and max.
lengths of initialization paths sub scripts program avg max avg max avg max path path path path path path dining phil bounded buffer rwvsn sleeping barber elevator average the time it takes to compare all fpmaps sequentially.
in practice the actual time of this latter task would be less because the search tasks would finish at different rates and fp maps could be compared against the current master map as tasks complete.
table shows the results for parallel scc certification and parallel trustful scc certification.
for each certification method and the number of partitions or column max task lists the size of the largest search script for each program for scc certification size is reported as a percentage of the program s number of transitions and for trustful scc certification size is reported as a percentage of the program s number of states.
columns speedupreport the speed up in certification time over the time to verify the entire program using jpf as reported in table .
in scc certification the size of the largest sub script determines the optimum number of processors to use during certification.
for example when partitioning the reachability graph of the dining philosophers example into subgraphs for scc certification the size of the largest resulting subgraph is .
thus the optimum number of parallel processors to use is .
taking this into consideration the results show that speed up for parallel scc certification is on average a factor of n fornprocessors.
trustful scc certification can achieve a speed up of up to a factor of 5n fornprocessors.
the speed up factors reported in table are not simply the product of the speed up factors reported for nonparallel scc certification in section and the number of parallel processors employed.
this is partly because of the time needed to compare fp maps at the end of certification and partly because the search tasks vary in size and we report the timings associated with the largest task.
most of the certification sub scripts are prefaced with an initialization path which affects the size of the script.
table reports the average column avg path and longest column max path initialization paths for the scripts generated for parallel scc certification for five programs.
the initialization paths for the remaining programs show a similar pattern and are not shown because of space considerations.
the reported average values are for all nine programs.
most path lengths are relatively short and jpf pscc can 373explore approximately transitions per second.
the lengths of initialization paths for trustful scc certification are similar.
.
discussion in this section we discuss some outstanding issues of scc including some of our design decisions restrictions on the properties that can be checked requirements on the model checker s used scalability and compatibility with search space reduction techniques.
.
properties safety properties play an important role in formal verification because they assert that the system stays within required bounds and does not perform any wrong actions .
scc can be used to certify invariants and program assertions and can also check for deadlock violations.
because the search script encodes all transitions of a program s reachability graph scc can also be used to check invariants over consecutive states such as the property x !next x which states that if the value of xis then in the next state its value will be .
even when certification is parallelized each scc search task is responsible for covering a set of contiguous states and all of their outgoing transitions.
thus every pair of consecutive states is captured in a search script making it possible to certify invariants over consecutive states.
in contrast trustful scc does not cover all transitions so it does not cover all pairs of consecutive states.
thus trustful scc can soundly certify only state properties.
.
scalability a number of factors affect the scalability of search carrying code.
for one scc certification is limited to finite state programs.
however this limitation applies in general to explicit state model checking.
thus if a program can be verified using explicit state model checking then it can be verified and certified using scc.
if the code producer uses abstractions to produce a finite state space for scc verification then the certifier must use the same abstractions and must check that the abstractions preserve the properties being proven.
another factor is that the results of our experiments reported in table suggest that the benefits of parallelization diminish as we increase the number of sub scripts we divide an scc script into.
our partitioning algorithm does not partition a script into subscripts of exactly equal size plus the resulting sub scripts are prefaced by initialization paths of varying lengths.
as such the speed up in certification time is bounded by the amount of time it takes to certify the largest sub script.
in the worst cases when a script is partitioned into or sub scripts the largest sub script is to times the size that would be expected if the sub scripts were truly equal sized.
we do not know whether the observed diminishing of returns is due to the small sizes of the programs in our test suite or is inherent to our approach.
more experiments on larger programs are needed to answer this question.
a more serious issue is the size of the search script that the code producer provides likely over a network to the code consumer.
the size of a compressed script in number of bytes is on the order of the number of states in the program s state space which could be very large in the worst case where the program s state space is at the limit of what can be model checked.
in this paper we assign responsibility of partitioning the script to the code consumer on the assumption that she knows how many processors are available and thus knows how many sub scripts to create.
however in cases where the script is large it may be prudent for the code producer to partition the search script.
this would certainly be the case ifit turns out that there is a limit to how evenly the script can be partitioned into sub scripts as discussed above.
.
using different model checkers in our work we have shown how scc can be used when the certifier and verifier use the same model checker.
however ideally the code consumer should be able to use a model checker of her own choosing adapted to use search scripts and not be restricted to using the same model checker as the code producer.
we have not evaluated using scc with different model checkers but we expect that different model checkers can be used for verification and certification as long as they satisfy certain requirements.
to start both model checkers must be explicit state model checkers as scc does not support symbolic model checking.
second the two model checkers must agree on how to interpret transition statements in the search script e.g.
they must both match a byte code instruction to the same instruction in the program being explored .
third the certifier model checker must create unique fingerprints for distinct states for checking the veracity of the script but there are no constraints on how this should be done.
if state space reduction techniques are used then the situation is more complicated because the techniques could change the size and shape of the reachability graph.
discussion of how scc interacts with state space reduction techniques follows.
.
model dependent reduction techniques a key question of any new model checking technique is whether and how it works in combination with existing search reduction techniques.
we discuss model dependent reduction techniques in this section and property dependent techniques in the next section.
we expect scc to complement model dependent reduction techniques as long as the reduction techniques are applied in advance or on the fly so that the search script encodes the reduced reachability graph and the verifier and certifier model checkers agree on the abstractions applied.
we consider only automated reduction techniques techniques that rely on user input e.g.
abstraction functions are not safe because a malicious code producer could specify an unsound abstraction.
symmetry reduction reduces the size of the state space by exploiting symmetries among states.
the idea is that states are grouped into equivalence classes and the model checker can discard a state if an equivalent one has been explored before.
there are a number of different techniques for identifying symmetries but the ultimate effect is that symmetric states are assigned the same fingerprint.
in scc verification symmetries result in a reduced reachability graph being explored and a smaller search script being generated.
if the same model checker is used during scc certification it identifies the same symmetries symmetric states are assigned the same fingerprint and the shape of the reduced reachability graph matches the search script.
if the code producer and consumer use different model checkers the checkers must implement the same reductions.
currently it is not realistic to expect different model checkers to use the exact same symmetry reductions.
but if model checkers were parameterized with respect to their state space reduction techniques and algorithms then requiring both model checkers to use the same symmetry reductions would not be a limitation.
in fact there has already been some work along these lines .
partial order reduction por is an automated pathreduction technique that finds transitions that are independent of each other and whose interleaved executions all lead to the same state regardless of the order of their execution.
por executes only one of the possible interleavings.
374during scc verification the model checker detects independent transitions explores only one interleaving and records only one interleaving in the search script.
the entire interleaving is recorded as a single transition in the search script.
if the same model checker is used during scc certification then the certifier s model checker identifies the same sets of independent transitions chooses the same interleavings as long as decisions are deterministic and disables the other interleavings.
as a result the por interleavings chosen during certification match the search script.
because a por interleaving is treated as a single compound transition it is never partitioned among different subscripts and during certification an entire interleaving is assigned to a single processor.
thus por does not interfere with scc even after parallelization.
if different model checkers are used for scc verification and scc certification they must both use the same por heuristics to determine which transitions are independent and select which interleaving to explore and the heuristics must be deterministic.
it might seem unrealistic for both model checkers to use the same heuristics but we believe a parameterized approach to statespace reductions as described above could address this limitation.
.
property specific reduction techniques the goal of property specific reduction techniques is to reduce the search space and search script to those program states that are relevant to the property being checked.
such reductions are problematic for scc because the code producer does not know in advance which properties are of interest to the code consumer and thus cannot apply the appropriate reductions.
moreover the code consumer cannot simply apply the reduction techniques herself because the resulting reduced program would no longer correspond to the supplied search script.
such techniques can only be useful if they can be applied to the search script rather than to the program.
consider program slicing which is a commonly used propertyspecific reduction technique that reduces the size of the search space by ignoring program statements that are not relevant for a given property.
traditional program slicing cannot be used in conjunction with scc for the reasons given above but it might be possible for the code consumer to slice the search script instead given that the script s transition instructions which are bytecodes literally encode the program statements.
the certifier model checker would need to be able to determine from a transition instruction in the search script whether the transition is relevant to the property being checked.
it would also need to perform a definition use analysis on the script which is a much larger artifact to analyze than the original program.
lastly not all irrelevant transitions can be removed from the search script because the sliced script must still be a valid path in the program s reachability graph.
we are still investigating the problem of script slicing.
although it seems to be possible it is not clear whether the resulting reductions will be significant.
in general the savings achieved by program slicing cannot be predicted in advance and it is possible that slicing provides no significant savings at all especially when checking a large collection of varied properties such as during certification.
.
related work in previous work we suggest using information gathered during one model checking run to speed up subsequent runs and we evaluated a jfp based prototype on six java programs.
we extend that work here by evaluating it on more and larger programs protecting against tampering of the search script and parallelizing the certification searches.our work is inspired by proof carying code pcc .
significant infrastructure is needed to support pcc including inference rules for reasoning about code a formal language for expressing safety properties and proofs and an algorithm for checking a program and its safety proof.
most research on pcc focuses on reducing the size of proofs and generalizing the kinds of properties that can be proved .
in contrast scc based certification can be implemented by making modest changes to existing modelchecking technologies.
scc search scripts are created automatically and can be decomposed into an arbitrary number of smaller scripts.
while a pcc certificate encodes the proof of particular properties an scc script is independent of any properties.
thus the scc script can be reused to speed up checks of newly identified properties.
techniques most closely related to scc are abstraction carrying code acc and model carrying code mcc .
in both cases the program to be certified is accompanied by an abstract model of the program.
in acc this abstract model is an abstract interpretation of the program.
in mcc the model is an extended finite state automaton over the alphabet of system calls and is synthesized from the program s execution traces.
in both cases the abstract models are property independent.
certification is a twostep process certifying that the model is a faithful abstraction of the program and certifying that the model respects the desired properties.
in acc and scc certification is done offline.
in mcc model veracity is checked at runtime by monitoring the program which incurs a performance penalty of to .
acc and mcc support richer property languages e.g.
temporal logic than scc does.
in addition acc and mcc can accommodate infinitestate programs.
however acc and mcc models are conservative abstractions which means that they are susceptible to spurious errors.
worse an mcc model may be unsound if it is synthesized from a deficient set of traces.
in contrast an scc script results in a sound and complete search of the state space.
importantly it is not known whether acc or mcc can be parallelized.
lauterburg et al.
propose a technique to support incremental state space exploration that is based on storing information regarding the entire reachability graph.
they use the information to speed up the model checking of subsequent versions of the same program a task that is comparable to our scc certification.
the maximum reported speed up is a factor of approximately two and their technique has not been parallelized.
early work on parallel model checking tried to speed up the process of finding errors by distributing the model checking search among multiple workstations on a network distributed memory .
the challenge was to distribute the workload evenly among the parallel processors.
stern and dill parallelized mur an explicitstate verifier by pre assigning states to processors based on a hash of the fingerprint.
however this approach could result in an imbalance in workload among the processors.
moreover substantial state information must be passed between processors whenever a new state is discovered and must be transferred to its assigned processor.
subsequent works by others investigate how to improve local and global load balancing and reduce communication overhead .
on a shared memory architecture communication among processors is negligible but the processors must synchronize their access to shared variables such as when they deposit states into each other s worklist or access a shared hash table of state fingerprints.
thus there is the extra challenge of keeping processors utilized and not waiting too long to access shared resources.
interestingly some researchers report that beyond an optimal number of processors the search time starts to increase with the number of 375additional processors because the synchronization overhead dominates any benefit from parallelization.
parallelized scc does not suffer from this overhead because the reachability graph is partitioned in advance in such a way that no communication or synchronization among processors is necessary.
each processor works independently of others and shares information with an administrator process which collects and compares fingerprint maps only at the end of its search task.
.
conclusion and future work we have proposed search carrying code scc as a technique to certify software that was previously verified by software model checking.
we have shown that scc certification can determine if the provided search script i.e.
the program s certificate is not a faithful representation of the program s state space and that scc certification can be parallelized to speed up the certification task.
in the special case where the source of a program is trusted we show how scc certification can be further optimized by searching a spanning tree representation of the program s reachability graph and eliminating data structures and checks on the search script.
in the future we would like to continue to address limitations of scc.
our current focus is on alternative representations and encodings of the information in the search script in order to reduce its size.
we are also investigating in more detail how scc can be used in combination with various search reduction techniques.
finally we would like to evaluate scc on industrial sized programs.