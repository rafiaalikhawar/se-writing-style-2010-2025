detecting and characterizing semantic inconsistencies in ported code baishakhi ray miryung kim suzette person neha rungta the university of texas at austin austin usa rayb utexas.edu miryung ece.utexas.edu nasa langley research center nasa ames research center hampton usa mountain view.
usa suzette.
person nasa.gov neha.s.rungla nasa.gov abstract adding similar reatures and bug fixes often requires porting program patches from reference implementati ons and adallting them target implementations.
porting errors may result from faulty adaptation s or inconsistent updates.
this paper investigates i the tyllcs of porting errors found in tlraetiec and how to detect and characteri .r.c potential porting errors.
analyzin g crsion histories we define live categories of porting errors including inrorrecl conlrol and data flow code redun dancy incllnsistent identifier renaming s etc.
i.el eraging this categllri r.atilln we design a static cllntrol and data dependent e analysis technique spa to deled lind chhracterize porting inconsistencies.
our evaluation on code from lour open suurce projects shows thai spa can dell oct porting incunsistencies with to 73o precision and recall and identify inconsistency types with to precision and to recall.
in a romparison with two cxisting crror detcction tools spa improves precision by to iicrttntag e ijoints.
i. introduction developers often port code fmm one implementation to another in order to implement similar features or bug fixes.
a recent case study of openbsd nctbsd and frecbsd found that j j to codc changcs arc ported from pecr projects .
also when libraries and frameworks evolve their apls client applications make similar updates to usc the new apls correctly 3j.
in a large code base typically to of the code is considered as code clones which often require similar updates during software evolution .
when porting changes from one implementation to another developers generally need to adapt the ported changes to fit the new context.
the code in the reference often serves as a template that is pasted into the target implementation and thcn latcr adaptcd .
the process of adapting a change to fit another context can be error prone often resulting in porting errors.
chou et al.
report that a significant jxlrtion of operating system bugs comes from ported edits r4 .
in a case study of clone related bugs juergens et al.
discover that .
nearly every second unintenlional inconsiste nt chanre .
to clones lead a fault 11of.
li et al.
idcntify errors in linux and frecbsd resulting from dcvelopers forgctting to renamc idcntificrs aftcr porting code .
jiang et a!.
19j present evidence of porting errors when similar code appears in different contexts.
porting errors can also happen when developers evolve jxlrted code differently .
whcn dcvelopers port codc from a referencc to a target con tcxt thcy usually expect thc portcd eodc to behavc similarly.
existing tool support for detecting semantic inconsistencies in ported code is limited.
for example li et a!.
and juergens et al.
find inconsistent clones using a lexical clone detection analysis .
jiang et al.
and gabel et al.
report clone related bugs by comparing the syntax tree structures for two clones .
such syntactic and lexical analyses are not sufficient to detect the semantic inconsistencies arising fmm updates to the ported code in different contexts.
the goal of this work is to assist developers in porting edit from one contcxt to another by dctccting semantic inconsistencies that may indicate a porting crror.
as a first step towards this goal we study the extent and ehardcteristics of porting errors that occur in pmctiee to better understand the types of porting errors and their fixes.
in our study we work backwards by first mining the version histories of linux and freebsd to detect commit messages containing porting error related keywords.
we then analyze three types of souree code commits fix inducing error inducing and reference and their corresponding patches.
a patch is the set of program statements that are added deleled or modified in a program vcrsion with respect to its previous version.
notc thai modified statcment can also be represcnted as dcleted statements in the old version and added statements in the new version.
we usc sliverski et al.
s fix inducing change identification method to identify the patch that originally introduced the porting error.
we then use repertoire to find a reference patch that served as the template for the error inducing patch.
through manual investigation of the reference patch the error inducing patch and the fix patch we find that many of the porting errors result from incorrect adaptation of the ported code including inconsistent identifier renamings diffcrent control and data flow contcxt in thc reference and targct implementations and codc redundan cy.
lcvemging this characterization of porting errors we design and implement spa an algorithm to detect and characterize porting inconsistencies.
spa detects semantic inconsistencies that arise due to the interactions between program statements in the ported code and program statements surroundin g the ported code.
spa takes two code patches as input a reference patch refold and ref cw and a target patch farold and tarn .
spa analyzes the reference and target patches to identify the ported code and then uses static control and data dependcnce analyses to identify the impact of thc portcd codc on thc reference and targct contcxt .
finally spa compares thc impact of the portcd cooe on thc refcrencc and targct scmantics to detcct and charactcrize porting inconsistencics.
to evaluate the accuracy of spa we perfonn an empirical evaluation on four large open source codebases freebsd linux eclipse cot and mozilla and compare the result.
with two stale of the art tools dejavu and jiang el al.
s elone related bug dctection tool .
thc result.
of our study show that spa idcntifics scmantic porting inconsistcncies with to precision and recall and idcntifics inconsistcncy types with to precision and to recall.
spa outperforms two relatcd error detcction tools with a precision improvement of to percentage points.
we make the following contribulions we conduct a comprehe nsive study of the extent and characteristics of porting errors reported for real world systems.
we identify categories of common porting errors related to inconsistent control flow inconsistent data flow inconsistent identifier renaming and code redundancy.
leveraging information about commonly found porting errors we design and implement a novel algorithm spa to dctect potential porting crrors based on inconsistent semantics of ported cooe betwecn the reference and target context.
.
we conduct an cmpirieal cvaluation of spa s ability to detect and characterize porting inconsistencies in four large open source eodebases.
the rest of the paper is organized as follows.
section discusses an empirical study of porting errors in linux and freebsd.
section iii discusses spa s methooolo gy for de tecting and characterizing porting inconsistencies.
section iv presents an empirical cvaluation of spa s capability to detect and characterize porting inconsistencies.
section v discusses related work.
finally section vi summarizes our work and directions for future work.
ii.
an empirtcal study of porting errors we conduct an empirical study of porting errors documented in real world projects to better understand the extent and characteris tics of poning errors found in practice.
in this study we focus on porting errors thai arise when porting a patch to a similar hut noi identical context within the same project.
we first identify porting errors that are reported and fixed by developers using the version histories from two large open souree projeet .
we then manually analyze these errors to undersrnnd the characteristics of the errors as well as the fixes.
most of the errors found in the artifacts used in our study can largely be characterized into five categories.
in the remainder of this section we present the study setup results and a description of the five categories of porting errors.
we first define several key terms used in this work.
definition .
a program pljtch l .
ljl is the set of syntactic program differences betwecn two program versions and where cach clement in the set is an atomic program statement that correspon ds to an edit operation e.g.
insert.
delete move and update.
definition .
ported code is a pair of atomic program statements sr and sl in patches pr and pi respectively such that s .
and st are syntactically similar and arc also edited similarly.
definition .
context of ported code is the set of program statements in a method that are not part of the ported code.
a. study method we mine the commit logs and analyze version histories for linux and freebsd.
table i shows the size of the two projects in kloc the evolution period under study and the number of unique developers who made commit.
during that period.
developers often document fixes to porting errors in com mit messages.
to detect how many hug fixes are related to porting we find commit logs that contain at least one porting related keyword copy cut paste or porting and at least one error related keyword error bug mistake fix or defect.
a sample commit message in freebsd is fix cut paste bug which would result in a panic the corresponding code patch fixes the port ing error.
to understand the nature of porting errors we work back wards from a porting error fix by extracting three patches a the fix patch pi where the porting error is fixed b the target patch pt where the porting error is introduced into the codebase and c the reference patch pr which contains edits that serve as the template for the ported code.
a fix patch pi is the program paleh associated with the mined commit message.
for example the fix patch corresponding to the commit message shown above is represented by the colored lines in the ir i example in table ii.
from the program locations edited in pi we use cvs annotate or git blame to identify the target patch pl which introduced the porting error.
this process is similar to how sliwerski et al.
21j identify a fix inducing patch.
we then use the repertotre tool to identify a set of candidate reference patches that may serve as the template for the target patch pi .
the reference patch by definition has a commit date prior to the revision date of a larget palch hence we consider patches available until the target patch date as candidate reference patches.
finally we select the reference patch pr through a manual inspection of the possible candidates.
for example in the ir i example in table where the developer forgot to update an identifier bp to rabp after porting code fragments from the reference patch we expect the reference patch to eonrnin the unaltered eooe fragment related to bp.
when multiple patches contain s imilar unaltered code fragments we select a patch with the maximum number of similar lines.
b. poning errors characterization in our study we were able to identify and porting errors documented in freebsd and linux version histories over the course of years and years respectively.
based on the porting errors analyzed in our study we were able to classify the errors into five different categories.
we usc the codc snippets in table ii to discuss each of the categories of porting errors beluw.
table i stuoy sullllicts kloc de cjopers years linux .
fit b. d .
4il5 icf inconsistent control flow.
many porting errurs arisc from edits that arc ported tu a different control flow context and are not adapted correctly with respect the context.
in the icf example shown in table it there is an extra for loop highlighted in gray in the reference context.
thus the continue statement in the reference code is iolended to match the inner for loop.
n the target coolext however there is only one for loop.
thus the continue statement marked in red unintentionally matches the wrong for loop.
thc corresponding fix patch removcs thc continue state ment in the target context to fix the error.
ir incollsistcnt rcnamin g. developers often forget to adapt variable type and constant names according to the target contcxt and these inconsistent renamings lead to porting errors.
this type uf porting error is further split into two sub catcgories ir i inconsistem renamings of identifier .
.
dcvelopers re name some occurrcm cs of an idcntificr i but forgct to update all occurrcm cs uf the identifier i cunsistently.
for example pointer bp is updated to pointer rabp three times missing the instanccs marked in red in the lr l example in table n. ir inconsistent renamings of related identifiers.
develop ers consistently rename an identifier but forget to update all related identifiers.
in the ir example in table n all instances of the ofdm related macro twl f ir5t of dm rate are updated to the cck related macro iwl fjrst cck rate.
however the variable ofdm and the related macro lowest present ofdm are not updated to cck and the related macro lowest present cck.
the corresponding fix patch replaccs the token ofdm with the token cck to fix this error.
idf inconsistent data flow.
this inconsistency occurs when developers mistakenly inscrt code to a diffcrent data initializa tion cuntext.
ln the ldf example in table u the first argument of the strcmp method optarg is initialized diltercntly in the reference and target edits.
optarg is an environment variable initialized by the getopt call that parscs the command line argument s and stores the next argument to optarg.
hence the function call get opt and thc use of variable optarg should occur as a pair.
n the reference context optarg is used after get opt and thus is initialized properly.
in the target context however there is no call to get opt .
thus optarg is not initialized properly.
rdn redundant operation s. developers may inadvertently introduce redundant operation s when they port code to the wrong place e.g.
whcre it already performs the samc opem tion or thcy may not update ported edil correctly to ensure linu.
rig.
i. rcla!ionship bc!wccn differcm !ypcs of poning errors there are no redundant computation s in the target context.
in the ron example in tahle ii a ecxle fragment related to memcpy was ported to the samc function body twice under the same scope in freebsd.
the corresponding patch removes memcpy and the buffer initialization statements to correct the redundant opemtions.
oth others.
other porting errors we identified include incorrect formattin g c.g.
indcntation that docs not match with the rest of the target cooe structure or unadapted eommenl that do not describe the target code currectly.
for example in frcebsd rile src sys geom!strip e!g stripe h version .
a commcnt related to concat name was updated not to stripe name .
c. distribution of porting errors in freebsd and linux table iii d!stribution of porting errors tct .
lin ron total linux t2.
.
.
.
.
fiftb.
d .
.
.
.
.
by manually inspecting the sets of reference patch.
pn target patch pt porting error fix patch pi.
associated commit messages and bug description s we eategori7.e the porting errors into the five categories described above.
table iii shows a distribution of the cases of freebsd and cases of linux across the five categorics of porting errors.
thc results show that a majority of porting errors are due to incunsistent renaming of identifiers lr .
and .
in frecbsd and linux respectively.
the errors related to control icf and data ldf flow inconsistency make up more than of the total porting errors.
the rest of the errors are either due to redundant operations ron .
and .
or wrong indentation and commcnts ath .
and .
in freebsd and unux respectively.
the error catcgories are not mutually exclusive.
for exam ple.
an inconsistent renaming error ir may also cause an inconsistent data initia1i7ation crror ldf i7.
and .
of the porting errors in freebsd and linux respectively are both types ir and ldf.
an inconsistent data initialization error jdf may also generate redundant operations rdn i. in frecbsd and .
in linux.
somctimes an inconsistent control flow icf may also initialize thc data erroneous ly tabl.e ii exami les of l lilting eiiiioiis of ljtfl eiient tyl es icf ineon btent contml fk w freebsb commit s cl sysl kernl sched 4bsd log fix a copy paste bug in non kse c reference file s c sys ke n 3ched 4bsd c forf..acii ksegrp in proc p g i c vendon author.
david u date 2cxwll aw e if c ke eptick continue if fshift ecpu shift ke ke...j clcpu real lathz loci ke ke cplick target file src sys kern sched 4bsd c foreacilthrf.ad in proc p to awake if kc k cptie l ee1 ltch el if shin cc u hh ti t ke kc...j clcpu fixpl ll i real lalhz leoi ke i e cplich ir i. inmn istent renaminj s uf identifiers frecbsd commit src sys kern vfs bio c version .
author.
phi date log fix eut pasle bug which would result in a panic because buffer was being biodooo ed mulliple limes.
reference file scc sys kern vfs bio c e t file src sys kern vfs io c op o jocl l b o !
jio op b f.l g ii i nii vp v type iioir lt vp v lype vchhi iiop spf.cstrategy .
else iiop stratf.gy .
voi si ecsthategy vp bp rabpl ehe iiop stilat!
gy vp by rabp lr .
incoru islent renaming5 of related identifiers linux colllmit 5cddob946a0afebld0364a3654328b046tb8 18a2 author emmanuel grumbac h. dale log rix a copy paste error in iwlealc basie tates whieh leads to a wrong calculation of cck basic tales.
reference rile wi i l s iwlwifi idvml cxon c thl !
ct file wi i l iwlwi fi dvml rxon c f rwi.
rate 24iolindex !o c lprc cnt otdlll ofdlll iwl ratf.
24iolmask iwl first o te it iwl.ftate.
liiolindex low l ...j. resenl cl t fdfttccl iwl.ftate lli ...hask iwlj ihs t t uw inronsistcnt ata u ... freebsb commit s cl sbi n gpt qpl c ven ion i. iii auioor.
marcel dme l.og fix eut n pa. te bug compare argument s against known alia .
not the global optarg.
reference pile src sh.in qpl gpt c targel pile src sbi n qpl gp t c ... in lnt argc chllr .hgv i p r c uuid o o t chllr nid t nidl i whlle ch gctopt .hgc argv lteh ch t ell e i f trcmp optarg pace t opt fs optsp ace i whch .
ell e c if strcmp .
ti l ci uuid t efi gpt ent type efl i i rdn redundant operations linux mmmit 19c2fdhab l r1854f2bfcc 7sc326dof453 7ec2a7e author.
john w. linville dale log looks lii e a copy n paste error idenlical lines are a few li s below the o s removed .
reference file s iccl sys idev imxgel i i mxge c target file srcl sys dev imxgel if.jflxge c mcmset t f tl v cxoc izeof truet mwifiex ie typc t f time tamp me11lcpy .buffer t5f tlv zeof t f tlv header i .ouffer izeof tbf tlv headerl memcpy .bufcer .
t f val .heof l val i .uuffer s1zeot tsf vall idf .
in f rccbsd and .
in linux.
figure i shows the distribution of the five porting error types in freebsd and linux.
d. threats to validity construct validity.
we rely on the method of mining for porting error related keywords in the commit messages .
it is possihle that developers may not document porting errors in commit messages when fixing porting errors.
infernal validity.
we assume that porting mistakes happen due to poor adaptation which may not be always true.
the five types of common porting crrors are derived from the analyzed data and thus are subject to the experimenter s interpretation or categorization bias.
external validity.
we study porting errors in frccbsd and linux.
both of these projects are written in c. thus our categorization of porting errors may be biased towards c language features.
also we study porting bugs within a project boundary.
our observations may differ for cross system porting errors.
though our results may not generalize to other systems we believe our study of two long surviving large scale operating systems provides meaningful insights.
ill. spa approach this section presents a semantic porting analysis algorithm spa.
it detects and categorizes inconsistencies in sequential program flow and incorrect identifier renaming within the scope of a single method.
our key intuition is that semantic inconsistencies in porting arise due to the interactions between ported code and the impacted context when the contexl differ between the reference and the target implementation s. a. overview an overview of the spa process is shown in figure .
to detect potential semantic inconsistencies spa takes as input a reference patch that specifics the syntactic difference s between refold and refncw and a target patch that specifies the syntactic differences between tarmd and tarncw.
we first extract the set of edit operations such as insertion and deletion of program statemenl from the target j ar and reference erer patches.
in step of figure we estimate which of the edit operations correspond to the set of program statements that arc ported from rcf ew to tar ew.
the ast nodes corresponding to the ported statemcnts arc storcd in the ported node pairs pnp set.
we then compute the statements impacted by the ported slatements in the reference ire and the larget ilar in step .
we use standard control and data dependence analyses to compute the impact of the ported statements on the other statements the context .
in step the infonnation computed in the previous steps is used to detect and categori7.c the potential porting inconsistencie s according to the types presented in section ill. finally the inconsistencies are reported in step .
itype afh unadapted indentalion or oommenls is not included in tile scope of our diaglklsi.
as this requires textual or t xical analysis arkl does nol.
involv ihe semanli of code f .... gmen t .
wc illuslrate the spa approach with an example shown in table iv.
the cxample is an adapted vcrsion of code fragmcnts from freebsd.
the codc is portcd from a reference method freebsd4 getfsstat to a target method osfl get fsstat.
lines marked with are the ported code.
the reference and target contexts are syntactically different.
in os fl get fs s tat the ported lines t and a appear after two if statemenl at lines t and t e. no such if statements are present in freebsd4 getfsstat.
also the variable buf is initialized at line tl2.
thus tl3 is in a different data initialization context in the target than il corresponding line re in the reference.
the program statements that are changed between the old and new versions arc highlighted in gray and the ported edil are marked with in table iv.
ported edil is ti0 and tl in tarnew correspond to r4 rs and re in ref ew respectively.
the ported edits in tar w arc control dependent on t4 and data dependent on tl t2 and t12.
also t11 t14 and t1s are data dependent on the ported edits tic and tl3.
all of these statements are treated as impacted statements.
similarly ri r2 and r8 are marked as impacted statements in refncw.
next we present the details of how impacted ported nodes are generated.
b. identify the impact of the ported code we present the thrce main steps to identify the porting con lext that may impact or may be impacted by the portcd codc.
thc inputs to spa are two patches specifying thc syntactic difference s between refold and ref cw and between tarold and tarnew plar ll.
tarold tar cw and pre!
.d refold ref w .
step i. identify edits in the reference and target spa computes the syntactic edit operations insert delete move or uptlate required on the abstract syntax trees asts to transfonn refold to ref .. cw and tarold to tarnew .
this algorithm is inspired by meng et aj.
s edit script generation and extends its implementation r r .
for the code shown in table iv three edit jfl ert operations are identified in the reference patch and five edit operations are identified in the target patch.
spa uses the edit operations to generate the edited nodes er !
and eta .
corresponding to ref and tar respectively.
an edited node cp is an ast node corresponding an edited srntement in a program patch p. the sourcc lines corresponding to the edited nodes are highlighted using a gray background in table iv.
step .
identify ported nodes spa delermincs the cor respondcnce of statements in the ported code between thc reference and the target.
it is possible that when a developer adapts ported code from one context to another she may also insert or delete additionaj code hence there may be edited nodes that do not correspond to ported code.
a ported node pair is a pair of ast nodes r l where r e ere!
and t e blar and rand t have a unique correspondence with each other.
this unique correspondence is detennined by a function clone that takes two arbitrary ast nodes as input and outpul truc if the ast node types are identical and their rei ... reletence ed node.
c .. o!
on !
i ii poooo n do i i d. .
dependent i .... ... t nod .. c 11c ... ic.
ii mil!
ii t ed .
.
.
iii j l i ii ii i fig.
.
spa workflow tarl.e iv exam i ll!
ai oi reil anii simi lli iei i jiit1n j example taken i iiom flllmb sd refnow rl in fr cbbd4 1ctf t t nt tlagb int bufd.e o tatf 05b i lat s bue null lnt error r4 t count but he i ost tf sizeot i r5 nt 5i count .
tatt 5i cof i rt error copyou t o b but i.e return .
ror tl int obfl gctf btat int fla l in bufd.e o fbt tf o b i su tf9 bur null.
lnt error c it tla l gf.tfss tati t5 return te if fla l wait t7 flags mnt wall t9 nt count out i n tatf sizeof .. jug int i.e count.
tatf i.eot jul she jll2 but new tatl i ill onor copront o b buf i.e n. m n. error copyout o b buf ize nturn errori ediloo lin s in a new v .
niion w.r.l.
the old v ni ion are pres nl d in dart back luund.
th portallin s begin with .
the mlli s are inoon isl n sla!t!ment delecloo by st a. labels are also similar above a certain threshold based on bi gram similarity .
a bi gram similarity detects the ratio of the total number of hi grams common between two strings to the average number of bi grams representing the strings.
thc output rangcs from to .
a high valuc indicates that strings are either identical or very similar i.e.
whcn developers rename identifiers lifter porting.
we sct thc similarity threshold to a high value of .
to ensure that the matehed hlbels are very similar each other indicating truly ported nodes.
ouf definition of ported node pair is very restrictive to reduce false posilives in the later sleps we only consider one to one correspondence s between a reference and a target node and ignore node pairs with one to many correspondence s. pnp t t it e eref f t e e ar f clone t t i pnp is a sct of ported node pairs where each pair r t e pnp represents a node ported from a reference patch to a tar get patch as defined in equalion i. each node in the pair t t is referred to as a ported node.
for example.
the nodes corre sponding to statements r5 and t lain table iv have the same ast node type declaration and label si2e count statfs si2e hence done rs tjo is true and r5 tl c is a ported lwde pair.
however no ast nodes in ere!
are syntactically similar to the ast node corresponding to statement til in btar.
therefore tll is no!
a member of any portcd node pairs.
all of the statements identified with in table iv have corresponding ast nodes in pnp.
step .
identify impacted nodes next spa identifies the ast nodes in refnow and tarncw that are either impacted by or impact the semantics of the ported nodes.
the impacted nodes include all of the ported nodes and the subset of the contcxt nodes that may affect the porting semantics or may be affected by the ported nodes.
spa identifies the impacted nodes using slatic intra procedural dala md control dependence analyses 122j with respect the ported nodes.
this step bears resemblance how sydil idenlifies the eonlexl of edit operations using control and data analysis .
data dependence .
statement is datu dependent on if defines a variable tl and uses v such that there exists a path from to along which 1j is not killed redefined .
ontrol dependenc e. statement is cofllrol dependent on .
if execution of depends on the decision made at .
definition .
a program dependence graph p dc on oe is a set of vertices on representing program statements and a set of edges j b !
n x on representing the control and dula dependencies between statemenl .
a control dependenc e graph coo is a sub graph of a pdg where the edges represent control dependencies belween vertices program locations whereas a data dependence graph dog is a sub graph of the pog where the edges represent data dependenc ies between vertices.
in spa we construct the poo vertiees using ast nodes each of which represents an atomic program statement and the edges correspond to the control and data dependences between statemenl .
the impacted nodes in ref and tar .v are derived from thcir respectivc program dcpendenee graphs pdgref and pdgtar.
given a set of vcrtices mapping to ported nodcs vp !
rcf ew and the pix i for rcf cw we generate the impacted nodes irc .
the impacted nodes map to vertices in the pdg reachable from vp along the control and dala dependence edges.
similarly we find itar from vp tarncw.
the vertices corresponding to statements tt and tl in table iv are not control or data dependent on ported code hence they are not in the impact set.
c. detect and categorize porting inconsistencies spa catcgorizes porting inconsistencics according to the types prcsented in scction using portcd node pairs pn p impacted nodes l and liar and thc data and eontrol dcpendence information computed in the previous steps.
icf inconsistent control flow.
to detect icf inconsis tencies spa performs the following steps given a pair of ported nodes t f we construct isomor phic sub graphs starting from r in cdgrer and from t in c dgtar.
a pair of vertices 1jr vi where 1jr e c dgrel and vt e c dgtar is isomorphic if i the vertex labels have identical ast types and similar syntactic structures e.g.
nodcs a a b and x y z have same ast type and syntactic structure and ii the vcrtices have the same relative position with respect to the ported nodes.
we extend komondoor ct al.
s progmm slicing based clone detection algorithm to construct the isomorphic sub graphs.
detect inconsistent nodes in the context with respect to t t and add them to the respective inconsistent sets jcre!
and jctar.
a node in lrp.
itar is inconsistent if it is reachable from r t in cdgrel cdglar but it is not contained in the respective isomorphic subgraph.
the nodes corresponding to statements r4 and in ta ble iv are a ported node pair.
r4 is not control dependent on any node within the method body while hl is control dependent on along the true control edge.
is then added to jctar as it is reachable frum purted node t9 although it docs not have a corresponding nodc in thc refcrence.
ir inconsistent renaming.
to detect this inconsistency we first construct the isomorphic sub graphs on cdgre!
and c dgtar with respect to the ported node pairs as described earlier.
for each isomorphic node pair in cogr and cogtar we extract the corresponding identifiers i.e.
variables types and method names and align them based on their syntactic similarity.
for example given two isomorphic nodes with labels a b c and x y z variable a is aligned with x variable b is aligned with y and variable c is aligned with z. we rank each identifier mapping with a confidence value based on the number of limes the mapping is encountered.
using these alignments we generate two identifier maps a idmuprc a map from each reference identifier to its corresponding target identifiers and b jdmaptar a map from each target identifier to its correspondi ng reference identifiers.
if a one to many or a many to onc relation is found in the maps then an ir inconsistency is detected.
wc consider identifier mappings with the lowest or all when there is a tic confidence valucs as the incorrect mappings and characterize the vcrtiees in the isomorphic sub graphs corresponding to the incorrect mappings as inconsistent.
table v shows an example of j dm apre generated from table iv.
spa generates a map entry os statfs ostatfs from the method signatures and as f1 statfs osflst atfs from the isomorphic nodes r4 and .
sinec the reference variable as f stat f s maps to two target variables osflstatfs and ostatfs an lr inconsistcncy is detccted.
table v idilnt ii ilr mapping from table tv nod.. idenlif .. r ri.t1 r4.t9 sometime s developer s forget to update reluted identijierl as shown in the ir example in table ii.
to detect this inconsistency we carry out a similar process at the granularity of tokens a opposed to identifiers after sepamting identifier names using sepamtors .
or a eamel case convention.
for cxample ofdm is mapped to cck once while ofdm is mapped to ofdm twice.
idf inconsistent data flow.
lof inconsistency detection is similar to our icf diagnosis but uses data dependence graphs dog instead of cogs.
in table iv r and tl are sll.ltem enl corresponding to ported node pair.
in the reference implemcntation re is data dependent on r2 for the definition of variable but.
however statement in the target implementation is data dependent on the definition of buf at t2 and .
although r2 and t2 are isomorphic the dependence on t12 creates an additional data dependence in the target implementatio n that is not present in the reference implementation.
therefore the node corresponding to t12 is added to ictar.
similarly r5 and tic arc statements corrcsponding to a ported node pair and both define variable s i l e. however in the reference implementation si2e is used at statement re while in the target implementation s i l e is used at statements til t13 and t14.
although re and t13 are isomorphic til and tl create additional data dependen ces in the target implementation that are not present in the reference implementation .
therefore the nodes corresponding to til and t arc added to iclnr.
ron redundant operation s. to detect redundant ported code.
spa checks for pairs of vertices in cdgtar that have identical labels and types and that are control dependent on the same impacted vertex.
note that we only look for an ron inconsistency in tarncw.
in table vi statements tl3 and tl4 in the target implementation have identical syntax and both are control dependent on the impacted statement t .
thus spa characterizes the nodes corresponding to statements t13 and t a redundant.
table vi shows the nodes that are inconsistent with respect to the ported code in table iv.
along with their corresponding inconsistency types.
tabu!
vt ciiaitact1!1t!
.atlon porti ll con sistu c!l s i taih.iliv inctliimoicfti !deni rcnami l ir icoiwo0000000l v.i ooci ldi l ludundaru roooet rdn f .
implementation tii.tl2.tl4 tij.tl4 spa is implemented using several existing tool chains.
first.
we extend lase and sydit which extract edit scripts to automate systematic program changes.
spa also extends the control and data dependence analysis of sydit to identify the impact of ported nodes in the reference and target programs respectively.
the dependency analysis uses cry.fta a static analysis framework to amllyzc java source code.
i v. experimental results in this section we present an empirical evaluation of spa s ability detect and diagnose porting inconsistencies in frecbsd unux eclipse cot.
and mozilla.
we compare the aceuracy of the results computed by spa with the results computed by two state of the art lools.
jiang et al.
s clone related error detection tool and dejavu .
jiang et al.
model the context of ported code in tenns of their immediate preceding lines even if the context does nol have any control or data dependence on ported code.
though dejavu exlends jiang el al.
by refining clone detection results to detemline ported code it still suffers from the same limitation as jiang et al.
ll ihe context is identified based on physical location proximity not on control and datn now dependences with the ported code.
we also compute spa s accuracy to characterize potential inconsistencies based on ule categories defined in section u. to this end we investigate two research questions rqi.
can spa aceumtcly detect porting inconsistencies?
rq2.
can spa uceumtcly categorize differcnt types of porting inconsisteneics?
a. srudy subjects to evaluate spa we use porting cxample.
from four dif ferent projects frecbsd linux.
eclipse cot and mozilla.
execpt for mozilja the reference and target patches for eaeh artifact are computed using repertoire .
from these.
we randomly select a examples rom freebsd.
b exam ples from linux c examples from eclipse cdt that are ported from cot versions cdt 2 0 to cdt 8 1 1 and d mozilla examples from the annotated data set of copy pasle errors provided by gabel ct al.
.
the freebsd and unux artifacts are from the data sel used in section ii.
to retrieve a large number of porting instances we choose cdt 2 c and cdt e l l versions which are months apart.
the mozilla examples were obtained from dcjavu s annotated data setl because dcjavu is not an open souree tool.
ln the morilla examples we treat an entire progr.un as a progmm patch whose old version is empty because spa works on program patches as opposed to entire programs.
we use a combination of commit logs and manual inspection to annolate the types of potential porting errors in selected target patches of the subject artifacts.
the current version of spa analyzes only java souree code so we convert the c and c porting examples from linux freebsd and m07.illa examples using a free ac java code converter ii.
b. study methodology we measure si a s cupability to detect and categorize port ing errors in terms of precision and recall.
for each error type c defined in section ii suppose that s is the set of examples where a porting inconsistcney is detected by spa and it error type is reported by spa to be c. suppose that a is the set of examples where a porting inconsistency is manually detennincd to be of type c. then thc precision and recall of spa in categorizing jxirting inconsistencies are defined as follows precbiion.
the perecntage of porting ineonsislencie.
iaf iff!
e found by spa that are also known to be type e i.e.
recall.
the pereentage of the icnown inconsistencies of trre which are also found to be type e by spa i.e.
iai is to evaluate the accur.tcy of spa s error detcetion capability we calculate precision and recall without considering individ ual error types.
c. study res l u and discussions rq i. can si a accurately detect porting inconsistencies?
we compare spa s ability to detect porting inconsistencies with liang et al.
s clone related bug detection algorithm 19p and dejavu 6j.
tuble vo sununarizes the comparison of spa with jiang et at using the eclipse cot artifact and with dejavu on the mozilla examples.
the first row represents the number of potential porting errors regardless of error type that were detected by the respective tools.
we also report the number of false positivc.
false negatives precision and recall of the error detcetion capability of each tool.
the re.
ults of our study show that si a improves the error detection capabilitic.
considembly over jiang el at spa improve.
the precision from to .
and marginally improves the recall from to .
out of the randomly selected examples from the dejavu annotated mozijla dma sel our manual inspection shows that only of them eont lin true porting inconsistencies.
thus dcjavu s precision is .
.
for the same data sct spa reports inconsistencies for examples.
thus spa s precision lhllp jlwwwcsif.
c .licdavis.edul gabcvresearchidejavu mozilla.zip jiang et al.
s clune okleelor deckard and the associated clune bug okteelor were duwnload.
t.i from hl1ps llgilhub.cumlskyhcwerldechrd.
in detecting errors on the mozilla data set is .
as shown in table vn.
because this data set docs nut cuntain any examples where dcjavu fails to report an inconsistency we are unable to assess the number of fajse negatives for either dejavu or spa.
furthennore because our comparison is limited to the data set where dejavu already found porting inconsistencies the precision of spa could be lower if the comparison was done on a different data set.
we find that spa reduces false positives over jiang et al.
s tool and oejavu in and cases respectively.
for example consider a case when a variable is initialized differently in the referenec and targct contcxts.
later both the referenec and the target contexts reinitialize the variable in the same manncr before using it in the ported code.
in this case spa correctly does not report any inconsistency unlike other tools because there is no data now between the inconsistent initialization and the ported code.
the cases where all three tools incorrectly detect inconsis tencies include porting code from a while comext to a for context porting code from an if context to a switch case context ctc.
table vii inconsistency detection results for eclipse edt and mozilla eclipse cdt mo illa spa jia i s tiklt spa ikjavu detected fatse positive is false negative precision .
.
.
.
recall .
iihj9 companson is done on dala sct whci c ocjavu already rcpot1ed porting errors.
rq2.
can spa accurately categorize diftcr nt typcs of purting inconsistcncies?
table vlii shows the precision and recall for spa iii categorizing potential porting errors in freebso and linux for the error types jcf ir i lr idf and ron.
spa has precision ranging from for icf to for rdn.
the recall for spa ranges from .
for rdn to for icf and idf w.r. .
the porting errors reported in the version histories see 2nd row in table vili .
version history based evaluation is often conservat ive in the sense that when there is taille viii inconsistenc y cliiirilcteiliziltlon iie.
ui.t.
on fltmlhsd lind llnux icy fr t fr l loy rdn sf 1i detected !
rom commit logs precision so .
.
.
recall .
.
manually annotated precision .
.
.
recall .
.
no mention of porting errors in the commit messages it docs not necessarily imply thc absenec of porting ineonsistencics.
to uvereome this limitation we cumpare spa results against the type and location of inconsistencies that were identified by manual inspection of individual patches.
the comparison against this annotated set is shown in rows in table viii.
table ix summarizes the number of porting inconsistencies for each error type and the precision and recall based on the manually identified error types for eclipse cot and mozilla data sets.
in eclipse cot spa detects and characterizes porting inconsistencies arc lcf are jr i j2 arc ir and are idp.
in mozilla spa detects instances of porting incunsistencies of which and arc of type jcf ir i fr and idf respectively.
no ron inconsistency is reported in these two data sets.
on average spa achieves precision and recall in eclipse cot and precision and recall in moziua data set.
in detecting icf inconsistencies spa may report false posilives when for example code is ported from a for block to an equivalent while block because these two loops have different syntaxes.
spa may gencrale a false positive of type jr i when the relative ordering of program variables is changed but the semantics remain unchanged e.g.
a statemcnt x x y in the reference implementation is modified to x y x in thc target.
when characterizing fr inconsistencics spa may report false positives when for instance the names cannot be tokenized properly due to inconsistent naming conventions.
for example if a ported node pair contains the variables foobar and foobar spa correctly splits the first one into faa and bar but does not split foobar.
thus spa misaligns the tokens.
in the case of iof inconsistencies spa may report a false positive when for example a variable is declared and defined in a single program statement in the reference but the declamtion and definition arc separate statements in the target.
here spa reports an inconsistency because the ast node types are different declaration versus assignment .
with respect to false negatives spa is not able to detect redundancie s that require a deeper semantic analysis such as redundant locking calls in a concurrency construct.
in spite of these limitation s there are some suc cess stories.
a bug was fixed in freebsd souree file src sys dev rn xge if rnxge c version .
with a commit message .
fix an mhuf leak caused hy a cul pasle hug where the small ring s mhuf were never freed.
hw the hig ring was freed twice .
a buffer rx big was mistakenly freed twice.
spa detects this bug successfully and categorizes it as an ron bug which is also confinmxl by the dcvelopers and took releases and days to detect and fix.
jiang et ai s tool is not able to detect this bug since it does not handle redundancy.
another identifier renaming bug was fixed in linux at commit id 2b9460.
code was ported from method rnlx4 ib post send to rnlx4 ib post recv but variable send cq was never updated to recv cq.
this bug caused a queue overflow in the infiniband driver module a high speed network driver and took days to fix.
spa table x spa inconsistency diagnosis results eclipse ci t icf ir i ir ldf si a detedoo .
annotated fa se positive false negative i prcdsion .
.
.
recall .
.
.. oo successfully detected this error.
olher tools were unable to detecl this error because they do not check whether related variables were updated eonsistenlly lr .
v. related work juergens ct al.
110j conduct an empirical study on the impact of inconsistent clones in a code base.
they detect inconsistent clones using a suffix tree based lex.icaj clone deteclion algorithm.
their interviews with developers confino that inconsislencies in the found clones are indeed bugs and report that .
nearly every second unintentional incon.
istent chankes to clone.
lead to a fault.
chou et al.
show that porting is an important source of bugs in operating systems .
in of the ported code at least one identifier is renamed and in cases at least one statement is inserted modified or deleted .
an incoltect adaptation of ported code often leads to porting errors .
this observation is aligned with our findings where we find and porting crrors by mining frecbso and linux.
version histories respectively.
using cp miner a mining based clone delection tool li et a!.
find and eltors in linux and freebsd respectively which developers created by forgetting to rename identifiers consistently after copy and paste .
jablonski et al.
detect similar errors by tmcking eopy paste cooc within an eclipse ide and by comparing the corresponding ast rep rescnrntions.
though the rcsults of these studies are aligned with our findings of ir inconsistencies we observe that such inconsistent renaming is a special case of a more general cate gory of porting inconsislencies forgetting to adapt identifiers according to the target contexi ir l and ir .
spa detccts a broader scope of inconsistcnt rcnamings by tokenizing function names file names and identifier names us ing a camel case naming convention and mapping correspond ing iokens.
our algorithm detects an inconsistency when a loken in one context maps to multiple lokens in the other con text.
for example when code is ported from export ava to import ava spa checks whether all names related to export are updated to import .
jiang el al.
show that an inconsistem context can also cause porting errors .
however their definition of context is limited to the innennosl comrol how construct surroundin g the cloned code.
they identify syntactic clones using ast level similarity and then detect inconsistencies by comparing the contexts.
while their diagnosis partially overlaps with our mozina total icf ir i ir idf total .
.
.
.
.
.
i 1l1c o tcncy categori7.ation of porting errors icf and ir i they do not report renaming errors on groups of identifiers ir data flow inconsistencies idf or redundant opemtion s ron .
also their error detection analysis is purely syntactic and thus suffers from a higher rate of false positivcs than our semantic control and data flow based approach.
spa reports percentage point better precision and percentage point more recall in detecting porting inconsistencies than jiang et al.
on the eclipse cot data set.
deja vu extends the work by jiang et a!.
by using severaj filtering heurislics such as assessing textual similarity and pruning non cloned contexts to improve its precision .
as shown in our evaluation spa s error detection still out performs dejavu with percemage point better precision.
also dejavu does noi report potential error types while spa automatically chamcterizes the detected inconsistencies to hclp developers detect porting errors.
vi.
conclusion when porting code from one contexi to another the se mantics of the ported code often change due to differences in the surroundin g comexts.
developers may overlook such subtle differences inadvertently creating a porting error.
by analyzing the version histories for linux and frccbsd wc identify five common categories of porting errors and then usc this categorization to design spa a novcl algorithm to detect and characterize semantic inconsistencies in ported cooe.
our evaluation of spa on seveml large open source code bases shows that spa can detect porting inconsistencies with high precision and recall and it outperfonns the precision of two state of the art techniques with to percentage point.
as part of our future work we plan to investigate methods for further reducing false positives such as comparing the dynamic program behaviors of ported code.
based on the observation that not all inconsistencies lead to an error we also plan to investigate heuristics to rank the inconsistencies based on their error potemial.
finally we plan to integrate spa with an integmted devclopment environment so that developers can detect porting inconsistencies during the porting process.
acknow ledgment we thank na meng for the discussions that inspired the design of the spa algorithm and for her help in reusing the implementation of sydit and lase.
this work was supported in part by the national science foundation under gmnts ccf1149391 ccf shf j08 and cns .
referen ces iii c java converler hup lf ngiblewftwaresolutions.oom.
crystal a stalic analysis framewort for edocalioo and resean h hup jfoode.google.comiplcrystlilsaf .
r. ai ekram.
c. kaps.er.
r. holt.
and m. godfrey.
cloning by accidenl an empirical study of source cock cloning us !
!ioi tware y 1em .
in mpiricuj s a eii int t rintl .
page !
p. nov. .
a. chou.
j. yang.
.
chelf.
s. hallem.
and d. engler.
an empirical ... udy of operuling systems mur.!.
in proct!edinxs ofrm eixlu ii aem rymposium .... opulliinx syslem.
principles.
sosp .
pages new york ny usa.
.
acm.
lsi b. f1uri m. wijrsch.
m. pinzger.
aoo h. c. gall.
change distilling iree differencing for fine grained source code change extraction.
ieee trnlullcliqiis sofl wll enginuring .
november .
m. gabel j. yang y. yu.
m. goidszmidl and z. suo scalable and syslemalic detcclion or buggy inconsistenc ies in source code in proct!edings q ille aem i ertwliqlla ron ul!nct!
qn objecl qrie ed programming syslem li1gu lgu and appficaliqtls.
oopsla .
pages .
new york.
ny.
usa .
acm.
p. jablonski and f .
i ou.
cren a for loading copy and pa le code clones aoo renaming i lenlifiers consi.
lently in the i le.
in i m udin g .
of ille ooi sia bll on ee ip .
e lechlu logy exdulnge eclirse pages .
nt.
w york.
ny.
usa.
.
acm.
l. jiang.
g. misherghi.
z. suo nd s. glondu.
deckard scalahle and accurate tree hased tjclc .1ion of code cloile.
.
in f rocudings oflm i enwlimwl evnlelv!ncti .... !iv11w l1v!
engineering.
icse .
pages 96los.
washington dc usa.
.
ieee col11puk.
t socicly.
l jiang z. su and e. chiu.
contellt bascd delcelion of clone related bugs.
in e.s c fs procudingt of liu!
lite joinl muling of 1m ropron !iv1 u1v!
enginuring con t!fi!nct!
!lid 1m acm sigsoft symposium oft tht!
lif iij of so t if t!
enginuring pages s5 .
new york ny.
usa.
.
acm.
e. juergens.
f. ikissenboe.
k u. ilummel and s. wagner.
do rode clonc s maller in proc di ij1 of tilt!
.
iniertullwnu cotr t!fi!tlce 0fi soft d1 t!
engillt!t!ring.
ic.
e pages washington oc usa .
ieee compukr society.
iii i t. kamiya s. kusumoto.
and k. i .
ccfinder a mullilinguislic token h a. cd cock clone lelcction syskm for louge scale soun e cock.
ratuucf ?iu i .... sn iw lf t!
eiigin ring.
.
.
m. kim.
1 bergman t. lau.
and d. notkin.
an etlmogoaphic study .. f cupy and pa. tt progr.mming jlf .k.1k e. in pl.
in ises proceedinll tile 2ofj.i inlenwlilltull s mposiwn qii empirical sn w lf t!
j!gillt!t!r1ng pages .
w .... hin ioo dc usa .
eee compute.
society.
r m. kim v. sa caw t d. nolkin.
and g. murphy.
an empirical study of code clone genealogies .
in eseclfse i1 proc dings 1m iotil uropt!lllf sofj t!
enginet!ring con tffl!fiu mid joinl ilh acm sigsoft inlef1wliotwi symposium on foutrtkuioru sofj af t!
engi rin g. pages new york.. ny usa.
.
acm.
r r. komondoor and s. lforwib semantics preserving procedure cliiil1c lioo.
in .
proc dingl of 1m 271h acm sigpi..an sigact sympos m on pri... ples of programming languages.
pages is5 i69 new york.
ny.
usa.
j j .
acm press.
lsi li.
s. lu.
s. myagmar.
and y.
71tou.
cp mideic a tool for linding copy paste aoo related hugs in oating !
tem cock.
in pm eedings i lire ron ef t!ncl!
ihi symposium oft o arling syslem.j ihsign of lmp e nl l ti .. iu .
05di .
pagel!
.
berkeley ca usa .
usenix as.wc alioo.
n. meng m. kim and k. s. mckinley.
systematic editing generating progrom transfonnations from an example.
n procuding s lire 32nd acm sigpu n cljii ullnctf uil progrumming language design urd imp emt!nll lliull.
ldi pages new york.
ny usa .
acm.
n. meng.
m. kim and k. s. mckinley.
lase localing and applyitlg syslematic edit by learning ff q1ii e alllp ies.
in procuding s ollhe in un lliomi cqiile nu on soii 11f t!
f ginuring icse pages sii i iscalaway.
nj.
usa.
.
ieee press.
.
kay aoo m. kim.
a ca.o c study ofcn s. .ystelll porting in forked projects.
in i roc t!dingj rile acm slgsoj t 20lh intertullimwl sytnllllsium n 1m foundalions of so nmf t!
en1l.illt!ering.
fse pag .
new yon .
ny usa.
.
acm.
b. ray c. wiley.
and m. kim.
reper1uire a cros.
sys tem porting analy i for forked software projects.
in fse acm sigsoft 1m 20tll intertull dmj symposium ?ii the i oundlilinns nf sofr .. d eng lit!tfring.
acm.
to appear.
ii m. kiseman and a. r. han ...... a conlej tuai poslp ccssing symm for error com clion u. ing binary n gr.uns.
ira..... compul.
s 4l!o may .
j. sliwer.
ki t. zimmennatln.
and a. zeller.
when do changes induce lil cs?
in j roc dinilj of tlte international worlcslwp on mining w i df t!
rrposi rit!s msr m. pages i s new york ny.
usa.
2oos.
acm.
m. weiser.
i rogr.utl slicing.
in pwcudinp o im inlt!nwlional ctjii e nct!
oft sn i lf t!
engintuing icse .
pages piscataway.
nj usa .
ieee press.