puzzle based automatic testing bringing humans into the loop by solving puzzles ning chen and sunghun kim the hong kong university of science and technology hong kong china ning hunkim cse.ust.hk abstract recently many automatic test generation techniques have been proposed such as randoop pex and jcute.
however usually test coverage of these techniques has been around only due to several challenges such as the object mutation problem where test generators cannot create and or modify test inputs to desired object states and the constraint solving problem where test generators fail to solve path conditions to cover certain branches.
by analyzing branches not covered by state of the art techniques we noticed that these challenges might not be so difficult for humans.
to verify this hypothesis we propose a puzzle based automatic testing environment pat which decomposes object mutation and complex constraint solving problems into small puzzles for humans to solve.
we generated pat puzzles for two open source projects and asked different groups of people to solve these puzzles.
it was shown that they could be effectively solved by humans out of puzzles were solved by humans at an average speed of one minute per puzzle.
the puzzle solutions helped cover and additional branches .
and .
coverage improvement in the two open source projects on top of the saturated branch coverages achieved by the two state of the art test generation techniques.
categories and subject descriptors d. .
testing and debugging testing tools general terms human factors reliability keywords testing human computation code coverage .
introduction software testing is a difficult but important part of the software development process.
however manual test case writing is labor intensive.
though many automatic test generation techniques have been proposed their coverage needs to be improved.
for example our evaluation study shows that only .
and .
of the total branches of the two subjects were covered by test cases generated by a state of the art approach .
other approaches based on dynamic symbolic execution dse like pex and jcute yield similar coverage results when applied to complex real world programs .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.the low test coverages are largely due to challenges of generating test inputs especially when the approaches are applied to object oriented programs.
the major challenges include insufficient objects complex constraint solving and object mutation .
first to construct test cases for object oriented programs objects need to be instantiated.
however the process of instantiating a valid object is often not straightforward.
this issue is partially addressed by and which capture objects from program executions or code repositories and reuse them as test inputs.
second it is necessary to solve path conditions to create and or modify test inputs to cover paths.
to solve path conditions automatically various satisfiability modulo theories smt solvers such as yices and z3 have been proposed.
however these solvers often yield limited results when used to solve certain forms of path conditions such as floating point non constant bit vector and non linear modulo arithmetic .
as shown in figures a and b a state of the art smt solver yices cannot solve these path conditions.
path condition foo .x n foo .y n a a simplified non constant bit vector example taken from apache commons math .
.
at multikeymap.java path condition foo .x bar .y n b a simplified non linear modulo example taken from apache commons math .
.
at extendedproperties.java figure path conditions unsolvable by a state of the art smt solver yices.
a path condition solution model specialcontainer .size figure an example of object mutation challenge third even when valid objects are instantiated and solutions to path conditions i.e.
models are obtained objects still need to be mutated according to the models before using them as test inputs.
for example if we have instantiated a valid specialcontainer object and have obtained a model as shown in figure for a path condition satisfying the model is still hard since automatically figuring out ways to increase the size of this specialcontainer can be non trivial.
satisfying a model even as simple as this by mutating objects may require extensive and sophisticated static and orpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
dynamic analysis.
for example in the authors have applied various static analysis techniques to automatically mutate objects based on solution models but the result was limited.
in the authors identified the object mutation challenge as the most significant cause of the low test coverage of the state of the art test generation technique pex.
however the constraint solving andobject mutation challenges presented in figures and might not be so hard for humans since we are very good at finding logic and rules quickly.
for example humans can quickly figure out solution foo.x foo.y n for figure a and solution foo.x bar.y n for figure b .
based on this observation we propose a puzzle based automatic testing environment pat which decomposes constraint solving and object mutation problems into small puzzles that humans can solve.
we evaluated pat by generating puzzles for two open source projects and asking humans to solve these puzzles.
our evaluation results showed that humans voluntarily played the presented puzzles and could solve them quickly and effectively of the presented puzzles were solved by humans and each puzzle was solved in less then one minute on average.
these puzzle solutions improved coverage by .
and .
in two open source projects on top of the very saturated test coverages achieved by state of theart automatic test generators which is non trivial.
we compared the effort of writing test cases without pat and found that solving pat puzzles is more efficient than writing test cases manually.
in addition solving pat puzzles does not require any programming skills or domain knowledge of the subjects.
in our evaluation none of the participants had domain knowledge but they improved test coverage significantly by solving pat puzzles.
this paper makes the following contributions a novel puzzle based testing environment that generates useful test cases through puzzle solving by humans.
an implementation of the proposed approach pat.
an experimental study to evaluate pat.
the rest of the paper is organized as follows.
section surveys related work.
section presents a motivating example.
section presents the detailed design of pat.
section presents evaluation results.
section discusses threats to validity.
finally section concludes.
.
related work .
automatic test generation many automatic test generation techniques have been proposed such as randoop which is based on random approach to generate test inputs.
michael et al.
proposed another random test generation technique based on genetic algorithm.
generates test inputs by symbolic executions.
pat is designed to work as complementary to all these automatic test generation techniques to achieve higher test adequacy.
dynamic symbolic execution dse such as generates test inputs by solving path conditions captured along dynamic execution paths.
this technique combines concrete execution with symbolic execution to achieve high test coverage.
however complex constraint solving and object mutation for object oriented programs have always been challenging.
xiao et al.
reported that complex constraints which cannot be solved by smt solvers and the object mutation challenge account for nearly of branches not covered by pex a dse framework for c .
erete et al.
also demonstrated limitations of smt solvers in constraint solving.pasareanu et al.
tried to enhance classical symbolic execution techniques by partially addressing the complex constraint solving challenge.
their approach splits complete path conditions into simple and complex subsets.
information from the simple subset of the path conditions and concrete executions are leveraged to simplify the solution of the complete path conditions.
however their approach has limitations since information from the simple path conditions is not always adequate to decide the satisfiability of the complete path conditions .
pat can complement this approach by leveraging humans to solve the complex constraints for smt solvers but may be easy for humans even when the simple path condition information is inadequate.
thummalapenta et al.
proposed mseqgen which mines existing code bases to extract call sequences that can create objects and mutate them.
this approach relies on existing code bases and may not find all necessary call sequences.
pat complements it by transforming object mutation into puzzle solving and leverages humans to help mutate the objects.
pat is a novel framework for decomposing complex constraint solving and object mutation challenges and presenting them as simple puzzles to humans.
through solving puzzles generated by pat humans can help address the challenges in automatic testing.
.
human computation human computation has been an emerging area in computer science .
several projects have been put on the internet and are open to the general public such as foldit recaptcha1 the esp game and pex4fun .
the main idea of human computation is that though humans compute at a much slower pace than ordinary computers they are capable of solving many things that computers cannot.
for instance the recaptcha project digitizes books with help from millions of online users typing captchas everyday.
the underlying idea of this project is that humans can easily recognize words more precisely than computers.
so with the help of human resources available on the internet millions of words not recognized by computers can be easily digitized.
most recently human computation has received attention in the software engineering area also.
dietl et.
al designed verification games which can be used to verify program properties with the help of human players.
pat is inspired by these human computation projects.
we also believe that humans even without much domain knowledge of testing subjects can help software testing by solving simple object mutation and constraint solving puzzles.
.
motiv ating example figure presents a motivating example taken from apache commons math .
which demonstrates the two major challenges in automatic test generation techniques.
in this code snippet the vectorialcovariance.getresult method creates an object of type realmatrix by calling a static method matrixutils.createrealmatrix line a .
the matrixutils.createrealmatrix method then calls the constructor of either array2drowrealmatrix orblockrealmatrix line b .
if the array2drowrealmatrix constructor is called it further invokes its parent constructor abstractrealmatrix illustrated in figure c .
after creation of the realmatrix object the getresult method proceeds to a conditional statement where the execution flows to different branches according to the value of member field n line a .
suppose the branch at figure a line has never been covered by existing test cases and we want to generate new test cases to cover this branch.
realmatrix getresult int dimension sums .length realmatrix result matrixutils .createrealmatrix dimension dimension if n double c .
.
.
target branch to cover .
.
.
return result a vectorialcovariance.getresult public static realmatrix createrealmatrix final int rows final int columns return rows columns ?
new array2drowrealmatrix rows columns new blockrealmatrix rows columns b matrixutils.createrealmatrix int int protected abstractrealmatrix final int rowdimension final int columndimension throws illegalargumentexception if rowdimension throw mathruntimeexception .
.
.
if columndimension throw mathruntimeexception .
.
.
lu null c abstractrealmatrix.abstractrealmatrix int int figure a motivating example from apache commons math .
object mutation challenge the first challenge of covering this branch is object mutation .
given a model satisfying some path conditions generating mutating an object to the desired object state without breaking class invariants is challenging .
without the necessary test inputs in the correct object states the target branch may not be covered.
the object mutation challenge surfaces when the model for covering the target branch requires non publicly accessible fields to have certain values or external library calls to return certain values.
a model this instanceof vectorialcovariance this .sums instanceof double this .sums .length this .n figure a model satisfying the path condition in figure for example figure is a model satisfying the path condition in figure for the target branch figure a line .
in this model line requires that a vectorialcovariance object s private field sums have a length of .
similarly line requires that the private field nshould have a value of .
since both fields are private and no direct setters are defined in the class for changing their values mutating vectorialcovariance to satisfy the model is a non trivial task.
for this challenge human computation might be helpful in that by observing the effects of executing member methods or even just observing the method names humans may recognize and generalize rules about the effects of these methods.the generalized rules can help mutate an object to satisfy a given model.
.
constraint solving challenge in typical dynamic symbolic execution approaches path conditions need to be retrieved along different program execution paths.
for instance along the path getresult createrealmatrix abstractrealmatrix getresult in figure a path condition is retrieved figure .
path condition this notnull this .sums notnull this .sums .length this .sums .length this .sums .length this .n figure path condition along an execution path however when the approaches try to compute models for certain types of path conditions such as those containing non linear or floating point arithmetics smt solvers may return an error.
for example a state of the art smt solver yices fails to compute a model for the path condition in figure with an error message error feature not supported non linear problem.
due to constraint .
even though there might be other smt solvers which provide stronger support many theories such as non linear arithmetics are undecidable.
in addition some weaknesses in smt solvers are demonstrated by .
without a necessary model satisfying the path conditions these automatic test generation approaches would not be able to create the necessary test inputs to cover the corresponding target branch.
for this challenge human computation can be helpful since some of these arithmetics might not be too difficult for humans.
based on these observations we propose pat a framework which tries to leverage human intelligence to help address the two challenges to improve test adequacy.
.
design and implementation this section presents the overall design and implementation of pat.
in general two types of puzzles are generated for the not covered branches.
puzzle solutions by humans are then used to generate test cases automatically.
figure presents the architectural design of pat which consists of five main phases up front testing runs path computation mutation puzzle generation constraint solving puzzle generation and finally test case generation from puzzle solutions.
initially pat runs test cases generated by several state of the art automatic test generation techniques to obtain a code coverage report together with various dynamic information.
based on the coverage report pat collects all branches not covered by the up front testing runs.
then pat tries to find program paths along with models which satisfy the path conditions by a symbolic execution algorithm for each of the not covered branches.
for branches which have feasible paths along with models that satisfy the path conditions but contain difficult to mutate fields such as the one in figure pat transforms the mutation problems into object mutation puzzles.
for branches for which pat cannot find any feasible program paths to cover in phase due to the smt solver s limitations pat decomposes the path conditions of the branches and transforms them into constraint solving puzzles.
finally puzzle solutions obtained from humans are automatically analyzed and converted into executable test cases.
the following subsections describe each phase in detail.142figure the architecture of pat.
.
up front testing runs in this phase pat runs test cases automatically generated from various state of the art automatic test generation techniques .
there are two main purposes of the up front testing runs.
first all automatically coverable elements are covered.
up front testing runs phase makes sure that human efforts are not spent on elements that can be effectively covered by automatic test generation techniques.
the second purpose is to collect dynamic information from the executions including object instances generated during executions and the method call sequences.
a method call sequence is the sequence in which methods call each other.
object instances are captured through the object capturing code inserted using the asm library.
the captured objects are saved and later restored using the xstream framework.
the dynamic information is essential to facilitate path computation and puzzle generation phases of pat.
after the up front testing runs pat obtains a detailed coverage report and identifies elements e.g.
branches not covered by automatic test generation techniques.
these not covered elements become targets of the later puzzle generation phases.
.
path computation from the coverage report of the up front testing runs pat identifies the set of not covered elements i.e.
branches .
our goal is to construct test cases which can effectively cover these elements.
to achieve this goal for each of the not covered branches pat looks for feasible execution paths covering the branch together with the corresponding path conditions.
our approach can be viewed as an instance of the weakest precondition computation similar to .
our approach is an inter procedural path sensitive and context sensitive backward symbolic execution algorithm.
pat first transforms the subject program from java byte code into static single assignment ssa representation using wala .
it then performs the symbolic execution from a target branch and runs backward to the entry of the current method which the branch is in.
if the current method is public the symbolic execution terminates.
otherwise pat finds a caller method of the current method from the method call sequence information collected during the up front testing runs.
the backward symbolic execution continues from the call site of the caller method to its entry.
this process continues until it reaches a public method s entry or pat cannot find any caller method anymore.
during the backward symbolic execution pat collects and propagates a set of path conditions represented in a symbolic manner along the backward execution path.
thus when the symbolic execution is completed a set of path conditions representing the necessary conditions to reach the target branch from a public method s entry is retrieved.
pat then tries to solve the set of path conditions using an smt solver yices .
if the set of path conditions is satisfiable a model is returned from the smt solver.
otherwise the backward symbolic execution is restarted by backtracking to an alternate backward path at the nearest program branching point.
the process of collecting feasible execution paths and the corresponding path conditions for a branch is completed when pat hasobtained a certain number currently of models corresponding to different execution paths.
termination handling however when computing feasible paths of a branch the above approach might run forever because of the undecidability problem in software verification .
this problem is generally caused by loops and recursive calls in the code.
to address this issue two parameters are introduced that limit the maximum number of times a loop can be unrolled and the maximum invocation depth allowed.
hence under the restrictions imposed by these two parameters the path computation process for each branch can enumerate every possible execution path within a finite number of steps and guarantee termination.
however under such approximations the computation approach becomes neither sound nor complete.
in our experiment we set the two parameters to two and five.
we also impose two additional bounds to the path computation phase to make sure it can terminate within a reasonable time the maximum computation time for one path is limited to seconds and pat is allowed to invoke the smt solver for at most times in the path computation phase for each branch.
.
mutation puzzles for branches which have valid models satisfying the path conditions but do not have test inputs satisfying these models pat generates object mutation puzzles from these models.
as indicated in section generating test inputs satisfying models automatically might not be a trivial task in object oriented programs since not all fields are directly assignable.
therefore we leverage human intelligence to help address this challenge.
to satisfy a given model we need to mutate one or several objects into certain object states.
for instance for the model in figure we need to mutate an vectorialcovariance object into an object state where field nhas a value of and field sums has a length of .
if such fields are public pat can simply assign the corresponding values to them.
however if they are non public pat needs to figure out a sequence of method calls that can mutate an object to this goal state.
the objective of object mutation puzzles is to obtain such a sequence with human help.
.
.
generating sub models model in notnull in.readint this .currentstate null a a complete model sub model in notnull in.readint sub model this .currentstate null b the divided sub models figure sub model division instead of presenting an entire model directly pat divides a model into several sub models to make the generated puzzles as simple as possible.
a sub model represents the goal state of only one object reference such as the callee or a parameter.
figure illustrates one such division.
the complete model in figure a is divided into two sub models in figure b to represent goal states143figure screenshot of mutation puzzles.
panel is the object state panel showing the goal and the current object state.
panel is the object panel showing the current mutating object.
panel is the action list panel that lists available actions with parameters.
ofinandthis separately.
the solution of the complete model can be retrieved by combining solutions of all individual sub models.
the retrieved solution is correct as long as the solutions to the individual sub models are independent of each other.
this means that the solution to one sub model should not affect solutions to any other sub models.
.
.
prioritizing sub models before generating puzzles pat first prioritizes all sub models to make better use of human efforts.
the key insight for prioritizing sub models is that one sub model can be shared by many different models.
for example sub model in figure is identical to sub model in figure b .
sub models shared by many different models are assigned higher priorities.
sub model in null sub model this .currentstate null figure another set of sub models .
.
generating puzzles for sub models after prioritizing the sub models object mutation puzzles are generated for them.
puzzles generated from sub models with higher priorities are presented earlier.
figure presents the interface of an object mutation puzzle generated from a sub model.
when designing the puzzle interface we want to make it as simple to play as possible such that humans can learn to play it within a few minutes.
on the puzzle interface there are three different panels namely the object state panel the object panel and the action list panel.
the object state panel comprises two sections.
the upper section shows the goal object state that should be satisfied in the puzzle.
the bottom section shows the current object state.
the object panel shows the object currently being mutated.
users can also save any intermediate object instances in the object cache section of this panel.
finally the action list panel lists all public member methods actions in button style.
thus users can invoke different member methods by pressing the corresponding buttons.initially pat tries to instantiate a set of objects of the type specified by the sub model.
there are two different ways by which pat can instantiate objects load from the set of previously saved objects or find and invoke the constructor that takes no parameter.
if both fail pat tries to instantiate objects of the sub classes until a set of objects is instantiated or there are no more sub classes to try.
if a set of objects is successfully instantiated a random object in the set is used as the current object.
users can easily change the current object by pressing the next object button.
to perform an action users can press any action button from the action list panel.
parameters are assigned in the following manner if it is a primitive type parameter users can simply type in the primitive value such as .
ortrue if it is not a primitive type parameter users can press the load object button to instantiate an object of the corresponding type and use it as the input parameter.
the mechanism of instantiating a parameter object is the same as the mechanism of instantiating a current object for a mutation puzzle as previously described.
if no object is loaded a null value is used.
after filling in all parameters users can press the execute button to execute the action.
after an action is executed pat immediately re evaluates the satisfaction of each model line in the object state panel.
once a model line has been satisfied by the current object state pat turns its color to green in the current state section.
the puzzle is considered solved if all model lines of the sub model have turned green and the solution is automatically saved into the server database.
the solution of a puzzle consists of all previously executed actions i.e.
method calls along with the input parameters.
.
.
providing hints since there can be many available actions in the action list panel we want to further simplify the solution of puzzles by recommending a set of potential actions to humans.
pat conducts a static analysis to identify all actions containing statements which can change the value of at least one field in the sub model.
all such actions are recommended to users by highlighting them in yellow.
figure demonstrates the simplified pseudo code for finding recommended actions in a target class.
for each method in the target class we analyze each of the instructions in the method.
if the current instruction is an assignment144input the target class of the mutation puzzle.
input the target fields which we want to change.
conduct points to analysis and build call graphs.
foreach method in the target class foreach instruction in the method ifit is an assignment instruction ifthe assignee is one of the target fields mark current method as recommend .
break ifit is an invocation instruction ifcallee has not been analyzed before recursively analyze if callee is recommend .
ifthe callee method is recommend mark current method as recommend .
break output all methods marked as recommend .
figure pseudo code for finding recommending methods instruction which assigns values to one of the fields appearing in the sub model we mark the current method as recommend .
if the current instruction is an invocation instruction and the callee method has not been analyzed before pat recursively analyzes the callee method of this invocation.
the current method is marked as recommend if the callee method has been marked recommend .
we limit the maximum recursion level of the analysis to to avoid infinite recursion in the presence of cyclic calls.
global lists of recommend andanalyzed methods are maintained during the process to avoid redundant analysis.
in figure actions vectorialcovariance int boolean clear andincrement double are highlighted because they can change either this.n orthis.sums or both.
.
.
solving the puzzles a typical scenario to solve the puzzle presented in figure is as follows.
a player observes the list of available actions.
judging from the action names argument types as well as the highlighted hints the user should be able to infer a group of candidate actions quite easily.
after a few attempts on the candidate actions the player may soon find out that model line can be satisfied by invoking action vectorialcovariance int boolean with as the first parameter value.
similarly invoking the highlighted actionincrement double with a double array increases this.n from to this field has already been reset to in the first action .
thus model line can be satisfied by invoking this action twice.
in this way the presented sub model is satisfied and all actions are recorded automatically.
.
constraint solving puzzles in case of branches for which pat cannot find any feasible paths to cover in the path computation phase pat goes on to examine whether the computation failures are due to smt solver limitations.
as indicated in section even though some particular forms of path conditions such as those containing non linear arithmetic are not solvable by the smt solver it does not necessarily mean that they are naturally difficult for humans.
when such path conditions are found pat extracts the not solvable constraints from these path conditions decomposes them and presents them to humans in the form of constraint solving puzzles.
.
.
extracting error related constraints given a target branch if pat is not able to obtain any feasible execution path with path condition it examines all path conditions which have been input into the smt solver for satisfiability checks.
usually if a path condition cannot be handled by the smt solver the solver outputs an error message indicating the cause of the error as shown in figure .
path conditions this notnull this .sums notnull this .sums .length this .sums .length this .sums .length this .n error feature not supported non linear problem .
figure an example of error causing path conditions once pat has found path conditions which cause smt errors it saves them for future puzzle generations.
since pat performs smt checks along many different paths for a given branch there can be many different path conditions that cause errors.
currently pat saves only the first erroneous path conditions it finds for one branch.
saving more path conditions for puzzle generations can increase the probability of finding a satisfiable model but it also requires more humans to solve them.
for the saved path conditions it might still be too long to present them directly.
by observing the path conditions in figure we notice that constraints and are independent of the error related constraints i.e.
and .
therefore pat performs an additional smt check to obtain a partial model which satisfies all the non error related constraints figure a .
thus only the error related constraints are left for puzzle generation figure b .
note that even though constraint in figure is not an errorcausing constraint it is related to the error causing constraint i.e.
in that they are both constraining the same variable.
therefore we still regard it as an error related constraint.
a partial model this instanceof vectorialcovariance this .sums instanceof double this .n a a partial model satisfying the non error related constraints error related constraints this .sums .length this .sums .length this .sums .length b error related constraints left for puzzle generation figure extracted error related constraints the partial model in figure a and a model obtained from public puzzle solving can be joined together to form a complete model such as the one in figure .
.
.
prioritizing constraint sets before generating constraint solving puzzles pat groups and prioritizes the error related constraint sets first.
the key idea of the grouping schema is that even though many constraint sets are literally different some are actually semantically equivalent.
for example even though both constraint sets in figure are extracted from different path conditions and they are literally different it is easy to notice that these constraint sets are actually semantically145equivalent.
by solving only one of them pat can retrieve models for both constraint sets.
hence pat identifies all constraint sets which are different only by their corresponding variable names as semantically equivalent.
these constraint sets are put into the same group and pat generates only one representative puzzle from a random constraint set in this equivalent group.
error related constraint set this .sums .length this .sums .length this .sums .length a error related constraint set error related constraint set this .covarianceimpl .sums .length this .covarianceimpl .sums .length this .covarianceimpl .sums .length b error related constraint set figure two semantically equivalent error related constraint sets then pat prioritizes the groups of constraint sets to make the best use of human efforts.
since solving each error related constraint set may lead to the solutions of multiple models for different branches the goal of the prioritization schema is to maximize the number of additional branches potentially coverable by the models.
to achieve this pat dynamically computes the potential gain of branch coverage for each constraint set group and selects the one with the highest potential gain to present first.
if there are multiple groups with the same highest potential gain pat selects the one with the fewest number of constraints.
.
.
generating puzzles for constraint solving figure screenshot of constraint solving puzzles.
panel presents the constraints being solved in the puzzle.
panel is the input area where users assign concrete values to variables.
after the error related constraint sets are grouped and prioritized they are presented as constraint solving puzzles by pat.
figure is a screenshot of the pat constraint solving puzzle.
two different panels are constructed with the left panel presenting the constraint set required to be satisfied and the right panel providing areas for humans to input concrete values.
whenever a value is changed by the user pat immediately re evaluates the satisfaction of each constraint line.
constraint lines satisfied by the current set of concrete values are highlighted in green.
a puzzle is considered solved when all constraint lines have turned green.
since each puzzle is actually a representation of a group of constraint sets that might be constraining different variables all variable names in the constraint lines are masked with symbols i.e.
a b etc.
.
.
constructing test cases from solutions the last phase of pat is to generate test cases at the server side from puzzle solutions.
solutions of constraint solving puzzles can be directly used as primitive type arguments or they can be assigned to publicly accessible fields based on the solved models.
in case the related fields are not directly assignable these solutions can be used as new models to generate additional object mutation puzzles.
for object mutation puzzles the complete action sequence taken by a player to solve a puzzle is directly translated into a corresponding method call sequence.
the method call sequence can generate test inputs satisfying a target model.
for example figure shows the method call sequence generated from the action sequence described in section .
.
.
the generated method call sequence produces a vectorialcovariance object satisfying the target model in figure .
it is possible that a player can perform some trial actions during puzzle solving which are not relevant to the solution.
in such case the resulting method call sequence can contain methods whose side effects do not contribute to the test input generation.
however since the test inputs generated by the whole method call sequence can still satisfy the target model these irrelevant method calls do not affect the test case generation process.
to construct the final test case for the model pat invokes the target method which includes the target branch with test inputs generated by the method call sequences.
vectorialcovariance var0 new vectorialcovariance true double var1 double objloader .loadobjectfromfile bigstore pat captured double hash 10032989 var0 .increment var1 double var2 double objloader .loadobjectfromfile bigstore pat captured double hash 10032989 var0 .increment var2 figure an example of generated method call sequence .
ev aluation .
evaluation setup in this section we investigate the usefulness of pat by addressing the following research questions rq1 how many object mutation puzzles and constraint solving puzzles can be solved by humans?
rq2 how many people would play pat voluntarily?
rq3 how much is the test coverage improved by the puzzle solutions of pat?
rq4 how much manual test case writing effort can be saved with the help of pat?
.
.
subjects for evaluation we deployed the pat framework to the apache commons math acm 1library version .
and the apache commons collections acc 2library version .
.
.
table subjects acm and acc name version of lines of branches commons math .
commons collections .
.
acm is a lightweight self contained mathematics and statistics library.
acc is a data container library which provides more time spent second branches coveredfigure the randoop coverage result for acm data structures over jdk.
both subjects are popular medium size libraries and have been commonly used in software engineering literature .
.
.
up front testing runs and baseline techniques before pat actually generates puzzles for the subjects a set of automatically generated up front test cases needs to be executed as described in section .
.
this phase removes branches easily coverable by automatic test generation techniques.
thus pat generates puzzles only for branches not coverable by automatic test generation techniques.
in the evaluation we generated the up front test cases with two types of automatic test generation techniques.
these two techniques are also used as baseline techniques when we compare the coverage improvements achieved by pat in rq3.
the first up front testing technique we used was randoop a state of the art feedback directed random test generation technique.
figure presents the coverage results of randoop.
the x axis in the figure represents the test case generation time in seconds spent by the technique.
for example means the technique was set to generate test cases for seconds.
the y axis represents the total number of branches covered by test cases generated by the technique.
figure shows that the coverage is basically saturated after seconds.
thus we used seconds as the time setting for randoop to generate the up front test cases.
the second up front testing technique we used was a symbolic execution based automatic test generation technique symbolic .
we had adapted and implemented a simplified version of the symbolic execution based test generation module.
this module uses the same path computation algorithm described in section .
to obtain the path conditions for each branch not covered by randoop.
to construct test inputs satisfying the path conditions this symbolic execution module attempts to mutate objects automatically without breaking any class invariants .
more specifically it assigns model values only to primitive type arguments and to member fields that are publicly accessible.
it is possible to assign values to non public fields through java reflection but our symbolic module does not do that since this may easily break class invariants and produce many objects with invalid states.
in total .
of branches were covered with test cases generated by the two up front testing techniques for acm.
for acc .
of branches were covered with test cases generated by the two techniques.
in our study we used these two up front testing techniques.
however besides these two techniques other automatic test generation techniques can also be deployed as the up front testing runs to generate pat puzzles.
.
rq1 puzzle solving results to investigate the effectiveness of humans in solving the puzzles we conducted one small scale study targeting the graduate computer science cs students.
we invited a group of eight graduate cs students to play both kinds of puzzles to investigate how effective they were in solving the puzzles.
all participants were presented with the top object mutation puzzles prioritized by pat as described in section .
.
and top constraint solving puzzles prioritized as described in section .
.
.
for evaluation purposes all participants were presented with the same set of object mutation puzzles and constraint solving puzzles.
however in the actual deployment pat does not present already solved puzzles again.
table shows the overall puzzle solving results.
table puzzle solving results for acm puzzle type total presented total solved avg.
time mutation min constraint min we investigated the effectiveness of participants in solving the presented puzzles in two aspects how many puzzles can they solve and how long does it take for them to solve the puzzles.
note that since the lists of puzzles solved by participants can have overlaps redundantly solved puzzles are counted only once.
in total of the object mutation puzzles were successfully solved by our participants.
on average a participant spent one minute on a puzzle before solving it or moving to the next puzzle.
the evaluation results show that the participants were able to handle the mutation puzzles quite effectively with a puzzle solving rate and one minute time spent on each puzzle.
table presents the overall results for constraint solving puzzles.
in terms of puzzle solving after removing the redundant ones of the constraint solving puzzles were successfully solved by our participants.
on average a participant spent one minute on a puzzle before solving it or moving to the next puzzle.
the evaluation results indicate that our group of participants can also solve the constraint solving puzzles quite effectively with a puzzle solving rate and one minute time spent on each puzzle.
overall the group of participants i.e.
cs graduate students which we investigated could solve both types of puzzles effectively.
.
rq2 voluntary participation the next research question we want to investigate is how many people would play pat voluntarily?
to investigate this question we setup and deployed pat on the second subject acc and generated puzzles for it.
then we posted the link to the puzzles on twitter and encouraged people to participate on a voluntary basis.
our tweet was retweeted several times.
table puzzle solving results for acc puzzle type total presented total solved avg.
time mutation min constraint min in total people volunteered to play the puzzles.
table presents the overall results of puzzle solving by these participants.
overall of the top object mutation puzzles and of the top constraint solving puzzles were successfully solved.
in terms of time spent on average a participant spent one minute on both kinds of puzzles before solving it or moving to the next puzzle.
comparatively the solving rate for object mutation puzzles was lower but the solving rate for constraint solving puzzles remained high comparing to puzzle solving by cs graduate students in rq1 .
to encourage more people to participate and play the pat puzzles we can further introduce a competition and reward mecha 147subjectsbranch coverage 75pat symbolic randoop acm acc4750 .
.
.
.
.
.
figure coverage improvements of acm and acc.
the numbers on the bar plots show the amount and percentage of additional branches covered by each technique.
nism.
for instance humans can compete for coming up with the first solution of a puzzle.
points or prizes can be awarded to them as stimulation.
implementing such a mechanism can attract more people to play the pat puzzles but it is more of an engineering issue.
a competition and reward mechanism will be introduced in future versions of pat.
.
rq3 coverage improvement we have shown that pat puzzles can be effectively solved by humans and people are willing to participate in solving puzzles.
the next research question we want to investigate is how much can these solved puzzles improve test coverage.
for this question we generated test cases using the puzzle solutions from rq1 and rq2 for the two subjects acm and acc.
we investigated the coverage improvements achieved by these pat test cases and compared them with the two baseline techniques randoop and symbolic.
we first used the two baseline techniques in up front testing runs as shown in section .
.
.
only constraints and mutations related to the not covered branches by these two baseline techniques were presented to humans as puzzles sections .
.
since human effort should not be wasted on branches coverable by automatic techniques.
we investigated how much pat improves coverage on top of these two baseline techniques.
figure presents the numbers and percentages of branches covered by the baseline techniques and pat for the two subjects.
randoop represents the branch coverage of running test cases generated by randoop.
symbolic shows the additional coverage that can be achieved with symbolic.
finally pat is the number of additional branches covered with test cases generated by pat.
for acm randoop achieved a coverage of .
branches.
as shown in figure coverage of this technique had reached saturation after running for seconds.
symbolic covered an additional .
branches on top of randoop.
overall the two baseline techniques together achieved .
branch coverage.
by running test cases generated from puzzle solutions obtained in rq1 pat improved the coverage of the two baseline techniques by .
branches.
considering the saturated coverage of the two baseline techniques and the relatively small scale of the study solving only pat puzzles a .
branch coverage improvement is non trivial.
the coverage improvement was achieved by humans without domain knowledge of the subjects.
similarly for acc the two baseline techniques had achieved a branch coverage of .
together.
on top of that pat improved the coverage by .
branches leveraging only puzzle solutions.overall after solving only puzzles of acm and puzzles of acc pat successfully generated test cases to cover .
and .
additional branches for the two subjects on top of the two saturated baseline techniques.
this shows that pat solutions were efficient in generating test cases to cover more branches.
in addition it shows that pat s prioritization approaches described in section .
.
and section .
.
were effective and participants efforts were well spent on the most important puzzles.
on average each puzzle solution helped cover three to four branches while one puzzle took about one minute to solve as shown in rq1 and rq2.
.
rq4 effort reduced we have shown that pat puzzles can be solved by humans and the puzzle solutions can improve test coverage significantly.
since the puzzle solving process includes human effort one could argue that humans can directly write the test cases manually without playing pat puzzles.
to evaluate this a graduate student randomly selected ten not covered branches from each subject and tried to write test cases manually to cover them.
he had six years of java programming experience and certain degree of domain knowledge of the subjects.
table manual effort in minutes required to write test cases for ten randomly selected branches in acm and acc acm branch time acc branch time polynomialsplinefunction 4m abstracthashedmap 22m vectorialcovariance 6m abstractmapbag 12m microsphereinterpolatingfunction 13m boundedbuffer 7m fractionformat 2m boundedfifobuffer 3m stepnormalizer 17m instantiatetransformer 4m directsearchoptimizer 5m lazylist 4m leastsquaresconverter 9m objectgraphiterator 11m loessinterpolator 12m linkedmap 5m rotationorder 4m flat3map 3m abstractrealmatrix 13m compositecollection 4m average 9m average 8m table shows the time in minutes spent on writing test cases for ten randomly selected branches for each project.
mostly it took to minutes to write a test case to cover one branch.
some branches such as abstracthashedmap took more than minutes as the pre condition for covering the branch was complex and involved several different methods.
overall it took minutes on average to manually write one test case to cover a branch.
these results indicate that manual test writing to cover even one branch requires significant time and effort.
however pat with its prioritization approaches section .
.
and section .
.
covered branches for acm and for acc leveraging only puzzle solutions from acm and from acc.
on average each pat puzzle helped cover three to four branches.
note that each pat puzzle was solved in one minute on average as shown in section .
and section .
.
in addition the time spent by participants on solving pat puzzles and time spent by developers writing test cases should not be directly compared.
in general much more programming and domain knowledge is required to write test cases for a given subject.
on the other hand the general public can play the puzzles with little or no domain knowledge of the subject.
therefore the use of pat makes the allocation of resources more effective as the effort from the general public can be utilized to test many branches.
thus developers limited time can be focused on writing test cases for branches not coverable by both automatic test generation techniques and pat.
furthermore developers can also play the puzzles themselves.
with their knowledge in the subject programs they may solve puzzles that are difficult for most ordinary participants.148the puzzle solutions they provide may help them cover more program branches without the need of writing test cases manually.
overall results in this section show that pat can effectively reduce the time and effort required by developers to write test cases.
.
threats to v alidity threats to external validity.
in our evaluation we used two medium size open source libraries acm and acc which are widely used in the literature as subjects .
since evaluation requires participant by many users and is time consuming we evaluated pat on only these two subjects.
however these subjects might not be representative of other kinds of systems such as closed source systems.
pat uses yices as its smt solver in puzzle generation.
it is possible that constraints unsolvable by yices may be solvable by other smt solvers.
we plan to use more smt solvers to further reduce the number of puzzles needed to be solved by humans.
threats to internal validity.
a threat to internal validity comes from captured objects used in mutation puzzles.
currently pat only captures objects from the up front test running phase section .
.
the quality and quantity of the captured objects may affect the results of pat.
threats to construct validity.
the major threat to construct validity comes from the measurement of usefulness.
in the evaluation we used the branch coverage criterion to evaluate the usefulness of pat.
there are other metrics that can be used to evaluate usefulness.
therefore conclusions obtained from our measurement criterion might not be representative of other measurement metrics.
.
conclusions and future work in this paper we have presented pat which decomposes object mutation and complex constraint solving problems into small puzzles for humans to solve.
our evaluation study shows that humans can efficiently solve these mutation and constraint problems by voluntarily playing the puzzles.
the solved puzzles yield non trivial test coverage improvement.
overall pat successfully leverages crowd sourcing to assist test input generation and automatic software testing.
we anticipate that future software engineering approaches will leverage more crowd sourcing to address challenges in software engineering research.
pat is a first step in this direction.
in future we expect pat to become an easily extensible platform to facilitate more types of puzzles related to software testing.
the pat puzzles and our experiment data are publicly available at http pat.cse.ust.hk .
.