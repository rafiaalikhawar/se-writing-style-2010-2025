precise identification of problems for structural test generation xusheng xiao1tao xie1nikolai tillmann2jonathan de halleux2 1dept.
of computer science north carolina state university raleigh nc 2microsoft research one microsoft way redmond wa xxiao2 txie ncsu.edu nikolait jhalleux microsoft.com abstract an important goal of software testing is to achieve at least high structural coverage.
to reduce the manual efforts of producing such high covering test inputs testers or devel opers can employ tools built based on automated structural test generation approaches.
although these tools can easi ly achieve high structural coverage for simple programs when they are applied on complex programs in practice these tools face variousproblems suchas theexternal metho dcall problem emcp where tools cannot deal with method calls to external libraries the object creation probl em ocp where tools fails to generate method call sequences to produce desirable object states.
since these tools currently could not be powerful enough to deal with these problems in testingcomplex programs in practice we propose cooperative developer testing where developers provide gui dance to help tools achieve higher structural coverage.
to re duce the efforts of developers in providing guidance to tools in this paper we propose a novel approach called covana which precisely identifies and reports problems that preven t the tools from achieving high structural coverage primaril y by determining whether branch statements containing notcovered branches have data dependencies on problem candidates.
we provide two techniques to instantiate covana to identify emcps and ocps.
finally we conduct evaluations on two open source projects to show the effectiveness of covana in identifying emcps and ocps.
categories and subject descriptors d. .
testing and debugging general terms measurement reliability keywords structuraltestgeneration dynamicsymbolicexecution d ata dependency problem identification permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.
.
introduction software testing is by far the most widely used technique for improvingsoftware reliability.
an important goal of so ftware testing is to achieve full or at least high structural coverage such as statement or block coverage and branch coverage of the program under test.
however manually producing test inputs for achieving high structural covera ge is labor intensive.
to address the issue testers or developers can employ tools built based on state of the art automated structural test generation approaches to automat ically generate test inputs such as dynamic symbolic execution dse also called concolic testing .
althoughthese automated test generation tools can easily achieve high structural coverage for simple programs thes e tools face challenges ingeneratingtest inputstoachieve h igh structural coverage when they are applied on complex programs in practice.
to better understand how automated test generation tools perform for complex programs we car ried out a preliminary study of applying pex a dse tool on four popular open source projects which have high download counts study details are described in section .
the results show that the total block coverage achieved is .
with the lowest coverage being .
.
among the problems that we empirically obervered many statements or branches are not covered due to two major types of problems the external method call problem emcp where method calls to external libraries1throw exceptions to abort test executions or their returnvalues are used todecide su bsequent branches causing the branches not to be covered the object creation problem ocp where tools fail to generate sequences of method calls to construct desired object states for non primitive method arguments or receiver objects to cover certain branches.
since these automated tools could not be powerful enough to deal with various complicated situations in real world codebasesautomaticallywithouthumaninterventionorgui dance we propose a new methodology of cooperative developer testing where tools and developers cooperate to effectively carry out software testing as follows.
automated test generation tools are first applied to generate test inputs and achieve coverage without human guidance.
after the tools reach the pre defined limits of resource consumption the tools stop and report the achieved coverage and the problemsthatpreventthemfromachievinghigherstructura l coverage back to developers such as which external method 1external libraries include native system libraries such a s file system andnetwork socket libraries andthird partypr ecompiled libraries where source code is not available.call causes branches not to be covered or the state of which object is required to cover certain branches.
by looking int o the reported problems the developers provide corresponding guidance to help the tools address the problems.
for example to deal with ocps developers can specify factory classes that encode desired method sequences for nonprimitive object types.
to deal with emcps developers can instruct the tools to instrument the external method calls or provide mock objects to simulate irrelevant environ ment dependencies.
with the provided guidance the tools are reapplied to generate test inputs for achieving higher structural coverage.
to achieve this cooperative developer testing the tools need to report the encountered problems and narrow down the investigation scope thus reducing the required efforts from the developers.
given the generated test inputs from tools and the achieved coverage it is not difficult to identify the problem candidates for the developers to analyze.
for example locating all the external method calls in the program under test can be easily achieved by static or dynamic program analysis and reporting the object types of the program inputs and all their fields to the developers is fairly easy as well.
however the number of such problem candidates could be high and quite some of these problem candidates referred to as irrelevant problem candidates are not causes for the tools not to achieve higher structural coverage.
for example the external method call console.writeline onlyprintstheargumentstringvalue.
therefore instrumenting or mocking this method call cannot result in any increase in coverage.
similarly some branches may require only the specific object state of a field of the program inputs and thus there is no need to spend efforts in providing sequences of method calls for all the fields of the program inputs.
since the number of problem candidates could be large the tools need to prune irrelevant problem candidates for reducing the efforts of developers in terms of investigation scope.
simple pruning techniques such as pruning external methodcalls bymethodnames orbelonginglibraries canresult in high false positives andfalse negatives.
in our prel iminary study we observed that if branch statements are data dependent on external method calls for their return values i.e.
return values are used to decide which branches of the statements totake thebranchesofthese branchstatement s are verylikelynotcoveredbythegenerated testinputs sin ce automatedtest generationtoolsnormallycannotinstrume nt or analyze the external method calls.
hence we can use compute data dependencies of branch statements containing not covered branches referred to as partially covere d branch statements on external method calls for their return values and use the computed data dependencies to effectively identify such external method calls and prune i rrelevant ones.
similarly we can compute data dependencies of partially covered branch statements on program inputs and their fields and use the computed data dependencies to help identify which fields of the program inputs require desired object states to cover certain not covered branche s. to address the need of precisely identifying problems for developers to provide guidance in this paper we propose a novel approach called covana that precisely identifies the problems that prevent the tools from achieving high structural coverage and prunes the irrelevant problem candidate s usingthedatadependenciesofpartially coveredbranchst ate mentson problemcandidates.
covanaconsists ofthreemain steps identify problem candidates based on the types of problems assign symbolic values toelements ofthe prob lem candidates including return values of external metho d calls or program inputs as well as their fields and perform forward symbolic execution using test inputs generate d by the tools as program inputs compute data dependencies of partially covered branch statements on program candidates and prune the candidates that none of partially coveredbranchstatementshavedatadependencieson.
since emcps and ocps are the two major types of the problems observed in our preliminary study we provide two specific techniques to instantiate covana for identifying these two types of problems.
to show the effectiveness of covana in this paper we use dynamic symbolic execution dse as an illustrative example of automated structural test generat ion approaches.
the primary reason why we choose dse is that dse is the most recent state of the art in test generation.
we concretize covana as an extensible framework that collects information from dse to identify different types of problem candidatesandperform forward symbolic execution to compute data dependencies of partially covered branch statements on problem candidates.
this paper makes the following major contributions the first attempt to precisely identify problems faced bytoolsbuiltforstructural test generationapproaches achievingthefirst stepofcooperative developertesting between tools and developers.
a novel approach called covana that identifies different types of problem candidates and prunes irrelevant candidates by computing data dependencies using forward symbolic execution.
a concretization of covana as a framework to identify problems that prevent dse from achieving high structural coverage.
two analysis techniques are provided to instantiate covana for precisely identifying emcps and ocps.
twoevaluationsofcovanaontwoopensourceprojects including xunit and quickgraph .
the results show that covana effectively identifies emcps out of emcp candidates with only false positive and false negative and ocps out of ocp candidates with false positives and false negatives.
.
preliminary study in this section we discuss the different types of problems that we empirically observed by applying a state of the ar t dse tool pex on four open source projects for achievingstructuralcoverage.
theanalysisoftheseproblemshel ps motivate our approach.
we choose pex as the dse tool in our empirical study and later we implement our approach upon it for two reasons pex can explore all public methods of any real world .net code bases and generate test inputs automatically pex has been applied internally in microsoft to test core components of the .net runtime infrastructure and found serious defects .
we apply pex on the core libraries of the four open source projects until all the methods have been explored by pex orproject loc cov ocp emcp boundary limitation svnbridge .1k .
.
.
xunit .4k .
.
.
math.net .5k .
.
.
.
.
quickgraph .3k .
total .3k .
.
.
.
.
table main problems for not covered branches in files fr om core libraries of four open source projects pexrunsoutofmemoryandcannotcontinuetogeneratetest inputs.
these four open sources projects are svnbridge xunit math.net and quickgraph which are quite popular and have high download counts.
after pex generates test inputs and produces coverage files we select source files that achieve low coverage in each project and manually investigate the problems that contribute to the not covered statements and branches.
the details of the subjects and results can be found in our project web2.
table shows the distribution of the problems that prevent dse from achieving high structural coverage.
column project lists the name of each project column loc shows the number of lines of codes for each project and column cov shows the block coverage achieved by pex.
the other four columns give the number and the percentage of the not covered branches caused by different types of problems.
the top major type of problems is object creation problems .
shown in column ocp since desired object states cannot be generated.
in unit testing of objectoriented code achieving high structural coverage require s desired object states for the receiver or non primitive arg uments of the method under test mut .
these desired object states help cover various branches.
however automate d approaches are often ineffective in generating method call sequences that produce desired object states to achieve hig h structural coverage facing object creation problems that prevent dse from achieving high structural coverage.
the second major type of problems is external methodcall problems .
shown in column emcp since external method calls cause to lose track of computed symbolic valuespassedastheirargumentsor throwexceptionst o hinder the exploration.
in our study we encountered many external method calls in files but only .
in are causes for dse not to achieve high structural coverage.
if we simply report every encountered external method call as an emcp we can get many irrelevant problems that are not cause for any not covered statment or branch.
the third main type of problems is boundary problems .
shown in column boundary mostly caused by loops in the program under test.
some programs under test have loops whose number of iterations depends on symbolic values and dse keeps increasing the number of iterations of the loops during path exploration preventing dse from exploring other paths in the remaining parts of the program.
the last main type of problems is limitations of the used constraint solver .
shown in column limitation since the used constraint solver cannot compute exact solutions to floating point arithmetics.
the reason why we did not have so many not covered branches due to this type of problems is that the used constraint solver generates approximateintegersforconstraintsthatcontainfloating p oint arithmetics andtheseapproximateintegers cancover certa in branches.
string getdefaultconfigfile string assemblyfile string configfilename assemblyfile .config if file.exists configfilename return configfilename return null ... public executorwrapper string assemblyfilename ... ... assemblyfilename path.getfullpath assemblyfilena me ... public assertactualexpectedexception object expected object actual ... ... this.actual string.format actual.gettype .fullname this.expected string.format expected.gettype .fullname ... figure three simplified methods from xunit .
.
example we next explain how covana instantiated with two specific techniques identifies emcps and ocps with two illustrative examples.
.
external method call problem emcp during the execution of the automatically generated test inputs external method calls may prevent the generated test inputs from achieving high structural coverage if the return values of external method calls are used to decide subsequent branches to take or throw exceptions to terminate test executions.
as a real example the return value of file.exists in figure is used in deciding which branch at line to take.
if the generated test inputs do not contain a file name that exists in the test environment being mostly the case the statement at line cannot be covered by the test inputs.
the method path.getfullpath at line is anotherexampleexternal methodcall thatpreventstestinpu ts from achieving higher structural coverage.
path.getfullpath throwsexceptionswhenaninvalidofanassemblyfileisgiven as the argument.
therefore if none of the generated inputs includes a valid name the lines after line remain not covered.
however not all the external method calls ca n cause problems for achieving high structural coverage.
for instance string.format at line and in figure only formats the string value of the input and does not affect the coverage achieved by the generated test inputs.
covana first identifies as problem candidates the externalmethod calls whose arguments have data dependencies on program inputs.
in figure covana identifies file.exists at line path.getfullpath at line and string.format at lines and as candidates since they all have data dependencies on the program inputs.
by assigning symbolic values to return values of the candidates and applying forward symbolic execution covana collects symbolic expres public class fixedsizestack private stack stack public fixedsizestack stack stack this.stack stack public void push object item if stack.count throw new exception full stack.push item ... public void testpush fixedsizestack stack object item stack.push item figure fixedsizestack implemented using stack sions in the predicates of branch statements.
from the symbolic expressions collected from branch statements covan a extracts elements of problem candidates and considers the branch statements that have data dependencies on problem candidates.
if one of the branches at line is not covered i.e.
line is a partially covered branch statement cov ana identifies fileexists as an emcp.
on the other hand there are no partially covered branch statements that are data dependent on the return values of string.format at lines and causing string.format at lines and to be pruned.
for path.getfullpath if all of its executions throw exceptions the remaining part of the program starting at line remains not covered.
covana detects the exceptions that cause to abort the test executions and identifiespath.getfullpath as an emcp that causes the area starting at line not to be covered.
.
object creation problem ocp figure2showsaclass fixedsizestack thathasafield stack of typestack.
invoking the method pushto push objects is required for increasing the size.
stackhas a field itemsthat stores the pushed objects and the method stack.count returns the number of objects stored in the stack.items3.
fixedsizestack has an upper bound of the number of objects that can be pushed into the stack.
to bound the size the method fixedsizestack.push throws an exception when the size of the stack has reached the bound in the example .
the method testpush receives a fixedsizestack object and an object to be pushed as its arguments and invokes the method fixedsizestack.push to push the object to the stack for testing.
to cover the true branch at line of the method fixedsizestack.push the generated test inputs need to include method call sequences to create a full fixedsizestackwhose size is .
since the field fixedsizestack.stack can be assigned directly by invoking the constructor of fixedsizestack and passing an object of stackas an argument i.e.
the field fixedsizestack.stack isassignable for the declaring class fixedsizestack the difficulty of generating an object state offixedsizestack whosesizeis10liesingeneratinganobject ofstackwhosesize is10.
letusassumethatautomatedtestgeneration tools cannot produce the required object state o f stack.
covana first assigns symbolic values to program inputs and their fields i.e.
fixedsizestack fixedsizestack.stack 3assume that stack.items is implemented using the object typelist object figure overview of covana andstack.items and performs forward symbolic execution to compute data dependencies.
by computing data dependencies of partially covered branch statements covana fig ures out that the branch statement at line with the true branch not covered has data dependencies on stack.items .
however reporting the object type of stack.items being list object results in a false warning.
since by providing method call sequences for list object the tools cannot assign it tothefield stack.items sincestack.items is assignable forstack.
based onthisobservation covanaconstructsafielddeclaration hierarchyfrom thefieldthatthebranchstatementhas data dependencies on up to the program input and identifies the declaring class whose field is not assignable as the cause of the ocp.
in this example the constructed hierarchy is fixedsizestack fixedsizestack.stack andstack.items .
covana analyzes the field declaration hierarchy starting from the program input.
by analyzing fixedsizestack andfixedsizestack.stack covana knows that fixedsizestack.stack is assignable for fixedsizestack .
then covana continues to checkfixedsizestack.stack andstack.items .
since the field stack.items can be changed only by invoking the method stack.push i.e.
not assignable for stack covana identifies the object type stackoffixedsizestack.stack as an ocp that causes the true branch at line not to be covered.
.
approach in this section we describe how covana identifies problem candidates of structural test generation and prunes irrele vant problem candidates by computing data dependencies.
covana consists of three main steps problem candidate identification forward symbolic execution and data dependence analysis.
in the following part of the section we introduces the overview of covana and describe these three main steps in detail.
.
overview of covana inthispaper weconcretizecovanaasanextensibleframework for identifyingproblemsthatpreventdsefrom achieving high structural coverage.
dse executes the program symbolically starting with arbitrary inputs.
along the execution path dse collects symbolic constraints on program inputs in branch nodes being runtime instances of branch statements to form an expression called the path condition.
to obtain a new path that takes a different branch one of the branch nodes in the path condition is negated to create a new path condition that shares the pre fix up till the node being negated with the original path.
then a constraint solver is used to compute test inputs that satisfy the new path condition.
these generated test inputs again are executed on the program to explore different paths of the program.
ideally all feasible paths can be exercised eventually through such iterations of path variations.
how ever as we discussed in the introduction various problems cause dse not to achieve high structural coverage.
figure shows a high level overview of covana.
covana accepts as inputaprogram undertestor parameterized unit test put and generated test inputs from automated test generation tools such as a dse based tool .
covana then leverages the dse engine to perform forward symbolic execution on the program or put using the test inputs as program inputs program inputs are assigned with symbolic values .
during execution covana monitors runtime events triggered by the dse engine for identifying different types of problem candidates.
after identifying problem candidates covana assigns symbolic values to elements of these problem candidates performs forward symbolic execution on these symbolic values and collects runtime information such as symbolic expressions and exceptions.
covana then uses the collected structural coverage and runtime informa tion to compute the data dependencies of partially covered branch statements on problem candidates and prunes irrelevant problem candidates that none of partially covere d branch statements have data dependencies on.
in our current prototype we instantiate this general approach with two techniques to identify the top two main types of problems emcps and ocps.
we next discuss each step of covana in detail.
.
problem candidate identification covana collects necessary information from the dse engine for identifying different types of problem candidates.
the dse engine executes the program under test or put with the generated test inputs symbolically.
during execution covana monitors different events triggered by the dse engine and exposes these events as interfaces for specifyin g different types of problem candidates.
there are many kinds of events that can be monitored such as events of method entry and method exit.
we next discuss how these events can be used to identify the problem candidates of emcps and ocps.
.
.
identifying emcp candidates a method exit event is triggered by dse engine when the execution ofamethod call is finished.
this eventcomes with detailed method information including method arguments method instrumentation information and so on.
ifthemethodisnotinstrumentedbydse themethodcall is considered as an external method call method calls to ei ther system libraries or third partypre compiledlibrari es.
if covanaconsidersallexternal methodcalls asproblemcand idates of emcp then the number of problem candidates can be very large for complex programs.
hence covana considers as candidates only the external method calls whose arguments have data dependencies on program inputs.
in this way the external method calls that have constant arguments are not considered as problem candidates and are pruned without computing data dependencies.
normally such external method calls are method calls that print constant strings or puta threadtosleep for some time which donot cause dse not to achieve higher structural coverage and can be safely pruned.
since dse typically assigns symbolic values to program inputs to know whether method arguments have data dependencies on program inputs can be achieved easily by checking whether the method arguments contain symbolic expressions of program inputs.
in our preliminary study described in section we observed that many branches are not covered since the conditions of these branches use the return values of externalmethod calls i.e.
data dependent on these external metho d calls .
the reason is that dse tools and other automated test generation tools are unlikely to generate different te st inputs to cause external method calls to return desired val ues since these tools have not instrumented or analyzed external method calls.
therefore for the external metho d calls whose arguments have data dependencies on program inputs covana considers them as emcp candidates.
to illustrate the analysis we use the example shown in figure .
during the test execution of the method getdefaultconfigfile covana identifies the external method call file.exists as an emcp candidate since its argument configfilename has data dependency with assemblyfile which is the program input.
the return value of file.exists which is used in the branch statement at line is assigned with a symbolic value for computing data dependencies.
.
.
identifying ocp candidates whenever test inputs are used as the arguments to execute the program under test the method entry event of the method under test is triggered.
in this exposed event the details of the generated program inputs are collected.
sinc e ocp requires objects of a non primitive type as program inputs covanaignores program inputswhose typeis primitive type such as int double andboolean.
covana considers the program inputs of non primitive types themselves and their fields of non primitive types as ocp candidates.
.
forward symbolic execution covana performs forward symbolic execution using the test inputs generated by automated test generation tools a s program inputs and collects runtime information for computing data dependencies.
covana assigns symbolic values to elements of the identified problem candidates such as return values of external method calls and leverages the dse engine to perform forward symbolic execution for collecting constraints on elements of problem candidates in branch statements.
we next discuss how covana uses this runtime information to compute data dependencies of partially covered branch statements on problem candidates.
.
.
collecting symbolic expressions in branches since elements of problem candidates are assigned with symbolic values if a branch statement has data dependency on problem candidates we can find symbolic expressions on elements of the problem candidates in the predicates of the branch statement.
such information is later used to compute data dependencies on problem candidates.
.
.
collecting uncaught exception after assigning symbolic values to elements of problem candidates covanamonitors theprogram execution.
whenever an uncaught exception is thrown covana collects the exception including its stack trace of the exception.
as weobserved in the preliminary study if an external method call throws an exception for the executions of all the generated test inputs the remaining parts of the program after the call site of the external method call cannot be covered.
thus covana uses the stack trace of an exception thrown at runtime for the analysis of emcp described in section .
.
.
.
data dependence analysis covana consumes the collected runtime information from the forward symbolic execution to compute data dependencies.
for each collected symbolic expression symfound in the predicates of a branch statement b covana extracts elements of the problem candidates elemfromsym.
from elem covana extracts the corresponding problem candidatespand considers bhas data dependency on p. using the collected structural coverage covana further compute s data dependencies of partially covered branch statement o n problem candidates.
with these data dependencies different analyses further prune irrelevant problem candidates.
.
.
emcp analysis covana first identifies emcp using the data dependencies of partially covered branch statements on emcp candidates.
if these exist some partially covered branch stat ements that have data dependencies on emcp candidates for their return values covana directly reports such external method calls as emcps.
to identify external method calls that throw exceptions to abort test executions covana furtheranalyzesthemethodcallsfromthecollectedstacktrac es of exceptions thrown during runtime.
if these method calls contain any external method call and the remaining parts of the program after the call site of the external method call are not covered covana identifies the extracted externalmethod call as an emcp that causes the remaining parts of the program not to be covered.
algorithm object creation problem ocp analysis require fieldsfor field declaration hierarchy bfor notcovered branches ensure ocp iflength fields 1then ocp createocp typeof fields b return ocp else set current null fori 1tolength fields 1do current fields dc typeof fields assg isassignable current dc if!assgthen ocp createocp dc b return ocp end if end for ocp createocp typeof current b return ocp end if .
.
ocp analysis covana identifies ocps using the data dependencies of partially covered branch statements on program inputs andtheir fields.
if a partially covered branch statement is dat a dependent on only program inputs covana directly reports theprogram inputsas ocps.
however ifapartially covered branch statement is data dependent on fields of program inputs covana constructs a field declaration hierarchy up to a program input and performs further analysis to identify which field causes tools not to achieve high structural coverage.
to construct a field declaration hierarchy of the field f that a partially covered branch statement is data dependen t on we can use reflection to obtain the class structure of a program input pand search the fields for finding f i.e.
f is one of the fields of p .
if we fail to find f we continue to search the class structures of the fields of p similar to graph searching.
the search continues until we find f. the fields along the path from ptofare used to construct the field declaration hierarchy.
another way which covana adopts is to use path conditions that lead to not covered branches and extract fields directly from path conditions since the symbolic expressions in the path conditions already contai n program inputs and their fields.
to illustrate the extractio n we use the example shown in figure .
the figure below shows the path condition that leads to the true branch at line and the field declaration hierarchy constructed from the path condition.
algorithm shows our algorithm that identifies ocps by analyzing the field declaration hierarchy fields and the not covered branches b .
if the extracted field declaratio n hierarchy contains only one field satisfying line of the algorithm which should be the program input itself our algorithm reports the program input as an ocp directly.
to identify which field in the field declaration hierarchy causes the ocp our algorithm analyzes the field declaration hierarchy level by level starting from level i.e.
the fie ld ofthe program input .
ifafieldis assignable for its declari ng class not satisfying line dse or other automated testgeneration tools can easily create an object of the field s class type and assign the object to the field by invoking the corresponding constructor or public setter method.
in this case it is the object type of the field or a field in the next level s not its declaring class that causes an ocp.
to further decide whether it is the current field or the field in the next level that causes the ocp our algorithm then continues to check the field in the next level back to line .
if a field is not assignable for its declaring class satisfying line the object state of the field can be changed only by invoking other public state modifying methods of its declaring class.
hence covana reports the type of its declaring class as an ocp.
in our example shown in figure the field stack.items cannot be assigned with an object oflist object by invoking any constructor or public setter method of stack.
to change the object state of stack.items dse needs specific sequences of method calls for stackinstead of list object .
as a result covana identifies the object type stackas an ocp line .
.
implementation the prototype implementation of covana includes three parts the extension to pex an automatic white box test generation tool built for dse.
this extension identifie s problem candidates assigns symbolic values to elements of problem candidates and collects runtime information a data dependence analyzer that analyzes the information produced by these two components and identifies emcps and ocps a graphic user interface gui component that shows the identified problems with detailed analysis information.
.
ev aluations in this section we discuss the two evaluations conducted to show the effectiveness of covana.
in our evaluations we use two popular .net applications xunit and quickgraph and answer the following research questions rq1 how effective is covana in identifying the two main types of problems emcps and ocps?
rq2 how effective is covana in pruning irrelevant problem candidates of emcps and ocps?
we next provide details of the metrics that we collect in our evaluations.
to measure the effectiveness of our approach in identifying emcps and ocps addressing rq1 we measure the number of problems that covana finds for the notcovered branches or statements of the subject applications .
to measure the effectiveness of our approach in pruning irrelevant problem candidates addressing rq2 we compare the number of identified problem candidates with the number of identified problem by our approach in applications under test and measure the number of problem candidates pruned by our approach.
to address both rq1 and rq2 we measure the false positives i.e.
the number of irreleva nt problem candidates that are not pruned by covana and the false negatives i.e.
the number of real problems that are identified as irrelevant problem candidates and pruned.
we next provide details on the subject applications and evaluation setup and the results of the two evaluations.
.
subjects and evaluation setup we usedtwopopular .net applications for evaluatingour covana approach xunit and quickgraph .
xunit is a unit testing framework for .net program development.
xunit includes classes and interfaces with .
kloc.
quickgraph is a c graph library that provides various directed and undirected data structures of graphs.
quickgraph also provides graph algorithms such as depth first search topological sort and shortest path .
quickgrap h includes classes and interfaces with .
kloc.
in our evaluations we use pex with the implemented extensions as our dse test generation tool.
the pex version usedfor ourevaluationis .
.
.
.
we firstapplypex to explore the applications under test and generate test input s. after test generation and execution which is automated by pex the coverage and the collected runtime information are fed into our stand alone analysis tool for identifying emcp s and ocps.
we next discuss the results of our evaluations in terms of theeffectivenessof covanainidentifyingemcps andocps and in reducing the irrelevant problem candidates.
.
rq1 problem identification in this section we address the research question rq1 of how effectively covana identifies emcps and ocps.
to address this question we measure the number of identified problems the number of false positives and the number of false negatives generated by covana.
to measure values for these metrics we executed the stand alone analysis too l implemented for our approach with the output information from pex as inputs and manually classified the problems reported by our tool as real problems false positives and false negatives.
to verify emcp candidates we either instrument or provide mock objects for the external method calls identified as emcp candidates and reapplied pex to check whether the not covered branches can be covered.
if so we classify the emcp candidates as real problems or irrelevant problem candidates otherwise.
similarly to ve rify ocp candidates we provide sequences of method calls for the object types of the ocp candidates and reapplied pex to check whether the not covered branches can be covered.
if so we classify the ocp candidates as real problems or irrelevant problem candidates otherwise.
table shows the results for all the assemblies in both subject applications.
column file lists the number of source files in each application assembly.
columns objectcreationproblem ocp and external method callproblem emcp show the statistics of emcps and ocps identified by covana.
subcolumn real gives the number of real problems identified by us manually.
subcolumn identified gives the numberof problems identifiedbycovana and subcolumn fp and fn givethenumberoffalse positives and false negatives respectively.
the results show t hat our approach identifies emcps with only false positive and false negatives.
in addition our approach identifies ocps with false positives and as false negatives.
the reason why we have false negatives is that in our prototype analysis tool we did not implement the logics required to handle dictionay objects c version of hashmap and static fields of classes.
in our future work we plan to address these issues by identifyingthe fields of dictionay objects and static fields of classes as candidates and computin g datadependencies of partially covered branchstatements on them.
we next provide examples to describe scenarios where our approach effectively identifies emcps and ocps.
we also describe scenarios where our approach produces false positives and false negatives.
figure shows the class testclasscommand of thexunit.sdk namespace.
when we applied pex to generate test inputs for the method testclasscommand.classstart pex generated only one test input and achieved low block coverage of .
.
in testclasscommand.classstart the loop at line requires the field testclasscommand.typeundertest to be not null.
since pex cannot find in the application any public class that implements the interface itypeinfo to create such an object for testclasscommand.typeundertest pex cannot generate more useful test inputs.
thus we need to report an ocp of the interface type itypeinfo .
by analyzing the data dependencies of the entry branch of the loop at line our approach extracts the argument object testclasscommand and its field testclasscommand.typeundertest .
by analyzing testclasscommand andtestclasscommand.typeundertest our approach figures out that testclasscommand.typeundertest can be assigned by using the public constructor of the classapplication assembly file object creation problem ocp external method call problem emcp identified real fp fn identified real fp fn xunit xunit.extensions xunit.console xunit.gui xunit.runner.msbuild xunit.runner.tdnet xunit.runner.utility quickgraph quickgraph.algorithms quickgraph.algorithms.graphviz quickgraph.collections quickgraph.concepts quickgraph.exceptions quickgraph.predicates quickgraph.representations total table evaluation results showing the effectiveness of cov ana in identifying emcp and ocp public class testclasscommand itestclasscommand readonly dictionary methodinfo object fixtures new dictionary methodinfo object random randomizer new random itypeinfo typeundertest ... public testclasscommand itypeinfo typeundertest this.typeundertest typeundertest public exception classstart try foreach type interface in typeundertest.type.getinterfaces ... ... public exception classfinish foreach object fixturedata in fixtures.values ... figure testclasscommand class of xunit testclasscommand and correctly reports an ocp of itypeinfo.
similarly pex achieves low coverage block coverage of .
when generating test inputs for the method testclasscommand.classfinish .
the reason is that the loop at line requires the field testclasscommand.fixtures to hold at least one item.
since there is no constructor or public setter method to assign an external object to testclasscommand.fixtures other public methods of testclasscommand need to be invoked to change the value of testclasscommand.fixtures .
therefore we need to report the program inputtestclasscommand as an ocp.
however our approach cannot detect such situation since the object type of the fieldfixtures isdictionary and we did not implement the logics to handle such type.
hence our approach did not identify the object type of the fixtures as an ocp for the not covered branch at line .
figure 5shows twomethods themethod parsecommandlineof classprogramin the namespace xunit.consoleclient and the constructor of the class executor in the namespacexunit.sdk .
forparsecommandline pex achieved low block coverage of .
because it cannot generate test inputstocause theexternal methodcall file.existsstatic bool parsecommandline string args out string assemblyfile ... assemblyfile args ... if !file.exists assemblyfile console.writeline error assembly file not found assemblyfile return false ... public executor string filename this.assemblyfilename path.getfullpath filename ... figure two methods that have emcps in xunit to return true.
since the outvariable assemblyfile is assigned with the value of args and thus has data dependencies on the program input args our approach assignedasymbolicvaluetothereturnvalueof file.exist and found that the branch statement at line the false branch not covered has data dependency on file.exist for its returnvalue.
thus ourapproachcorrectlyreportedanemcp offile.exists .
for the constructor of the class executor pex achieved low block coverage of because pex generated a nullobject as the argument for the constructor which caused the external method call path.getfullpath to throw an exception.
our approach collected this exception thrown from path.getfullpath during runtime.
by checking the coverage of the remaining parts of the program after the call site of path.getfullpath our approach found that none of them was covered.
as a result our approach reported path.getfullpath as an emcp.
although another external method console.writeline at line receives assemblyfileas argument and is marked as an emcp candidate by our approach this external method did not have any return value and thus no branch statements have data dependencies on console.writeline .
as a result our approach correctly pruned console.writeline .
.
rq2 irrelevant problem candidate pruning in this section we address the research question rq2 of how effectively our approach prunes irrelevant problem candidates.
to address this question we compare the number of identified problem candidates with the number of problems reported by our approach and measure the number ofapplication object creation problem ocp external method call problem emcp cand ident pruned fp fn cand ident pruned fp fn xunit .
.
quickgraph .
.
total .
.
table evaluation results showing the effectiveness of cov ana in reducing irrelevant problem candidates lines are external method calls public static list recentlyusedassembly loadassemblylist ... using var xunitkey registry.currentuser.
createsubkey xunit key name using var recentkey xunitkey.
createsubkey recent assemblies key name for int index index using var itemkey recentkey.
opensubkey index.tostring if itemkey null break if itemkey !
null ... figure the method loadassemblylist in the class recentlyusedassemblylist of xunit problem candidates pruned by our approach.
in addition we measure the false positives i.e.
the irrelevant proble m candidates not pruned by covana and the false negatives i.e.
the real problems prunedby covana.
to measure values for these metrics we executed the stand alone analysis too l implemented for our approach with the output information from pexas inputs andmanually classified theproblemcandidates reduced by our tool as real problems false positive s and false negatives in the same way as in addressing rq1.
table shows the results of both subject applications.
column application lists the names of the subject applications.
columns external method call problem and object creation problem show the statistics of emcps and ocps respectively.
here the emcp candidates are all the encountered external method calls during the test execution and the ocp candidates are all the non primitive object types of program inputs and their fields that dse assigns symbolic values to.
in table subcolumn cand givesthenumberofproblemcandidates subcolumn ident gives the number of problems identified by covana and subcolumns fp and fn give the number of false positives and false negatives respectively.
the results show t hat our approach prunes .
in emcp candidates with only false positive and false negatvies and prunes .
in ocp candidates with false positives and false negatives.
these results show that our approach effectively reduces the irrelevant problem can didates with low false positives and false negatives.
.
discussion and future work covana identifies problems faced by tools built for structural test generation approaches and prunes irrelevant pr oblemcandidatestoreducetheproblemspaceforinvestigatio n. covana serves as the first step towards problem solving.
in fact identifying problems for developers to investigate i sanalogical to fault localization before fault fixing.
below we discuss how covana can be used to assist other automated test generation approaches or manual test generati on approaches and thendiscuss some issues including those en countered in our evaluations.
assisting other structural test generation approaches .
given test inputs no matter whether they are generated by other automated test generation approaches such as a random approach or are generated manually covana can be used to identify problems of specific types such as emcps and ocps.
the analysis result of covana not only can reduce the efforts of developers in providing guidance to tools but also can reduce the cost of tools built for other test generation approaches.
the first example is to automatically generate mock objects for only the externalmethod calls identified as emcps by covana.
since covana greatly reduces the number of irrelevant problem candidate s of emcp it becomes possible to generate mock objects for the external method calls identified as emcps.
as another example random approach can assign more probabilities on exploring the object types reported as ocps by covana increasing the chances to achieve higher structural coverage in shorter time.
advanced method sequence generation approaches can also be used to address ocps for increasing coverage.
static field .
in our evaluations we observed that a few classes contained static fields that were initialized insid e the classes.
these static fields were later used by some branches and some of these branches were not covered by dse.
since dse did not automatically assign symbolic values to static fields dse was not able to collect symbolic constraints on these static fields.
in future work we plan to assign symbolic values to these static fields so that our approach can collect the symbolic constraints on these static fields for o ur analysis.
concrete arguments for external method calls .
our current covana implementation identifies the return values of external methods as candidates if the method arguments have data dependencies on program inputs.
however in our evaluations there were a few external method calls received concrete values as arguments and resulted i n some not covered branches.
the external method call recentkey.opensubkey shown in figure received a concrete value returned by index.tostring .
since its return value itemkeyofrecentkey.opensubkey isnull the false branch at line is not covered.
in this case our approach cannot detect the problem since our approach does not mark as a candidate the return value of any external method call that does not receive any symbolic values as an argument.
by assigning symbolic values to all external method calls ou r approach can be easily extended to compute data dependencies on every external method call no matter whether its arguments have data dependencies on program inputs.
however computing data dependencies on every externalmethod call may incur many false positives and increase the performance overhead significantly since the number ofexternal method calls encountered during the program executions is not trivial.
in future work we plan to conduct experiments to measure the effectiveness and performance overhead when every external method call is considered as a candidate.
other potential issues .
besides the issues encountered in our evaluations there are still some potential iss ues that may affect the effectiveness of our approach argument side effect some external method calls may have side effects on the receiver objects or method arguments that have data dependencies on program inputs causing some subsequent branches not to be covered control dependency extending our approach to consider control dependency may improve the effectiveness of our approach in some cases static analysis our approach currently computes dynamic data dependencies based on the executed paths and may miss some data dependencies on unexecuted paths.
employing static analysis to analyze all the paths is one option to solve the problem.
nevertheless due to the complexity of programs static analysis may produce false positives on detected data dependencies which would compromise the effectiveness of our approach.
we plan to conduct experiments to evaluate the effectiveness of incorporating argument side effect control dependency and static analysis.
.
related work coverage analysis .
pavlopoulou and young developed a residual coverage monitoring tool for java which provides richer feedback from actual use of deployed software.
since their approach aims to reduce the performance overhead for gathering structural coverage from deployed software their approach does not provide a way to analyze the coverage while our approach analyzes the residual structural coverage gathered from dse to filter out irrelevant problem candidates.
explaining failures of program analysis .
dincklage and diwan propose an analysis language and build a system to produce reasons when program analyses fail to produce desirable results.
the objective of their approach is to express arbitrary data flow analyses using their analysis language andcomputereasons for thefailures.
althoughour approach is remotely related to their approach in terms of helping explain causes of residual structural coverage in t he form of problems our approach focuses on a quite different problem and includes significantly different techniques needed for addressing unique challenges in identifying pro blems that prevent test generation tools from achieving hig h structural coverage.
symbolic execution .
anand et al.
propose typedependence analysis which performs a context and fieldsensitive interprocedural static analysis to identify the parts of the program under test that may be unsuitable for symbolic execution such as third party libraries.
their approach identifies external method calls that are problemat ic in symbolic execution by carrying out static analysis to determine whether an external method call receives symbolic values as arguments.
to identify emcps our approach considers not only data dependencies of arguments of externalmethod calls on program inputs but also data dependencies of partially covered branch statements on external metho d calls for their return values.
.
conclusion in this paper we propose cooperative developer testing where developers provide guidance to help structural testgeneration tools achieve high structural coverage.
to redu ce the efforts of developers in providing guidance we propose a novel approach called covana which precisely identifies and reports problems that cause structural test generatio n tools not to achieve high structural coverage.
covana identifies these problems by computing data dependencies of partially covered branch statements on problem candidate s. we concretize covana to identify problems faced by dse and present two techniques to identify emcps and ocps the top two major types of problems.
we also evaluate covana on two open source projects and the results show that covana effectively identifies emcps and ocps.