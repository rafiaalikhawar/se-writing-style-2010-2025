verifying ctl live properties of infinite state modelsusing an smt solveramirhossein vakili and nancy a. daycheriton school of computer scienceuniversity of waterlooontario canada n2l 3g1 avakili nday uwaterloo.caabstractthe ability to create and analyze abstract models is an im portant step in conquering software complexity.
in this pa per we show that it is practical to verify dynamic proper ties of infinite state models expressed in a subset of ctldirectly using an smt solver without iteration abstraction or human intervention.
we call this subset ctl live and itconsists of the operators of ctl expressible using the leastfixed point operator of the mu calculus which are commonlyconsidered liveness properties e.g.
af au .
we showthat using this method the verification of an infinite statemodel can sometimes complete more quickly than verifyinga finite version of the model.
we also examine modellingtechniques to represent abstract models in first order logicthat facilitate this form of model checking.categories and subject descriptorsd.
.
software program veri fication formal methods model checking f .
.
specifying and verifyingand reasoning about programs mechanical verification f. .
mathematical logic temporal logicgeneral termsverificationkeywordsctl live first order logic infinite state model model check ing smt solver1.
introductionabstraction is a key element to conquering complexity inthe development of software .
we need tools that sup port reasoning about abstract models of systems in order tobetter understand our models and to detect errors earlierpermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redistribute to lists requires prior specificpermission and or a fee.fse november hong kong chinacopyright acm ... .
.in the development process.
abstract models are often ex pressed using infinite or complex data structures.
temporallogic model checking of the dynamic behaviour of mod els with infinite state spaces without the use of abstractionis usually considered beyond the realm of first order logic fol reasoners because of the iterative nature of the fixedpoint or transitive closure computation.
however withthe recent advances in smt satisfiability modulo theories solvers that have turned first order reasoners into powerful e cient verification tools it is worth taking another lookat the problem of how to express the temporal logic modelchecking problem in fol.
some results use an smt solver it eratively to analyze invariants of infinite state systems e.g.
.
these methods are guaranteed to terminate withoutapproximation only if the property is not satisfied.in recent work we showed that the validity of proper ties within a subset of the temporal logic ctl computationtree logic can be expressed in fol directly without theuse of iteration.
we called this subset ctl live and it con sists of operators that are commonly used to describe live ness properties i.e.
those expressible using the least fixedpoint operator of the mu calculus e.g.
af au .
we alsoshowed that ctl live is maximal with respect to fol inthe sense that ctl operators that are not within ctl live e.g.
invariants are not expressible in fol .our fol theory for ctl live creates the possibility ofthe following practical use model the system as a poten tially infinite kripke structure in fol add automaticallygenerated constraints based on the ctl live property andgive the problem to an smt solver to solve by itself.
ifthe property is valid theoretically with enough resources the smt solver can complete the analysis because fol isrecursively enumerable.
this method is elegant in its sim plicity no iteration or abstraction is required and no userintervention is needed to determine reachability constraints inductive invariants .we evaluate the practical application of this theory througha set of case studies.
we address three open questions .will this method work in practice?
in other words arestate of the art smt solvers e cient enough to ana lyze properties of the dynamic behaviour of infinitestate systems?
.how e cient is the model checking of an infinite statemodel in comparison to the analysis of a finite versionof the same model?
.are there modelling techniques that facilitate the useof smt solvers for model checking?permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
213c i n t e g e rinitial condition c p1 p2 c c c c figure a simple counter c 0initialc 2c 3c ...c ...c ...figure the kripke structure represented by thesystem in figure 1we have chosen a varied collection of four case studies drawnfrom di erent sources.
each has an infinite state spacethrough the use of integers or more complex data types.our results show that our approach does work in practiceand can verify liveness properties of infinite state modelsquickly using the smt solvers z3 and cvc4 .
in fact for some of the case studies we show that the verificationof the infinite state system completes more quickly than theverification of the same problem with limited ranges in finitesolvers such as alloy and cadence smv .
through out the paper we consider questions regarding modellingtechniques to facilitate this form of dynamic analysis.finally we address the verification of safety properties which are not part of ctl live .
we show that the induc tive invariant approach to verifying invariants is not com plete for infinite state systems an inductive invariant for asafety property does not always exist.we believe our results regarding the model checking ofinfinite state systems automatically are an exciting step for ward in the quest to provide automatic reasoning tools forabstract models of dynamic systems.the rest of this paper is organized as follows section 2provides the background material needed to understand ourresults.
section describes the process and the chain of toolsthat we use to verify our case studies.
the case studies arepresented in section .
section discusses modelling choicesthat have an e ect on the performance of the tools we use.section presents our theoretical result on the method offinding inductive invariants for model checking safety prop erties.
section describes related work and section con cludes the paper.
.
backgroundin this section we briefly present the background conceptsneeded to understand our results.
a kripke structure is abasic way of modelling the dynamic behaviour of a system.akripke structurek hs s0 n piis a four tuple wheresis a set of states s0is a non empty subset ofscalledthe initial states nis a total binary relation overscalledthe transition relation andpis a set of labelling predicates where each labelling predicate is a subset ofs.
a kripkestructure is infinite if and only if its set of states is infi nite.
kripke structures are used to define the semantics oftemporal logics.computation tree logic ctl is a temporal logic thatallows us to describe properties over possible computationpaths of a system .
ctl contains all the logical connec tives of propositional logic and a set temporal connectives.each temporal connective consists of two parts apath quan tifierand astate quantifier.
the path quantifiers area forall ande exists .
the state quantifiers arex next state f eventually g globally andu strong until .
the syn tax of ctl is defined for a given set of labelling predicatesp p 1 2wherep2p ex ax ef af eg ag 1au 1eu a kripke structure defines a set of computation paths whereeach path represents a trace of execution.
a computationpath starting at states2sis an infinite sequence of states s07!s17!...such thats s0and for everyi n si si .
the satisfiability relation for ctl c is usedto give meaning to ctl formulae.
the notationk s c denotes that the statesof the kripke structureksatisfiesthe ctl formula andk s6 c is used whenk s c does not hold.
the satisfiability relation for ctl c i sdefined by structural induction on k s cp p s holds wherep2pk s c k s6 c k s c k s c 1andk s c 2k s cex 9s02s n s s0 k s0 c k s caf for all pathss07!s17!...such thats0 sthere exists anisuch thatk si c .k s c 1eu there exists ajand a path s07!s17!...
such thats s0 k sj c andfor alli jk si c .the connectives above form a complete fragment of ctl e.g.
eg is equivalent to af .
a kripke structureksatisfies the ctl formula denoted byk c i for alls2s0we havek s c .example1.figure represents a simple asynchronouscounter system.
there are two processes in this system p1andp2.
they both have access to a shared variable of typeinteger c. at each moment in time one of the processeschanges the value ofc p1incrementscby2units andp2by3units.
in this asynchronous system the order in whichthe processes are executed is not known as a result whenc in the next stepc 102orc 103depending on whichprocess has been executed.
the initial value ofcin thissystem is0.
we want to use ctl to study the behaviourof this system.
figure represents a part of the kripkestructure of the counter system in figure .
the set ofstates of this kripke structurekis the set of all positiveintegers s integer.
this kripke structure has only one2141 declare fun init int bool declare fun next int int bool define fun p1 c int cn int bool cn c define fun p2 c int cn int bool cn c assert forall c int init c c assert forall c int cn int next c cn or p1 c cn p2 c cn figure smt lib specification of the model in figure 1table satisfiability relationsnotationdescriptionk c kripke structureksatisfiesctl formula .symbolic k c symbolic kripke structuresymbolic k satisfies ctlformula .
fol formula is valid with re spect to the set .initial state s0 and the transition relation satisfiesthe following property c c0 2ni c0 c 2 c0 c 3this kripke structure satisfiesefc i .
e .
k cefc since there exists a path from the initial state to a statewherecbecomes5 on the other handk6 cafc sincenot all paths eventually makecequal to5.
if processp1isexecuted for the first steps cnever becomes5.
since eachprocess increases the value ofc we can see thatk cafc 5holds.
.
kripke structures in fol andsmt solversfirst order logic fol provides quantifiers along withpropositional logic connectives to describe properties overrelationalandfunctional symbols .
aninterpretationde termines the content of each relational and functional sym bol.
a problem in fol consists of a set of formulae.
ev ery interpretation that satisfies all these formulae is called asatisfying interpretation.
using the concept of satisfiability validity is defined as follows definition1.
validity suppose is a set of fol for mulae and is a fol formula entails d e n o t e db y i every interpretation that satisfies all the formu lae in also satisfies .from this definition we can prove that i s is unsatisfiable.a satisfiability modulo theories smt solver for shortsmt solver is an automatic tool to check the satisfiabilityof a set of fol formulae .
an smt solver di ers froma general purpose fol satisfiability checker in one majorway if a built in type such asintegeris used in a formula the smt solver considers only the standard interpretationfor that type and the defined operations over it.
smt libis a standard notation that state of the art smt solvers ac cept as input .
a specification of a problem in smt libconsists of four parts declaration of user defined types declaration of functional symbols used in the model1 definitions that are used to simplify the model and a setof constraints where each constraint is a formula.
smt libdoes not distinguish between terms and formulae.
a formulais a term of typebool.
to ease the parsing of smt lib spec ifications by smt solvers each smt lib specification is asequence of s expressions.example2.figure presents a symbolic representationof the kripke structure of figure as an smt lib specifica tion.
this specification does not contain user defined types.lines and declare thatinitandnextare relational sym bols overintandint intrespectively.
to increase thereadability of this specification we have definedp1andp2in lines and .
a definition is essentially a macro.
inlines crepresents the current state andcnthe value ofcin the next state.
line is a constraint stating that thestatecis an initial state i it is equal to zero c .
theconstraint in line states thatcnis the next value ofci eitherp1holds between them orp2.as this example suggests to symbolically represent a kripkestructure in fol we need at least two relational symbols initrepresenting the set of initial states andnextrepre senting the transition relation.
the types ofinitandnextares b o o lands s b o o lrespectively.
in these dec larations sdepends on the types of the variables used inthe specification.the symbolic representation of a kripke structurek whichwe denote bysymbolic k is a set of fol formulae that de finesk.
the formula in line of figure in infix form usingthe classical symbols for fol connectives is the following 8c cn int.next c cn p1 c cn p2 c cn in this case the transition relation is uniquely defined.
how ever in general a symbolic kripke structure can representa set of kripke structures rather than a single one.
under specification of the transition relation and the use of user defined types and operations that are not fully interpretedare the main reasons that a symbolic kripke structure canrepresent multiple kripke structures.
in all our case studies we uniquely defined the transition relation.we definesymbolic k c to mean that every satisfyinginterpretationkofsymbolic k satisfies the ctl formula symbolic k c i everykthat satisfiessymbolic k a l s ok c ifsymbolic k has only one satisfying interpretation up toisomorphism namelyk thensymbolic k c is equiva lent tok c .
table is a summary of the satisfiabilitynotations used in this paper.1a relational symbol is a functional symbol of typebool.215ctll2fol case of1 p wherepis a labelling predicate2 8s d e s d e s sctll2fol 1 8s d e s d 1e s d 2e s sctll2fol sctll2fol 8s d e s d 1e s d 2e s sctll2fol sctll2fol ex 8s 9s0 n s s0 d e s0 !d e s sctll2fol ax 8s 8s0 n s s0 !d e s0 !d e s sctll2fol ef d e d e 8s 9s0 n s s0 d e s0 !d e s sctll2fol af d e d e 8s 8s0 n s s0 !d e s0 !d e s sctll2fol 1eu d 2e d e 8s d 1e s 9s0 n s s0 d e s0 !d e s sctll2fol sctll2fol 1au d 2e d e 8s d 1e s 8s0 n s s0 !d e s0 !d e s sctll2fol sctll2fol figure the definition ofctll2fol from .
is a ctl live formula.temporal part 1 ex ax ef af 1eu 1au 2propositional part p 1 2wherepis a labelling predicate.figure ctl live2.
ctl live verification as a fol theoryin recent work we presented a subset of ctl thatwe called ctl live and described how to represent the ver ification of a ctl live property as a validity problem infol.
ctl live is presented in figure .
the grammar ofctl live does not allow a temporal connective to be withinthe scope of negation e.g.
the formulaaf is part ofctl live but af is not.ctl live includes the ctl connectives whose semanticsin the mu calculus are defined using theleast fixed pointoperator.
the intuition behind reducing ctl live modelchecking to fol validity checking is that model checking isabout verifying whether the set of initial states is includedin the set of states that satisfies a property.
if the ctlproperty under study is expressible as thesmallestset thatsatisfies some fol formulae then checking whether the setof initial states is a subset of the smallest one is equivalentto checking whether the set of initial states is a subset ofallof them s0 x2 xi s0 xfor everyx2 in this equation contains all the sets that satisfy someproperty andtx2 xis the smallest one.
this property hasa higher order quantifier over sets which is not available infol but it is implicitly available in the quantification overinterpretations in the definition of validity in fol defini tion .to model check a symbolic kripke structuresymbolic k and a ctl live formula we use a function calledctll2fol shown in figure .
the functionctll2folrecurses over thestructure of and generates a set of fol formulae.
in fig smt lib speccvc4z3avestanavestan modelctl live formula figure overview of our methodure d eis a new relational symbol that is introduced byctll2folfor the formula for a labelling predicatep dpeis equal top.
the complexity ofctll2folis linear withrespect to the size of .the following theorem allows us to reduce ctl live modelchecking to validity checking in fol theorem1.
model checking ctl live letsymbolic k be a set of fol formulae that specifies a kripkestructure s we have symbolic k c symbolic k ctll2fol s0 d ewhered eis a relational symbol generated byctll2folands0is a predicate describing the initial set of states .
.
methodour theoretical result regarding the ability to express theverification of ctl live properties in fol makes it possibleto turn a ctl live verification problem into a problem thatcan be directly solved by an smt solver without iteration orhuman intervention.
the approach that we use to implementour method is described in figure .a model is created in fol using a tool that we call aves tan.
our current version of avestan is a complete reengi neering of our earlier tool also called avestan whichwas a language and tool to support the creation of models in2161 declare fun af int bool assert forall c int c af c assert forall c int forall cn int next c cn af cn af c assert not forall c int init c af c figure declarations and formulae that are added to figure to model checkafc 5smt lib.
it was strongly based on alloy but the tooltranslated the model into an smt lib specification.
ournew tool is implemented in python3 and uses python asboth the object and meta language for expressing models infol.
it produces specifications in smt lib for analysis byan smt solver.we implemented the functionctll2folof figure inavestan to create the constraints needed for the verificationof a ctl live property.
using avestan we transform amodel plus these constraints into an smt lib specificationand check the validity problem as a satisfiability problemusing both cvc4 version .
and z3 version .
.
.
thefollowing is an example that illustrates the method of ap plying the result of theorem to verify a declarative modelusing an smt solver.example3.suppose we want to prove that in the kripkestructure of figure ceventually becomes larger than by using an smt solver.
we need to prove that this kripkestructure satisfiesafc .afis part of ctl live there fore we can use the result of theorem .
according to thistheorem we need to computectll2fol afc .f o l l o w ing the definition ofctll2folat line ctll2fol afc is a set with two constraints .8s d e s d e s .8s 8s0 n s s0 d e s0 d e s whered eisc nisnext of figure andd eis a newrelational symbolafof typeint bool.
since the state ofthe system is represented by an integer the quantificationover states becomes quantification over integers.
written interms of the model and property these constraints are .8c int.c af c .8c int.
8cn.next c cn af cn af c now we need to check whethersymbolic k sctll2fol afc entails the following 8c int.init c af c we know that entails i s is unsatisfiable there fore we add thenegationof the formula in equation tosymbolic k sctll2fol afc and run the smt solverto check for the satisfiability if it is unsatisfiable then wecan conclude thatafc 5holds.
figure presents thedeclaration ofaf line along with the three formulae lines in smt lib notation that need to be added tofigure to model checkafc .
the output of z3 onthis model isunsat which tells us that the original modelsatisfiesafc .
.
case studiesin this section we present four case studies that testwhether it is possible to use our theory and method to verifydynamic properties in ctl live of abstract models using ano the shelf smt solver.
our models were chosen from a va riety of sources and domains.
as we present each case study we discuss how it is modelled in fol and when possible we compare to how it was modelled and verified previously.all our experiments were run on an intelr coretmi7 3667umachine running ubuntu .
bit with up to .5gb ofuser memory.
to analyze the case studies we used thesolvers in their default mode without any flags or a cus tomized configuration.
the smt lib specifications of thecase studies and other models developed for this paper areavailable on line2.
.
case study leader election protocolthe leader election model is a protocol to elect a processas the leader among a finite set of processes that form aring .
a finite instance of it was previously verified byjackson using the alloy analyzer .
in the leader electionmodel each process in the ring can only communicate withits successor and predecessor and there is no centralizedcontroller.
each process has a unique identifier id and avalue to represent who this process thinks is the leader ofthe ring my lead .
the goal of the protocol is that everyprocess including the leader will eventually recognize thatthe process with the greatest id is the leader.
we modelled asynchronous version of this protocol at each moment everyprocess passes to its predecessor its value formy leadandreceives from its successor the successor s value formy lead.if the received value is greater than the process currentvalue ofmy lead the process updates its value with thereceived one otherwise it is left unchanged.
in the initialstate the value passed by a process is its own id.we used unbounded integers to model ids and time.
foreach process we declared a functional symbolmy leadoftypeint int.
we have a fixed number of processes.
thering topology is enforced by an ordering on the processes where the successor of the last process is the 0thprocess andfor any other processes such asi the successor isi .the properties we verified are that every process will even tually recognize the leader af my lead i lead id wherelead idis the largest id among the current processes my lead ithe value ofmy leadfor the ithprocess.
thus foriprocesses we haveiproperties which we conjunctedtogether and checked.
in this model the setint which isused to represent time is also the state space of this system.the following table shows the performance of z3 for di erentnumbers of processes .48s44.38s3m24.64s50m44.09s2h37m11.69s2 number of processestime in seconds z3alloy figure leader election model z3 vs alloycvc4 with even processes could not finish the verification.when we modelled this problem with an unbounded num ber of processes the verification in either smt solver doesnot complete.
verification for an unbounded number of pro cesses would likely require user intervention to deduce aninvariant that would help the smt solver verify the prob lem.we also modelled this synchronous version of the algo rithm in alloy .
to verify the liveness properties usingalloy we needed to finitize all sets including time.
weset the bounds on time and ids to be the number of pro cesses.
figure which is in logarithmic scale to increase thereadability of the plot compares the performance of z3 onmodels where there are no bounds on time and ids to theperformance of the alloy analyzer version .
using min isat where time and ids are bounded.
in the alloy models the properties were conjuncted together and verified as inz3 .
as this figure shows our approach to the verificationof this protocol with an infinite state space is much fasterthan alloy where every set needs to be finitized.while our verification does require a bound on the numberof processes it is significant that it does not require a boundon time.
when we finitize time as in the alloy model weare bounded model checking bmc .
when usingbmc to verify a liveness property spurious counterexam ples can result because the bound is insu cient to concludeliveness.
in general computing a su cient bound to get areliable result is hard and in some infinite cases it is impos sible.
in our smt lib models we use unbounded integersto represent time.
since smt solvers check satisfiabilitywith respect to standard interpretations and this interpre tation for integers guaranties thatinthas an infinite setof elements our technique does not produce spurious coun terexamples.
.
case study bakery algorithmthe bakery algorithm ensures mutual exclusion betweentwo processes that run concurrently and asynchronously .bultan gerber and pugh verified that in this algorithm thetwo processes cannot get into their critical sections at thesame time .
their method is an iterative approach thatuses a presburger arithmetic solver.in the bakery algorithm model the state of a process isdetermined by its control state value and a ticket.
the valueof a control state is eitherthinking waiting orcritical.
aticket is a non negative unbounded integer.
since we havetwo processes the state space of this system s is the fol lowing s t w c int t w c intwe modelled the set t w c as an uninterpreted type namedcontrolstate wheret w andcare three distinctconstants of typecontrolstate.
the following is a fragmentof the smt lib specification that modelscontrolstateen suring that each value is distinct declare sort controlstate declare fun t controlstate declare fun w controlstate declare fun c controlstate assert not t w assert not t c assert not w c besides comparing the value of the tickets this algorithmalso manipulates the value of tickets using the addition op eration on integers as a result an uninterpreted type with atotal ordering would not be su cient to express this model.each transition in our model is defined as a functional sym bol of types s bool.
by combining these transitions we modelled the transition relation.for this case study we verified that any process e.g.
pro cess that is waiting to get into its critical section willeventually succeed ag c1 w afc1 c this is an invariant property therefore to verify this prop erty we needed to show that every reachable state satisfiesc1 w afc1 c.agis not part of ctl live there fore we cannot ask the smt solver to prove this propertydirectly.
instead we created a more general property thatimplies the formula of equation we proved that the set ofallstates which includes the reachable states satisfies thefollowing property c1 w af c1 c dead end wheredead endis true of a state i that state does not haveany next state.
this model has a non total transition rela tion however according to the semantics of ctl correctpaths of the model must be infinite and only those must beconsidered.
rather than making the transition relation to tal we introduced the idea of a dead end state which isone from which there are no next states and thus it satisfiesa ctl formula that has a universal path quantifier.we stated this property by making the set of initial statesbe the set of all states.
this revised property is part of ctl live.
z3 verified this property in .
seconds and cvc4 in8.
seconds.another algorithm studied by bultan gerber and pughis the ticket mutual exclusion algorithm .
we tried toverify an invariant property similar to equation for thismodel using a similar technique to the bakery algorithm however neither smt solver terminates within a thresholdof hours.
it is likely that this property of this model is only218250200040006000800010000ub100101102 vehicle speedtime in seconds cadence smvz3 unbounded figure collision avoidance model in cadencesmv ub unbounded satisfied within the reachable set of states and therefore itdoes not hold for the entire set of states.
.
case study collision avoidance state flow modelour third case study is a stateflow model of a collisionavoidance feature used in a modern vehicle .
it waspreviously used with other feature models to check for fea ture interactions using cadence smv.this case study has control state complexity in a hierar chical non concurrent state transition model with basicstates.
however there are two variables manipulated by thetransitions of the model speed and threshold which deter mine when collision avoidance needs to be engaged.
thesevariables are used in the triggers of transitions and thus a ect the control logic of the system and therefore are notremoved by standard cone of influence reductions.
in ourmodel the speed of a vehicle is modelled as an unboundedinteger and threshold is a constant positive integer.
weverified that every basic state is reachable without a boundon speed and threshold.
this property is a conjunction of 9efformulae.
z3 verifies all these properties together in .58seconds.
cvc4 terminates in .
seconds havingunknownas output.
theunknownmeans the solver cannot verify norrefute the property.because we had access to the original models we can com pare our results to using cadence smv to analyze the state flow models for di erent finite bounds on speed and thresh old.
figure presents these results.
as this figure shows the performance of cadence smv degrades as the size ofspeed and threshold is increased.
.
case study file systemour last case study is a file system that was originallymodelled in z .
woodcock and davies use natural de duction to prove properties manually about this model.the state of the file system is represented as a partialfunction fromkeyst odatanamedcontent.
there are threeoperations that change the state of the file system addinga new entry deleting an existing entry andwriting a newdata to an existing key.the major di erence between the file system model andour other case studies is in its state space each state isa function whereas in the other case studies a state is atuple that includes an infinite element.
since quantificationover functions is not allowed in fol we cannot directly useour technique to model check a ctl live property of thismodel.borrowing a technique used in alloy models in ourmodel we explicitly introduced the state space as a newuninterpreted setstateand declaredcontentas follows content state key datawherecontent s k dis interpreted as the content ofthe file system at statesfor the keykisd.
to model thefact thatcontentis apartialfunction fromkeytodata we declare a constantnullof typedata the value ofcon tent s k being equal tonullmeans that the content ofthe file system at statesfor the keykis empty.
in alloy this technique manifests itself in the use of a state objectto encapsulate the elements of the state.the disadvantage of explicitly introducing the setstateis that it is uninterpreted and it may result in spuriouscounterexamples.
for example the following property isnot entailed by this model content s k null 9s0 delete k s s0 this property states that if at statesthe content of keykis not empty then we can deletekfrom it and go to somestates0.
the spurious counterexample for this property is asingle state with a non empty content.
we need to ensurethat interpretations that do not include enough states areeliminated from the analysis.
to eliminate these spuriouscounterexamples we need to interpret stateby addingsome axioms to the model.
these axioms are calledgener ator axioms .
for our file system model where only aperformed operation can change the state a set of standardgenerator axioms exist for every operation we needed toadd a formula stating that if an operationopis applicableon a states1 then there exists another state such ass2that is the result of performingopons1 in other words we needed to state that all the operations are total.
forexample the generator axiom fordeleteis same as the for mula in equation exceptsandkare bounded by universalquantifiers.we verified a bisimilarity property that the operationwritecan be simulated by some combination ofaddanddeletefor all possible states of the file system.
for thispurpose we created two models with the same state space one that includes all operations model and one thatincludes onlyaddanddelete model .
we assume thatsome states2is the result of writing something to the filesystem at some states1 then we check in model thats2is reachable froms1 write k d s1 s2 s s efs s 2z3 verified this property in .
seconds and cvc4 in .69seconds.
.
conclusionsour case studies show that our method is practical for avariety of di erent examples.
in all our models we wereable to leave some element of the model state unbounded219table run time of z3 and cvc4 for each casestudy in seconds dnv did not verify case studyz3cvc4leader election processes8.48dnvleader election processes44.38dnvleader election processes204.64dnvleader election processes3044.09dnvleader election processes9431.69dnvbakery algorithm0.
.64collision avoidance0.58dnvfile system0.
.
number of processestime in seconds 1allite figure z3 on di erent models for the leader elec tion problemand complete verification of a property in ctl live.
weused unbounded integers user declared sorts and a partialfunction as part of the state.
table summarizes the runtimes of z3 and cvc4 for all the case studies.
z3 clearlyperforms better than cvc4 for the data types used in ourcase studies.
.
modelling optimizationsin this section we provide some insights about factorsthat can be used by a modeller to develop models that aremore e cient to analyze in smt solvers.first we consider the trade o in the number of vari ables and the number of constraints.
for the leader electioncase study we have two choices for expressing the id of theleader .declare a new constant and assert that this constant isequal to the id of some process and that it is greateror equal to all the ids or2.use the if then else construct in smt lib and compareall the ids with each other to determine the largest.the first approach adds nconstraints and a new variable wherenis the number of processes.
the second approachdoes not introduce any new constraints or variables butthe term that represents the greatest id is complex.
plotite of figure shows the sum of the times for verifyingnproperties using the ite modelling approach wherenisthe number of processes.
plot shows the same problemusing the first modelling approach.
clearly the approachof creating a single more complicated constraint performedless e ciently that having a number of simple constraintswith more variables in this case.in addition we can compare verifyingnproperties to gether as a conjunction of constraints to verifying eachproperty individually.
plot all of figure is the result ofverifying the conjunction of the properties.
for larger num bers all performs more poorly than plot which is thesum of the times to verify each property individually3.
thisresult again supports the hypothesis that simple constraintsare better for smt solvers than complex ones.next we consider the e ect of the use of quantifiers inthese problems.
since we use integers to model time in theleader election case study rather than using our ctl livectll2fol the eventuality property can be expressed usingan existential quantifier as in 9t int.t my lead i t leader idsince alloy s input language is as expressive as fol wecan use ourctll2folfunction to model check a ctl liveproperty using the alloy analyzer.
we set the size of all thesets in the alloy model equal to the number of processes.figure presents the result of trying these two approachesboth for alloy and z3.
as this figure shows the alloy an alyzer is on average .27x faster when using the quantifiermethod to express the properties compared to our ctl livetheory in alloy.
on the other hand z3 on the smt libmodels that used our ctl live theory was on average .98xfaster than using the quantifier method on the model.
ourconclusion from this observation is that the modelling meth ods also depend on the analysis tool that is used.
however z3 using the ctl live theory with unbounded integers wasthe most e cient method.
.
inductive invariantsthe verification of invariants is often of interest for safetyproperties of models.
a propertypis aninvarianti itholds in everyreachablestate of a kripke structure.
ac cording to the semantics of ctl pbeing an invariant of akripke structurekis equivalent toksatisfyingagp.agis not part of ctl live and previously we proved that itsmodel checking is not reducible to fol entailment checking theorem2.
maximality of ctl live ctl live isthe largest fragment of ctl that its model checking is re ducible to entailment checking in fol in other words thetemporal part of ctl live cannot be extended witheg ag o r for model checking a symbolic kripke structureinfol .in our proof of this theorem we showed that the complementof the halting problem on an empty tape for a determinis tic turing machine dtm is reducible to universal model3since the alloy models were analyzed using the all ap proach in section .
we have reported the results of theall approach using z3 even though the approach per forms better.
number of processestime in seconds alloyquantifier methodctl live theory number of processestime in seconds z3quantifier methodctl live theory figure alloy and z3 with di erent approaches for the leader election case studychecking ofeg ag .
the complement of the halting prob lem is not recursively enumerable and as a result it cannotbe reduced to entailment checking in fol which is a re cursively enumerable problem.
we also know thateg isequivalent to af .
sinceafis included in ctl live cannot be added as well.
therefore the verification ofan invariant cannot be done by an smt solver directly andalternative techniques are needed.
a common approach tothis problem is to find an inductive invariant.
a propertypis aninductive invariantfor a kripke structureki itsatisfies the following two constraints .8s s0 s p s .8s s0 p s n s s0 p s0 the first constraint states that every initial state satisfiesp and the second one states that if the statessatisfiespands0is reachable fromsin one step thens0satisfiesp.
it is easyto see that every inductive invariant is also an invariant ofa kripke structure but every invariant is not necessarily aninductive invariant.
checking if a property is an inductiveinvariant is computationally easier than checking if it is aninvariant.according to theorem model checkingagis not re cursively enumerable whereas inductive invariant checkingis.
motivated by this fact the inductive invariant method tocheck if a propertypis an invariant has gained popularityfor both finite and infinite kripke structures.
many resultshave found inductive invariants by hand.
the method ofic3 is a way to find automatically inductive invariantsfor finite systems and this approach has been generalized innuxmv in an incomplete approach to finding automat ically inductive invariants for infinite state systems.generally speaking the goal is to find an inductive invari ant that is strong enough to prove the original invariant ofinterest.
this method is essentially as follows to prove thatpis an invariant first check if it is an inductive invariant if it is not then try to compute or guess anrso thatp ris an inductive invariant and therefore pis proved to bean invariant.
the formulartries to eliminate unreachablestates that do not allowpto be an inductive invariant.a important question is does anralways exist whenpis an invariant?
for finite kripke structures the answer is yes since the number of states is finite rcan enumerateall reachable states.
however for infinite state systems wecan now show thatris not guaranteed to exist.theorem3.
incompleteness of inductive invariantmethod there exists a kripke structurekand a propertypsuch thatpis an invariant ofkand there is no formularsuch thatp ris an inductive invariant fork.proof.we have shown that proving a dtm doesnothalt on an empty tape is reducible to proving that a formulanamed haltis an invariant .
if anrexists then wecan enumerate allr s and check if halt ris an inductiveinvariant in parallel therefore a semi decision procedure forthe complement of the halting problem exists and it is recur sively enumerable.
this is a contradiction and as a result such anrdoes not always exist.
.
related worksat and smt solvers have been used for bounded modelchecking .
these methods use a reasoner directly formodel checking by expanding the transition relation for afinite number of steps.k inductionis a technique for unbounded model checkingof safety properties .
this technique extends boundedmodel checking by proving that bounded model checking forthe bound k is su cient.
the number k is dominated by thediameter of a kripke structure.
the diameter is computediteratively using a sat solver to check the equivalence oftwo formulae the equivalence holds i no new state can bereached by taking more than k steps.
in terminationis guarantied due to the finiteness of the kripke structuresunder study.bultan gerber and pugh use presburger formulae to rep resent infinite sets of states symbolically .
their model221checking approach for invariants requires a fix point calcu lation and termination is achieved by using conservativeapproximation.
this approach allows false negatives.recently ic3 has been generalized using smt solvers toverify safety properties of infinite systems iteratively .these approaches also incorporate abstraction techniques togain better performance.based on the deductive system of kesten and pnueli beyene popeea and rybalchenko encoded ctl modelchecking of infinite state systems into forall exists quantifiedhorn clauses .
the contribution of is to develop a solverfor forall exists quantified horn clauses and demonstrate itsuse for model checking ctl properties.
their method re quires the models and the model checking constraints to beexpressed in forall exists quantified horn clauses and to sat isfy some well foundedness conditions whereas our resultshold for any set of fol constraints which may describemultiple kripke structures.
termination of their method isnot guaranteed.in comparison to these approaches our approach does notrequire using an smt solver iteratively but it is only appli cable to a subset of ctl.
also our approach is theoreticallyguaranteed to terminate when the property is valid whereasthe other approaches terminate when the property is notsatisfied.compositional model checking and abstraction are techniques that can be applied to model check an infi nite state system.
our approach could be used along withthese techniques to verify safety and liveness properties ofan infinite system.
.
conclusionin this paper we have shown that it is practical to usesmt solvers in particular z3 to verify ctl live proper ties of infinite state models without the need for iteration abstraction or human intervention.
the system is modelledas a potentially infinite kripke structure in fol a theoryof fol constraints is automatically generated based on theproperty and the problem is given to an smt solver to solveby itself.
the decidability of analysis is based on the subsetof fol used to express the model.
because fol is recur sively enumerable with enough resources the analysis willterminate if the property is valid.
we have also shown thatthe analysis of infinite state systems using an smt solvercan be more e cient than the analysis of a finite versionof the model.
smt solvers use deductive analysis ratherthan just state space search and therefore can take advan tage of structures found in abstract models.
we discussedmodelling techniques that facilitate e cient model checkingusing smt solvers.
finally we proved that inductive invari ants do not always exist for safety properties of infinite statesystems.in the future we plan to investigate the scalability of ourapproach for larger models.
however even though the tex tual size of our case studies are all fairly small the modellinge ciencies gained by representing systems abstractly o setsomewhat concerns with respect to scalability.
we are alsoexploring less primitive ways to write fol models the anal ysis of models with richer data types and quantifiers andways to more easily understand counterexamples producedby smt solvers for temporal logic properties.
.
acknowledgementswe thank the reviewers for their insightful and detailedcomments which have improved our paper.
.