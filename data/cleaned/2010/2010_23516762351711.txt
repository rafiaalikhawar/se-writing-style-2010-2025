automatic recovery of statecharts from procedural code moria abadi blavatnik school of computer science tel aviv university tel aviv israel moriaabadi gmail.comyishai a. feldman ibm research haifa haifa university campus mount carmel haifa israel yishai il.ibm.com abstract we have developed a static analysis algorithm that extracts statecharts from procedural implementations of state machines.
the extracted statecharts are semantically equivalent to the original program and can be used for further development instead of the procedural code.
we have implemented this algorithm in a tool called statrec.
we report on the results of running statrec on a number of examples including an implementation of the tcp protocol.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering general terms algorithms keywords state machines statecharts static analysis .
introduction finite state machines are ubiquitous in computing especially in reactive and embedded systems.
existing code contains many instances of finite state machines implemented procedurally.
modern development environments enable the description of finite state machines as statecharts which provide a visual expression of state machines as well as strong and intuitive generalizations that make them exponentially more concise and thus easier to maintain.
however the benefits of these visual formalisms are not available for existing procedural implementations of finite state machines.
as part of our investigation of how to improve the development of reactive systems we have previously suggested the need for refactoring tools for statecharts including permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.refactorings that combine modifications of code and of statecharts .
the latter paper presents a systematic but still manual way to convert a procedural implementation of a finite state machine into a statechart.
here we present statrec a tool that performs this transformation automatically.
the resulting statechart is executable and preserves the semantics of the original program.
further development can be done on the extracted statechart instead of on the procedural implementation of the state machine.
in particular the statechart can be further refactored using the proposed statechart refactoring tools.
statrec is based on a language independent internal representation and is in principle available for every language from which there is a path to that representation.
these currently include java but not yet c c .
we therefore had to translate the examples we report on in this paper manually from c to java.
the translation was as literal as possible to the extent of including some c idioms that are not natural to java.
when c c can be translated to our internal representation this manual step will not be necessary.
.
a first example the example of figure is adapted from a textbook on software development with statecharts .1this example describes a bomb detonation timer which has two states.
in the setting state the user can set the timer using the up and down switches and arm the bomb using the arm switch .
in the timing state the timer counts down the seconds until detonation.
timer ticks appear ten times a second the attribute fine time is on the full second.
however in this state the user can enter a binary code using the up and down switches and press arm to defuse the bomb if the code is correct.
the statechart of figure was generated from this code by the statrec tool.
the two states have been identified as well as the transitions between them including self transitions.
each transition is labeled by the event that causes it the guard that specifies the conditions under which it is taken in brackets if any and the actions executed when the transition is taken following a slash .
in this example it was necessary to create an extra state timing1 because one of the transitions has an associated action that modifies the value of me.timeout which is used in the guard of a subsequent transition.
the timing1 state has an entry action which is executed whenever the state is entered.
the 1the full example as translated to java is available from the authors.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
1public void setting bomb1 me event e switch e.sig case up sig if me.timeout me.timeout break case down sig if me.timeout me.timeout break case arm sig me.code me.state timing state 13public void timing bomb1 me event e switch e.sig case up sig me.code me.code break case down sig me.code break case arm sig if me.code me.defuse me.state setting state break case tick sig if tickevt e .fine time me.timeout if me.timeout system.out.println boom!!!
system.exit figure a procedural finite state machine.
bomb setting up if me.timeout me.timeout down if me.timeout me.timeout timing timing1 me.timeout system.out.println boom!!!
system.exit timing0 tick arm me.state setting state down me.code up me.code me.code arm me.code me.state timing state figure the statechart generated for the program of fig.
.
entry action contains the common part of the code that is executed upon the occurrence of the tick event when the event s fine time is line of figure .
the test for a zero timeout line determines which transition is subsequently taken the code that executes when the condition istrue appears on the transition.
because of the need to create an additional state statrec packaged the two sub states that represent the timing procedure in a super state thus encapsulating them in a single abstract unit.
this example demonstrates some of the issues in extracting a state diagram from procedural code.
these include identifying the state transitions the events associated with each one and other conditions that need to be made into transition guards.
in addition it is necessary to identify the correct placement for pieces of the code these could be placed in entry actions if they are executed unconditionally or on the appropriate transition otherwise.
tests that depend on values that are modified by preceding actions in the same transition are called dynamic choices while those that can be computed on entry are static choices .
only the former require new states to be added.
.
case study the tcp protocol in order to evaluate statrec on larger examples we used it to extract statecharts from the implementation of the tcp protocol from a textbook on the subject .
this is a complete working implementation of the protocol written in c and manaully converted to java for use by statrec.
based on our experience we believe that this code is typical of procedural state machine implementations.
it freely mixes actions and tests makes some state changes in called procedures and even makes calls from one state procedure to another.
the tcp protocol maintains a set of tcp connections each connection has receiver and transmitter components responsible for accepting and sending messages respectively.
these are implemented as separate state machines but they are not independent.
in the implementation we used for our case study the state of the transmitter component is sometimes modified directly by state procedures of the receiver as an external state change that is a change not made as a response to some event.
in addition every connection has its own state but a central component opens and closes connections allocating connection objects from a common pool.
unused connections in the pool are in the free state and exit this state via external state changes.
the receiver component is invoked from the main loop once the specific connection for an incoming packet has been identified.
no events are distinguished upon the arrival of a new packet the state procedures examine various fields of the incoming packet in order to decide what to do.
statrec therefore creates a single packet event.
several external state changes are applied to the receiver component necessitating the creation of the triggered operations to tcpsynsent to tcpclosed etc.
the high level statechart of the tcp receiver component is shown in figure .
in this view the internal details of the super states have been hidden the user can selectively zoom into each as desired.
the generated statecharts contain a lot of text in the transitions mostly in the associated actions.
this may sometimes obscure the structure of the statechart.
in such cases the extract transition method refactoring which replaces an action consisting of a set of statements with a call to a newly generated method could be used to reduce the clutter.
we applied this refactoring manually in figure .
large conditions in guards could similarly be extracted into methods.
the size of the code and conditions does not239tcpreceiving tcptimewait enterexit 60 tcpsynrcvd enterexit 74 enterexit 71 enterexit 68 tcpclosewait packet tcpclosewait process free tcpsynsent enterexit 86 enterexit 83 enterexit 80 tcpfin1 enterexit 104 enterexit 101 enterexit 98 tcplisten packet tcplisten process tcpclosed packet tcpreset pep result syserr tcpfin2 enterexit 89 tcplastack packet tcplastack process tcpestablished enterexit 77 tcpclosing enterexit 95 enterexit 92 to free to tcplastack to tcplisten to tcpsynsent to tcpfin1 to tcpclosed enterexit 60 enterexit 74 enterexit 71 enterexit 68 enterexit 86 enterexit 83 enterexit 80 enterexit 104 enterexit 101 enterexit 98 enterexit 89 enterexit 77 enterexit 95 enterexit 92 figure the high level statechart of the tcp receiver component.
1int tcpsynsent tcb ptcb ep pep ip pip ip pep.ep data tcp ptcp tcp pip.ip data if ptcp.tcp code tcpf ack !
ptcp.tcp ack ptcb.tcb iss ptcp.tcp ack ptcb.tcb snext return tcpreset pep if ptcp.tcp code tcpf rst !
ptcb.tcb state tcps closed ptcb.tcb error tcpe reset tcpattemptfails tcpkilltimers ptcb signal ptcb.tcb ocsem return ok if ptcp.tcp code tcpf syn return ok ptcb.tcb swindow ptcp.tcp window ptcb.tcb lwseq ptcp.tcp seq ptcb.tcb rnext ptcp.tcp seq ptcb.tcb cwin ptcb.tcb rnext ptcb.tcb rbsize tcpacked ptcb pep tcpdata ptcb pep ptcp.tcp code tcpf fin if ptcb.tcb code tcpf syn !
ptcb.tcb state tcps synrcvd else tcpcurrestab ptcb.tcb state tcps established signal ptcb.tcb ocsem return ok figure the tcpsynsent state procedure .
pose a problem for the analysis but makes it difficult for developers to understand the statechart unless abstracted into separate methods.
to demonstrate the detailed results of the algorithm we use the synsent state extracted from the tcpsynsent procedure shown in figure .
the part of the statechart computed from this state procedure appears in figure .
theinitial state of the synsent super state synsent0 appears in the left part of the figure.
a transition labeled packet leads from it to synsent1 which contains as an entry action the two assignments from lines of the code.
these are executed unconditionally and their values are used in subsequent tests and actions.
the body of the tcpsynsent procedure contains four tests all of which are used in the determination of the target state.
these make for five possible behaviors.
however two of these have actions that affect the ptcp object prior to the test that uses it line .
a new state synsent2 had to be created to accomodate these actions.
the tcp receiver component has states including synsent but the implementation has only state procedures since the free state has no behavior associated with it.
a total of lines of java code were analyzed to create the final statechart which has states grouped in super states.
the additional states were required by dyanmic choices.
one for each of the state procedures was required because each starts with assignments to two variables that hold the ip and tcp packets and for other side effects.
in addition static choices were created.
figure shows the generated high level statechart for the tcp transmitter component.
the transmitter is implemented using four state procedures with external state changes initiated by the receiver.
a total of lines of code were analyzed creating dynamic and static choices.
the textbook from which this code was taken provides state diagrams for the receiver and transmitter components.
the statecharts generated by statrec are similar but not identical to those shown in the book.
for example the transmitter state diagram in the book has a transition from retransmit totransmit triggered by an event called ack arrives.
in the code this transition is implemented as an external change of the transmitter s state by the receiver when the latter receives an acknowledgment.
also the book shows the transmitter as moving from idletotransmiton the event send.
however the tcpxmit procedure which implelements the transmit state also checks for this event and may change the state to persist under certain240synsent2 ptcb.tcb swindow ptcp.tcp window ... closed synsent1 pip ip pep.ep data ptcp tcp pip.ip data established ptcb.tcb state tcps closed ptcb.tcb error tcpe reset tcpattemptfails tcpkilltimers ptcb signal ptcb.tcb ocsem result ok synrcvd synsent result ok ptcp.tcp code tcpf ack !
ptcp.tcp ack ptcb.tcb iss ptcp.tcp ack ptcb.tcb sne xt result tcpreset pep packet tcpcurrestab ptcb.tcb state tcps established signal ptcb.tcb ocsem result ok ptcb.tcb state tcps synrcvd result ok figure the part of the tcp statechart showing transitions emanating from the synsent state.
tx tcprexmit tcpxmit enterexit 13 enterexit 10 tcpidle enterexit 19 enterexit 16 tcppersist delete result ok persist tcppersist process persist send tcppersist process send retransmit result ok to tcpidle to tcpxmit enterexit 13 enterexit 10 enterexit 19 enterexit 16 figure the high level statechart of the tcp transmitter component.
conditions.
this violates the standard semantics of finite state machines in which one event cannot cause two successive transitions.
these examples highlight the differences between a state diagram provided for documentation or didactic purposes and an executable statechart that captures the full behavior of the program.
.
discussion we presented statrec a tool that extracts statecharts from procedural implementations of state machines.
the statecharts recovered by statrec are relatively flat and do not take full advantage of the capabilities of the statechart formalism.
once statecharts are recovered however they can be further refactored by combining states into superstates extracting parallel components and extracting substates into new classes .
statrec is limited by the amount of application knowledge embedded in the code it analyzes.
we have proved that the resulting statechart preserves the semantics of the original program space restrictions prevent inclusion of the proof here .
however the generated statechart is not always the one that a developer would have chosen when creating anew statechart without reference to an existing implementation.
even the tcp example shown above which was designed as an example of how to program communication protocols in c exhibits many problems for a reengineering tool.
often the code does not contain enough information about the states in which the state machine can be when an external state change is applied.
by using such application knowledge the developer can refactor the generated statechart to reflect better the application s semantics.
also the procedural code can be refactored before applying the statrec transformation in order to generate simpler statecharts for example by grouping all side effecting operations in the code in order to eliminate unnecessary dynamic choices.
in this way procedural code can be turned into a modular and maintainable object oriented form that takes advantage of the visual statechart formalism to describe state based behavior.
.