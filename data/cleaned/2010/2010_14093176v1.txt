arxiv .3176v1 sep 2014test casepurification for improving faultlocalization jifeng xuan inrialille nordeurope lille france jifeng.xuan inria.frmartinmonperrus universityof lille inria lille france martin.monperrus univ lille1.fr abstract finding and fixing bugs are time consuming activities in software development.
spectrum based fault localization aims to identify the faulty position in source code based on the execution trace of test cases.
failing test cases and their assertions form test oracles for the failing behavior of the system under analysis.
in this paper we propose a novel concept of spectrum driven test case purification for improv ing fault localization.
the goal of test case purification is to separate existing test cases into small fractions called purified test cases and to enhance the test oracles to further localize faults.
combining with an original fault localiza tion technique e.g.
tarantula test case purification result s in better ranking the program statements.
our experiments on faults in six open source java programs show that test case purification can effectively improve existing faul t localization techniques.
categories andsubject descriptors d. .
automatic programming d. .
testing and debugging general terms algorithms experimentation keywords testcasepurification spectrum basedfaultlocalization test case atomization dynamic program slicing .
introduction findingandfixingbugsareessentialandtime consumingactivities in software development.
once a bug is submitted developers must allocate some effort to identify the exact lo cation of the bug in source code .
the problem of localizing bugs in a program is known as fault localization which consists of automatically rankingprogram entities e.g.
program methods or statements based on an oracle of the bug fse november hong kong chinausually a failing test case .
spectrum based fault localization also known as coverage based fault localization is a family of methods that use the execution trace of test cases i.e.
the coverage data to measure the faultyness probabilities of program entities.
for example tarantula jaccard and ochiai are popular spectrum based faul t localization techniques.
according to the fault localizat ion rankings the developers manually examine the program under debugging to find out the location of the bug.
in modern test driven software development unit testing plays an important role for ensuring the quality of software .
a unit test framework such as junit for java nunit for .net and cppunit for c provides a platform for developers to manage and automatically execute test cases .
each test case is formed as a test method which employs a test oracle to ensure the expected behavior.
the test oracle inatest case is implementedas asetof executable assertions for verifying the correctness of the program behavior.
for instance an open source project apache commons lang version .
consists of test cases with assertions testing the behavior of over 55k lines of code.
that is each test case includes .
assertions on average.
if an assertion in a test case is violated the unit test framework aborts the execution of this test case and reports the test result i.e.
the test case is failed .
test cases can be employed for fault localization .
aborting the execution of a failing test case omits all the unexecuted assertions that are in the same test case.
however the effectiveness of fault localization depends on the quantity of test oracles.
our key intuition is that recovering the execution of those omitted assertions can lead to more test cases and further enhance the ability of fault localization .
in this paper we propose the concept of spectrum driven test case purification test case purification for short for improving fault localization.
the goal of test case purification is to generate purified versions of failing test cases which include only one assertion per test and excludes unrelatedstatementsofthisassertion.
weleverage thosepurifi ed test cases to better localize software faults in java projec ts.
test case purification for fault localization consists of th ree major phases test case atomization test case slicing and rank refinement.
first test case atomization generates a se t of single assertion test cases for each failed test case se cond test case slicing removes the unrelated statements in a llthe failing single assertion test cases third rank refine ment combines the spectra of purified test cases with an existing fault localization technique e.g.
tarantula and sorts t he statements as the final result.
we evaluate our work on six real world open source java projects with seeded bugs.
we compare our results with six mature fault localization techniques.
our experimental results showthattest case purification caneffective ly improve the results of existing techniques.
applying test case purification achieves better fault localization on t o of faults depending on the subject program and performs worse on only .
to .
of faults.
in terms of fault localization test case purification on tarantula tarantulapurification for short obtains the best results among all the techniques we have considered.
tarantula purification per forms better than tarantula on .
of the faults with an average fault localization improvement of .
statemen ts.
with tarantula purification developers can save half of th e effort required for examining faulty statements.
this paper makes the following major contributions.
.
we propose the concept of spectrum driven test case purification for improving spectrum based fault localizatio n. in contrast to novelty in the suspiciousness metric that is common in the fault localization literature we explore a novel research avenue the manipulation of test cases to make the best use of existing test data.
.
we empirically evaluate our approach on seeded faults on six real world projects.
we compare the fault localization effectiveness of six state of the art techni ques tarantula sbi ochiai jaccard ochiai2 and kulczynski with and without test case purification.
the remainder of this paper is organized as follows.
section presents the background and motivation of our work.
section proposes the approach to test case purification for improving fault localization.
sections and show the data sets in the experiments and the experimental results.
section states the threats to validity in our work.
section lists the related work and section concludes this paper.
.
backgroundandmotivation .
terminology we define the major terms used in this paper to avoid ambiguous understanding.
atest case also called a test method is an executable piece of source code for verifying the behavior of software.
in junit a test case is formed as a test method which consists of two major parts a test input and a test oracle.
a test input is the input data to execute the program while a test oracle determines the correctness of the software with respect toi ts test input.
test oracles are created by developers accordin g to business and technical expectations.
a test oracle is implemented as a set of executable assertions to ensure that the software performs as expected.
a test suite is a set of test cases.
anassertion is a predicate a binary expression that indicates the expected behavior of a program.
if an assertionis not satisfied an exception is thrown.
then the test case containing this assertion aborts and the testing framework reports the failure.
for example assertequals a b in junit is widely used to ensure the equality of values aand b. in practice a single test case can consist of many assertions see section .
for details .
asubject program also called a proband or an object program is a program under test.
based on a unit testing framework like junit a test suite can be automatically executed to test the program.
aprogram entity represents an analysis granularity for fault localization.
for instance a program entity can be a class a method a statement etc.
in this paper we focus a widelyused program entity i.e.
a statement .
aspectrum of a test case is a set of program entities decorated with execution flags.
for a given test case a flagof a program entity indicates whether the test case executes a.k.a.
covers this particular program entity.
in this paper we focus on subject programs written in java andtestedwith junit aunittestingframework.
bothjunit and junit are widely used in current java projects.
an intuitive difference between these two versions is that a tes t case in junit starts with a specific annotation testand a test case in junit is named with a specific convention in atestmethod style .
our work supports test cases in both versions of junit.
figure b briefly illustrates an exampl e of a test case in junit .
.
spectrum based faultlocalization spectrum based fault localization also kn own as coverage based fault localization is a family of ap proaches to identifying the exact location of bugs in source code.
popular techniques include tarantula and ochiai .
the input of those approaches is the subject program with its test suite.
spectrum based fault localization exe cutes the whole test suite and collects the spectrum of each test case.
all spectra of test cases form a spectrum matrix also called a test coverage matrix and each element in the matrix indicates whether a test case covers a statement.
based on the spectrum matrix a fault localization approach calculates the suspiciousness for all statements and ranks them according to their suspiciousness.
a detailed descrip tion of existing fault localization techniques can be found in section .
.
.
motivation figure shows a fraction of a subject program in apache commons ac lang .
.
ac lang is an extension library for the java programming language.
figure a lists several methods for the calculation of the maximum and the minimum for ieee floating point numbers .
note that we have omitted the modifiers of methods and several statements to reduce the space.
we inject a fault at line i.e.
if !
float.isnan a by negating the original conditional expression.
then we execute all the test cases of ac lang and the only failing test case during execution can be found in figure b .
we call this failing test case t1.
the test case t1aborts since subject program test case public class ieee754rutils t1 a1 a2 a3 p2 p3 s1 float min float a float b float c ... return min min a b c float min float a float b if float.isnan a return b else if float.isnan b return a else return math.min a b float max float a float b float c ... return max max a b c float max float a float b fault fix as if float.isnan a if !
float.isnan a return b else if float.isnan b return a else return math.max a b float max float array ... float max array for int j j array.length j max max array max return max pass or fail f p f f f f f original test case t1 public class ieee754rutilstest test void test t1 ... assertequals .2f ieee754rutils.min .2f .5f float.nan assertequals .5f ieee754rutils.max .2f .5f float.nan ... float af new float .2f float.nan .7f .0f .0f float.nan assertequals .0f ieee754rutils.max af ... b original test case a subject program with spectra c test case purification the subject program and test cases are extracted from apache commons figure example of test case purification.
the subject prog ram and test cases are extracted from apache commons lang .
.
test cases t1is the original test cases.
test cases a1 a2 a3 p2 andp3are generated during test case purification.
test case s1is an extra example for the explanation.
the assertion at line is unsatisfied.
in all the test cases of ac lang only t1fails and statements from line to line are executed by t1 as shown in figure a .
we use tarantula as an example of fault localization technique.
based on the actual execution of tarantula all the statements executed by t1are ranked with the same suspiciousness.
thus it is hard to identify the fault at lin e from these statements.
however t1is aborted at line and the last assertion at line has not been executed.
thus we consider making use of the unexecuted assertion to improve fault localization.
as shown in figure c we create three copies a1 a2 anda3 oft1 for each copy we force two assertions to not throw an exception even if the assertion is unsatisfied.
that is each of test cases a1 a2 anda3 has only one valid assertion.
then we execute test cases a1 a2 anda3 we find that a2 anda3fail at line and line respectively actually a2 in this execution expresses the same behavior as t1 .
for each ofa2anda3 we remove the irrelevant statements to line and line respectively then we get two smaller test casesp2andp3.
we execute p2andp3and the spectra are represented as columns in figure a in gray.
based on the spectra of p2andp3 statements at line and line are executed twice and six other statements are executed only once.
thus we can rank the two statements at line and line as faulty statement prior to the other statements.the reason for ranking the last two statements is that these statements are the frequently executed ones by failing test cases.
in other words the fault in source code causes the failure of p2andp3and the spectra of p2andp3are different.
thus the two statements are the most suspicious based ontheevidencefrom thetwotest cases p2andp3.
moreover if we directly remove irrelevant statements for the origina l test case t1 all the dependent statements like lines and will be kept as shown in s1in figure a .
for a large subject program a large number of dependent statements often interrupt the identification of the fault.
this example motivates our work test case purification for fault localization.
we use test case purification to generat e small fractions of test cases to improve the existing techniques in fault localization.
.
test case purification in this section we propose the concept of spectrum driven test case purification test case purification for short for fault localization.
we first present the framework in sectio n .
.
then we show the details of the three main phases in sections .
.
and .
respectively.
finally we discu ss the extensibility of test case purification in section .
.
.
frameworktry assertion catch java.lang.throwable throwable do nothing figure a surrounding structure for transforming an assertion into a regular test case statement no exception from the assertion reaches the testing framework if the assertion fails .
the main goal of test case purification is to generate purified test cases from each failing test case.
a purified test case is a short test case with only one assertion and is generated by removing several statements from the original failing te st case.
we employ such purified test cases to improve existing techniques on fault localization.
figure illustrates the framework of test case purification for fault localization.
this framework consists of three ma jor phases test case atomization test case slicing and ra nk refinement.
given a specific technique on fault localization the input of test case purification is a subject program with its test suite and the final output is a ranking of statements.
both the input and the output are the same as those in typical fault localization techniques e.g.
tarantula and och iai.
intest case atomization each original failing test case withkassertions is replaced by ksingle assertion test cases.
a single assertion test case is a copy of the original test case but only one out of koriginal assertions is kept.
in test case slicing each single assertion test case is treated as a program.
we use dynamic slicing technique to remove irrelevantstatementsineachsingle assertion testcase.
then short test cases are generated as purified test cases.
in rank refinement we re rank the statements in an existing fault localization techniquebased onthe spectraof all thepurifi ed test cases.
in our work test case purification for fault localization is run automatically.
we describe the implementation details in section .
.
.
test caseatomization the goal of test case atomization is to generate a set of test cases for each failing test case.
as the term atomization suggests we consider each assertion has an atomic part in a test case.
given a failing test case with kassertions we createkcopies for this test case and we transform k assertions into regular test case statements for each copy no exceptionfrom theassertion reaches thetestingframework if the assertion fails .
to transform an assertion into a regul ar test case statement we surround this assertion with a trycatchstructure shown in figure .
in java the class java.lang.throwable is a superclass of all the exceptions.
as mentioned in section .
an exception will be thrown to the test case if an assertion is not satisfied .
basedontheabovestructure theexceptionwillbecaughtasthrowable and the test case will not be interrupted1.
based on the surrounding structure in figure a set of ksingleassertion test cases are created to replace each originally failing test case.
a failing test case with only one assertio n will be kept without handling.
note that in junit two kinds of interruptions will stop the executionofatestcase namelyafailureandanerror.
a failureis caused by an unsatisfied assertion which is designed by developers an erroris caused by a fault which is not considered by developers .
thus an error may appear in any statement of a test case.
in test case atomization we only deal with the failures in assertions in junit.
if an er ror appears the execution of a single assertion test case w ill be aborted because an error usually causes severe problems which are beyond the expected test cases by developers.
after generating single assertion test cases we compile a nd execute all the single assertion test cases.
meanwhile we collect the failing ones among these test cases for each fai ling single assertion test case we record its position that aborts the execution.
this position is referred as a broken statement .
for example a broken statement in a singleassertion test case could be an assertion i.e.
the exact as sertion left in the test case or a statement that throws an unexpected error.
finally each failing single assertion test case as well as its broken position is collected.
.
test caseslicing the goal of test case slicing is to generate purified test cases before collecting their spectra.
given a failing sing leassertion test case resulting from test case atomization w e slice this test case by removing irrelevant statements.
program slicing can be mainly divided into two categories static slicing and dynamic slicing .
informally st atic slicing keeps all the possible statements based on static da ta andcontrol dependencieswhile dynamicslicing keepstheac tually executed statements in the dynamic execution with dynamicdataandcontroldependencies .
intestcaseslicin g we use a dynamic slicing technique to remove statements in test cases since dynamic slicing may lead to more removal of statements .
in dynamic slicing a slicing criterion should be specified before execution the program.
a slicing criterion is defined as a pair b v where bis a statement in the object program and vis a set of variables to be observed at b. we perform dynamic slicing and slice single assertion test cases during its execution by the junit framework.
our slicing criterion for a test case is its broken assertion wit h all the variables at this statement.
then we execute the dynamic slicing technique to collect the statements that wi ll be removed.
after the slicing each failing single asserti on test case in test case atomization is updated with a purified test case.
then we execute these purified test cases on the 1sometimes an assertion is originally surrounded by a trycatchstatement e.g.
writing files may throw an ioexceptionin java.
directly adding the surrounding structure to this assertion will cause the compiling error.
in this case we collect the candidate exceptions and add a fraction of dead code to make the compiling pass like if false throw new ioexception .localizing faults with the given techniquetest suitesubject programfault localization technique e.g.
tarantula failed test casesstatement suspiciousness atomizing test casessingle assertion test cases running test cases failed single assertion test cases broken statements slicing criteria slicing test casespurified test cases running test casesspectraranking statementsfinal statement rankingoriginal fault localization test case atomization test case slicing rank refinement figure framework of test case purification for fault local ization.
this framework consists of three phases test case atomization test case slicing and rank refinemen t. project program and record the spectra for next phase.
.
rank refinement the goal of rank refinement is to re rank the statements by an existing fault localization technique with the spectra i n the phase of test case slicing.
in all the purified test cases we keep only one test case if two or more than test cases have the same spectrum.
as mentionedinsection3.
allthepurifiedtestcasesarefail ing test cases.
let sbe a set of candidate statements.
we define the ratio of a statement s s. first for a statement s sthat is covered during the execution of all the purified test cases ratio s ef s ef s nf s where ef s and nf s are the numbers of test cases covering and non covering s. second for a statement sthat is not covered by any purified test case we directly set ratio s .
the output of an existing fault localization technique suc h tarantula or ochiai is the suspiciousness values for all th e candidate statements.
let susp s be the suspiciousness value of a statement s sin a fault localization technique.
then we normalize the susp s as to for all the statements in s. the normalized suspiciousness value is defined asnorm s susp s min s max s min s where min s andmax s denote the minimum score and the maximum score for all the statements in s respectively.
for each statement s s bothratio s andnorm s is between0and1 bothinclusive .
thenwerefinetheranking ofeachstatement sbycombining ratio s andnorm s .
the final score of sis defined as score s norm s ratio s .
then for all the statements s s the final score score s is between and both inclusive .
based on the final scoresof all the statements we re rank the statements as the resul t of fault localization by test case purification.
.
discussion basic fault localization technique .
test case purification modifies the existingtest cases.
consequently the spe ctra are changed and the suspicious statements according to afault localization technique e.g.
tarantula are re ra nked.
manyotherfaultlocalization techniquescanbeusedinstea d such as ochiai jaccard and sbi.
we examine the results for six fault localization techniques in section .
method of rank refinement .
we define the new score of each statement sasscore s .
this definitioncanbereplaced by other formulae for example the average of norm s and ratio s i.e.
norm s ratio s or the geometric mean i.e.
norm s ratio s norm s ratio s .
results of such refinement methods can be further explored.
.
experimental setup .
subject programs we select six open source subject programs for our experiments.
table gives the key descriptive statistics of those subject programs.
all six programs are java libraries whic h are widely used in fault localization research .
we compute the size metric source line of code sloc with cloc2.
the subject programs in our selection are provided with large test suites written in junit.
for each subject program we execute the original program with its dependent libraries.
we confirm that the whole test suite passes i.e.
our experimental configuration is correct.
2cloc .table subject programs with source code test suites and faulty versions subject programprogram source test suite faulty version classes sloc classes slocjunit version test cases assertions assertions per test case mutants faults jexel .
.
beta13 .
jparsec .
.
.
jaxen .
.
.
apache commons ac codec .
.
apache commons ac lang .
.
joda time .
.
in some programs assertions are abstracted into a specific c lass which are not the same assertions in junit.
in our work we only handle the assertions in junit.
thus the assertions per test case can be less than .
table mutant operators for generating faulty versions mutant operator description invert negatives invert an integer or a floating point number as its negative return values change a returned object to null or increase or decrease a returned number math replace a binary math operator with another math operator negate conditionals negate a condition as its opposite conditional boundary add or remove the boundary to a conditional statements increments convert between an increment and a decrement we follow existing work in and use mutation testing tools to create faulty versions.
a mutantof a program is a copy of the original program with a single change.
for instance a mutant may contain one change of negating a conditional statement.
mutants are meant to simulate likely faults made by developers.
some of mutants known as equivalent mutants provide the same observable output as the original program.
we employ six mutant operators to generate all the mutants for a given subject program.
table 2presentsthesix mutantoperators for generatingfaultyve rsions.
inour work we use thepittool3togenerate mutants which has implemented all these six operators.
we discard equivalent mutants and keep the faulty versions.
finally w e randomly select mutants from all the seeded faulty versions for each subject program as the final dataset of faulty programs.
a thorough study by steimann et al.
has shown that a sample size of mutants gives stable fault localization results.
.
techniques incomparison as explained in section the goal of test case purification is to improve existing fault localization by maximizing the usage of all the assertions.
in our experiments we evaluate the effectiveness of test case purification on six wellstudied fault localization techniques tarantula statis tical bug isolation sbi ochiai jaccard ochiai2 and kulczyn ski2 .
jones etal.
propose tarantulafor fault localiza tion.
tarantula ranks statements by differentiating the executio n of failing and passing test cases.
sbi is proposed by liblit et al.
and calculates the suspiciousness value.
the ir work shows that the predicted suspicious statements cor3pit .
.table six spectrum based fault localization techniques in comparison technique definition tarantula ef s ef s nf s ef s ef s nf s ep s ep s np s sbi ef s ef s nf s ochiai ef s radicalbig ef s nf s ef s ep s jaccard ef s ef s nf s ep s ochiai2 ef s np s radicalbig ef s ep s np s nf s ef s nf s ep s np s kulczynski21 parenleftbig ef s ef s nf s ef s ef s ep s parenrightbig relate with the root cause.
ochiai is proposed by abreu et al.
whichcountsbothfailingtestcases andexecutingt est cases.
jaccard is also proposed by abreu et al.
.
those four techniques are the most widely used ones for the evaluation of fault localization.
ochiai2 by naish et al.
is an extension version of ochiai the difference is that ochiai considers the impact of non executed or passing test cases.
kulczynski2 by naish et al.
is another widely used metric.
evaluations of ochiai2 and kulczynski2 can be found in .
generally a spectrum based fault localization technique can be formalized as a formula of calculating the suspiciousnes s values susp s f parenleftbig ef s nf s ep s np s parenrightbig where ef s and nf s are thenumbersoffailing test cases thatexecuteanddonotexecutethestatement swhile ep s and np s are the numbers of passing test cases that execute and do not execute the statement s respectively.
table summarizes the six techniques that we consider for evaluating test case purification.
for a given fault localization technique the wasted effort of localizing the faulty statement is defined as the rank of the faulty statement in the ranking according to the suspicious ness values.
for statements with the same suspiciousness values the wasted effort is the average rank between all of them.
formally the wasted effort of fault localization is defined as stmteffort s s susp s susp s s s susp s susp s 2wheresis a set of candidate statements s sis the faulty statement and indicates the size of a set.
.
implementation we now discuss the implementation details of our experiment.
our test case purification approach is implemented in java .
.
our experiments run on a machine with an intel xeon .
cpu and an ubuntu .
operating system.
our implementation automatically runs the three phases in figure .
in our work test suites are automatically executed with ant .
.44andjunit4.
.
wesetthetimeoutofrunningafaulty program as five times of that of the originally correct versio n to avoid performance bugs which may be potentially generated during the program mutation.
we execute an existing fault localization technique to compute the origi nal suspiciousness values.
we implement the six existing fault localization techniques on top of gzoltar .
.
.
gzoltar is a library for facilitating and visualizing fault localiz ation.
we use gzoltar to collect the program spectra.
in the phases of test case atomization and test case slicing we directly manipulate test cases with spoon .
.
spoon is a library for java source code transformation and analysis.
with the support by spoon a java test class is considered as an abstract syntax tree and we modify source code via programming abstractions.
spoon also handles annotations in java hence our implementation fully supports both junit and junit .
in the phase of test case slicing we slice test cases with javaslicer7.
javaslicer efficiently collects runtime trace for a subject program and removes traces offline with dynamic backward slicing.
javaslicer requires specifying th e point of a thread.
thus we develop a driver program to facilitate the test case slicing.
since program slicing tec hniques may cost time and resources it is necessary to decide how many test cases should be sliced.
based on our experience it seems that slicing failing test classes one by one is the most efficient compared to handling failing test cases one by one or all the failing test cases together.
.
experimental results in this section we present our experimental results on test case purification.
section .
presents the overall compari son based on all seeded faults in six subject programs section .
discusses the detailed results for each subject pro gram section .
evaluates the time cost of test case purification.
.
overallcomparison we compare the capability of our test case purification technique to improve six existing fault localization technique s on six subject programs.
table presents the average fault localization results on seeded faults with mutation.
the columns positive 4ant .
.
.
5gzoltar .
.
.
6spoon .
.
7javaslicer .table number of faults where test case purification improves existing fault localization techniques column positive worsens column negative and has no impact column neutral .
each number is computed over seeded faults in six subject programs.
technique in comparisonpositive negative neutral faults percent faults percent faults percent tarantula .
.
.
sbi .
.
.
ochiai .
.
.
jaccard .
.
.
ochiai2 .
.
.
kulczynski2 .
.
.
gives the absolute and relative numbers of faults which are improved after applying test case purification compared to basic techniques in fault localization.
column negative indicates the number of faults when the basic fault localization gives better results.
column neutral shows the number of faults which are not changed after applying test case purifi cation.
as shown in table test case purification improves fault localization for basic fault localization techniques.
fo r instance by applyingtest case purification o f faults for tarantula achieve lower wasted efforts i.e.
faul ts are easier to be localized and the results are better .
the number of faults where purification worsen the ranking is small worse in .
of faults for tarantula and much smaller thanthe numberof faults that are improved.
except tarantula test case purification decreases the effectivene ss of fault localization in no more than faults.
we note that for all the six techniques in our comparison we obtain neural results on over of faults.
the main reason is that some of the considered faults are easy to localize.
for example for jaccard root cause statements fo r faults are directly ranked as the first in those cases our approach cannot improve the localization since the results are already optimal.
meanwhile for jaccard again root cause statements are ranked between the 2nd to the 10th position and consequently the localization of these faults is hard to improve.
in section .
we will show that our test case purification works well for the difficult faults which are originally localized beyond t he top statements.
table presents the wasted effort with or without applying test case purification on faults.
the wasted effort is measured with the absolute number of statements to be examined before finding the faulty one see section .
.
it is the main cost of fault localization.
in total there are competing techniques six fault localization technique s with or without purification .
tarantula with test case purification called arantula purification for short gives the best results among techniques for three of six subject programs.
ochiai purification gives the best results for th e remaining three subject programs.
the last row in table gives the average results over all six subject programs.
according to this aggregate measure purification test case im proves the wasted effort from .
statements tarantula to .
statements tarantula purification .
by applyingtest case purification with tarantula developers save .
statements to examine.
in the worst case they still save statements.
summary .
applying test case purification to the state ofthe artfault localization techniquesresultsinupto43 p ositive results with the price of .
worsened faults.
among techniques in comparison tarantula purification obtai ns the best results which are .
better than the best origi nal technique according to our experimental setup without purification ochiai is the best technique with an average wasted effort of .
statements .
.
detailed comparisonper faultcategory to better understand the effectiveness of test case purification we analyze all faults in our six subject programs in details.
let soriginaldenotes the original fault localization result i.e.
the wasted effort of localizing the faulty stat ements as described in section .
.
we divide the faults in subject programs intothreecategories accordingto soriginal namely faults with soriginal soriginal and soriginal .
for example the faults with soriginal can be viewed as the easy category where there is no space for improvingthe fault localization since the results are o ptimal.
similarly faults with soriginal can be viewed as the medium category.
it is a reasonable task for a developer to examine the top suspicious statements in a program le lo also suggest that localizing a fault in top statements is a proof of effectiveness.
results of suc h faults can be improved a bit.
faults with soriginal can be viewed as representing the hard category.
more wasted efforts may need to be checked to localize the faults.
table 6shows thedetailed evaluationonfaults in thosethre e categories according to soriginal.
each line is the comparison between an original fault localization technique and te st case purification.
for each category we list the positive negative neutral as in table and total faults respectively.
we evaluate test case purification with both faults the number of faults and stmtsave the average saved effort obtained by applying test case purification .
note that stmtsave may be below zero because applying test case purification may lead to worse results.
for faults with soriginal applying test case purification can obtain positive and neutral results with few negative re sults.
taking tarantula as an example the effectiveness of fault localization on faults .
is improved b y applying test case purification and worsened for faults .
in column negative .
for ochiai localization on out of faults .
is improved.
test case purification can save over statements on average for tarantula or sbi statements for kulczynski2 and over statements for ochiai jaccard or ochiai2.
in jexel applying test cas e purification never leads to negative results.
that is fault localization on all the faults with soriginal can be improved or unchanged.
in both jaxen and ac lang test case purification can lead to non negative results on five origina l techniques except tarantula one negative result .
in joda time between and cases are worsened.
test case purification in joda time performs the worst among our six subject programs.
apotential reason is thatjoda time consists of over thousand sloc this scale probably hindersfault localization.
for faults with soriginal test case purification can also work well.
five out of the six fault localization techniques obtain no more than four negative results an exception is tarantula which obtains negative results.
on most of subject programs applying test case purification can improve the original fault localization but tarantula in jparsec as well as tarantula and ochiai in joda time achieve a little decrease.
note that the result of a fault wit h soriginal may not have enough space to improve since the faulty statement has been ranked in top statements.
for faults with soriginal the results are already optimal.
a good approach cannot decrease the results for such faults.
in our work only one fault with soriginal out of cases in all the subject programs gets a negative result by applying test case purification.
in other words .
of faults keep an optimal rank under test case purification.
for all the techniques in our experiments five out of six subject programs have less than negative results among faults.
joda time contributes the most negative results e.g.
negatives for tarantula.
on the other side applyin g test case purification to tarantula improves the most among the six original fault localization techniques.
one major reason for the negative results is that there exists dependency between test cases.
for example if two test cases share a static object and one test case creates the object with a fault the source code of creating the object contains a faulty statement then the other test case may fail due to the propagation of the fault.
such propagation makes the second test case fail but the spectrum of the test case does not contain the fault statement.
based on our manual checking the dependency of test cases is the major reason of negative results.
we will further discuss the reasons for negative results in section .
.
summary .
based onthecomparison with sixtechniqueson sixsubject programs test casepurificationcanimproveori ginal techniques in fault localization.
for the hard locali zed faults with initial rankings beyond10 statements test c ase purificationsaves theeffort ofexaminingmore than10statements in average.
.
computation time as shown in table tarantula purification obtains the best results among all the techniques in comparison.
in this section we present the computation time of our work.
table lists the computation time of tarantula purification on six subject programs.
for each subject program we list the computation time in seconds of the original fault localiz ation and the three phases in test case purification.
the whole process of test case purification costs .
secondsonaverage.
themosttime consumingpartis thephase oftestcaseslicing.
amajor reasonforthelarge computatio n time is that dynamic program slicing is a complex task and requires monitoring theruntimetraces .
compari ng with the time of original fault localization techniques i. e. .
seconds the time of test case purification is still ac table wasted effort measured with the absolute number of s tatements to be examined before finding the fault .
the wasted effort for our dataset is given on all six co nsidered fault localization techniques with and without test case purification.
the last row averages over al l subject programs.
subject programoriginal technique test case purification tarantula sbi ochiai jaccard ochiai2 kulczynski2 tarantula sbi ochiai jaccard ochiai2 kulczynski2 jexel .
.
.
.
.
.
.
.
.
.
.
.
jparsec .
.
.
.
.
.
.
.
.
.
.
.
jaxen .
.
.
.
.
.
.
.
.
.
.
.
ac codec .
.
.
.
.
.
.
.
.
.
.
.
ac lang .
.
.
.
.
.
.
.
.
.
.
.
joda time .
.
.
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
for some cases the group of tarantula and sbi as well as the g roup of ochiai and ochiai2 produce very similar results.
st udies in show evidences on their similarity.
the spectra are usually different which are shown in table .
table detailed evaluations on three categories of faults optimally localized easy localized hard localized .
columns stmtsave measure the saved effort obtained with test case purification .
subject programtechnique in comparisonsoriginal soriginal soriginal sum neutral positive negative neutral total positive negative neutral total positive negative neutral total faults faults faults faults faults stmtsave faults stmtsave faults stmtsave faults faults stmtsave faults stmtsave faults stmtsave faults faults stmtsave jexeltarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
jparsectarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
jaxentarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
ac codectarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
ac langtarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
joda timetarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
alltarantula .
.
.
.
.
.
.
sbi .
.
.
.
.
.
.
ochiai .
.
.
.
.
.
.
jaccard .
.
.
.
.
.
.
ochiai2 .
.
.
.
.
.
.
kulczynski2 .
.
.
.
.
.
.
only one fault with soriginal has a negative result.
that is test case purification makes th e original result worse on one fault in joda time when comparing with tarantula.
ceptable.
we plan to explore further techniques to improve the phase of test case slicing.
summary .
the computation time of test case purification seconds per fault is acceptable since the whole proces s can be executed automatically.
.
threatsto validity we discuss threats to the validity of our results with respec t to experiment construction and method construction.
.
experiment constructionin our work we evaluate test case purification based on six existing fault localization techniques.
experiments are c onducted in six typical open source subject programs in java.
however comparing with the large number of existing fault localization techniques the generality of our work should be further studied.
to conduct large scale experiments we employ mutation testing techniques to inject faults in subject programs.
we use six widely used mutant operators to generate all faulty versions of the subject programs under consideration.
then we randomly select faulty versions as the final faults.
apotential threat is that the type of mutant operators may impact the effectiveness of fault localization.
for example a fault localization technique may be good at handling a specific type of faults.
we have not checked the results for this issue.
we leave it as one of our future work.
table time of tarantula with test case purification in seconds subject programoriginal fault localizationtest case atomizationtest case slicingrank refinementtotal jexel .
.
.
.
.
jparsec .
.
.
.
.
jaxen .
.
.
.
.
ac codec .
.
.
.
.
ac lang .
.
.
.
.
joda time .
.
.
.
.
average .
.
.
.
.
.
method construction in section .
we propose a rank refinement method to leverage the spectra of purified test cases to improve an orig inal fault localization technique.
our method is a simple formula to combine spectra of test case purification and the original fault localization.
other formulae can be used for the combination e.g.
the average and the weighted average .
we plan to design new methods to make better use of the spectra of test case purification in the future.
in our work we generate purified test cases to improve fault localization.
based on the spectra of purified test cases we rankfrequentstatementsinsuchspectrapriortootherstat ements.
our experiments show that test case purification can obtain non negative results on most faults.
a potential assumption is that test cases are executed independently.
that is the results of a test case should not impact the results of other test cases.
this assumption can be satisfied since most of test cases are well designed.
as mentioned in section .
sometimes test cases suffer from dependencies.
this is a challenge topic in fault localization since there i s no explicit relationship between the failing test case and t he faulty statement.
weusejavaslicer astheimplementationtoolintestcas e slicing.
as mentioned by the authors of javaslicer this too l has some known limitations.
for example traces of native methods and java standard library classes may be missed.
to our knowledge javaslicer is the most easy to use slicin g tool for java .
.
in our implementation of test case slicing we write a program to check potential missing statements by javaslicer but the implementation may still miss some statements.
.
related work to our knowledge this paper is the first work to directly manipulate test cases to improve fault localization.
we lis t the related work as follows.
.
faultlocalizationtechniques fault localization aims to localize the faulty position in p rograms.
tarantula by jones et al.
is an integrated framework to localize and visualize faults.
empirical evaluatio ns oftarantulaonfaultlocalization canbefoundin .
abre u et al.
propose ochiai and jaccard for fault localization .all of tarantula ochiai and jaccard can be viewed as the state of art in spectrum based fault localization.
naish et al.
propose a family of fault localization methods and empirically evaluate their results.
recent work by zhang et al.
addresses the problem of how to identify faults with only failed runs.
xie et al.
propose a theoretical analy sis on multiple ranking metrics of fault localization and divid e these metrics into categories according to their effectiven ess.
santelices et al.
combine multiple types of code coverage to find out the faulty positions in program.
baah et al.
employ potential outcome model to find out the dynamic program dependencies for fault localization.
xu et al.
develop a noise reduction framework for localiz ing java faults.
this work is a general framework that can be used to improve multiple existing fault localization tec hniques.
digiuseppe jones recently propose a semantic fault diagnosis approach which employs natural language processing to detect the fault locations.
xuan monperrus develop a learning based approach to combining multiple ranking metrics for fault localizing.
steimann et al.
discuss the threats to validity in the empirical assessments of fault localization.
their work also presents t he theoretical bounds of the accuracy in fault localization.
hao et al.
propose a test input reduction approach to reduce thecost of inspectingthe test results.
gong et al.
design adiversity maximization speedupapproachtoredu ce the manual labeling of test cases and improve the accuracy of fault localization.
yoo et al.
address the problem of fault localization prioritization.
their work investigat es how to rank remaining test cases to maximize fault localization once a previous fault is found.
baudryetal.
leveragetheconceptofdynamicbasicblock s to maximize the ability of diagnosing faults with a test suit e. artzietal.
directlygeneratetestcases forlocalizing faults in invalid html programs in dynamic web applications.
this work does not require the test oracles since a web browser canreportthecrashesonceinvalidhtmlprogramsarefound.
fault localization is also used as a phase of predicting a candidate position of the patch in software repair such as genprog and nopol .
in our work we address the same problem statement of fault localization.
in contrast to existing work test case purifi cation is a framework to make better use of existing test cases.
our approach directly operates on test cases and can be generally applied to most of existing approaches.
.
mutation and slicing based fault localization mutation basedfaultlocalization hasbeenrecentlypropo sed.
the kernel idea of mutation based fault localization is to l ocalize faults by injecting faults.
zhang et al.
propose fifl a fault injecting approach to localizing faulty edits in evolving java programs.
candidate edits are ranked based onthesuspiciousness ofmutants.
papadakis letraon develop metallaxis fl a mutation based technique for fau lt localization on c programs.
their work shows that test cases that are able to kill mutants can enable accurate fault localization.
moon et al.
recently propose muse an approach based on both mutants of faulty statements andmutants of correct statements.
slicing based fault localization leverages program slici ng to remove the statements in programs to find out the final faulty statements.
zhang et al.
employ dynamic slicing to reduce the size of c programs to avoid the distribution by irrelevant statements.
mao et al.
combine both statist ic slicing and dynamic slicing to identify the faulty statemen ts in programs.
they empirically evaluate the slicing based techniques on multiple fault localization techniques.
xie et al.
proposeanewconceptofmetamorphicslice basedon the integration of metamorphic testing and program slicing .
metamorphic slices localize faults without the requiremen t of test oracles.
existing work on mutation based and slicing based fault lo calization aims to change the subject program to identify the faulty parts in the program.
in our work test case purification changes test cases for fault localization rather than subject programs.
we make better use of existing test cases test oracles to improve the effectiveness of fault localiz ation.
.
conclusion in this paper we propose a test case purification approach for improving fault localization.
our work directly manipulates test cases to make better use of existing test oracles.
we generate small fractions of test cases that we call purified test cases to collect discriminating spectra for a ll assertions in the test suite under consideration.
our exper imental results showthattest case purification caneffective ly improve original fault localization techniques.
only a sma ll fraction of faults .
to .
suffer from worsened results .
the results show that the benefits of test case purification exist on six fault localization techniques.
as future work we plan to conduct experiments on other java projects to further investigate the performance of our work.
we plan to design new ranking methods to combine with thespectraof test case purification.
moreover we want to explore how to reduce the time cost of test case slicing.
we plan to check the applicability of the idea of test case purificationforothersoftware problems e.g.
regression testing or automatic software repair .
.