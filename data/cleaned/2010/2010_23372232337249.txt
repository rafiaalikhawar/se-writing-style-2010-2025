reconciling manual and automatic refactoring xi ge quinton l. dubose emerson murphy hill department of computer science north carolina state unive rsity raleigh nc xge qldubose ncsu.edu emerson csc.ncsu.edu abstract although useful and widely available refactoring tools are underused.
one cause of this underuse is that a developer sometimes fails to recognize that she is going to refactor before she begins manually refactoring.
to address this issue we conducted a formative study of developers manual refactoring process suggesting that developers reliance on chasing error messages when manually refactoring is an error prone manual refactoring strategy.
additionally our study distilled a set of manual refactoring workflow patterns.
using these patterns we designed a novel refactoring tool called benefactor.
benefactor detects a developer s manual refactoring reminds her that automatic refactoring is available and can complete her refactoring automatically.
by alleviating the burden of recognizing manual refactoring benefactor is designed to help solve the refactoring tool underuse problem.
i. i ntroduction software is expensive to maintain.
as software ages it must be maintained to reflect evolving user requirements this maintenance accounts for between and of the total cost of software .
one of the primary ways that software developers maintain software is through refactoring the process of changing the structure of code without changing the way that it behaves .
refactoring is both an effective and commonplace way of improving non functional requirements.
empirical stud ies of refactoring have found that it can improve maintainability and reusability .
not only does existing work suggest that refactoring is useful but it also suggest s that refactoring is a frequent practice .
cherubini and colleagues survey indicates that developers rate the importance of refactoring as equal to or greater than that of understanding code and producing documentation .
however refactoring by hand has long been assumed to be error prone.
in order to help developers perform efficient and correct refactoring various refactoring too ls have been developed.
these tools promise to help developers refactor faster and with a smaller probability of introduci ng defects.
refactoring tools have been integrated into most popular development environments making them available in a variety of programming languages to a large population of developers.
despite the wide availability our previous work shows that refactoring tools are underused according to two case studies about of refactorings are performed by hand .several solutions have been proposed to solve the underuse problem.
for example tools with improved user interfaces can make refactoring tools more usable .
other novel tools have supported new specialized types of refactoring .
other research has proposed automatic testing to make refactoring tools more reliable .
such solutions make one common assumption that the software developer recognizes that she is going to refactor before she even begins.
this assumption is false when a developer has already started a refactoring manually by the time she realizes that she is refactoring.
one developer outlined this situation in an interview as i already know exactly how i want the code to look like.
because of that my hands start copypaste and the simple editing without my active control.
after a few seconds i realize that this would have been easier to do with a refactoring .
but since i already started performing it manually i just finish it and continue.
this situation illustrates how refactoring tools do not sup port the developer when she does not realize she is refactoring until after she has already begun.
without that realization a software developer will not use any the refactoring tool no matter how usable useful or reliable that tool is.
in this paper we investigate how to design a refactoring tool that is aware of a developer s refactoring rather than relying on the developer s recognition of it.
in section iii we describe a formative study about developers manual refactoring.
building on the study s results in section iv we designed a novel refactoring tool.
we make the following major contributions in this paper a formative study of developers manual refactoring.
to the best of our knowledge we are the first to study developers manual refactoring process.
our study suggests that reliance on compiler errors when manually refactoring is a common and error prone technique.
a proof of concept refactoring tool called benefactor.
in addition to relieving the developer from the burden of recognizing that she is going to refactor benefactor also allows implicit refactoring configuration and the interleaving of refactoring and non refactoring changes.
.
c ieee icse zurich switzerland ii.
m otivation to use a refactoring tool a developer must recognize that she is refactoring and select the appropriate refactoring w ith a menu or a hotkey.
if she is unaware that she is refactoring and begins to refactor manually she may become aware that she is refactoring part way through the manual refactoring.
in this case the developer faces the late awareness dilemma she must either undo all the code changes that she has already made and then invoke the refactoring tool or keep refactoring manually until the refactoring is complete.
we next illustrate this dilemma using two examples.
suppose grace is a developer who works on the apache tomcat open source project .
to improve understandability she wants to change the name of a local variable descs to descriptors .
she starts this task manually from the declaration of descs towards the tenth and last reference to descs .
after changing six names as shown in figure she realizes that she is performing a rename refactoring.
grace decides it would be easier to just finish the refactorin g manually even at the risk of introducing a bug.
figure rename local variable refactoring example.
late awareness of refactoring occurs for other refactoring types as well.
suppose that glen is a developer who works on the vuze project .
he notices that the getrequestedpiecenumbers method shown in figure contains three for loops that are nearly identical.
to enhance maintainabilit y he intends to extract the loop as a new helper method.
glen starts by cutting the code in the third loop and then declares the helper method getrequestedpiecenumbershelper .
glen then realizes that he is performing the extract method refactoring and that he would like to have a refactoring tool figure out what variables to pass in to the method.
to do so he undoes his changes and invokes the extract method tool even though he has to configure the refactoring tool with the name of the helper method which he already specified once while manually refactoring.
figure extract method refactoring example.
iii.
f ormative study in order to resolve the late awareness dilemma we intend to build a novel refactoring tool that can complete manual refactorings.
however three important research question s must be answered first rq1.
how correctly do developers refactor manually?
if developers mistakenly modify program behavior when refactoring manually then refactoring tools can potentially improve the refactoring process.
rq2.
how significant is the late awareness problem?
if many developers do not recognize that they are refactoring before they begin then the late awareness is a contributor to refactoring tool underuse.
rq3.
what are developers manual refactoring workflows?
to create a refactoring tool that can complete refactorings automatically the tool must be able to recognize when a developer is refactoring.
models of manual refactoring workflows will help our tool recognize when a developer is refactoring.
we conducted a formative study to answer these questions.
a. participants and refactorings we recruited 12developers to participate in our study.
six were graduate students and five were commercial software developers.
we also recruited one refactoring researcher not one of the authors who has current development experience212of more than ten years.
although we did not collect all of the participants demographic information at least 10of the 12participants had professional programming experience of more than four years.
we asked participants to perform refactorings in the source code of the vuze project.
we chose this project is for its large size and maturity.
we manually inspected the source code of vuze then located fourteen locations where refactoring could reasonab ly be performed.
at each of the fourteen locations we asked participants to perform one refactoring without the assist ance of any refactoring tools.
among the fourteen refactorings we chose three that were especially complex a rename local variable refactoring an extract method refactoring and a change method signature refactoring.
when performing these complex refactorings participants needed to carefu lly consider how to avoid changing program behavior.
we describe the complex refactorings in detail in section iii c1.
the fourteen refactorings spanned 8refactoring types rename extract constant extract local variable inline local variable change method signature extract method introduce parameter and pull up method .
we chose these types from the types listed in fowler s catalog according to three criteria.
the first is their frequency in real world.
according to our previous research using automatic tools to perform rename extract local vari able inline extract method and change method signature accounts for over of all refactoring tool usage .
this high tool usage suggests that these refactoring types occur frequently.
simplicity is the second criterion because sim ple refactorings would be easier for participants to complete i n a short study session.
the third criterion is wide coverage o f a variety of software entities such as constants temporar y variables local variables fields and methods.
we also cho se pull up method because it involved class inheritance.
b. data collected we collected data using a pre study questionnaire videos of participants manual refactorings and a post study que stionnaire.
to view the participants refactoring videos an d their answers to the questionnaires the reader can refer to our study material website.
pre study questionnaires we recruited developers through email.
if they were willing we sent them a consent form and pre study questionnaire.
one subject consented but did not fill out the remainder of the questionnaire.
we asked the following questions in the questionnaire coding experience about what percentage of your job involves writing code?
java proficiency how proficient are you with the java programming language rating from 1to5 1for not at all and 5for expert ?
participants produced a slightly distribution of java experience median .
with all participants reporting at least some experience and two participants considering themselves experts.
refactoring familiarity how familiar are you with the practice of refactoring rating from 1to5 1for not at all and 5for i refactor every time i program ?
participants produced a fairly normal distribution of refactoring experience median .
to perform the study participants connected to a remote computer running the eclipse ide and containing the code to be refactored.
using the online screen sharing service join.me participants could easily view and operate eclipse.
at the same time we established a skype conversation with the participant to give them directions.
observing manual refactoring after setting up screen sharing we opened the first code location where we wanted the participant to perform a refactoring.
we told the participant which refactoring we wanted her to perform and that no automatic refactoring tools were allowed.
if the participant was unfamiliar with the refactoring we gav e her an explanation of what the resulting code should look like.
we were careful to avoid telling the participant how to perform each refactoring.
once we had answered all of the participants questions about the task we asked her to star t. we repeated this process with all 14refactorings.
while the participant was performing these refactorings we used screen capture software to record the entire process which we analyzed after the study session ended.
to analyze each refactoring we tagged it as either correct incorrect or unknown.
correct meant that the participant s refactoring resulted in the code structure t hat met with fowler s definition and did not modify the software s behavior.
incorrect indicated that the softw are s behavior was modified but the participant s refactoring resulted in a code structure that met with fowler s definitio n. refactorings tagged as unknown included those that the participant skipped those that were finished only with our detailed guidance we guided some participants to spare them the embarrassment of not being able to complete the task those that were finished by invoking refactoring tool s and those that we were not able to tell whether the new code structure met with fowler s definition.
only refactorings tagged as correct and incorrect were used in our analysi s of refactoring workflows.
post study questionnaire after the study we presented each participant with a questionnaire that asked the following questions q1.
how often does this situation occur i get part way through a code change when i realize there is a refactoring tool that can help me do the job.
choose from one of the following words never rarely sometimes often and always.213figure code illustrating a complex refactoring.
q2.
what would you do after the situation in q1 happens?
options i finish the change without a refactoring tool back out of the change and redo the change using a refactoring tool or other.
c. results rq1.
refactoring correctness our previous research suggests that developers may rely on compilation errors to locate the related code to update .
for example in figure grace is using the compilation errors to determine what parts of the code needs to be updated.
however this strategy is sometimes error prone because compilation erro rs do not indicate every location that needs to be updated for certain complex refactorings.
we had participants perform three of these complex refactorings to determine to what extent they used this strategy.
overall participants inadvertently changed behavior in eleven of the fourteen refactorings and very few finished participants completed complex refactorings them correctly.
complex refactoring we asked participants to perform the complex extract method refactoring shown in figure .
if a developer extracts the last forloop into a new method the new method should return the value of pos because the extracted forloop modifies the value of pos and the code in the original method later reads the value.
however compilation errors do not result if posis not returned so relying on error messages for this part of the refactoring is not sufficient for a correct refactoring.
only one participant correctly performed the complex extract method refactoring while seven performed it incor rectly because of failing to return the value.
complex refactoring we asked participants to perform a rename local variable refactoring on code that is summarized in figure .
we asked the participants to rename lifehours tooriginal republish interval which is also the name of a field of the containing class.
if a developer renames lifehours tooriginal republish interval in the declaration names in checkcacheexpiration .
.
.
that originally bound to the field original republish interval now bind totable i questionnaire results.
pre study questionnaire post study questionnaire coding java refactoring late handle late awareness experience proficiency familiarity awareness manual tool others sometimes sometimes often sometimes rarely often the local variable.
no compilation error is generated when the rebinding occurs.
no participant correctly performed complex rename local variable refactoring while nine performed it incorrectly .
complex refactoring we asked participants to perform a change a method signature refactoring by swapping the order of two parameters.
more specifically we asked them to refactor setuserdata object key object value to setuserdata object value object key .
if a developer swaps these parameters in the method declaration no compiler errors are shown because all invocations of this method stil l had arguments of correct types.
one participant performed this complex refactoring correctly while two performed it incorrectly.
summary across the three complex refactorings were performed incorrectly.
it appeared that developers relied on compiler errors for refactoring even in situatio ns where that reliance was misplaced.
somewhat surprisingly participants also made mistakes in the non complex refactorings.
in total participants completed 96non complex refactorings and of them were incorrect.
most of these incorrect refactorings resulted from participant s failing to address all compiler errors.
in addition to these results we also observed another problematic manual refactoring technique.
when performing the rename field refactoring four of the eleven participant s invoked the find and replace all tool replacing all of the occurrences of the original field name in the file.
although this technique did not happen to modify behavior in the given code this technique is generally unsafe because the original name may also occur in other places not referring to the field such as in a method name.
rq2.
late awareness how significant is the late awareness problem?
we answer this question by using participants post study questionnaires.
among the 12participants recruited in our formative study six returned their post study questionnaires.
tabl e i shows the answers of these participants to each question we asked.2five of the six participants indicated that late awareness of refactoring tools happens to them at least sometimes.
two of these five participants indicated that 2the first row shows the refactoring researcher s answers.214late awareness of refactoring happens to them often .
this suggests that the late awareness problem may happen to a variety of programmers.
participants reported that when late awareness occurs a median of of the time they finish the refactoring manually.
one participant indicated that she handles late awareness through other means but did not elaborate.
rq3.
refactoring workflow patterns what are the developers manual refactoring workflows?
to investigate this question we studied the videos of participants perfor ming the refactorings.
we distilled a set of widely adopted refactoring workflows for each refactoring type which we refer to as refactoring workflow patterns.
we modeled these patterns using finite state machines fsms over a set of parameterized elementary operations to facilitate represen tation and interpretation.
we use operations on abstract syntax tree ast nodes to model refactoring workflow patterns.
asts are tree representations of the syntactic structure of source code writte n in a programming language.
nodes inside an ast represent software entities at various levels such as variables fiel ds statements methods and classes.
we use the following operations on the ast nodes to model our refactoring workflow patterns cop x copy node x s source code to the clipboard.
cut x cut node x s source code and keep it in the clipboard.
ins x insert node xinto the ast possibly via a paste command.
upd x update the value of node x. inspired by regular expressions we also define the following quantifiers op x indicates performing operation opon zero or more nodes xsimultaneously.
op x indicates performing op on zero or more nodes xsequentially.
op x indicates performing operation opon one or more nodes xsimultaneously.
op x indicates performing op on one or more nodes xsequentially.
due to space limitations we present the refactoring workflow patterns for only rename field and extract method two common refactorings .
for refactoring workflow pattern s for other refactoring types the reader can refer to our stud y material website mentioned in section iii b. rename field participants had similar workflows when manually performing the rename field refactoring.
eleven rename field refactorings that were considered usabl e that is correct and incorrect .
each participant used one of two patterns seven participants first updated the name of the field in its declaration and then iteratively updated the names of all the