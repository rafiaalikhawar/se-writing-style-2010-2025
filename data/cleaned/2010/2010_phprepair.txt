automated repair of html generation errors in php applications using string constraint solving hesam samimi max sch afery shay artziy todd millstein frank tipy and laurie hendrenz computer science department university of california los angeles usa fhesam toddg cs.ucla.edu yibm t.j. watson research center hawthorne ny usa fmschaefer artzi ftip g us.ibm.com zschool of computer science mcgill university montreal canada hendren cs.mcgill.ca abstract php web applications routinely generate invalid html.
modern browsers silently correct html errors but sometimes malformed pages render inconsistently cause browser crashes or expose security vulnerabilities.
fixing errors in generated pages is usually straightforward but repairing the generating php program can be much harder.
we observe that malformed html is often produced by incorrect constant prints i.e.
statements that print string literals and present two tools for automatically repairing such html generation errors.
phpquickfix repairs simple bugs by statically analyzing individual prints.
phprepair handles more general repairs using a dynamic approach.
based on a test suite the property that all tests should produce their expected output is encoded as a string constraint over variables representing constant prints.
solving this constraint describes how constant prints must be modified to make all tests pass.
both tools were implemented as an eclipse plugin and evaluated on php programs containing hundreds of html generation errors most of which our tools were able to repair automatically.
keywords php automated repair string constraints i. i ntroduction php is the most widely used server side programming language for implementing web applications with a recent survey finding that it is employed by about of all websites .
typically a php application generates html pages based on user input and information retrieved from a database.
these html pages often contain javascript code to enable interactive usage and links or forms referring to additional php scripts to be executed.
one particularly common issue plaguing many php applications is generation of invalid html.
modern browsers are quite tolerant of html errors and employ heuristics to silently correct them although pages may render more slowly because of these error correcting heuristics .
in some cases however erroneous html will be displayed differently depending on the browser so the pages generated by a php program may look fine to the developer while they would be unacceptable to a user with a different browser.
in extreme cases invalid html may even cause browsers to supported in part by national science foundation award ccf .become unresponsive or expose security vulnerabilities .
finally erroneous html can be an obstacle to screen readers and other assistive technology.
the world wide web consortium maintains a collection of anecdotes from web professionals about problems with malformed html1.
this paper presents an approach to help programmers find and fix html generation errors in php programs.
the approach is based on the observation that malformed html is most often generated due to errors in statements that print string literals.
this is not surprising because such constant prints are the way in which a php program typically generates the tag structure of an html page.
while for example the data in an html table might be generated via a dynamic database lookup in the php program the table s html tags would be produced by printing the appropriate string literals e.g.
tr and td in the right places.
we describe two tools for fixing html generation errors which we have implemented in a plugin for the eclipse php development tools.2the first tool phpquickfix targets a common special case whereby a single constant print statement cannot possibly result in legal html.
examples include uses of html special characters such as that should be escaped or mismatched start and end tags as in b i yes!
b .
these problems are highlighted in the ide and a quick fix is suggested which if accepted by the programmer automatically repairs the affected code.
our second tool phprepair targets the more general problem of incorrect constant print statements in php programs including bugs caused by the interactions among multiple such statements and bugs that require adding changing or removing such statements.
given a test suite for a php program along with the expected html output for each test we encode the condition that actual and expected output agree for each test case as a string constraint over variables corresponding to constant prints in the program.
a string constraint solver automatically provides a solution 1see sites work better.html.
2see our constraint which phprepair employs to modify the program appropriately.
the result is a repaired program that passes all tests in the given suite.
phprepair only considers insertion modification and deletion of constant prints in a program.
despite the limited form of such repairs they are still quite expressive since the constant prints can be arbitrary for example a constant print may be inserted at any location in the program and there is no bound on the length of the string that it prints.
our focus on constant prints allows phprepair to perform an exhaustive search over the space of possible repairs ensuring both completeness andminimality prior work on automated program repair typically lacks these properties .
in principle a purely static analysis could give stronger guarantees than phprepair s test based approach.
however in practice the dynamic nature of php would make such an approach difficult to scale to real programs in a manner that only detects actual errors and fixes those errors without introducing new html generation bugs.
in contrast a testing approach is practical and effective for two main reasons.
first prior work has shown how to automatically generate high coverage tests for php programs .
second while fixing a php program to correct html errors on all possible execution paths is quite challenging fixing an individual broken html page is usually relatively straightforward often requiring nothing more than e.g.
inserting a missing end tag.
indeed such fixes are automatically suggested by tools such as html tidy 3or they can be obtained by querying the dom representation of the page inside a browser which reflects the automatic corrections performed by the browser s html repair logic.
therefore both a highquality test suite and the associated test oracles required by our approach can be generated in a fully automatic manner.
we have evaluated our tools on several real world php programs showing that many html generation bugs can be fixed by our approach.
phpquickfix identified several thousand shallow bugs that could be repaired by the suggested quick fixes.
of the remaining bugs in each program on average were fixed by phprepair which justifies our focus on constant print statements.
a repair is found within seven seconds on average so our tools are suitable for interactive use.
the remainder of the paper is organized as follows.
in section ii we provide some background and introduce our two tools in the context of a motivating example.
section iii precisely defines our notion of a repair and describes how the test based tool phprepair finds repairs.
section iv provides implementation details for both tools.
section v evaluates our tools on a set of php programs section vi discusses related work and section vii concludes.
3see head title list capitals title style type text css .highlight background color aquamarine style head body ?php highlight isset get con mysql connect localhost test test mysql select db countries con data mysql query select from countries if !mysql num rows data echo h1 no data!
h1 n else ?
table border tr th h3 country th th h3 capital h3 tr ?php while row mysql fetch array data echo tr td if highlight echo div class highlight b echo row if highlight echo div tr else echo td echo td .
row .
td echo tr n ?
body html figure .
a simple php script.
ii.
b ackground and overview a. an example php program figure shows a small php script designed to illustrate our approach.
the program queries a database for a list of countries and their capitals and renders this data as an html table optionally highlighting country names by printing them in bold face on a light blue background.
a peculiar feature of php is that programs can contain fragments of inline html code that are printed verbatim when the program is executed.
in the program of fig.
there are several such fragments the first one lines prints the page header including a css stylesheet while the last one lines prints the page footer.
snippets of php code appear inside ?php.
.
.
?
directives.
the first snippet lines performs initialization and error checking it uses the built in function isset to determine whether the script was passed an http get parameter hl setting flag highlight accordingly it then connects to a mysql database containing the information to be displayed and sends a query to the database lines .
if the query fails or returns no results the body of the generated html page consists of the error message printed on line .
otherwise another inline html fragment is used to emit the start tag of the table to be displayed line table i test cases for the script in fig.
.
id database parameters output t1 see fig.
t2 countries see fig.
f canada ottawa netherlands amsterdam usa washington g t3 same as for t2 fhl7!
gsee text html head title list capitals title style type text css .highlight background color aquamarine style head body h1 no data!
h1 body html figure .
valid html generated by the script in fig.
on test case t1.
and its first row containing the column headers.
to build the table the script iterates over the results of the query using a while loop lines .
for every query result it prints a new row of the table with two td elements containing the name of the country and its capital respectively.
if the script was passed the hlparameter the country name is additionally wrapped in a belement to typeset it in bold font and a divelement with class highlight which the css style sheet on line styles using an aquamarine blue background.
b. html generation bugs this example program contains several bugs similar to issues encountered in real world php applications which cause it to generate invalid html in certain situations.
we will consider three test cases as described in table i t1runs the script on an empty database without setting parameter hl t2uses a non empty database containing information about the capitals of canada the netherlands and the usa but again does not set any parameters and t3runs it on the same database as t2with parameter hlset to .
in test case t1 the program produces the html page in fig.
which is syntactically correct.
in test case t2 it produces the page in fig.
which is not valid html the first h3element on line is missing an end tag as is the table element on line .
these two problems are silently corrected by modern browsers allowing the page to display as intended.
for 4note that this html fragment is printed as part of the else branch of theifstatement on line which is only closed on line in another php snippet php code and html fragments can be freely mixed without regard to syntactic nesting and this is frequently done in real world programs.
5perhaps surprisingly the missing end tag of the second thelement on line is not a problem this self closing hence its end tag is optional.
html head title list capitals title style type text css .highlight background color aquamarine style head body table border tr th h3 country th th h3 capital h3 tr tr td canada td td ottawa td tr tr td netherlands td td amsterdam td tr tr td usa td td washington td tr body html figure .
invalid html generated by the script in fig.
on test case t2.
instance inspection of the dom produced when this page is displayed in google chrome .
shows that it inserts the missing end tags as expected a h3 tag before the th tag on line and table before the body tag on line .
translating these fixes for the generated html page into fixes for the generating php program can be much more difficult however.
it is clear that the first h3element in the inline html on line must be closed by adding h3 on that same line between country and th .
however there are many possible options for inserting the missing statement echo table to close the start tag on line and it is easy to do so improperly.
if it is inserted as part of that same block of inline html then the table will be closed before all of its rows have been output.
if it is inserted inside the body of the while loop the result on test t2will be to emit three table tags.
inserting it after line would repair test t2but would break test t1.
inserting it after line leads to valid html being produced in both cases.
finally consider test t3 where the script is run on the same database as in t2 but now with the parameter hlset to .
this produces essentially the same page as in fig.
but the table rows are now of the following form tr td div class highlight b canada div tr td ottawa td tr this is not valid html the belement is missing an end tag and a tr tag occurs where a td tag is expected.
different browsers display this invalid html page in different ways as shown in fig.
.
while they all insert the missing b tag before the div tag the unexpected tr tag is not handled uniformly.
internet explorer decides to treat it as a td tag which is arguably the best fix from a user s perspective google chrome and firefox on the other hand silently insert a td tag before the tr and another tr tag after it thus splitting one row into two and upsetting the table layout considerably.
these kinds of inconsistencies which can occur across different browsers as well as different versions of the same browser are very easy for developers to miss during testing.
as before propagating the desired html fixes in this case those performed by internet explorer back to the gen figure .
different renderings of our invalid html page in google chrome .
left internet explorer .
middle and firefox .
right .
html head style type text css test div margin 10px 10px test form width style head body table tr th test th tr tr td div id test div form id test form method post input type text name test div td tr table body html figure .
an invalid html page that causes internet explorer to hang.
erating php program is non trivial.
of the various options for places to insert the missing b tag the right place is on line in the then branch of the ifstatement.
emitting it before the ifstatement would be acceptable for this test case but would break t2.
propagating the other fix requires modifying the tr tag on the same line to td .
problems such as incorrect or missing end tags may seem trivial but they by no means always are the html page in fig.
adapted from causes even very recent versions of internet explorer to hang while displaying without problems in other browsers.
the problem here is a missing end tag for the form element starting on line which in a somewhat subtle combination with a table and a css stylesheet triggers a bug in the browser s html repair logic.
in some cases invalid html can also impact browser performance or lead to security vulnerabilities .
c. automated php program repair while repairing a php program can in principle require arbitrary modifications to its statements and structure weobserve that repairing html generation bugs often requires only additions modifications and removals of statements that print string literals e.g.
inline html or an echo or print statement whose argument is a string literal which we collectively dub constant prints .
this is the case because as illustrated in fig.
constant prints are the mechanism by which the tag structure of an html page is generated.
by focusing on this common class of repair actions we have devised a two pronged approach to automatically repairing php programs that is simple yet effective and have implemented the approach as a plugin for the eclipse php development tools.
first the fragile nature of php results in many shallow html generation bugs whereby a single constant print is erroneous in the sense that it cannot possibly result in legal html no matter what context it is executed under.
for instance line of the program in fig.
can be seen to be erroneous in isolation since it contains improperly nested html start and end tags.
we have developed phpquickfix a static checker that catches these kinds of local html generation bugs.
phpquickfix attempts to parse each string constant and inline html fragment in the program in isolation.
while parsing a string phpquickfix maintains a stack of currently open elements whenever it detects an end tag that does not match the most recently opened tag it generates a quick fix proposal to insert the expected end tag at the current location.
the tool also identifies and generates a quick fix for two simple but common errors namely ampersand characters that are not part of a character reference and hence should be escaped as amp and nonalphanumeric attribute values that are not quoted.
since phpquickfix considers each constant print in isolation it cannot detect or repair html errors involving multiple program points such as the missing table tag in our running example.
generalizing phpquickfix to performstatic analysis over an entire program would be quite difficult due to the many highly dynamic features of the language and the need to precisely model the effect of varying databases and parameter settings on control and data flow.
instead we propose a test based approach to repairing complex html generation bugs.
our approach assumes that a test suite for the program is available.
each test in this suite is described by i the input data on which to run the program such as http parameters and databases and ii the expected output the program is supposed to produce.
such a test suite can be produced without user interaction by employing a high coverage test generation tool for php such as apollo and an html repair tool such as html tidy or it can be created manually.
our second tool phprepair automatically adds modifies and removes constant prints in the given php program in order to produce a program that passes all tests in the given suite.
phprepair is based on the idea that we can characterize a given test s execution by the sequence of strings output by individual print statements that are executed in the program says1 s n. ifs1 sn e where represents string concatenation and eis the expected output then the test case passes otherwise it fails.
replacing each sithat results from a constant print with a constraint variable viin the above equation encodes a string constraint whose solution tells us how to repair the program to satisfy the test case.
a solution to all the constraints generated from a test suite leads to a repair that makes the whole suite pass.
in the next section we develop this basic idea in more detail on the basis of the examples in this section.
iii.
i nput output based repair a. test cases and repairs a program pis a collection of php scripts.
a test case t consists of a configuration to run the subject program under and an expected output .
for the purposes of this discussion the precise structure of is irrelevant it could for instance specify an initial database configuration a sequence of scripts to execute and the values of http parameters to pass to the scripts.
the actual output p produces on tis the html page generated by the last script invoked when running punder .6the program is said to pass test casetif the actual output of pontequals the expected output .
we refer to an inline html fragment or a print orecho statement as a print.
a print whose argument is a string literal is called a constant print or cprint for short.
any other print is called a variable print or vprint.
programspandp0are called repair convertible if one can be obtained from the other by repeatedly performing any of the following repair actions i adding a new cprint ii 6while earlier scripts do not directly contribute to the actual output they may alter the database or session state and hence indirectly influence it.
html head title list capitals title style type text css .highlight background color aquamarine style head body table border tr th h3 country h3 th th h3 capital h3 tr tr td canada td td ottawa td tr tr td netherlands td td amsterdam td tr tr td usa td td washington td tr table body html figure .
expected output for test t2 non empty database no parameters .
html head title list capitals title style type text css .highlight background color aquamarine style head body table border tr th h3 country h3 th th h3 capital h3 tr tr td div class highlight b canada b div td td ottawa td tr tr td div class highlight b netherlands b div td td amsterdam td tr tr td div class highlight b usa b div td td washington td tr table body html figure .
expected output for test case t3 non empty database parameter hl .
removing a cprint or iii modifying an existing cprint by changing the string constant that it prints .
a repair problem consists of a program pand a settof tests.
a solution of the repair problem is a program p0such thatpandp0are repair convertible and p0passes all tests in t. note that we only consider repair actions involving cprints.
in particular we do not consider adding deleting or modifying vprints or changing the program s control structure.
our evaluation in sec.
v suggests that most realworld html generation bugs can be repaired in this way.
as an example of a repair problem consider the program of fig.
and the test suite t ft1 t2 t3gconsisting of the test cases described in table i which each only invoke a single script the one shown in fig.
.
the expected output fort1is the same as the actual output shown in fig.
the expected outputs for t2andt3are given in fig.
and fig.
.
fig.
shows the repairs to be performed to solve this repair problem where changes are highlighted and unchanged portions of the program are omitted two existing cprints are modified and one new cprint is added.. .
.
tr th h3 country h3 th th h3 capital h3 tr .
.
.
echo b div t d .
.
.
echo table .
.
.
figure .
repair for the php script in fig.
.
b. properties we have designed an approach that sets up a constraint system to capture the semantics of the repair problem as defined above with solutions representing repairs.
before discussing it in detail let us consider what properties we desire from such an approach.
soundness if the constraint system has a solution it should represent a valid repair i.e.
the repaired program should pass every test in the suite.
completeness if a valid repair exists the constraint system should have a solution.
minimality for usability we would like to find a repair that is minimal in the sense that it modifies the original program as little as possible.
our approach makes two assumptions about the given program and its test suite.
firstly the program may not inspect or modify its own source code this is needed since we rely on source level instrumentation to dynamically collect information about program executions.
secondly all tests must be deterministic i.e.
the program must execute in the same way and in particular produce the same output every time it runs a given test.
since individual php scripts are not usually interactive this is not a severe restriction.
c. finding a sound repair let a program pand a test suite tbe given.
if we assign a unique label to every print in p we can characterize an execution of pon a testt2tby its print trace which is the sequence of prints encountered during the execution together with the string values they printed.
figure shows a possible labeling of the script from fig.
where we have labeled the cprints as c1toc14 and the vprints as v1andv2.
multi line html fragments are counted as a single cprint and only get a single label.
additional empty cprints have been inserted on lines and these are necessary for the completeness of our approach and are explained in more detail below.
using this labeling the print trace of running the program on testt1is reflecting the fact that the program executed the cprints on lines and in this order but no vprints.
html ... body c1 ?php ... if !mysql num rows data echo h1 no data!
h1 n c2 else ?
table border tr th h3 country th th h3 capital h3 tr c3 ?php while row mysql fetch array data echo tr td c4 if highlight echo div class highlight b c5 echo c6 echo row v1 echo c7 if highlight echo div tr c8 else echo td c9 echo td c10 echo row v2 echo td c11 echo tr n c12 echo c13 ?
body html c14 figure .
labeled version of the script from fig.
.
since a cprint will print the same string every time it is executed we can abbreviate print traces by omitting the output of cprints.
using this convention the print trace of testt2is as follows and is similar for t3 .
c1 c3 c4 c6 v1 canada c7 c9 c10 v2 ottawa c11 c12 c4 c6 v1 ne... c7 c9 c10 v2 amsterdam c11 c12 c4 c6 v1 usa c7 c9 c10 v2 washington c11 c12 c13 c14 clearly the program passes a test case if the concatenation of all the output strings in the associated print trace equals the expected output.
if we interpret the labels of cprints as constraint variables we can express the condition that actual output and expected output on a test case must agree as a string constraint the left hand side of the constraint is the concatenation of all labels in the print trace while the right hand side is simply the expected output.
we will call this constraint the repair constraint .
the repair constraint for test case t1 for instance is c1 c2 c14 where 1is the html document of fig.
.
one solution to the constraint has c1 c2 andc14take on their original values i.e.
the string literals printed by the corresponding cprints in the original program.
since our approach to program repair only attempts to modify constant prints we do not represent vprints as constraint variables.
indeed using a constraint variable for atable ii asolution for the repair constraints encoding t1 t2and t3.
var old value repair value c3 .
.
.country th .
.
.
.
.
.country h3 th .
.
.
c8 div tr b div td c13 table vprint would in general lead to unsolvable constraints since a single vprint may produce a different output each time it is executed e.g.
v1in fig.
.
instead we represent each occurrence of a vprint by the constant output it produced in the execution in question.
for test case t2 we then obtain the repair constraint c1 c3 c4 c6 canada c7 c9 c10 ottawa c11 c12 c4 c6 netherlands c7 c9 c10 amsterdam c11 c12 c4 c6 usa c7 c9 c10 washington c11 c12 c13 c14 where 2is the html page in fig.
.
this constraint as well as the one above for test t1 is solved by setting c3 country h3 th c13 table and all other variables to their original values.
a satisfying assignment for a set of repair constraints directly corresponds to a repair in which every cprint is modified to print the string assigned to its constraint variable.
the repaired program will then by construction pass the test cases encoded by the constraints.
therefore a solution to the repair constraints for a given test suite corresponds to a repair that makes the program pass every test in the suite.
table ii shows a solution for the repair constraints encoding tests t1 t2andt3 omitting unchanged variables corresponding to the repair in fig.
.
d. ensuring completeness and minimality while the approach outlined so far is sound if the underlying constraint solver is it can only find repairs involving modifications of existing cprints including setting the string of a cprint to the empty string which is tantamount to deletion .
there is no support for adding new cprints hence the approach is not yet complete.
note that it is never necessary to add a new cprint c0 right before or after an existing cprint c instead of adding c0we can just as well modify c. for the same reason it is unnecessary to add c0if it is in the same block of straightline code as cand there are no vprints in between.
thus our approach is complete if the program to be repaired has a cprint at the beginning of every code block after every vprint and after every nested code block.
we can easily bring any program into this form by padding it with trivial cprints of the form echo and phprepair performs this simple modification.
for instance in the program of fig.
cprints are inserted on lines and after nested blocks and on line after a vprint.on the other hand there is no need to insert a cprint after line at the beginning of the loop body as there already is a cprint on the next line.
to achieve minimality we use a cost metric to characterize the number of changes required by a repair.
let mbe a solution for the set of repair constraints under consideration.
then we can define cost m as the number of variables to whichmassigns a different value than its original value meaning that mis considered more expensive the more cprints it modifies.
in order to find a minimal repair for the program we then simply look for a solution with the minimum cost.
while this cost metric assigns the same cost to every modification it is easy to substitute a different metric that for instance penalizes adding a cprint more heavily than modifying an existing one or takes the amount of change to each print statement into consideration.
iv.
i mplementation in this section we discuss implementation details of our two repair tools.
the tools are part of a plugin that we have built for the eclipse php development tools pdt .
a. phpquickfix phpquickfix integrates into the pdt as a build participant and is run every time a source file is processed.
warnings are displayed as annotations in the ide and come with a proposed quick fix that if the user accepts it modifies the program directly in the editor to repair the problem.
as described in section ii c phpquickfix checks each string literal in the program in isolation for common html generation errors.
this is unsound in general since some strings do not represent html or undergo further processing before being printed.
hence phpquickfix sometimes emits spurious warnings and the programmer has to exercise caution in applying the suggested fixes.
since it only considers one string literal at a time phpquickfix is of course also not complete.
nevertheless our experiments in section v indicate that phpquickfix is a valuable tool for quickly detecting and eliminating common html generation bugs.
b. phprepair phprepair can be invoked via a menu item added to the pdt.
the option requires the developer to specify an xml file which contains an encoding of the test suite.
phprepair first uses source level instrumentation to generate the repair constraints.
from the original program p it creates an instrumented program pithat is identical to pexcept that trivial cprints are inserted as described in sec.
iii d and all prints are replaced by calls to a logging function which performs the normal print and logs both the label of the print and the output it produces.
running pi 7an inserted cprint will not actually appear in the repaired program unless the solution to the repair constraints requires it.table iii diff regions for the example test suite .
tests actual output expected output diff variables t2 t3 .
.
.country t. .
.
.
.
.country h3 t. .
.
c3 t2 t3 .
.
.
tr b .
.
.
tr table b. .
.
c13 t3 .
.
.ada div tr td.
.
.
.
.
.ada b div td td.
.
.
c7 c8 t3 .
.
.nds div tr td.
.
.
.
.
.nds b div td td.
.
.
c7 c8 t3 .
.
.usa div tr td.
.
.
.
.
.usa b div td td.
.
.
c7 c8 on a test case produces a log containing the associated print trace from which the repair constraint is constructed.
phprepair then solves the set of repair constraints by encoding them in the input language of kodkod an efficient sat based constraint solver.
we considered using an off the shelf string constraint solver such as hampi or kaluza instead but neither solver supports cost optimization which we need in order to find a minimal repair.
in contrast kodkod can be easily used with any underlying sat solver including a cost optimizing one.
another advantage of kodkod is that it provides a simple way to bound the allowed solutions to each variable which we use to drastically reduce the search space.
such bounds are easy to obtain due to the simple form of our repair constraints where the right hand sides are constant.
for example the string value of a variable vappearing in a constraint cmust be entirely composed of characters appearing on the right hand side of c and its maximum length is bounded by the length of the right hand side.
we further optimize the constraints passed to the solver by employing a simple localization heuristic based on the observation that the differences between the actual and expected outputs for failing test cases are generally small.
we first compute diff regions for each test case i.e.
substrings of the actual output that do not agree with the expected output.
using the logged print traces we can then identify all cprints that produce output in a diff region.
we call the variables corresponding to these cprints diff variables .
in the example of sec.
ii the actual and expected output on tests t2andt3yield five diff regions shown in table iii.
the last column lists the diff variables for every region overall the diff variables for this test suite are c3 c7 c8 c13.
given this information our heuristic forces all non diff variables to retain their original values since they do not contribute to any of the diff regions and hence likely already have their correct values.
we do this by canceling out each non diff variable from the left hand side of each repair constraint along with its corresponding expected output on the right hand side which by definition matches the variable s actual output .
the result is a set of localized constraints in place of each original repair constraint.
from the repairconstraint for test t2we get three localized constraints c3 country h3 th c7 c13 table whereast3contributes only one new constraint c7 c8 b div td these four constraints can be solved by kodkod leading to the solution shown in table ii.
localization is sound and critical in practice for reducing repair time but it can sometimes lose solutions since it does not allow a cprint outside of a diff region to be modified.
for example consider a repair that requires hoisting a cprint from within an ifblock to occur just before the conditional.
if the block is only executed on passing tests our heuristic will not allow that cprint to be modified causing the localized constraints to become unsatisfiable.
we regain completeness through a simple back off procedure if the localized constraints are unsatisfiable we expand each diff region by a fixed amount and try again.
in the limit each test output becomes a single diff region causing the original repair constraints to be solved.
finally we observe that constraints that do not have any variables in common can be solved independently.
we can hence improve constraint solving time by partitioning the repair constraints according to their variables and solving each partition separately.
this optimization is particularly effective after localization which tends to produce many constraints that each refer to a small number of variables.
v. e valuation we present an evaluation of our repair techniques on a set of php applications focusing on three evaluation criteria ec1 how many html generation errors can phpquickfix fix?
how many spurious warnings does it produce?
ec2 how successful is phprepair in repairing the remaining html generation errors?
ec3 when phprepair fails how often is this due to the restriction to modify only cprints and how often due to limitations of the constraint solver?table iv subject programs .
program version files loc tests coverage faqforge .
.
.
webchess .
.
.
schoolmate .
.
.
hgb .
.
timeclock .
.
.
dnscript n a .
a. experimental setup and methodology table iv describes our subject programs and their test suites.
the loc column lists the number of lines containing an executable php statement and the last two columns give the size of the test suite and its line coverage.
the tests were generated automatically using apollo on a time budget of minutes.
coverage for timeclock is low since it makes heavy use of client side javascript which is not very well supported by apollo.
note that each test typically triggers multiple html generation errors and a single error may be triggered by multiple tests so the number of failing tests tends to be correlated only loosely with the number of bugs.
phprepair additionally requires the expected output for each test.
we used the w3c markup validation service8to identify validity violations and html tidy to automatically fix simple html errors.
more complex errors that exceed the capabilities of html tidy were fixed by hand.
to address criterion ec3 we also manually constructed golden versions of the subject programs that produce the expected output on all tests.
this required significant effort on the order of several days of work for the larger benchmarks.
on each benchmark we first used phpquickfix to fix all the simple html generation errors and then applied phprepair to the modified program and its test suite to repair more complex errors.
we believe this approach reflects the way in which our tools would be used by programmers.
to simulate a developer interacting with phprepair to repair all failing tests in a test suite t1 t n we used the following iterative process.
let tfbe the first failing test case.
we first run phprepair on testst1 t f with a timeout of three minutes for the solver.
recall from the end of sec.
iv that we partition the repair constraints into independent sets.
we automatically apply to tfthe repairs corresponding to each constraint set for which phprepair provides a solution.
if all sets have solutions then test tfhas been fully repaired so we move on to the next failing test case.
otherwise we manually apply as many fixes from the golden version as required to make tfpass before moving on.
we repeat these steps until all tests pass.
to measure the effectiveness of our approach we count the total number of patches i.e.
positions where a contiguous program fragment was inserted modified or removed required to fully repair each program and compute what percentage of patches were applied automatically by php8see v number of errors found and repaired by phpquickfix .
name errors reported false positives faqforge webchess schoolmate hgb timeclock dnscript table vi number of errors found and repaired by phprepair .
name tool all manual non cprint tool patches patches manual patches patches faqforge webchess schoolmate hgb timeclock dnscript repair .
this is a more objective metric than the number of fixed test cases which depends heavily on the test suite.
using the number of validator error messages is also problematic since a single error may lead to several messages.
b. results ec1 table v shows the number of html generation errors reported by phpquickfix on each of the subject programs in the middle column.
as can be seen from these results the simple kinds of errors detected by phpquickfix are quite common.
as mentioned in sec.
iv phpquickfix can incur false positives but on most of our benchmarks this is very rare.
the sole exception is hgb which uses custom html templates with un escaped ampersand characters as field separators.
these characters are substituted away when producing actual html output but the local analysis performed by phpquickfix cannot recognize this.
ec2 table vi reports on our evaluation of phprepair listing for every benchmark the number of patches automatically applied by phprepair and the number of patches applied manually the fourth column shows how many of the latter involved fixing statements other than cprints and hence exceeded the capabilities of our tool.
across all benchmarks phprepair on average performs of all patches automatically.
on these benchmarks our iterative process went through a total of iterations.
on iterations phprepair timed out without finding a solution the remaining iterations completed in an average of seconds.
the relatively low percentage of automated repairs on hgb is largely an artifact of our evaluation strategy most manual patches could have been found automatically but they occurred in the same test case and constraint as a more complicated repair and so had to be applied by hand.
9measured on a .4ghz core duo macbook pro with gb of ram.ec3 the fourth column in table vi shows that on average only about of the necessary repairs were out of scope for our approach.
examples of such repairs are missing include statements and faulty vprints.
the high number of non cprint patches in timeclock is due to a single patch involving a vprint that is required in every script.
while most of the invalid html generated by our benchmarks would be silently corrected by a browser we found three errors that resulted in visible layout problems two of which were automatically fixed by phprepair .
c. threats to validity the subject programs used in our evaluation may not be representative of other php programs.
we did not specifically select the benchmarks to suit our approach many of them have been used in our previous research .
some php programs such as phpbb2 use custom templating mechanisms to generate their output whereby a template of the page to generate is read from a file and subjected to some string processing to generate the actual output page.
our approach does not work well on such programs which typically contain few cprints.
the bugs we detected and fixed may not be representative since the test suites we use do not cover all of a program s behavior.
however the test suites achieve high coverage and were generated using algorithms that are completely unrelated to the repair techniques studied in this paper.
finally there is often more than one way to fix a given html generation error but in our evaluation we had to pick a single fix.
when constructing the corrected html output and the golden versions of our subject programs we have attempted to choose sensible repairs that disturb the original structure as little as possible.
vi.
r elated work static analysis of strings in web applications has been used to validate html output from web applications to ensure that only xml documents meeting a given dtd are generated and to detect security vulnerabilities .
our phpquickfix tool also performs a static analysis but only handles the special case of html errors within an individual string literal.
since phpquickfixis neither sound nor complete it cannot guarantee the absence of all errors similarly phprepair is only sound up to the given test suite.
however our tools can automatically repair html generation errors rather than simply identifying them.
due to its dynamic approach phprepair does not incur false positives as a static tool might.
nguyen et al.
tackle the same problem of repairing html generation errors in php code but in a very different way.
they use a heuristic algorithm to map html output back to the program while we use instrumentation to get a precise mapping.
like us they focus on constant prints but their heuristic repair algorithm does not appear toensure soundness completeness or minimality.
finally their evaluation only considers fixes found by html tidy we also consider more complicated manual fixes.
weimer et al.
use genetic programming to repair c programs whereby repairs are found by adapting statements from other locations in a program.
like ours their approach requires a test suite uses instrumentation to record execution paths and guarantees correctness up to that suite.
our focus on constant prints allows us to perform exhaustive search for repairs ensuring both completeness and minimality.
genetic programming approaches support more complex repairs but rely on heuristics and hence lack these important properties.
there has also been work on synthesizing programs that meet a given specification.
closest to our work are approaches that require the user to provide an initial program template with holes to be filled in .
phprepair implicitly allows any cprint as a hole and uses tests to identify which ones to modify along with cost minimization to avoid unnecessary patches.
finally gulwani described a tool to synthesize excel spreadsheet macros.
like phprepair that approach is based on input output examples and synthesizes a program that generates strings.
however programs are synthesized in a specialized domainspecific language while we repair arbitrary php programs.
angelic debugging like our approach uses constraint solving over a test suite to identify erroneous expressions.
while it can handle more general errors angelic debugging is in general not able to suggest source level repairs.
several projects use constraint solving for automatic program transformations often in the form of refactorings as in type related refactorings refactoring for inferring generic types in java and refactorings that manipulate access modifiers .
vii.
c onclusions and future work we have presented a novel approach to automatically repair html generation errors in php programs targeting a common class of repairs based on adding modifying and removing statements that print string literals.
we have developed a simple static tool phpquickfix for repairing errors local to a single print statement and a test based tool phprepair for repairing more complex errors by solving a system of string constraints.
our experiments show that these tools are able to efficiently repair most html generation bugs in a variety of open source benchmark programs.
there are several avenues for further research.
we would like to experiment with different cost metrics incorporating knowledge of the program s structure e.g.
to encourage solutions where all fixes are localized in the same script .
to improve performance we may be able to leverage the highly structured form of our constraints to aggressively optimize our sat based encoding rather than relying on kodkod s built in encoding.
finally we would like to generalize our approach to handle more complex repairs.