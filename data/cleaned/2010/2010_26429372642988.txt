behavioral resource aware model inference tony ohmann michael herzberg sebastian fiss armand halbert marc palyart ivan beschastnikh yuriy brun university of massachusetts university of british columbia amherst ma usa vancouver bc canada ohmann mherzberg sfiss ahalbert brun cs.umass.edu mpalyart bestchai cs.ubc.ca abstract software bugs often arise because of differences between what developers think their system does and what the system actually does.
these differences frustrate debugging and comprehension efforts.
we describe perfume an automated approach for inferring behavioral resource aware models of software systems from logs of their executions.
these finite state machine models ease understanding of system behavior and resource use.
perfume improves on the state of the art in model inference by differentiating behaviorally similar executions that differ in resource consumption.
for example perfume separates otherwise identical requests that hit a cache from those that miss it which can aid understanding how the cache affects system behavior and removing cache related bugs.
a small user study demonstrates that using perfume is more effective than using logs and another model inference tool for system comprehension.
a case study on the tcp protocol demonstrates that perfume models can help understand non trivial protocol behavior.
perfume models capture key system properties and improve system comprehension while being reasonably robust to noise likely to occur in real world executions.
.
introduction software developers spend half of their time looking for and fixing bugs with the global annual cost of debugging topping billion .
mature software projects often ship with known defects and even security critical bugs remain unaddressed for long periods of time .
one significant cause of bugs is the inconsistency between what developers think their system does and what the system actually does .
to increase their understanding of a system developers instrument key locations in the code and use logging to peek into an implementation s behavior at runtime.
logging system behavior is one of the most ubiquitous simple and effective debugging tools.
logging is so important that production systems at companies like google are instrumented to generate billions of log events each day.
these events are stored for weeks to help diagnose bugs .
the resulting logs are often incredibly rich with information as legal behavior conditions that result in errors and resource use.
further it is trivial to enhance systems to produce even richer logs by including more runtime information .
unfortunately the richness that makes logs useful simultaneously makes them complex verbose and difficult to understand.
additionally logs contain linear series of events that represent individual system executions e.g.
the processing of a single client request which makes it difficult to understand system behavior in aggregate.
this paper focuses on helping developers understand how a system behaves and how it utilizes resources.
dynamic behavioral specification mining e.g.
tackles the problem of inferring a behavioral model that summarizes a set of observed executions in a concise form.
such models have been used to improve developers understanding of systems from logs to generate test cases and test oracles and to help make sense of complex distributed systems .
while state of the art model inference algorithms rely on event names method names message types and sometimes data values stored in the logs they ignore other rich information that makes logs so useful.
one log feature that is not utilized by existing model inference tools is the prevalence of resource utilization information in logs.
for example a log may record how long each logged event took to execute by including a timestamp with each event how much memory each method used by tracking memory allocation or how much data was sent or received over the network.
our work is motivated by the observation that the precision of model inference algorithms and the utility of the inferred models can both be improved by using resource utilization information that is typically recorded in system logs.
we describe perfume a novel model inference algorithm that extends synoptic in a principled manner to account for resource usage information in system logs such as timing cpu and memory utilization and other resource measures.
perfume infers a model directly from a text log and requires its user to specify a set of regular expressions to parse the log.
perfume works on existing runtime logs with arbitrary log formats as long as they can be parsed by regular expressions and requires neither access to source code nor binaries of the modeled system.
much of the prior model inference work has focused either on improving inference precision or on inferring richer kinds of models such as extended finite state machines fsms message sequence graph and communicating fsms .
these more expressive models can describe more complex software e.g.
distributed systems and also provide more information about the underlying behavior to the user or an automated analysis tool.
however this prior work often abstracts away the context in which the software executes.
in this work we augment the abstract execution of a system with data on its utilization of resources such as time perm ission to make di gital or hard copies of all or part of this work for personal or cla ssroom use is granted without fee pro vided that copies are no t made or distributed for profit or com mercial ad vantage and that copies bear this notice and the full citation on the first page.
cop yrights for componen ts of this wo rk owned by others than the author s must be honored.
abstracting with credit is perm itted.
to copy otherw ise or republish to post on servers or to redistribute to lists require s prior specific perm ission and or a fee.
requ est permissions from perm issions a cm.org.
ase septem ber vasteras sweden.
copyright is held by the owner author s .
pu blication rights licensed to acm.
d perfumetest bandwidth .0broadband .7narrowband .0query .3query .7problem .5ok .5ok .8query .2query .2query .
c synoptictest bandwidthbroadbandnarrowbandqueryqueryqueryokproblemokquerytest bandwidthbroadbandnarrowbandqueryqueryqueryquery b ktailsproblemok .
.
.
get http .
test bandwidth .
.
.
get http .
test bandwidth .
.
.
get http .
test bandwidth .
.
.
get http .
test bandwidth .
.
.
get http .
broadband .
.
.
get http .
broadband .
.
.
get http .
narrowband .
.
.
get http .
query .
.
.
get http .
query .
.
.
get http .
narrowband .
.
.
get http .
query .
.
.
get http .
ok .
.
.
get http .
query .
.
.
get http .
query .
.
.
get http .
ok .
.
.
get http .
query .
.
.
get http .
problem .
.
.
get http .
query .
.
.
get http .
ok a input logfigure a a sample network diagnosis tool s log of four execution traces one trace per ip address and models inferred by the b ktails algorithm with k c synoptic and d perfume on that log.
in the perfume model each event is annotated with the time it took to complete.
power and bandwidth.
our tool perfume infers models that capture the context in which the execution took place.
to ease human comprehension of models perfume limits each model s context to a single resource described numerically.
still for many analyses a small amount of such contextual information provides valuable insight that is not present in the abstract sequences of events likely data invariants and other behavior descriptions.
perfume models are predictive they generalize observed executions and predict unobserved combinations of behavior that likely represent possible system executions.
this helps to keep the models concise and to reason about the system behavior as a whole as opposed to only about the observed executions.
perfume infers models by mining temporal properties with resource constraints from the log building an optimistically concise fsm model of log executions by overgeneralizing those executions and iteratively refining the model via counterexample guided abstraction refinement cegar until the model satisfies all the mined resource constrained properties.
perfume builds on synoptic by extending its property mining model checking and refinement algorithms to account for and enforce the resource constrained temporal properties while also extending the underlying formalism to encode the executions resource context.
this enables perfume models unlike those of related work to account for optimizations such as caching lazy evaluation and loop perforation all of which impact system performance and can cause bugs.
perfume models can be used to improve developers comprehension of a system.
our small scale user study showed that when given perfume models academic developers answer more system comprehension questions correctly and in less time than when shown only execution logs and .
more correctly in .
less time than when shown synoptic inferred models.
this paper makes the following contributions we introduce perfume a new approach to infer behavioral resource models of systems.
the approach and the corresponding open source tool are general purpose perfume works on any resource that can be represented numerically and any system log that contains a set of sequentially executed events.
we implement and publicly deploy perfume in the cloud and release the source code we demonstrate that perfume models improve comprehension via a user study with academic developers showing that perfume models make developers more effective at answering system comprehension questions than execution logs and .
more effective than models inferred by synoptic.
we demonstrate that perfume models can capture complex behavior via two case studies one applying perfume to the tcp protocol and another to a web log from a real estate website used in the bear framework evaluation.
the rest of this paper is structured as follows.
section illustrates how resource information can improve model inference.
sections and detail the log parsing property mining and model construction stages of perfume respectively.
section describes our prototype perfume implementation and section evaluates perfume in a user study and two case studies.
section places our work in the context of related research.
section discusses our findings and future work.
finally section summarizes our contributions.
.
perfume overview consider an example system of a network diagnosis tool that a server can use to identify problematic client network paths.
the tool first determines if the client is using narrowband or broadband and then executes a series of queries.
based on the speed and characteristics of the client s responses to the queries the tool classifies the network path as okorproblematic.
the tool s developer wants to know what factors cause the tool to report client paths as problematic.
runtime logs of the tool shown in figure a can help answer this question but the information is hard to infer manually.
instead model inference tools can summarize the log.
figures b and c depict models inferred using two well known algorithms ktails and synoptic respectively.
the ktails model differentiates execution paths of broadband and narrowband clients but it contains no indication of the types of executions that suggest network problems because all paths pass through the common bottom node.
unlike the ktails model the synoptic model correctly conveys that no network problems are reported for narrowband clients.
however it does not help the developer further differentiate between those broadband clients who experienced a network problem and those who did not.
what the developer really wants to see is a model that reveals what types of executions imply a network problem.
our proposed approach perfume infers the model shown in figure d that exposes this information1.
this model still differentiates execution paths of broadband and narrowband users but it also separates the subpathbroadband!query!query!problem from the sub path broadband!query!query!okbased on the performance of 1the perfume implementation outputs event based models but for exposition we convert them to the more standard state based fsms with anonymous states.
20the second query.
the former sub path reveals that the tool reports a network problem when a broadband client responds slowly to the second data query.
note that simply adding resource information to the edges on the ktails and synoptic models would not help identify what leads the tool to report a problem.
the synoptic model would predict that both slow and fast responses on broadband can lead to a problem.
meanwhile the ktails model predicts that all combinations of response speeds and bandwidths can lead to a problem.
by contrast the perfume model not only displays the resource information but is also more precise in its predictions which leads to a more accurate differentiation between executions.
.
goals and challenges perfume s high level objective is to produce a representative model of a system from an execution log containing examples of that system s behavior.
more specifically goal .
generate models that are precise and predictive.
predictive models generalize from the observed executions to also describe unobserved but likely possible executions.
goal .
generate models that are concise.
concise models are human readable and are more likely to be understood by a developer than the logged executions.
concise models also contribute to generalization preventing or reducing overfitting to the observed executions.
achieving these goals requires solving three research challenges challenge .
identify resource based properties to precisely describe observed behavior without overfitting.
we use property mining to generalize observed behavior.
these properties must be tractable to mine and to model check and they must be descriptive.
section addresses this challenge.
challenge .
make perfume general and applicable to a wide range of systems logs and resource measures.
to apply to a broad range of systems perfume must neither require access to the system source code nor binaries and should handle a large variety of logs.
section addresses this aspect of this challenge.
further perfume must make few assumptions about the resource measures.
for example while timestamps increase monotonically in many log formats and this monotonicity eases property mining and model checking many resources including memory usage power availability and network congestion are not typically monotonic and perfume should mine and model check such properties.
section .
addresses this aspect of this challenge.
challenge .
efficient model checking of resource based temporal properties.
model checking efficiency is necessary for model refinement inferring the minimal model is np complete and perfume approximates an optimal solution.
sections .
and .
address this challenge.
.
the perfume approach figure summarizes the perfume approach.
perfume infers fsm models in which each event is annotated with a distribution of resource metric values.
visually we represent this distribution as parserexecutionlogparsingexpressionsresource constrained property minerinitial model constructioncegar refinementktailscoarseningfinalmodelinput output figure the perfume model inference process.
a range e.g.
and represent singleton ranges with a single number.
perfume infers models of unmodified systems as its input is a runtime log of system executions.
perfume does not require a specific format as long as the log can be parsed with regular expressions as described in section .
perfume produces precise and concise models by generalizing observed executions.
perfume ensures precision by enforcing a rich set of temporal resource constrained properties that hold in the observed executions.
for example if perfume finds that the log of observed executions captures timeout behavior then the model it infers will disallow predicted unobserved executions from reaching a timeout sooner than the fastest observed timeout.
section will formalize the property templates using timed propositional temporal logic tptl .
perfume mines instances of these properties from the observed executions and refines the model to ensure that predicted but unobserved executions behave accordingly.
perfume ensures conciseness in three ways perfume starts the inference process with the smallest possible but imprecise initial model that separates only different event types and limits the edges to only those observed during execution perfume refines the initial model to eliminate counter example generalizations that violate the mined properties and perfume coarsens the final model using the ktails algorithm to clean up after suboptimal refinement.
section further details this three step process.
.
log parsing perfume operates on system execution logs and requires access to neither system source code nor binaries making perfume general and broadly applicable to a wide range of systems satisfying part of challenge from section .
.
perfume has two inputs the system s runtime log and a set of regular expressions for parsing the log.
the regular expressions must extract from the log the individual execution traces of the system.
each trace consists of a sequence of event instances and each event instance is associated with a resource measurement .
for example in the log in figure a a trace is a session for one ip address and event instances are specific server actions that appear on each log line such as the strings test bandwidth andquery .
the resource measurements are the timestamps associated with each log line.
to parse the log in figure a the developer would need to specify the following two regular expressions ?hipi .
?h dtimei .
n get http .
?h typei .
nkhipi the first expression matches the log lines and extracts the ip address time and event type from each line.
the second expression maps log lines with the same ip address value to the same execution.
there are two common points at which systems log events either before starting the event or after completing it.
perfume works for both cases but models inferred from two such logs should be interpreted differently.
for example consider two adjacent event instances aandb and time as the logged resource metric.
if logging occurs before starting an event the difference between the metrics 21description timed propositional temporal logic formula notation in this paper aalways followed by bupper bound t whenever ais present in a trace bis also present later in the same trace with metric difference at most t. x. a!
3y.
b y x t a t !b aalways followed by blower bound t whenever ais present in a trace bis also present later in the same trace with metric difference at least t. x. a!
3y.
b y x t a t !b aalways precedes bupper bound t whenever bis present in a trace ais also present earlier in the same trace with metric difference at most t. x. a 3y.
b y x t a t b aalways precedes blower bound t whenever bis present in a trace ais also present earlier in the same trace with metric difference at least t. x. a 3y.
b y x t a t b ainterrupted by bupper bound t between any two consecutive aevents there must be a bevent and the metric difference between the two aevents must be at most t. x. a!
b 3y.
a y x t ab t !
a ainterrupted by blower bound t between any two consecutive aevents there must be a bevent and the metric difference between the two aevents must be at least t. x. a!
b 3y.
a y x t ab t !
a anever followed by b whenever ais present in a trace b is never present later in the same trace.ltl formula a!
b a6!b figure perfume property types including a description the corresponding tptl formula and the short hand notation used in this paper.
ofaandbis the time to complete a. it follows that the time to complete the last event in each trace is undefined.
however if logging occurs after completing an event the metric difference between aandbis the time to complete b. it follows that the time to complete the first event in each trace is undefined.
.
property mining perfume models predict possible unobserved executions that likely could be produced by the underlying software system.
to ensure this prediction is accurate and satisfies goal from section .
perfume approximates the unknown properties of the underlying system using properties mined from the observed traces and enforces those properties on all paths in its inferred model.
a path that violates one or more of these properties represents an execution that exhibits behavior dissimilar to all observed behavior and therefore perfume assumes that the system is unlikely to produce such an execution.
section .
will describe the types of properties perfume uses and section .
will discuss perfume s solution to the challenge of mining such properties from logs with monotonic and non monotonic resources.
.
property types perfume parses the log of observed executions and mines seven types of temporal resource constrained properties that hold for every trace in the log.
the seven property types figure perfume mines and enforces are based on the most common and representative specification patterns presented by dwyer et al.
.
we formalize these properties using timed propositional temporal logic tptl .
these properties help perfume address challenge from section .
by ensuring that perfume s predictive models are precise.
for example if every observed execution that had a send event also had a receive event and the most time that ever passed between these events were .
seconds perfume would mine the property send always followed by receive upper bound .
represented as send !
receive .
when inferring the model perfume would ensure that no predicted execution had a sendevent without a later receive event and had a receive event generated more than .
seconds after a send event.
three of these property types always followed by always precedes and never followed by were presented in synoptic and we extend the former two with resource constraints.
while these ostensibly simple property types were shown in to capture complex behavior perfume can be easily extended to support more complicated property types.
we introduced resource constrained interrupted by properties which are binary properties with some characteristics of ternary properties after empirically finding that they can express additional system behavior.
note that while there are only seven property types there can be many more instances of these types mined from a log the number of instances typically depends on the number of different event types the system can produce.
the seven property types are templates for constraints on the possible behavior of the system with the first six property types also encoding the system s performance characteristics.
for the upper bound constraints on properties always followed by and always precedes tis the maximum resource metric difference for all traces between the first event aand the last event bin each trace.
for the lower bound constraints on the same properties tis the minimum resource metric difference between any event aand any event bin each trace.
bounds on the interrupted by property behave identically except relevant metric differences are between the first and last event of the same type a. recall that these resource metric differences include the metric measurement during the completion of abut not bif events are logged before they start.
the reverse is true if events are logged after completion.
perfume s properties extend synoptic s properties with performance data and capture key behavioral properties of the system more precisely.
for example from the log in figure a one of the properties perfume mines is broadband 7s problem .
this property is crucial to understanding the system s behavior because it differentiates the query events after broadband that lead toproblem from those that lead to ok. this reveals that network problems are reported after a fast query followed by a slow query a b compile 110change120pull60 compile 50compile 110change120pull10pushcompile 120change compile 60pull compile change compile push compile change compile pull push pull compile change compile change compile push dijkstra120 dijkstra dijkstra130 dijkstra dijkstra120 lamport lamport110 lamport lamport lamport perlis120 perlis perlis130 perlis perlis140 perlis perlisfigure memory is a non monotonic resource.
the log a of three executions of a version control system is annotated with the user s local machine memory use.
perfume handles non monotonic resources and infers the model b of that log.
whereas no problems are reported after two fast queries.
section .
will explain how perfume uses these temporal properties to refine the model separating paths that exhibit distinct behavior and enforcing that all predicted paths satisfy the mined properties.
.
handling varied resource types the log in figure represents the typical workflow of three developers changing and compiling code and interacting with a distributed version control system via pulls and pushes.
the log keeps track of the memory consumption of each developer s system at the time each event executes.
unlike time system memory consumption is non monotonic.
mining properties constrained by resources that either increase or decrease monotonically e.g.
time can be done by comparing relatively few pairs of event type instances.
for example to mine instances of the property a t !b one has to consider all adjacent a andbinstances in every trace and identify the pair with the least t difference in the resource.
similarly for a t !b one only has to consider the first instance of ain every trace and the last instance ofb.
however for logs with non monotonic resources as in figure a such algorithms cannot work because the two instances of a andbwith the least and most resource differences may neither be adjacent nor most distant in the trace.
for example in figure a the first last pair algorithm would report compile !
push which is a false property because the difference between lamport s second compile event instance and only push instance is .
figure lists the unoptimized resource constrained temporal property mining algorithm that handles both monotonic and nonmonotonic resources.
this algorithm inspects all atype andbtype event instance pairs to compute the lower and upper bounds for each mined property.
perfume uses synoptic s miner for unconstrained property types described in section .
in .
perfume s implementation of the algorithm in figure also minimizing the number passes over the log.
this algorithm addresses part of challenge from section .
ensuring that perfume is applicable to a broad range of resource measures and log types.
function computebounds atype btype log let lbound positive infinity let ubound negative infinity foreach trace inlog foreach e1intrace where e1 etype atype foreach e2intrace after e1where e2 etype btype computedelta returns the difference in resource utilization between two event instances.
lbound min lbound computedelta e1 e2 ubound max ubound computedelta e1 e2 return lbound ubound figure perfume s algorithm for computing the lower bound and upper found resource constraints for two event types atype and btype on a given loginput.
this algorithm is run on each pair of event types that appear in a mined unconstrained property.
the constraints for the interrupted by property type are computed differently we omit this algorithm for brevity.
.
model construction to construct a concise model satisfying goal from section .
perfume first builds the most concise model it can as section .
describes.
while concise this initial model is imprecise because it predicts many executions that do not satisfy the mined temporal resource constrained properties.
thus to satisfy goal from section .
perfume iteratively refines the initial model to satisfy these properties.
section .
explains the refinement process.
perfume s task is np complete so it approximates a solution and may at times make suboptimal refinements.
to partially correct these suboptimalities once perfume s refinement reaches a model that satisfies all mined properties it coarsens the model where possible without introducing property violations.
section .
explains the coarsening process.
both refinement and coarsening require model checking detecting property violations in the model and section .
describes this process.
.
initial model construction initially perfume constructs the most concise possible fsm model.
in this model all events of the same type lead to the same state.
for example the initial model for the log in figure a would have all query events lead to a single state and no other events lead to that state.
the initial model is very concise but only somewhat precise.
all the edges in this model represent an observed state transition.
however because all events of a given type lead to the same state this model is overgeneralized it predicts many unobserved executions without regard for their satisfying the temporal resource constrained properties mined from the observed executions section making the model somewhat imprecise.
next perfume refines this initial model to eliminate mined property violations and increase the model s precision.
.
refinement the goal of this phase of the algorithm is to refine a model that violates some of the mined properties into a concise version that satisfies all of those properties.
creating such a model that is optimally concise is np complete .
like prior work perfume finds an approximate solution.
to satisfy challenge from section .
this refinement must be efficient.
perfume iteratively performs counterexample guided abstraction refinement cegar until the model satisfies all the mined properties.
in each iteration perfume uses model checking to iden23broadband .7query .3problem .5ok .5query .2query .4broadband .7query .3query ok .5problem .
a b figure an example of a perfume refinement step part of the construction process of the model from figure d .
the partial model in a does not satisfy the mined temporal property broadband problem .
perfume refines this model by splitting the shaded state into the two shaded states in b .
the resulting model satisfies the mined property.
tify a predicted path in the model that violates a mined property2.
model checking section .
recognizes violations by finding paths that falsify a mined property s tptl definition.
using the first identified counterexample path perfume localizes the violation and splits states in the model to eliminate the path from the model.
localization helps approximate the optimal states to split in order to keep the model as concise as possible.
then perfume iterates to find another violation of this or another property and further refines the model until all properties are satisfied.
figure shows one example refinement iteration.
the partial model in figure a does not satisfy the mined temporal property broadband problem .
perfume finds the counter example path that contains the sub path broadband .
!query .
!
problem .
and refines the model to eliminate this path by splitting the shaded state into the two shaded states in figure b .
the resulting model satisfies the mined property.
perfume s refinement is guaranteed to produce a model that satisfies all the mined properties because in the degenerate case it will refine the model until it describes exactly the observed executions and makes no other predictions.
in our experience however perfume finds a more concise predictive model.
.
coarsening since model inference is np complete the refinement procedure efficiently approximates the most concise model by sometimes making suboptimal refinements.
once refinement produces a model that satisfies all the mined properties a modified version of ktails with k 1can make the model more concise through coarsening.
this process checks each pair of events of the same type to see if their source and destination states can be merged without introducing a property violation.
this guarantees that perfume s model is locally minimal although it cannot guarantee global optimality.
this coarsening helps keep the inferred model concise satisfying goal from section .
.
.
model checking perfume uses model checking to identify property violating counterexamples to guide refinement section .
and during coarsen2while model checking does not differentiate between observed and predicted paths observed paths cannot violate the properties mined from the observed paths themselves.
figure a screenshot of the perfume front end.
the three tab interface allows viewing the perfume inputs mined invariants and the model.
shown here is one of the models used in the user study section .
.
another view of this model is shown in figure .
ing to identify a locally concise model that preserves the mined properties section .
.
this model checking procedure must be efficient to address challenge from section .
.
during model checking for each mined property instance perfume tests if there exists a path through the model that falsifies the property instance s tptl definition.
to do this perfume encodes each property as a property fsm that accepts only the executions that satisfy the property.
model checking simulates all paths in the model in this property fsm.
if model checking discovers a path the fsm rejects that path serves as the counterexample.
when used for refinement this counterexample is simulated in the model to locate the violation.
when used for coarsening the violation signifies that the proposed merge of two states should be rejected.
.
implementation perfume is implemented in java and is released as open source .
the implementation builds on the synoptic code base we added a total of new lines of code to synoptic about of the codebase to implement perfume.
the java prototype outputs models in the graphviz dot format3 which can then be converted into standard image formats.
as well we deployed a web based front end to perfume bitbucket.org perfume .
figure shows a screenshot of the front end.
using this front end users can upload a log enter the regular expressions to parse that log and then explore the perfumegenerated model.
the front end model visualization highlights the paths that consumed the most and least resources and supports several other queries to allow users to better understand the modeled system behavior.
by default perfume generates models in event based form as shown in figure .
these can be trivially converted to state based models akin to other figures in this paper.
the event name within each node is simply moved to all its outgoing edges if events are logged before they start as is the case in figure or all its incoming edges if events are logged after they complete recall section .
.
evaluation we evaluated perfume in three ways.
first we carried out a user study to see if users can interpret perfume models and use them to answer questions about system behavior section .
.
we found 24that on average subjects answered questions more quickly and more correctly with perfume than with only logs and synoptic .
second we applied perfume to a log of tcp packets captured from a browsing session section .
.
we used the inferred tcp model to identify three standard timing based protocol behavior.
finally we applied perfume to a subset of a web access log for a real estate website that was the subject of evaluation in section .
.
using the inferred model we replicated some of the findings from and also identified a new analysis specific to the perfume model.
.
user study to understand if perfume derived models support developer system understanding we designed and conducted a user study.
all of the user study materials are available online .
our goal was to compare perfume behavioral resource models against the standard behavioral models derived with synoptic as well as to compare them against the raw log information that a developer typically inspects.
the study was structured as a take home assignment in a graduate software engineering course.
a total of students completed the survey and additional participants completed it voluntarily.
the respondents had .
years of programming experience on average and of the reported that they use logging to debug their code frequently or very frequently.
to our knowledge none of the participants had previous experience with perfume.
participants were asked to read a short description of a system and then answer questions about the system s behavior using one of three treatments a runtime log the log and an inferred synoptic model or the log and an inferred perfume model.
each respondent answered questions about three systems exactly one with each treatment.
the order of the systems and treatments were random.
every question had one correct answer and the responses were timed.
participants using the perfume treatment answered .
of the questions correctly meanwhile the synoptic treatment resulted in .
correct responses .
fewer correct responses and the log treatment .
.
fewer correct responses .
the mean time taken to answer questions in the perfume synoptic and log treatments averaged by system was seconds seconds and seconds respectively.
using perfume models reduced question response times by712 versus synoptic models and778 versus logs.
for the study we selected three systems the radius authentication protocol a web browser and a hypothetical connection tester tool modeled in figure .
the radius protocol authenticates clients on a network.
clients send a request message with a username and password and the server can grant access reject access or ask the client to send another request message containing additional credentials.
logs included these messages with their sizes in bytes.
participants using the perfume model correctly answered the most questions .
about the radius protocol.
they also spent the least amount of time seconds .
.
caching web browser .
web browsers often cache previouslyviewed pages and resources to disk to speed up subsequent requests.
we manually wrote a log that simulated a web server cache recording when an object was cached and retrieved along with the total number of kilobytes read from and written to disk.
figure shows the perfume inferred perfume model for this log.
for this system participants performed best using a synoptic model.
they spent an average of seconds to correctly answer 4because the number of questions for each system varied we first computed the average of the correct answers for each system and then averaged these across the three systems for each treatment.
cache page retrieve page retrieve page cache image cache image retrieve image retrieve image quitfigure perfume model of web browser caching events used in the user study section .
.
.
of the questions.
using a perfume model they averaged seconds were correct .
of the time.
.
connection tester is a fictional tool that diagnoses network issues.
it tests a client s bandwidth executes a series of queries and then classifies the network path as normal or problematic based on the results.
our manually written logs included server events with timestamps.
participants using perfume models averaged seconds to answer questions about connection tester the most time of the three tools.
however perfume model users correctly answered almost every question averaging .
correct.
users answered correctly less than .
of the time using the other two tools.
after completing the survey respondents were asked to describe their experiences with the three tools.
of the respondents found perfume models to be the most useful for some types of questions.
further said they would use perfume models if available said they might said he would not and did not respond.
multiple participants found perfume models to be easier to understand and one envisioned applying them to regression testing.
one respondent commented that comparing these models with mental model of a system would be very useful in making sure the contracts expect to be enforced are actually holding.
a respondent also suggested that perfume models would make abnormal behaviour much more clear and would be very useful for debugging.
no one tool dominated the others across all three systems but participants using perfume did best on two of the three systems.
and on average participants using perfume models spent the least time answering and answered the most questions correctly.
while this study was small these preliminary results suggest that perfume models can help developers understand unfamiliar systems quickly.
.
modeling tcp tcp is a network transport protocol for in order and reliable exchange of packets sequences of bytes between a source and a destination host.
a tcp connection starts with a three way handshake between a client active end point and a server passive end point .
in this exchange the client first sends a synpacket to which the server replies with a syn ack which the client in turn 25synsyn acksyn acksyn acksyn figure a part of the perfume model derived for tcp.
the servergenerated events are shaded.
the model illustrates that perfume correctly inferred the synre transmission timeout.
answers with an ack.
once established a tcp connection transfers data bidirectionally between the two end points using ackpackets to acknowledge data reception.
when the transfer is completed the server typically closes the connection with a fin and the client responds to this with a fin ack.
tcp packets include flags to encode packet types such as syn ack and fin and special events such as rstandpsh.
an end point sends a packet containing the rstflag if it decides to terminate the connection unilaterally e.g.
due to a technical issue which relieves it from executing the closing handshake involving fin.
since tcp implementations typically buffer data in the host operating system interactive applications need a way to flush these internal buffers.
thepshflag causes data in the buffers to be transmitted immediately.
.
.
methodology we used perfume to infer a model of tcp with the flag types serving as model events.
we then examined this model manually.
we used wireshark5to capture all incoming and outgoing tcp packets on server port into a log.
we then opened a wikipedia page6in the google chrome version web browser and opened the article for each of the five umass campuses in a separate window always letting one page fully load before opening the next.
these pages included text and images.
we exported all captured tcp packets into a file.
we treated the flags of a single captured packet as an event and all packets sent received via a specific client port the server port was always as a trace.
we filtered out traces longer than events as these traces contained long psh ack andacksequences that occur when transferring large amounts of data such as images.
since we were specifically inspecting behavior while establishing and closing connections these traces would have complicated the model without adding useful information.
note that such filtering is a likely part of a process developers may follow in using perfume to investigate a system s behavior.
we collected and processed traces containing a total of events.
the largest trace had events and the shortest trace had the minimum for the handshake information exchange .
perfume mined properties such as syn 36ms psh ack meaning that it takes at least milliseconds from the connection initialization the client sending a packet with the synflag set to the first packet containing application data the server sending packet with the psh ack flags set .
.
.
results and observations the model perfume inferred has a total of nodes and edges and is available online .
it displays the initial three way handshake that utilizes syn.
additionally the model shows an alternating pattern of ackpackets between the client and the server as well as graceful termination via finpackets.
the perfume model also captured several tcp corner case behaviors rst ackack9.5sfin ackack9.6sack6.6srstfigure a part of the perfume model derived for tcp.
servergenerated events are shaded.
the model illustrates that perfume correctly inferred that if the server transmits a rstpacket when the client does not communicate for a long time.
if the synpacket during the initial handshake is not acknowledged by the server within a short timespan the client assumes it was lost and resends the synpacket.
this is indicated by thesyn loop in the model and explains how tcp reacts to lostsynpackets.
figure illustrates this behavior with the empirically derived timeout range of seconds.
a connection may not terminate gracefully with fin and may be aborted by the server with a rst.
the model inferred by perfume indicates that this behavior occurs after a long break seconds since the client s last ackwithout any further packets.
this corner case demonstrates how the server terminates the tcp connection when the connection has remained quiescent for too long.
figure illustrates this behavior.
the inferred model also captures the behavior in which no data is sent after the initial handshake leading to a slow transition between the client s ackand a fin ack .
in the other cases data is sent with a pshflag and perfume shows a faster transition in these cases.
this illustrates how the client terminates the connection if it requires no new data after the initial handshake.
the slow transition is most likely caused by a timeout as the client waits for new data.
we used perfume to infer a model of flags within tcp packets in connections between a web browser and a web server.
one of the authors who had minimal prior knowledge of tcp identified three corner case behaviors.
this case study demonstrates that perfume generated models can capture performance and resourcebased behavior and may be useful for improving comprehension of a protocol or for confirming specific protocol behavior.
.
modeling user behavior several existing tools use web logs to infer models of how users interact with websites .
in this section we compare perfume with one of these tools bear which mines behavioral models using probabilistic markov models.
.
.
methodology the bear authors shared with us an anonymized subset of the log they used in their experiments.
this log contains web request data from a real estate website on which users browse or search for houses and apartments to rent or buy.
each logged web request is associated with a timestamp which we use to compute the time between a user s web requests.
the input log consisted of about lines.
we reused bear s pre processing and taxonomy of events.
the pre processing cleans the log e.g.
by removing events generated by web crawlers and provides each event with semantics by categorizing the events using manual rules see section .
in .
reusing these bear components allows us to directly compare the bear s and perfume s model inference processes.
26s2s4s3s1sales anncsp .85m 13ssales anncsp .085m 2ssales anncsp .085m 11ssearchp .11m 39sfigure a part of the perfume generated real estate website userbehavior model from the log used in the bear evaluation .
this part describes the behavior relevant to the search page state s2 indicating that users leave this page quickly presumably toward their intended target pages.
the pre processed log contained about lines categorized into categories.
perfume executions took on average hours to infer a model.
this runtime is an average of executions on an intel core i7 3630qm laptop with gb ram running 64bit java .
.
.
compared to bear which completes in a few minutes perfume is slow.
we believe this is due to the complexity of the constrainedinvariants by comparison synoptic also takes a few minutes to complete .
we believe there is ample room for optimization in our implementation.
.
.
results and observations perfume extracted traces with a total of events from the log.
it mined property instances and inferred a model with states and transitions.
the complete model is available online .
to study the model we used gephi a graph exploration tool.
additionally we developed a script to highlight certain configurations in the model.
our analysis identified states with high probability of a short stay to focus on webpages on which users spent a short time.
such an analysis is relevant to web developers and maintainers who strive to keep the users attention.
we used a prior study to define a short stay threshold value of seconds we use this as a cut off for the median of the range of times on an edge in the perfume model.
to find pages with high probability of a short stay we rely on the trace based transition probabilities present but not shown by default in the perfume models.
the probability of a transition between two states on some event is the number of traces from the log that transition along the event divided by the total number of traces that pass through the source state.
given a state we add the probability of all the state s outgoing transitions except self transitions that represent a short stay.
we identified several states with a high probability of a short stay these states correspond to the search sales and renting pages of the real estate website.
here we discuss the search page.
figure presents a part of the model relevant to the search page state s2 .
this page has a high probability of a short stay since transitions out of s2have a median time below 20s with probability .
other states in the model representing the search page had similar high probabilities of a short stay.
this result suggests that the search page is well designed since users are routed off the search page quickly.
the bear framework can detect navigational anomalies such as the difference between actual and expected user navigation flow by comparing the bear model to the site map .
the bear study used such anomalies to identify problems with the termsof use page this page which is only accessible from the contact page was missing a back button.
this resulted in unexpected transitions from the state corresponding to the terms of use page.
the perfume model can also support this task by showing reachability in the inferred model from the terms of use page state.
however perfume cannot easily support some other analyses supported by bear.
for example bear can report the probability of a user browsing the sales page and not the renting ads page.
overall the perfume model improved our understanding of the real estate website.
while perfume allowed us to answer certain questions that bear cannot answered e.g.
finding pages with high probability of a short stay and perfume allowed us to replicate some of the analysis that bear supports other bear supported analyses could not be easily performed on perfume models.
thus perfume is complementary to bear assisting some of the same and some different comprehension tasks.
.
related work we have previously proposed perfume at a high level in focusing on log event timestamps.
in this paper we generalize perfume to other resources present a complete and detailed description of the involved algorithms evaluate perfume and present deploy and release the source code of a perfume prototype.
perfume builds on synoptic which infers behavioral models that obey temporal properties without resource constraints.
as figure illustrates synoptic models are likely more concise but less precise than perfume models.
walkinshaw et al.
also infer models constrained by temporal properties but these properties are provided manually by the user.
other approaches infer different kinds of models such as live sequence charts or enrich models with other information such as data invariants .
by contrast perfume infers models to help developers understand system resource utilization characteristics.
the timed automata formalism extends finite state machines with real valued clocks to describe systems for which time plays an important role.
perfume can be seen as a first step toward inferring timed automata system models.
invarimint proposes declaratively specifying fsm based model inference algorithms.
invarimint does not support resource based properties.
we plan to express perfume with invarimint using an extended set of intersection and union operations over automata that encode metric values.
perfume mines temporal properties with constraints from the input log.
prior specification mining work has focused on mining temporal and data properties as well as richer performance related properties of distributed systems .
on their own however mined properties can easily overwhelm a developer which is why perfume uses mined properties to infer a more comprehensible concise model of a system s resource utilization.
other approaches for tracing and capturing performance data in complex systems are complementary to ours as they produce logs that can reveal system structure .
perfume targets sequential systems and requires a totally ordered log of system behavior perfume models cannot describe multi threaded or distributed systems.
recent work on statistical debugging indicates that most userreported performance issues are diagnosed through comparison analysis .
building on perfume can support performance comparison by differencing two perfume derived models.
more generally perfume models can be used for performance fingerprinting testing and other tasks.
depending on the specificity of the logged information perfume models may also be used to support lag hunting .
software performance engineering research can be classified into 27two distinct approaches predictive model based approaches used in early phases of a software development and measurementbased approaches like perfume that improve the comprehension of existing systems.
predictive model based approaches have been extensively surveyed .
perfume is not intended to replace specialized and fine grained performance analysis tools such as runtime profilers like yourkit7 or memory tools like valgrind8.
these specialized tools provide thorough performance analysis of a specific resource and require instrumentation.
perfume relies on existing log messages though more can be added to improve its analysis does not require instrumentation and can model any numerically valued resource that is interesting to a developer.
further perfume can take advantage of prior work on fine grained logging of performance information and recent tools that make it easy to collect and manage event logs9.
.
discussion and future work our evaluation results indicate that perfume models can help developers understand the performance characteristics of their systems.
we are working to expand the capabilities of the perfume front end website to allow developers to interact with perfume models in more meaningful ways.
for example developers will be able to visualize answers to queries like which path in the model has the least sum total resource use?
front end answer highlight path or why are these two states split?
front end answer highlight property type that is violated when the two nodes are merged .
the focus of our evaluation was primarily on the inference of models from logs with timing information like timestamps though the user study described in section .
included two non temporal models.
we believe that perfume models generalize easily to many other kinds of resources that can be expressed numerically such as energy throughput and memory use.
we will explore the modeling of these various resource types in our future work.
perfume inferred models describe not only the system but also its environment.
thus a model inferred from a set of executions in an environment with environment specific resource use may not generalize to other contexts but does accurately describe that and similar deployments.
our view is that the model is a compromise between the design time specification model and the low level log of an execution helping developers reason about the system and its deployment.
perfume models may have more nodes and edges than synoptic models as perfume satisfies a superset of the synoptic properties .
this may hurt human comprehension.
more generally there is a trade off between including more information in the models and making the modes useful for comprehension.
however there are tools e.g.
gephi that are designed to make large graph exploration more tractable.
in fact we used gephi when dealing with the more complex model in section .
.
we also envision other non comprehension uses for perfume models.
for example developers can use these models to identify erroneous executions based on performance characteristics during debugging.
also perfume models can be thought of as specifications of a system s actual runtime behavior.
this can be useful to library developers who can use the inferred models to document good and bad library usage practices.
in ideal circumstances executions in the input log would exercise all possible system behavior.
in reality however most logs will be incomplete so perfume predicts system behavior that is not present disconnectedauth77eap auth connected rekey rekey connected figure a ground truth model of wpa supplicant s high level behavior including time bounds in milliseconds.
in the log.
one way to assess the effectiveness of perfume s predictions is to evaluate its ability to recover a known ground truth model of a system s behavior using logs covering varying proportions of all possible system behavior.
we have begun a preliminary evaluation in this direction on the wpa supplicant wireless authentication daemon10model pictured in figure .
we used this model as the ground truth although perfume originally inferred this model from daemon logs .
we generated a log from this model that provides full coverage of model behavior by traversing each path in the model two times one execution exercised all minimum metric values and another exercised all maximum metric values.
for each loop in the model at least one execution traversed that loop and no executions traversed any loops more than once.
using the complete set of such paths perfume recovered the ground truth model in figure .
we are working to extend this early result to circumstances in which the set of observations generated from a ground truth model is incomplete or noisy.
.
contributions we have presented perfume a resource aware approach for inferring behavioral software models.
a preliminary evaluation shows promise that perfume inferred models encode important behavior missed by prior approaches and improve developers comprehension.
for example a small scale user study showed that using perfume improves comprehension task correctness and speed by over using logs and by over using a prior model inference tool.
by using resource use information only available at runtime perfume can improve the inferred model s precision and convey information that other approaches ignore.
perfume inferred models may also improve software processes and various forms of program analysis.
for example library developers can use perfume to document the performance characteristics of the library api.
these models can then be used to optimize programs automatically according to their library s usage patterns.
in testing perfume models can be used to broaden a test suite s coverage by producing and testing perfumepredicted executions.
further testing can focus on likely executions that are especially slow and are more likely to contain performance bugs.
our early results show great promise for perfume s model quality and suggest applying perfume in these contexts.
.