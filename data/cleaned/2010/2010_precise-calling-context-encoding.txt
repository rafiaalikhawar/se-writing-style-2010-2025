see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation precise calling context encoding conf erence paper in ieee t ransactions on softw are engineering may .
.
sour ce dblp citations 53reads author s including william n. sumner simon f raser univ ersity publica tions citations see profile dasar ath weer atung e purdue univ ersity west laf ayette publica tions citations see profile xiang yu zhang taiyuan univ ersity of t echnolog y publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y william n. sumner on mar ch .
the user has r equest ed enhanc ement of the do wnlo aded file.precise calling context encoding william n. sumner yunhui zheng dasarath weeratunge xiangyu zhang department of computer science purdue university wsumner zheng16 dweeratu xyzhang cs.purdue.edu abstract calling contexts are very important for a wide range of applications such as profiling debugging and event logging.
most applications perform expensive stack walking to recover contexts.
the resulting contexts are often explicitly represented as a sequence of call sites and hence bulky.
we propose a technique to encode the current calling context of any point during an execution.
in particular an acyclic call path is encoded into one number through only integer additions.
recursive call paths are divided into acyclic subsequences and encoded independently.
we leverage stack depth in a safe way to optimize encoding if a calling context can be safely and uniquely identified by its stack depth we do not perform encoding.
we propose an algorithm to seamlessly fuse encoding and stack depth based identification.
the algorithm is safe because different contexts are guaranteed to have different ids.
it also ensures contexts can be faithfully decoded.
our experiments show that our technique incurs negligible overhead .
on average .
for most medium sized programs it can encode all contexts with just one number.
for large programs we are able to encode most calling contexts to a few numbers.
categories and subject descriptors d. .
testing and debugging monitors testing tools general terms reliability security performance experimentation keywords calling context dynamic context sensitivity profiling .
introduction the goal of calling context encoding is to uniquely represent the current context of any execution point using a small permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.number of integer identifiers ids ideally just one.
such ids are supposed to be automatically generated at runtime by program instrumentation.
efficient context encoding is important for a wide range of applications.
event logging is essential to understanding runtime interactions between different components of large distributed or parallel systems.
however different modules in these systems tend to use the same library to communicate e.g.
sending a message using a socket library.
simply logging these communication events often fails to record the intents of these events.
recording their contexts would be very informative but on the other hand expensive and bulky as it often implies walking stack frames to reconstruct a context and explicitly dumping the context as a sequence of symbolic function names.
it has been shown in that context sensitive event logging is critical for event reduction which speeds up execution replay by removing events in a replay log that are not relevant to producing a failure.
in that work context information was retrieved through expensive stack walks.
calling contexts have also been used to reverse engineer the format of program input in autoformat .
in aspect oriented programming properties of calling contexts may be used to precisely locate aspects and have been used to support gathering execution information for debugging and unit test generation .
context information has been shown to be very useful in testing sensor network applications in .
context encoding can also improve bug reporting.
the backtrace of a failure itself a context is a very useful component in a bug report.
with context encoding succinct bug reports can be generated.
moreover it is also possible to collect contexts of additional execution points besides the failure point.
for programs without symbolic information for the sake of intellectual property protection context encoding provides a way to anonymously represent contexts and allows them to be decoded at the developers site.
context sensitive profiling is very important to program optimization .
it annotates program profiles such as execution frequencies dependences and object life times with context information.
stack walking is too expensive when profile information is generated at a high frequency.
context sensitive optimizations often specify how programs should behave in various contexts to achieve efficiency.
for example region based memory management tries to cluster memory allocations into large chunks called regions so that they can be explicitly managed context sensitive region based memory management specifies in which region an allocation should be performed under various contexts.
525such analyses need to disambiguate the different contexts reaching a program point at runtime to decide if the current context is one of those specified.
context encoding is highly desirable in this case.
realizing the importance of context encoding in recent years a few encoding methods have been proposed.
in a technique is proposed to instrument call sites to cumulatively compute a hash of the function and line number containing the call site.
the same encoding is guaranteed to be produced if the same context is encountered because the hash function is applied over the same data in the same order.
the technique lacks a decoding component meaning the context cannot be directly decoded from the computed hash.
note that such capability is essential to applications that require inspecting and understanding contexts.
moreover different contexts may have the same encoding.
in an approach is proposed to change stack frame sizes by allocating extra space on stack frames such that the stack offset which is essentially the aggregation of stack frame sizes disambiguates the contexts.
this approach is not safe either especially in the presence of recursion.
the reason is that the number of stack frames at runtime could be arbitrary such that the aggregated size cannot be statically analyzed or safely profiled.
hence the extra space on individual stack frames cannot be safely determined.
the technique relies on offline training to generate a decoding dictionary.
both the inherent imprecision and incompleteness in the training set may lead to failure of decoding.
the reported failure rate could be as high as .
in this paper we leverage the ball larus bl control flow encoding algorithm to solve the context encoding problem.
the scenario of encoding contexts has different constraints such that a more efficient algorithm can be devised.
the basic idea is to instrument function calls with additions to an integer id such that the value of the id uniquely identifies contexts.
our algorithm is safe uniquely identifying different contexts.
it can precisely recover a context from its encoding.
it has low overhead and handles function pointers stack allocations recursion and so on.
our main contributions are summarized as follows.
we leverage the bl algorithm to encode acyclic contexts.
the algorithm is more efficient as it exploits the unique characteristics of calling context encoding.
we propose an algorithm to encode recursive contexts.
recursive contexts are divided into acyclic sub sequences that are encoded independently.
the sub sequence encodings are stored to a stack.
a featherweight generic compression further reduces the stack depth.
we propose an algorithm to safely leverage stack depths to disambiguate contexts.
instead of allocating extra space on stack to distinguish contexts we use our acyclic encoding algorithm in a lazy fashion meaning that we apply it to contexts that cannot be safely disambiguated through stack offsets.
we have a publicly available prototype implementation .
we evaluate it on a set of spec benchmarks and other large real world benchmarks.
our experiments show that our technique has very low overhead .
on average and it can encode all contexts of most medium sized programs with just one bits integer.
for large programs it can encode most runtime contexts with a few numbers.
.
motivation g76 g73 g83 g86 g86 g76 g73 g83 g86 g40 g81 g87 g85 g92 g40 g91 g76 g87 g76 g71 g32 g76 g71 g32 g76 g71 g32 g76 g73 g83 g86 g72 g79 g86 g72 g86 g76 g73 g83 g86 g72 g79 g86 g72 g86 g83 g68 g87 g75 g76 g71 g86 figure example for ball larus path encoding.
instrumentation is marked on control flow edges.
node annotations rounded boxes at the corners represent the number of paths starting from the annotated point.
background ball larus path encoding.
in the seminal paper ball and larus proposed an efficient algorithm referred to as the bl algorithm to encode intra procedural control flow paths taken during execution.
the basic bl algorithm translates an acyclic path encoding into instrumentation on control flow edges.
at runtime a sequence of instrumentation is executed following a control flow path resulting in the path identifier being computed.
all instrumentation involves only simple additions.
the idea can be illustrated by the example in fig.
.
the code is shown on the left and the control flow graph is shown on the right.
instrumentation is marked on control flow edges.
before the first statement idis initialized to .
if the false branch is taken at line idis incremented by .
if the false branch is taken at line idis incremented by .
as shown on bottom left executions taking different paths lead to different values inid.s i m p l y idencodes the path.
the algorithm first computes the number of paths leading from a node to the end of the procedure.
for example node has four paths reaching exit.
such numbers are annotated as rounded boxes in fig.
.
given a node with npaths the instrumentation from the node to exitgenerates ids falling into the range of n to denote the paths.
for instance the instrumentation in fig.
generates paths with ids in .
in particular the instrumentation on separates the range into two sub ranges and denoting the paths following edges 2a n d1 respectively.
the instrumentation on further separates the two paths from to exit.
more details about the bl algorithm can be found in .
the algorithm has become canonical in control flow encoding and been widely used in many applications .
inadequacy of bl for context encoding.
although the bl algorithm is very efficient at encoding control flow paths we observe that it is inadequate for encoding calling contexts which are essentially paths in a call graph.
consider the example in fig.
.
the code is shown on the left.
figures b and c show the call graph with two encoding schemes.
the bl encoding is presented in b and c shows more efficient encoding.
nodes in a call graph represent functions and edges represent function calls.
bl encoding is designed to encode statement granularity paths g76 g81 g87 g38 g94 g39 g171 g96 g76 g81 g87 g39 g94 g40 g41 g96 g76 g81 g87 g36 g94 g37 g38 g96 g76 g81 g87 g37 g94 g171 g39 g96 g36 g37 g38 g39 g40 g41 g76 g71 g32 g76 g71 g32 g76 g71 g32 g70 g82 g81 g87 g72 g91 g87 g76 g71 g36 g37 g39 g40 g36 g37 g39 g41 g36 g38 g39 g40 g36 g38 g39 g41 g171 g171 g36 g37 g38 g39 g40 g41 g76 g71 g32 g76 g71 g32 g70 g82 g81 g87 g72 g91 g87 g76 g71 g36 g37 g39 g40 g36 g38 g39 g40 g36 g37 g39 g41 g36 g38 g39 g41 g36 g37 g39 g36 g38 g39 g36 g37 g36 g38 g36 g68 g38 g82 g71 g72 g69 g37 g47 g72 g81 g70 g82 g71 g76 g81 g74 g70 g50 g88 g85 g72 g81 g70 g82 g71 g76 g81 g74 figure the inadequacy of the bl algorithm for encoding contexts.
g81 g83 g83 g80 g83 g80 g68 g76 g81 g76 g71 g32 g81 g88 g80 g38 g38 g83 g81 g88 g80 g38 g38 g81 g32 g520 g81 g88 g80 g38 g38 g83 g76 g76 g32 g171 g80 g76 g32 g171 g80 g76 g71 g32 g520 g81 g88 g80 g38 g38 g83 g76 figure intuition of our algorithm.
leading from the entry of a function to the end of it.
the criterion is that each of these paths has a unique encoding.
as shown in figure b all the paths leading from atoeor fhave different encodings.
however context encoding has a different criterion that is all unique paths leading from the root to a specific node have unique encodings because we only need to distinguish the different contexts with respect to that node.
in other words there are no constraints between the encodings of paths that end at different nodes.
it is fine if two paths that end at different nodes have the same encoding.
for example paths abdeand abdfhave the same encoding according to the scheme in c .
as a result although the encoding in figure c has less instrumentation on edges versus in b and requires a smaller encoding space the maximum id is versus in b it still clearly distinguishes the various contexts of any node.
our technique is based on the above observation.
it handles recursive calls and function pointers.
it also leverages stack offset namely the offset of the stack pointer regarding the stack base to achieve efficiency.
more important our algorithm is precise meaning it ensures that each context has a unique encoding and it allows decoding.
.
definitions definition .a call graph cg is a pair angbracketleftn e angbracketright.nis a set of nodes with each node representing a function.
eis a set of directed edges.
each edge e eis a triple angbracketleftn m lscript angbracketright i n which n m n represent a caller and callee respectively and lscriptrepresents a call site where ncallsm.
in the above definition of call graph call edges are modeled as a triple instead of a caller and callee pair because we want to model cases in which a caller may have multiple invocations of the callee.
definition .the calling context cc of a given function invocation m is a path in the cg leading from the root node to the node representing m. the context of an execution point can be computed by concatenating the context of its enclosing function invocation and the program counter pc of the point.
definition .a valid calling context encoding scheme is a function en cc zsuch that n n x y the ccs of n x negationslash y en x negationslash en y any encoding scheme that generates unique encodings i.e.
integer sequences zrepresents a sequence of integers for unique contexts of the same function is a valid encoding scheme.
for example a na ve but valid encoding scheme is to use the sequence of call site pcs to denote a context.
our research challenge is to devise a highly efficient valid encoding scheme which also allows precise decoding.
fig.
c presents an example of such a scheme.
.
encoding acyclic graphs in this section we introduce an algorithm to encode calling contexts that do not involve recursion.
the basic idea is illustrated in fig.
.
assume function numcc n r e p r e s e n t s the number of contexts of a node nsuch that numcc n p i ...mnumcc pi where for i p iare the parents of n. a critical invariant of our technique is that the numcc n contexts of nshould be encoded by the numbers in the range of numcc n .to do so the edge instrumentation should separate the range into mdisjoint subranges with numcc p1 representing the numcc p1 contexts along edge p1 n numcc p1 numcc p1 numcc p2 representing the numcc p2 contexts along p2 n a n d p j ... i numcc pj p j ...inumcc pj encoding the numcc pi paths along pi n. as shown in fig.
this can be achieved by instrumenting an edge pi n with id p j ... i numcc pj .
algorithm encoding for acyclic cgs.
annotate n e forn nin topological order do for each parent pofndo numcc numcc numcc instrument n e annotate n e forn ndo s for each e angbracketleftp n lscript angbracketrightinedo annotate ewith s insert id id sbefore lscript insert id id safter lscript s s numcc the algorithm is presented in algorithm .
it first computes the number of calling contexts for each node stored in numcc .
it then traverses each node nin the main loop in lines .
for each edge e angbracketleftp n lscript angbracketright the following instrumentation is added before the invocation at lscript the context identifier idis incremented by the sum sof the numcc so f g70 g82 g81 g87 g72 g91 g87 g76 g71 g36 g37 g45 g39 g41 g42 g36 g37 g36 g45 g36 g37 g39 g36 g45 g39 g36 g37 g40 g36 g37 g39 g41 g36 g45 g39 g41 g36 g37 g39 g41 g36 g45 g39 g41 g171 g44 g40 g43 figure example for acyclic encoding.
label c means id c is added before the invocation and id cis added after superscript ondis to disambiguate call sites.
g36 g37 g38 g39 g41 g42 g40 g43 g85 g72 g70 g88 g85 g86 g76 g82 g81 g36 g37 g38 g39 g41 g42 g40 g43 g39 g56 g48 g48 g60 g89 g82 g76 g71 g36 g171 g94 g37 g171 g171 g76 g71 g32 g38 g171 g76 g71 g32 g171 g96 g89 g82 g76 g71 g41 g171 g94 g90 g75 g76 g79 g72 g171 g94 g83 g88 g86 g75 g31 g76 g71 g79 g33 g76 g71 g32 g79 g38 g171 g76 g71 g32 g83 g82 g83 g73 g76 g85 g86 g87 g171 g96 g43 g171 g171 g96 g71 g88 g80 g80 g92 g72 g71 g74 g72 g68 g50 g85 g76 g74 g76 g81 g68 g79 g38 g68 g79 g79 g42 g85 g68 g83 g75 g69 g55 g85 g68 g81 g86 g73 g82 g85 g80 g72 g71 g42 g85 g68 g83 g75 g70 g44 g81 g86 g87 g85 g88 g80 g72 g81 g87 g68 g87 g76 g82 g81 figure example for encoding cyclic cgs.
all preceding callers after the invocation idis decremented by the same amount to restore its original value.
consider the example in fig.
.
node annotations i.e.
numbers in boxes are first computed.
in the first three steps of the topological traversal nodes a b a n d jare annotated with meaning these functions have only one context node d s annotation is the sum of those of band j denoting there are two possible contexts when dis called the remaining nodes are similarly annotated.
the program is instrumented based on the annotations.
consider the invocations to i which are from f g a n d j. the empty label on edge fimeans that the invocation is instrumented with id and id before and after the call respectively.
this instrumentation is optimized away.
the edge gihas the label meaning the instrumentation before and after comprises id and id .
note that is the annotation of f. similarly since the sum of the annotations of fand gare edge jihas the label .
other edges are similarly instrumented.
at runtime the instrumentation yields the encodings as shown in the table in fig.
.
in applications such as context sensitive profiling and context sensitive logging context ids are emitted as part of the profile.
in order to facilitate human inspection decoding is often needed.
the decoding algorithm is presented in algorithm .
the algorithm traverses from the given function in a bottom up fashion and recovers the context by comparing the encoding with edge annotations.
in particular at line the recovered context ccis initialized with the given functionm which is the leaf node of the final context.
lines compose the main process which terminates when the the root node is reached.
in the inner loop from lines to the algorithm traverses edges ending at the current function n. at line it tests if the encoding falls in the encoding range of the contexts along the current edge.
if so the edge is taken the caller pand the call site lscriptare attached to the recovered context at line .
symbol represents concatenation.
at line the encoding is updated by subtracting the edge annotation.
this essentially reverses one step of encoding.
the process continues by treating the caller as the new current function at line .
consider the example in fig.
.
assume the id is generated at function i. the algorithm starts from i.s i n c e en gi en gi numcc g the contextmust have followed the edge gi.
the edge is taken and the encoding is decremented by to the value .
at g s i n c e en jg en jg numcc j edge jgis taken.
finally edge ajis taken yielding the context ajgi.
algorithm decode a context id.
input the encoding id the function mat which the encoding was emitted the edge set e the edge annotations en.
output the explicit context cc.
decode id m e en cc m n m while n negationslash root do for each e angbracketleftp n lscript angbracketrightinedo ifen e id en e numcc then cc p lscript cc id id en e break n p .
encoding with recursion in the presence of recursion a context may be of unbounded length making encoding using a bounded number infeasible.
we propose to use a stack to encode contexts with recursion.
the basic idea is to encode the acyclic sub paths of a recursive context.
when a recursion occurs the current acyclic encoding is pushed to the stack and the following acyclic sub path is encoded with a new id.
the numbers on stack and the current id together represent the context.
in order to perform correct acyclic sub path encoding recursive cgs need to be transformed.
our solution is presented in algorithm .
the first step deals with cg transformation in annotaterecursive .
a dummy root node is introduced.
a dummy edge is introduced between the new root and the original root.
dummy edges are further introduced between the new root and any nodes that are the target of a back edge.
note that only one dummy edge is introduced even if there are multiple back edges to the same node.
a dummy edge is always the first edge in the edge set of a node.
in the transformed graph back edges are removed to allow acyclic encoding.
consider the example in fig.
.
the recursion fcis removed and dummy edges are introduced between the dummy root and the original root a as well as between the dummy root 528and the recursive edge target c. intuitively after transformation acyclic sub sequences of a recursive context become valid contexts in the transformed cg.
hence they can be taken into account in the annotation computation.
in fig.
b the dummy edge from dummy tocmakes the acyclic subpaths such as cdfandcgf become valid contexts and have unique encodings in the transformed graph.
note that paths that do not involve recursion such as acgfh are not divided into sub paths even if they contain a node that may be the target of a back edge such as cin this case.
the instrumentation algorithm is shown in function instrumentrecursive .
the instrumentation is performed on the original graph which may have back edges.
since the transformed graph shares the same node set as the original graph except the dummy root the acyclic node annotations on the transformed graph are also annotations on the original graph and hence used in instrumentation.
similar to the previous algorithm smaintains the sum of contexts of callers that precede the one being processed.
at line it is initialized to if the node could be a back edge target otherwise.
setting to respects the numbering caused by the dummy edge on the transformed graph.
lines handle non back edges and they are the same for acyclic graphs.
lines handle back edges.
specifically before a recursive invocation the current idand the call site are pushed to the stack and idi sr e s e tt o0 .
r e s e t t i n g idindicates that the algorithm starts to encode the next acyclic sub path.
after the invocation idis restored to its previous value.
fig.
c shows the instrumentation for functions a and f which are the callers of c. algorithm handling recursion.
description angbracketleftn prime e prime angbracketrightrepresents the transformed cg stack is the encoding stack.
annotaterecursive n e n prime dummy n e prime e angbracketleft dummy root angbracketright for each back edge e angbracketleftp n lscript angbracketrightinedo e prime e prime e e prime e prime angbracketleft dummy n angbracketright annotate n prime e prime instrumentrecursive n e annotaterecursive n e forn ndo s nhas a dummy edge in e prime ?
for each edge e angbracketleftp n lscript angbracketrightinedo ifeis not a back edge then insert id id sbefore lscript insert id id safter lscript s s numcc p else insert push angbracketleftid lscript angbracketright before lscript insert id 0before lscript insert id p o p .first after lscript decodestack id stack m e prime ene prime lscript while true do decode id m e prime ene prime wcc cc wcc ifstack.empty then break angbracketleftid lscript angbracketright stack.pop m the residence function of lscript consider the example context acgfcde .i ti se n c o d e da sa sub path with id on the stack and the current sub path id .
the encoding is pushed to the stack before fcalls c. after the idvalue is pushed it is reset to .
as a result taking the remaining path cdeleads to id .
assume the execution returns from e d c and then calls c d f a n d h yielding the context of acgfcdfh .
the context is encoded as on the stack and current id .
the decoding algorithm for recursive cgs is presented in function decodestack .
it takes the numbers on the stack the current sub path encoding and the current function as part of its inputs.
intuitively it decodes one acyclic subpath of the recursive context at a time until all encodings on the stack are decoded.
decoding an acyclic sub path is done by calling the acyclic decoding algorithm on the transformed graph at line .
the resulting acyclic sub path cc is concatenated with the whole recovered context wcc.a t line the call site label lscriptis used to identify the method in which the idwas pushed to the stack which is also the starting point of the next round of decoding.
consider an example.
assume we want to decode a context represented by the stack having an entry angbracketleft3 ftoc angbracketright t h e current id and the current function e. after the first iteration i.e.
decode e ... the sub path cdeis decoded.
function fis decided as the starting point of the next round of decoding according to the call site on the stack.
after the round the value on the stack is decoded to the sub path acgf.
the two sub paths constitute the context.
our design can easily handle very deep contexts caused by highly repetitive recursive calls.
in such cases contexts are a string with repetitive substring patterns such as acgf cgf cgf cgf ... in fig.
.
such redundancy is not directly removable without relatively expensive compression.
with encoding the repetitive patterns are encoded into repetitive integers and can be further encoded as a pair of id and frequency.
the above context can be encoded to two pairs 1a n d2 w i t ht h ef o r m e rr e p r e s e n t i n g acgfand the latter representing the three repetitions of cgf.
.
safe hybrid encoding leveraging stack offsets the encoding algorithms we have discussed so far explicitly produce a unique id for each calling context.
we call themexplicit encoding techniques.
at runtime it is often the case that the stack offset namely the value of the current stack pointer subtracted by the base of the entire stack can disambiguate the current context.
consider the example in fig.
c .
previously updates to idhad to be inserted on edge cdto distinguish the two contexts of d. let the stack offset at the entry of din the context of abdbexand the offset in the context of acdbey.i fxdoes not equal y the two contexts can be disambiguated without any explicit encoding.
we call such stack offset based encoding implicit encoding as explicit instrumentation is not needed.
in reality a few factors make applying implicit encoding difficult.
first of all there may be multiple contexts that alias to the same implicit encoding i.e.
they have the same stack offset.
consider the example in fig.
.
the two contexts abd1fand abd2fmay have the same stack offset because the same sequence of functions are called.
second programming languages such as c c allow declaring variable size local arrays.
gccallocates such arrays on g59 g60 g61 g179 g76 g71 g32 g180 g59 g60 g61 g179 g76 g73 g76 g71 g76 g71 g32 g180 g59 g60 g61 g179 g180 g44 g80 g38 g38 g59 g32 g94 g38 g314 g96 g44 g80 g38 g38 g60 g32 g94 g38 g314 g96 g68 g32 g32 g44 g80 g38 g38 g61 g32 g94 g38 g404 g61 g314 g96 g44 g80 g38 g38 g59 g32 g94 g38 g314 g96 g44 g80 g38 g38 g60 g32 g94 g38 g314 g96 g69 g32 g95 g44 g80 g38 g38 g59 g60 g95 g32 g32 g81 g88 g80 g38 g38 g59 g60 g44 g80 g38 g38 g61 g32 g94 g38 g404 g61 g314 g38 g404 g61 g314 g96 g44 g80 g38 g38 g61 g32 g94 g38 g404 g61 g314 g38 g404 g61 g314 g96 g44 g80 g38 g38 g59 g32 g94 g38 g314 g96 g44 g80 g38 g38 g60 g32 g94 g38 g314 g96 g70 g32 g95 g44 g80 g38 g38 g60 g95 g32 g81 g88 g80 g38 g38 g60 figure intuition of hybrid encoding.
g70 g82 g81 g87 g72 g91 g87 g82 g73 g73 g86 g72 g87 g36 g37 g45 g39 g41 g42 g36 g37 g39 g41 g44 g36 g45 g39 g41 g44 g36 g37 g39 g41 g44 g36 g45 g39 g41 g44 g36 g37 g39 g42 g44 g36 g45 g39 g42 g44 g36 g45 g42 g44 g36 g45 g44 g36 g37 g39 g42 g36 g45 g39 g42 g36 g45 g42 g44 g40 g43 g179 g180 g179 g180 g179 g76 g73 g76 g71 g180 g70 g82 g81 g87 g72 g91 g87 g82 g73 g73 g86 g72 g87 g36 g37 g39 g36 g45 g39 g36 g37 g39 g41 g36 g45 g39 g41 g36 g37 g39 g42 g36 g45 g39 g42 g36 g37 g39 g41 g44 g36 g45 g39 g41 g44 g36 g37 g39 g42 g44 g36 g45 g39 g42 g44 g36 g45 g44 g81 g82 g71 g72 g44 g80 g38 g38 g39 g41 g42 g44 g76 g71 g69 g49 g72 g90 g72 g81 g70 g82 g71 g76 g81 g74 g86 g70 g75 g72 g80 g72 g68 g44 g80 g83 g79 g76 g70 g76 g87 g70 g82 g81 g87 g72 g91 g87 g86 g70 g38 g82 g81 g87 g72 g91 g87 g72 g81 g70 g82 g71 g76 g81 g74 g86 figure example of hybrid encoding.
edge instrumentations are quoted and stack frame offsets are not.
stack.
stack allocations make stack offsets variable and hence implicit encoding is infeasible.
third in the presence of recursion stack offsets cannot be statically reasoned about which makes it inapplicable.
in order to address the aforementioned issues we propose a hybrid encoding algorithm that performs explicit encoding when implicit encoding is not applicable.
the algorithm is safe meaning that it uniquely encodes each possible context.
the intuition of the hybrid algorithm is presented in fig.
.
besides the number of contexts each node is also annotated with a set of implicit contexts denoted as imcc which represents a set of contexts of the node having distinct and fixed stack offsets.
it is a mapping from contexts to their offsets.
for instance the implicit context set of node xin fig.
contains context c1and its stack offset symbol mapsto represents the maps to relation .
each edge is annotated with two pieces of information.
the first piece is the stack frame offset which is the difference between the stack pointer and the base of the current stack frame when the invocation denoted by the edge occurs.
the stack offset of a context can be computed by aggregating the edge offsets along the context.
the second annotation is the instrumentation which is quoted.
symbol represents concatenation.
the figure presents three cases.
in case a the two implicit contexts of zhave a conflicting offset namely .
we cannot implicitly encode both.
in such a case we implicitly encode the context along edge xzand explicitly encode that from yz.h e n c e imcc zis set to contain the context from edge xzandidis increased by numcc x along edge yz.
the instrumentation has the same effect of separating the encoding space as in previous algorithms.
in case b the two implicit contexts do not conflict and all contexts of xand ycan be implicitly encoded implied by the sub condition imcc x y numcc x y .
in such a case no explicit encoding is needed and the imcc set ofzcontains both.
in case c the two implicit contexts of zdo not conflict but the contexts of yare heterogeneously encoded denoted by imcc y negationslash numcc y .
it implies thatidmay be non zero at y depending on the context at runtime.
if idis not zero explicit encoding must have been used and the new context of zshould be explicitly encoded.
hence idis increased by numcc x .i f idis zero the context of yis one of the contexts in imcc y. because the corresponding context of zdoes not have conflicts and can be implicitly encoded no update to idis needed.
the above logic is realized by the guarded instrumentation on edge yz in fig.
c .
the algorithm is presented in algorithm .
variable imcc represents the set of contexts that are implicitly encoded for each node.
function extend imcc n extends the implicit contexts in imcc along the invocation p n. this is done by concatenating nto the contexts in imcc and increasing the corresponding stack offsets by the stack frame offset of p n. function conflict imcc x imcc y tests if two implicit context sets conflict.
this is done by checking if there are two contexts in the two respective sets alias to the same stack offset.
the instrumentation algorithm is described in function instrument .
here we only present the algorithm for acyclic graphs.
the extension to recursion can be achieved in a way similar to explicit encoding and hence omitted.
the algorithm traverses the nodes in the topological order.
it first resets the imcc for the current node nat line .
it then traverses the set of invocations to n denoted by edges of the form angbracketleftp n lscript angbracketright w i t h pthe caller and lscriptthe call site.
it extends imcc t onat line and then tests if the extended set conflicts with the implicit contexts of nthat have been computed so far.
if there is no conflict the extended set is admitted and aggregated to the implicit set of nat line .
line checks if all contexts of pare implicit.
if so the afore530algorithm hybrid encoding.
definitions imcc an array of implicit contexts indexed by nodes extend imcc n c n mapsto t offset p n c mapsto t imcc in which offset p n is the stack frame offset of the call to ninp.
conflict imcc x imcc y j c1 mapsto t imcc x c2 mapsto t imcc y 0otherwise instrument n e forn nin topological order do imcc s for each edge e angbracketleftp n lscript angbracketrightinedo imcc prime extend imcc n ifnotconflict imcc imcc prime then imcc imcc imcc prime if imcc negationslash numcc then case c in fig.
otherwise case b replace the call lscript n ... inpwith if id id id s n ... id id s elsen ... else case a insert id id sbefore lscript insert id id safter lscript s s numcc mentioned case b in fig.
is encountered.
there is no need to instrument the invocation.
if not case c is encountered namely the contexts of pmay be explicitly encoded.
hence the instrumentation should decide at runtime if the context has been explicitly encoded.
if so the instrumentation will continue to perform explicit encoding as shown by the boxes in lines .
if the extended implicit set incurs conflict case a is encountered.
in lines the edge is explicitly encoded.
encoding example.
consider the earlier example in fig.
.
fig.
b shows the graph with stack frame offset annotations and instrumentation quoted .
for instance when bis called inside a the stack frame offset is when dis called inside b the frame offset is .
hence the stack offset of the context abdis the sum of the two which is .
similarly the stack offset of ajdis .
the two different offsets disambiguate the two contexts and thus the implicit context set of d as shown in fig.
a contains both contexts.
no instrumentation is needed.
now let us consider f. when the first edge is processed extend imcc f is computed as abd1f mapsto ajd1f mapsto at line and it is assigned to imcc a tl i n e8 .w h e n the second edge is processed extend imcc f is computed as abd2f mapsto ajd2f mapsto .
the conflict test at line fails so imcc f only contains the set extended along the edge d1f as shown in fig.
a .
moreover the algorithm instruments the edge d2faccording to lines .
when iis considered the extensions from imcc imcc andimcc do not conflict.
however contexts to gmay be explicitly encoded as imcc negationslash numcc .
the instrumentation has to be guarded as shown on the edgegi.
sample encodings can be found in fig.
c .
compared to the instrumentation in fig.
in which edges need to be instrumented with each instrumentation comprising one addition and one subtraction reads and writes the hybrid version instruments edges.
furthermore the instrumentation on edge gimay need just one read the read in the predicate .
decoding example.
the decoding algorithm is elided for brevity.
we will use examples to intuitively explain the idea.
the encoding of a context under the hybrid algorithm is a triple which comprises the stack offset the explicit id and the current function.
note that only the explicit id is computed by instrumentation the other two can be inferred at any execution point.
assume we are given the encoding of offset id and the current function g. the explicit encoding id means that the context is not explicitly encoded and can be looked up from the imcc set.
from imcc we recover the context as ajdg.
assume we are given the encoding offset id 6a n d the current function i. the nonzero explicit encoding means that explicit encoding is used.
from the encoding graph in fig.
b we know that explicit ids at iin range represent contexts along the edge gi.
we reverse both the stack offset and the explicit encoding along this edge and getoffset 4a n d id .
the ids at gin range represent contexts along jg.
backtracking along the edge leads to offset 1a n d id .
now with id we know that the remaining part of the context can be looked up yielding aj.
here we recover the whole context ajgi.
.
handling practical issues handling insufficient encoding space.
since our technique uses a bit id it allows a function to have a maximum of 232different contexts.
we observe for some large programs a function may have more than 232contexts.
for example in gcc there are a few functions that are called by a few thousand other functions leading to an overflow in the encoding space.
in order to handle such cases we propose a selective reduction approach.
we use profiles to identify hot and cold call edges.
cold edges are replaced with dummy edges such that sub paths starting with these cold edges can be separately encoded.
as a result the overall encoding pressure is reduced.
at runtime extra pushes and pops are needed when the selected cold edges are taken.
handling function pointers.
if function pointers are used points to analysis is needed to identify the targets of invocations.
due to the conservative nature of points to analysis the possible targets may be many.
we employ a simple and safe solution.
we profile the set of targets for a function pointer invocation with a number of runs.
edges are introduced to represent these profiled targets and then instrumented normally.
during real executions if a callee is out of the profiled set push and pop are used.
handling setjmp longjmp.
setjmp allows a developer to mark a position in the calling context that a successive use of longjmp can then automatically return to unwinding the calling context to the marked point.
our approach safely handles such unwinding by detecting when a setjmp is encountered and storing a copy of the context stack height and current context identifier within the local variables of 531the function containing setjmp.
when longjmp unwinds the calling context these values are then safely restored from the local copies unwinding the context encoding as well.
handling stack allocations.
implicit encoding is not possible when stack allocation is used e.g.
when allocating a variable size array on the stack.
we use static analysis to identify all functions that have stack local allocation and prohibit implicit encoding for those functions.
.
evaluation we have implemented our approach in ocaml using the cil source to source instrumentation infrastructure .
the implementation has been made available on our project website .
all experiments were performed on an intel core .1ghz machine with 2gb ram and ubuntu .
.
note that because we use source level analyses for our implementation we do not have as much information as would be available were the analysis within the actual compilation phase.
in particular we don t know if the compiler eventually inlines a function resulting in indistinguishable stack frame sizes.
hence we disabled inlining during our experiments.
observe that this is not a limitation of our algorithm but rather an outcome of our infrastructure selection.
an implementation inside a compiler after functions are inlined can easily handle the issue.
table presents the static characteristics of the programs we use.
since cil only supports c programs our implementation currently supports c programs.
we use specint benchmarks and a set of open source programs.
some of them are large such as .gcc alpine a n d vim.
three specint programs .eon .gap and253.perlbmk are not included because cil failed to compile them due to their use of c or unsupported types.
for each program the table also details lines of code loc the number of nodes in the call graph cg nodes the number of edges in the call graph cg edges the number of recursive calls or back edges in the call graph recursions the number of function pointer invocations and the maximum id required in the call graph under the original bl numbering scheme bl max id and our scheme our max id .
we can observe that most programs make use of recursion and function pointers.
in particular .gcc has recursive invocations and uses function pointers at places.
we are able to encode the contexts of all programs smaller than 100k loc in a bit id.
for the larger programs overflows are observed and selective reduction section is performed to reduce encoding pressure and fit the id into bits.
the numbers below the table show the number of nodes on which selective reduction is performed for each large programs.
observe the maximum id for the original bl encoding scheme is often a few times larger than ours.
fig.
illustrates the runtime overhead of our encoding algorithms.
we use reference inputs for spec programs and random inputs for the rest.
in particular we use training inputs to profile spec programs.
the runtime for alpine .0cannot be accurately measured as it is an interactive program.
the slow down is not humanly observable though.
the times for vimwere collected in batch mode.
we normalize the runtime of two encoding algorithms one is the basic algorithm that handles recursion and the other the hybrid algorithm.
from the figure we observe that our technique is very efficient the average overheads are .
and .
for the two respective algorithms.
the hybrid algorithm improves over the basic algorithm by .
.
.gcc and .vortex have relatively higher overhead due to the extra pushes and pops caused by selective reduction.
programsmax depth depth dynamic ours plain ours plain contexts cmp .
.
diff .
.
sdiff .
.
find .
.
locate .
.
grep .
.
tar .
make .
alpine .
vim .
.gzip .vpr .gcc .mcf .crafty .parser .vortex .bzip2 .twolf average .
.
.
.
table dynamic context characteristics.
table presents the dynamic properties.
the second and third columns compare our encoding stack depth ours to the plain calling stack depth plain i.e.
the call path length.
the third and fourth columns show the stack size needed to cover of contexts at runtime.
the last column presents the number of unique contexts encountered.
we observe that our maximum encoding stacks are substantially shorter than the corresponding maximum plain stacks.
for most utility programs the encoding stack is empty meaning the contexts can be encoded into one id without using the stack.
we also observe that some programs need maximum encoding stacks with a non trivial depth e.g.
.gcc .mcf .crafty and .parser .
however when we look at the cutoffs .gcc and .mcf require encoding stacks of depth and respectively.
to precisely evaluate our technique we also contrast the full frequency distributions for our encoding stacks and the corresponding plain stacks.
due to space limit we only present some of the results in fig.
.
each diagram corresponds to one of the benchmarks considered.
the x axis corresponds to stack depth and y axis shows the cumulative percentage of dynamic context instances during execution that can be represented in a given stack depth.
thus if a curve ascends to very quickly it means that most contexts for that benchmark could be stored with a small encoding stack possibly even size zero.
the graph for .gzip is very typical for medium sized programs.
our stack is always empty while the plain stack gradually ascends.
observe the diagram of .gcc .
even though the maximum encoding stack has the size of our curve quickly ascends over the bar with the stack depth .
the diagrams for other large programs such as .vortex vimand alpine .
are similar.
finally the diagram of .parser shows that our technique is relatively less effective.
the reason is that parser implements a recursive descent parsing engine that makes intensive recursive calls based on the syntactic structure of input.
the recursion is mostly irregular so our simple compression does not help much.
.crafty is similar.
532table static program characteristics.
programs loc cg nodes cg edges recursions fun pointers our max id bl max id cmp .
.
diff .
.
sdiff .
.
find .
.
locate .
.
grep .
.
tar .
make .
alpine .
.5e vim .
.7e .gzip .vpr .gcc .1e .mcf .crafty .parser .vortex .5e .bzip2 .twolf selective reduction is applied to nodes in alpine .
in .gcc 3i n .vortex and in vim.
figure normalized runtime comparison of benchmarks with no instrumentation basic encoding instrumentation and the hybrid encoding instrumentation.
times are normalized against the native runtime.
.
related work explicit context encoding.
the most direct approach to identifying calling contexts is to explicitly record the entire call stack.
there are two main approaches for so.stack walking involves explicitly traversing the program stack whenever a context is requested in order to construct the full identifier for the context .
compared to our approach stack walking is more expensive and hence less desirable.
maintaining the calling context tree involves explicitly unfolding a cg into a tree at runtime with each tree path representing a context.
tree nodes are allocated and maintained on the fly.
the current position in the tree is maintained by a traversal action at each call site.
while call trees are very useful in profiling our technique is more general as it provides more succinct representation of contexts and has less overhead.
moreover our encoding technique is complementary to call trees because a compressed tree can be constructed using encoding by denoting tree sub paths as individual nodes.
path encoding.
in ball and larus developed an algorithm to encode control flow paths.
our technique is inspired from theirs.
in comparison our algorithm is more compact for context encoding as it encodes in a different backward direction.
the bl algorithm breaks loop paths at control flow back edges and our algorithm similarly separates recursive contexts into acyclic subsequences and encode independently.
however due to the characteristics of contexts our recursive encoding relies on a stack.
furthermore we safelyleverage stack offset to remove unnecessary encodings.
in the bl algorithm was extended to encode control flow paths across function boundaries.
in it was proposed that the bl algorithm can be used to encode calling contexts.
however the approach was not fully developed.
it does not encode decode recursive contexts and it was not implemented.
in edge profiles are used to avoid considering cold paths and to infer paths without numbering where possible.
if only a subset of paths are known to be of interest uses this information to construct minimal identifiers for the interesting paths while allowing uninteresting paths to share identifiers when advantageous.
similar to these approaches our technique uses profiling to guide instrumentation improve efficiency and reduce encoding space pressure.
if it were known that only a subset of calling contexts were of interest we could further reduce both our instrumentation and identifier size but we leave this open as future work.
probabilistic contexts.
it may be acceptable that context identifiers are not unique.
that is some arbitrary contexts may be merged with low probability.
in such scenarios probabilistic calling contexts c a nb eu s e dt ov e r ye f ficiently identify calling contexts with high probability of unique identifiers.
in calling contexts are hashed to numeric identifiers via hashes computed at each function call.
decoding is not supported in this technique.
more recently uses the height of the call stack to identify calling contexts and mutates the size of stack frames to differentiate conflicting stack heights with empirically high probability.
533figure context encoding stack size distributions our approach also uses the height of the call stack to disambiguate calling contexts but in contrast we only use it to eliminate instrumentation and path numbering where it can be shown that it is safe to do so.
their decoding is achieved by offline dictionary lookup.
the dictionary is generated through training and hence the actual calling contexts cannot always be decoded.
in contrast our approach guarantees safety and easy decoding.
furthermore their approach is unsafe with stack allocation.
sampling based profiling.
in adaptive sampling is used to guide context sensitive profiling thus reducing the number of times contexts are even needed.
while this is useful when performing hot context profiling it does not generalize to other uses of contexts where coverage guarantees are important.
.
conclusions we propose a technique that encodes the current calling context at any point during execution.
it encodes an acyclic call path into a number and divides a recursive path into sub sequences to encode them independently.
it leverages stack depth to remove unnecessary encoding.
the technique guarantees different contexts have different ids and a context can be decoded from its id.
our results show that the technique is highly efficient with .
overhead on average.
it is also highly effective encoding contexts of most medium sized programs into just one number and those of large programs in a few numbers in most cases.
.
acknowledgement we thank the anonymous reviewers for their insightful comments.
we are grateful to ben wiedermann for his feedback on early drafts.
this research is supported in part by the national science foundation nsf under grants and .
any opinions findings conclusions or recommendations in this paper are those of the authors and do not necessarily reflect the views of nsf.
.