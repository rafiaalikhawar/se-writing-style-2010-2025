how we get there a context guided search strategy in concolic testing hyunmin seo and sunghun kim department of computer science and engineering the hong kong university of science and technology hong kong china hmseo hunkim cse.ust.hk abstract one of the biggest challenges in concolic testing an automatic test generation technique is its huge search space.
concolic testing generates next inputs by selecting branches from previous execution paths.
however a large number of candidate branches makes a simple exhaustive search infeasible which often leads to poor test coverage.
several search strategies have been proposed to explore high priority branches only.
each strategy applies di erent criteria to the branch selection process but most do not consider context how we got to the branch in the selection process.
in this paper we introduce a context guided search cgs strategy.
cgs looks at preceding branches in execution paths and selects a branch in a new context for the next input.
we evaluate cgs with two publicly available concolic testing tools crest and carfast on six c subjects and six java subjects.
the experimental results show that cgs achieves the highest coverage of all twelve subjects and reaches a target coverage with a much smaller number of iterations on most subjects than other strategies.
categories and subject descriptors d. .
testing and debugging general terms reliability veri cation keywords concolic testing symbolic execution search strategies .
introduction recently an automatic test generation technique called concolic testing or directed automated random testing dart has received much attention due to its low false positives and high code coverage .
concolic testing runs a subject program with a random or user provided input vector then it generates additional input vectors by analysing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.previous execution paths .
speci cally concolic testing selects one of the branches in a previous execution path and generates a new input vector to steer the next execution toward the opposite branch of the selected branch.
by carefully selecting branches for the new inputs concolic testing can avoid generating redundant inputs for the same path and achieve high code coverage.
however the huge search space is one of the biggest challenges in concolic testing .
the search space in concolic testing is the branches in the execution paths.
to generate the next input concolic testing has to select one branch among a large number of candidate branches.
as concolic testing proceeds by generating more input vectors the search space gets even bigger as more branches are added from new execution paths.
given a limited testing budget exploring all branches even for a medium sized application is not practical .
to alleviate the search space challenge search heuristics or search strategies have been proposed .
instead of exploring all branches in the candidate list search heuristics prioritise branches according to some criteria and only explore high priority branches.
for example the carfast strategy always selects a branch whose opposite branch is not yet covered and has the highest number of statements control dependent on that branch .
the cfg strategy calculates the distance from the branches in an execution path to any of the uncovered statements and selects a branch that has the minimum distance rst .
the generational strategy measures the incremental coverage gain of each branch in an execution path and guides the search by expanding the branch with the highest coverage gain .
however most strategies do not consider how an execution reaches a branch in the branch selection criterion even though covering the branch may depend on this information.
figure shows an example code snippet consisting of three conditional statements with three possible execution paths over the cfg control flow graph of the code.
each diamond in the cfg represents a conditional statement and the left and right edges correspond to the true and false branches of the conditional.
selecting b6from 1to generate the next input to cover b5is unsuccessful because b4 the branch taken right before b6 sets a constraint such that total is less than .
however total must be bigger than or equal to to cover b5.
this introduces con ict between the two constraints total total .
as a result concolic testing gets an unsat result from the smt solver and cannot generate an input vector.
this is the same for .
however if b6was selected from concolic testing... if member level prime shipping fast b1 else shipping slow b2 if total disc get disc total b3 else disc b4 if total t total disc points get points t b5 else points b6 ... b 1 a b4 b2 b6 b3 b1 b5 2 b4 b2 b6 b3 b1 b5 3 b4 b2 b6 b3 b1 b5 d c figure an example code snippet consisting of three conditional statements and three execution paths over the cfg.
the left and right branches in the cfg correspond to trueand false branches respectively.
could generate an input vector for b5because 3has taken b3and the constraint for b3 total does not con ict with the constraint for b5 total .
oftentimes branches in a program have dependencies on other branches.
in figure b5has a dependency on b3such thatb5can only be covered from the execution paths taking b3.
selecting branches by considering their context how the execution reached the branches can help cover such branches.
for example after selecting b6in 1and getting an unsat result we can see that 1has takenb4before it came tob6.
there are two more execution paths 2and which also go through b6 but they have a di erent context for b6 2has takenb4but 3has takenb3before they came to b6 .
then we can select b6in 3instead of selecting b6in because we have already selected a branch having the same context asb6in .
in this paper we introduce the context guided search cgs strategy in which the search is guided by the context of branches.
cgs selects a branch under a newcontext for the next input.
we de ne the context of bas a sequence of preceding branches in the execution path.
in addition cgs excludes irrelevant branches in the context information by calculating dominators of branches.
we implement the cgs strategy on two publicly available concolic testing tools crest and carfast and evaluate them on six c subjects and six java subjects.
the evaluation results show that cgs achieves a higher coverage than any other strategy used in the evaluation on all twelve subjects.
in addition cgs achieves such coverage with a much smaller number of iterations than other strategies.
our paper makes the following contributions use of context information in branch selection we look at how an execution reached bin the branch selection process.
irrelevant branches are excluded in the context information by analysing the static structure of the program.
level based cgs strategy we consider preceding branches located close to bas more important than preceding branches located far from b and de ne di erent levels of context.
in addition we incrementally increase the consideration level of the context.
evaluation on six c subjects six java subjects we evaluate cgs on two publicly available concolic testing tools on six c subjects and six java subjects.the remainder of the paper is organised as follows.
section introduces concolic testing and describes several representative search strategies found in the literature.
we explain cgs in section .
section shows the evaluation plan and the experimental results are shown in section .
related work is described in section and we conclude this paper in section .
.
preliminary this section describes concolic testing and its search space challenge.
in addition we introduce several representative search strategies proposed to address the challenge in the literature.
.
concolic testing concolic testing or directed automated random testing dart is an automatic test generation technique based on symbolic execution.
the key idea behind symbolic execution is to represent program variables with symbolic values instead of concrete values.
symbolic execution maintains a symbolic memory state which is a mapping from program variables to symbolic expressions and a symbolic path constraint pc which is a conjunction of conditions collected at each conditional statement along an execution path .
initially symbolic execution starts with an empty mapping as and true aspc1.
for each input variable v a symbolic value s0is introduced into the mapping fv7!s0g.
the symbolic memory state is updated at each assignment statement by representing variables in the program as symbolic expressions over the symbolic values.
for example after executing w v under the current memory state offv7!s0g the memory state is updated to fv7!s0 w7!
2s0g.
when a conditional statement if e s1 else s2 is executed the symbolic execution follows both branches by forking another symbolic execution.
the condition eis evaluated under the current symbolic memory state as e and pcis updated as pc e for the execution taking the true branch and pc e for the execution taking the false branch.
when the symbolic execution reaches the end of the program concrete input vectors for each execution path can be generated by solving the collected pcwith an smt solver.
concolic testing performs symbolic execution dynamically by running the target program with a concrete input vector and performing symbolic execution along the execution path of the input.
after nishing the symbolic execution thepcconsists of the symbolic constraints at each conditional statement encountered along the execution path pc pc1 pc2 pcn .
each pcicorresponds to either the true orfalse branch taken at the i th conditional statement.
concolic testing selects apci or the corresponding branch and formulates a new path constraint by negating pciwhile maintaining the same pcjfor j i pc0 pc1 pc2 pci .
the newpc0represents an execution path taking the exact same branches as the previous execution path until pci however it takes the opposite branch at pci.
a new input vector for this execution path is generated by solving pc0 with an smt solver.
1we explain symbolic execution following the terms and notations used in .b1 b3 b5 b7 b6 b8 2 1 b1 b3 b5 b7 b6 b8 2 1 b4 b11 b12 3 b c 1 b1 b3 b5 b7 a b9 b9 b10 b9 b10 b13 figure concolic testing selects a branch for the next input.
the new execution paths are added to build the execution tree.
concolic testing runs the target program with the newly generated input vector and performs symbolic execution again along the new execution path.
if pc0is unsatis able the smt solver returns an unsat result and concolic testing selects a di erent pc.
this process repeats for a given number of iterations or until a target coverage goal is achieved.
one of the key bene ts of concolic testing over pure symbolic execution is that concolic testing can use concrete values to overcome the limitations of symbolic execution .
for example when a pccontains complex constraints such as non linear expressions or oating point operations of which smt solvers cannot deal with e ciently concolic testing can simplify the constraints with concrete values to solve it.
even though this concretisation may introduce imprecision it allows concolic testing to generate input values where symbolic execution may not .
.
search space in concolic testing the execution paths explored in concolic testing form a tree.
figure shows three execution paths building a tree up.
the set of all feasible execution paths is called an execution tree .
concolic testing can be viewed as building the complete execution tree starting from an initial execution path.
the search space in concolic testing is the branches in the current execution tree.
the branch selected for the next input determines which path to add to the tree.
if all branches are chosen without missing any branch concolic testing eventually builds the complete execution tree.
one of the biggest challenges in concolic testing is that there are often too many branches to select for the next input.
this is referred to as the path explosion problem .
the number of paths in the execution tree increases exponentially with the number of branches in the program.
visiting only the top twenty branches in the execution tree in a breadth rst search bfs order requires more than one million concolic runs .
however programs usually have far more than twenty branches for example an execution path of grep a 15k line of code program contains more than branches.
therefore exploring all paths in an execution tree in a reasonable amount of time is not feasible.
to mitigate this challenge search heuristics or search strategies have been proposed .
instead of exploring all branches in an execution tree search strategies prioritise some branches and only explore those high priority branches.
algorithm shows a generic search strategy .
the algorithm starts with an initial execution path as the execution tree line .
a branch is selected from the currently built execution tree t line .
if there is an input vectoralgorithm generic search strategy input a target program pand an execution path p output a set of test input and coverage information 1t p initialise execution tree with p 2while termination conditions are not met do b pick a branch from t p get execution path of bfrom t if9ithat forces ptoward b0 balong pthen q concolicrun p i addqtot end if 9end while guiding the execution toward the opposite branch of the selected branch line the program is run concolically with the new input line and the new path is added to t line .
the algorithm repeats till the termination conditions are met line .
in general the algorithm terminates when a coverage goal is achieved or a given testing budget is reached.
search strategies decide which branch to choose in line .
.
search strategies in this section we introduce several representative search strategies which are trying to improve coverage in general in the literature.
search strategies focusing on covering speci c branches are introduced in section .
.
.
dfs and bfs a typical tree traversal algorithm such as dfs has been used to explore an execution tree .
however the dfs strategy has several limitations.
first when the program contains a loop or recursion whose termination condition is dependent on symbolic input dfs may be trapped in the loop or recursion by continuously generating input vectors which only increase the number of iterations of the loop or recursion during the execution.
bounding the depth is one way to overcome this problem .
however the maximum depth is set arbitrarily and the branches located beyond the maximum depth cannot be selected using this approach.
in addition since it selects branches in the increasing order of depth generating input vectors becomes harder as the depth increases as the number of involved constraints also increases.
the breadth rst search bfs strategy traverses the execution tree according to a bfs order.
the bfs strategy prefers branches that appear early in the execution paths therefore generating new input vectors is easier because a smaller number of constraints will be involved for those branches.
on the other hand branches that only appear later in the execution path have little chance of being selected during a given testing budget.
in theory both dfs and bfs strategies can cover all execution paths in the execution tree.
however as described in the previous section real world programs have a non trivial number of execution paths and neither strategy scales to even medium sized programs .
in practice both strategies may end up with a skewed search area as shown in figure 3a and 3b which may result in low coverage.
.
.
random search to overcome the skewed search area limitation random strategies have been proposed to provide a scattered search area as in figure 3c.
uniform random search traverses the a dfs b bfs c random or heuristic based search figure the search area of each strategy.
the large coloured triangle represents the execution tree.
dfs and bfs have a skewed search area and random or heuristic based strategies have a scattered search area.
execution tree from the root and randomly selects a branch to follow .
for example at the rst branch in the initial execution path it ips a coin.
if the result is heads it follows the current execution path and moves onto the second branch.
if the result is tails it tries to follow the opposite branch by generating an input vector for that branch.
it then moves onto the next branch in the new execution path.
the strategy repeats this process by ipping a coin at the next branch it visits.
instead of traversing the execution tree randomly random branch search selects a branch randomly from the last execution path only.
after executing the program with a new input vector the strategy selects another branch randomly from the new execution path.
evaluation results show that random branch search is more e ective than uniform random search or dfs .
even though random strategies have shown better coverage than dfs covering new branches relies on randomness.
.
.
carfast to improve the coverage further strategies exploiting coverage information have been introduced.
carfast is a prioritised greedy strategy.
a greedy strategy always selects a branch whose opposite branch is not yet covered so that additional coverage gain is achieved with the new input vector.
in addition carfast prioritises those branches according to a score value which is the expected number of statements coverable when the branch is selected.
this is measured by calculating the number of statements transitively control dependent on each branch.
carfast strategy selects a branch whose opposite branch has the highest score value and is not yet covered.
.
.
cfg directed search cfg directed search combines the coverage information with the static structure of the program to guide the search .
for each branch in an execution path it calculates the distance from the opposite branch to any of the currently uncovered statements.
the distance is measured by the summation of the weight of the shortest path in the control ow graph cfg after assigning each branch edge weight one and all other edges weight zero.
the strategy selects a branch with the minimum distance rst.
the intuition behind this approach is that an uncovered statement located close to the current execution path is easier to cover than a branch located far from the current path.
.
.
generational search generational search uses the incremental coverage gain of each branch to guide the search.
it is a strategy used insage a white box fuzz testing tool based on dynamic symbolic execution .
instead of selecting only one branch for the next input generational search selects all the branches in an execution path and generates a set of input vectors.
these inputs become a generation .
the program under test is run with each of the new input vectors and the incremental coverage gain is measured for each input.
the execution path of the input with the largest coverage gain is chosen for the next generation.
again all the branches in the new execution path are selected and the newly generated input vectors become the next generation.
generational search repeats this process by selecting an execution path with the largest coverage gain.
.
limitations due to the path explosion dfs and bfs cannot search the whole space within the limited testing budget and may end up with a skewed search area.
branches located within the search area may be selected several times while branches only located outside the search area may not be selected.
this typically results in low coverage.
random strategies have scattered search areas but the branch selection relies on randomness.
a greedy strategy does not select branches if their opposite branches are already covered but this may put limitations on the search area.
moreover most heuristic based strategies such as carfast cfg directed and generational search focus on coverage information in the branch selection process but do not consider how the execution reaches the branch.
however as we showed in section certain branches have dependencies on other branches and looking at how the execution reaches the branch can help cover such branches e ciently.
.
context guided strategy this section describes our context guided search cgs strategy.
we rst show an overview of cgs.
we then de ne context and dominator and explain the strategy in detail.
.
overview cgs explores branches in the current execution tree.
for each visited branch cgs examines the branch and decides whether to select the branch for the next input or skip it.
figure 4a shows the branch selection process.
cgs looks at how the execution reaches the current branch by calculatingk context of the branch from its preceding branches and dominator information.
we explain context and dominator in the following sections.
then the k context is compared with the context of previously selected branches which is stored in the context cache .
if the k context is new the branch is selected for the next input.
otherwise cgs skips the branch.
figure 4b shows how cgs builds the execution tree.
cgs visits branches according to a bfs order under di erent levelsof contexts.
first cgs examines branches based on their context .
after examining the last branch of the current execution tree cgs increases the context level to context and traverses the tree again to examine previously skipped branches.
figure 4b shows cgs nished the traversal under1 context and is currently examining biat the context level.
as cgs increases the context level more branches are selected for the next input and the execution tree grows further with the new execution paths.context cache k context examine select skip preceding branches dominators a branch selection context context context bfs traversal examine bi b incremental search figure overview of cgs .
context we de ne the context of bas a sequence of preceding branches appearing in an execution path including bitself.
context information shows us how the execution reaches b. in addition we de ne k context ofbas a sequence of kpreceding branches in an execution path.
for example 1in figure 1b consists of branches b1 b4 b6 .
then context ofb6becomes b4 b6 .
cgs examines each branch by its context and selects a branch having a new context only for the next input for example when cgs visits b6in 1in figure cgs calculates its context as b4 b6 .
since this context is new cgs selects the branch and tries to generate a new input vector.
cgs stores the context into the context cache and moves on to examine the next branch.
when cgs visits b6 from cgs skips it since it has the same context b4 b6 which has been explored before.
however when cgs visits b6from cgs selects b6for the next input since it has the new context of b3 b6 .
the size of the context a ects the performance of cgs.
under1 context the full context of each branch is considered and cgs becomes the same as the bfs strategy selecting every branch for the next input since each branch has a di erent context under context .
on the other hand under context each branch itself becomes its own context and cgs selects each branch only once.
this causes cgs to skip a large number of branches but might result in low coverage.
the optimal kmay vary depending on the characteristics and size of the test subjects and testing budget.
instead of settingkto a xed number cgs incrementally increases k by considering preceding branches located close to bas more important than preceding branches located far from b. for example cgs starts with context and traverses the execution tree.
since cgs skips a large number of branches under context it quickly nishes the traverse.
then cgs increases kto2 context and traverses the execution tree again from the top.
at this time cgs examines the previously skipped branches and selects branches based on their context .
cgs continuously increases kafter the end of each traversal of the execution tree within the given testing budget.
incrementally increasing khas the bene t that it can improve coverage faster than starting with a xed keven though both may yield similar coverage in the end.
we compare the coverage di erences between incremental kand xed kstrategy in section .
.
2suppose we consider context currently and b6has never been visited before.
.
dominator depending on the structure of cfg it is possible that all the execution paths reaching a branch have the same kcontext when kis small.
figure shows part of the cfg of function regex compile ingrep.
due to the structure with deeply nested conditional statements all the execution paths going to b11have the same k context ifkis smaller than or equal to ve.
for example b11has the same 5context of b3 b5 b7 b9 b11 in both execution paths 1and .
however the branches in this context areirrelevant for nding a di erent context for b11since every execution path tob11must go through them.
to exclude irrelevant branches in the context we calculate dominator information.
in cfg node ddominates node n written as d dom n if every path from the entry node to node nmust go through node d .
from the de nition it follows that if p1 p2 p kare all predecessors of n andd6 n then d dom n if and only if d dompifor eachi .
therefore nding dominators of node ncan be formulated as nding the maximal xed point solution to the following data ow equation .
dom n0 fn0g dom n p2preds n dom p a fng the dominator concept is de ned for nodes in the cfg but we can apply it to edges branches also such that bxdom byif every path from the entry node to bymust go through bx.
for example in figure b3dominatesb11since all the execution paths heading for b11must go through b3.
after calculating dominators we consider non dominating branches only in the context information.
for example the context ofb11in 1in figure becomes b1 b11 instead of b9 b11 sinceb3 b5 b7andb9are dominators of b11.
with dominator information cgs can nd execution paths reachingb11with di erent context by increasing the context level to2 context only instead of increasing it to context .
.
cgs algorithm algorithm shows cgs in detail.
we use a list of branches at each depth in the tree for the bfs traversal line .
the depth is initialized to one line and increased after examining all branches at the current depth line .
for each randomly selected branch in the list k context of the branch is calculated and the context is checked for 3in other words b11is control dependent on b3 b5 b7and b9.b1 b2 b3 b5 b7 b9 b11 b4 b6 b8 b10 b12 1 2 figure an example complex cfg which is part of the cfg of function regex compile ingrep.
whether it is new or not line .
the branch with a new context is selected for the next input and if it has a satisfying input vector for the negated path condition line the target program is run with the new input vector line and the new path is added to the execution tree line .
the algorithm starts with the minimum context size line .
after the bfs traversal is over we increase the size of context by one line and start the traversal again from the top of the tree line .
from the second traversal we examine previously skipped branches line .
the algorithm repeats until the termination conditions are met line .
.
evaluation this section describes the evaluation plan for cgs including research questions concolic testing tools evaluation strategies and subjects.
.
research questions we designed our evaluation to address the following research questions.
rq1.
given the same testing budget how many branches can each strategy cover?
we measure the number of branches covered by each strategy given the same testing budget.
a strategy achieving a higher coverage is better.
rq2.
give a target coverage goal how many iterations does each strategy require to achieve that goal?
how fast a strategy reaches a target coverage is another common criterion to evaluate the performance of search strategies .
when enough testing budget is given di erent strategies may ultimately reach a similar coverage.
however the number of iterations required to reach that coverage might be di erent.
a strategy table subjects used in the experiments.
subject testing tool language loc grep crest c 19k replace crest c .5k expat crest c 18k cdaudio crest c 2k floppy crest c .5k kbfiltr crest c 1k tp300 carfasttool java .3k tp600 carfasttool java .6k tp1k carfasttool java .5k tp2k carfasttool java .4k tp5k carfasttool java .8k tp10k carfasttool java 28kalgorithm context guided search strategy input a target program pand an execution path p output a set of test input and coverage information 1t p initialize execution tree with p 2k size of context 3while termination conditions are not met do d bfs depth while d depth of tdo blist get branches at depth dfrom t forb in blist do if k context ofbis not new or bhas been selected before then continue end if p get execution path of bfrom t if9ithat forces ptoward b0 balong pthen q concolicrun p i addqtot end if end for increase dby end while increase kby 20end while achieving the same coverage with a smaller number of iterations is better.
.
testing tools and evaluation strategies we evaluate cgs on top of two publicly available concolic testing tools crest and carfasttool .
crest is an automatic test generation tool for programs written in c. we chose crest since it has been widely used in previous work .
crest s test driver comes with dfs random branch selection and cfg directed strategies.
in addition we implemented cgs carfast and generational strategies in the test driver of crest.
carfast is a search strategy and implemented in a java concolic testing tool.
to avoid confusion we call the strategy carfast and the testing tool carfasttool.
we chose carfasttool as another testing tool since we wanted to test programs in a di erent language other than c and carfasttool is one of the most recently published concolic testing tools for java programs.
we implemented cgs in the test driver of carfasttool.
with carfasttool we only compare cgs with the carfast strategy since the previous work already showed that carfast outperforms dart which is based on the dfs strategy and other random approaches on the same subjects.
we conducted the experiments on a linux machine equipped with intel xeon .67ghz cpu and 64gb ram.
since the coverage depends on the initial input vector we conducted the experiments times with a random initial input4and calculated the average coverage.
for carfasttool we conducted the experiments times since carfasttool took a much longer testing time than crest.
.
evaluation subjects we used six open source c programs used in as the evaluation subjects for crest.
first is grep a text search program supporting regular expressions replace is a text processing program included in crest while expatis an open source xml parser library.
the other three 4forexpat we used a sample xml le for the initial input.table the number of branches covered by each strategy on six c subjects at di erent iterations.
the numbers inside the parenthesis show the coverage improvements over the last iterations.
subject strategyiterations grepcgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
replacecgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
expatcgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
cdaudiocgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
oppycgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
kb ltrcgs .
.
.
.
.
cfg .
.
.
.
.
random branch .
.
.
.
.
generational .
.
.
.
.
dfs .
.
.
.
.
carfast .
.
.
.
.
programs cdaudio floppy andkbfiltr come from the svcomp benchmark which is used in the competition for software veri cation.
for carfasttool we used six java subjects included in the benchmark set coming with carfasttool.
they are synthesised java programs of di erent sizes generated by a set of prede ned rules.
we could not add real world programs into the evaluation subjects for carfasttool since the tool s symbolic execution and constraint solving technique are specialized for testing the benchmark programs and cannot handle real world programs.
table shows some statistics about the testing subjects.
.
results we show the evaluation results of the search strategies for various subjects in this section.
in addition we discuss the e ects of the increasing ksearch and dominator.
.
coverage in crest this section presents the coverage results of six search strategies on six c subjects experimented on crest.
we rst show the coverage achieved by each strategy given the same testing budget to answer rq .
table shows the number of covered branches on six c subjects at and iterations.
we counted the number of unique branches in the cfg whichare covered by the execution paths of the inputs generated in the experiment.
for example at iterations cgs covered .
branches on average on grep while cfg covered .
branches.
random branch covered .
branches and dfs covered .
branches only.
the results show that cgs achieved the highest coverage on all six subjects and at all di erent iteration points.
on grep and expat cgs covered .
and .
branches respectively which are .
and .
more branches than cfg the second best strategy.
cgs also achieved the highest coverage on replace .
we conducted the mann whitney u test and found the coverage di erences between cgs and the second best strategy on grep expat andreplace are statistically signi cant with p value less than .
.5oncdaudio floppy and kbfiltr cgs and generational covered the same number of branches being and respectively.
on kbfiltr cfg also reached the same coverage at iterations.
unlike cgs other strategies showed di erent performances depending on the subjects.
for example cfg was the second best strategy on grep replace andexpat but not on the other subjects.
generational search did not perform well on grep replace and expat but was one of the best strategies 5the results of shapiro wilk test showed that we can reject normal distribution hypothesis with p value lower than .
on most cases.grep target replace target expat target cdaudio target floppy target kbfiltr target cgs cfg rb gen dfs carfast cgs cfg rb gen dfs carfast cgs cfg rb gen dfs carfast cgs cfg rb gen dfs cgs cfg rb gen dfs cgs cfg rb gen dfsiterationsfigure the number of iterations required to reach a target coverage on six subjects in crest.
oncdaudio floppy and kbfiltr .
on the other hand cgs consistently yielded the highest coverage on all six subjects.
table also shows that most strategies reached a coverage plateau at iterations.
except cgs and cfg which continuously improved coverage by more than on expat the other strategies have about or less improvement in coverage over the last iterations.
we conducted additional experiments on expat for cgs and cfg and counted the number of branches covered at iterations which is more testing budget.
still cgs covered .
more branches than cfg by covering .
branches while cfg covered .
branches.
on cdaudio floppy andkbfiltr cgs and generational already reached a coverage plateau after iterations.
we then compared the covered branch set between the strategies.
for each strategy we combined all the branches covered during experiments then we compared the covered branch set between cgs and other strategies.
on replace cdaudio floppy andkbfiltr cgs s covered branch set included all the branches covered by other strategies.
on the other hand on grep we found branches which were covered by cfg but not covered by cgs.
other strategies also covered a few number of branches which were not covered by cgs.
for example there were two and four branches covered by generational and dfs respectively but not covered by cgs.
similarly on expat we found branches covered by cfg but not covered by cgs.
generational and dfs also covered and branches respectively which were not covered by cgs.
even though cgs covered more branches given the same testing budget the di erences on covered branch set show that each strategy can explore different parts of the program.
for better coverage di erent strategies can be combined to complement each other.
to answer rq we set a target coverage goal and measured the number of iterations required by each strategy to reach the target.
we set the lowest achieved coverage on each subject at iterations as the target coverage.
for cdaudio floppy and kbfiltr the di erence between the lowest coverage and the others was too large so we chose second to the lowest coverage as the target.
figure shows the number of iterations by each strategy required to reach the target coverage.
for example we set the coverage achieved by dfs on grep as the target coverage for grep.
the bar graph in figure shows that dfs reached the target coverage at iterations.
cgs reached this coverage with the smallest number of iterations followed by cfg which reached it at iterations.
carfast reached it at iterations randombranch at and generational at iterations.
cgs reached the target coverage with the smallest number of iterations on most subjects except expat .
on expat cfg reached the target coverage rst after iterations followed by cgs which took iterations.
however table shows that cgs consistently achieved a much higher coverage than cfg after iterations.
even though cgs and generational reached the same coverage on cdaudio floppy and kbfiltr in table figure shows that cgs reached it faster than generational.
cgs reached the target coverage after and iterations on cdaudio floppy and kbfiltr while generational reached it after and iterations respectively.
overall the coverage results on c subjects show that cgs outperforms other strategies.
cgs achieved the highest coverage on all six subjects and reached the target coverage rst on ve out of six subjects.
.
coverage in carfasttool this section presents the evaluation results of cgs and carfast on six java subjects experimented on carfasttool.
we rst show the coverage results given the same testing budget for rq1.
table shows the number of branches covered by cgs and carfast at di erent iterations.
for example at iterations cgs covered .
branches on tp300 while carfast covered .
branches on average.
at iterations cgs covered .
branches and carfast covered .
branches.
the results in table show that cgs achieved a higher coverage on all six subjects at all iteration points.
on tp300 the smallest subject in the experiments cgs covered .
more branches than carfast.
the di erences between cgs and carfast become bigger as the size of the subjects increases.
on tp10k which is the largest subject in the extable the number of branches covered by cgs and carfast on six java subjects at di erent iterations.
the numbers inside parenthesis show the coverage improvements over the last iterations.
sub strategyiterations tp300cgs .
.
.
.
carfast .
.
.
.
tp600cgs .
.
.
.
carfast .
.
.
.
tp1kcgs .
.
.
.
carfast .
.
.
.
tp2kcgs .
.
.
.
carfast .
.
.
.
tp5kcgs .
.
.
.
carfast .
.
.
.
tp10kcgs .
.
.
.
carfast .
.
.
.
tp300 tp600 tp1k tp2k tp5k tp10k cgs carfast cgs carfast cgs carfast cgs carfast cgs carfast cgs carfastiterationsfigure number of iterations required to reach a target coverage in carfasttool.
periments cgs covered .
more branches than carfast by covering .
branches.
to see if the coverage di erences between the two strategies are signi cant we conduced the mann whitney u test and found that the coverage differences are statistically signi cant with the p value lower than .
on all six subjects.
since carfasttool only reported the coverage summaries we could not compare the covered branch sets directly.
table also shows that both strategies reached a coverage plateau at iterations having less than coverage gain over the last iteration on most subjects.
to see how fast each strategy improves coverage we set a goal coverage and measured the number of iterations required to reach that goal.
we set the coverage achieved by carfast at iterations as the goal coverage.
figure shows the number of iterations required by each strategy to reach the goal.
for example we set as the goal coverage for tp300 .
figure shows that cgs reached the goal after iterations while carfast reached it after iterations.
on tp10k the goal coverage was and cgs reached it after iterations while carfast reached it after iterations.
on all six subjects cgs reached the target coverage with a signi cantly less number of iterations than carfast.
for tp300 and tp600 cgs needed only .
and .
of the iterations needed for carfast to reach the goal.
as the subject size becomes bigger the di erence between the required number of iterations becomes smaller.
even though cgs reaches the goal much faster than carfast on tp1k and tp2k with only .
and .
of the number of iterations needed for carfast.
on tp5k and tp10k cgs reached the target with .
and .
of the number of iterations needed for carfast.
overall cgs outperforms carfast.
cgs achieved the highest coverage and reached the target coverage with a much smaller number of iterations on all six java subjects.
.
discussion .
.
increasing k vs. fixed k cgs increases the context level incrementally starting from one.
to see the e ects of the increasing ksearch we compared it with the xed ksearch.
we ran cgs again for six c subjects by xing kto ve from the beginning and compared the coverage with the results of the original cgs which increases kfrom one to ve.
figure shows the results on grep.
both increasing k and xed kreached a similar coverage after iterations.however increasing kimproved coverage faster than xedk.
at iterations increasing kcovered about more branches than xed k. in particular increasing khad a sharp coverage gain between and iterations while xed khad a similar gain but later between and iterations resulting in slower coverage improvement.
in addition the duration of the sharp gain is di erent.
increasingkimproved coverage quickly during approximately iterations while xed kincreased during approximately iterations again resulting in slower coverage improvement.
evaluation results on the other c subjects showed similar trends where increasing kimproved coverage faster than xed k. moreover xed kdid not reach the coverage achieved by increasing kat iterations on all six subjects.
.
.
dominators cgs uses dominator information to exclude irrelevant branches in the context information.
to see if this is helpful for improving coverage we ran cgs by calculating the context without dominator information cgs nodom .
the results on grep are also depicted in figure .
cgsnodom achieved much lower coverage than cgs at iterations.
when the context level is one dominator information is not considered in cgs therefore cgs and cgsnodom showed the same coverage in the beginning.
however as the context level is increased the dominator information became e ective and cgs increased the coverage faster than cgs nodom.
the results on replace andcdaudiowere similar.
cgs nodom showed the same coverage in the beginning but had lower coverage in the end.
on the other hand the e ect of dominator was not clear on the other subjects where cgs and cgs nodom showed a similar coverage improvement.
.
threats to validity we identify the following threats to the validity of our experiment the subjects and search strategies used in the experiment may not be representative .
we used grep and replace in the experiment since they come with crest and have been used to evaluate other strategies in .
we chose expat a text parsing program as another subject to minimise the e ects of oating points and non linear constraints since crest s symbolic execution does not support them.
we used three more subjects from the sv comp benchmark which have been used in other work .
six java subjects coming with carfast tool have been chosen to evaluate cgs in the same environment where carfast has been evaluated .
even though we used six open source c programs with diverse sources and six synthesised java programs they may not be representative of other programs.
in addition there are many other search strategies and we only compared cgs with ve of them.
our approach may yield di erent results on other subjects and other search strategies.
more precise symbolic execution and constraint solving may yield di erent results.
crest s symbolic execution does not support oating points and nonlinear constraint solving.
carfast s symbolic execution only deals with integer values.
the experimental results might be di erent with more precise symbolic execution and di erent constraint solving techniques.
number of branches covered iterations cgs increasing k cgs fixed k cgs without dominator figure comparison of cgs increasing kand xed k. the graph also shows the result of cgs without dominator information.
.
related work .
other search strategies several heuristic based approaches have been proposed to guide an execution toward a speci c branch which is generally undecidable .
xie et al.
introduced a tness guided path exploration technique.
their technique calculates tness values of execution paths and branches to guide the next execution towards a speci c branch.
the use of tness functions is similar to a traditional search based testing technique which uses tness functions to generate input vectors however they combined it with concolic testing.
marinescu et al.
introduced a system called katch to guide the symbolic execution towards the code of the software patches.
it exploits the existing test suite to nd a good starting input and uses symbolic execution with several heuristics to generate more inputs to test the patches.
for example to deal with branches having concrete values it guides the execution toward a di erent de nition location of the variables used in the branches.
our approach focuses on improving coverage in general rather than focusing on speci c branches.
however these techniques can be incorporated with our strategy to guide the execution to hard to cover branches.
li et al.
introduced a technique which steers symbolic execution to less traveled paths which is the most similar approach to ours.
whenever a symbolic execution comes to a branch it forks another state to follow both true and false branches.
to select which state to follow they used thesubpath of each state and chose a state having the least frequent subpath.
the subpath is a similar concept to context in our approach.
however they used a xed size subpath while our approach incrementally increases the size of the context.
in addition they did not consider dominator information in the subpath.
on the other hand there are techniques combining concolic testing with other testing techniques to explore the search space e ectively.
hybrid concolic testing combines random testing and concolic testing.
the technique starts from random testing to quickly reach a deep state of a subject program by executing a large number of random inputs.
when the random testing saturates without improving coverage for a while it switches to concolic testing to exhaustively search the state space from the current programstate.
however as the authors mentioned hybrid concolic testing works best for reactive programs that receive inputs periodically while our search strategy best suits programs that have a xed sized initial input.
garg et al.
introduced a technique combining feedback directed unit test generation with concolic testing.
the strategy starts with a unit testing similar to randoop and switches to concolic testing when the unit testing reaches a coverage plateau.
since it combines random testing with concolic testing our strategy can be used in the concolic testing part.
klee used a meta strategy which combines several search strategies in a round robin fashion to avoid cases where one strategy gets stuck.
cgs selects branches in a new context and this can help prevent the continuous selecting of the same branch.
.
techniques for path explosion pruning redundant paths is another way to deal with path explosion.
boonstoppel et al.
introduced the rwset technique to prune redundant paths during exploration which is based on two key ideas.
first if an execution reaches a program point in the same state as some previous executions then the execution produces the same results as before therefore the exploration can stop at the program point.
second if two states only di er in program values that are not subsequently read then the two states produce the same results and one state can be discarded.
ja ar et al.
introduced a technique using interpolation to subsume execution paths that are guaranteed not to hit a buggy location.
interpolation succinctly represents the reason any branch cannot be covered.
they introduced a technique to nd full interpolants quickly so that next executions satisfying the interpolant can be subsumed.
summary can also be used to alleviate the path explosion problem .
a function summary fis de ned as a disjunction of formula w where wis de ned as prew postw.prewis a conjunction of constraints of the inputs to fand postwise ect offor a conjunction of constraints of the outputs from f. since a summary succinctly represents the execution of a function the summary can greatly reduce the number of paths during a symbolic execution if the function is called frequently from many di erent locations.
however calculating the summary for a complex function is non trivial .
.
conclusion an e cient search strategy is a key component in concolic testing to overcome the search space challenge.
while most strategies focus on coverage information in the branch selection process we introduce cgs which considers context information that is how the execution reaches the branch.
our evaluation results show that cgs outperforms other strategies.
however we believe further coverage improvement can be achieved.
speci cally a more precise dependency analysis would allow a search strategy to focus on more important branches.
it is our future plan to investigate more deeply into such a strategy.
.