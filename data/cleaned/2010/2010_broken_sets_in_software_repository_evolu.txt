broken sets in software repository evolution j er ome v ouillon cnrs pps umr univ paris diderot sorbonne paris cit e jerome.vouillon pps.jussieu.frroberto di cosmo univ paris diderot sorbonne paris cit e pps umr cnrs f roberto dicosmo.org abstract modern software systems are built by composing components drawn from large repositories whose size and complexity increase at a fast pace.
software systems built with components from a release of a repository should be seamlessly upgradeable using components from the next release.
unfortunately users are often confronted with sets of components that were installed together but cannot be upgraded together to the latest version from the new repository.
identifying these broken setscan be of great help for a quality assurance team that could examine and fix these issues well before they reach the end user.
building on previous work on component co installability we show that it is possible to find these broken sets for any two releases of a component repository computing extremely efficiently a concise representation of these upgrade issues together with informative graphical explanations.
a tool implementing the algorithm presented in this paper is available as free software and is able to process the evolution between two major releases of the debian gnu linux distribution in just a few seconds.
these results make it possible to integrate seamlessly this analysis in a repository development process.
i. i ntroduction component based software architectures maintained in a distributed fashion and evolving at a very quick pace are nowadays commonplace in particular in the world of free and open source software foss .
components are usually made available via a repository and are equipped with metadata such as dependencies andconflicts that specify concisely the contexts in which a component can or cannot be installed.
a typical example taken from the debian gnu linux distribution is shown in figure i where we can see that the logical language used for expressing dependencies and conflicts is quite powerful as it allows conjunctions symbol disjunctions symbol and version constraints.
maintaining and evolving component repositories is an important task and requires an extensive quality assurance process besides traditional issues concerning the bugs in the code inside each component the quality of a large component repository rests also on how well components can be combined with each other a property known as co installability .
similarly to what happens with the source code of a single component which is passed through regression tests to ensure that one did not re introduce issues that were fixed before we are naturally led to check whether there is any set of work performed at the irill centre for free software research and innovation package tesseract ocr 2source tesseract .
.
version .
.
b1 depends libc6 .
.
libgcc1 .
.
5libjpeg8 8c libstdc .
.
6libtiff4 zlib1g .
.
7tesseract ocr eng tesseract ocr language package tesseract ocr eng 10source tesseract eng version .
c o n f l i c t s tesseract ocr .
fig.
.
inter package relationships of tesseract ocr an optical character recognition engine and tesseract ocr eng the english language pack as found on february in the testing suite of the debian gnu linux distribution.
components which were co installable in the old repository but become non co installable in the new release.
sets of components with this property which we call broken sets are particularly damaging in the evolution of a repository their existence means that there may be perfectly functional deployments based on the old repository that will be disrupted as soon as one tries to upgrade their components to the version in the new repository.
the configuration in example i is a real world example of such a broken set the tesseract optical character recognition program which is split in several related packages1 was perfectly functional before february 20th2012 but on that day the introduction of the updated english language pack tesseract ocr eng made the installation of this program temporarily impossible for the english language.
broken sets need to be identified early in the evolution process and fixed well before the release of the new repository but finding broken sets in repositories whose size is in the tens of thousands of components is a daunting task there may be exponentially many broken sets and listing them all would be both computationally unfeasible and of no use for a quality assurance team which would be flooded under the error reports.
in this paper we describe a highly efficient algorithm that solves the problem by finding a very small subset of the broken sets which subsume all the others and is close to minimal in a sense that will be made precise later on.
1essentially tesseract ocr for the core engine and tesseract ocr lang for all supported language langwe have developed a tool that implements this algorithm and finds such minimal problematic configurations on real component repositories in a few seconds it also provides very concise explanations that allow to identify the origin of the problem.
we found several such issues in the evolution of the debian distribution using the tool.
the paper is organised as follows section ii briefly recalls the basic notions about packages and dependencies and the formally certified semantic preserving repository transformations developed in which our work builds upon and then presents the key ideas of our approach.
section iii presents some of the results obtained by our tool on real world gnu linux distributions.
the technical development follows section iv provides a precise formalisation of all the transformations and simplifications that can be performed to reduce dramatically the search space for explanations section v describes in detail an algorithm that uses these results and builds a set of broken sets that cover all upgrade issues and we show in section vi how we provide minimal explanations that contain all the relevant information for understanding the cause of these broken sets.
we discuss related work in section vii and section viii concludes.
ii.
o verall approach while the concrete details may vary from one technology to the other the core metadata found in component based systems always allows to express a few fundamental properties a component called package in the following may depend on a combination of components expressed as a conjunction of disjunctions of components and a component may conflict with a combination of components expressed as a conjunction.
extra properties like versioned constraints e.g.libc6 .
.
in figure i can be preprocessed out so we focus on a core dependency system containing a binary symmetric conflict relation and a dependency functiond 1 ... 1 n1 ... k ... k nk that is satisfied when for each iat least one of the i jis installed.
we follow the notations of earlier works that we briefly recall.
a. repositories arepository is a tuple r p d c wherepis a finite set of packages d p p p p is the dependency function we write p x for the set of subsets of x and c a symmetric irreflexive relation over p is the conflict relation .
one can represent a repository with a concise graphical notation like in figure 2a where cis in conflict withbandf whilearequiresfand either borc ande requiresfandg anddrequirese.
we call dependency a set of packages dincluded in d for some package p. aninstallation iof a repository p d c is a subset of p. an installation iishealthy when the following holds abundance every package has what it needs.
formally for every package i and for every dependency d d we have d i e atio slash .
peace no two packages conflict that is c i i .
a package isinstallable in a repository if it is included in a healthy installation iof this repository.
a set of packages areco installable in a repository rif they are all included in some healthy installation iof the repository.
b. repository transformations to identify co installability issues in a single repository introduced a set of repository transformations that allow to extract from a large repository a much smaller co installability kernel which is equivalent as far as coinstallability is concerned.
the gain allowed by these transformations is impressive starting from a ubuntu repository containing packages dependencies and conflicts one goes down to a kernel containing only elements with dependencies and conflicts similar gains are obtained on debian or mandriva repositories .
a description of these transformations can be found in section of where they are also shown correct the proofs are certified in coq for completeness we recall here the main steps involved.
flattening dependencies the first transformation replaces the dependency function dof a repository r p d c with a special flattened form hatwidedwith two key properties first by applying a sort of transitive closure to d itdirectly describes all dependencies of each package so if hatwided 1 ... k1 ... 1 n ... knn then the packages j iare all the packages relevant for installing package and only them.
on the example repository of figure 2a this amounts to adding a dependency from dtof and one from dtog figure 2b .
second since we are only interested in co installability we can prune the expanded dependency function by removing any dependency containing a package with no conflicts.
on the example repository of figure 2a this pruning phase removes the dependencies from dtoe fromdtogand from etog leading to the repository of figure 2c.
finally to render the repository more homogeneous hatwidedadds a self dependency to each package with conflicts leading to figure 2d.
packages d eandfnow have the same dependencies which reflects the intuition that they behave the same way as far as co installability is concerned.
these three operations transitive closure pruning and addition of self conflicts leave co installability invariant theorem in .
they are performed in a single pass and can be formally defined as follows given a repository p d c the flattened dependency function hatwidedis the smallest function with respect to point wise inclusion such that refl c hatwided trans 1 ... n d d1 hatwided 1 ... d n hatwided n uniondisplay i ndi hatwided the presentation of flattening through these inductive rules is particularly useful as it is possible to see by following the derivation tree how the original dependencies are composed together into the final flattened form.
removing irrelevant dependencies and redundant conflicts as a second phase identifies several classes of dependencies that are irrelevant as far as co installability isa b ce f d g a original repositorya b ce f d g b transitivitya b cd f e g c pruning a b cd f e f g b c d self dependency additiona b cd f e f g b c e simplificationb c a d e f g b c a d e f f quotient fig.
.
transformations of a repository added dependencies are in bold dotted ones are removed in the next phase a b c a the dependency b c is implied by b a b c d b redundant conflict between aandb fig.
.
implied dependency redundant conflict concerned and can thus be removed.
in this work we only use two such simplifications.
the first simplification is called canonisation in as it corresponds to putting dependencies in a canonical minimal form by removing any dependency dthat is implied by another dependency d of the same package that is d d .
an example can be seen in figure 3a where the dependency ofaonborcis implied by the dependency of aonb.
the second simplification is the removal of irrelevant dependencies with have no impact on co installability.
in particular a dependency disclearly irrelevant if it contains a package that has conflicts only with packages belonging to d. in figure 2d the dotted disjunctive dependency is clearly irrelevant and can be removed by theorems and of leading to the repository in figure 2e.
it is also possible to remove conflicts which are implied by other conflicts like the one between aandbin figure 3b.
quotienting equivalent packages it is evident looking at figure 2e that packages a d eandfare as far as co installability is concerned really equivalent because they share the very same set of dependencies.
this happens quite often in real repositories so quotienting the final repository can greatly reduce its size as can be seen in figure 2f.
these transformations have been proven correct in in a modular way so we can now safely cherry pick those of them which are relevant for us.
c. repository evolution and upgrades this work is no longer concerned with a single repository r we want to compare co installable sets of packages in aab c r r de fig.
.
repository evolution.
current repository r p d c with those of a previous stater p d c of the repository that evolved into r. one example of such evolution is shown in figure where one can see that in the process we may find removed packages in p p liked upgraded packages in p p likea b c new packages in p p likee .
we assume that packages keep the same name across repository evolution this allows to immediately relate packages between the two repositories with no extra notational burden and corresponds to a best practice in gnu linux distributions where repository maintainers keep a dummy package with the old package name and a dependence on the new package name when a change of name is needed similarly we assume that package upgrades are one to one operations.
a healthy installation i of repository r can be successfully upgraded if one can find an healthy installation iof repository rsuch that i p i this models closely the common practice of allowing to install extra packages during an upgrade and accepting to uninstall old packages that have been removed in the new repository.
d. finding upgrade issues the key insights in a perfect world it would be possible to successfully upgrade any healthy installation but in practice this is not the case as example i shows.
to improve this situation we need to find a way of identifying all potential upgrade failures by looking only at the old and new repositories.
of course if an installation i cannot be upgraded it must contain a set of packages that were co installable in the oldp0 q0 p1p2p3q1q2q3 fig.
.
many minimal broken sets one minimal explanation repository r p d c and are no longer co installable in the new repository r p d c we call such sets broken sets .
andi pis a broken set.
finding broken sets is not easy listing all broken sets would require to enumerate all co installable sets of the old repository r to see whether their image in the new repository becomes non co installable.
unfortunately this might lead to testing all the 2nsubsets of a repository of size n withnin the range of thousands to tens of thousands2 this approach is unfeasible.
a dual approach would be to reuse the highly efficient coinst tool from to find all minimal non co installable subsets of the new repository r and check whether they were installable in the old repository r .
unfortunately this would also be unsatisfactory on one side the number of minimal non co installable subsets in rcan be huge and one would need to test them all even if the changes made fromr torhave no impact on them on the other side the efficiency of coinst relies on computing equivalence classes of co installable packages but these classes may be completely disrupted by an evolution of a repository.
our solution fortunately it is possible to avoid listing all broken sets by looking for a special collection of broken sets that has the property that any installation that cannot be upgraded contains at least one element of this collection we call any such collection a cover .
to efficiently build such a cover we needed to combine several key ideas.
we illustrate them here on small examples of repository evolutions that are represented graphically by indicating the newly added packages dependencies or conflicts by dashed lines or borders.
using explanations to choose relevant broken sets.
we remark that broken sets are closed by superset if cannot be upgraded then all fail as well.
so we might want to only consider broken sets of minimal size.
but the fact that a broken set has minimal size does not mean that it must be included in a cover as we can see in the repository shown in figure .
here we have three packages depending on p0and three packages depending on q0 adding the conflict between p0andq0in the new repository prevents the upgrade of any installation containing simultaneously one of the piand one of theqipackages.
in this case all the sets pi qj built by taking one package on the left and one on the right are 2the current debian testing distribution is approaching .
packages and the basic collection of eclipse plugins contains over .
elements.a b c d a conjunctiona b c d b disjunction fig.
.
multiple explanations a b c fig.
.
broken sets minimal size vs. minimal explanation broken sets of minimal size but one of these broken sets namely p0 q0 is much better than the others indeed any installation containing one of the pi qj necessarily contains also p0 q0 which is sufficient alone to provide a cover.
to capture the reason why p0 q0 is better than the other sets we call explanation of a broken set in a repository r p d c any subrepository as formally defined in section iv a of rin which is still a broken set and then we give our preference to the broken sets with minimal explanations.
in figure p0 q0 is the broken set with the minimal explanation all other pairs have an explanation that contains it.
there can be several minimal explanations associated with a broken set for instance in the repository rof figure 6a the broken set a d has one minimal explanation that is r restricted to packages a b d and another minimal explanation that is rrestricted to packages a c d .
in this case it is easy to see that any installation containing a d must also contain either b d or c d .
this means that we have the choice when building a cover to replace a d by either one of the two other broken sets and we prefer b d or c d because they have smaller explanations than a d .
the repository rof figure 6b illustrates a dual situation here the broken set a d has a unique minimal explanation the full repository.
but we prefer to add to a cover the two broken sets b d and c d instead of a d because they both have smaller explanations than the broken set a d .
unfortunately it is not always possible to minimise simultaneously the cardinality of a broken set and the size of its explanation as can be seen in the repository of figure here we have the choice between taking as best broken set either a which has as explanation all the repository or the set a b which is bigger but has a smaller explanation consisting of the repository without the dependency from ato b. our algorithm combines the two minimisation techniques by first enumerating all possible minimal explanations of a given shape and then taking minimal broken sets for each of them.
focusing on explanations containing only new conflictsor new dependencies.
the second insight is that if it is impossible to upgrade an installation the cause must lie with thechanges made to the repository so we should start our search from the differences between the old and the new repository.
indeed a fundamental result proven in this work is that when searching for broken sets to add to a cover we can restrict our attention to explanations that have as root cause only new conflicts andnew dependencies .
this allows to reduce dramatically the search space by only enumerating explanations involving new conflicts and new dependencies.
building explanations by combining flattened dependencies.
the final ingredient of our approach is the reuse of several transformations from that leave co installability invariant which we recalled in subsection ii b. after these transformations the new repository is put in a simplified flattened form that allows to enumerate explanations by just combining together the flattened dependencies joining them when they share conflicts.
combining these three key ideas we could devise an algorithm that is complete and extremely efficient in practice finding covers that contain very small broken sets and providing minimal explanations for each broken set.
visualising upgrade issues to visualise in a compelling way the upgrade issues we first draw a graph of the broken sets in the cover as can be seen in figure this allows a repository maintainer to quickly identify the new incompatibilities and select the ones he wants to focus on.
then for each broken set in the cover we draw a graph called full explanation that conveys concisely all the information necessary to understand why it was co installable in the original repository and is no longer co installable in the new one.
in this graph dependencies and conflicts are drawn with different styles solid lines indicate an object present in both the old and new repositories dashed lines indicate an object present only in the new repository and dotted lines indicate an object present only in the old one.
two examples of full explanations are given in figure which can be read as follows.
in figure 10a we see that tdbsodbc is no longer co installable with libiodbc2 because the new version of package tdbsodbc is in conflict with both versions old and new of libiodbc2 .
in figure 10b we see that speechd el is no longer co installable withemacs23 nox because all versions of emacs23 conflict with all versions of emacs23 nox and both versions ofspeechd el depend on any version of emacs23 or on the old version of eieio .
iii.
e xperimental results an ocaml program implementing the algorithm described in this paper is available together with a few sample outputs from we have run it on several instances of repository evolutions of the debian gnu linux distributions that correspond to the two main use cases of the tool.
analysing major upgrades requires comparing one version of a distribution to the next we tested two such cases by comparing two successive releases of debian oldstable and stable and the last debian stable release february versus the february snapshot of the testing release i386 architecture .
identifying recently introduced issues requires comparing versions of a distribution during the development phase we tested several instances of this scenario by comparing various pairs of testing snapshots monthly from october to february .
a summary of the result is shown in the table below the running time has been measured on a machine using an intel core i7 at .93ghz.
distributions running time broken sets oldstable stable .4s stable testing .9s .2s in figure one can see the full set of upgrade issues between the stable version of debian and the snapshot of the testing version which fits on a single a4 page.
on this graph an edge connecting two packages stands for a broken pair of packages.
a larger broken set is represented by a circle connected to the packages it contains.
one can see that with only two exceptions the broken sets that compose the cover contain just two packages.
looking at some of the transitions we could find several real upgrade issues in the evolution of the debian repositories many of them are due to incomplete migrations of related packages like in the case of the tesseract example shown in the introduction but there are more damaging ones like the transition from gnat .
tognat .
where some packages changed to depend from the old version to the new one starting in december while most packages are still depending on the old one in february .
iv.
f ormal development we now turn to the formal development of our approach and present the fundamental theoretical results of our work which allow to find a cover containing a limited number of small broken sets and to provide concise and readable explanations for each of them.
a. finding broken sets as highlighted in the previous section in order to find a cover of broken sets for a repository r we focus on explanations which are particular subrepositories ofr consisting of dependencies and conflicts that may prevent the installation of a set of packages that were previously co installable.
formally a repository r p1 d1 c1 is asubrepository of another repository p2 d2 c2 written r r when p1 p2 p1 d1 d2 c1 c2.
our algorithm enumerates such explanations striving to satisfy two conflicting objectives on one side we want to find enough explanations to get a cover but on the other side we want to keep the number of explanations small enough to keep the problem tractable and the report readable.
reduced repositories we start by putting the two initial repositories in a reduced form by applying in this order the following co installability invariant transformations from perform flattening see theorem of remove redundant conflicts see lemma of remove remaining irrelevant dependencies see theorem and and lemma of canonise dependencies see theorem of .
we write p tildewided tildewidec for the reduced repository computed from a repository p d c .
compared to we do not remove an irrelevant dependency dof a package if we can findd tildewided 0 andd0 d 0 such that d0and d d so as to validate the crucial lemma below.
all clearly irrelevant dependencies and in practice almost all other irrelevant dependencies can still be removed.
weak co installability an important feature of reduced repositories is that one does not need to consider dependencies recursively to check co installability.
instead we can adopt a two level view of repositories given a set of packages at the upper level they are weakly co installable if one can find a set of packages at the lower level called features that satisfies their dependencies and that do not conflict with one another.
aconfiguration is a pair i f of a setiof packages and a setfof features we say that it is healthy when the following conditions hold abundance every package has the features it needs.
formally for every package i and for every dependency d d we have d f e atio slash .
peace no two features conflict that is c f f .
the following key theorem is a direct consequence of our previous work as its proof is just a composition of the theorems corresponding to each of the transformations performed to obtain a reduced repository theorem a set of packages is co installable in an initial repository if and only if it is weakly co installable in the corresponding reduced repository.
minimal explanations given a set of packages not weakly co installable in a reduced repository p tildewided tildewidec we callexplanation of any subrepository of p tildewided tildewidec in which is not weakly co installable.
explanations correspond to the so called unsatisfiable cores of sat problems .
there may be several explanations for a set of packages .
considering only the minimal ones with respect to the subrepository relation is sufficient.
they have a very specific shape illustrated in figure as shown by the following theorem.
theorem a minimal explanation p d c of a broken set has the following properties the set of dependencies and conflicts is connected only packages in have dependencies if e atio slash then d all packages in a dependency have a conflict p d d d p c packages in conflict belong to a dependency c d d d fig.
.
typical shape of a minimal explanation if the set is minimal and thend e atio slash .
b. focusing on interesting explanations we can take advantage of the similarities between the old and new repositories to only consider some of the minimal explanations above built using only a subset of the dependencies and conflicts of the new reduced repository.
first of all the packages in a broken set by definition are present in both repositories so new packages have no dependencies in a minimal explanation.
in the following subsections we show that we can restrict our attention to minimal explanations containing only a very restricted form of dependencies this characterisation is essential to prune the search space when we enumerate minimal explanations.
for the sake of clarity we first explain some of the pruning we could perform if we were working on the initial repositories before turning to the case of reduced repositories.
interesting explanations in non reduced repositories we consider an old repository p d c and a new repository p d c .
we call new dependency a dependency d d of some package p p such that there is no dependency d d such that d d. an explanation for a non co installable set of packages is a subrepository in which these packages are still not co installable.
the following lemma shows that if we were to enumerate minimal explanations in the initial repositories it would be sufficient to consider explanations in which the root dependencies are all new.
the proof of the lemma relies on iteratively removing root dependencies that are not new in the explanations.
we writer mapsto d for the repository rwhere the dependency dof package has been removed.
theorem there exists a cover ccontaining only broken sets having an explanation p d c such that all dependencies in d for are new dependencies.
proof we show that by starting with any cover cand iteratively applying a suitable transformation we eventually reach a cover that satisfies the above property.
consider a cover ccontaining a broken set with explanationr p d c .
suppose that there exists a package and a dependency d d which is not new.
then we claim that the set c1 c 1 broken 1 d p is also a cover and that the subrepository r mapsto d is an explanation for all broken sets 1 .
leti be an healthy installation of r that cannot be successfully upgraded.
we need to prove that it includes a broken set in c1.
ascis a cover there exists a broken set 1incthat is containedini .
if 1 e atio slash then 1 c1and we are done.
we now consider the case where i .
asdis not new there exists d d such that d d. asi is an healthy installation ofr that contains package by abundance there exists a package d i .
note that d p .
thus the set included in i was co installable and therefore is included in c1 as wanted provided it is not co installable in r. suppose this were not the case.
then it would also be co installable in the subrepository r mapsto d .
but then it is easy to see that would be co installable in r which contradicts our hypotheses.
hence the set is not co installable which complete this part of the proof.
to prove termination we keep track of an explanation for each of the broken sets in the cover that is we consider sets formed of pairs r composed of a broken set and the corresponding explanation such that the collection of broken sets is a cover.
then the operation above consists in removing pairs from the set adding new pairs with strictly smaller explanations.
clearly this process terminates.
at this point the operation cannot be applied anymore which means that we have a cover that proves the lemma.
taking advantage of reduced repositories we now turn to reduced repositories and establish a similar result but with the important difference that we do not need all the new dependencies we show that it is enough to consider those dependencies which are both new w.r.t.
the reduced repositories and whose derivation tree has at the root a dependency which is new in the non reduced repository.
we call such dependencies fully new .
to the new repository p d c we associate the flattened repository p hatwided c .
each dependency din hatwided can be seen as a composition of dependencies in the derivation below dis the composition of dependency d0from the initial repository and dependencies difrom the flattened repository.
d0 1 ... n d ... d1 hatwided 1 ...... dn hatwided n d uniondisplay i ndi hatwided a crucial lemma shows that a similar property holds for dependencies in the reduced repository p tildewided tildewidec .
we call lean derivation tree a derivation tree of d hatwided such that for any conclusion d hatwided of a subderivation of this tree we haved tildewided as well.
with such a tree we can decompose a dependency in tildewidedwhile remaining in tildewided.
lemma all dependencies in tildewided for all phave a lean derivation tree.
proof we show that given a dependency d tildewided and any derivation tree of d hatwided we can find a lean derivation tree.
the proof is by induction on the cardinality of the dependency d then by induction on the size of the initial derivation tree.
the base case where the tree is just composed of rule refl is immediate.
otherwise the tree starts by an application of rule trans to some dependency d0 d and subtrees with conclusions di hatwided i for i d0.
we are going to showthat for each i d0 we can find a lean derivation tree with conclusion d i hatwided i for some dependency d i di.
then by applying rule trans ond0and these trees we get a derivation tree for a dependency uniontext id i hatwided i .
due to canonisation as uniontext id i uniontext idi d we must have uniontext id i d and thus we have a lean derivation for d. we now prove the existence of suitable dependencies d i. a dependency in hatwided i but not in tildewided i is either irrelevant or implied by another dependency in tildewided i .
sincedi d and the dependency dis still in tildewided the dependency di has not been removed due to irrelevancy either.
therefore by definition of canonisation we can find d i tildewided i such that d i di.
ifdi d i we find a lean derivation tree by applying the induction hypothesis of the inner induction.
otherwise the cardinality of d iis strictly smaller than the cardinality of d. hence we can apply the induction hypothesis of the outer induction to get the lean derivation tree.
theorem there exists a cover ccontaining only broken sets with an explanation p d c such that all dependencies in d for are either self dependencies or fully new dependencies.
proof starting from the cover composed of all possible broken sets we can associate to each of these sets an explanation and to each dependency in this explanation we can associate a lean derivation tree by lemma .
adapting the proof of lemma if one of these derivation trees start by a rule trans involving a dependency which is not new in the non flattened repository we can build a new cover by removing the corresponding broken set and adding other broken sets with the explanation where the tree has been replaced by all immediate subtrees above the rule trans .
we are replacing subtrees by strictly smaller subtrees.
hence the process eventually terminates yielding a cover for which no associated derivation trees start with a dependency which is not new in the non flattened repository.
after this first transformation we mimic again the argument of the proof of lemma to remove all flattened dependencies dthat are not new after each removal it may be necessary to add some self dependencies which are important for weak co installability.
pruning conflicts and self dependencies we can further restrict the search space when enumerating minimal explanations as follows.
if a minimal explanation contains a conflict and self dependencies for the two packages in conflict then it is reduced to this conflict and these dependencies.
besides this conflict must be a new conflict that is a pair of packages and both inp p such that c c .
otherwise the minimal explanation is composed of fully new dependencies of conflicts that connect a new dependency to either another fully new dependency or a package in p p and of the self dependencies for such packages.
so we can first inspect all new conflicts to capture the first kind of explanations and then drop all conflicts and self dependencies that do not correspond to the configuration of the second kind before continuing to enumerate explanations.c.
simplifying covers a cover containing only broken sets with minimal explanations may be further simplified using a notion of implication that generalises to sets of packages the strong dependencies introduced in .
we say that a set of packages s1implies a set of packages s2 written s1 s2 ifs1is installable and every healthy installation containing s1also contains s2.
if in a cover c 1 ... n there is some broken set i that implies another broken set jin the old repository then c i is still a cover and we can safely drop i. computing implications may be expensive though so we only implement an approximation of this simplification step in our algorithm that turns out to provide a good compromise in practice and is based on the following notions.
we say that a broken set 1implies pointwise another broken set 2if for every package 2 2there exists a package 1 1such that 1 implies 2 in the old repository.
we approximate the implication between packages by following only conjunctive dependencies this can be done with the following rules.
conj refl conj trans 1 ... n d 1 ... n v. p utting it all together the algorithm the algorithm takes as input the old repository p d c and the new repository p d c .
it starts by computing the corresponding reduced repositories p tildewiderd tildewiderc and p tildewided tildewidec as described in section iv a1 and initialises a sat solver with their encodings as described in since our solver allows to check co installability without rebuilding the encodings such checks are blazingly fast and can be performed at little cost in the rest of the process.
we then progressively build a cover in two phases corresponding to the observations of section iv b3.
broken sets corresponding to new conflicts.
we first find the pairs of packages 1 2 tildewidec tildewiderc which are broken sets.
for each of these pairs we add to the cover a broken set of minimal cardinality contained in it.
other broken sets.
we first compute a subrepository p d1 c1 of p tildewided tildewidec that contains all relevant minimal explanations by removing from p tildewided tildewidec the conflicts and dependencies that may be dropped according to section iv b3.
for this we start by computing the fully new dependencies section iv b2 and the subset c1 tildewidecof conflicts that involve at least a package in a new dependency and whose other package is either in p p or belongs to a new dependency as well.
we then remove fully new dependencies that are irrelevant with respect to c1and finally add selfdependencies on packages in p p with a conflict.
this gives us the repository p d1 c1 .
to find the explanations we are interested in we enumerate all dependency functions d2pointwise included in d1suchthat all dependencies in d2are connected through conflicts in c1 using a backtracking algorithm.
in order not to consider all permutations of dependencies we keep track of two sets of dependencies when building explanations the positive set of dependencies that are part of the explanation a negative set of dependencies that are not going to be part of any further explanation.
when backtracking we add the dependency to the negative set as all explanations it may be involved into have already been considered.
the process starts with the two sets being empty.
we add a first dependency to the positive set then repeatedly add dependencies connected to other dependencies in the positive sets.
all possible combinations are considered through backtracking.
at each step the set of all packages d2 e atio slash included in the positive set is a candidate broken set .
each time a minimum broken set is built it is added to the cover.
final simplification.
finally we identify all broken sets that can be shown to imply pointwise another broken set following only conjunctive dependencies and remove them to obtain the final cover section iv c .
vi.
e xplaining broken sets as said in section ii d3 we associate to each broken set a graph called full explanation which is computed as follows.
we run a sat solver on the unsatisfiable problem obtained by encoding the new repository and asserting the packages in and then extract an unsatisfiable core .
since in our encoding each boolean clause of the sat problem corresponds exactly to one dependency or conflict the unsatisfiable core can be immediately turned into an explanation.
then we annotate appropriately each dependency and conflict in this explanation a dependency can be present in both the old and the new repository or just in one of them the possible targets of a dependency might satisfy it in the old repository the new one or both similarly a conflict might be between all possible versions of a pair of packages between one version of a package and any version of the other or between two precise versions of the packages.
as explained in section ii d3 different line styles distinguish these cases.
vii.
r elated works ensuring the correct behaviour of components when composed into an assembly is a fundamental concern for modern software architectures and has been extensively studied dynamic aspects of the components are considered to ensure certain properties of their composition to automatically detect behavioural incompatibilities from the component source code or to deploy and upgrade such systems .
research on static inter module dependencies is also largely performed at the level of the component source code with dependencies automatically extracted from huge sets of source code and then used to predict failures or to guide automated testing some work like manually analyse the architectural dependencies to improve the modularisation of the software architecture on problemspython envisageplugins mayavi2 python enable python traitsbackendqt x magit x liboss salsa asound2 xul ext adblock plussoftware properties kdemdbtools dev x libqt4 phononkredentials x kid3 qt libdap dev libcurl4 openssl devliboauth dev heimdal dev grass devlibgdal1 dev code saturne includelibhdf4 devlibdnet devbinutils gold lazarus x fpc libjpeg62 dev libhdf5 lam .
.
x cdoparaview x gnudatalanguagelibhdf5 serial .
.4libopal deviceape browser x libgdchart gd2 xpm dev x libkio5 x libcurl4 gnutls dev libiodbc2 dev x fp units multimedia libgcal dev libmagplus3 x libxqilla dev libxerces c2 dev libmedc dev libsc dev x libcups2 dev x gnome core devel x libgl1 mesa swx11 gnome desktop environment x libgpod4 nogtk filelight l10n kde l10n cavalencia x mingw32 ocaml x mingw32 binutilsphp apc php5 xcache speechd el emacs23 lucid x capplets data gnome utils x cyrus dev .
x sa learn cyrus harden servers cyrus doc .
x kolab cyrus commoncyrus imapd .
bindfs x loop aes utils smcroute pimdgnome core gpe login x libamrita2 ruby1.
x libamrita ruby1.8bcfg2 server fam x libqwt5 qt4 dev libqwt devgnome api docs libclutter gtk .
doc zabbix server pgsql x zabbix proxy mysql x texmacs common texmacs extra fontsw3c dtd xhtml w3c markup validatorlibgdb dev x gdb minimal kbd gcpeggkcc heimdal clients libodbc ruby1.
.
x libodbc ruby dococtave3.
headers x libreiser4 dev libcdb dev libowfat dev policycoreutils mcstranspacemaker x cluster agents linkchecker python dnspythonocsinventory reportslibapache2 mod php5filter x libgd2 noxpm libcgi application extra plugin bundle perl x libgd gd2 noxpm perl libgnuift0 dev x graphicsmagick libmagick dev compatgnat .
ahven dbg x fso gpsd kde window manager obexd server gnome session libdb4.
dev libdb devldtp python pyatspi fig.
.
problematic upgrades in debian i386 stable vs. testing february tdsodbc libiodbc2 a emacs23 nox emacs23 speechd el eieio b fig.
.
actual broken sets and their full explanationssmall enough some components to avoid the need for automation.
our work is part of a recent research area that focuses on the properties of large component repositories that can be established automatically without looking at the source code of the components and without testing them it is only assumed that each component carries with itself a small amount of metadata describing what the component provides and what it requires to be deployed and run.
in most frameworks determining whether a single component can be installed at all is an np complete problem albeit the concrete instances arising in real world systems like gnu linux distributions eclipse plugins or osgi component repositories turn out to be tractable .
for the maintenance of component repositories though more sophisticated analyses are required.
this includes identifying for each component the other components that it absolutely needs those that it can never be installed with and what component upgrades are more likely to impact a repository .
an important advance in this area was made in that shows how to efficiently extract from any component repository a much smaller co installability kernel that allows to identify directly the sets of components that cannot be installed together.
this makes it possible for a quality assurance team to quickly find component incompatibilities in a given repository .
the present work is a significant step forward in this direction as it provides for the first time a means to identify how coinstallability evolves from one version of the repository to another and provides simple and effective explanations for quality assurance teams that want to understand why some components that were coinstallable become all of a sudden incompatible.
while the examples in this paper all come from the world of gnu linux distributions the algorithm presented can be applied directly to other frameworks like eclipse plugins or osgi component repositories.
viii.
c onclusion we have shown that it is possible to determine how coinstallable sets of packages change across repository evolutions and developed an algorithm that computes efficiently a concise representation of the upgrade issues introduced by such changes.
we have also shown how to present concisely all the information relevant for understanding the origin and the importance of an upgrade issue with an informative graphical explanation.
a tool implementing the algorithm presented in this paper is available as free software and is able to process the evolution between two major releases of the debian gnu linux distribution and compute all the explanations in just a few seconds.
these results make it possible to integrate seamlessly this analysis in a repository development process.