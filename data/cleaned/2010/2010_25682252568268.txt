understanding javascript event based interactions saba alimadadi sheldon sequeira ali mesbah karthik pattabiraman electrical and computer engineering university of british columbia vancouver bc canada saba sheldon amesbah karthikp ece.ubc.ca abstract web applications have become one of the fastest growing types of software systems today.
despite their popularity understanding the behaviour of modern web applications is still a challenging endeavour for developers during development and maintenance tasks.
the challenges mainly stem from the dynamic event driven and asynchronous nature of the javascript language.
we propose a generic technique for capturing low level event based interactions in a web application and mapping those to a higher level behavioural model.
this model is then transformed into an interactive visualization representing episodes of triggered causal and temporal events related javascript code executions and their impact on the dynamic dom state.
our approach implemented in a tool called clematis allows developers to easily understand the complex dynamic behaviour of their application at three di erent semantic levels of granularity.
the results of our industrial controlled experiment show that clematis is capable of improving the task accuracy by while reducing the task completion time by .
categories and subject descriptors d. .
testing and debuggingtracing d. .
distribution maintenance and enhancement general terms design algorithms experimentation keywords program comprehension event based interactions javascript .
introduction javascript is widely used today to create interactive modern web applications that replace many traditional desktop applications.
however understanding the behaviour of web permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.applications is a challenging endeavour for developers .
program comprehension is known to be an essential step in software engineering consuming up to of the e ort in software maintenance and analysis activities.
first the weakly typed and highly dynamic nature of javascript makes it a particularly di cult language to analyze.
second javascript code is extensively used to seamlessly mutate the document object model dom at runtime.
this dynamic interplay between two separate entities namely javascript and the dom can become quite complex to follow .
third javascript is an event driven language allowing developers to register various event listeners on dom nodes.
while most events are triggered by user actions timing events and asynchronous callbacks can be fired with no direct input from the user.
to make things even more complex a single event can propagate on the dom tree and trigger multiple listeners according to the event capturing andbubbling properties of the event model .
unfortunately despite its importance and challenges there is currently not much research dedicated to supporting program comprehension for web applications .
popular tools such as firebug and chrome devtools are limited in their capabilities to support web developers e ectively.
in this paper we present a generic non intrusive technique called clematis for supporting web application comprehension.
through a combination of automated javascript code instrumentation and transformation we capture a detailed trace of a web application s behaviour during a particular user session.
our technique transforms the trace into an abstract behavioural model preserving temporal and causal relations within and between involved components.
the model is then presented to the developers as an interactive visualization that depicts the creation and flow of triggered events the corresponding executed javascript functions and the mutated dom nodes within each episode.
to the best of our knowledge we are the first to provide a generic technique for capturing low level event based interactions in a javascript application and mapping and visualizing those interactions as higher level behavioural models.
our work makes the following key contributions we propose a generic technique for capturing and presenting the complex dynamic behaviour of web applications.
in particular our technique captures the consequences of javascript and dom events in terms of the executed javascript code including the functions that are called indirectly through event propagation on the dom tree.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm extracts the source and target relations for asynchronous events i.e.
timing events and xmlhttprequest requests callbacks.
identifies and tracks mutations to the dom resulting from each event.
we build a novel model for capturing the event driven interactions as well as an interactive visual interface supporting the comprehension of the program through three di erent semantic levels of zooming granularity.
we implement our technique in a generic open source tool called clematis which does not modify the web browser is independent of the server technology and requires no extra e ort from the developer to use.
we empirically evaluate clematis through two controlled experiments comprising users in total.
one of the studies is carried out in a lab environment while the other is carried out in an industrial setting.
the results of the industrial experiment show that clematiscan reduce the task completion time by while improving the accuracy by .
.
related work ui feature location.
li and wohlstadter present a tool called script insight to locate the implementation of a dom element in javascript code.
similarly maras et al.
propose a technique for deriving the implementation of a ui feature on the client side.
while similar to our work at a high level in these approaches the user needs to select a visible dom element and its relevant behaviour in order to investigate its functionality.
this manual e ort can easily frustrate the user in large applications.
further these techniques are not concerned with capturing event based interactions.
finally the model they derive and present to the user contains low level information and noise which can adversely influence program comprehension.
capture and replay.
related to our work are capture and replay techniques for web applications .
the goal in most of these techniques is to find a deterministic way of replaying the same set of user events for debugging purposes.
instead of simply replaying recorded events our approach aims at detecting causal and temporal event based interactions and linking them to their impact on javascript code execution and dom mutations.
visualization.
there are many tools that use visualization to improve the process of understanding the behaviour of software applications.
for instance extraviz visualizes dynamic traces of java applications to assist with program comprehension tasks.
however their approach does not concern itself with building a model of the web application while ours does.
zaidman et al.
propose a firefox add on called firedetective which captures and visualizes a trace of execution on both the client and the server side.
their goal is to make it easier for developers to understand the link between client and server components which is di erent from our approach which aims to make it easier for developers to understand the client side behaviour of the web application.
firecrystal is another firefox extension that stores the trace of a web application in the browser.
it then visualizes the events and changes to the dom in a timeline.
firecrystal records the execution trace selectively similar toour work.
but unlike clematis firecrystal does not capture the details about the execution of javascript code or asynchronous events.
another limitation of firecrystal is that it does not link the triggering of events with the dynamic behaviour of the application as clematis does.
dynaria focuses on investigating the structural and quality aspect of the code.
while dynaria captures a trace of the web application clematis facilitates the process of comprehending the dynamic behaviour using a high level model and visualization based on a semantically partitioned trace.
.
challenges and motivation modern web applications are largely event driven.
their client side execution is normally initiated in response to a user action triggered event a timing event or the receipt of an asynchronous callback message from the server.
as a result web developers encounter many program comprehension challenges in their daily development and maintenance activities.
we use an example presented in figures to illustrate these challenges.
note that this is a simple example and these challenges are much more potent in large and complex web applications.
challenge event propagation.
the dom event model makes it possible for a single event fired on a particular node to propagate through the dom tree hierarchy and indirectly trigger a series of other event handlers attached to other nodes.
there are typically two types of this event propagation in web applications with bubbling enabled an event first triggers the handler of the deepest child element on which the event was fired and then it bubbles up and triggers the parents handlers.
when capturing is enabled the event is first captured by the parent element and then passed to the event handlers of children with the deepest child element being the last.
hence a series of lower level event handlers executed during the capturing and bubbling phases may be triggered by a single user action.
the existence or the ordering of these handlers is often inferred manually by the developer which becomes more challenging as the size of the code dom tree increases.
example.
consider the sample code shown in figures .
figure represents the initial dom structure of the application.
it mainly consists of a fieldset containing a set of elements for the user to enter their email address to be registered for a service.
the javascript code in figure partly handles this submission.
when the user clicks the submit button a message appears indicating that the submission was successful.
this message is displayed from within the event handler submissionhandler line which is attached to the button on line of figure .
however after a few seconds the developer observes that the message unexpectedly starts to fade out.
in the case of this simple example she can read the whole code and find out that the click on the submit button has bubbled up to its parent element namely fieldset .
closer inspection reveals that fieldset s anonymous handler function is responsible for changing the value of the same dom element through a settimeout function lines in figure .
in a more complex application the developer may be unaware of the existence of the parent element its registered handlers or the complex event propagation mechanisms such as bubbling and capturing.
challenge asynchronous events.
web browsers provide a single thread for web application execution.
to cir body fieldset class registration email input type text id email button id submitbtn submit button div id regmsg div fieldset body figure initial dom state of the running example.
cumvent this limitation and build rich responsive web applications developers take advantage of the asynchronous capabilities o ered by modern browsers such as timeouts andxmlhttprequest xhr calls.
asynchronous programming however introduces an extra layer of complexity in the control flow of the application and adversely influences program comprehension.
timeouts events can be registered to fire after a certain amount of time or at certain intervals in javascript.
these timeouts often have asynchronous callbacks that are executed when triggered.
in general there is no easy way to link the callback of a timeout to its source which is important to understand the program s flow of execution.
xhr callbacks xhr objects are used to exchange data asynchronously with the server without requiring a page reload.
each xhr goes through three main phases open send and response .
these three phases can be scattered throughout the code.
further there is no guarantee on the timing and the order of xhr responses from the server.
as in the case of timeouts mapping the functionality triggered by a server response back to its source request is a challenging comprehension task for developers.
example.
following the running example the developer may wish to further investigate the unexpected behaviour the message has faded out without a direct action from the developer.
the questions that a developer might ask at this point include what exactly happened here?
and what was the source of this behaviour?
.
by reviewing the code she can find out that the source of this behaviour was the expiration of a timeout that was set in line of figure by the anonymous handler defined in lines .
however the callback function defined on line of figure executes asynchronously and with a delay long after the execution of the anonymous handler function has terminated.
while in this case the timing behaviour can be traced by reading the code this approach is not practical for large applications.
a similar problem exists for asynchronous xhr calls.
for instance the anonymous callback function of the request sent in the informserver function line figure updates the dom line .
challenge implications of events.
another challenge in understanding the flow of web applications lies in understanding the consequences of in directly triggered events.
handlers for a propagated dom event and callback functions of timeouts and xhr requests are all javascript functions.
any of these functions may change the observable state of the application by modifying the dom.
currently developers need to read the code and make the connections mentally to see how an event a ects the dom state which is quite challenging.
in addition there is no easy way of pinpointing the dynamic changes made to the dom state as a result of event based interactions.
inferring the implications of events is therefore a significant challenge for developers.
document .ready function submitbtn .click submissionhandler fieldset .registration .click function settimeout clearmsg ... 7function submissionhandler e regmsg .html submitted !
9var email email .val if isemailvalid email informserver email submitbtn .attr disabled true ... 16function informserver email .get register email function data regmsg .append data ... 22function clearmsg regmsg .fadeout figure javascript code of the running example.
example.
after the submitbtn button is clicked in the running example a confirmation message will appear onscreen and disappear shortly thereafter lines figure .
additionally the attributes of the button are altered to disable it line .
it can be di cult to follow such domaltering features in an application s code.
.
approach in this section we describe our approach for addressing the challenges mentioned in the previous section.
the overall process consists of the following main steps first our technique captures a fine grained trace of all semantically related event based interactions within a web application s execution in a particular user session.
the collection of this detailed trace is enabled through a series of automated javascript transformations section .
.
next a behavioural model is extracted from the information contained within the trace.
the model structures the captured trace and identifies the implicit causal and temporal relationships between various event based interactions section .
.
finally based on the inferred behavioural model our approach generates an interactive web based user interface visualizing and connecting all the pieces together.
this interactive visualization assists developers during their web application comprehension and maintenance tasks section .
.
we describe each step further below.
our technical report contains a more elaborate description of the technical details of the approach.
.
javascript transformation and tracing to automatically trace semantically related event based interactions and their impact we transform the javascript code on the fly.
our approach generates a trace comprising multiple trace units.
a trace unit contains information acquired through the interception of a particular event based interaction type namely dom events timing events xhr369calls and callbacks function calls and dom mutations.
the obtained trace is used to build a behavioural model as described in subsection .
.
interposing on dom events.
there are two ways event listeners can be bound to a dom element in javascript.
the first method is programatically using the dom level 1e.click handler or dom level e.addeventlistener methods in javascript code.
to record the occurrence of such events our technique replaces the default registration of these javascript methods such that all event listeners are wrapped within a tracing function that logs the occurring event s time type and target.
the second and more traditional way to register an event listener is inline in the html code e.g.
div onclick handler .
the e ect of this inline assignment is semantically the same as the first method.
our technique interposes on inline registered listeners by removing them from their associated html elements annotating the html elements and re registering them using the substituted addeventlistener function.
this way we can handle them similarly to the programmatically registered event handlers.
capturing timeouts and xhrs.
for tracing timeouts we replace the browser s settimeout method and the callback function of each timeout with wrapper functions which allow us to track the instantiation and resolution of each timeout.
a timeout callback usually happens later and triggers new behaviour and thus we consider it as a separate component than a settimeout .
we link these together through a timeout id and represent them as a causal connection later.
in our model we distinguish between three di erent components for the open send and response phases of each xhr object.
we intercept each component by replacing the xmlhttprequest object of the browser.
the new object captures the information about each component while preserving its functionality.
recording function traces.
to track the flow of execution within a javascript based application we instrument three code constructs namely function declarations return statements and function calls .
each of these code constructs are instrumented di erently as explained below.
function declarations tracing code is automatically added to each function declaration allowing us to track the flow of control between developer defined functions by logging the subroutine s name arguments and line number.
in case of anonymous functions the line number and source file of the subroutine are used as supplementary information to identify the executed code.
return statements apart from reaching the end of a subroutine control can be returned back to a calling function through a return statement.
there are two reasons for instrumenting return statements to accurately track nested function calls and to provide users with the line numbers of the executed return statements.
function calls in order to report the source of a function invocation our approach also instruments function calls.
when instrumenting function calls it is important to preserve both the order and context of each dynamic call.
to accurately capture the function call hierarchy we modify function calls with an inline wrapper function.
this allows us to elegantly deal with two challenging scenarios.
first when multiple function calls are executed from within a single line of javascript code it allows us to infer the orderof these calls without the need for complex static analysis.
second inline instrumentation enables us to capture nested function calls.
dom mutations.
information about dom mutations can help developers relate the observable changes of an application to the corresponding events and javascript code.
to capture this important information we introduce an observer module into the system.
this information is interleaved with the logged information about events and functions enabling us to link dom changes with the javascript code that is responsible for these mutations.
.
capturing a behavioural model we use a graph based model to capture and represent a web application s event based interactions.
the graph is multi edge and directed.
it contains an ordered set of nodes called episodes linked through edges that preserve the chronological order of event executions.1in addition causal edges between the nodes represent asynchronous events.
we describe the components of the graph below.
episode nodes.
an episode is a semantically meaningful part of the application behaviour initiated by a synchronous or an asynchronous event.
an event may lead to the execution of javascript code and may change the dom state of the application.
an episode node contains information about the static and dynamic characteristics of the application and consists of three main parts .source this is the event that started the episode and its contextual information.
this source event is either a dom event a timeout callback or a response to an xhr request and often causes a part of the javascript code to be executed.
.trace this includes all the functions that are executed either directly or indirectly after the source event occurs.
a direct execution corresponds to functions that are called from within an event handler on a dom element.
an indirect execution corresponds to functions that get called due to the bubbling and capturing propagation of dom events.
the trace also includes all a synchronous events that were created within the episode.
all the invoked functions and initiated events are captured in the trace part and their original order of execution and dependency relations are preserved.
.result this is a section in each episode summarizing the changes to the dom state of the application.
these changes are caused by the execution of the episode trace and are usually observable by the end user.
edges.
in our model edges represent a progression of time and are used to connect episode nodes.
two types of edges are present in the model temporal the temporal edges connect one episode node to another indicating that an episode succeeded the previous one in time.
causal these edges are used to connect di erent components of an asynchronous event e.g.
timeouts and xhrs.
a causal edge from episode stodindicates episode dwas caused by episode sin the past.
1because javascript is single threaded on all browsers the events are totally ordered in time.370figure top menu of clematis.
bottom overview of a captured story.
algorithm story creation input trace output story procedure createmodel begin g v e story ecurr eprev tu extractandsorttraceunits trace foreach tu2 tudo ifeprev eprev.ended tu.type episodesource then ecurr createepisode ecurr.source setepisodesource tu v v ecurr else if tu.type functiontrace eventhandler tu.type xhrc allback timeoutcallback episodeendcriteria then ecurr.trace ecurr.trace tu else if tu.type dommutation then ecurr.results ecurr.results tu ifepisodeendcriteriasatisfied then e e createtemporallink eprev ecurr eprev ecurr timeoutmap timeoutset timeoutcallback maptimeouttraceunits tu xhrmap xhropen xhrsend xhrcallback mapxhrtraceunits tu e e extractcausallinks timeoutmap xhrmap story buildstory g v e return story story.
the term story refers to an arrangement of episode nodes encapsulating a sequence of interactions with a web application.
di erent stories can be captured according to di erent features goals or use cases that need investigation.
algorithm takes the trace collected from a web application as input and outputs a story with episodes and the edges between them.
first the trace units are extracted and sorted based on the timestamp of their occurrence line .
next the algorithm iteratively forms new episodes and assigns trace units to the source trace and the result fields of individual episodes.
if it encounters a trace unit that could be an episode source i.e.
an event handler a timeout or an xhr callback a new episode is created lines and added to the list of nodes in the story graph line .
the encountered trace unit is added to the episode as its source line .
line shows di erent types of trace units that could be added to the trace field of the episode.
this trace is later processed to form the complete function call hierarchy as well as each function s relation with the events inside that episode.
next dom mutation units that were interleaved with other trace units are organized and linked to their respective episode lines .
an episode terminates semantically when the execution of the javascript code re lated to that episode is finished.
the algorithm also waits for a time interval to ensure that the execution of immediateasynchronous callbacks is completed line .
when all of the trace units associated with the source trace and result of the episode are assigned and the episode termination criteria are met a temporal edge is added to connect the recently created episode node to the previous one line .
the same process is repeated for all episodes by proceeding to the next episode captured in the trace line .
after all episodes have been formed the linkages between distant asynchronous callbacks those that did not complete immediately are extracted and added to the graph as causal edges lines .
finally the story is created based on the whole graph and returned lines .
.
visualizing the captured model in the final step our technique produces an interactive visualization of the generated model which can be used by developers to understand the behaviour of the application.
the main challenge in the visualization is to provide a way to display the model without overwhelming the developer with the details.
to this end our visualization follows a focus context technique that provides the details based on a user s demand.
the idea is to start with an overview of the captured story let the users determine which episode they are interested in and provide an easy means to drill down to the episode of interest.
with integration of focus within the context developers can semantically zoom into each episode to gain more details regarding that episode while preserving the contextual information about the story.
story map queries and bookmarking.
a menu bar is designed for the visualization that contains two main parts thestory map and the query mechanism figure top .
the story map represents a general overview of the whole story as a roadmap.
based on a user s interaction with the story e.g.
episode selection the episodes of interest are highlighted on the roadmap.
the query section enables users to search and filter the information visualized on the screen.
users can filter the episodes displayed on the screen by the episode types i.e.
event timeout or xhr .
they can also search the textual content of the events as well as the actual code.
moreover they have the option to bookmark one or more episodes while interacting with the target web application.
those episodes are marked with a star in the visualization to help users to narrow the scope and spot related episodes e.g.
episode in figure is bookmarked .
the episodes timing information is also shown.
semantic zoom levels.
the visualization provides semantic zoom levels.
the first level displays all of the371figure three semantic zoom levels in clematis.
top overview.
middle zoomed one level into an episode while preserving the context of the story.
bottom drilled down into the selected episode.
episodes in an abstracted manner showing only the type and the timestamp of each episode figure bottom .
when an episode is selected the view transitions into the second zoom level which presents an outline of the selected episode providing more information about the source event as well as a high level trace figure middle .
the trace at this level contains only the names of the invoked functions triggered events and dom mutations caused directly or indirectly by the source event.
the user can view multiple episodes to have a side by side comparison.
the final zoom level exhibits all the information embedded in each episode i.e.
detailed information about the source event the dom mutations caused by the episode and the low level trace.
the trace of an episode at this level includes a sequence diagram of the dynamic flow of all the invoked javascript functions and events within that episode.
upon request the javascript code of each executed function is displayed and highlighted figure bottom .table adapted comprehension activities.
activity description a1 investigating the functionality of a part of the system a2 adding to changing the system s functionality a3 investigating the internal structure of an artifact a4 investigating the dependencies between two artifacts a5 investigating the run time interaction in the system a6 investigating how much an artifact is used a7 investigating the asynchronous aspects of javascript a8 investigate the hidden control flow of event handling .
tool implementation clematis we implemented our approach in a tool called clematis which is freely available .
we use a proxy server to automatically intercept and inspect http responses destined for the client s browser.
when a response contains javascript code it is transformed by clematis .
we also use the proxy to inject a javascript based toolbar into the web application which allows the user to start stop capturing their interactions with the application.
the trace data collected is periodically transmitted from the browser to the proxy server in json format.
to observe low level dom mutations we build on and extend the javascript mutation summary library .
the model is automatically visualized as a web based interactive interface.
our current implementation does not capture the execution of javascript code that is evaluated using eval .clematis provides access to details of captured stories through a restful api.
more details may be found in our technical report .
.
controlled experiments to assess the e cacy of our approach we conducted two controlled experiments one in a research lab setting and the other in an industrial environment.
common design elements of both experiments are described in this section.
the next two sections are each dedicated to describing the specific characteristics and results of each experiment separately.
details of the tasks and questionnaires used for both experiments can be found in our technical report .
our evaluation aims at addressing the following research questions rq1 does clematis decrease the task completion duration for common tasks in web application comprehension?
rq2 does clematis increase the task completion accuracy for common tasks in web application comprehension?
rq3 for what types of tasks is clematis most e ective?
rq4 what is the performance overhead of using clematis?
is the overall performance acceptable?
.
experimental design the experiments had a between subject design i.e.
the subjects were divided into two groups experimental group using clematis and control group using other tools.
the assignment of participants to groups was done manually based on the level of their expertise in web development.
we used a point likert scale in a pre questionnaire to collect this information and distributed the level of expertise in a balanced manner between the two groups.
none of the participants had any previous experience with clematis and all of them volunteered for the study.
task design.
the subjects were required to perform a set of tasks during the experiment representing tasks normally used in software comprehension and maintenance ef 372table comprehension tasks used in study .
task description activity t1 locating the implementation of a feature modifying the doma1 a4 t2 finding the functions called after a dom event nested calls a1 a4 a5 t3.a locating the place to add a new functionality to a functiona2 a3 t3.b finding the caller of a function a4 a5 t4.a finding the functions called after a dom event nested calls bubbling a1 a4 a5 t4.b locating the implementation of a ui behaviora1 a3 a4 t5.a finding the functions called after a dom event bubbling capturing a1 a5 a8 t5.b finding the changes to dom resulting from a user actiona4 a5 t6.a finding the total number of sent xhrsa6 a7 t6.b finding if there exists an unresponded xhra4 a5 a7 forts.
we adapted the activities proposed by pacione et al.
which cover categories of common tasks in program comprehension to web applications by replacing two items.
the revised activities are shown in table .
we designed a set of tasks for each experiment to cover these activities.
tables and show the tasks for studies and accordingly.
because study was conducted in an industrial setting participants had limited time.
therefore we designed fewer tasks for this study compared to study .
independent variable iv .
this is the tool used for performing the tasks and has two levels clematis represents one level and other tools used in the experiment represent the other level e.g.
chrome developer tools firefox developer tools firebug .
dependent variables dv .
these are task completionduration which is a continuous variable and accuracy of task completion which is a discrete variable.
data analysis.
for analyzing the results of each study we use two types of statistical tests to compare dependent variables across the control and experimental groups.
independent samples t tests with unequal variances are used for duration and accuracy in study and for duration in study .
however the accuracy data in study was not normally distributed and hence we use a mann whitney u test for the analysis of accuracy in this study.
we use the statistical analysis package r for the analysis.
.
experimental procedure all experiments consisted of four main phases.
first the subjects were asked to fill a pre questionnaire regarding their expertise in the fields related to this study.
in the next phase the participants in the experimental group were given a tutorial on clematis .
they were then given a few minutes to familiarize themselves with the tool after the tutorial.
in the third phase each subject performed a set of tasks as outlined in tables and .
each task was given to a participant on a separate sheet of paper which included instructions for the task and had room for the participant s answer.
once completed the form was to be returned immediately and the subject was given the next task sheet.
this allowed us to measure each task s completion time accurately to answer rq1 and rq3.
to address rq2 and rq3 the accuracy of each task was later evaluated and marked from 0table comprehension tasks used in study .
task description activity t7 extracting the control flow of an event with delayed e ectsa1 a4 a5 a7 t8 finding the mutations in dom after an eventa1 a5 t9 locating the implementation of a malfunctioning featurea1 a2 a3 t10 extracting the control flow of an event with event propagationa1 a5 a8 to according to a rubric that we had created prior to conducting the experiment.
the design of the tasks allowed the accuracy of the results to be quantified numerically.
the tasks and the rubric are available in our technical report .
in the final phase participants filled out a post questionnaire form providing feedback on their experience with the tool used e.g.
limitations strength usability .
we categorized the qualitative data and present it in section .
.
.
experiment lab environment the first controlled experiment was conducted in a lab setting with students and postdocs at the university of british columbia ubc .
.
approach experimental design.
for this experiment both groups used mozilla firefox .
.
the control group used firebug .
.
.
we chose firebug in the control group since it is the de facto tool used for understanding editing and debugging modern web applications.2firebug has been used in other similar studies .
experimental subjects.
we recruited participants for the study females and males.
the participants were drawn from di erent educational levels undergraduate students master s students ph.d. students and postdoctoral fellow at ubc.
the participants represented different areas of software and web engineering and had skills in web development ranging from beginner to professional.
the tasks used in this study are enumerated in table .
experimental object.
we decided to use a web based survey application that was developed in our lab.
the application had modest size and complexity so that it could be managed within the time frame anticipated for the experiment.
yet it covered the common comprehension activities described in table .
experimental procedure.
we followed the general procedure described in section .
.
after filling the pre questionnaire form the participants in the control group were given a tutorial on firebug and had time to familiarize themselves with it though most of them were already familiar with firebug.
.
results duration.
to address rq1 we measured the amount of time minutes seconds spent on each task by the participants and compared the task durations between clematisand firebug using a t test.
according to the results of the test there was a statistically significant di erence pvalue .
in the durations between clematis m sd and firebug m sd .
2firebug has over million active daily users mozilla.org en us firefox addon firebug statistics usage 373to investigate whether certain categories of tasks benefit more from using clematis rq3 we tested each task separately.
the results showed improvements in time for all tasks.
the improvements were statistically significant for tasks and and showed a and average time reduction with clematis respectively.
the results show that on average participants using clematis require less time than than the control group using firebug for performing the same tasks.
accuracy.
the accuracy of answers was calculated in percentages.
we compared the accuracy of participants answers using a t test.
the results were again in favour of clematis and were statistically significant p .
clematis m sd and firebug m sd .
as in the duration case individual t tests were then performed for comparing accuracy per task related to rq3 .
clematis showed an increased average accuracy for all tasks.
further the di erence was statistically significant in favour ofclematis for task and subtasks .a and .a.
the results show that participants using clematis achieved higher accuracy than participants in the control group .w e discuss the implications of these results in section .
.
experiment industrial to investigate clematis s e ectiveness in more realistic settings we conducted a second controlled experiment at a large software company in vancouver where we recruited professional developers as participants and used an opensource web application as the experimental object.
.
approach experimental design.
similar to the first experiment the participants were divided into experimental and control groups.
the experimental group used clematis throughout the experiment.
unlike the previous experiment members of the control group were free to use the tool of their choice for performing the tasks.
the intention was for the participants to use whichever tool they were most comfortable with.
participants used google chrome s developer tools used firefox s developer tools and used firebug.
experimental subjects.
we recruited developers from a large software company in vancouver females and males.
they were to years old and had medium to high expertise in web development.
task design.
for this experiment we used fewer but more complex tasks compared to the first experiment.
we designed tasks spanning the categories following the control flow understanding event propagation detecting dom mutations locating feature implementation and determining delayed code execution using timeouts.
experimental object.
phormer is an online photo gallery in php javascript css and xhtml.
it provides features such as uploading commenting rating and displaying slideshows for users photos.
it contains typical mechanisms such as dynamic dom mutation asynchronous calls xhr and timeouts and event propagation.
phormer has around lines of javascript php and css code in total.
it was rated .
star on sourceforge and had over downloads at the time of conducting the experiment.
experimental procedure.
we followed the same procedure described in .
with one di erence the participants t7 ctrlt7 expt8 ctrlt8 expt9 ctrlt9 expt10 ctrlt10 exptotal ctrltotal expduration mm ss figure notched box plots of task completion duration data per task and in total for the control and experimental groups lower values are desired .
in the control group were not given any tutorial regarding the tool they used throughout the experiment as they were all proficient users of the tool of their choice.
.
results box plots of task completion duration and accuracy per task and in total for the control ctrl and experimental exp groups are depicted in figures and respectively.
duration.
similar to the previous experiment we ran a set of t tests for the total task duration as well as for the time spent on individual tasks.
the results of the tests showed a statistically significant di erence p value .
between the experimental group using clematis m sd and the control group m sd in terms of total task completion duration.
the results showed improvements in duration when using clematis for all four tasks.
we found significant di erences in favour of clematisfor tasks t7 t8 and t9.
the results show that developers using clematis took less time on all tasks compared to developers in the control group.
accuracy.
we used mann whitney u tests for comparing the results of task accuracy between the control and the experimental group since the data was not normally distributed.
for the overall accuracy of the answers the tests revealed a statistically significant di erence with high confidence p value .
between clematis m sd and other tools m sd .
we then performed the comparison between individual tasks.
again for all tasks the experimental group using clematis performed better on average.
we observed statistical significant improvements in the accuracy of developers using clematis for tasks t7 t8 and t10.
the results show that developers using clematis performed more accurately across all tasks by on average compared to developers in the control group.
t7 ctrlt7 expt8 ctrlt8 expt9 ctrlt9 expt10 ctrlt10 exptotal ctrltotal exp020406080100accuracy figure notched box plots of task completion accuracy data per task and in total for the control and experimental groups higher values are desired .
.
performance overhead with respect to rq4 there are two sources of performance overhead instrumentation overhead and execution overhead.
the former pertains to the overhead incurred due to the instrumentation code added by clematis while the latter pertains to the overhead of processing the trace and constructing the model.
we do not measure the overhead of visualization as this is dependent on the user task performed.
phormer the experimental object in study was used to collect performance measurements over one minute trials.
the results were as follows instrumentation overhead.
average delays of .
and .
seconds were experienced for pre and post processing phases with clematis respectively.
and a .
ms additional delay was noticed for each page.
on average each captured episode occupies .
kb within our trace.
execution overhead.
for processing one minute of activity with phormer clematis experienced an increase of .
ms .
ms and .
ms for dom events timeouts and xhrs respectively.
based on our experiments there was no noticeable delay for end users when interacting with a given web application through clematis .
.
discussion .
task completion duration task completion duration is a measure of task performance.
therefore clematis improves web developers performance by significantly decreasing the overall time required to perform a set of code comprehension tasks rq1 .
dynamic control flow.
capturing and bubbling mechanisms are pervasive in javascript based web applications and can severely impede a developer in understanding the dynamic behaviour of an application.
these mechanisms also complicate the control flow of an application as described in section .
our results show that clematis significantly reduces the time required for completing tasks that involve a combination of nested function calls event prop agation and delayed function calls due to timeouts within a web application t2 t5.a and t7 .
hence clematis makes it more intuitive to comprehend and navigate the dynamic flow of the application rq3 .
one case that needs further investigation is t10.
this task mainly involves following the control flow when most of the executed functions are invoked through event propagation.
the results of this task indicate that although usingclematis caused an average of reduction in task completion duration the di erence was not statistically significant.
however closer inspection of the results reveals that the answers given using clematis for t10 are more accurate in average.
this huge di erence shows that many of the developers in the control group were unaware of occurrences of event propagation in the application and terminated the task early.
hence they scored significantly lower than the experimental group in task accuracy and still spent more time to find the inaccurate answers.
feature location.
locating features finding the appropriate place to add a new functionality and altering existing behaviour are a part of comprehension maintenance and debugging activities in all software tools not only in web applications.
the results of study suggested that clematisdid reduce the average time spent on the tasks involving these activities t1 t3 t4.b but these reductions were not statistically significant.
these tasks mostly dealt with static characteristics of the code and did not involve any of the features specific to javascript based web applications.
study however involved more complicated tasks in more realistic settings.
t9 represented the feature location activity in this study and the results showed that using clematisimproved the average time spent on this task by .
thus we see that clematis speeds up the process of locating a feature or a malfunctioning part of the web application rq3 .
state of the dom.
the final category of comprehension activities investigated in this work is the implications of events on the state of the dom.
results of study displayed a significant di erence in duration of the task involving finding dom mutations in favour of clematis t5 .
the results of study further confirmed the findings of study by reducing the duration in almost half t8 .
thus clematisaids understanding the behaviour of web applications by extracting the mutated elements of the dom visualizing contextual information about the mutations and linking the mutations back to the corresponding javascript code rq3 .
.
task completion accuracy task completion accuracy is another metric for measuring developers performance.
according to the results of both experiments clematis increases the accuracy of developers actions significantly rq2 .
the e ect is most visible when the task involves event propagation rq3 .
the outcome of study shows that clematis addresses challenge described in section in terms of both time and accuracy t5.a .
study further indicates that clematis helps developers to be more accurate when faced with tasks involving event propagation and control flow detection in javascript applications and improvement for t7 and t10 respectively .
for the remaining tasks of study the accuracy was somewhat though not significantly improved.
we believe this is because of the simplistic design of the experimental375object used in study as well as the relative simplicity of the tasks.
this led us towards the design of study with professional developers as participants and a third party web application as the experiment object in the evaluation of clematis .
according to the results of study clematis significantly improves the accuracy of completion of tasks t8 that require finding the implications of executed code in terms of dom state changes rq3 .
this is related to challenge as described in section .
for the feature location task t9 the accuracy results were on average slightly better with clematis .
however the experimental group spent less time on the task compared to the control group.
this is surprising as this task is common across all applications and programming languages and we anticipated that the results for the control group would be comparable with those of the experimental group.
.
consistent performance looking at figures and it can be observed that using clematis not only improves both duration and accuracy of individual and total tasks but it also helps developers to perform in a much more consistent manner.
the high variance in the results of the control group shows that individual di erences of developers or tools in study influence their performance.
however the low variance in all the tasks for the experimental group shows that clematis helped alldevelopers in the study to perform consistently better by making it easier to understand the internal flow and dependency of event based interactions.
.
participants feedback we analyzed the qualitative data obtained through the post questionnaire forms.
overall the feedback was very positive.
the main features that the participants found most useful were the semantic zooming presenting the overview first and providing more details on demand visualizing the hierarchy of functions and events in the customized sequence diagram linking the visualization back to javascript code and extracting dom mutations per event.
the participants also requested for a number of features to be included in future versions of the tool.
these features included filtering and query options for dom mutations ability to attach notes to bookmarked episodes and integrating clematis with debugging techniques such as breakpoints.
overall according to two of our industrial participants clematis is helpful and easy to use and very useful.
a lot of potential for this tool!
.
.
threats to validity internal threats.
the first threat is that di erent levels of expertise in each subject group could a ect the results.
we mitigated this threat by manually assigning the subjects to experimental and control groups such that the level of expertise was balanced between the two groups.
the second threat is that the tasks in the experiment were biased towards clematis .
we eliminated this threat by adopting the tasks from a well known framework of common code comprehension tasks .
a third threat arises from the investigators bias towards clematis when rating the accuracy of subjects answers.
we addressed this concern by developing an answer key for all the tasks before conducting the experiments.
a similar concern arises regarding the task completion duration measurements.
we mitigated thisthreat by presenting each task to subjects on a separate sheet of paper and asking them to return it upon completion.
the duration of each task was calculated from the point a subject received the task until they returned the paper to the investigators thus eliminating our bias in measuring the time and the subjects bias in reporting the time .
finally we avoided an inconsequential benchmark by choosing a tool for the control group in study that was stable and widelydeployed namely firebug.
in study the developers in the control group were given the freedom to choose any tool they preferred and had experience with .
external threats.
an external threat to validity is that the tasks used in the experiment may not be representative of general code comprehension activities.
as mentioned above we used the pacione s framework and thus these tasks are generalizable.
a similar threat arises with the representativeness of the participants.
to address this threat we used both professional web developers and students postdocs with previous web development experience.
reproducibility.
as for replicating our experiments clematis the experimental object phormer and the details of our experimental design e.g.
tasks and questionnaires are all available making our results reproducible.
.
concluding remarks modern web applications are highly dynamic and interactive and o er a rich experience for end users.
this interactivity is made possible by the intricate interactions between user events javascript code and the dom.
however web developers face numerous challenges when trying to understand these interactions.
in this paper we proposed a portable and fully automated technique for relating low level interactions in javascript based web applications to high level behaviour.
we proposed a behavioural model to capture these event interactions and their temporal and causal relations.
we presented a novel interactive visualization mechanism based on focus context techniques for presenting these complex event interactions in a more comprehensible format to web developers.
our approach is implemented in a code comprehension tool called clematis .
the evaluation of clematis points to the e cacy of the approach in reducing the overall time and increasing the accuracy of developer actions compared to state of the art web development tools.
the greatest improvement was seen for tasks involving control flow detection and especially event propagation showing the power of our approach.
as part of future work we plan to improve the interactive visualization and extend the details captured in each story to allow the programmer to gain a better insight into the application.
another direction we will pursue is in debugging where clematis can potentially help developers to better detect and localize faulty behaviour of javascript applications.
.