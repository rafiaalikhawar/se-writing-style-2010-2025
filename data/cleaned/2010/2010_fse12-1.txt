automating presentation changes in dynamic web applications via collaborative hybrid analysis xiaoyin wang1 lu zhang1 tao xie2 yingfei xiong1 hong mei1 1key laboratory of high confidence software technologies peking university moe china 2department of computer science north carolina state university usa wangxy06 zhanglu xiongyf04 meih sei.pku.edu.cn xie csc.ncsu.edu abstract web applications are becoming increasingly popular nowadays.
during the development and evolution of a web application a typical type of tasks is to change the presentation of the web application such as correcting display errors adding user interface controls or changing appearance styles.
to change the presentation of a static web page developers are able to modify the html text of the web page using a graphical web page editor.
however to change the presentation of a dynamic web application instead of using a graphical web page editor to directly modify generated web pages developers need to modify the code that generates the web pages.
as manually performing presentation changes in dynamic web applications is tedious and error prone we propose a novel approach based on collaborative hybrid analysis that combines static analysis and dynamic analysis to facilitate developers to perform presentation changes in dynamic web applications.
our approach includes two parts.
the first part takes as input the presentation change to be performed on a generated web page with proper runtime information and uses dynamic string origin analysis to locate the source code segment that generates the changed part of the web page.
the second part checks unexpected impact of directly performing the change on the source code segment and asks for human intervention when unexpected impact exists.
we implemented our approach for the php language and carried out an empirical study on presentation change tasks identified from bug reports of three real world dynamic web applications in total more than kloc .
among the tasks our approach is able to correctly locate the place to modify in each presentation change task and correctly perform the presentation change on the source code in more than half of the tasks.
categories and subject descriptors d. .
general terms reliability keywords presentation change web application dynamic string origin analysis corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.
.
introduction recently web applications are becoming increasingly popular due to easier access to the internet.
various researchers have developed techniques to facilitate the development and evolution of web applications such as testing web applications static checking for bugs in web applications and refactoring web applications .
a typical type of daily tasks during the development and evolution of web applications is presentation changes which are modifications made to change the appearance of web pages.
typical presentation changes in web applications include correction of display errors adding user interface controls etc.
according to our investigation of bug reports from three real world web applications about of the bug reports are presentation changes and these presentation change bug reports primarily occur in early evolution stages of the applications.
on a static web page it is straightforward to perform a presentation change because a developer can directly modify the graphical presentation of each static web page with the help of a graphical web page editor.
however most web applications nowadays contain a large number of web pages that are generated dynamically at the server side through code written in a programming language e.g.
php .
in such a case it is difficult to perform presentation changes because the developer should not directly modify the generated web pages but needs to modify the code that generates the web pages requiring presentation changes.
manually performing a presentation change in the code that generates a web page is often tedious and error prone for two main reasons.
first to locate the piece of code for modification the developer needs to be familiar with both the structure of the generated web page and the structure of the code generating the web page.
typically the structure of the web page generation code is different from the structure of the generated web page itself.
for example the web page generation code may use complex loop structures to generate repetitive fragments in the generated web page.
second the developer also needs to ensure that the modification of the located code realizes only the presentation change without inducing unexpected impact.
due to the dynamic nature modifying one place in the web page generation code may impact many places in the generated web page and or other web pages that can be generated by the code.
without knowing the potential impact the developer may change the code in an unexpected way.
text search may be helpful in some occasions where the developer uses the need to change presentation fragment in the generated web page as a query to search in the web page generation code.
however it is common that the text serving as the query appears many times in the web page generation code and the developer thus faces a large number of false positives.
for example if the developer wants to delete a certain tag tr 1in a dynamically generated web page he or she may get hundreds or thousands of irrelevant tr tags when searching for the code that generates the web page with tr .
furthermore when the need tochange presentation fragment is not generated from one entire constant string text search can hardly locate the piece of code corresponding to the need to change presentation fragment.
in the preceding example if the developer searches using tr together with its surrounding texts to try to filter out some irrelevant results text search may return nothing because tr and its surrounding texts may be in separate constant strings in the source code and are concatenated at runtime.
fault localization is another approach to supporting locating the code segment to change.
however existing fault localization techniques usually require to run the web application with many test cases including passing and failing ones incurring much extra overhead.
furthermore these techniques typically require developers to inspect a non trivial number of suspected locations without providing support on changing these locations.
to facilitate developers to perform presentation changes we propose a novel approach to automating presentation changes in dynamic web applications.
our approach aims to help a developer perform presentation changes in a dynamic web application in a way similar to performing presentation changes in static web pages.
to use our approach a developer needs to run an instrumented version of the web application to generate the need to change web page with runtime information produced by the instrumentation.
then the developer can annotate a presentation change on the generated need to change web page by selecting a need to change html segment and providing the new value2.
with the annotated change and the runtime information as input our approach automatically performs a change on the source code to fulfil the presentation change if no unexpected impact is found or provide the developer with the need to change location in the source code together with the information of detected unexpected impacts.
our approach basically consists of two parts.
the first part is dynamic string origin analysis which takes as input the runtime information of a web page generating execution and a given part pin the generated web page.
the output of dynamic string origin analysis is the source code segment that generates pduring the execution.
therefore our dynamic string origin analyzer can map a presentation change back into the web page generation code.
the second part is unexpected impact detection which takes as inputs the source code of a web application an annotated presentation change pcon the web page generated by the web application and a change scon the source code.
the output of our unexpectedimpact detector is all the possible places affected by scexcept pc.
the general idea of our approach is to generate code changes by mapping changes from the program output to its source code using dynamic analysis and check the safety of the changes through static analysis and dynamic analysis.
in this paper we refer to this two part analysis for automating code changes as collaborative hybrid analysis since both static analysis and dynamic analysis are involved and collaboration between the two types of analysis is essential.
note that the general idea of collaborative hybrid analysis may not be limited to the particular problem discussed in this paper but be potentially applicable to automate other types of code changes such as fixing sql queries or changing file outputs.
1in html tr causes to print a new line in the web page similar to nn in some programming languages.
2for insertion the developer needs actually to choose a point between two characters in the html document as the insertion point.as we implemented and evaluated our approach for dynamic web applications written in the php language we use examples in php throughout this paper for illustration.
however the idea of our approach is general and in principle applicable for dynamic web applications written in other languages.
the presentation changes that this paper aims to handle are changes in the presentation part of web pages including the display style the layout of controls and the format and labels of controls.
handling changes about the displayed data and computation results is out of the scope of this paper.
to evaluate our approach we carried out an empirical study on presentation changes identified from bug reports in three real world dynamic web applications in total up to kloc .
note that in our evaluation we extracted presentation changes from bug reports because we had the recorded developer changes as the ground truth.
our approach is not specific to fixing presentation change bugs but can also be applied to evolutionrelated presentation changes.
our empirical results show that our approach is able to correctly locate the place to modify to realize a presentation change in each presentation change task.
furthermore our approach can correctly propagate the presentation change to the source code in more than half of the tasks and correctly detect unexpected impacts in most of the remaining tasks.
this paper makes the following main contributions an approach based on collaborative hybrid analysis that automatically performs presentation changes in a dynamic web application.
dynamic string origin analysis which locates the sourcecode segment in the web application that generates a certain part of a generated web page.
unexpected impact detection which determines whether the web page generation code can be directly changed to realize the presentation change without unexpected impact.
an empirical study on a total of bug reports of three real world dynamic web applications i.e.
squirrelmail webcalendar andorangehr to demonstrate the effectiveness of our approach.
.
motivating example consider the example from file mailbox display.php in the version of may of the squirrelmail project.
the presentation change is made to fix bug report no.
.
the textual description of the bug report is missing form in mailbox display.php .
from the bug report we know that a bug in the code results in a missing form in an html text generated by mailbox display.php .
therefore the developer needs to change the code in mailbox display.php to make the string form inserted into an appropriate position in the generated web page.
the code related to the change is depicted below.
function displaymessagearray ... ... mail message listing beginning ... ... echo table form echo td tr ... function mail message listing beginning ... ... echo n n n form name messagelist method post action moveurl n ... the form begins in mail message listing beginning but needs to be closed in displaymessagearray .
thus the developer must check the code very carefully to insert the string form into an appropriate position.
actually earlier comments to the bugreport suggest to insert echo form at the end of function mail message listing beginning .
however the correct fix which was done a month later actually inserts echo form in the middle of displaymessagearray as shown in the italicized line .
from the example we can see that due to the complexity of the web page generation code it is tedious and error prone for the developer to perform presentation changes manually.
the html segment generated by the preceding code is depicted below.
the italicized form is where the missing form should be inserted into the generated html text.
form name messagelist method post action move messages.php?msg mailbox inbox startmessage table form td tr with our approach the developer can run the instrumented source code of squirrelmail to record the required execution information.
after the developer specifies that the form should be inserted between table and td in the generated html text our approach maps all the substrings in the generated html text to their origins in mailbox display.php and thus identifies the place in mailbox display.php where the echo form should be inserted.
in particular our approach actually appends form to one constant string in mailbox display.php .
our approach further checks that this change to the php file would not have any unexpected impacts.
.
related work for convenience we classify related research into seven categories string taint analysis dynamic taint analysis impact analysis hybrid analysis automated support for presentation changes bidirectional transformation and automated bug fixing.
string taint analysis.
our dynamic string origin analysis is closely related to static string taint analysis which is developed by wassermann and su on the basis of string analysis in order to determine whether the data origins of a given string variable are from an unsafe source.
yu et al.
recently proposed an automaton based string taint analyzer for php with stronger handling of string operations.
in our previous research we adapted string taint analysis to statically locate all the constant strings that are the data origins of a given string variable.
our dynamic string origin analysis differs from existing research on string taint analysis as follows.
first we apply string taint analysis dynamically on one execution trace while all existing variants of string taint analysis statically analyze all possible executions.
second our dynamic string origin analysis uses executionspecific information such as actual values of unanalyzable strings and execution specific finite state transducers to improve the precision of analysis.
third the taints used in our string origin analysis record locations of a runtime string value s data origins which are different from the taints used in any existing variants of string taint analysis.
finally our unexpected impact detection is able to check the impacts of changing a certain constant string in the code such checking cannot be handled by existing string analysis and stringtaint analysis.
dynamic taint analysis.
dynamic taint analysis is a category of techniques that add taints on a runtime value e.g.
a byte or an object propagate taints during the flow of the value and trace where the value goes to by checking the taints.
typically dynamic taint analysis traces where the user input goes to at runtime since user input is often considered as insecure in many securityrelated tasks.
as a character in a string takes a byte our dynamic string origin analysis is similar to byte level dynamic taint analysis.
however there are two main differences between the two analyses.
first our dynamic string origin analysis uses complex taints to trace location information while existing techniques for dynamictaint analysis mainly use boolean taints to trace security information.
second our dynamic string origin analysis is based on analyzing productions in the extracted context free grammar while byte level dynamic taint analysis is based on analyzing all operations on each byte of each involved variable.
therefore it would be much more expensive to adapt byte level dynamic taint analysis for our target problem than using our dynamic string origin analysis.
for example byte level dynamic taint analysis needs to instrument at a level finer than the statement level used in our dynamic string origin analysis and byte level dynamic taint analysis needs to instrument all involved library code but our dynamic string origin analysis does not.
note that the propagation of complex taints could further worsen the situation.
impact analysis.
our unexpected impact detection is related to research on impact analysis.
impact analysis refers to approaches to inferring how a change to one piece of code affects other places in the same code base.
arnold and bohner wrote a book on impact analysis for software changes.
the book contains the latest approaches in the area of impact analysis at its publication time such as dependence analysis and static slicing and provides ideas and guidelines for using impact analysis practically.
ren et al.
proposed an automatic impact analysis tool for java called chianti.
chianti first decomposes the differences between two versions of software to a list of atomic changes and then decides which parts of the code and which test cases may be affected by the changes.
law and rothermal proposed to use dynamic analysis to decide more precise but incomplete impact of a software change.
existing techniques of impact analysis either static or dynamic try to locate all affected places of a given change on the source code.
in contrast our unexpected impact detection takes as inputs both the source code and an execution trace and tries to locate only the affected places that are unexpected i.e.
the affected places that do not correspond to the developer specified presentation change .
hybrid analysis.
there have been some research efforts on integrating static analysis and dynamic analysis.
nimmer and ernst proposed a bug detection approach that first mines program invariants from a large number of program executions and then verifies the mined invariants using static analysis.
this research uses dynamic analysis and static analysis as two independent steps while our approach relies on the collaboration of static analysis and dynamic analysis.
furthermore dynamic analysis in our approach requires only one single execution while dynamic analysis in their approach requires multiple executions.
dufour et al.
proposed the blended analysis which performs static analysis in the scope of an execution trace.
conceptually the first part in our approach is similar to this research but the second part in our approach involves more static and dynamic analyses.
automated support for presentation changes.
whyline is a debugging tool that allows developers to ask why and why not questions about presentation bugs.
it provides some support for presentation changes.
similar to our approach whyline also uses program instrumentation to build mappings between gui components and the source code.
therefore whyline is able to answer questions about the gui components such as why is the color of the button red?
and guide developers to the related places in the code to fix presentation bugs.
however there are two main differences between whyline and our approach.
first as whyline is developed for traditional gui structures it is not applicable for dynamic web applications in which the whole gui is built by concatenations and operations of strings.
in contrast our approach uses dynamic string origin analysis to map gui components in web applications to their origins in the source code.
second beside mappingbetween gui components and the source code our approach further provides support for developers to propagate changes in generated web pages back to the source code.
nguyen et al.
proposed an approach that automatically propagates fixes of syntactical errors in html texts back to the serverside code.
their basic idea is to first statically build from the source code a symbolic model that estimates all the possible html pages that the source code may generate and then they match the fixed html page to the model to locate the source code segment that corresponds to the fixed part of the html page.
our work differs from this approach in three main aspects.
first our approach is able to handle presentation changes besides syntactical fixes.
second we use dynamic analysis which is able to precisely handle all statically uncertain issues such as user inputs and library functions without source code.
thus our approach is able to construct a correct mapping from an arbitrary part of the html page back to the source code.
third our approach further detects the unexpected impacts of propagating a change on the html page back to the source code.
there is concurrently conducted work by samimi et al.
that proposed an approach to automatically fixing html generation errors.
their approach is based on multiple test cases and generates a string constraint on the printed constant strings constant strings that are echoed to the html page to make all the test cases pass.
then a fix is automatically generated through solving the constraint.
compared to their approach our approach relies on only one test case.
furthermore by further tracing back to the data origins of printed variables our approach is able to generate fixes beyond changing printed constant strings.
bidirectional transformation.
bidirectional transformation aims to tackle the problem of maintaining data consistency between two related data sources .
when one of the two related data sources changes the other data source must change accordingly.
bidirectionalization which aims to add the capability of backward transformation to one directional transformation programs is a state of the art solution for bidirectional transformation.
thus maintaining the consistency between the presentation and the source code can also be viewed as a bidirectionalization problem in general.
there are two main differences between our approach and bidirectional transformation.
first bidirectional transformation propagates changes in output back to input while our approach propagates changes in output back to the program.
second existing bidirectionalization techniques are able to handle only data transformation programs that contain no complex operations e.g.
string operations arithmetic operations while our approach is able to handle string operations that are popular in our target problem.
automated bug fixing.
automatically performing presentation changes can be viewed as a case of automated bug fixing such as wei et al.
weimer et al.
carzaniga et al.
and dallmeier et al.
.
typically these approaches search for good fixes using specifications or test oracles as the criterion.
furthermore these approaches are concerned with bugs that result in erroneous program states instead of the presentation.
different from these approaches our approach actually propagates the fixes written by developers in the generated web pages to the source code and our approach is concerned with presentation bugs that may not be related to program states.
.
approach to solve the problem of automating presentation changes in dynamic web applications we propose a general idea named collaborative hybrid analysis which contains two main parts a change mapping part that involves dynamic analysis to map thechange on the generated html text to the code generating the html text and a checking part that involves both static analysis and dynamic analysis to make sure that the change in the code would not bring unexpected impacts.
note that this idea is general and may be applicable to various code change scenarios other than presentation changes in dynamic web applications.
in the change mapping part a developer needs to re generate the need to change web page through executing an instrumented version of the web application.
along with the generation of the need to change web page our approach uses the instrumented code to record some runtime information.
with the help of the runtime information our approach uses dynamic string origin analysis to locate in the web page generation code the data origins of generated parts.
thus our approach is able to map the change i.e.
insertion deletion or replacement made by the developer on the generated web page to the data origins in the web page generation code.
in the checking part which uses both static analysis and dynamic analysis our approach further checks whether the change can be applied without further revisions of the code.
if so our approach recommends direct propagation of the change to the web pagegeneration code.
otherwise our approach highlights the need tochange place in the code and provides the reason for not being able to perform the change directly.
in this paper we refer to this checking as unexpected impact detection .
in the preceding approach to automating presentation changes in dynamic web applications there are two main technical challenges to overcome.
the first challenge is what dynamic information to record and how to use the collected information to achieve required precision for mapping the change from the generated web page to the code.
to overcome this challenge we propose dynamic stringorigin analysis based on static string taint analysis which typically does not meet our requirement when handling user inputs string operations etc.
to deal with our dynamic information.
the second challenge is how to check against unexpected impacts.
to overcome this challenge we propose unexpected impact detection.
we describe the details of how we overcome the two challenges in the next two subsections.
.
dynamic string origin analysis as mentioned previously our dynamic string origin analysis is based on string taint analysis .
the process of string taint analysis is as below.
the analysis transforms the web page generation code to an extended context free grammar cfg containing finite state transducers fsts .
then the analysis propagates taints from the terminals to the nonterminals through productions and fsts in the cfg and determines the taints of the nonterminals.
however static string taint analysis may not be suitable for the target problem without adaptation.
first it may generate false positives due to its approximation for statically unknown elements e.g.
user input possible numbers of loop iterations .
second static string taint analysis considers all possible executions and therefore can hardly achieve mappings between code elements and the exact positions in the generated html text.
therefore we propose dynamic string origin analysis .
one concern of dynamic analysis is the runtime overhead imposed by the instrumentation but such concern is not a problem in our case we could have two versions of the program an instrumented one for performing the presentation change and the original one for normal execution and testing.
the basic idea of dynamic string origin analysis is to perform string taint analysis on an execution trace instead of the source code.
as dynamic string origin analysis makes use of the recorded runtime information of the execution there would be no approximation.
moreover instead of boolean taints our dynamic string origin analysis uses a taint that records the source code location information so that the taints of a generated html text represent all of its data origins.
we next present how we record runtime information for our dynamic string origin analysis section .
.
.
we then present how we adapt string taint analysis for our purpose section .
.
.
.
.
recording of runtime information in the instrumented web application the instrumented code records two kinds of information.
the first kind of information is the executed statements in their execution order.
this kind of information provides the basis for our dynamic string origin analysis.
the second kind of information is the values of expressions that existing techniques of string taint analysis cannot handle precisely.
typically those expressions include user inputs e.g.
post and get operations the invocations of library functions except string operations array elements and arithmetic or boolean expressions used as strings.
for such an expression existing techniques of string taint analysis use the closure of the alphabet to estimate its value.
for example the statement x post is transformed to a production x !
.
as we use our dynamic stringorigin analysis on one execution trace we are able to use the actual values of these expressions and thus further reduce the imprecision of string taint analysis.
we next illustrate how we record the runtime information with the following example code portion i uid str replace post sql select from utbl where uid .
uid query mysql query sql num mysql num rows query while i num result mysql fetch array query str.
td .
i. .
result .
td i echo str echo tr .
uid the execution trace of the code portion is as below where the value of post is wxy and there are two titles in the database for user wxy t1 and t2 .
for brevity we present only the line number of a statement and the recorded values associated with the statement.
for line we record the value of a user input.
for lines and we record the return values of library functions where resource id is the handler of the sql query and array1 and array2 represent two arrays of values read from the database.
for line we record the value of an array element and for line or we record the value of an arithmetic expression.
i post wxy query resource id num result array1 result t1 i result array2 result t2 i .
.
analysis with runtime information when placing the executed statements in their execution order we get a new program which we refer to as the trace program in this paper.
from the trace program we construct an extended cfg in a way similar to the construction of an extended cfg in stringtaint analysis.
the only difference lies in that we use the recorded actual values for places where existing techniques of string taint analysis use the closure of the alphabet for estimation.
note that the trace program contains neither branches nor loops.
thus the imprecision caused by the control dependencies on user inputs has already been removed naturally.
for the code portion and the runtime information presented in section .
.
we construct the following extended cfg in which instead of using the alphabet closure to estimate the values of user inputs and unanalyzable variables i.e.
post num result and i we use their actual values i1!
post id !wxy uid!preg replace post id str1!
td .
.
.t1.
td str2!
td .
.
.t2.
td page!
str2.
expr expr!
tr .
as our extended cfg is constructed from an execution trace either a terminal or a nonterminal represents just one string.
therefore we are able to use the taint of a terminal or a nonterminal to represent the origins of different parts in the string represented by the terminal or the nonterminal.
initially we give each terminal a location flag as the taint.
in particular if the terminal represents a string constant the location flag records the exact location of the string constant in the code.
if the terminal represents a string value read from files databases the network or the user input the location flag records the location of the reading statement.
if the terminal represents a non string type variable or constant concatenated with strings the location flag records the location of the concatenation.
the taint of a terminal also contains information to distinguish these different types of terminals.
we give no taint to any nonterminal initially and we propagate taints of the terminals to the nonterminals.
the taint of a nonterminal is a list of index ranges and their corresponding location flags3.
for example a nonterminal whose value is abcde15 may have the following taint file1.php line constant file2.php line database file2.php line number .
the taint indicates that the origin of substring abc is the string constant in line of file1.php the origin of substring de is from a database in line of file2.php and the origin of the substring is from a number in line of file2.php.
as our taint of a terminal nonterminal indicates the origins of its substring we also refer to our taint as the origin signature below.
to ensure that we have calculated the origin signatures of all the nonterminals at the right hand side of a production before we calculate the origin signature of the nonterminal at the left hand side of the production we propagate the origin signatures in the same order as the execution order.
to present how we propagate origin signatures in a production whose right hand side is simple concatenation let us consider a production in the form of y !
x1x2x3 x n in which y is the nonterminal at the left hand side and each xiis a terminal or a nonterminal whose origin signature is sig xi and whose value is value xi .
the origin signature of y after propagation is basically the concatenation of sig xi with adjustment of the index ranges.
for example if the length of value x1 islength x1 we need to increase the indices in sig x2 bylength x1 to form the corresponding part of indices in the origin signature of y .
as each nonterminal in our cfg represents just one string our propagation of the origin signature is able to calculate the exact origin of any substring of the string represented by the nonterminal.
if the right hand side of a production is not just concatenation of nonterminals and or terminals but is a more complex string operation such as str replace andtrim there is a finite state transducer fst in the extended cfg to simulate the string operation.
in existing techniques of string taint analysis an fst can read a string strwith its origin signature sig st and output a string str1and its origin signature sig str1 .
if we use exactly the same fsts used in existing techniques of string taint analysis in our dynamic string origin analysis the fsts can guarantee that str1is the same as the 3note that our previous research uses location flags but not index ranges as taints.figure an example of location fst t a output of the string operation with input str and sig str1 indicates the origin of each substring in str1that comes from str.
however if the output of a string operation has substrings coming from more than one parameter of the string operation an fst used in existing techniques of string taint analysis can calculate only a partial origin signature.
to overcome this limitation we extend the existing fsts by adding origin signatures to output strings on edges of the fsts.
as any real argument of a string operation with multiple parameters can be a string variable one origin signature added on one edge of the fsts may contain multiple origins.
note that as fsts can simulate string operations defined in library code using fsts naturally avoids instrumenting library code.
to illustrate our adaptation on fsts we present an example in figure which shows an adapted fst for str replace a y x where the value of y is bc .
in the figure we use tag ch to represent the location flag of a character ch .
consider the case where the value of x is abcda the location flag of abc in x is tag1 the location flag of da in x is tag2 the location flags of the b and c in y are tag3 and tag4 respectively.
the output of the fst would be b tag3 c tag4 b tag1 c tag1 d tag2 b tag3 c tag4 in which the tag after each character indicates the location flag of the character.
in contrast using the standard fst the output would be bcb tag1 c tag1 d tag2 bc and the location information of the characters from the argument y would get lost.
after taint propagation the origin signature of the start nonterminal i.e.
s describes the origins of all the substrings in the generated web page.
using this origin signature when the developer makes a change in the generated web page our approach is able to map the change to its data origins in the web page generation code.
.
unexpected impact detection as mentioned previously propagating a presentation change from a web page back to the web page generation code may have unexpected impacts on other places in the generated web page and or on other web pages that can be generated by the code.
specifically we deem an impact of a code fix as expected if the impact matches the user specified presentation change in the generated web page.
other impacts of the code fix are deemed unexpected.
when the unexpected impact is on other places in the generated web page we refer to it as inner page impact.
existing bidirectionalization techniques have already considered this category of unexpected impacts and refer to them as conflicts.
in particular conflict detection in bidirectionalization checks whether multiple elements in the output of the transformation are mapped to a single element in the input and whether these output elements are changed inconsistently.
similar to existing bidirectionalization techniques our approach checks whether two substrings in the generated web page corresponding to the start variable in the cfg sharing the same location flag change consistently or not.
note that in nature the checking of this category of unexpected impacts is based on dynamic analysis which analyzes the cfg constructed from one execution trace.when the unexpected impact is on other web pages we refer to it as inter page impact.
bidirectionalization techniques do not consider this category of unexpected impacts because a transformation program in bidirectionalization always transforms one input to the same output.
when a change propagation denoted as c has an inter page impact the changed code must have some impact to multiple web pages denoted as p set .
among these pages only one denoted as p is shown in the execution and contains the userspecified presentation change.
in each page in p setother than p there must be some part denoted as pa that is data dependent or control dependent to c and part of the code that generates pa is not included in the execution trace because pais not generated.
therefore the clue of inter page impact should be the existence of some code that is data dependent or control dependent on the changed code but not included in the execution trace.
therefore we detect inter page impacts by first searching the execution trace for code elements variables expressions and return values that may contain the changed part as a substring and then statically checking in the source code whether these code elements are used in branch predicates in the execution trace or are used in statements not in the execution trace.
specifically to detect interpage impacts we use a static analysis technique that consists of four steps.
first in the origin signature of the start nonterminal we find the location flags corresponding to the changed part on the changed web page and use these flags to form a flag set denoted as flags .
second for each nonterminal in the cfg if its origin signature contains any location flag in flags we put the nonterminal into a set called refnt .
note that the origin signature of a nonterminal is the sequence of the location flags of its each substring.
third we map each nonterminal in refnt back to the code elements that the nonterminal represents.
if a code element is represented by a nonterminal in refnt we put it into a set called refvar .
fourth we check whether there exists a reference of a code element in refvar that is in branch predicates recorded in the input execution trace or is in any statements not recorded in the input execution trace.
if so we deem that we have detected an unexpected impact in the second category because the change may affect some parts of the code that are not executed in the current execution.
when our approach detects an unexpected impact in either category our approach highlights the unexpected impact and recommends to the developer that the presentation change cannot be directly performed to the source code.
.
practical issues beside the preceding two categories of unexpected impacts our approach also considers two practical issues before performing a presentation change.
first the presentation change made in a generated web page may not always map to constant strings in the code.
when a presentation change maps to strings read from files databases the network or the user input we would recommend the developer to do some manual refactoring to realize the presentation change since the developer needs to adjust the processing logic to change the value of data read from outside the web page generation code.
second if the made presentation change is an insertion and the inserted string is between two concatenated constant strings the string can be inserted either to the right of the first string or to the left of the second string.
in such a case our approach would also ask the developer to choose one insertion point.
.
empirical study to evaluate our approach we implemented our approach for the php language and conducted an empirical study on our approach using three php projects as subjects.table subject web applications used in our study subject dev.
start end kloc squirrelmail apr dec to webcalendar 7jun dec to orangehrm mar oct to .
research questions our empirical study tries to answer the following two research questions.
rq1 how effective is our approach on locating the source code that generates the changed part of the html page?
rq2 how effective is our approach on detecting unexpected impacts and discovering practical issues?
the first research question is mainly concerned with the effectiveness of our technique for dynamic string origin analysis.
the second research question is mainly concerned with the effectiveness of our techniques to detect unexpected impacts and to deal with practical issues.
.
study design we used three popular open source dynamic web applications as subjects in our empirical study squirrelmail webcalendar andorangehrm .squirrelmail is one of the most popular web based email clients webcalendar is one of the most popular web based calendars and memorandums and orangehrm is a web based human resource management systems.
all of the three web applications are dynamic web applications written in php and their source code is accessible from sourceforge4.
we choose these three applications because they are from different domains and their presentation styles are different from each other so that our empirical results on them would probably be generalizable to different presentation styles.
furthermore all three subjects have more than bug reports so that we have enough data sets to construct presentation changes for our empirical study.
to perform our study we manually studied bug reports for each web application.
in particular we chose the earliest bug reports marked as fixed in the bug repository of each web application.
the reason is that we need bug reports marked as fixed to compare the results of our approach with the actual results and most of early bug reports were already fixed no matter whether they were easy or difficult to fix.
however among recent bug reports the bug reports marked as fixed may be more likely to be easy to fix and thus may not be representative.
table depicts the detailed information of the three web applications.
in table columns and present the submission date of the first fixed bug report and the submission date of the 200th fixed bug report in the form of mmm dd yyyy respectively.
column presents the size of each web application in kilo lines of code kloc .
since the size of the source code would change from the start date to the end date we give two numbers for the size of the source code on the start date and that on the end date respectively.
for example to indicates that the size of the source code is kloc on the start date and kloc on the end date.
among the studied bug reports we manually identified bug reports5corresponding to presentation changes from the version histories and the bug repositories of the three subjects.
table depicts the result of our manual investigation of the bug reports.
in table columns to present the number of studied 5the information of the bug reports are available on the project web site projects apc bug reports the number of presentation change bug reports the percentage of presentation change bug reports among all studied bug reports the number of duplicate presentation change bug reports and the number of identified presentation change tasks respectively.
in table we have three main observations.
first in all of the web applications under study there exist some bugs related to presentation changes.
this fact indicates that most web applications may require presentation changes during their development and evolution.
second the average percentage of presentation bugs among all bugs is .
.
this percentage number indicates that presentation change bug reports are an important category of bug reports for web applications and presentation change tasks are quite common in the early evolution history of web applications.
third in squirrelmail presentation change bug reports account for .
of all the studied bug reports while in orangehrm presentation change bug reports account for .
of all the studied bug reports.
this difference indicates that the frequency of presentation changes may be different for different web applications.
a possible explanation is that the gui structure of squirrelmail is more stable than that of orangehrm because there is a defacto standard gui structure for web based email client applications.
furthermore to understand whether some presentation change tasks take developers non trivial effort to perform we studied the processing days of the presentation change bug reports and other bug reports6.
for each software project under study table compares the processing days of the presentation change bug reports and the processing days of all the studied bug reports.
in table column presents the software project under study.
columns and present the average processing days and the processing day range for the presentation change bug reports among the studied bug reports of the software project respectively.
columns and present the average processing days and the processing day range for all the studied bug reports of the software project respectively.
all the processing day values are calculated as the difference between a bug report s closing date and its submission date.
if a bug report is closed on the day it is submitted we deem the processing days as zero day.
from table we have two main observations.
first the average processing day values of presentation change bug reports vary from .
days to .
days in the three software projects.
this observation indicates that presentation change tasks are generally not trivial and developers do take some time to perform them.
second the average processing day values of presentation change bug reports are typically comparable to that of all bug reports presentationchange bug reports take longer time in two subjects and shorter time in one subject.
this observation indicates that presentationchange tasks are not significantly simpler than other bug fixing tasks.
third the maximal processing days of all bug reports are much more times than those of the presentation change bug reports.
this result shows that the presentation change bug reports are usually not the most time consuming ones to process among all the bug reports but require average processing days of all the bug reports.
among the studied bug reports for each subject there are duplicate bug reports7.
as the developers of the three web applications did not record duplication relationships between bug re6note that the processing days of a bug report may not exactly reflect the difficulty of bug fixing tasks for various reasons e.g.
developers different schedules .
7in fact automated detection of duplicate bug reports in bug repositories is a recent research focus .table result of manual investigation of the studied bug reports subject bug reports presentation of presentation duplicate presentation presentationstudied change reports change reports change reports change tasks squirrelmail .
webcalendar .
orangehrm .
total .
table the processing days of the bug reports subject presentation change bug reports all bug reports avg.
processing days processing day range avg.
processing days processing day range squirrelmail .
.
webcalendar .
.
orangehrm .
.
ports we manually picked out the duplicate bug reports from the presentation change bug reports.
as shown in table we identified duplicate presentation change bug reports in total.
since it is difficult for us to remove all duplicate bug reports in the studied bug reports without detailed analysis of each bug report we used all the bug reports including the duplicate presentation change bug reports when calculating the numbers for the percentage.
for each of the unique presentation change bug reports we built a presentation change task according to the following procedure.
first we checked the description of the presentation change bug report in the bug tracking system and the comments of the code commits.
from this information we figured out which code commit contains code changes related to the presentation change bug report.
second according to the description in the presentationchange bug report we used our approach to instrument the web application and executed the instrumented web application to generate the need to change web page.
third we identified the required change in the generated web page and used our approach to map the required change to the web page generation code.
finally we checked the code changes in the corresponding code commit to discover how the developers changed the code to realize the presentation change.
we used these code changes as the ground truth of the corresponding presentation change task.
for each of the tasks if our approach can directly propagate the change in the generated web page to the source code we checked whether the change suggested by our approach matches the actual change otherwise we checked whether our approach can correctly detect the unexpected impacts and practical issues by checking with developers actual changes.
to check the correctness of a mapping we compared the places suggested by our approach with the places changed by the developers.
in the case of unexpected impacts and mapping to places other than constant strings the fix made by the developers is typically more complex.
in such case we checked whether the statements that contain the places suggested by our approach are involved in the fix made by the developers.
in the case of the insertion issue we checked whether the two suggested places match the actual change in the fix made by the developers.
if one suggested place matches it we deem that our approach correctly locates the need to change place.
.
overall results table depicts the overall results of our approach on preforming the presentation change tasks in the three web applications.
for each subject columns to in table present the number of presentation change tasks under study the number of tasks for which our approach correctly maps the changed substrings in the web page to their corresponding places in the source code the number of tasks for which our approach directly propagates the change to the source code in a way matching the actual change the number of tasks for which our approach directly propagates the change tothe source code without matching the actual change the number of tasks for which our approach does not recommend direct propagation due to inner page impact the number of tasks for which our approach does not recommend direct propagation due to interpage impact the number of tasks for which our approach does not recommend direct propagation due to an insertion issue and the number of tasks for which our approach does not recommend direct propagation due to mapping the change to code elements other than constant strings respectively.
from table we have four main observations.
first for all of the changing tasks our approach is able to correctly map the presentation change to the corresponding places in the source code.
this observation indicates that dynamic string origin analysis on the execution trace is very precise in providing developers with places to modify for realizing presentation changes.
second for out of the tasks our approach is able to directly propagate the presentation change to the source code correctly.
this observation indicates that developers can perform more than half of the presentation changes in dynamic web applications as in static web pages with the help of our approach.
third there are tasks for each of which our approach correctly locates the corresponding source code and recommends direct propagation but the actual change is not a direct change.
in each of the tasks the developers actually try to make a static part in the generated web page dynamic.
for example in bug report no.
of the orangehrm subject the users complained that the feedback information of an operation is always in red no matter whether the operation fails or not and demanded that the information should be in green when the operation succeeds.
our approach is able to locate the corresponding constant string about the color in the source code and confirm that changing the substring from ff0000 red to green would not have unexpected impacts.
however in the actual fix the developers add some condition checking instead of directly changing the substring ff0000 .
in such a case there is no wonder that our approach cannot produce the correct fix.
the reason is that the intention of the change is not to always have the feedback information in red.
since the developers know the intention of the change they should know that the direct propagation is incorrect beforehand.
finally for each of the other tasks our approach is able to correctly decide that the presentation change in the generated web page cannot be directly propagated to the source code.
among these tasks tasks are due to unexpected impacts on other possible generated web pages tasks are due to ambiguity of insertion tasks are due to mapping the presentation change in the generated web page to code elements other than constant strings.
this observation indicates that the proposed techniques to detect unexpected impacts and to address the practical issues are helpful to prevent our approach from producing incorrect changes.table overall results of our approach subject tasks correct correct direct incorrect direct inners page inter page issue of issue of nonemap propagation propagation impact impact insertion constant strings squirrelmail webcalendar orangehrm total .
example tasks in this subsection we use two example tasks to further illustrate how our approach works in different situations.
example .
the first example is about bug report no.
ofwebcalendar which takes the developers days to process.
the bug is for the version on aug. 8th .
the summary of the bug report is rejected e mail link missing a quote .
the description of the bug report states that a quotation mark is missing for the email links in the rejected list.
this missing quotation mark causes the page to be displayed incorrectly.
therefore the presentationchange task is to add the quotation mark to a proper place in the source code.
the erroneous html fragment is as below.
the underlined part of the html should be .
... br strike a href mailto mymail gmail.com?
subject webcalendar mycal xiao a strike rejected ... the source code that generates the preceding html fragment is as below.
our approach is able to locate the underlined constant string in the code and recommend a direct insertion of a quotation mark between the two characters of the constant string.
it is not easy to manually locate the fixing place for this bug because the whole html tag is broken into concatenated fragments and string variables in the php source code while our approach is able to locate the place and fix it automatically.
note that text search can hardly help much in this case because the strings immediately before and after the underlined are from the database and do not appear in the php file at all.
therefore using text search the developers would find nothing by searching for the texts around the underlined .
if searching for the string subject in the php file there would be places for further inspection.
... echo br strike a href mailto .
tempemail .
?subject subject .
tempfullname .
a strike .
translate rejected .
n ... example .
the second example is about bug report no.
oforangehrm which takes the developers days to process.
this bug is for the version on jul.
27th .
the summary of the bug report is pim emergency contact there has to be a space after fields .
the bug report states that the developers should insert a space after the fields in the page about the emergency contact information of employees.
the need to change html fragment is as below.
the underlined space is what should be added.
... tr td home telephone td ... td strong home telephone strong td ... the source code that generates the preceding html fragment is as below.
our approach is able to locate td in line as the right side of the insertion and home telephone in line as the left side of the insertion.
furthermore our approach is able to identify that changing home telephone would have inner page impact because of another appearance of home telephone generated by line .
with the preceding information a developer should be able to choose the correct insertion point without further inspection of the code.... hmtele home telephone ... td ?
hmtele?
insertion td ... td strong ?
hmtele?
strong td ... using text search a developer can easily locate the appearance of home telephone in line but adding a space after home telephone would be an incorrect change of the code.
as a result the developer may notice this incorrectness only after some testing which may be performed by a tester sometime later.
furthermore even after the developer knows that the space is added to a wrong place the developer still needs to inspect the code to find the correct place to add the space.
.
threats to validity in our study we applied our approach on presentation change tasks for three dynamic web applications.
this factor may be a threat to the external validity since it is possible that our empirical results may be specific to the used tasks and web applications and thus may not be generalizable.
to reduce this threat we used web applications from different domains as subjects.
the main threat to construct validity is the way we construct our presentation change tasks.
since the tasks are recovered from bug reports and version histories the scenarios in the constructed tasks may not be exactly the same as the scenarios in real world development.
to reduce this threat we carefully studied the bug reports and the version histories of each subject and examined the changed code to confirm that we correctly reproduced the need to change web pages and identified the required changes.
the main threat to the internal validity is the possible faults in implementing our approach.
to reduce this threat we carefully reviewed the source code of our implementation before conducting our empirical study.
another threat to the internal validity is that the developers themselves may make mistakes so that the bug fixes that we used as the ground truth may not all be correct.
to reduce this threat we use the earliest bug reports in the software development history so that the developers should have enough time to correct their fixes if they made mistakes.
.
discussion limitations of our approach.
our approach has three main limitations.
first our approach is more suitable for being applied to small atomic presentation changes such as changing a certain property of a certain gui component.
for pervasive style changes and large structure changes the developers can still trace the whole need to change part in the generated web page to the data origins in the web page generation code.
however in such a case the located data origins may include user inputs or computation results or the data origins may affect a large number of other web pages so that intensive human invention may be required.
second since our approach does not record or analyze the execution of javascript at the browser side we cannot handle the presentation changes in the web page parts generated dynamically at the browser side using ajax or similar technologies.
in such a case the code that generates the web page is itself dynamically generated and thus more difficult to instrument and analyze.third although our approach includes a series of techniques to check whether the intended presentation change can be directly propagated to the web page generation code we still cannot guarantee that a directly propagated presentation change is desirable.
our empirical results confirm the existence of such undesirable propagated presentation changes.
however our empirical results also show that undesirable cases are rare and developers intention for such a presentation change is typically different from ordinary presentation changes.
further investigation may be needed to study the condition for propagating a desirable presentation change.
using cfgs in dynamic analysis.
note that although contextfree grammars cfgs are essential in static string taint analysis it is not necessary for us to use cfgs in our dynamic string origin analysis.
in fact due to its dynamic nature the cfg constructed by our dynamic string origin analysis is a simple regular grammar.
therefore it is feasible to directly process the execution information without involving cfgs8.
however transforming the execution information to a cfg makes it possible for us to take advantage of existing tools for static string taint analysis which provides a convenient way to deal with string operations provided by library methods without instrumenting the library code.
dealing with css properties.
css cascading style sheet has been widely used in web application development and webpage design.
by using css developers can define a format in an external format file i.e.
.css file and link html tags to their formats.
for example a developer can define a format f1 which indicates the color of the text to be red.
then she can use f1 in the class property of html tags to link the tag with the format.
for example the developer can write the html text p class f1 abc p and then abc is shown in red.
the advantage of using css is that it can help developers perform formatrelated presentation changes just in the css file when they want to switch all the tags linked to a certain format to another format.
however there are still quite many presentation changes on dynamically generated html pages that are not about format switching.
actually both examples depicted in this paper are about display errors rather than format switching.
furthermore it is also possible for developers to change only one tag linked with the format e.g.
changing abc to be in black but keeping other texts with the f1 tag to be still in red .
in these cases the change should be made in html texts instead of css files and our approach is able to handle these cases well.
actually two of the three subject applications i.e.
squirrel andorangehrm use css properties in their presentation but the presentation changes required in these two applications are similar to those in webcalendar .
dealing with non presentation changes.
our approach may also be helpful for some non presentation change tasks especially those user visible non presentation changes.
for a user visible nonpresentation change our approach is able to provide the starting locations for the developers to further investigate.
pervasiveness of presentation changes.
our empirical results demonstrate that in the studied web applications more than of bug reports among the studied bug reports are about presentation changes.
actually there are also presentation change tasks triggered by the design decisions of developers especially before the release of the first version but not related to bug reports.
that is to say presentation changes are a common type of software changes in the early evolution history of web applications.
indeed in the later evolution history of a web application its presentation structures may become stable and the number of presentation change tasks may decrease accordingly.
8actually the simplicity of only one execution gives us many alternatives for implementing our dynamic string origin analysis.due to the difficulty of constructing tasks for presentation changes triggered by design decisions our empirical study uses presentationchange tasks constructed only from bug reports.
however we expect that our approach should still be applicable for such a presentation change because the developers should be able to generate the need to change web page and the desired change to the generated web page for such a presentation change task.
strength of collaborative hybrid analysis.
in our approach the basic idea of collaborative hybrid analysis plays an important role.
based on this idea we can use one execution to perform precise analysis without considering other possible executions.
on the basis of one execution it is also natural for developers to provide the desired presentation change because only with a generated web page can developers know what the presentation change is.
however changing the source code based on only one execution may be too risky.
the second part of our collaborative hybrid analysis uses both dynamic and static analyses to reduce the risk.
therefore we design the unexpected impact detection in a conservative way.
therefore we expect that the paradigm of collaborative hybrid analysis might provide a useful framework to automate various kinds of code changes.
first when looking for the right place to realize a specific code change dynamic analysis can be a means more precise and or more reliable than static analysis because dynamic analysis is able to use the information specific to one execution to avoid interferences between different executions.
second as it may be risky to perform a code change based on dynamic analysis static analysis should be indispensable to guard the code change.
indeed different combinations of dynamic and static analyses may be needed for different code changes.
.
conclusion and future work in this paper we have proposed an approach based on collaborative hybrid analysis to automating presentation changes in dynamic web applications.
in particular we use dynamic analysis to propagate the change on the generated html text to the source code and use both static analysis and dynamic analysis to ensure the safety of such propagation.
we carried out an empirical study on three widely used open source php web applications.
we identified and constructed presentation change tasks from their bug reports.
our empirical results demonstrate that our approach is able to correctly locate the place to modify to realize the presentation change in each presentation change task and correctly propagate the presentation change to the source code in more than half of the tasks.
for most of the remaining tasks our approach is able to correctly detect unexpected impacts.
there are three main ways to further improve and extend our approach in future work.
first as there are several threats to validity in our empirical study we plan to further reduce these threats in future work.
specifically we plan to apply our approach on more presentation change tasks for more dynamic web applications.
furthermore our evaluation involves a relatively small number of cases related to unexpected impact detection.
we plan to evaluate our approach on more presentation change tasks involving unexpected impact detection so that we can have a better evaluation on this part of our approach.
second our approach cannot guarantee that a presentation change is desirable.
in future work we plan to investigate new techniques for this purpose such as considering multiple executions.
third we currently evaluate our approach with the development histories.
we plan to carry out a user study on groups of developers to evaluate our approach on the practice of web application development and maintenance.