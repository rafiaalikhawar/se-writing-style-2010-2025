the confidence in our k tails hila cohen and shahar maoz school of computer science tel aviv university israel abstract k tails is a popular algorithm for extracting a candidate behavioral model from a log of execution traces.
the usefulness of k tails depends on the quality of its input log which may include too few traces to build a representative model or too many traces whose analysis is a waste of resources.
given a set of traces how can one be con dent that it includes enough but not too many traces?
while many have used the k tails algorithm no previous work has yet investigated this question.
in this paper we address this question by proposing a novel notion of log completeness.
roughly a log of traces extracted from a given system is k complete i adding any new trace to the log will not change the resulting model ktails would build for it.
since the system and its full set of traces is unknown we cannot know whether a given log is k complete.
however we can estimate its k completeness.
we call this estimation k con dence .
we formalize the notion of k con dence and implement its computation.
preliminary experiments show that k con dence can be e ciently computed and is a highly reliable estimator for k completeness.
general terms algorithms design experimentation keywords dynamic speci cation mining probabilistic approach .
introduction dynamic speci cation mining algorithms extract candidate speci cations from logs of execution traces.
one such well known algorithm is k tails rst introduced in .
ktails input consists of a set of traces and a positive number k. its output is a nite state automaton approximating the behavior of the system from which the traces have been extracted.
it works by starting with a most re ned model and iteratively coarsening it by merging states whose future permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
are equivalent.
over the last two decades the algorithm has been implemented and used in many variants e.g.
.
the usefulness of a speci cation mining algorithm in general and of k tails in particular depends on the quality of its input log.
on the one hand if there are too few traces the constructed model may not be a good representation of the behavior of the system under investigation.
on the other hand if there are many traces perhaps some are redundant and executing the algorithm over all of them is a waste of resources.
given a set of traces how can one know whether it includes enough but not too many traces to build a representative model?
while many have used the ktails algorithm no previous work has yet investigated this question.
in this paper we address this question by proposing a novel notion of log completeness.
roughly a log of traces extracted from a given system is k complete i adding any new trace to the log will not change the resulting model ktails would build for the log.
since the system and its full set of traces is unknown we cannot know whether a given log is k complete.
however we can estimate the probability that the log is k complete.
we call this estimation k con dence .
a low k con dence of say .
hints that the model which may be built by the k tails algorithm is probably far from characterizing the behavior of the system under investigation.
there is high probability that additional traces will change the model which k tails would build.
given a log with such a low k con dence one should better look for additional traces.
a very high k con dence of say .
hints that the model which may be built by the k tails algorithm is probably very close to correctly characterize the behavior of the system under investigation.
there is very low probability that additional traces will change this model.
we compute the k con dence of a set of traces by estimating the probability that it includes all possible sequences of lengthkthat the system under investigation can generate.
the estimation is based on the appearances of the sequences in the speci c traces we see in the log and on their frequencies.
it does not require running the k tails algorithm.
an interesting and important feature of k con dence is its non monotonicity.
speci cally as traces are added to a log its k con dence may increase or decrease.
indeed in the absence of additional information e.g.
about the order in which traces are produced a new trace may introduce new information which should lead us to revise our previous estimations.
note however that the k con dence of a log does not depend on the order of traces in the log.
we have implemented the computation of k con dence and evaluated it over several models.
the evaluation shows that k con dence can be e ciently computed and is a highly reliable estimator for k completeness.
thus it can be e ectively used by engineers using the k tails algorithm.
the next section presents two examples.
sect.
presents the formal de nitions and the computation of k con dence.
sect.
presents a preliminary evaluation and sect.
discusses design decisions and limitations of our work.
sect.
discusses related work and sect.
concludes.
.
examples we use an example to demonstrate k con dence usage and another one as a running example for this paper.
the traces and models described below are available in .
we consider the example cvs client presented by lo and khoo in .
the client provides the following interaction scenarios initialization multiple le upload download and deletion multiple directory creation and deletion.
consider an engineer having a log of traces from this system trying to extract a model of its behavior.
fig.
shows the model suggested by k tails with k for this log the dashed transitions login tostorefile rename tologout and removedir toremovedir arenotpart of the model suggested by k tails for this traces log .
can she be con dent that this model is a good representation of the system s behavior?
perhaps the model is partial and more traces are needed?
indeed adding more traces and feeding the resulting log of traces to k tails results in a revised model as shown in fig.
including the dashed transitions .
our tool computes a k con dence of .
to the rst log of traces and a k con dence of .
to the second log of traces for k .
these k con dences are essentially the probabilities that the logs are k complete computed solely based on the traces themselves.
on the one hand if the engineer has set a minimum kcon dence threshold of .
which we suggest to be a reasonable choice she would not have stopped analyzing traces too soon i.e.
before nding the additional transitions.
on the other hand should the engineer continue to analyze more traces of this system?
given the computed kcon dence of .
the probability that additional traces will reveal new behaviors is very small.
indeed in our example an extension of the log with additional traces many of them new traces not duplicates of any of the traces seen before resulted in a slightly higher k con dence of .
but in the same model as was suggested by k tails for the second log of traces.
thus by stopping the analysis when k con dence passed the .
threshold the engineer saved the resources required in order to produce and analyze the additional traces yet did not lose any information.
as a running example for this paper we consider a simpler model representing a le reading protocol.
the model and randomly generated traces from it are shown in fig.
.
.
k completeness and k confidence .
basic definitions a trace over an alphabet is a nite word he1 e2 e miwheree1 e m2 .
forj we use j to denote the jth element in .
figure cvs model as mined by k tails from the log of traces without the dashed transitions and from the log of traces including the dashed transitions letmbe a model over an alphabet .
we use t m to denote all traces accepted by the model m. a log ofm l t m is a nite set of traces from t m .
we denote the set of all possible logs of mbyl m .
we characterize the k tails algorithm using a property we call k directly follows .
roughly the property k directlyfollows for a sequence of events es he1 e2 e kiholds in a trace i the sequence appears somewhere in the trace.
we formalize the k directly follows property using a pair of functions.
the rst function ktrmaps every trace and a sequence esto a value inf0 1g intuitively ktrassigns a value to the relation between the k directly follows property and the trace .
the second function klogmaps subsets of f0 1gtof0 1g aggregating the results of ktrper sequence from the trace level to the log level.
the formal de nitions of the two functions follow the semantics of k directly follows .
formally de nition k directly follows property .
ktr he1 e2 e ki 19jv m k j m em 0otherwise klog s 12s 0otherwise example .
fortr1andtr3shown in fig.
k and the sequences of length khopen readi hread readi hopen openi we have ktr tr1 hopen readi ktr tr3 hopen readi ktr tr1 hread readi ktr tr3 hread readi ktr tr1 hopen openi ktr tr3 hopen openi .
for a logftr1 tr3gand the same three sequences we have klog fktr tr1 hopen readi k tr tr3 hopen readi g klog fktr tr1 hread readi k tr tr3 hread readi g klog fktr tr1 hopen openi k tr tr3 hopen openi g .
606tr1 open read close tr2 open read read close tr3 open read read close open read read close open read close tr4 open read read close tr5 open read read close open read read read read read close open read close tr6 open read close open read close tr7 open read close open read read close open read close tr8 open read read close figure a simple example model and randomly generated traces .
k completeness we say that a log l2l m is k complete if the information one may extract about the k directly follows property from the log lis equal to the information one may extract about this property from any log that includes l and thus speci cally from all the traces in t m .
formally de nition k completeness .a logl2l m is k complete i 8l02l m s.t.l l0 8es2 k klog fktr es j 2lg klog fktr es j 2l0g .
the intuition behind this de nition is as follows.
consider a model produced by k tails for a log and a new trace whose all subtraces of length k appear in the produced model.
applying k tails to a new log that consists of the original log and the new trace produces the same model.
example .
for the logs l ftr1g l0 ftr1 tr3g and the sequencehread readi klog fktr hread readi j 2lg klog fktr hread readi j 2l0g .
thus l ftr1gis not complete.
.
k confidence estimating k completeness for a xed number kand a logl2l m our goal is to compute the probability that lis k complete i.e.
to compute l s k con dence.
we de ne a random variable y over t m which maps a trace to its k directly follows property results.
formally y y ktr es example .
to continue our example from fig.
the trace tr1and the sequences hopen readiandhread readi we have y tr1 andy tr1 .
fory2f0 1gj jkwe denote the probability that yequals yby y y p ycan be viewed as a k dimensional array over f0 1g y is the probability that in a random trace from t m we get the values of the k directly follows property as they are encoded in y. it is determined by mbutmis considered unknown.
we consider all traces from a log lto be samples from y. we assume that traces are randomly and independently chosen fromt m .
ifjlj nwe denote them by y1 y2 y n. these are independent identically distributed random variables versions of y. another random variable we de ne isyn which aggregates all these samples to the k directlyfollows values of the entire log yn yn klog fyi j1 i ng we now de ne the true but unknown k directly follows values f in order to later compute the probability that ynis equal to it f f klog fy j y 0g example .
for the model shown in fig.
and the sequencehread readi since there are traces in t m where the sequence appears and others where it does not appear we havef klog fy j y 0g klog f0 1g for the same model and the seqeuncehread openi since the sequence does not appear in any trace int m we havef klog fy j y 0g klog f0g note thatmdetermines f it is independent of any speci c log .
we can now write def.
using the above notation as follows a log lof sizenis k complete i yn f recall that our goal is to compute the probability that l is k complete.
using the notation de ned above what we are looking for is p .
de nition k con dence .the k con dence of a log of sizen l2l m isp .
.
computing k confidence we useesto denote the sequence he1 e2 e ki.
since it is xed we omit from the formulas below.
the probability that the k directly follows property does not hold in the model but appears in one of the traces is zero.
thus we only need to consider the other case where the sequence of length kdoes not appear in the traces yn but is possible in the model f .
formally p p f esp f p f p f f q i np f f we useqesto denote the probability that the k directlyfollows property for esholds on a random trace from t m i.e.
that the sequence he1 e2 e kiappears somewhere in the trace.
when f we have qes andq i np qes n. sinceqesis unknown we estimate it using the average of thenrandom variables yi qes nx i 1yi n and so overall we have p x fesj qes 0g qes n 607es n n n n n n n n close read .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
close open .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
open read .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
open open .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
open close .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
read open .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
read read .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
read close .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
close close .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
con dence .
.
.
.
.
.
.
table example k con dence computation for the log of traces shown in fig.
with k .
if we are using a threshold we stop the computation after traces have been analyzed.
see sect.
.
.
.
example computation we demonstrate a k con dence computation on our running example model and generated traces shown in fig.
.
for these traces table shows the computation of kcon dence for k .
each row corresponds to a di erent sequencees e.g.
the rst row corresponds to the property close directly follows read .
each column corresponds to the addition of a new trace to the accumulating log.
the table cell for row esand column n jshows the value qesfrom equ.
.
at the bottom line of each column we show the accumulating total p which represents the probability that the set of traces analyzed so far is kcomplete i.e.
k con dence as de ned in equ.
.
thus the table shows the intermediate k con dence values.
as an example for n the computed value qclose open see equ.
is the probability to have an instance of close open in a random trace given the traces analyzed so far.
since this is the third trace already the negative contribution to the accumulating k con dence is see equ.
.
that s the probability that in a random log of size close open will not occur.
given a threshold of in this example one could stop after analyzing only traces from the original log and have high con dence that the model built by k tails for this traces log will not change if additional traces are considered.
note that in our example as traces are added k con dence may increase or decrease.
in fact the rst computed kcon dence is always already however in general the larger the log the lesser the expected decrease in k con dence when a new trace is added we demonstrate it in this example by showing the computed values for n andn .
in sect.
we discuss this non monotonicity and the need for a minimal number of traces to produce useful results.
.
ev aluation we have implemented the computation of k con dence.
the implementation gets as input a log a set of traces and a numberk.
note that the k con dence computation does not need to run the k tails algorithm.
given a log l for each trace 2l and for each sequence of length k es we computektr es .
the computed values are used as input for the computation of the log s k con dence.
we conducted preliminary experiments to check whether k con dence can be used as an e ective proxy for true kcompleteness.
all logs models and implementation code described in this paper are available for inspection and reproduction together with documentation from .
.
methodology we use two measures to evaluate the e ectiveness of kcon dence k reliability and k redundancy.
we de ne the k reliability of a log to be if the log is k complete and otherwise.
for a set of logs l a mean k reliability close to hints that most of the logs are k complete.
we de ne the kredundancy of a log to measure how close is it to its minimal pre x log which is k complete assuming an arbitrary xed order of traces .
for a set of logs l a mean k redundancy close to and a low standard deviation hint that the logs do not include much redundant traces.
formally de nition k reliability .
the k reliability of a log lis rel l 1lis k complete 0otherwise.
de nition k redundancy .given a log l in a xed arbitrary order let imin l be the minimal index of traces in l such that the set of traces imin2lis k complete.
the k redundancy of lisred l imin l jlj.
example .
consider our running example and the results of computing its con dence fig.
and table .
this log s reliability is rel l .
since it reaches completeness already after the 3rd trace and we stopped the computation when reaching the .
threshold after the 6th trace its 2redundancy is red l .
note that to calculate k reliability and k redundancy as in the above example one must know the system from which the traces were extracted so that she can compute the true value for each sequence.
this is typically unknown in a realworld setting but it is known in our controlled evaluation.
.
experiment design for each model we used the following experiment protocol.
we rst generated traces from the model using the trace generator of with high state coverage.
we then created an initial log by randomly selecting a minimal number of traces and iteratively computed the current log s kcon dence and added a trace to it.
we kept adding traces to the current log until we reached a xed k con dence threshold of .
or we ran out of traces to add .
finally we computed the k reliability and k redundancy of the nal log we checked true k completeness using a model checker i.e.
by expressing the k directly follows properties in temporal logic and verifying them against the model .
we used k .
we repeated the above protocol for each model times and computed the mean of k reliability and k redundancy for the sets of logs.
608model j j s t a.l.
java.net.datagramsocket java.net.multicastsocket java.net.socket java.net.url java.util.formatter java.util.stringtokenizer table models used in our evaluation taken from pradel et al.
.
for each model we report the size of the alphabet the number of states s the number of transitions t and the average length of the generated traces used in the logs truncated .
model jljc.
m rel.
m red.
m sd java.net.datagramsocket .
.
.
java.net.multicastsocket .
.
.
.
java.net.socket .
.
.
.
java.net.url .
.
.
java.util.formatter .
.
.
.
java.util.stringtokenizer .
.
.
.
table experiment results.
each experiment was repeated times for each of the models.
for each model we report the average number truncated of traces required to reach k con dence the mean of the calculated k con dence c. m k reliability rel.
m and the mean and standard deviation of k redundancy red.
m sd .
traces generated using the trace generator of .
.
results we used nite state automaton models from pradel et al.
.
table lists the models we used.
for each model we report the size of the alphabet the number of states and transitions and the average length of the generated traces used in the logs.
table shows the experiment results on the models listed in table .
the results show that our k con dence computation is highly reliable .
in only one case java.net.socket we ran out of traces to add before k con dence reached the .
threshold.
on the other hand k redundancy is not always low which hints to the conservative nature of the k con dence de nition.
all experiments were executed on an ordinary laptop computer intel i7 cpu .0ghz 8gb ram with windows bit os java .
.
bit.
for all models in all our experiments k con dence computation never exceeded milliseconds.
this shows that the k con dence computation is fast.
it is not surprising as the computation is by de nition linear in the number of traces in the log.
.
threats to validity we now discuss threats to the validity of our results.
first the selection of models in our evaluation may not represent typical systems.
we used publicly available models taken from .
yet we do not know if these are representative of real world systems.
second in our evaluation we used a publicly available trace generator from with high state coverage.
it is possible that one may get di erent results if a di erent trace generator or a di erent coverage criteria are used.
finally the selection and order of traces in the log affect the point where the analysis may reach the con dence threshold and thus a ect the point used to compute redundancy although by de nition the k con dence and kcompleteness of a log do notdepend on the order of traces in it .
we mitigated this by using randomization in the selection of traces and in the order in which they were analyzed and by repeating all evaluation experiments times.
.
discussion and limitations we now discuss some important design decisions and several limitations of our present work.
an important assumption underlying our work is that the traces are randomly and independently chosen from t m .
if this is not the case e.g.
if one uses a biased trace generator which favors some system features over others and the bias isknown it may be possible to account for this bias in the computation of the qess and improve it.
one may be concerned about the non monotonicity of our notion of k con dence as traces are added to a log its kcon dence may increase or decrease.
however we consider this non monotonicity an advantage in the absence of additional information e.g.
about the order in which traces are produced a new trace may introduce new information i.e.
reveal a new k length sequence which should lead us to revise our previous estimations see e.g.
in table the con dence decreases when the 3rd trace introduces the sequence close open .
moreover as ngrows the probability that a sequence that is possible in the system has not yet been seen decreases and so roughly the larger the log the lesser the expected decrease in k con dence when a new trace is added and the expectation of a decrease approaches zero at the limit a formalization and proof for this claim is outside the scope of this paper .
still in contrast it is important to note that our notion of k completeness is monotonic i.e.
by de nition any extension of a k complete log is k complete.
also by its de nition the k con dence of a log does not depend on the order of traces in it.
finally another limitation relates to the size of the log.
our experience shows that for very small logs e.g.
under traces k con dence results are very sensitive and uctuate much so they are practically useless.
in general the larger the alphabet the more traces are required in order to get useful results and reduce the risk that additional traces decrease the computed k con dence .
still note that this limitation is typically not a problem in practice because realworld logs consist usually of many traces.
.
related work dynamic approaches to speci cation mining look for candidate speci cations in execution traces see e.g.
.
none of these to the best of our knowledge has considered the con dence one could have in the completeness of the input logs.
in dallmeier et al.
consider dynamic speci cation mining and ask the following question what makes us believe that we have seen su ciently many executions?
indeed it seems that in our present work we ask a similar question.
however our work and dallmeier et al.
work di er fundamentally.
dallmeier et al.
look for the answer in test case generation and in static speci cation mining.
in their work a partial set of traces is enriched in order to explore previously unobserved aspects of the execution space including more general behavior and more exceptional behavior.
in contrast we consider a black box setting and address this question by providing a formal probabilistic measure to the notion of su ciently many traces .
we do not suggest ways to make an incomplete log more complete.
instead we provide a probabilistic measure of k con dence which allows engineers who use the k tails algorithm to assess the k completeness of the traces they have.
609hee et al.
presented a probabilistic approach to log completeness in the context of the algorithm which mines petri nets in particular work ow nets and is used extensively in the eld of process mining.
our work is inspired by the work of hee et al.
and extends it we present a notion of log con dence for the well known k tails algorithm with preliminary evaluation of its e ectiveness in the context of real world models.
to the best of our knowledge no other work has considered the question of estimating log completeness with regard to k tails speci cally or with regard to other dynamic speci cation mining algorithms.
.
conclusion and future work we presented k con dence as a novel means to estimate the k completeness of a log of traces i.e.
whether additional traces may change the model that k tails builds for the log.
our preliminary implementation and evaluation show that k con dence is an e ective proxy for true k completeness.
thus it can be used to help engineers decide whether additional traces are required.
no other work in the area of speci cation mining has addressed this question before.
we are working on a major extension and generalization of the present work which goes beyond the k tails algorithm and de nes a black box probabilistic framework with a general notion of log con dence in the context of dynamic speci cation mining.
we plan to apply this framework to additional dynamic speci cation mining algorithms e.g.
synoptic and mining of scenario based triggers and e ects .
we hope to report on this framework in a future paper.
.