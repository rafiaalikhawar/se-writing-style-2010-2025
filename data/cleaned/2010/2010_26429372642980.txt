automated synthesis and deployment of cloud applications roberto di cosmo roberto dicosmo.orgmichael lienhardt michael.lienhardt inria.frralf treinen treinen pps.univ parisdiderot.fr stefano zacchiroli zack pps.univ parisdiderot.frjakub zwolakowski jakub.zwolakowski inria.fr univ paris diderot sorbonne paris cit pps umr cnrs f paris france antoine eiche mandriva fr aeiche mandriva.comalexis agahi kyriba corporation usa alexis.agahi kyriba.com abstract complex networked applications are assembled by connecting software components distributed across multiple machines.
building and deploying such systems is a challenging problem which requires a signi cant amount of expertise the system architect must ensure that all component dependencies are satis ed avoid con icting components and add the right amount of component replicas to account for quality of service and fault tolerance.
in a cloud environment one also needs to minimize the virtual resources provisioned upfront to reduce the cost of operation.
once the full architecture is designed it is necessary to correctly orchestrate the deployment phase to ensure all components are started and connected in the right order.
we present a toolchain that automates the assembly and deployment of such complex distributed applications.
given as input a high level speci cation of the desired system the set of available components together with their requirements and the maximal amount of virtual resources to be committed it synthesizes the full architecture of the system placing components in an optimal manner using the minimal number of available machines and automatically deploys the complete system in a cloud environment.
this work was supported by the french anr project anr2010 segi aeolus and partially performed at irill center for free software research and innovation in paris france permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
introduction in contrast to classic monolithic software that runs locally on a single machine large distributed systems are built from many running services executing on possibly heterogeneous virtual machines orlocations and collaborating to provide the expected functionality to nal users.
the system architect must choose which services to use and how to con gure them knowing that services may depend on and or be in con ict with each other consider fault tolerance and quality of service issues and provide enough instances of each service design the physical architecture on which to run the system trying to keep its cost reasonable with nonetheless enough locations with enough resources e.g.
ram disk space bandwidth to allow the installation and the good execution of the services they host choose which implementation of each service to install on which location knowing that implementations usually in the form of packages have dependencies and con icts too.
once all this planning is done the deployment phase must provision the required virtual machines install the right packages on each of them and nally start and interconnect services in the right order.
this is a daunting task not unlike building a puzzle each running service package and machine being a piece where one only knows the overall expected functionality.
to reduce the complexity of this process many industrial initiatives develop tools that allow to select con gure and push on the cloud some well de ned services.
however these tools are only useful once the puzzle is solved i.e.
when the right services and packages have been selected the locations on which they must be deployed have been chosen and the way of con guring them in a manner that satis es all the requirements has been found.
solving this puzzle currently requires a signi cant amount of human expertise so that in practice large software stacks are often managed using custom scripts and manual techniques which are error prone and fragile .
in this article we present a toolchain developed in the framework of the aeolus project that provides a generic automatic and sound alternative to these scripts and techniques.
the toolchain is composed of two tools zephyrus automatically generates an abstract representation or con guration of the target system according to a concise speci cation of the expected functionalities.
it takes into account the set of available services which can serve as building blocks with their requirements replication policies and resource consumption characteristics information concerning the implementation of the services e.g.
that theapache service is provided by the www servers apache package on gentoo linux by the apache2 package on debian etc.
and the maximum amount of virtual machines available together with their characteristics.
it is also able to minimize the amount of needed resources.
armonic takes the full system con guration produced by zephyrus and deploys it by provisioning the required virtual machines on a cloud computing platform such as openstack installing the needed packages on each machine it con gures the di erent services to establish the required connections and nally starts the services in the right order relying on precise metadata that describe the internal state machines and runtime dependencies of each service.
this toolchain decouples system design from system deployment.
it builds upon the sound formal foundations of the aeolus component model which describes each available service as a component type using ports tagged with an arity to encode requirements provides con icts and replication policy as well as an internal state machine to capture component life cycles.
zephyrus uses a stateless version of the aeolus model extended to take into account locations repositories packages and resources as detailed in packages and repositories are encoded following the now standard approach originated from .
the speci cations accepted by zephyrus are given in a rigorous syntax whose semantics de nes when a con guration satis es a speci cation.
based on this formalization zephyrus can be proven correct and complete it will always nd a con guration that is optimal w.r.t.
the chosen criterion if one exists.
furthermore the generated con guration is guaranteed to provide the expected functionalities and satis es the constraints de ned by the replication policies as well as the dependencies and con icts between services.
armonic then takes over and uses the information about the internal state machine of the components to determine a correct service activation sequence under the assumption that the dependency relation among services is acyclic which is usually the case.
paper structure.
section presents the toolchain through a realistic running example.
section discusses the internals of the various tools and presents the theoretical results establishing soundness completeness and complexity of the architecture synthesis phase.
section reports on experimentation with the toolchain as well as its adoption in an industrial context at kyriba corporation.
before concluding section discusses related work.
.
walkthrough in this section we describe zephyrus andarmonic by showing them at work on an example that is simple enough to be fully presented and yet realistic as it corresponds to a common use case of application deployment in the cloud.
zephyrus takes several inputs .
a description of all the existing components and their constraints which come in various formats due to their di erent origins e.g.
package database architectural choices machine physical resources etc.
this is called auniverse.
.
a description of the current system con guration existing machines which services are currently deployed where etc.
.
a high level speci cation of the desired system.
as part of the speci cation architects can include objective functions that they would like to optimize for such as the desire of minimizing the number of virtual machines that will be used for the deployment and hence the system cost .
.
use case deploying a wordpress farm the task we want to perform is deploying the popular wordpress blog platform on a private openstack cloud.
in addition to being realistic this use case is often used as a benchmark to showcase the characteristics of cloud provisioning platforms.
wordpress is written in php and as such is executed within web server software like apache or nginx.
additionally wordpress needs a connection to a mysql instance in order to store user data.
simple wordpress deployments can therefore be obtained on a single machine where both wordpress and mysql get installed.
serious wordpress deployments however that sustain high load and are fault tolerant are more complex and rely on some form of load balancing.
one possibility is to balance load at the dns level using servers like bind multiple dns requests to resolve the website name will result in di erent ips from a given pool of machines on each of which a separate wordpress instance is running.
alternatively one can use as website entry point an http reverse proxy capable of load balancing and caching for added bene t such as varnish.
either way wordpress instances will need to be con gured to contact the same mysql database to avoid delivering inconsistent results to users.
also having redundancy and balancing at the front end level one usually expects to have them also at the dbms level.
one way to achieve that is to use a mysql cluster and con gure the wordpress instances with multiple entry points to it.
constraints.
several design constraints should be taken into account when designing such a system.
some constraints come from package providers and cannot be easily changed.
for instance wordpress varnish etc.
usually come from software distribution packages and have their own dependencies and con icts which must be respected on each machine when installing the software.
on the other hand house requirements are de ned by system architects to capture some ad hoc policy.
for this use case we assume given the following requirements at least replicas of wordpress behind varnish or alternatively at least replicas with dns based load balancing since dns based load balancing is not capable of caching the expected load on individual wordpress instances is higher at least di erent entry points to the mysql cluster each mysql instance shouldn t serve the needs of more than wordpress instances 212figure zephyrus used to design a scalable fault tolerant wordpress deployment no more than dns server deployed in the administrative domain di erent wordpress and mysql instances are deployed at di erent locations.
similar constraints might exist on machine resources e.g.
we expect varnish to consume 2gb of ram and we don t want to deploy it to a smaller machine especially if in combination with other ram consuming services.
note that house requirements are not intrinsically related to the software components we are using but are rather an encoding of explicit architectural choices.
.
architecture synthesis figure shows the application of our toolchain to the design of a complex wordpress deployment like the one we have discussed.
on the left of the black arrow is a schematic representation ofzephyrus input on the right its output.
available services are depicted in the gure using a graphical syntax inspired by the aeolus model each one with its own requirements con icts and house replication policy.
component requirements are exposed as required ports that should be connected via bindings to matching provided ports o ered by other service instances respecting port replication constraints an upper bound or on the amount of incoming bindings for provided ports a lower bound on the amount of outgoing bindings to di erent service instances for required ports.
for example the fact that the http load balancer requires wordpress replicas is indicated by the annotation on its wordpress backend required port and the fact that the dns load balancer is incompatible with other dns services is indicated by the dnscon ict port.
note that our ports result in a very exible notion of dependency with choice any requirement can be satis ed by anycomponent providing the right port.
for instance if we require the port wordpress frontend we allow zephyrus to choose which of dns load balancer orhttp load balancer is the best to use.
to our knowledge zephyrus is the only tool to manage such exibility in dependencies.
1it is technically possible to co locate multiple say mysql instances on the same machine but it would be pointless to do so when we are seeking fault tolerance and load balancing.services and implementations.
zephyrus takes as input a description of the available service types and an implementation relation that maps each service to the set of packages implementing it.2these two parts of the universe are given as input to zephyrus as a json le that in our running example looks like this component types name dns load balancer provide require conflict consume name http load balancer provide require consume name wordpress provide require consume name mysql provide consume implementation the component types section describes the available component types with their ports as well as their non functional requirements like memory or bandwidth.
port names are distinguished from components or packages by a simple syntactic convention ports start with .
the implementation section maps services to the software packages that should be installed to realize them on actual machines.
package repositories.
unlike other tools zephyrus is fully aware of available package repositories with their dependencies and con icts and uses such information to ensure that package level con icts and dependencies are respected on all machines.
it is possible to associate di erent package repos2in the example we have kept things simple but zephyrus is capable of handling complex situations where the same service can be implemented by di erent packages on di erent machines according to the locally installed os.
213table speci cation syntax s trueje op e speci cation jsandsjsors js sjnots e nj jn eexpression je eje e kjtjp elements j j fjr slg sl truejelop el local speci cation jslandsljslorsl jsl sljnotsl el nj ljn ellocal expression jel eljel el l kjtjp local elements j jo op n j resource constraint jr jrjr jr repository constraint op j j operators itories to di erent locations allowing to handle deployment of heterogeneous systems.
the size of a repository may be huge the debian squeeze repository contains packages so zephyrus uses coinst to abstract packages into a set of much smaller equivalence classes and yet su cient to capture all package incompatibilities.
available virtual machines.
another essential part of zephyrus input is the description of the initial con guration i.e.
the set of available machines with information on their resources memory package repository existing services and packages.
in our example we start with an initial con guration consisting of bare locations with 2gb of ram.
such con guration is fed to zephyrus in json format e.g.
locations name loc1 repository debian squeeze provide resources name loc2 repository debian squeeze provide resources target system specification.
zephyrus accepts a speci cation of the desired target system.
speci cations are de ned according the abstract syntax presented in table .
a speci cation sis a set of basic constraints e op e combined using the usual logical connectors.
these basic constraints specify how many elements packages component types etc should be in the generated con guration using terms of the form that correspond to the number of instances of element in the system.
for instance one might state that we want at least instances of the component type apache apache where apache represents the number of apache instances in the con guration.
moreover it is possible to express constraints on locations.
locations can be speci ed in our syntax with the term j fjr slgwhere j is the constraint on the resource available on that machine jris the set of repositories that can be installed on that machine standing for any repository and slis a constraint specifying the contents of the machine basically slisswithout locations .
for instance we can specify that no location with less than 2gbof ram and redhat installed should have a mysql running mem 2g redhat mysql .
for our running example we need exactly one wordpress frontend i.e.
exactly one service o ering a wordpress frontend port and that no machine is deployed with more than one instance of either mysql wordpress services on it.
wordpress frontend and mysql and wordpress note that no constraint is imposed on the co location of di erent services on the same machine.
optimization criteria.
inzephyrus one may request a solution that is optimal w.r.t.
a speci c objective function.
currently zephyrus supports two built in optimization criteria namely compact andconservative which respectively minimize the number of components and locations used or their di erence with respect to the initial con guration.
running zephyrus.
we are now ready to ask zephyrus to compute the nal con guration zephyrus u univ.json opt compact ic conf.json spec sp.spec repo debian squeeze ds.coinst in addition to the obvious parameters universe optimization function con guration speci cation we pass an extra one the repo option tells zephyrus that all the information about the packages contained in the repository named debian squeeze is available in the le ds.coinst.
the actual output of zephyrus contains a complete description of the system to be deployed it is too long to be listed here in full so we only highlight some excerpts of it.
the format is the same as for con gurations and starts with the description of the locations locations name loc1 provide resources repository debian squeeze packages installed name loc2 provide resources repository debian squeeze packages installed mysql server wordpress we see that each location is associated to a list of packages that should be installed there.
only the root packages are listed and zephyrus has already checked that they can be co installed satisfying dependencies and con icts.
the second part of the output is the list of service instances present in the system mapped to their locations components name wordpress type wordpress location loc1 name wordpress type wordpress location loc2 name mysql type mysql location loc2 finally the third part of the output lists the bindings that connect ports of service instances together 214figure screenshot of armonic web interface.
bindings port wordpress backend requirer http load balancer provider wordpress port wordpress backend requirer http load balancer provider wordpress port sql requirer wordpress provider mysql the con guration corresponding to zephyrus output is depicted on the right of figure where shaded boxes denote locations we omit installed packages for the sake of readability.
all choices there load balancer mapping between services and machines bindings etc.
have been made by zephyrus .
note how services have been co located where possible minimizing the number of used machines only out of the available machines have been used the proposed solution is optimal w.r.t.
the desired metric.
.
configuration deployment once we have the con guration generated by zephyrus as output we are left with the task of turning it into a running system.
while zephyrus output is agnostic as to the nal deployment tool we have developed our own tool called armonic to work closely in conjunction with zephyrus .
starting from the con guration generated by zephyrus armonic rst provisions the needed virtual machines vms on a target private openstack cloud creating new instances as needed.
the resource information cpu storage memory contained in zephyrus output are used by armonic to choose appropriately sized vms aka avors .
after provisioning armonic takes care of con guring vms using an agent orchestrator architecture each vm comes with an agent which receives con guration instructions from a central orchestrator.
during vm con guration armonic installs on each vms the packages dictated by zephyrus tunes service con guration les to implement bindings e.g.
to connect a wordpress to a mysql armonic will patch a wordpress con guration le to point to a given vm ip address and port and starts services in the right order as it goes.
in our example a wordpress instance is deployed at location loc1.
however a mysql database must be available before the deployment of wordpress in order to properly start the service.
to address this armonic devisesadeployment plan using bindings to determine a suitable deployment ordering and follows it during component deployment.
in the example armonic will deploy mysql right away as it has no further component dependencies then wordpress and nally the load balancer.
the armonic orchestrator is equipped with a web interface shown in figure at work on the deployment of a simpli ed version using a single mysql database instead of a cluster of the con guration of figure .
to deploy an application users can simply feed zephyrus output into thearmonic web interface and then monitor live the state of deployment.
in figure the deployment is almost nished all components are deployed and connected except the last wordpress instance and the load balancer which are shown grayed out as they are only partially deployed.
the deployment of this use case takes about minutes including building and booting virtual machines package installation and service con guration.
.
toolchain internals .
minimizing input figure presents a simple schema of the architecture of zephyrus which is basically structured into ve blocks.
the input phase of zephyrus collects all the data provided by the user.
for each location we take into account not only the available services but also all the possible ways to deploy them i.e.
packages that must be installed to realize them together with their dependencies this can amount to handle tens of thousands of packages for each location and a na ve approach would simply be unfeasible.
we believe this is one of the fundamental reasons why competing tools do not represent package relationships explicitly or completely with the consequence of potentially producing con gurations which are not deployable due to package incompatibilities unknown to the tool.
we compare this aspect of zephyrus with alternative approaches in section .
to render the problem tractable zephyrus performs several simpli cation passes on the input data that greatly reduce its size the universe is trimmed by removing all services that are not in the transitive closure of the services present in the initial con guration or the request package 215figure overall architecture of zephyrus repositories are pruned by keeping only packages that implement services which were not removed by the previous simpli cation phase lower and upper bounds on the needed resources and components are computed and only the minimum estimated number of available locations is kept.
all these operations are safe as we can prove that they do not exclude any correct solution.
a second important simpli cation is achieved by using a slightly modi ed version of the coinst tool which reduces by several orders of magnitude the data present in software package repositories like those o ered by the debian or redhat distributions while retaining all the coinstallabilityinformation needed to determine if a set of packages can or cannot installed together.
we refer the interested reader to for precise gures and detailed proofs we just recall here that this simpli cation is safe and preserves all correct solutions.
.
constraint generation the second phase of zephyrus translates the trimmed input into a set of constraints over non negative integers.
these constraints use di erent variables for the number of instances to create on each of the locations for each of the types in the universe and also variables representing the packages that must be installed on each location.
the constraints impose that the instances respect the de nition of their type in the universe the way how instances are implemented by packages the compacted dependencies and con icts between packages and the problem speci cation.
the most interesting of these constraints ensure that it is possible to create the bindings between all instances according to the capacity constraints.
these constraints distinguish our approach from others they are necessary due to the exible dependencies we have on ports.
constraints are constructed using auxiliary variables b p tr tp for the number of bindings on port pbetween requesting instances of type trand providing instances of type tp.
on the example of section .
these particular constraints for the bindings on port sqllook like this b sql wp mysql mysql b sql wp mysql wp b sql wp mysql wp mysql here expresses that the number of bindings on port sql between instances of the two types is at most the number of instances of the providing type mysql times since any component of that type can bind to at most instances that the number of bindings on port sqlis at least the number of instances of the requesting type wptimes thenumber of binding each component of type wprequires and nally states that the number of bindings is at most the number of pairs of instances of type wpwith instances of type sql.
this last restriction expresses that no two bindings may exist between the same pair of instances.
the ability to capture as simple integer constraints the existence of a complete architecture corresponding to a speci cation is the cornerstone of our approach.
it allows us to deal with the many facets of a system design as a whole and thus ensures the completeness of our tool and the optimality of the generated con guration.
in particular if the output of zephyrus indicates that several services are to be installed on the same machine we know that no con ict between the packages that realize them will arise on actual machines.
.
external solvers the generated constraints as well as the optimization function are expressed using the minizinc constraint modelling language .
this allows us to employ any of the many existing constraint solvers that support minizinc .
zephyrus can currently use gecode an e cient open source solver or several of the solvers provided in the g12 suite .
the tool exploits this exibility by implementing asolver portfolio approach that reduces execution time by running several solvers in parallel and stops as soon as one of the solvers nds a solution.
.
configuration generation when the external solver nds a solution for the generated constraint the next part of zephyrus proceeds to transform that solution which is a simple mapping from variables to integers into an actual con guration.
the two main challenges of that generation are i to reuse as many existing parts of the initial con guration as possible in order to minimize the impact on the existing system and ii to correctly generate bindings between the instances taking into account that any two instances can be bound on a given port at most once.
the algorithms employed in this generation phase are presented in detail in .
once the con guration has been generated it can be written to a le in two di erent formats either a the same json format used for the input con guration which precisely describes all the con guration features and is used by armonic as input or b the dotformat that encodes the con guration into a graph that can be viewed using the dot program to visualize the synthesized architecture.
if no con guration satis es the given input constraints zephyrus will exit with an error message and produce no output les.
.
synthesis soundness and completeness an important property of zephyrus is that all its parts have been formalized.
in particular the translation into constraints and the generation of the con guration two very complex and important pieces of zephyrus have been precisely described and proven correct in where the following results have been shown for zephyrus theorem soundness .the con guration generated by zephyrus is correct w.r.t.
the input universe and speci cation.
theorem completeness .if there exists a con guration that validates the input universe and speci cation then zephyrus will successfully generate a correct con guration.
216figure armonic representation of mysql and wordpress component types.
theorem optimality .the con guration generated by zephyrus is optimal w.r.t.
the input optimization function.
.
deployment planning virtual machine selection.
in this paper armonic uses the popular openstack platform to provision virtual machines starting from the locations entries found in zephyrus output to determine machine names and resources compute storage and memory capacity .
in order to map resources to the available vm avors a correspondence table is de ned between provide resources and openstack avors for instance m1.small using this table armonic can create vms using the openstack api e.g.
nova boot flavor m1.small image debian squeeze loc1 component life cycle.
armonic associates each component type to an acyclic state diagram that captures the component life cycle.
as an example figure shows the life cycles for the worpdress and mysql component types that we have used in the walkthrough of section .
di erent states may require and provide di erent ports.
for instance mysql s active state provides a port sql denoting that such port can be depended upon only when that state in the mysql life cycle has been reached.
given that wordpress con gured and subsequent state s require that port wordpress cannot enter such state before mysql has entered its active state.
determining deployment order.
section .
brie y introduces the need of a component deployment plan.
computing such a plan can be quite challenging even undecidable depending on the expressivity of component constraints.
hence armonic makes several simplifying assumptions to keep the problem tractable.
first armonic currently assumes that all vms are empty with no services initially deployed on them.
this assumption simpli es deployment of services because it ignores recon guration needs.
second we suppose there is only one path to reach a given state while armonic life cycle representation allows for multiple paths.
finally we suppose that there are no circular dependencies between components.
we are working on an improved planning algorithm which will ad dress these limitations and also allow for optimizations such as maximally parallel component deployment.
.
service configuration to connect components according to zephyrus bindings armonic has to generate service con guration les and may have to create resources.
for instance connecting mysql to wordpress consists of creating a mysql database and user with the appropriate permissions and making a wordpress con guration le point to the right ip address port db name and user name.
to automate this process armonic allows to attach additional information to provide and require ports.
thus the provide port sql of mysql exposes three required variables a database name a user name and a user password.
the require port sql of wordpress exposes these variables with prede ned values.
since the component mysql is the provider of the bindings sql which has wordpress as requirer armonic uses this information to bind requirer and provider con guration variables.
in this case armonic will call the provide port sql of mysql with values of require port sql of wordpress.
this action will create the database and the mysql user.
these values will then be used by the armonic agent to patch the wordpress con guration le.
.
experimentation the complete toolchain presented in this paper is available as free software released under the gpl license.
zephyrus amounts to about .
lines of ocaml and is available at armonic is about .
lines of python plus glue code for component life cycles written in shell script or augeas and is available at .
we have experimented the complete toolchain in both articial and industrial settings in this section we present some of our ndings.
as the gures for armonic are dominated by the deployment time used by system level tools package managers service startup etc.
and also because we have already brie y presented them at the end of section .
we focus here on zephyrus .
.
synthesis efficiency given that the architecture synthesis part of our toolchain implemented by zephyrus has a daunting complexity in theory one may ask whether this part could be a bottleneck of our approach.
in order to answer this question we have conducted several architecture synthesis benchmarks on both realistic and extreme use cases.
the ones we illustrate here are variants of the wordpress example described in section .
there are however three important changes needed to properly benchmark it the use case is parameterized to scale it up and to demonstrate how zephyrus handles problems which require more and more components and locations i the rst parameter is the minimum replication constraint on the wordpress backend port required by the load balancer ii the second parameter is the minimum replication constraint on the sqlport required by wordpress components .
the resources associated to available locations are inspired by amazon s ec2 vm o ering.
we took what 217figure wordpress synthesis benchmarks for increasing values of the replication constraints on wordpress backends x axis and mysql y axis amazon calls old previous generation general purpose machines.
so there are four types of locations available corresponding by cost and capacity to amazon instance types m1.small m1.medium m1.large and m1.xlarge .
we have provided zephyrus with a nite but large enough number of machines for each instance type .
we use a single package repository associated to each machine and a single package implementing all the available component types.
this simpli cation does not a ect the test results as all component types in this benchmark are co installable anyhow.
we have used a portfolio of solvers as discussed in section .
consisting of the following solvers gecode the standard nite domain constraint solver from the g12 suite and the g12 cpx constraint programming with explanations solver from the g12 suite.
as these solvers are optimized for di erent goals each of them works better in some situations and worse in others.
it is very di cult to guess beforehand which solver is more adapted to a speci c constraint problem instance.
the portfolio approach permits us to work around this obstacle by trying these three approaches at the same time.
we have varied the two use case parameters from to .
execution times are obtained as average of runs on a commodity desktop machine intel i7 .
ghz gb of ram .
the diagram in figure shows that a vast majority of cases are solved very quickly in less than one minute.
only the larger ones can take more than minutes e.g.
the case which is the highest peak in the chart.
to put this worst case solving time into perspective please note that the largest use case consists of components interconnected by bindings and distributed over machines.
this surpasses by a signi cant margin the size of most professional wordpress deployments.
.
application to continuous integration zephyrus has been deployed in a large industrial use case at kyriba corporation3 a large software editor providing software as a service treasury management solutions.
in figure local quali cation process at kyriba figure remote quali cation process at kyriba the following we o er a return on that experience validating the usefulness of the proposed approach in an industrial setting.
this use case highlights the importance of considering all system design constraints together and the bene ts of statically detecting when they are not satis able in which case zephyrus will exit with an error.
it also shows the exibility of our toolchain by relying on a in house deployment back end other than armonic for the actual deployment.
kyriba solution is a complex software platform composed of more than components deployed on multi tier architectures with many di erent versions running at the same time.
maintaining the consistency of the system as a whole is a major undertaking.
to address this challenge kyriba has invested in completely automating the build integration and deployment processes.
kyriba distinguishes two software quali cation processes a local one run by individual developers on their machines and another more thorough one run on a remote continuous integration ci service.
heavy exhaustive tests are performed remotely whereas individual developers only run a subset of available tests on their machines.
successful completion of the local quali cation process detailed in figure is required in order to be able to commit code changes to the source version control system.
after each commit the process depicted in figure is triggered rst ci runs the same process that has been run on developers machine automatic deployment is then performed on the cloud infrastructure with the latest component version and more extensive tests ui deep functional scenarios stress tests are executed.
.
.
a case for automation kyriba follows the continuous integration recommendations and implements acceptance and stress tests.
these tests are very time consuming while local tests take less than minutes to complete global ones might take hours.
furthermore as kyriba solution is an assembly of multiple components integration tests involve many interdependent components that should all be deployed before testing.
when deploying on a single machine maintaining 218consistency e.g.
version alignment is rather easy and can be enforced using package dependencies when components are distributed as services on multiple physical virtual machines consistency is harder to maintain.
in the past test deployment was done using custom tools involving a manual setup and component protocol incompatibilities were only detected at runtime.
short feedback loops discipline helps developers with error diagnostic related to small code changes so kyriba has been looking for a tool that could anticipate error detection.
zephyrus turned out to be a perfect t for this need as a deployment validation tool for both the local and remote quali cation processes.
zephyrus is now used in distributed component consistency validation and deployment con guration scenarios.
zephyrus helps to get feedback before launching local deployments tests and has led to a significant reduction of the number of failures occurring during automated deployment in comparison to the previous more manual test setup.
.
.
zephyrus adoption for developers.
developers de ne relationships between components in partial zephyrus les when they create packages for their project.
these les are then merged with zephyrus les containing the full infrastucture description provided by engineering operations team before being processed by the solver.
two kinds of such relationships need to be de ned dependencies between packages with speci c version requirements e.g.
the application .
requires a web server of version at least .
.
to be installed on the same machine to run properly service binding relationship with api level requirement e.g.
the application .
requires a service api version exposed by another application on some machine not necessarily where the application is deployed.
developers can declare these requirements using ports speci ed in the zephyrus universe de nition component types name fa accounting engine .
provide fa accounting engine v1 finiteprovide require implementation fa accounting engine .
debian kyriba kyriba fa accounting engine .
the component type kyriba fa accounting engine provides a fa accounting engine v1 service with api level and requires a graphite v3 service.
in the implementation section the component type is linked to the concrete package implementation kyriba fa accounting engine .
.
this partial universe de nition is merged with the full universe description containing the de nitions of all kyriba components and the default speci cation in order to verify that at least one nal con guration exists.
this ensures that no dependency problem can arise during deployment.
figure local quali cation process with zephyrus figure global quali cation process with zephyrus developers may also override the default specification with their own speci cation to validate di erent deployment scenarios during the local quali cation process.
the local quali cation process is modi ed by adding a zephyrus validation stage before local deployment see figure .
using zephyrus metadata developers simply declare component interfaces and the way they are exposed.
moreover using zephyrus developers know beforehand if the components they are working on can be deployed together with other components.
for continuous integration and deployment environment.
similarly to the local one the global quali cation process has been instrumented with an extra zephyrus validation stage as illustrated in figure .
zephyrus automatically checks application consistency before actually engaging in a deployment process.
if the solver nds a solution the related con guration is used by infrastructure management scripts based on the fabric library4 in order to orchestrate an integration test deployment on the cloud infrastructure such as the amazon elastic cloud computing service .
the newly created platform is then checked against all acceptance stress and ui test cases.
to upgrade the production platform.
zephyrus is also used to plan platform upgrades on the infrastructure currently in production.
according to the software road map product managers de ne the component versions needed to be shipped to production for a milestone release.
all those values are set in zephyrus les and based on the current production deployment zephyrus computes an output le containing the di erent application packages that should be installed with the related con guration parameters that need to be set for application binding.
this guideline le is then used by engineering teams to write orchestration scripts and pinpoint manual upgrade tasks.
.
.
outcome summing up kyriba s experience with zephyrus is that instead of managing deployment scenarios manually using spreadsheets and at documents with ad hoc semantics leading to complex time consuming and error prone deployments zephyrus brings precise semantics and simpli es the 219automation of software quali cation processes.
zephyrus provides static validation before actually performing expensive and very long dynamic validation at runtime.
as most compiler like tools zephyrus improves engineering quality and reduces building cost with less failures at deployment integration test stage and platform upgrade.
.
related work the problem of managing networks of interconnected machines has attracted signi cant attention in the area of system administration.
many popular system management tools exist to that end cfengine puppet mcollective and chef are just a few among the most popular ones.
despite their di erences such tools allow to declare the components that should be installed on each machine together with their con guration les.
then they employ various mechanisms to deploy components accordingly.
the burden of specifying where components should be deployed and how to interconnect them is left to the sysadmin let alone the di cult problem of optimal resource allocation.
as an extra complication system management tools stop at the package management abstraction and therefore have no way of knowing in advance whether deployment will succeed or not.
if the sysadmin requests to install two incompatible web servers on the same machine the incompatibility will only be discovered by the package manager at deploy time when one of the two services fails to get installed or started .
at that point it is up to the admin to go back to the planning stage and work around the incompatibility.
in our approach all package relationships are known to zephyrus which can therefore plan around component incompatibilities.
system management tools can be used as an alternative toarmonic though.
once optimal resource allocation is done by zephyrus the actual deployment can be delegated to them now with the guarantee that no deployment error due to incompatibilities will arise an interesting candidate could be .
cloudfoundry speci cally targets application deployment in the cloud but su ers from the same limitations as described above.
confsolve improves on the system management approach it relies on a constraint solver to propose an optimal allocation of virtual machines to servers and of applications to virtual machines but it does not handle connections among services nor capacity or replication constraints and is unaware of package incompatibilities.
in juju each service is deployed on a single machine or more recently in a virtual container on a machine .
that avoids the issue of component incompatibilities but does so at the price of wasting resources.
in our wordpress example zephyrus proposes a solution that needs machines whereas juju would have required .
two recent e orts feinerer s work on uml and engage are more similar to our approach as they both rely on a solver to plan deployments.
feinerer s work is based on the uml component model which includes con icts and dependencies with capacity constraints but uses dependencies only between components which greatly restricts the expressiveness of the model choices are not possible .
moreover no tool for actually building the computed con guration is provided.
engage on the other hand o ers no support for con icts in the speci cation language one can only indicate that a service can be realized by exactly one out of alist of components.
neither feinerer s work nor engage or any other tool that we are aware of allows to nd a deployment that uses resources in an optimal way minimizing the number of needed virtual machines.
another approach to automated deployment is proposed in which uses an architecture description language with user provided information about relationships among software services and implements a decentralized protocol to perform automatic con guration.
this work may also be used as a backend for zephyrus .
finally we would like to put zephyrus in perspective.
in our view automated management of cloud applications is best realized by a phase approach.
in the rst phase architecture synthesis zephyrus or similar tools are used to devise an optimal system architecture.
then in a second phase planning the obtained con guration is compared with that of the existing system to produce a detailed deployment plan that migrates the existing system to the desired one.
to implement planning the actual state of services and their life cycles e.g.
how do they pass from an inert installed state to an up and running one?
do dependencies and con icts change in the meantime?
ignored for the purpose of this paper become relevant again.
even though planning has been shown to be undecidable in the most general case promising progress has been made on automated planning for restricted cases like planning in the presence of complex activation requirements that include circular dependencies whereas giving up the possibility of expressing component con icts .
.
conclusion we have introduced an automated approach to the design and deployment of complex distributed applications composed of interconnected services as typically found in modern cloud environments.
the system architect can specify the components needed to obtain the required functionalities add non functional constraints e.g.
maximum number of client components connected to a given service or minimum number of replicas as well as available physical resources e.g.
memory or bandwidth and declare component incompatibilities.
the architect can also choose an optimization goal allowing to specify whether she prefers a conservative solution that changes the current con guration as little as possible or a minimum cost solution.
the approach is realized by two complementary tools zephyrus will synthesize an optimal architecture including precise information about service interconnections.
such an architecture is then fed to the second tool armonic which is able to deploy it on state of the art cloud infrastructures such as openstack taking care of all deployment aspects from machine provisioning to service con guration and initialization.
a major advantage of the proposed approach w.r.t.
the state of the art is that all existing constraints including software package level incompatibilities are taken into account to prevent deploy time errors.
we have validated the complete toolchain both theoretically showing soundness and completeness of the approach and practically by applying it to relevant industrial use cases.
to the best of our knowledge this toolchain is the rst that allows to consistently handle capacity and replication constraints con icts and service co location thus nally providing an instrument able to handle the stringent requirements of cloud applications in the real world.
.