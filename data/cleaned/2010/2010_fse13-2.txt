regression tests to expose change interaction errors marcel b hme bruno c.d.s.
oliveira abhik roychoudhury national university of singapore marcel oliveira abhik comp.nus.edu.sg abstract changes often introduce program errors and hence recent software testing literature has focused on generating tests which stress changes.
in this paper we argue that changes cannot be treated as isolated program artifacts which are stressed via testing.
instead it is the complex dependency across multiple changes which introduce subtle errors.
furthermore the complex dependence structures that need to be exercised to expose such errors ensure that they remain undiscovered even in well tested and deployed software.
we motivate our work based on a well tested and stable project gnu coreutils where we found that one third of the regressions take more than two years to be xed and that two thirds of such long standing regressions are introduced due to change interactions for the utilities we investigated.
to combat change interaction errors we rst de ne a notion of change interaction where several program changes are found to a ect the result of a program statement via program dependencies.
based on this notion we propose a change sequence graph csg to summarize the controlow and dependencies across changes.
the csg is then used as a guide during program path exploration via symbolic execution thereby e ciently producing test cases which witness change interaction errors.
our experimental infrastructure was deployed on various utilities of gnu coreutils which have been distributed with linux for almost twenty years.
apart from nding ve previously unknown errors in the utilities we found that only one in ve generated test cases exercises a sequence that is critical to exposing a change interaction error while being an order of magnitude more likely to expose an error.
on the other hand stressing changes in isolation only exposed half of the change interaction errors.
these results demonstrate the importance and di culty of change dependence aware regression testing.
categories and subject descriptors d. .
software engineering testing and debugging general terms theory algorithms experimentation keywords test generation graph based search permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction changes even to well tested software projects can introduce subtle bugs of varying severity that may be exposed only years later.
such change based errors in deployed software come in two forms.
first of all bug xes may introduce new bugs.
for instance gu et al.
mention that feature additions or bug xes introduce new bugs in of cases.
secondly a subtle or poorly understood interaction among various changes may introduce hard to nd errors in well tested code which then get deployed.
in this paper we focus on test generation to expose such subtle change interaction errors cies .
subtle change interaction errors can be found in many well tested and deployed software projects.
in our study on gnu coreutils we found that every fth bug x actually patches regressions introduced in an earlier commit.
about one third of these regressions take more than two years to nd and x1 despite the tool set being rather well tested.
note that of the total commits update the comprehensive test suite while only actually update the utilities the remaining are related to maintenance like documentation the build process or ambiguous error messages .
thus it is surprising that on utilities with such well updated test suites errors due to change interaction will remain for two years.
in fact the gnu coreutils have been dispatched with almost every linux distribution for the last years!!
this led us to think that change interaction errors which stress subtle dependencies across changes may be hard tond due to most regression testing methods being focused on some form of coverage .
at this point we step back and review the recent regression testing research which focus on program changes.
a recent work presents criteria and experiments for the interaction among program changes but does not suggest any method for integrating them into regression testing.
among the works achieving change aware test generation some study only independent program changes .
several of the testing methods attempt to achieve either a structural coverage of changed statements or some other structural coverage such as branch outcome coverage in the modi ed program e.g.
see .
since coverage based methods may not stress the semantic e ect of the changes attempts have been made to take a powerful symbolic execution based path exploration engine and adapt it to the presence of program changes.
since symbolic execution captures the semantic e ect of program changes the hope is that the semantic e ect of a change can be propagated through 1in our experience most bugs are xed days after the report.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
309such methods.
on the other hand since a fulledged symbolic execution based path exploration can be exceedingly slow these methods employ various pruning strategies to cull away program paths which cannot reach or propagate changes e.g.
see .
other authors suggest to statically compute the program slices for every change and dynamically employ symbolic execution upon these slices to exercise all paths that are a ected by a changed statement e.g.
see .
however in all of these works the set of changes in a program is treated in an aggregate fashion.
the ows dependencies across changes are not systematically explored exploited for generating test cases.
in this paper we present a test generation method to systematically explore and expose subtle errors arising due to the interaction among program changes.
since any such change interaction leading to errors is inherently dynamic we rst statically approximate the relationships among the changes.
our approximation is called change sequence graph csg which captures i the controlow across the changed statements and ii the controlow to control locations at which multiple changes may interact leading to unexpected semantic e ects.
these interaction locations are computed based on the program dependencies across multiple changed statements.
the csg is then used as a de nitive guide to nd out the sequence of control locations that need to be visited for exposing potential change interaction errors.
these control locations are visited systematically by programming a graph based search strategy on top of the directed symbolic execution engine otter .
experimental results from our approach on coreutils show the prevalence of change interaction errors among regression bugs.
we note that the gnu coreutils tool set is a collection of linux utilities which have been widely tested.
in particular every fth commit to the repository updates a comprehensive test suite that exists for more than twenty years and the tool set was further tested by the authors ofklee and test zesti reporting and errors respectively .
despite such extensive testing we found and reported ve veri ed previously unknown regression errors apart from many known errors.
among other notable ndings we noticed that two in three di erential errors can be classi ed as change interaction errors.
we also found that only half of the cies were exposed by a testing algorithm that target changes in isolation but does not account for their interaction.
this clearly demonstrates the importance of change interaction aware regression testing.
in summary the contributions of this paper are change interaction errors we identify and formalize change interaction errors errors that happen in evolving software which arise due to the combined semantic impact of multiple changes.
we argue for the importance of this class of errors with a study of regression on gnu coreutils over a period of years.
detection method for cies based on csgs we propose a datastructure called a change sequence graph to capture potential sequences of changed statements and interaction locations in an execution of a program.
using csgs we show a detection method which stresses sequences in the graph to expose cies.
implementation and empirical evaluation our cies detection method has been implemented and an empirical evaluation using that implementation was conducted to evaluate its e ectiveness.
.
regression in gnu coreutils to study software regression we looked at the repository ofgnu coreutils which has been actively developed and maintained for more than twenty years.
our results show that within the last ve years every fth bug x actually patches regressions introduced earlier and that of such regressions take more than years to be xed.
.
statistics of regression it is possible to access the history of every change commited to the source code repository of gnu coreutils since oct .
usually these commits are accompanied by a commit message that describes the relevance and intention of the change.
the commits to the repository of gnu coreutils are categorized as changes to particular tools or as build tests maint amongst others.
the developers adopted this commit message labeling about ve years ago.
this allows us to distinguish code changing commits3from maintenance commits.
parsing the commit messages for keywords such as bug x or regression we were able to approximate how many of the code changing commits are bug xes and feature additions.
if the commit message contained introduced or regression we could derive whether a bug x was actually patching regressions introduced earlier.
often a regression xing commit would reference the regression introducing commit.
thus we can measure the time in between.
note that this process may yield false negatives.
while we manually validated the reported ones we may miss some real regressions.
as the commits have been nicely categorized in the last ve years we looked at those between jan and feb .
however regression xing commits can reference regression introducing commits that were submitted much earlier.
given the x and the logarithmic y axis in figure the graph shows that x percent of the regression introducing commits require more than y days to be found and xed solid line and contain more than y changed lines of code cloc dashed line .
figure regression statistics gnu coreutils results.
about of the .6k commits in the recent years are code changes feature additions and bug xes in roughly equal shares.
interestingly every fth bug x actually patches regressions introduced in an earlier commit.
the following observations are further corroborated by package maintainer p adraig brady via email exchange 3code changing commits are labeled by the changed tool.310o.i of the regressions introduced in earlier commits take more than years to nd and x despite a comprehensive and well maintained test suite of the total commits update the test suite o.ii of the regressions are introduced when more than loc are changed while only about of the codechanging commits modify loc or more .
this led us to suspect that the changed behaviour introduced by the syntactic changes to the tools is not properly tested.
in particular we consider the subtle interplay of many code changes as reasons for regressions to be exposed so late.
we call this type of errors change interaction errors .
indeed as discussed in section we nd that of the errors introduced in earlier commits can only be exposed by input exercising certain critical sequences of changed statements.
it turns out that only one in ve tests inputs exercise a critical sequence while such test cases are times more likely to expose an error.
in the remainder of this section we have a closer look at one of the regression errors.
.
buffer overflow in cut during our investigations we found and reported a bu er over ow in the tool cutofgnu coreutils which was introduced as a regression error in commit ec48bead and manifests as seg fault for the failing test input.4bu er over ows can be exploited maliciously to gain root access to a ected computers .
this issue is particularly critical for systems that are dispatched with almost every linux distribution such as gnu coreutils which contains wellknown command line tools such as cp mv rm echo and cut.
fortunately in the ve years preceeding this paper the package maintainer of gnu coreutils had to x only seg faults.5however a surprising out of are regression errors introduced in earlier commits .
.
.
the anatomy of a regression in simple terms the tool cuttakes a set of number ranges a le and an optional output delimiter as input and prints the content of every line in the speci ed le within the speci ed ranges optionally separated by the speci ed outputdelimiter.
for instance the command in figure uses hello world as input to the cututility which prints the range between the 2nd and 3rd character and from the 7th character onwards both ranges separated by comma .
echo hello world cut output del b2 7el world figure linux terminal the output of cut problem .if there are no nite ranges e.g.
then too much memory is unnecessarily allocated.
speci cally if max range endpoint is set in line of figure or earlier then the array printable field is allocated max range endpoint of memory line .
if output delimiter specified then printable field is unnecessarily but successfully accessed at eol range start in line .
note if eol range start max range endpoint then max range endpoint is set to eol range start in line .
4report and x avail.
at .
5again we analysed commit messages in the repository.
due to false negatives the actual number may be greater.intended change .memory allocation only if necessary.
speci cally only if max range endpoint is set allocate the array printable field with max range endpoint of memory.
only if output delimiter specified andmax range endpoint is set then the array printable field shall be accessible in line .
bool is printable field size t i return printable field .. if max range endpoint eol range start max range endpoint eol range start .. if max range endpoint printable field malloc max range endpoint .. if output delimiter specified !complement eol range start max range endpoint !
is printable field eol range start mark range start eol range start figure seg fault introduced in cut actual changes .the developer applies three code changes.
every change is essential to x the memory leak.
speci cally the developer c. adds that printable field is allocated only if max range endpoint is set line c. adds that printable field is accessed only if max range endpoint is set line and c. removes that max range endpoint is set to eol range start ifeol range start max range endpoint lines .
note all changes are essential to x the memory leak.
for instance without change c. the variable guarding the memory allocation is always set rendering the additional checks of changes c.1and c.2redundant.
regression error .if nite ranges are speci ed then unallocated memory can be accessed yielding a seg fault.
speci cally if max range endpoint is set max range endpoint eol range start and output delimiter specified is set then the array printable field is accessed out of bounds at eol range start in line .
.
.
combined semantic impact of changes the observation of the regression error depends on the execution of both changes c.1and c. .
they have a combined semantic impact on the same program location the memory access.
speci cally the allocation of memory forprintable field in line depends on the code added with change c. .
the access of memory in printable field in line depends on the code added with change c. .
because the success of accessing an array also depends on the memory allocation for this array both changes have a combined impact at the memory access location.
so the memory access at line is called interaction location of c.1and c. .
the sequences in which the changes can be executed are depicted in figure .6note c.3is not part of the presented graphs since a deletion does not manifest in the changed version p0.
6for brevity we removed sequences that contain a change but no memory allocation or access.311root memory allocation c. memory access c. outfigure input can exercise these change sequences.
it is insu cient to test both changes in isolation.
the regression error is only observable for some input that exercises both changes the sequence following the solid lines in figure .
the bu er over ow is not observable for input exercising only change c.1but not c.2and neither for input exercising only change c.2but not c. sequences exercising one of the dashed lines in figure .
hence we call this regression a change interaction error .
.
errors in software evolution this section formally describes classes of errors that can occur during software evolution.
in particular we are interested in a class of errors arising from the interaction of multiple changes that we call change interaction errors cie .
to establish the context of cies we also de ne a useful generalization of regression errors which we call di erential errors .
.
preliminaries for the de nitions in this section we will assume two successive versions of a program pandp0 and an oracle s. the oracle sspeci es the intended behavior for pandp0.
as such it is expected that for all input iexecuted on p0 the output is observationally equivalent7to executing ion the oracle s. note that we abstract over what the oracle s is it could be a speci cation the ultimate nal version of a program a validating test suite or some other artifact that could be used to validate expected behaviour.
using earlier version p the changed version p0and intended behavior s ofpandp0 we can more formally de ne what we mean by aregression error .
de nition regression error a regression error is observed on input iif and only if p i p0 i andp i s i .
in other words a regression error happens when for some input ithe earlier version p works as expected but the new version p0 does not work anymore.
note that this de nition does not prevent p0from exposing the correct behaviour for some other input which fails in pw.r.t.
s. therefore our de nition of regression error captures the common situation in which the initial version pmay have some errors that are intended to be xed in p0 but while p0is xed for some inputs it starts behaving incorrectly for some other inputs.
an intended software quality improvement turns into a possible detoriation of the software quality.
7two programs pandp0are observationally equivalent for an input i p i p0 i if the relevant program output produced by executing ionpandp0is the same.
.
differential errors in the context of software evolution we often nd the need for a notion more general than that of a regression error .
we call this notion di erential error .
de nition di erential error a di erential error is observed on input iif and only if p i p0 i andp0 i s i .
in other words a di erential error happens when for some input i the changed version p0works di erently from both the earlier version pand the intended behavior s. there are two interesting situations.
the situation in which the earlier version p i worked as expected p i s i is just equivalent to the de nition of regression error.
on the other hand the situation in which the earlier version p i did not work as expected either p i s i cannot be called regression error.
so we call it di erential error.
this captures a situation e.g.
of an incomplete x. the developer intends to x the behaviour of p when test cases iandjfailed on pw.r.t.
s. but while imay now pass in the xed version p0andj produces di erent output jmay still fail on p0w.r.t.
s the x was incomplete.
in practice it is helpful to characterize situations in which several intermediate xes are implemented until an ultimate version meets the expectations.
.
change interaction errors a change interaction error is a special kind of di erential error.
informally a change interaction error happens when multiple changes are introduced in a program and those multiple changes interact in unexpected ways.
more formally we can de ne this class of errors as follows.
de nition change interaction error cie a change interaction error occurs if there exists a sequence cconsisting of at least two changed statements such that there exists an input ithat exercises all changed statements in cin order and p i p0 i s i p0 i and for every input jthat skips the execution of at least one changed statement in c we have that s j p0 j .
we call the sequence cacritical sequence of the cie because it corresponds to a sequence of changed statements that needs to be exercised in the given order to expose the differential error.
intuitively if every input exercising smaller sequences than cdoes not expose an error but some input exercising cin order exposes a di erential error then this error is due to the interaction among the statements c2 c. .
running example for illustration purposes we use the two concrete program versions pandp0in figure to explain salient concepts in the remainder of this work.
the two programs are simpli ed extracts of two versions of the linux core utility cut the behavior of which is explained in section .
.
.
the code is related to the parsing of the user provided number ranges for the tool.
as long as fspoints to a character of the string it tests whether the character is a digit line a dash line or the end of the line line .
if the character is a digit then the number is read into value v. in the changed version a boolean lhsis set to true lines .
if the character is a dash the variable init is computed using v lines .
if the end of the line is reached the bug is observable if init is line .312p p0 2while true 3if isdigit fs v rddigit fs else if fs c v init c ?
v else if fs eol assert init !
break 13fs 1bool lhs false 2while true 3if isdigit fs v rddigit fs lhs true else if fs c lhs init c ?
v il else if fs eol assert init !
break 13fs figure core utility cut.v1 changed to cut.v2 the changed statements are highlighted in grey.
there are three changed statements in the changed version which can be identi ed using the corresponding line numbers f1 7g.
we should point out that our notion of change is syntactic purely textual and corresponds to code changes that manifest in the changed version p0 such as added or modi ed statements.
in other words changed statements can be determined using textual di erencing tools like diff.
the use ofdiff has the advantage that it works for any two programs although it can be quite imprecise.
there are other more precise ways to deal with changes but these typically assume some form of alignment between the two program versions .
unfortunately these alignment assumptions do not always hold for the real programs that we are interested in.
for this reason we chose the less precise but unrestricted approach using diff.
change interaction error.
in the program p0in figure a cie happens when the input string is .
in this case the following sequence of changed statements is executed h1 7i.
before entering the loop line is executed.
since the rst character is the rst iteration of the loop meets the condition at line and the changed statement in line is executed.
at this point the variable vis set to and the variable lhsis set to true.
in the second iteration of the loop the condition at line is met and the change in line is executed.
since lhsis true init is set to as vis .
in contrast for the same input program psets the variable init to .
consequently in the last iteration of the loop the assertion in line is violated for p0 but not for p. note that only a speci c sequence of changes as well as a speci c input triggers this error.
the interaction of the changed statements in lines and at the statement in line causes this error.
the combined semantic impact of both changes lead to the di erential evaluation of the conditional expression c ?v in both versions pandp0.
other change sequences such as h1 7i h1 5i h1 5i will not expose the error.
.
change sequence graph to support detection of change interaction errors cie we propose a statically computed structure which we call change sequence graph csg .
a change sequence graph approximates the computation of potential cies by using controlow information to derive sequences in which the changed statements can potentially be exercised and dependence information to derive locations at which the changes can potentially interact.
10cfg pdg csg 9figure pdg cfg and csg for p0in figure .
.
potential interaction to aid detecting cies we can approximate all potential sequences of changed statements in a program using controlow information from a controlow graph cfg .
essentially a potential sequence of changed statements corresponds to a path in the cfg that contains changed statements.
having information about every potential sequences of changed statements is helpful because all critical sequences will be included in those sequences.
in other words this information will allow us to build a detection method for cies that searches potential critical sequences and exposes cies.
we are particularly interested in change sequences where the changed statements interact.
that is each executed changed statement has some impact on the output and not executing one of those statements can lead to a di erent output.
it is in this class of sequences where we can nd change interaction errors.
to detect such sequences one useful de nition is that of a potential interaction location of a sequence of changed statements.
de nition potential interaction location a statement sis a potential interaction location of a set of changed statements c ifs statically data or controldepends on every c2c.
information about potential interaction points can be computed using the program dependency graph pdg .
essentially we utilize the backward slice of the statement sto compute the set of changed statements that can have a semantic impact on s. if the set contains more than one different changed statement then sis a potential interaction location of those statements.
note that an interaction location can coincide with a changed statement.
in figure the graphs on the left and in the middle depict the pdg and the cfg for our running example respectively.
the statement at line is a potential interaction location of the changed statements in lines and since it transitively depends on both the changed statements.
as such both changes can have a combined semantic impact on this control location e ectively causing the regression error.
the notion of potential interaction location allows us to de ne an approximation of change interaction .
de nition potential change interaction a set of changed statements cis potentially interacting if there are potential interaction locations for c. if there is no interaction location for two changed statements since there is no informationow they are guaranteed not to interact and can be tested in isolation.313algorithm change sequence graph construction require programs pandp0 let ccode diff p p0 let cfg markedcfg p0 ccode let pdg markedpdg p0 ccode let csg markednodesof cfg for all change c2cfg do traversechange c c end for function traversechange curr c for each node that directly follows curr incfg do ifnode is change or output then add edge from ctonode incsg else let ci dependsonchanges node pdg ifjcij 1then add node tocsg for each c2cido add edge from ctonode incsg end for traversechange node node else traversechange node c end if end if end for end function ensure change sequence graph csg .
the information about all potential sequences of changed statements and potential interaction points can be synthesized in a change sequence graph csg .
thus a csg represented a subset of program paths in a program where change interaction errors may exist.
other program paths which are not represented in the csg cannot have change interaction errors as they do not contain change sequences.
.
computing the change sequence graph the csg can be computed using the cfg and the pdg for the changed program p0.
algorithm shows the detailed construction of the csg.
the inputs of the algorithm are two programs pandp0and the output is the change sequence graph csg .
the rst step is to compute the changed statements between pandp0 line .
as discussed in section this can be done using the diff tool.
the next step is to compute the annotated versions of the cfg and pdg of p0 lines .
both the cfg and pdg are annotated with information about the changed statements.
initially the csg contains no edges only nodes.
these nodes are the changed statements and output nodes that are recovered from the cfg using the procedure markednodesof line .
the nal step of the algorithm is to iterate through all the changed statements in the cfg and for each change use the auxiliary function traversechange to add the relevant edges and interaction locations to the csg lines .
the recursive function traversechange takes two arguments curr andc.
the rst argument represents the current node in the cfg.
the second argument represents the changed statement that edges may have to connect to.
for each node in the cfg which directly follows from the current node we have three possibilities for the node change or output node lines if we reach some other change node this indicates that there may be a controlow from the change cto this change.
thus we add a corresponding edge to the csg to indicate such potential ow.
similarly if we reach an output node we should add an edge between change cand that node to indicate the potential controlow.
interaction location lines if the node is an interaction location it is added to the csg and connected.
speci cally the function dependsonchanges node pdg computes the changed statements that can have a semantic input on node using the pdg .
if there is more than one change having a semantic impact on node then node is an interaction location and is added to the csg connected to the changes it depends on.
conceptually every interaction location can be regarded as a new change.
to trace the semantic impact of the interaction location we keep recursively traversing the cfg by invoking traversechange with both arguments set to node.
naively the function dependsonchanges can return all changed statements in the static backward slice of node.
for optimization purposes the function may choose a node to be an interaction location only if node is an important interaction location in some respect.
for instance given an interaction location ifor change sequence cand a statement sthat directly depends oni while sis now also considered an interaction location of c it may not be an important one.
alternatively the interaction locations could be computed by taking the static forward slice for every changed statement and marking their intersection as an interaction location.
neither of above line any other cfg node should be ignored in the csg.
this is achieved by calling traversechange with node as rst argument.
this sets curr representing the node in the cfg that is currently traversed to node and implies that node will not appear in the csg.
.
search based input generation to expose change interaction errors and di erential errors in general test cases are generated.
the exploration technique uses the change sequence graph as a guide to exercises the structure of inter dependencies across the changed statements.
we employ symbolic execution along these dependencies.
the search based input generation is depicted in algorithm .
the algorithm takes two program versions pand p0 and the csg cf.
alg.
as input and computes a set of di erence revealing test cases t. we adopted the directed symbolic execution algorithm as discussed by ma et al.
.
however instead of searching for input that exercises any target in a speci ed at set of targets we extended the algorithm to search a speci ed directed graph of targets i.e.
thecsg .
the search algorithm is presented independent of the search strategy.
algorithm is initialized in the rst ve lines.
it starts with an empty test suite tand the rst set of changed statements in the csg those without incoming edges .
these are added as targets for the symbolic state symbstate which is created in lines .
a symbolic state is essentially an intermediate state of symbolic execution and has three main properties i a statement next which is to be executed next ii a partial path condition pc that is satis ed by every input exercising the same program path until s and iii a set of targets .314algorithm search based input generation require programs pandp0 directed graph csg let t let symbstate targets csg startnodes let symbstate pc true let symbstate next p0 firststmt let states fsymbstateg while states6 istimeout do let beststate choosebeststate states let s symbexec next beststate p0 ifisbranch s then let statet beststate pc s branchcond let statef beststate pc s branchcond remove beststate from states add statet andstatef tostates else if s2beststate targets then ifsis an output then let t smtsolve beststate pc ifp t p0 t then add ttot end if remove beststate from states else beststate targets next targets of sincsg end if end if end while ensure di erence revealing test cases t. the symbolic execution of a symbolic state can be resumed at any time and pauses if a branch or a target is reached.
the rst symbolic state symbstate is created with pc true statement next is set program start and the targets are assigned to the rst set of changed statements in line .
in the following line it is added to the empty list of symbolic states .
distance public class helloworld public static void main string args string a e string b l string c w string d o string e h string f r string g d string final1 e a b b d string final2 c d f b g string low final1.tolowercase system.out.println low final2 csg p beststate s figure the beststate is chosen with the shortest distance in the source code of p0from sto the target left .
once a target is reached the symbolic state moves to the target s children in the csg right .
the search commences in line .
as long as the list of states is non empty and no timeout occurs the search works as follows.
from the list of states thebeststate is chosen according to a given search strategy which is implemented inchoosebeststate .
for instance as depicted in figure every symbolic state is assigned a measure of distance to its targets ranked according to this measure and chosen if ithas the shortest distance.
we further prioritize states with a greater proportion of targets that are yet unreached by other symbolic states.
in line the beststate resumes the symbolic execution of p0until s the next statement to be executed becomes either a branch or one of the targets to be reached.
if sis a branch lines then two states are created one following the true branch and the other following the false branch.
the path conditions and the list ofstates are updated accordingly.
if sis atarget lines then we further distinguish whether or not sis an output statement.
if sis an output statement then we solve the path condition using a satis ability modulo theory solver to derive a concrete program input t line .
this input is executed on both versions to validate whether texposes a behavioral di erence.
if so tis added to the set of di erencerevealing test cases t. since beststate reached the output it requires no further symbolic execution and can be removed from the list of states line .
otherwise if sis a target of beststate and not an output statement line then we set as new targets ofbeststate the nodes following the outgoing edges of the reached node in the csg .
the right hand side of figure shows the beststate searching for two csg nodes in grey .
if beststate nds the node on the left the next target of beststate becomes that bottom left node.
.
empirical ev aluation .
implementation and setup we have implemented algorithm into the directed symbolic execution tool otter .
the user provides two versions of a c program compiled into the c intermediate language cil and a text le with a representation of the csg.
otter provides a wide choice of search strategies which implement the function choosebeststate in algorithm .
for our experiments we used one of the most e cient8strategies.
the best symbolic state is chosen based on the shortest distance to the targets computed in the interprocedural controlow graph.
occasionally the next state is chosen randomly.
we extended the search strategy by prioritizing states with a greater proportion of yet unreached targets.
instead of searching for a global set of targets our implementation extends a symbolic state to have its own set of targets.
once a target is reached the children of the reached target become the new targets for this state.
the execution of a symbolic state terminates only if the output has been reached and thus no more further targets are to be reached.
we then compute a concrete input satisfying the path condition of a state that reached an output node.
this input is executed on both program versions.
the information from the standard unix pipes stdout and stderr describes the program output.
if the output di ers in more than the program name the test case and its di ering output is reported.
if the user optionally provides a golden version our implementation can classify the observed di erential output further as di erential error i.e.
regression incomplete x or progression .
we executed our implementation on a desktop computer with an intel r coretm2 quad cpu at .83ghz and 4gb of main memory to generate test cases within the time frame of minutes.
the same sequence of changed statements can be exercised by multiple generated test cases.
8roundrobin randompath intersdse efficient .
.
subjects we chose the subjects according to the following criteria known regressions.
for every regression we know i the earlier version ii the regression introducing version iii the bug report s and iv the regressing xing version s .
the analysis of known regressions increases the credibility of the subjects and reduces the scope of non maintenance commits which we need to inspect.
multiple changes.
in this study we are not interested in the semantic impact of single changed statements but the interplay of multiple changed statements.
therefore we consider only regressions involving multiple changed statements.
deterministic behavior.
the execution of the same input on the same program always yields the same output.
determinism is a prerequesite for every testing technique and as such also for symbolic execution.
version pair fixed in commit bug report revision date seq.v0!seq.v1 seq.v2 .
.
msg00055.html .
.
!
.
.
seq.v3 .
.
msg00139.html seq.v3 .
.
msg00139.html seq.v1!seq.v2 seq.v4 .
.
msg00145.html .
.
!
.
.
seq.v5 .
.
msg00054.html cut.v0!cut.v1 cut.v4 .
.
msg00036.html .
.
!
.
.
cut.v6 .
.
msg00151.html cut.v1!cut.v2 cut.v3 .
.
msg00195.html .
.
!
.
.
cut.v5 .
.
msg00114.html cut.v6!cut.v7cut.v8 .
.
msg00011.html24.
.
!
.
.
expr.v0!expr.v1expr.v2 .
.
msg00189.html16.
.
!
.
.
table six version pairs introducing eleven errors.
we study six version pairs that together introduced di erential errors ve of which are found and reported by our method in bold font .
table shows the considered version pairs the latter version of which introduces errors that are fixed in the a subsequent revision.
the xes are presented with commit date and bug report .
the bug being xed with cut.v4 is further discussed by marinescu and cadar and together with cut.v8 only observable as bu er over ow.
we inserted an assertion that states that an array shall never be accessed out of bounds.
the tools cut seq and expr consist of about and lines of code loc respectively.
however these tools utilize monolithic shared libraries prompting colleagues to quote between 2k to 3k e ective loc for the smallest tools up to 20k instructions for the largest tool in gnu coreutils .
.
research questions during the empirical evaluation of the change interaction guided regression test generation technique we want to answer the following research questions.
rq.
severity.
how many di erential errors can be classi ed as change interaction errors?
what is the probability to exercise a sequence exposing a change interaction error compared to other sequences?
rq.
e cacy.
how many di erential errors are exposed by a test generation technique that exercises changes in isolation as compared to one that considers their inter dependencies and change interactions?
.
results and analysis .
result presentation table shows the errors introduced when changing the given versions whether these are change interaction errors and the test cases generated by our csg guided test generation technique.
the rst two columns show the errors introduced by the changes of the version pairs that are fixed in the versions given in the second column.
for instance when seq.v1 was changed to seq.v2 errors are introduced that are xed in versions seq.v3 seq.v4 and seq.v5 .
errors xed in revisions highlighted in bold face were previously unknown and subsequently reported by us.
the following four columns show the results for the generation of test cases exercising the change sequence graph while the latter three columns show the results for a test generation technique that considers su cient to exercise every changed statement e ectively treating changes in isolation .
both groups of columns have a similar format.
column tests depicts the number of test cases generated.
column diff depicts the number of test cases revealing a di erence when executed on both versions.
some of the semantic di erences are expected progression .
column error depicts the number of test cases exposing the given error.
as per de nition a di erential error that is exposed only by input exercising a sequence of changed statements but not by input skipping statements in that sequence is classi ed as change interaction error col. cie .
version pairs sequence test error seq.v0!seq.v1non critical .
.
critical .
.
seq.v1!seq.v2non critical .
.
critical .
.
cut.v0!cut.v1non critical .
.
critical .
.
cut.v1!cut.v2non critical .
.
critical .
.
cut.v6!cut.v7non critical .
.
critical .
.
expr.v0!expr.v1non critical .
.
critical .
.
table test of generated tests exercise a non critical sequence.
error of generated tests that exercise a non critical sequence expose an error.
table shows the percentage of tests exercising critical sequences versus the percentage of tests exercising non critical sequences.
one test case exercises exactly one sequence.
a critical sequence is a sequence of changed statements that is relevant to expose a change interaction error.
the rst column depicts the version pairs considered followed by whether the results refer to critical ornon critical sequences.
the latter two columns are explained by example of the last row on average one quarter of the generated test cases for the version pair expr.v0 andexpr.v1 exercise a critical sequence.
from those every sixth exposes an error .
to generate the test suites that stress changes in isolation see rq.
we generated test cases that cover every changed statement that is also exercised by the approach presented in this paper.
we set as targets the output and such statements that have the greatest depth in the chain of control dependencies.
in other words instead of a graph of targets we provided a set of targets.
otherwise we employed the same tool search strategy and time frame.316rq1 change sequence graph rq2 changes in isolation version pair fixed in cie tests di error tests di error seq.v0!seq.v1seq.v2 x seq.v3 x seq.v1!seq.v2seq.v3 seq.v4 seq.v5 x cut.v0!cut.v1cut.v4 cut.v6 x cut.v1!cut.v2cut.v3 cut.v5 x cut.v6!cut.v7 cut.v8 x expr.v0!expr.v1 expr.v2 x average per version pair .
.
.
.
.
table errors introduced xed in later versions are witnessed by test cases generated within minutes.
rq.
change interaction errors two third of the analyzed di erential errors are change interaction errors.
only one in ve test cases exercise a critical sequence being times more likely to expose an error.
using our implementation we have found and reported four of the seven listed change interaction errors and one more di erential error that were previously unknown.
on average test cases were generated that exercise a change sequence see table .
every fourth test case propagates the combined semantic e ect of the exercised changed statements to the output and thus makes a di erence observable.
while many of these expose expected behavioral changes every fth test case exposes a di erential error.
change interaction errors are subtle .
on average only .
of the generated test cases exercise a critical sequence see table .
on the other hand the malicious e ect of a critical change sequence is much greater than that of a noncritical sequence.
only .
of the test cases exercising a non critical sequence expose an error versus exercising a critical sequence.
test cases exercising a critical sequence are .
times more likely to expose an error than test cases exercising a non critical sequence.
that suggests that the changes in these critical sequences are interacting in a negative and unintended manner.
rq.
comparison to changes in isolation only of the change interaction errors are exposed by test cases generated to stress changes in isolation .
to compare we generated a test suite that covers every changed statement which is also covered by the test suite generated using a change sequence graph.
on average test cases were generated that exercise a change sequence cf.
table .
every fth test case propagates the combined semantic e ect of the exercised changed statements to the output and thus makes a di erence observable.
many of these expose expected behavioral changes every 15th test case exposes a di erential error signi cantly less than our csg based test generation approach.
within ve minutes using our csg based approach every error is witnessed by test cases on average.
in contrast using the other approach that considers changes in isolation only seven of the eleven errors are witnessed by on average test cases each.
in particular only of the change interaction errors are exposed by test cases generated to stress changes in isolation as compared to by our technique.
.
threats to v alidity the main threat to external validity is the generalization of the results.
during our study of gnu coreutils we encountered several regression errors that can only be observed when certain environmental conditions are satis ed.
one example is an error that was reported to occur speci cally on a solaris bit machine and could not be reproduced on other machines.
depending on the program environment the same test case may or may not expose an error.
in fact the package co maintainer of gnu coreutils p adraig brady noted in an email correspondence that it may be unclear even for the experienced developer exactly how to write the test cases in the presence of such non determinism.
he suggested to introduce an explicit interface for le operations.
this suggests a lack of modelling the environment or concurrency during the testing process.
as discussed in section .
our experimental subjects and regression errors are chosen so that the observability of an error does not depend on the program environment but on source code properties.
the conclusions should be viewed in the same context.
the main threats to internal validity are t. the search strategy that was utilized and t. the practical absence of assertions that mark an error within symbolic execution.
t. the experimental results depend on the utilized search strategy.
a less e cient search strategy may have exposed less di erential errors within the same amount of time.
however the utilized search strategy does not prioritze critical over non critical sequences.
thus it does not a ect the main conclusion of rq.
.
we utilized the same search strategy for the experiments that compares to testing changes in isolation.
thus it does not a ect the main conclusion of rq.
.
t. symbolic execution requires highlighting of error states for instance by assertions.
in section and table we list the versions cut.v4 and cut.v8 as bug xes for regressions introduced in an earlier version of cut.
the regressions are observable as bu er over ows.
however without the explicit assertion stating that an array should never be accessed at an index greater than its size the symbolic index for this array may often concretize as small number such as or but never as a number that has more than the nine digits necessary to witness these particular over ows.
while ourimplementation is able to nd error exposing test cases in the presence of such assertions it is unable to nd errorexposing test cases in their absence for such bu er over ows.
.
related work test suite augmentation aims at generating new test cases that stress the changed behaviour in a program.
typically this is done by exploiting knowledge about changes and using symbolic execution techniques which are also key ideas in our approach.
however the main novelty of our work is the consideration of the inter dependencies among multiple changes during test generation.
our technique effectively exercises sequences of changed statements and potential interaction locations.
existing techniques either discuss the semantic impact of single changes only or do not systematically consider the interaction and interdependencies among multiple code changes .
test suite augmentation techniques can be distinguished insemantic approaches that are based on the program summaries of both versions to compute the semantic changes and syntactic approaches that are directed by the syntactic changes to exercise paths that may expose semantic changes.
the syntactic techniques can be further distinguished into those seeking to re establish code coverage of a test suite after the program is changed those following the reach infect propagate9approach and those exercising every program path a ected by a change .
techniques such as express or dise that exercise every program path a ected by changed statements are ner grained and less scalable than our approach.
the focus on a ected code regions makes these techniques more e cient than full path exploration approaches like dart since less paths are to be explored.
however these techniques may still exercise many di erent paths within the same sequence of changed statements paths that may or may not contain interaction locations paths that may all expose the same error.
more systematically our csg directed tsa approach targets sequences and interaction locations of changed statements instead of all a ected paths .
in practice this means that once a di erence revealing test case is found for a sequence unexplored a ected paths that can still realize this sequence do not no have to be explored further.
tsa techniques based on reach infect propagate rip follow a motivation similar to our work instead of exploring every path a ected by changes the rip approaches deem it su cient to nd one path that executes a change infects the program state and propagates to the output.
however existing techniques consider the semantic e ects of the changes in isolation.
for the subjects in our experiments a technique based on this consideration could expose only half of the change interaction errors.
in the presence of multiple changes the approach of santelices et al.
requires a change free path from the change to the program start e ectively a change in isolation.
coverage based tsa techniques seek to re establish code coverage when the program is changed .
however to expose change interaction errors and understand the combined semantic impact of multiple changes it is insu cient to merely exercise every change as discussed earlier.
semantic tsa techniques require the computation of a di erential semantic program summary for both versions to determine the semantic changes.
while this approach is sound and very precise it may be less scalable.
9reach a change infect the program state and propagate the infection to the output .change interaction.
santelices et al.
propose a formal de nition of change interaction two changes c1and c2interact in an execution if removing one of the changes alters the semantic e ect of the other change on that execution.
this notion of change interaction is too precise.
for our practical purposes detecting such changes interactions cannot be done in an e cient manner.
essentially given a test case tand code changes cthat are applied to program pyielding p0 there are 2jcjprogram con gurations to be analyzed each with only a subset of capplied to p. our de nition of potential change interaction approximates the above de nition and can be computed more e ciently.
a set of changed statements cpotentially interacts if there exists a statement that syntactically depends on every c2c.
reachability.
in order to explore change sequences our approach builds and extends previous work that deals with reaching statements in a program.
however these tools seek to reach a single statement a set of statements or a sequence of statements instead of a graph.
to overcome this problem we have modi ed the otter tool to take a graph of statements as input and target multiple statements along this graph structure at once.
.
conclusion when a program evolves due to feature additions bug xes or other code quality improvements the source code of the program is changed.
especially when multiple developers change the code base at di erent places comprehending the semantic impact of such code changes and potential interactions is di cult.
consequently errors that result from a poor understanding of the inter dependencies across changes are often introduced in the code base.
in this paper we have argued for the importance and subtleness of such change interaction errors which are pervasive even in well tested and widely used software.
since existing regression test generation techniques do not adequately stress code where change interaction may occur we have proposed a new regression test generation technique that addresses these limitations.
our recipe for exposing change interaction errors employs a judicious mix of ows dependencies and semantic e ects across changes.
in other words to witness a change interaction error multiple changes should be executed ow information multiple changes should a ect a potential interaction location via data and control dependencies dependence information and the semantic e ect of a change should not get masked.
in our approach the control ow between changes is captured in the change sequence graph dependencies across changes are witnessed in potential interaction locations and we attempt to exercise these dependencies and propagate their semantic e ects via symbolic execution on the changed program.
our experiments on gnu coreutils demonstrate the e ectiveness of this approach in hunting down hard tond change interaction errors even in well tested software.
.