detecting energy bugs and hotspots in mobile apps abhijeet banerjee1lee kee chong1sudipta chattopadhyay2abhik roychoudhury1 1national university of singapore singapore2link ping university sweden abhijeet cleekee comp.nus.edu.sg sudipta.chattopadhyay liu.se abhik comp.nus.edu.sg abstract over the recent years the popularity of smartphones has increased dramatically.
this has lead to a widespread availability of smart phone applications.
since smartphones operate on a limited amount of battery power it is important to develop tools and techniques that aid in energy efficient application development.
energy inefficien cies in smartphone applications can broadly be categorized into energy hotspots and energy bugs .a n energy hotspot can be described as a scenario where executing an application causes the smartphone to consume abnormally high amount of battery power even though the utilization of its hardware resources is low.
in contrast an energy bug can be described as a scenario where a malfunctioning application prevents the smartphone from becoming idle even after it has completed execution and there is no user activity.
in this paper we present an automated test generation framework that detects energy hotspots bugs in android applications.
our framework systematically generates test inputs that are likelyto capture energy hotspots bugs.
each test input captures a sequence of user interactions e.g.
touches or taps on the smartphone screen that leads to an energy hotspot bug in the appli cation.
evaluation with freely available android applications from google play f droid shows the efficacy of our framework in finding hotspots bugs.
manual validation of the experimental results shows that our framework reports reasonably low number offalse positives.
finally we show the usage of the generated resultsby improving the energy efficiency of some android applications.
categories and subject descriptors d. .
testing and debugging c. keywords mobile apps non functional testing energy consumption .
introduction global penetration of smartphones has increased from to over the last five years.
as of more than .
billion smartphones are being used worldwide .
over the recent years smartphones have improved exponentially in terms of processing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.fse november hong kong china copyright acm ... .
.speed and memory capacity.
this improvement has allowed application developers to create increasingly complex applications forsuch devices.
additionally modern smartphones are equipped witha wide range of sensors and i o components such as gps wifi camera and so on.
these i o components allow developers to cre ate a diverse set of applications.
in spite of such high computation power and developer flexibility the usage of smartphones has beenseverely impeded by their limited battery capacity.
in terms of com putation capacity most of the current generation smartphones are two or even three orders of magnitudes better than their decadeold counterparts.
however the battery life of these modern smart phones has improved only two or three times .high computational power coupled with small battery capacity and the application development in an energy oblivious fashion can only lead to one situation short battery life and an unsatisfied user base.
energy inefficiencies in smartphone applications can broadly be categorized into energy hotspots and energy bugs .a n energy hotspot can be described as a scenario where executing an application causes the smartphone to consume abnormally high amount of battery power even though the utilization of its hardware resources is low.in contrast an energy bug can be described as a scenario where a malfunctioning application prevents the smartphone from becoming idle even after it has completed execution and there is no user activity .
table lists the different types of energy bugs and energy hotspots that can be found in android applications.
it is also worthwhile to know that most contemporary smartphone devicesare designed to operate at different power states and prolong the battery life.
however as listed in table malfunctioning applications may lead to inappropriate power states such as energy hun gry gps sensor updates non idle power state in the absence of user activity and so on.
moreover most of these energy inefficiencies appear when the application does not access the device resources in an appropriate fashion e.g.
not releasing wifi gps wakelocks or expensive sensor updates eventually hampering the battery life.therefore to build energy efficient applications it is crucial forthe developer to know these energy inefficiencies in the application code.
presence of such energy inefficiencies in the application code can be highlighted to the developer via our proposed methodology.
in this paper we present an automated test generation framework to detect energy hotspots bugs in android applications.
specifically our framework systematically generates test inputs which are likely to capture energy hotspots bugs.
each test case in our gen erated test suite captures a user interaction scenario that leads toan energy hotspot bug in the respective application.
we argue that 1for instance if we compare nokia communicator released in to samsung s3 released in we can observe that the processing power has increased from 24mhz to1.4ghz whereas the battery capacity has only increased from 800mah to2100mahpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
588table classification of energy bugs and energy hotspots category energy bug energy hotspot a hardware resourcesresource leak resources such as the wifi that are acquired by an application during execution must be released before exiting or else they continue to be in a high power state suboptimal resource binding binding resources too early or releasing them too late causes them to be in high power state longer than required b sleep statetransition heuristics wakelock bug wakelock is a power management mechanism in android through which applicationscan indicate that the device needs to stay awake.however improper usage of wakelocks can causethe device to be stuck in a high power state even after the application has finished execution.
this situation is referred to as a wakelock bug tail energy hotspot network components tend to linger in a high power state for a short period of time after the workload imposed on them has completed.the energy consumed by the component between the period of time when theworkload is finished and the component switches to the sleep state is referredto as tail energy .
note that tail energy does not contribute to any useful work by the component.
scattered usage of network components throughout the application code increases power loss due to tail energy c backgroundservices v acuous background services in the scenario where an application initiates a service such as lo cation updates or sensor updates but doesn t re moves the service explicitly before exiting the ser vice keep on reporting data even though no appli cation needs it expensive background services background services such as sensor updates can be configured to operate at different sampling rates.
unnecessarily high samplingrate may cause energy hotspots and therefore should be avoided.
similarly fine grained location updates based on gps are usually very power intensive andcan be replaced by inexpensive wifi based coarse grained location updates if anapplication is using both the wifi and the gps d defectivefunctionality immortality bug buggy applications may respawn when they have been closed by the user thereby continuing to consume energy loop energy hotspot portions of application code are repeatedly executed in a loop.
for instance a loop containing network login code may be executed repeat edly due to reasons such as unreachable server the systematic generation of such user interaction scenarios is challenging.
this is primarily due to the absence of any extra functionalproperty e.g.
energy consumption annotations in the application code.
as a result any naive test generation strategy may either beinfeasible in practice e.g.
exhaustive testing or it may lead to an extremely poor coverage of the potential energy hotspots bugs.this also brings us to the difficulty of defining an appropriate cover age metric for any test generation framework that aims to uncover energy hotspots bugs.
in our framework we address these challenges by developing a directed search strategy for test generation.
to design a directed search strategy it is critically important to know the potential sources of undesirable energy consumption.
table lists such sources of energy consumption in android applications.
moreover existing works such as have shown that i ocomponents are primary sources of energy consumption in a smart phone.
one crucial observation is that i o components are usuallyaccessed in application code via system calls .
besides the power management functionality e.g.
wakelocks background services and other hardware resources cf.table of a device can only be accessed through a set of system calls.
in summary most of theclassified energy hotspots bugs cf.
table are exposed via the invocation of system call s .
therefore the general intuition behind our directed search strategy is to systematically generate userinteraction scenarios which potentially invoke such system calls.
our search strategy revolves around systematically traversing an event flow graph efg .
efg is an abstraction to capture a set of possible user interaction sequences.
each node in an efg captures a specific user interaction e.g.
touching a button on smartphone screen whereas an edge in the efg captures a possibletransition between two user interactions.
therefore each trace in an efg captures a possible sequence of user interactions.
since exhaustive enumeration of efg traces is potentially infeasible our di rected search methodology generates appropriate efg traces whichare likely to lead to undesirable energy consumption.
to accom plish this we primarily employ two strategies.
based on our observation from table we execute selected efg traces and these selected efg traces invoke system calls that might be responsiblefor irregular power consumption .
besides if an energy hotspot bugis detected after executing an efg trace we record the sequence of system calls responsible for such irregular energy behaviour.
subsequently we prioritize unexplored efg traces that may invoke asimilar sequence of system calls.
such a guidance heuristic primar ily aims to uncover as many energy hotspots bugs as possible in alimited time budget.besides the challenges encountered in generating energy stressing test inputs it is also non trivial toautomatically detect a potential energy hotspot bug in a given trace.
to detect energy hotspots bugs our framework executes a test input i.e.
a user interaction scenario on a off the shelf smartphone while simultaneously measuring the power consumption via a power meter.
to detect anenergy bug in a specific trace we measure the statistical dissimi larities in power consumption trace of the device specifically be fore and after executing the respective application.
as the power consumption of an idle device should be similar a statistical dissimilarity indicates an energy bug .
to detect an energy hotspot we employ an anomaly detection technique to locate anomalouspower consumption patterns.
once we finish the process of detecting hotspots bugs in a power consumption trace we generate a different user interaction scenario using the directed search strategyin the efg to investigate.
the test generation process continuestill the time budget permits or all event traces invoking system callshave been explored.
as the system calls are the potential locations to cause irregular energy behaviour the quality of our test suite is provided via the coverage of system calls in the application.
contribution.
in summary we provide a systematic definition detection and exploration of energy hotspots bugs in smartphoneapplications.
we combine a graph based search algorithm and guidance heuristics to find possible energy hotspots bugs in an application.
each test case in our generated report captures a user interac tion scenario that leads to an energy hotspot bug.
we have imple mented our entire framework for android apps.
for the evaluation of our framework we have performed experiments with 30freelyavailable android apps from the google play f droid.
these ap plications are diverse in terms of apk android application package file size.
the largest tested application was .0mb in size whilethe smallest application was 22kb in size.
the average apk size of the tested applications was .1mb.
the lines of code for the open source applications used in our experiments varied from to11 with an average of lines of code per application.
additionally the applications used in our experiments use multiple i o components and had a substantial number of user interaction ui screens.
experiments with our framework uncovered energybugs in10of the tested applications and energy hotspots in 3of the tested applications.
manual validation of the experimental resultsshows that our framework reports reasonably low number of false positives.
finally we show the usage of our test suite by improving the energy efficiency of some of the tested android applications.
.
general background android is an open source operating system os designed for mobile devices such as smartphones.
we choose android as ourtarget platform primarily due to its relevance in the real world glob ally of all smartphones tablets are android based .
additionally a wide variety of tools are publicly available for android application developers.
this includes among others tools to mon itor the state of an application in real time e.g.
logcat to communicate with the device e.g.
android debug bridge and to facilitate application development and testing e.g.
emulator .
the user interaction interface of an android application is referred to as an activity .
figure shows the life cycle of an android activity.
an activity can be in one of the seven stages during itslife cycle.
usually all the set up tasks such as acquiring resources and starting background services take place in four stages of the activity namely oncreate onstart onresume andonrestart .
similarly all the tear down tasks such as releasing resources andstopping background services take place in three stages namely onpause onstop andondestroy .
however some real life applications do not follow the ideal set up and tear down scenariosas explained via figure .
such applications may contain energy bugs .
this situation is made worse by the fact that most real life applications have a huge number of feasible user interaction scenarios due to complex guis .
as a result it can be impossible for a developer to test an application for all possible scenarios.
activity launchactivity shutdown activity runningoncreate ondestroy onstart onstop onresume onpause another activity comes to foregrounduser returns to activityonrestartactivity finished or destoryed activity not visible to user activity killedactivity with higher priority needs memoryuser navigates to activity figure life cycle of an android activity figure shows a snippet of application code that has a potential energy bug.
the application code is supposed to start a location update background service line i nt h e oncreate method.
subsequently it performs some operation with list data line .
when the user stops the application the location update service is re moved line i nt h e onstop method.
however if there is an exception before line for instance due to line the location list integer data locationmanager locationmanager long min update time min distance override public void oncreate bundle savedinstancestate super.oncreate savedinstancestate setcontentview r.layout.main locationmanager locationmanager getsystemservice location service locationmanager.
requestlocationupdates locationmanager.gps provider min update time min distance this somefunctiontomanipulatedatalist overridepublic void onstop super.onstop try data.clear this can throw an exception locationmanager.
removeupdates this catch exception ex log.v demo some exception happended figure code with a potential energy bugupdate service is never stopped resulting in an energy bug .
the example in figure shows one possible scenario cf.
table c v acuous background services which can lead to an energy bug.
next we shall show an example that can lead to an energy hotspot .
the code snippet in figure a shows an example with energy hotspots due to disaggregated network activities cf.
table b tail energy hotspot .
observe that in figure a network related code line is interleaved with cpu intensive code line within the same loop.
such an interleaving causes energy inefficienciesdue to tail energy see table b tail energy hotspot .tailenergy behaviour has been observed for network components such as3g gsm andwifi .
other works have observed tailenergy in components such as storage disks and gps as well.
in order to reduce energy loss due to tail energy the network related code in figure a can be aggregated as shown in figure b .
public object nonaggregatedcomm object objectarray new object for int i i i object temp downloadobject i objectarray processobject temp return objectarray public object aggregatedcomm object temparray new object for int i i i temparray downloadobject i object objectarray new object for int i i i objectarray processobject temparray return objectarray a b figure a code with energy hotspot due to disaggregated communication b code without energy hotspot finally we shall explain the method used for obtaining the power consumption ratings of the hardware components in our smart phone.
one approach to obtain the power consumption ratings would be to perform empirical experiments based on the guidelines provided on the android developer web page .
however thereis a more elegant way to obtain the power consumption ratings.most android smartphones are shipped with a xml file usuallynamed as power profile.xml containing the average power consumption ratings for the hardware components in the device.
the data contained in this xml file is provided by the device manufac turer and therefore it is reliable.
moreover the android frameworkuses this data to show battery related statistics.
however note that the data in this xml file is an indicator of average power consumption of the hardware components of the device and does not corre spond to any particular application being run on the device.
thedata from power profile.xml for our smartphone lg l3 e400 i s shown in figure .
screen bluetooth gps wifi radio cpu power consumption mw figure power profile for lg optimus l3 e400 smartphone5903.
framework overview an overview of our test generation framework is shown in figure .
our framework has two essential components i guided exploration of selected event traces that are more likely to uncoverenergy hotspots bugs and ii detection of hotspots bugs in a given event trace for an application.
the information provided by the hotspot bug detection component is also utilized by the guidancecomponent to select subsequent event traces.
the process of selec tion execution and detection continues until the given time budget has expired or all event traces invoking system calls have been explored.
finally event traces that lead to energy hotspots bugs arereported to the developer for further investigation.
to detect a hotspot bug we measure the power consumption of the application for a given event trace.
however it is impossible to detect a hotspot bug in an application solely by analyzing its power consumption trace.
for instance consider a scenario where twoprograms p 1andp2have similar power consumption traces.
however program p1has a much higher utilization of system resources such as cpu compared to p2.
in such a scenario program p1 is more energy efficient than program p2.
therefore to accurately detect energy inefficiencies it is important to define an appropriatemetric for system resource utilization.
for a hardware component x theload xrepresents the average amount of computational work performed by the hardware componentxover a given period of time.
load xhas a range from to .
for example load cpu represents the fraction of time cpu is in use and therefore load cpu can be a number between and .
for other hardware components i.e.
wifi screen radio and gps load xcaptures whether the respective components are in use.
for instance load wi fi is set to if the wifi is transmitting data and it is set to otherwise.
for any hardware component x we measureload xdirectly from the device while the application under test is being executed.
it is important to note that a higher load x in a high power consuming component xwould result in a higher power consumption for the device.
based on this information wedefine a new metric of utilization that will be subsequently used in energy hotspots bugs detection.
d efinition .
.
utilization u can be defined as the weighted sum of utilization rates of all major power consuming hardwarecomponents in a device over a given period of time.
based on the power profile for our device cf.
figure major power consuming components in our mobile device are the screen wifi radio gps and cpu.
therefore for a given time interval the utilization of system resources can be computed by equation .
utilization u screen ucpu uwi fi uradio ugp s ucpu w cpu load cpu if cpu is operating at 320mhz wcpu load cpu if cpu is operating at 480mhz wcpu load cpu if cpu is operating at 600mhz wcpu load cpu if cpu is operating at 800mhz uscreen braceleftbigg wscreen on load screen if screen on wscreen ful l load screen if at full brightness ux wx load x x wifi radio gps in equation uxrepresents the utilization of hardware componentx.
utilization of a component xis directly proportional to its load x. for any component x the value of wxis computed from the power profile figure .
specifically the value of wxis normalized such that wxfor the most power consuming componentapplication event trace utilizationenergy consumption trace energy hotspots bugsevent flow graph test suite hotspot bug detection guidance module database efg extraction event trace generation power meter smartphone time budget expiredhotspot bug detection component guidance component figure overview of the test generation framework is in our case screen full as shown in figure .
note that in our case equation does not include bluetooth.
this is becausein our target device bluetooth has a very low power consumption compared to other components.
however if required we can easily extend equation to accommodate bluetooth as well.
using thenew metric of utilization u we can now compute the magnitudeof energy inefficiency as follows.
d efinition .
.
energy consumption to utilization e u r a tio is the measure of energy inefficiency of an application for a given time period.
ife u ratio of an application is high it implies that the energyconsumption is high while utilization is low.
therefore a highe u ratio indicates that the application is energy inefficient .
recall that we discuss two categories of energy issues that can make an application energy inefficient i.e.
energy hotspots and energy bugs .
a high e u ratio during the execution of an application indicates the presence of an energy hotspot.
on the contrary a per sistently high e u ratio even after the application has completed execution indicates the presence an energy bug.
now we shall briefly discuss the exploration of event traces to reveal hotspots bugs.
in our framework guided exploration of se lected event traces is based on event flow graph efg .
efg of an application can be defined as follows.
d efinition .
.
an event flow graph efg is a directed graph capturing all possible user event sequences that might be executed via the graphical user interface gui .
nodes of an efgrepresent gui events.
a directed edge between two efg nodes x andyrepresents that gui event yfollows gui event x. in our experiments we use a modified version of the dynodroid tool to generate the efg.
subsequently our framework generates event sequences up to maximum length kand stores them in a database.
after the event traces have been generated our frame work initiates a guided exploration of those traces.
the crucialfactor during the exploration is to identify the event traces that may lead to hotspots or bugs.
our framework accomplishes this by selecting event traces based on the number of invoked system callsand guidance heuristic.
the guidance heuristic gathers informationfrom previously detected hotspots bugs specifically the sequence of system calls which are likely to lead to energy inefficiencies.
subsequently the selection process is biased towards event tracesinvoking a similar sequence of such system calls.
this process ofselection execution and detection continues until the time budgethas expired or all event traces invoking system calls have been explored.
finally event traces that lead to energy hotspots bugs are reported to the developer for further investigation.
.
detailed methodology in the following sections we shall describe our test generation methodology in detail.
broadly our framework contains two sub steps i preprocessing the application under test to build a database of possible event traces and ii test generation using event traces generated in the first step.
.
preprocessing the application preprocessing of application can be divided into three steps i efg extraction ii event trace generation iii extraction of system calls sequence for each event trace.
note that this preprocessing step is performed only once for each application.
the generatedefg and database are stored for later use and need to be updatedonly if the application s user interface changes.
since this preprocessing is done offline a developer can rerun the test generation step detailed in section .
without repeating preprocessing step.
i event flow graph extraction we build the event flow graph efg based on the ui model proposed in .
for thepurpose of efg construction we use two third party tools hierarchy viewer and dynodroid .
hierarchy viewer provides information about the ui elements of the application under exe cution and dynodroid is used to explore these event sequence au tomatically.
note that dynodroid does not generate the efg byitself therefore we modified the dynodroid source code to build the efg.
the efg was constructed gradually each time dynodroid interacts with the application.
figure shows how our efg is be ing gradually built as dynodroid performs the exploration of eventsequences.
it is worthwhile to note that dynodroid does not guarantee to reach all gui states during exploration.
therefore our constructed efg is in fact a partial efg of the entire application.
however in our experiments we observed that the generated efgscover most of the gui elements for the tested applications.
ii event trace generation efg is primarily used to generate a set of event traces.
note that each application has a start gui screen.
this gui screen is presented to the user when an applica tion is launched.
we refer to this gui screen as the root screen .
therefore for a sequence of user interactions performed in an application the first action corresponds to an event present in the root screen .
using this notion we define an event trace as follows.
d efinition .
.
an event trace is defined as a path of arbitrary length in the efg.
such a path must start from an event in theroot screen of the respective application.
based on our efg we generate a complete set of event traces upto lengthk.
these event traces are stored in a database for further analysis during test generation.
figure b shows the partial efg of an application.
the node containing the event playbutton captures the root screen of the same application.
an example event trace of length would be playbutton stopbutton playbutton orskipbutton ejectbutton backbutton .
note that events playbutton andskipbutton correspond to different events in the root screen of the application.
rewindbuttonplaybutton pausebuttonstopbutton ejectbuttonskipbutton rewindbuttonplaybutton pausebuttonstopbutton ejectbuttonskipbutton button1 button2 backbutton a b figure a an example efg b efg after pressing ejectbutton iii extraction of system calls existing literature has shown that i o components are one of the major sources of energyconsumption in smartphones.
on observing the power profile ofour smartphone see figure we find this argument to be consis tent.
in general for modern smartphones the major power consum ing components are the screen cpu wifi radio gps sdcard camera and audio hardware.
we observed that these components except for the cpu can only be accessed via a set of system calls apis provided by the android sdk framework.
therefore wecreate a pool of such systems calls.
table shows a categoriza tion of these systems calls based on their functionalities.
sinceour target device lg l3 e400 uses android .
gingerbread therefore we only consider system calls available in android .
.
itis worthwhile to note that such a pool is constructed only once and it needs to be updated only if the android sdk framework changes .
table categorization of android system calls functionalitynumber of apisexample power management wakelock.acquire local area wireless networks2116 wifilock.acquire telecomm networks smsmanager.sendtextmessage haptic feedback vibrator.vibrate gps locationmanager.requestlocationupdates audio video camera.startpreview storage downloadmanager.enqueue others sensormanager.getaltitude we instrument the application code locations which invoke any system calls from our constructed pool.
this instrumented coderuns in an emulator on our desktop pc.
the sole intention of this instrumentation is to collect the system call traces during the execution of an event trace .
we execute the instrumented code on the emulator and record the system calls invoked for each event trace .
these system calls are annotated with the efg node corresponding to the triggered event.
thus for each event trace generated from the efg we can generate the respective system call trace .
it is important to note that the event traces are executed on the smartphone as well as in the emulator.
the instrumented application runs on the emulator whereas the instrumentation free application run on smartphone.
therefore the instrumentation does not influence the energy consumption behaviour of the application.
.
test generation in this subsection we shall describe i technique for hotspot bug detection ii guidance heuristic for the framework and iii algorithm for test generation i technique of hotspot bug detection as described in section energy hotspots bugs are those regions of code that lead tohighe u ratio cf.
def .
.
to detect energy hotspots during an event trace t we must first obtain the e u ratio trace e u t during the execution of t.e u tis divided into four different stages pre execution stage pre execution stage exc recovery stage rec and post execution stage post see figure .
the rationale for dividing e u ttrace into four stages is as follows in the pre stage the execution of event trace thas not started yet.
therefore pre stage records the idle behaviour low power state of the device.
similarly in the post stage the devices has completed execution of tand so in an ideal scenario the device would have gone back to its idle behaviour during post stage.
the execution stage as the name suggests is when592tis actually executing on the device.
after the execution of t the device takes a brief period of time referred to as screen time out duration to return to its idle behaviour.
in our framework this time period between the exc andpost stage is referred to as rec stage2.
figure an example of energy consumption to utilization e u trace with no hotspot bug with an energy bug and with an energy hotspot to detect the presence or absence of an energy bug we compare thee u tvalues in pre andpost stages using statistical methods.
if the dissimilarity between e u tvalues in pre andpost stage is more than a predefined threshold in our experiments the threshold was set to an energy bug is flagged i.eexecution oftchanged the idle behaviour of the device .
compared to detection of bugs detection of hotspots is much trickier.
hotspots may appear only during the execution of an eventtrace i.e.exc stage or just after the execution of an event trace i.e.rec stage stage.
note that e u tvalues obtained in exc stage and rec stage may substantially vary for different event traces.
besides different executions of the same event trace mayshow different e u tvalues in exc stage or rec stage due to different hardware states.
therefore we first need a clear definition of energy hotspots to detect them automatically.
we believe thatabnormally high energy wastage during the execution of an eventtrace is a suitable indicator of energy hotspots.
to detect such unusual energy behaviours we draw connections from the data mining and classification techniques.
we observe that the problem of detecting unusual energy behaviours is similar to detect unusual subsequences in time series data .
we use an anomaly detection technique that computes discords in a time series data.
discords are subsequences in a time series data that are maximally different from the rest of the time series.
we employ the discord detector on the e u tvalues from the exc andrec stage.
as a result the discord detector highlights subsequences in e u tthat are abnormally different from the rest of the subsequences in the exc andrec stage.
additionally the anomaly detector also points out the magnitude of each computed discord.
for instance in figure discord d 1has a higher anomaly magnitude than the discordd2.
these magnitudes are extremely helpful.
this is because the computed energy hotspots can be ranked based on their magnitude before reporting to the developers.
as the anomaly de tector we integrate jmotif into our framework.
jmotif is an off the shelf data mining library and it includes the implemen tation of finding discords in a time series data as proposed in .
ii guidance heuristics for test generation the primary objective of the guidance heuristics is to select an unexplored eventtrace that has a substantial likelihood of leading to a hotspot or abug.
the guidance function uses three parameters to rank the unex2in all our experiments rec stage was much larger than the screen time out duration.
this allowed the device to return back to its idle behaviour by the post stage after a bug free event trace has completed execution.plored event traces a number of systems calls in the event trace b similarity to previously explored hotspot bug revealing eventtraces c starvation of event traces due to unexplored system calls.the rationale for using these parameters is explained subsequently.
we have described in an earlier section .
iii extraction of system calls that the major power consuming component in smartphones can be accessed through a set of system calls.
therefore the presence of system calls that activate or deactivate such hardwarecomponents can be used for guiding our test generation.
at thebeginning of test generation process all event traces are ranked ac cording to the number of such system calls they can invoke.
in subsequent iterations the guidance module becomes more intelligentby learning specific system call subsequences that are more likely to generate energy hotspots bugs which is where the guidance bysimilarity or exploration history comes into play.
while selecting an unexplored event trace the guidance heuristics compares an unexplored trace to all previously explored event traces that haduncovered an energy hotspot or a bug.
comparison between twoevent traces is performed in terms of the sequence of systems callsthey can invoke.
note that such a comparison is perfectly feasible as we extracted the system call trace for each event trace during the preprocessing stage.
similarity between two system call tracesis compared using jaro winkler distance algorithm .
finally our third parameter guidance by starvation aims to cover as many system calls as possible during exploration.
since the first two parameters are based on the number of system calls and the explo ration history it is possible that the guidance heuristics may ignoreseveral unexplored system calls.
this leads to starvation where a set of system calls will never be explored by the test generation process.
such starvation is undesirable as unexplored system calls may potentially expose new energy hotspots bugs.
therefore toensure a fair coverage of all the system calls invoked by an appli cation we add a guidance parameter to deal with the problem of starvation.
essentially guidance by starvation ranks all unexplored event traces by the ratio of number of unexplored system calls in anevent trace to the total number of system calls in all event traces.
iii algorithm for test generation the algorithm for our testgeneration framework is shown using a flow chart see figure .
the primary objective of our framework is to uncover as many energy hotspots bugs as possible in an application within a giventime budget.
input to our framework is an android applicationfrom which the database of the application s event traces is generated.
recall that generation of event traces from the efg of an applications was explained in section .
.
our framework system atically executes the event traces from the database on the smart phone.
each execution is monitored for presence of hotspots bugs.the exploration continues until the allocated time budget has expired.
on completion the framework reports a set of event traces each of which leads to an energy hotspot bug when executed onthe device.
the two most important components of our frame work that are guidance heuristics for test generation and technique of hotspot bug detection have been discussed in preceding paragraphs.
there is however one more component of the frame work that must be explained.
notice that in the flow chart figure8 the first block indicates refine guidance parameters .
essentially this indicates the step in our framework where the reliance or the weight of the various guidance parameters are refined.
recall that our guidance heuristics is based on three param eters guidance by number of system calls corresponding weightwould be guidance by exploration history corresponding weight would be and guidance by starvation of system calls corresponding weight would be .
assume that for a given event trace e guidance by number of system calls assigns a rank g n similarly593refine guidance parameters weight for guidance by number of system calls weight for guidance by exploration history weight for guidance by system call starvation update test suitedatabase of unexplored events test suiteupdate database re rank all unexplored event tracesselect execution trace e start monitoring device execute event trace e on the smartphone stop monitoring device analyze e u data to detect hotspots bugs time budget expired?contains hotspot bug ?y nn y figure flow chart for our test generation framework guidance by exploration history assigns a rank ghand guidance by starvation assigns a rank gs.
to obtain a single score sefor an unexplored event trace e we use equation .
se gn gh gs where .
in equation and are three tunable factors which drive the priorities of different guidance param eters.
in the beginning we do not have any knowledge about likely hotspots bugs.
therefore is initialized to 1and both and are initialized to .
in each iteration the value of and are refined to uncover likely energy hotspots bugs as well as to get a fair cov erage of invoked system calls.
specifically in each iteration we decrease the value of by a fixed amount .
if an energy hotspot was found in the previous iteration we increase thevalue of to .
the intuition behind this refinement is to find energy hotspots bugs that had similar system call sub sequences aspreviously found hotspots bugs.
we continue increasing the value of as long as we find hotspots bugs or the value of reaches .
if we are unable to find any hotspots bugs in some iteration we hopeto reach previously unexplored system calls and therefore we in crease the weight of to .
this assignment of extra weight is taken out from i f .
otherwise we modify the value of to to decrease the priority of execution history.
.
experimental ev aluation we evaluated our framework to answer the following three research questions i efficacy of our framework in uncovering energy bugs and hotspots in real world applications ii how can an application developer benefit from the reports generated by ourframework and iii is guidance based on system call coverage more appropriate metric than code coverage for uncovering energy bugs and hotspots?
first we describe our experimental setup and the set of subject programs that we analysed in our experiments.
.
experimental setup in our experiments we use an lg optimus l3 smartphone as the device to run our subject programs.
the device has a singlecore processor and features standard i o components such as gps wifi 3g and bluetooth.
the device uses android .
.
gingerbread operating system os .
to monitor energy consumption of the smartphone we used a y okogawa wt210 digital powermeter for precise power measurement.
our energy testing frame work runs on top of a desktop pc that has an intel core i5 processorand gb ram.
the os used on our desktop pc was windows .
batterypower meter smartphone desktop pcpower meter output over serial port communication over adbvoltage measurementcurrent measurement figure our experimental setup figure shows the setup for our experiments.
for the purpose of this experiment we created a special apparatus to house the smartphone battery such that we could measure the voltage and currentflowing through the battery without any distortion.
note that con temporary smartphone batteries may have more than two terminals.additional terminals may be used by the battery to report data such as internal temperature.
however for our experiments only the positive and the negative terminals need to be monitored as shownin figure .
any additional terminals may be directly connectedto the smartphone.
our framework runs on the desktop pc which also serves as the global clock.
all the measurements from the power meter reporting power consumption data and the smart phone reporting utilization data are collected at the desktop pc.each reading is recorded with a timestamp generated on the desktop pc.
since the timestamps are generated by a single clock the clock on the desktop pc we can use these timestamps to synchronize the data from the power meter and the smartphone.
also notethat we use the android debug bridge to communicate with the smartphone.
these communication includes sending event traces to the smartphone and recording utilization data.
.
choice of subject programs the subject programs for our experiments are available on google play store f droid repository .
we have analyzed a total of android applications from different categories e.g.
tools productivity transportation as shown in figure .
the subject pro grams are diverse in terms of apk android application package file size.
the largest application tested was .0mb in size whilethe smallest application was 22kb in size.
the average apk size of the subject programs was .1mb.
the subject programs also had varying gui complexity.
we measure gui complexity of an ap plication by the number of feasible event traces that could be ex plored starting from the main screen of the application.
by fixing the length of the event traces to explore to a length of we observe that our chosen subject programs contain between to 800feasible event traces.
we also estimate the popularity of an appli cation by observing the number of times it has been downloaded as well as its user ratings.
these two statistics are only available for applications on the google play store.
as of march the subject programs have an average user rating of .
out with594table statistics for all the energy hotspots bugs found in tested applications out of the applications that we analyzed application description feasible traces k bugs found false positivehotspots found false positive hotspot bug type previouslyreported aagtl a geocaching tool y e s n o y e s y e s resource leak no aripuca records tracks and waypoints y e s n o no n a v acuous background services no montreal transit fetches bus subway and other tran sit information y e s n o no n a expensive background services suboptimal resources binding no omnidroid automated event action manager y e s n o no n a v acuous background services im mortality bug ye s zamnim shows location aware zmanim y e s n o no n a v acuous background services ye s sensor test monitors and logs sensor output y e s n o no n a immortality bug no eponte displays traffic information no n a y e s n o suboptimal resources binding no kfmb am listens to online radio y e s n o y e s n o v acuous background services sub optimal resources binding no food court finds restaurants near a location y e s n o no n a v acuous background services no fire and blood simple touch and draw game y e s n o no n a v acuous background services no speedometer shows measurements of sensors y e s n o no n a v acuous background services no a minimum rating of .
and a maximum rating of .
.
the median number of downloads for the subject programs is between with a minimum download count of and a maximumdownload count of .
figure categories of the android applications used in our experiments note that our framework does not require the source code of an application to detect energy hotspots bugs.
however the sourcecode is required to obtain code coverage metrics and for debuggingpurposes.
therefore we only consider open source applications for the second and third research questions where the source code is needed to perform our evaluation .
the lines of code for theopen source applications used in our experiments varied from to11 with an average of lines of code per application.
.
results rq1 efficacy of our framework in uncovering energy bugs and hotspots in real world applications one of the objective of our experiments was to observe the efficacy of our framework to quickly uncover energy bugs and energy hotspots in real world applications.to do so we evaluated the applications using our framework witha time budget of 20minutes.
additionally we also limit our exploration for event traces up to a length of .
a summary of the bugs and hotspots reported by our framework is listed in table .
our framework reported energy bugs for out of30 subject programs.
the framework also reported energy hotspots for 3subject programs.
note that our hotspot detection technique is based on an anomaly detection method .
therefore some of the reported hotspots may contain false positives due to the presence of noise in the measured data.
such noise may arise due to unpre dictable behaviours such as network load.
to confirm a reportedenergy hotspot we manually execute the respective event trace on our device and we observe whether the same energy hotspot can be replicated.
the result of the manual validation cf.
table revealed only one false positive for the application aagtl .i ti si m portant to note that the number of feasible event traces can be substantially large even for event traces having length as shown in table .
in spite of this large number of event traces we observed that our framework can quickly gravitate the exploration processtowards more energy consuming event traces.
existing tools forandroid application ui testing such as monkey cannot uncover such high energy consuming event traces because they are designed to stress test the ui of the application by generating pseudo randomstream of user events irrespective of the application s efg or thesystem call usage.
rq2 how can an application developer benefit from the reports generated by our framework?
after analyzing an application our framework generates a test report .
this report serves as a guide to optimize energy consumption and to remove potential en ergy issues.
the report contains a set of test cases where each test case captures an energy issue reported by our framework.
each test case includes i amonkeyrunner script for automatic execution of events that lead to the energy issue ii energy trace pattern iii details of the energy issue e.g.
magnitude of energy hotspot and iv the set of system calls invoked.
from the report the developer may prioritize energy issues exhibiting an energy bug or an energy hotspot of relatively high mag nitude.
for each test case the developer can run the provided monkeyrunner script and observe the event sequence that navigates the application to trigger the reported energy issue.
this would help the developer in identifying the root cause of the energy issue.
forinstance let us assume that an event trace texposes an energy hotspot.
while executing t if the hotspot appears before the execution of a certain event e neitherenor any subsequent events in tare responsible for causing the hotspot.
thus the search space for identifying the root cause of the hotspot is reduced to the codefragments that were executed before ewas triggered.
this will help the developer in fixing the reported energy issues.
we have performed case studies on two of the analyzed applications our framework reported energy bug for one and a hotspot for another to demonstrate how a developer can utilize the generated reports todebug and fix energy issues in applications.
aripuca gps tracker.
our framework reports two event traces with energy bugs in aripuca gps tracker .
the energy consumption pattern for such an event trace is shown in figure a .
as shown in figure a the energy consumption in the post stage is not similar to the pre stage indicating an energy bug.
therefore the device did not become idle even in the absence of user activity.
the effect of the bug is permanent unless i gps location update is explicitly removed or ii the application is killed.
we595manually verified that the reported event traces do not exercise the functionality of the application that requires gps location updateto run in the background.
the reported event traces were waypointsbutton waypoint details menubutton button1 waypointsbutton waypoint details menubutton backbtn the reported bug indicated that the location updates gps updates were not removed before the application becomes inactive.
by ob serving the similarity between the two traces i.e.
the event sequence waypointsbutton waypoint details menubutton we deduced that the bug was triggered upon arriving at a certain gui state.
we manually execute the event trace waypointsbutton waypoint details menubutton and suspend the application afterwards by pressing the home button.
at this point location updates are not needed by the application any more and they should be switched off.
upon inspecting the source code we observed that the application had a missing code fragment for removing locationupdates when exiting.
we fix the issue by adding the release codeat an appropriate location.
thereafter we re run the reported event trace using our framework.
the energy consumption graph after fixing is shown in figure b .
as shown in figure b the en ergy consumption in the post stage is similar to the pre stage resolving the energy bug.
a before fix b after fix figure energy trace of the event trace for aripuca gps tracker montreal transit.
five event traces with hotspots are reported for the application montreal transit .
the energy consumption trace for one such event trace is shown in figure a .
immediately af ter the execution enters the rec stage cf.
figure a we can observe potentially high e u ratios in a period of around seconds.
note that this energy issue is an energy hotspot and not anenergy bug.
this is because the high e u ratio does not persist.
the code for pausing the application consumes abnormally high amount of energy causing the hotspot to appear during the sameperiod.
we observed that all the five reported event traces exhibitsimilar hotspots.
on a closer inspection we found that the gps location updates continue to run for a few seconds even after the application exits.
before we explain the exact cause for the hotspot let us first give an overview of the application.
montreal transit is an application to show transit information where each screen shows transit information for some mode of transportation.
when a screen for some transportation say subway is displayed it fetches the distances to some of the nearestsubway stations.
however in order to do so it needs to acquire thelocation of the device.
surprisingly we found that the location update was triggered twice instead of once.
the second location update was triggered by a third party advertisement module to display location based advertisements in the application.
we found that thecode to load advertisement is being executed on the main thread ofthe application.
as a result any delay in loading the advertisement from the network prolongs the entire main thread.
if the user exits the application while the main thread is being delayed the releaseof gps based location updates is delayed as well.
the hotspots reported in our experiment can be best explained by such delay.
toconfirm our speculation we moved the code related to the loadingof advertisements in a separate asynchronous thread.
as a result we observed that the event traces which earlier exhibit hotspots nolonger do so cf.
figure b .
on a different note we suggest that to develop energy efficient applications the developer should use expensive resources as optimally as possible.
for instance the location updates in the preceding scenario should be performed justonce and shared between the various modules that need it.
we alsosuggest that any feature that is surplus to the requirements of users e.g.
advertisements should be put in a separate asynchronous thread to improve the user experience.
a before fix b after fix figure energy trace of the event trace for montreal transit rq3 is guidance based on system call coverage more appropriate than code coverage for uncovering energy bugs and hotspots?we have argued that i o components and power management utili ties contribute significantly to the energy consumption of a mobiledevice.
therefore we use the number of system calls invoked by an event trace as one of the guiding parameters in the exploration.
as a result the test suite generated by our framework should cover asmany system calls as possible.
on the other hand a more conven tional approach would be to measure code coverage of the test suite to evaluate the efficacy of a test generation framework.
therefore we evaluated the efficacy of system call based coverage with re spect to code coverage to obtain a minimal test suite for uncover ing energy bugs or energy hotspots.
we choose line of code loc table coverage statistics from all open source apps used in our experiments application system call code lines name coverage coverage of code aagtl android battery dog aripuca kitchen timer montreal transit npr news omnidroid pedometer v anilla music player simple chess clock wifi ace world clock as our code coverage metric and use emma a java code coverage tool to obtain loc covered by a test suite compared to the total loc of the application.
we observed that the generated test suites had a system call coverage of more than while having code coverage ranging from see second and third columns of table .
subsequently we wanted to observe if achieving an incremental code coverage uncovers any additional hotspots bugs.
therefore we manually generated additional test cases for the ap plications in table .
we observed that the manually generated596test cases increased the code coverage ranging from to17 .
however no additional hotspots bugs were revealed.
this is mostlikely due to the inefficiency of a human user to systematicallyfind energy inefficient event traces based on a given metric.
addi tionally on inspecting the emma coverage reports and the source code we observed that for real life applications a substantial portion of the code is present to give feedback to the user and to ensure compatibility over different versions of the os.
therefore thecoverage achieved by executing such code would not necessarilycontribute to finding energy hotspots bugs.
.
related work in recent times due to the prevalent use of smartphone devices topics related to functional and extra functional testing of smart phone applications have attracted the attention of software engi neering research community.
recent proposals such as and have discussed functionality testing of android applications based on symbolic execution and biased random search.
in con trast we focus on automated testing of extra functional aspects forsmartphone applications specifically the energy behaviour.
recent works on energy aware profiling have shown poor energy behaviour of several smartphone applications.
theseworks on profiling validates the idea of energy aware developmentfor smartphone applications.
however like any other program pro filing techniques works proposed in require specific input scenarios to execute the application on smartphone device.
a more recent work has proposed a technique to relate power mea surements with source lines of applications.
such a technique alsorequires input scenarios to execute an application.
automatically finding such input scenarios is extremely non trivial as the poor energy behaviour might be exposed only for a specific set of userinteraction scenarios.
therefore our approach on generation of in put scenarios complements the works proposed on energy awareprofiling or source line level energy estimation.
once the set of user interaction sequences is generated by our framework they can be further used with works such as or .
the work proposed in discusses energy aware programming support via symbolic execution.
for each code path explored by a symbolic execution toolkit the base energy cost can be highlighted to the programmer.
however such an approach is preliminary inthe sense that it only considers the cpu power consumption.
incontrast power consumption to access memory subsystems net work card and other i o components were not considered.
in smartphone devices i o components consume the most power.
since we perform direct power measurements for an application we canhighlight the gross energy consumption to the developer withoutignoring the energy consumption of any hardware component.
the work in proposes to analyze the overall energy behaviour of an application via an energy model.
our goal is orthogonal to suchapproach.
we aim to find user interaction scenarios that may leadto undesirable energy behaviours of an application.
therefore ourwork has a significant testing flavour compared to the work proposed in .
more importantly we rely on direct power measurements rather than relying on any energy model.
another work uses data flow analysis to detect wakelock bugs in android applications.
the detection of wakelock bugs is relatively easy.
this is due to the fact that the acquire and release of wakelocks can be related directly to program statements.
therefore the detection ofwakelock bugs can be performed even in the absence of power mea surements.
in contrast we aim to solve a more general problem ofdetecting energy inefficiencies and in addition we also compute the specific input scenarios that witness the same.a different line of work aims to produce energy efficient applications from different implementations of the same functional ity .
the decision to choose an implementation is influenced by monitoring the power consumption for a given test suite .
for instance the work in dynamically chooses approximate imple mentations of a given functionality to reduce the power consump tion.
along the same line a recent work monitors the powerconsumption of different api implementations and computes the potentially best implementation in terms of energy efficiency.
our work is complementary to such approaches as we aim to automat ically detect input scenarios that result in energy inefficiencies andgenerate a test suite that can be used for improving the energyefficiency of the application.
finally the work in introduces programming language constructs to annotate energy informationin the source code.
since we directly measure the power consump tion our approach does not require any new language construct.
.
discussion and future work summary.
in this paper we provide a systematic definition detection and exploration of energy hotspots bugs in smartphone ap plications.
our methodology is used to develop a test generation framework that targets android applications.
each entry in our generated test report contains a sequence of user interactions thatleads to a substantial wastage of battery power.
such test cases areuseful to understand several corner scenarios in an application interms of energy consumption.
our evaluation with 30applications from google play f droid suggest that our framework can quickly uncover potential energy hotspots bugs in real life applications.
threats to v alidity.
it is worthwhile to mention that our test generation method is not complete .
this is due to the fact that our computed event flow graph efg may only cover a portion of the application.
as a result we may not expose all the energy hotspots bugs in an application.
besides our current test generation framework revolves around directing the test generation to wards i o operations as i o components are some of the major sources of energy consumption in smartphones.
however it is possible in some pathological cases e.g.
unusual cache thrashing and memory traffic that cpu bound applications may lead to substan tial drainage of battery power.
detection of such energy stressingbehaviours can be studied in the future.
in our current implementation we can deal with gui based applications by generating ui inputs automatically.
however cer tain applications such as game applications require human intelligence in navigating through the different gui screens.
for example the transition between two gui screens might happen only by answering questions that require human intelligence.
in sucha situation we may not be able to generate sufficient event tracesautomatically to stress the energy behaviour.
future work.
using our energy aware test generation framework several research directions can be studied in future.
in particular we plan to study energy aware debugging.
specifically we plan to use our energy stressing input scenarios and compute theroot cause of energy wastage automatically .
such debugging techniques will greatly help the developer to bring down the possible causes of energy wastage.
we also plan to investigate the automated refactoring of an application to reduce energy wastage.
.
acknowledgement the work was partially supported by a singapore moe tier grant moe2013 t2 entitled energy aware programming .
.