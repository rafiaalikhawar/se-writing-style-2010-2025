a model driven framework for guided design space exploration abel heged us akos horv ath istv an r ath and d aniel varr o department of measurement and information systems budapest university of technology and economics budapest hungary hegedusa ahorvath rath varro mit.bme.hu abstract design space exploration dse aims at searching through various models representing different design candidates to support activities like configuration design of critical systems or automated maintenance of it systems.
in modeldriven engineering dse is applied to find instance models that are i reachable from an initial model with a sequence of transformation rules and ii satisfy a set of structural and numerical constraints.
since exhaustive exploration of the design space is infeasible for large models the traversal is often guided by hints derived by system analysis to prioritize the next states to traverse selection criteria and to avoid searching unpromising states cut off criteria .
in this paper we define an exploration approach where selection and cut off criteria are defined using dependency analysis of transformation rules and an algebraic abstraction.
the approach is evaluated against other exploration techniques and illustrated on a cloud infrastructure configuration problem.
index terms design space exploration model transformation i. i ntroduction design space exploration dse is a process to analyze several functionally equivalent implementation alternatives which meets all design constraints in order to identify the most suitable design choice solution based on quality metrics such as cost or dependability.
design space exploration often appears as a challenging problem in application areas such as dependable embedded systems and it system management where model driven engineering mde techniques are already popular.
dse can be performed either during the design process to find optimal designs or during runtime to help dynamic reconfigurations.
in traditional dse problems the design constraints and quality metrics are numeric attributes to express cost time or memory limits etc.
however systems with modular software and hardware architectures like autosar in the automotive domain or large reconfigurable architectures introduced complex structural constraints that express restrictions on the graph based model of the system under design.
these constraints may include restrictions related to the communication architecture or allocation of software and hardware resources.
furthermore during the design of dynamically changing systems e.g.
reconfiguration of virtual servers over physical ones the design space exploration also requires the dynamic creation and deletion of elements.existing dse approaches usually apply model checking with exhaustive state space exploration or solve finite domain constraint satisfaction problems that cannot effectively handle structural constraints and dynamic manipulation of elements.
in order to alleviate these issues designers often provide additional information hints about the system e.g.
from earlier experience or by some analysis that can reduce the design space to a more feasible size .
the design process is often complemented with different design and analysis and verification tools which can also provide mathematically well founded hints about the model in the early stages of development.
these hints may express additional system properties which can be incorporated in the dse process to assist the evaluation of alternate solutions.
guided model driven design space exploration aims to explore alternative system designs efficiently by making use of advanced model driven techniques e.g.
incremental model transformations and hints obtained by analysis tools or provided by the designer .
these hints are interpreted during the exploration to continue along promising search paths using selection criteria and to avoid the traversal of unpromising designs by cut off criteria .
additionally the use of incremental techniques leads to exploration strategies that are able to find additional alternative solutions which are close to an earlier solution.
in our paper we propose a model driven framework for guided design space exploration where the system states are graphs operations are defined as graph transformation rules while goals and constraints are defined as graph patterns.
we extend our previous work on model driven design space exploration by incorporating hints during the exploration strategy which are derived from dependency analysis of transformation rules and algebraic analysis on the petri net abstraction of the system .
cut off and selection criteria are defined based on these hints and their evaluation guides the design space exploration by identifying dead end states and prioritizing possible operations respectively.
major contributions of this paper with respect to our previous work are i the design and implementation of a complete model driven framework for guided design space exploration ii a guided exploration strategy that exploits various hints and iii an experimental evaluation of the approach on relevant case studies.
.
c ieee ase lawrence ks usa173 ii.
o verview of the approach in our paper we describe a novel framework that combines themodel driven approach of design space exploration dse with guided exploration techniques building on hints from analysis and guidance through cut off and selection criteria.
the schematic overview of the framework for guided design space exploration is illustrated in figure .
fig.
.
model driven guided design space exploration first the design problem description specifies the domain where the exploration takes place to produce solutions.
it includes the initial state of the system at the start of the exploration the set of manipulation operations called labeling or exploration rules defined on the system goals described as structural or numerical constraints which need to be satisfied by solution states found by the exploration and global constraints which are satisfied by the initial and solution states and all intermediate states on the trajectory between them.
the detailed discussion of the problem description is found in section iv the design space exploration performs the search for solutions by exploring the design or state space of the problem description.
it starts from the initial state and traverses reachable states by applying the operations on the system see section iii .
in order to find a solution quickly exploration is often aided by an exploration strategy detailed in section vii .
a simple strategy as proposed in may use random selection in a depth first search or statically assign priority levels to operations.
however a more advanced strategy should also determine whether a given state will never lead to a valid solution i.e.
it is a dead end and states reachable from it should not be traversed.
in a guided approach the exploration strategy relies on guidance which uses hints for driving the traversal and identifying dead ends.
hints are information originating from the designer or as in our paper from some automated analysis carried out using formal methods that often abstract the design problem description.
the result of the analysis can be information regarding the number of operation applications called as an occurrence vector partial ordering of operations restrictingthe set of required operations etc.
these results are often generated before the exploration in a preprocessing phase.
our guided approach uses occurrence vectors anddependency relations between rules as hints see section v .
finally the guidance calculates and interprets hints and provides decision support for the exploration strategy see details in section vi .
in our approach guidance is defined as the evaluation of cut off and selection criteria based on the current state and the hints as defined in .
cut off criteria identify dead end states and bound the exploration while selection criteria prioritize available rules in a state by their likelihood of leading to a final solution state.
challenges of guided design space exploration while existing model driven frameworks e.g.
groove are able to explore the design space of smaller problems by exhaustively traversing reachable states and checking global constraints and goals in each state they use no global information when selecting the applied labeling rules.
our guided approach however takes advantage of hints and guidance that help the exploration and addresses the following challenges identify decisions in the exploration the framework should clearly separate the guidance from the exploration strategy to easily allow the modification of both parts of the framework.
soundly reduce traversed design space the guidance should reduce the number of traversed states before finding solutions but it must ensure that no valid solutions are removed by the cut off criteria.
provide optimal solutions the guided framework should find the solutions that are optimal with respect to a user defined metric .
moreover the framework should be able to continue exploration to find other less optimal solutions if necessary.
extensibility the approach should be easily applicable on different design problems and the set of criteria should be extensible.
this is a key feature for adapting the framework to various domains.
iii.
g uided design space exploration the guided design space exploration approach is based on a general search process which traverses the design space starting from the initial state.
this general process includes a step evaluate criteria which relies on the guidance and hints provided by system analysis to the different exploration strategies identify decisions challenge .
the search process depicted in figure consists of the following steps check operation applicability.
first labeling rules of the design problem description are checked for executability i.e.
whether they can be executed in the current state of the model and this information is passed to the criteria evaluation.
evaluate criteria.
the cut off and selection criteria are evaluated using the hints the rule dependencies and the occurrence vector and the results are stored.174fig.
.
workflow of the guided design space exploration cut off?
if at least one of the cut off criteria were satisfied during the evaluation or there are no applicable rules the state is a dead end and the branch is cut.
select rule.
the design space exploration then selects the next applicable rule based on the evaluation results.
apply rule.
the selected rule is applied to the model resulting in a new model state.
check new state.
the global constraints and goals are checked on the new state to decide whether it is an invalid or solution state.
a is valid state?
if any of the constraint are violated the state is invalid and the exploration continues from the previous state.
note that a state is also considered invalid if the exploration has visited it earlier since in this case the reachable states are already explored from this state.
b is solution found?
if all of the goals are satisfied the state is a solution.
save solution.
when a solution model is found the trajectory with the executed rules and corresponding model state information is saved to a solution list.
continue search.
once the new model state is checked the next applicable rule is selected from a valid new state otherwise from the previous state.
design space exploration terminates either once a predefined number of solutions are found or if the found solution is acceptable by other user defined metrics or if there are no applicable rules within the limited search space.
since a hint does not always represent a feasible trajectory the exploration is restarted with an alternative vector if more solutions are required to be found.
iv.
d esign problem description a. motivating example cloud configuration today services are often built on top of a cloud middleware cm using components as building blocks to be able to scale dynamically to meet demands.
servers s and highavailability clusters cl can be deployed on the cloud middleware while databases db are installed on servers and applications app are executed over databases.
finally serverscan also be deployed on clusters and storage st subsystems can only operate over clustered servers.
in order to provide an appropriate infrastructure for clients the configuration of the cloud infrastructure must meet certain requirements including complex structural constraints e.g.
an application and a storage subsystem is required for a cloudbased web service.
such an infrastructure is shown in figure .
fig.
.
an example system providing reliable service to satisfy this constraint the cloud configuration has to be designed in an appropriate way.
we assume that regular change management commands including deletion or creation e.g.
deploying a new database are issued by some middleware service broker.
if the current infrastructure of the cloud detects that the required parameters cannot be satisfied by the actual cloud configuration reconfiguration operations are to be initiated which lead the system into a state where all constraints are met.
to deal with changes of requirements and possible commands guided design space exploration is used to find command sequences that should be executed to create a valid configuration.
b. initial state states are represented as instance models that conform to a metamodel.
this metamodel describes the problem domain and the initial state defines where the design space exploration starts from.
ametamodelmm for a design problem includes the set of model element types of the domain their attributes and relationships between model elements.
an instance model is a model that conforms to a metamodel if it only includes model elements and relations with types defined in mm .
fig.
.
metamodel and instance model of the cloud infrastructure the left part of figure shows the metamodel for the cloud case study.
the metamodel contains a cloud component node designated graphically as a rectangle.
the specific components socket server database application andstorage are specialized from this node socket is a generalization of cloud mw andcluster .
edge deployedon is a relation that connects two different components denoting that the source175fig.
.
example goal and global constraint node is deployed on the target node of this relation.
the right part of figure illustrates an instance model containing a databaseddeployed on two servers s1 s2that are on cloud c. note that in the rest of the paper we omit deployedon don relations by illustrating the relation using vertical arrangement of components.
c. goals and global constraints goals and global constraints of the design problem description are defined as bounds on the number of matches for graph patterns.
graph patterns represent conditions that have to be fulfilled by a part of the model this part is called a match .
the left part of figure shows an example goal which specifies that a solution model includes at least 5databases deployed on clusters while the right part shows a global constraint that allows maximum servers deployed on clouds altogether.
d. labeling rules the labeling rules that define the possible manipulation operations on the problem state are represented by graph transformation gt rules.
gt rules are specified by a precondition or left hand side lhs pattern determining the applicability of the rule and a postcondition or right hand side rhs pattern that specifies the result model declaratively.
the negative application conditions nac of a gt rule specify patterns that prohibit the application of the rule if they have matches.
the reconfiguration actions of the ongoing example is captured by a set of graph transformation rules in figure .
an overview on using graph transformations for software architecture reconfigurations can be found in .
fig.
.
graph transformation rulesthe addcm rule adds a new cloud cm adds creates a new server sdeploying it on top of a cm or cluster cl however a clcannot have more than two sdeployed on it.
rule addcl produces a new cldeploying it on top of a cm adddb adds a new database dbdeploying it on top of two s that have no other node deployed on them addapp creates a new application app deploying it on top of two dbthat have no other node deployed on them.
finally addst adds a new storage stdeploying it on two sthat are deployed on the same cland have no other node deployed on them.
it is important that the set of goals constraints and rules are easily extensible by the designer extensibility challenge .
the design problem description is not hard coded into the exploration and can be modified using a high level textual language .
our framework also supports dynamic handling of goals constraints and rules e.g.
to generate solutions for different subsets of rules.
application of a rule ralters the model by replacing the pattern defined by lhs with the pattern of the rhs illustrated in figure .
this is performed by finding a match of the lhs in the model checking the negative application conditions removing a part of the model that can be mapped to the lhs but not the rhs yielding an intermediate graph and adding new elements to the intermediate graph which exist in the rhs but not in lhs or updating existing elements yielding the derived graph.
e. design space the design space traversed by the guided exploration approach is represented by a graph transition system containing the states which are reachable from the initial state by applying the labeling rules.
agraph transformation sequence gt sequence is a sequence of gt steps application of a rule on a given match i.e.
a sequence of rule applications.
agraph transition system gts is defined as a graph where nodes are instance models and edges are rule applications.
starting from g0 initial state the state space i.e.
the reachable instance graphs of gts is represented by executing all applicable rules from a given initial graph as long as possible.
the different matches of applicable rules may lead to different edges ingts .
a path in the graph transition system is a gt sequence also called a trajectory between two states.
a state giis reachable from g0iff there is a trajectory in gts from g0togi.
in figure an extract of the graph transition system of the running example is shown.
on the left the root of the graph transition system is the start graph g0where the system configuration contains a cm three s and one dbcomponents.
rules adds addcl and addcm are applicable to g0 here we follow the application of adds andaddcl .
v. h ints the design space exploration framework uses graph transformation sequences to reach solution states.
in order to guide the exploration efficiently both the amount and order of rule applications are useful hints.176fig.
.
a part of a graph transition system a. graph transformation rule dependency given the precondition postcondition nature of gt rules it is possible to derive which rules might be affected by the application of a given rule.
for example the application of a gt rule rcan alter the model in a way that other rules which were disabled before become enabled or the other way around thus the application of these rules depend on the application of r. the dependencies between rules are independent of the instance models and can be derived from the rule definitions.
this analysis can be carried out using various techniques such as critical pair analysis or conditional transformation based dependency analysis and results in a matrix of dependencies between rules.
fig.
.
dependency graph example the result of the analysis is used to create a dependency graph gd illustrated in figure of the rules where an arc denotes sequential dependency i.e.
the application of the source rule may affect the match set of target rule .
note that there may be arcs in both direction between two rules.
as illustrated on figure rule adds depends on rules addcm addcl while rules addst adddb depend on adds the sets are represented by triangleleftsldradds andradds trianglerightsld respectively .
b. transformation rule occurrence vector we use a petri net abstraction technique introduced for gts in which provides hints that estimate how many times each rule is applied in order to reach a given state.
a candidate occurrence vector is a solution of the analysis of the petri net abstraction where i is the numberof times that rule riis applied during the execution.
during the design space exploration the number of times rule rihas been applied in a given path is stored in the application vector va asva i .
an execution path of the state space exploration is compliant with ifva the number of applications is less or equal for each rule .
throughout the paper we use the difference i va i as the remaining application number iof ruleri.
this number is stored as an attribute for nodes ingd see figure together with the state ofrithat is either enabled or disabled in a given state.
c. using dependency graph in design space exploration the model state and the dependency graph are tightly connected for a given initial graph and occurrence vector.
figure illustrates how the application of a gt rule affects the current state and the remaining application number.
first the current state is depicted as the model m representing the current cloud configuration and remaining application number and state of each node in the dependency graph gd in short thecurrent dependency graph .
the color of the nodes e.g.
nadds ofgdrepresent the state of the corresponding gt rules radds green dark background for enabled grey light for disabled.
the number near each node is the remaining application number e.g.
adds .
fig.
.
gt rule application and its effects on the dependency graph in the course of design space exploration the next gt rule which is applied radds in the example is selected from the set of enabled rules.
the application has the following effects on the models a model mchanges according to the rule definition here a new server sis added to cloud cm the new model is illustrated as m prime b the adds ismodified to represent that the rule is applied it decreases from to c gdis also changed to g prime d as adds decreased and the applicability of gt rules may change here radddb becomes enabled .
the design space exploration then continues from m primeby selecting a rule based on g prime d. vi.
g uidance a. overview of cut off and selection criteria cut off and selection criteria are used as guidance to decide in which order the states of the design space are explored.177we define formal criteria over the current dependency graph which are evaluated to support decisions cut off criteria inspect the current dependency graph and return a boolean result which is true if further exploration of the current branch cannot lead to a goal state with a compliant trajectory.
in this case the exploration continues from an other state instead of executing a rule in the current state.
selection criteria take the current dependency graph and define an ordering of applicable rules.
a given rule ri is placed before an other rule rj if the execution of ri is more promising based on the criteria and the current state than the execution of rj.
b. criteria for guided design space exploration we used the following cut off and selection criteria which are meaningful when dealing with guided dse.
non compliant path look ahead cut off criterion.
if the application of any gt rule would make the current execution path non compliant with the occurrence vector it can be cut.
permanently disabled rule cut off criterion.
the current path can be cut if there is a disabled rule which still has to be applied based on the occurrence vector but rules that may enable it will not be applied.
independent rule application selection criterion.
applicable rules with no forward dependency should be applied as early as possible to reduce the number of different applicable operations later in the trajectory.
maximal forward dependant application path selection criterion.
among the applicable rules at any given state of the exploration the rule that affects more applications should be applied earlier in the trajectory.
c. criteria evaluation the criteria defined over the dependency graph are evaluated at every state using an algorithm described in interpret hints challenge .
the main steps of the algorithm are a starting point is selected from the criterion the list of nodes satisfying the starting point are created the operations of the criterion are applied on each node and the result is assembled as a boolean value cut off criteria or an ordered list of rules selection criteria .
vii.
e xploration strategy guided exploration strategies can be categorized by the used hints and guidance.
we specified two guided strategies see figure the first uses occurrence vectors only as hints occurrence while the other uses rule dependency as well full guidance .
note that the full guidance strategy uses rule priorities only if two labeling rules were evaluated as equal by the guidance.
these strategies are compared to the fixed priority depth first search strategy.
figure illustrates the design space exploration for these techniques on a simple example.
the circles denote the traversed states which are numbered according to the traversal fig.
.
comparison of exploration strategies by used hints order while the applicable rules are listed beside them.
downward arrows illustrate rule applications while upward and dotted arrows represent backtracking from invalid or cut off states.
the same rule can be applied multiple times at a given state if more than one applicable match is found in the graph see state 2on the right side .
the exploration terminates when an optimal solution is found.
a solution is optimal if the path leading to it contains the least number of rule applications i.e.
it is the shortest trajectory to a solution model .
note that the framework is extensible also to labeling rules with costs and optimal solutions identified by the lowest total cost .
fig.
.
comparison of exploration strategies in the case of the fixed priority strategy the next applied operation is the one with the highest priority among the applicable ones.
in the example first r1is applied then r2.
from state firstr1is applied leading to state 3without applicable rules.
after backtracking r3is applied instead.
note that after this point all reachable states from state and state 1are explored before trying r2in state which finally leads to an optimal solution .
moreover as the depthfirst technique is used in the fixed priority exploration strategy the first solution found by that strategy is often several times longer than the optimal suboptimal solutions are used as depth limits to force the exploration to find shorter solutions.
theoccurrence strategy applies operations based on the occurrence vector provided by the system analysis.
the example in figure shows that r2should be applied twice and r3 once.
therefore r1is not applied in state 0or2 highlighted in order to be compliant to the occurrence vector.
in states and4 the exploration backtracks as no more rule applications are allowed by the vector and then continues to find the solution in state .
the full guidance exploration strategy illustrated in the right side of figure takes the dependency relations be 178tween rules into account in addition to the occurrence vector.
therefore in state highlighted it selects r3for the next application.
rule r2is applicable on two matches in state the first leading to a dead end state while the second application leads to a solution in state .
note that the selection in state leads to a reduced traversed design space compared to the occurrence exploration strategy reduce traversed design space challenge .
viii.
i mplementation details figure gives an overview of the implemented guided design space exploration framework.
the implementation uses the v iatra model transformation framework which provides metamodeling capabilities and supports model transformations based on the concepts of graph transformations and abstract state machines.
its incremental pattern matcher is used as a powerful query engine .
fig.
.
overview of the guided dse framework thedesign space exploration is performed by the constraint satisfaction engine csp m presented in where rules goals and constraints specified using graph transformation rules and patterns are used in solving constraint satisfaction problems over the input model both included in the design problem description .
the abstraction of graph transformation rules into petri nets pn and ilp problems are also automated.
we used the industry leading ibm cplex1optimization tool which supports the calculation of alternate solutions occurrence vectors used for initializing the dependency graph .
the edges ofgdare computed from the transformation rules using the condor2dependency analyzer tool while the graph itself is built and stored as an emf instance model.
the criteria definitions and the criteria evaluation algorithm guidance are implemented in java as separate components and are connected to the guided design space exploration strategy .
ix.
e valuation of the approach the aim of the evaluation is to demonstrate that the full guidance strategy is more efficient than the other strategies namely fixed priority and occurrence which we used for measurements in as it traverses considerably fewer states and does not introduce significant overhead thus provides better runtime in most cases than the other approaches.
the reader is directed to for comparison with other tools e.g.
sicstus prolog clp fd korat and groove which is omitted here for space considerations.
a. cases used in the evaluation for evaluation we used the cloud case study presented in section iv a and a service configuration case study presented in .
these cases are relevant in the context of modeldriven dse as they represent both design time and runtime exploration problems respectively and it allows comparison with previous results .
both case studies included multiple cases see figure .
poweron cases deal with empty initial models while reconfigurecases deal with existing models which must be modified to satisfy goals.
in the cloud cases the goals describe the number of required components e.g.
2applications and 2storage in poweron small .
furthermore global constraints are raised to give some limit to the priority based strategy e.g.
a cloud middleware should have at most 100nodes installed .
finally theclustered database case requires databases to be deployed on clusters see figure .
in the service configuration cases the models represent a set of services that are reconfigured runtime e.g.
removing faulty or starting new instances to meet some qos requirements.
the constraints in these cases define the maximum number of services while goals describe the number of active services and that faulty services are removed.
the size of the models are given after the name of the problem in the cloud cases the required applications and storages subsystems while in the service cases the maximum number of services faulty and active services in the initial model and active services in solutions.
b. evaluation environment and method the evaluation was carried out 5times for each test case and strategy in the following way3 the initial model is loaded into v iatra the goals constraints and operations are added to the framework the exploration component is initialized and runtime measurement is started using wall time with os level nanotime precision .
next the design space exploration framework looks for an optimal solution.
finally the runtime measurement is stopped and the results are saved.
the exploration is limited to1million visited states.
c. evaluation of results the table in figure shows the results of measurements using the case study models.
for each case we measured the average length of the shortest discovered solution trajectory the number of applied rules the average number of visited states during the design space exploration and the average runtime of the exploration.
3for measurements we used a computer with intel centrino duo .
ghz gb memory win7 prof. bit eclipse .
.
v iatra .2179fig.
.
results for exploration until optimal solution denote cases where exploration did not terminate in all tests we made the following observations based on the results from the different cases find optimal solution we observed that the usage of occurrence vectors as hints in the exploration ensures that the first solution found by such strategies is optimal as well optimal solutions challenge .
in our observations the fixed priority strategy finds longer solutions first and traverses a large number of states even in case which is the smallest before finding an optimal solution.
low overhead of criteria evaluation the evaluation of cut off and selection criteria is performed at every new traversed state and it might in principle slow down the exploration considerably.
however our observation is that criteria evaluation has very low overhead less than of the overall runtime .
the full guidance strategy requires some initial bookkeeping building dependency graph and initializing criteria but afterwards it traverses states in roughly 600ms similarly to the other strategies .
rule dependency increases efficiency in all cases the full guidance strategy traverses significantly fewer states than theoccurrence strategy.
note that the only case when the fixed priority strategy traverses less states is case where the occurrence vector is recalculated at least 20times before finding a feasible solution.
it is important to note that in these cases the full guidance approach outperforms the occurrence strategy by identifying infeasible occurrence vectors with less exploration.
figure illustrates how the number of traversed states for these two strategies when exploring infeasible occurrence vectors in case .
the graph clearly shows that the full guidance strategy explores only half the states in average that the occurrence does.
note that in case the occurrence strategy did not find a solution inside the limit in some instances.
fig.
.
reduction in visited states by the full guidance strategy to sum up the results of the evaluation we observed that the combined use of occurrence vectors and rule dependency for cut off and selection criteria based guidance outperforms our previously published strategies.
the added computation required for criteria evaluation does not significantly increase runtime.
the under approximation of the occurrence vector based analysis ensures that guided exploration strategies always find optimal solutions first.
d. limitations our guided dse relies on the quality of the hints provided for the design problems.
this manifests as a limitation in the following cases if the occurrence vector is infeasible and it includes a large number of rule applications similarly to case and if the dependency graph gd is close to a complete directed graph which makes criteria less effective as guidance.
finally a large gd in case of large set of operations may increase the overhead of criteria evaluation.
x. r elated work model driven guided design space exploration implemented over graph transformations is a novel idea in the field however similar approaches are not unprecedented in a broader research scope as described below.
in our previous work introduces the usage of occurrence vectors for hints in the optimization of gt systems while defines the dependency graph and the evaluation algorithm for arbitrary cut off and selection criteria.
finally describes the formal foundations of model driven dse used in our approach.
while we apply these techniques the design of the guided dse framework and guided exploration strategies are major novel contributions.
graph transformation based approaches the approach in is similar to our approach as it also exploits the dependencies between gt rules using critical pair analysis.
here gt systems are enhanced with control flow as well and the dependency information helps in discovering possible runtime problems.
model checking approaches to analyze gt systems are similar to our approach as they also perform state space exploration.
one can categorize them as compiled180approaches such as which translate graphs and gt rules into off the shelf model checkers to carry out verification and interpreted approaches like which store system states as graphs and directly apply transformation rules to explore the state space similarly to our approach.
they place emphasis on exhaustive traversal e.g.
by optimizing the storage of individual states while we aim at finding solutions quickly using guidance and hints.
model driven design space exploration techniques the desert tool suite provides model synthesis and constraint based dse for dsmls with structural semantics using ordered binary decision diagrams for encoding and pruning the design space.
presents a generic dse framework extending upon desert by supporting arbitrary analysis tools and includes model transformations for mapping design problems to intermediate and low level formats.
the octopus toolset uses an intermediate representation for design problem specification and performs dse using integrated analysis tools.
these are all compiled approaches where the design problems are specified as models and model transformations are applied to derive inputs for analysis tools.
furthermore the analysis tools perform the dse while in our approach they only provide hints for the exploration.
sch atz et al.
developed an interactive incremental process using declarative transformation rules for driving the exploration.
the rules are modified interactively to improve dse performance which can be considered as a guidance.
however the hints do not originate from analysis contrary to our approach.
guided design space exploration techniques existing dse techniques sometimes use guidance information to reduce the number of alternatives that are evaluated.
mohanty et al.
use human in the loop guidance in addition to symbolic search techniques for finding candidates which are then analyzed using low level simulation to find the final design.
in different chip design alternatives are evaluated using implementation specific information from earlier designs e.g.
cycle counts and energy consumption or estimates by experienced designers.
the hints are a collection of values while guidance is used for selecting optimal mappings.
these approaches use hints and guidance for reducing the design space although hints originate from earlier experience or human interaction instead of formal mathematical analysis of the design problem.
structural constraint solving structural constraint solving aims to find object graphs that satisfy given constraints both on attributes and object structures by exploring a usually bounded number of possible object graphs.
the cute framework uses a combination of symbolic and concrete execution to derive path constraints for each separate execution paths.
java pathfinder is based on generalized symbolic execution that first introduced the use of model checkers for solving structural constraints.korat performs specification based testing by using a predicate representing the properties constraints of the desired output structures and explores the input state space of the predicate using bounded exhaustive testing.
in all of these approaches hints are given in the form of explicit bounds on the size of the state space.
however they cannot restrict how solutions are achieved from the initial model meaning that no constraints can be defined to hold on states visited during a solution trajectory.
in our case it is supported by global constraints and explicit rule definitions thus resulting in fundamentally different search strategies.
metaheuristic based search strategies there are several single solution based metaheuristic techniques used in search based software engineering for the optimization of various design space exploration problems .
guided local search based techniques uses a predefined schema to inject penalties into their guidance functions.
simulated annealing based techniques are similar to hill climbing approaches with the ability to avoid local optimum solutions by permitting moves to less fit states with a decreasing probability over time.
common in these techniques that they use an iterative traversal algorithms to improve candidate solutions with regards to their measure of quality e.g.
guidance function .
however with no hints available about the global optimum these techniques rely only on neighboring states when selecting the next step on the contrary our approach uses hints like the occurrence vector for finding the optimum solution.
xi.
c onclusion and future work guided dse exploration uses hints to reduce the number of states traversed when searching for solutions.
hints are used i to identify dead end states cut off criteria and ii to order applicable rules in a given state selection criteria .
in the current paper we defined a model driven framework for guided dse which uses rule dependency and occurrence vectors as hints for the exploration strategy.
evaluation of the exploration strategies using a cloud configuration problem showed that our criteria driven approach can reduce the design space further thus increasing the efficiency of the exploration.
future work.
we plan to improve the framework by better reusing the design space when exploring subsequent occurrence vectors to identify states where the traversal should continue.
we are also working on defining problem specific criteria and specialized algorithms to increase the efficiency of the approach.
acknowledgment this work was partially supported by the securechange ict fet fp7 project the certimot erc hu09 project and additionally the janos bolyai scholarship.