singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems vector abstr action and concr etization for scalable detection of vector abstr action and concr etization for scalable detection of refact orings refact orings narcisa andr eea milea national univ ersity of singapor e lingxiao ji ang singapor e management univ ersity lxjiang smu.edu.sg siau cheng khoo national univ ersity of singapor e follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the softwar e engineering commons citation citation milea nar cisa andr eea ji ang lingxiao and khoo siau cheng.
v ector abstr action and concr etization for scalable detection of refact orings.
.
22nd a cm sigsof t international symposium on the foundations of softwar e engineering fse pr oceedings nov ember hong k ong china .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
vector abstraction and concretization for scalable detection of refactorings narcisa andreea milea school of computing national university of singapore mileanar comp.nus.edu.sglingxiao jiang school of information systems singapore management university lxjiang smu.edu.sgsiau cheng khoo school of computing national university of singapore khoosc nus.edu.sg abstract automated techniques have been proposed to either identify refactoringopportunities i.e.
codefragmentsthatcanbebut have not yet been restructured in a program or reconstruct historicalrefactorings i.e.
coderestructuringoperationsthat have happened between different versions of a program .
in this paper we propose a new technique that can detect both refactoring opportunities and historical refactorings in large code bases.
the key of our technique is the design of vector abstraction and concretization operations that can encode code changes induced by certain refactorings as characteristic vectors.
thus the problem of identifying refactorings can be reduced to the problem of identifying matching vectors which can be solved efficiently.
we have implemented our technique for java.
the prototype is applied to bundle projects from the eclipse ecosystem containing .
million lines of code and reports in total more than 32k instances of types of refactoring opportunities taking minutes on average for each type.
the prototype is also applied to versions of smaller programs jmeter ant xml security and detects more than .8k refactoring opportunities within individual versions with a precision of about and more than historical refactorings across consecutive versions of the programs with a precision of about .
categories and subject descriptors d .
.
software engineering distribution maintenance andenhancement restructuring reverse engineering and reengineering general terms algorithms design experimentation performancekeywords refactoringdetection softwareevolution vectorbased code representation .
introduction software development and maintenance tasks often need to change the structure of code without changing the functionality of the code.
this kind of code changes are often called refactoring and have long been recognized as an important way to improve the design of existing code permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.fse november hong kong china copyright acm ... .
.making code easier to understand maintain adapt to new requirements.
detecting refactoring has been a topic of long lasting interest in the literature.
some of the studies aim to detect refactoring opportunities i.e.
code fragments that can be but have not yet been restructured and thus to reduce bad smells in code and improve the design of the code some studies focus on understanding historic refactorings that have happened they reconstruct the refactoring operations used to restructure the code by analyzing different versions of a program to facilitate code maintenance and evolution studies .
it is desirable to have an approach that provides scalable consistent detection of both refactoring opportunities and historic refactorings as it can enable developers to measure more accurately their refactoring efforts and progresses during software evolution.
figure illustrates some challenges in detecting refactoring.1the first challenge is how to identify that code fragment a may be refactored?
one naive way isto check a s code pattern against every type of refactorings to see whether it may match one refactoring type.
such checks may identify many meaningless refactorings since certain refactorings may in fact be applied to any code.
then we may ask a more specific question how can we identify alikelyrefactoring type for a ?
an idea is to utilize refactorings that have happened we can try to identify another piece of code cthat has been refactored yet is similar to a before it is refactored and then we can have high confidence in saying that a may be refactored in the same way as c.i n this example the question may become how to decide a is similar to a supposedly before refactoring version of either code fragments b or c shown in the figure?
this can be challenging as well.
the code fragments a and b infigure1looksimilartoeachother but a contains extra variable declarations the underlined red parts and a method call to instantiate the bold part they may not be detected as similar code a.k.a.
code clones or refactoring unless relaxed similarity conditions are used.
however relaxed similarities can lead to many false clones to be detected and thus imprecise refactoring detection.
we can see that c may in fact be more similar to a than b if its call to the method getvector is inlined i.e.
by replacing the call to getvector with the actual method body from b and removing one of the returnstatements the inlined code denoted as ci becomes syntactically 1the code fragments a b and c were detected by our approach as a refactoring opportunity in a program named jmeter version and still exist with small variants in the latest version .
https jmeter.apache.org where a may be refactored into d which is syntactically similar to c but does not actually exist in the program.public static vector getcontrollers properties properties string name controller.
vector v new vector enumeration names properties.keys while names.hasmoreelements string prop string names.nextelement if prop.startswith name object o instantiate properties.getproperty prop org.apache.jmeter.control.samplercontroller v.addelement o return v a public static vector getvector properties properties string name vector v new vector enumeration names properties.keys while names.hasmoreelements string prop string names.nextelement if prop.startswith name v.addelement properties.getproperty prop return v b public static vector getvisualizer properties properties return instantiate getvector properties visualizer.
non nls org.apache.jmeter.visualizers.visualizer c public static vector getcontroller t properties properties return instantiate getvector properties controller.
org.apache.jmeter.control.samplecontroller d figure sample refactoring detected from jmeter.
similar to a except for differences in variable declarations the underlined red parts in a .
again usual code clone techniques may detect a and ci a s clones only if relaxed similarity conditions are used to tolerate the differences but these techniques cannot flexibly specify which differences to tolerate when computing similarity and using a relaxed similarity to force the detection of a and ci may produce other false clones that differ in other program elements than the variable declarations.2this indicates that similarity based clone detection is not sufficient for accurate refactoring detection a desired refactoring detection tool should possess knowledge about various kinds of refactoring operations and work flexibly with specific program elements.
last but not least in the context of discovering refactoring opportunities in large code bases we may need to compare many code fragments against each other and there is the added challenge to locate suitable refactoring candidates from multitude of code very efficiently.
in this paper we present a new vector based approach for scalable detection of both refactoring opportunities and historical refactorings.
we first construct characteristic vectors that can be used to encode syntactic features of code and use such vectors to encode inlinedcode so that the effect of method extraction and inlining which are commonly performed by various refactoring operations can be captured as well.
then we present a novel approach via vector abstractionandconcretization that can manipulate vectors flexibly based on code changes induced by known refactorings.
by 2in fact removing the underlined variable declarations in a and replacing the uses of the variables with their right side expressions isanother kind of refactorings called inline temp.
using vectors and vector operations as the representation of code and code changes our approach reduces the problem of detecting refactoring to the problem of finding similar vectors satisfying certain refactoring conditions.
since vector based operations can be performed in almost linear time with respect to the number of vectors and the dimension of each vector it becomes the key to the scalability of our approach.
for each code fragment identified as a refactoring candidate our approach also reports the likely refactoring op eration applicable to cby reporting a set of sample code fragments that may have been refactored via the same kind of refactoring operations.
such sample refactored code may help users understand better how to refactor c.f o r t h e example shown in figure our approach identifies a as a refactoring opportunity and reports b and c together as a sample.
then a user could proceed to refactor a in a way similar to b and c and transform a into d .
we have implemented our approach for java for both sourcecodeandbytecode andenabledvectorabstractionandconcretization operations for common types of refactoring operations.
our prototype is scalable and precise in alarge code base comprising of bundle projects in the eclipse ecosystem e.g.
eclipse jdt eclipse pde apache commons hamcrest objectweb asm etc.
containing .
million lines of code the tool reported in total more than 32k instances of types of refactoring opportunities taking minutes on average for each type in a smaller code base containing versions of three java programs jmeter ant and xml security our tool reported historical refactorings across various versions and more than .8k instances of refactoring opportunities.
with validation by four graduate students we find that the detected refactorings are of high precisions about for historical refactorings and about for refactoring opportunities.
our main contributions in this paper are as follows wedesignasystematicwaytoencodesyntacticfeatures of code and code changes needed for various types of refactoring operations as abstraction and concretization operations of characteristic vectors our encoding of code and code changes does not need to differentiate code within the same version or from dif ferent versions of a program so that we can detect both refactoring opportunities and historical refactorings our vector based encoding and similarity queries are efficient and enable scalable detection of refactorings we have evaluated our approach on large code bases with scalable and precise detection results.
the rest of the paper is organized as follows.
section presents related work.
section presents our detection approach.
section presents specific vector abstraction andconcretization operations used in our approach.
section presents the results of our empirical evaluation and discusses threats to validity.
section concludes with future work.
.
related work this paper is related to many studies in refactoring detection and software maintenance and evolution in general.
t h ed i s c u s s i o nh e r ei sb yn om e a n sc o m p l e t e .
there are many introductions and surveys for software refactoringandrelatedtools .
somesurveys and tools investigate the relations between refactoring and code clones and clone detection has been toutedas an important way to detect refactoring opportunities ex tract or pull up method in particular .
different from clone detection techniques especially the ones based on vector representations for code our approach extends vector operations with abstraction and concretization and utilizes various characteristics specific to refactoring operations.
many studies aiming for automatic detection of refactorings besides the studies on clone detection rely on the changes recorded in version control systems.
their focus is to reconstruct historical refactoring operations that have happened.
demeyer et al.
define heuristic metrics to search for refactoring between successive versions.
hayashi et al.
model the refactoring detection as a graph search representing structural differences between two versions of a program.
wei gerber and diehl define signatures based on code clone detection results to look for refactoring.
preteand kim et al.
use template logic queries to represent refactoring operations and a logic programming engine to search for refactoring happened between versions of a program their tool reffinder can detect kinds of refactorings in fowler s catalog .
taneja and dig et al.
present tools refactoringcrawler and refaclib to detect refactorings between different versions of libraries.
soetens etal.
detect refactoring operations as actual changes are happening in an integrated development environment and thus achieve higher accuracy than previous work.
origin analysis has also been used to detect refactoring by capturing certain kinds of cross function changes and how call relations change between two versions of a program.
different from these techniques our detection technique is vector based and is not limited for changes between versions it can search whole code bases and detect refactoring opportunities within t h es a m ev e r s i o no fac o d eb a s ea sw e l l .
there exist studies that detect refactoring opportunities they are related to many studies on detecting bad smells incode .
tourwe and mens use logic programming to encode several types of refactoring operations and detect possible refactoring opportunities.
meng et al.
create context aware edit scripts from two or more examples and use the scripts to identify edit locations and transform the code.
thisapproachcanbeappliedtofindrefactoringopportunities and fully automated while we have yet to automate somesteps in our approach.
however the edit scripts are so far limited within a single method as their experience shows that combining inter procedural analysis and the expressiveness of general purpose edits is a very hard problem.
they cannotdetect changes that require moving code from one method to another or coordinating changes to multiple methods in the way our approach does.
some other studies detect refactoring opportunities by searching for user built code that may be replaced with certain library calls or upgraded with calls to different versions of library apis .
those techniques mostly rely on graph based matching and substitution while we rely on compact and efficient vector based representations.
cider is another work that can detect refactoring without code change histories.
their algorithm relies on graphmatchingandrequiresinitialseedsthataresimilarcode fragments at first and is limited within individual methods too.
our technique does not need seeds and relies on vector matching making it more scalable to large code bases where code divergences across functions occur more often.
hui et al.
identify particular kinds of generalization refactoring opportunities.
our vector based approach detects different types of refactorings and can complement those studies.many other studies on refactoring focus on the specification and implementation of refactoring operations.
a classical work by opdyke describes a set of refactoring operations for c in terms of the preconditions needed to preserve behaviour.
griswold specifies refactoring from the perspective of their effects on program dependence graphs .
l ammel and garrido use rewriting rules to represent refactoring.
recent studies also aim to allow programmers to script their own refactoring operations.
to this end verbaere et al.
propose a domain specific language jungl for expressing dataflow properties on a graph representation of the program.
sch afer et al.
improve on this and provide high level specifications for many refactoring operations implemented in eclipse.
ge and murphy hill can automatically validate a manually performed refactoring.
our work complements those studies in that it searches for new refactoring opportunities.
as future work we planto investigate the development of a language for specifying vector abstraction and concretization that would allow us to more comprehensively and precisely specify the intended refactorings in addition to learning from examples.
many of the above mentioned studies can also automatically perform identified refactoring.
modern development environments such as eclipse and netbeans have automated refactoring capabilities.
concurrencer can identify and convert sequential code that may be benefited from the java.util.concurrent supports.
lambdaficator automatically refactors certain anonymous inner java classes and forloops to lambda expressions and functional operations available in java .
our tool currently focuses on detection only.
as our tool reports refactorings together with possi ble refactoring results it can also be improved to perform identified refactorings automatically.
.
methodology we explain the main steps of our approach along with figure .
given a source code base we construct its syntax trees sts andcallgraphs cgs .
thestsareusedinaway similar to previous studies to generate characteristic vectors for code fragments from the code base.
when the code is compilable we also generate the bytecode for java or binary code and construct characteristic vectors for the bytecode or binary code as well .
using bytecode or binary code has the benefit that many code differences only applicable to high level languages e.g.
different syntaxesfor writing forloops are unified or eliminated which can potentially help to detect more refactorings .
we also simulate the effect of method linining by manipulating the sts based on call relations and get inlined code and generate vectors for code fragments in the inlined code as well.
our tailored vector generation is described in section .
.
aftervectorsaregenerated theyare abstracted toeliminate or unify code characteristics related to a particular type of refactoring .
the particular code characteristics are semiautomatically extracted from known sample code refactored by see sections .
and .
then hash basedsearch simplehashandlocality sensitive hashing lsh is used to query for similar abstractedvectors efficiently so that we can identify candidates for refactoring see section .
.
not all candidates can be true refactorings.
we then apply vector concretization to check whether the characteristics in the concrete vectors indeed match the code characteristics of a particular type of refac inlined code vectors for inlined source code inlined bytecode vector abstraction vector ased query vector concretization detected refactorings vector generation figure overview of our approach.
toring see section .
.
we can afford to do more detailed checks during concretization since the number of candidates is much smaller than the original code sizes.
finally the code fragments corresponding to the candidates that are likely to be true refactorings are reported to users.
.
vector generation in this work we use characteristic vectors for the purpose of refactoring detection.
we define vectors as follows.
definition .
characteristic vector .
given a sequence of kunique features denoted by a characteristic vector vfor a code fragment cis an array of sizeksuch that n1 ... nk 0and for each i niisthe number of occurrences of the feature fiinc.
an entry in a vector vcan be referred to by either an index ior a feature fi d e n o t e db y v o rv r e s p e c t i v e l y .
i n principle the features can be anything in the code of interest to an application.
for example they can be different types of nodes in the syntax tree of cto represent the syntactic characteristics of the code or be certain parts of thesyntax tree that match slices of the program dependence graph of the code .
following the previous work we use the types of the nodes in syntax trees as features for this paper.
notethatnodetypesforsourcecodeandbytecodecan be different and thus corresponding vectors can be different.
since the vectors are generated according to the number of occurrences of program elements in code they themselves do not capture various specific information about each element e.g.
the specific name of an identifier the specific value of a constant etc.
or relational information between elements e.g.
the containing class of a method or a field the parent class of a child class a statement appearing before another statement etc.
.
nevertheless such vectors have been shown to be effective for code clone detection .
.
.
f or original not yet inlined code given a code fragment cfrom a code base we can identify t h en o d e so ft h es y n t a xt r e et h a tm a t c ht h el o c a t i o no f c and then count the number of occurrences of different node types.
for example sample heavily simplified vectors for the code fragments figure a b and c are shown in table the table headers indicate the sample features used for the vectors rows are the vectors for each of the three methods.
separated from the usual method invocations 3we use the term characteristic vector and vector interchangeably.
mth invoc.
api invoc.
refers to invocations of methods not defined in the subject program new invoc.
refers to invocations of constructors e.g.
new vector .
the actual number of features in the vectors depend on the numberof different types of nodes in either abstract or concrete syntax trees for a programming language.
our prototype implementation relies on abstract syntax trees generated by eclipse jdt for java which has more than node types.
table sample partial vectors for code in figure row idcode simple namestring literalvar.
decl.
stmt.
cast if return whilemth invoc.new invoc.
w invoc.
1getcontrollers 2getvector 3getvisualizer 4getvisualizer inline getvector 16features thesevectorsonlycapturecharacteristicsofthecodeinside the same function if a method is invoked in a code fragment the vector for the code fragment does not capture any characteristic of the code inside the invoked method except the method invocation expression and actual parameters.
thus in this paper we call these vectors base level characteristic vectors or simply basevectors.
although refactoring can happen on arbitrary pieces of code our implementation only generates base vectors for method bodies as the bodies likely contain refactorings in smaller scopes too and we do not aim to detect minimal code fragments that may be refactored.
this differs from the vector generation strategy for clone detection and helps to reduce our search space.
.
.
f or inlined code refactoring may involve different ways of extracting or inliningmethods.
toencodevariouspossiblechangesinduced by method inlining or extraction we also consider different ways to inline methods for a given code fragment c.i n general if cinvokesnmethods there could be up to 2nways to inline the nmethods in combination.
to reduce the search space in this paper we inline methods invoked in cin mainly three different modes inlining all methods invoked in call at once inlining all calls to each distinct method separately or inlining nothing.
we do not inline constructor and api invocations.
in this way the number of inlined versions ci ofcmay equal to two plus the number of distinct methods defined in the program and called in c. an inlined version ciforccan be the same as cwhen the mode of inlining n o t h i n g i sa p p l i e do rw h e nn om e t h o di sc a l l e di n c.we simulate the effect of method inlining by summing up the vectors for the caller and the callee and manipulating the features in the vectors that are related to method declarations andinvocations i.e.
thefeaturesfortheinvocations returns and formal and actual parameter substitutions.
specifically for the features shown in table we reduce the occurrence counters for mth invoc.
and simple name each by one for each method called simple name is a child node of mth invoc.
representing the method name in the syntax trees generated by eclipse jdt for java and remove all counts for returns from the callee.
we assume each actual argument is only evaluated once and the corresponding formal parameter somehow automatically receives its value and thus the vectormanipulations do not need to consider the effect of parameter substitution.
for example when we inline getvector into getvisualizer the vector for getvisualizer is changed as the row in table .
the red parts of the row indicatethe manipulations applied to the sum of rows and tosimulate the inlining.
such simulated method inlining via vector manipulation has been shown in our previous work to be effective for detecting method extraction and inlining .
this paper employs the same idea of vector inlining but extends it to define vector abstraction and concretization for detecting more types of refactorings.
we note that the manipulation of vectors to simulate method inlining may be language specific it depends on the structure of syntax trees as well it can be different for source and bytecode too.
however the idea of encoding method inlining as vector operations can be generally applicable to different programming languages.
in the following discussion we use the following terms and notations given a code fragment c w ec a l li t base code a n d its vector is called base vector and denoted as vc.
the set of all possible inlined versions of cis denoted as ci w h i l e an instance in the set is denoted as ci.
the vector for the inlined code ciis called inlined vector and denoted as vi c. .
vector abstraction our objective here is to encode code changes induced by a kind of refactoring operation in the form of vectors as precisely as possible and abstract away or eliminate the changes from the vectors representing code while maintaining essential code features so that the abstracted vector representations for the code before and after it is refactored can be the same.
then the problem of searching for refactorings can be reduced to the problem of finding code with the same abstracted vector representation.
each refactoring type has a different abstraction since they often induce different code changes.
we use ato denote the abstraction operation for a refactoring type .
a v m e a n s to apply the abstraction onto a vector v a n d denotes the resulting abstracted vector.
the query portion on the left in figure illustrates the conceptual relations among base code inlined code and various kinds of vectors with respect to a refactoring ap i e c eo fb a s ec o d eu s e da saq u e r y q can have more than one inlined code qi i t sb a s ev e c t o r vq c a nb e c o m ea na b s t r a c t e db a s ev e c t o r q and its inlined vectorvi qcan become an abstracted inlined vector i q.i ti s possible that i qmay be the same as vi qand orvq.
in this paper we use a semi automated mechanism to extract differences from sample code refactored by a type of refactoring and define the abstraction for systematically based on the differences.
we introduce our definitions inline base code inlined codeinlined vector base vectorabstracted inlined vectorabstracted base vector query query result match abstracted vectors filter vectors check concrete vectors for patterns specific for query result check across results for higher report likely refactorings for vector abstraction codevectorsabstracted vectors vector generation figure given a piece of code q search for code similar toqifqmay be refactored via a refactoring operation .
definition .
vector substitution .
given a vectorvand a set of mappings from features to counts f fi mapsto ni thevector substitution is denoted by v f i t generates a new vector v prime s u c ht h a t i ..k v prime braceleftbigg niif fi mapsto ni f v otherwise bothniandf denote the mapping result for a feature fj.
definition .
vector difference .
given two vectorsv1andv2 t h evector difference operation forv1and v2is defined as v1 v2 v m d where .v is a vector called assimilation vector betweenv1and v2 i ..k v min v1 v2 .
m k .dis a feature mapping set of size m i ..k fi mapsto v2 v1 diffv1 negationslash v2 .
such vector difference operations v m d encode both common parts in v and differences in d between two vectors.
when v1andv2correspond to two sample pieces of codec1andc2 a n dc2is the result of applying a certain refactoring operation ontoc1 the feature mapping set d indicates the features that may be changed by and can help us define the abstraction operation afor that can abstract away the changes that may be induced by into an arbitrary vector v. the abstracted vector for vis denoted by either a v o r .
the rules below describe how is generated for an arbitrary v based on a given v1 v2 .
the rules are conceptually the same for source code and bytecode.
i v ifddoes not contain a mapping for fi.
ii if there is a subset of d denoted as d fd1 mapsto nd1 fd2 mapsto nd2 ... fds mapsto nds where s k and d1 d2... ds ds k such that s i 1ndi 4then we consider the features in d as inter exchangeable and we merge their counts in vall into a unique conceptual feature as follows s i 1v i ..s .
for example various relational operators a n d in code are in fact inter exchangeable since a refactoring operation can reverse the condition in an ifstatement and swap the branches of if.
such a refactoring would induce changes in the counts for the individual operators but the total sum of the counts for these interexchangeable code features should remain the same.
iii if there is a subset of d denoted as d fd1 mapsto nd1 fd2 mapsto nd2 ... fds mapsto nds where s kand d1 d2... ds ds k such that nd1 nd2 fdi mapsto ndi d ndi negationslash because of the rule in def.
.
.... nds then we consider the features in d should be changed together in the same way by and we set all t h e i rc o u n t st o1a sf o l l o w s i ..s .
this condition helps the refactoring cases when it is not important to count the actual number of occurrences of a code feature as long as the feature exists in the code.
for example the refactoring type consolidate duplicate conditional expression consolidates more than one conditional expression into one so the features essential to the conditional expressions were all set to .
iv there may be multiple subsets of dsatisfying the above conditions if the subsets are disjoint we perform the abstraction for each subset separately if the subsets overlap we manually identify a subset to abstract.
in our experiments vector differences dare generated from sample refactored code in classical collections see section and of small sizes and it was easy to find suitable subsets as above efficiently.
v otherwise.
the intuition for this rule is that if a feature fican be changed by the refactoring but not in conjunction with other features fimay in fact be changed arbitrarily by and it is non essential for and thus we abstract it away.
as one can see we define conjunction as the subsets satisfying the rule ii or iii and we found the simple rules are sufficient for the refactoring types detected in our experiments.
also since the rules do not yet consider the semantics of the features the mapping dgenerated from sample refactored code may contain more features than what are really needed for .
so we also manually verify each inferred abstraction in our experiments.
for example we can define the vector abstraction for the kind of refactoring operation in figure .
even though those code snippets are detected by our tool here we use them as sample refactored code to illustrate how we define the abstraction for a refactoring operation based on sample refactored code.
for this case the vector in row in table is v1and the other in row is v2 the vector difference dis simple name mapsto var.
decl.
stmt.
mapsto which indicates the removal of two variable declaration statements containing four simple names two are for the variable names the other two are for the variable types .
the above abstraction rule v applies so the abstraction awould set the counts for both simple name and var.
decl.
stmt.
to zero.
table shows the abstracted vectors if the abstraction is applied to the concrete vectors in table .
table sample abstracted vectors for vectors in table row idcode simple namestring literalvar.
decl.
stmt.
cast if return whilemth invoc.new invoc.
w invoc.
1getcontrollers 2getvector 3getvisualizer 4getvisualizer inline getvector 6features when more than one pair of sample code is provided for a refactoring operation we can refine the extracted abstraction for to represent the most general code changes induced by .
to achieve this we can calculate the vector difference v m d for every pair and look for the maximum common difference among all those v m d .
in this paper we still employ manual efforts to use appropriatethresholds and refine the extracted abstraction if necessary.
as interesting future work we plan to automate the extraction of abstraction from given sample code based on vector arithmetics.
such automation may be in spirit similar to studies on specification mining and programming by examples but it will use a significantly different technique based on vector representation and arithmetic of the characteristics of code and code changes.
.
vector based query when we want to find instances of a type of refactoring operations in a large code base we apply the abstraction for to all vectors generated from the code base.
the code difference induced by should thus be eliminated and the abstracted vectors of either refactored or non refactored code should appear the same.
then we can use hash based matching techniques to find vectors that are either matching exactly or very similar to each other .
we tailor the queries in our approach to answer the question can a piece of code qbe refactored via a refactoring operation so that it becomes similar to some other code?
as illustrated in the step in figure we perform queries on abstracted vectors for either base or inlined code or both abstracted vectors either qor i qor both are used each as a query against all other available abstracted vectors to identify the ones matching the query.
depending on the vectors used we can identify candidates for both historical refactorings and refactoring opportunities when we use every abstracted vector generated for one version of code as a query to search for matching ones in the set of abstracted vectors for another version of the code we can detect historical refactorings happened between two versions of the code.
when we use every abstracted vector generated for a code base as a query to search for matching ones in all abstracted vectors for the same code base we can detect refactoring opportunities that may be similar to some refactorings that have happened in the code base.
the types of refactorings under investigation would affect whether the corresponding queries and matching outcomes are drawn from either base vectors or inlined vectors or both.
for example for the detection of the opportunity of method inlining shown in figure a we used the abstracted vector for thebasevector of a as a query and search for its matches among the abstracted vectors for all other inlinedcode.
not all matched vectors can be refactorings we apply heuristic filters figure step to reduce unlikely ones filtersmall when a piece of code is too small e.g.
smaller than the number of elements involved in the abstraction for or the sizes of the sample code used to define the abstraction it may not be useful to refactor it.
we can use a threshold e.g.
of the sizes of the sample code or program elements or functioning statement to remove code that is too small.
filterclones when comparing the concrete vectors for both the query code and the result code if both vq vc1 andvi q vi c1 qandc1are very likely the same syntactically and their inlined versions are the same as well.c 1is simply a clone of qand may not indicate how to refactor q and thus can be removed.
filternames many refactoring operations would maintain various names e.g.
some variable names in the code and the name of the method class file containing thecode the same before and after the refactoring.
we can remove a query result if its fully qualified method name does not match that of the method containing the query code.
this can be useful for detecting and reconstructing historical refactorings happened between versions where the query code and the result code are in different versions of a program and often share same name.
we only turn on this filter for across version refactoring detection.
for the code fragments in figure a and c inlined with b can be detected as likely refactorings since their abstracted vectors rows and in table are the same.
.
vector concretization after above steps we have a set of filtered query results for each piece of code used as a query.
the following concretization phase performs several kinds of checks on the concrete vectors corresponding to the query and the query results to improve the precision of refactoring detection.
this phase corresponds to steps and in figure .
the first kind of checks is to make sure the differences among the concrete vectors indeed subsume the differences d see section .
that may be induced by a kind of refactoringoperation i .
e .
may really be applied to the corresponding code.
this is useful for reducing false positives since different refactoring operations may in fact change same features in code and having similar abstracted vectors may not mean the corresponding concrete vectors satisfy requirements needed by see the concretization rule i below .
t h es e c o n dk i n do fc h e c k si st om a k es u r et h er e p o r t e d query results indeed have the contexts in which the refac toring operation can be carried out.
for example the refactoring reverse conditional reverses the relational operator in an ifstatement and swaps the branches of the if and thus the refactoring can only happen when the code contains at least one if even though the feature representing ifitself is not changed by the refactoring.
so we perform checks that the common parts among the concrete vectors indeed subsume the common parts v see section .
that represent the contexts needed for see the rule ii below .
for certain types of refactorings we manually add special checks for them see section based on our understanding of the code changes involved in the refactorings to help reduce false positives.
for example a refactoring operation may simply replace the wholebody of a method with a call to a newly extracted method containing the replaced body.
although such a refactoring may be classified as extract method it may be too simple to be useful.
thus we filter such cases during concretization the rule iii .
we also cross check query results to improve their credibility.
intuitively the query results should be syntactically different from the query otherwise they are likely clones only not refactorings.
also when there are more than one query result that are syntactically different from each other they may indicate more than one way to refactor the query code which may appear confusing for users.
we thus choose to remove such cases so that users can have higher confidence that the refactoring operation indicated by the final query results can be applied to the query code the rule iv .
the rules below describe the above checks more rigorously i calculate the vector difference between vi qand each vi ci vi q vi ci vi q miq di q .
check them against the vector difference v m d f o r and remove the query result ciif one of the following conditions is true if fi mapsto ni d s.t.
ni vi q ni it means would need to remove ni instances of the code feature fibutqidoes not contain enough if fi mapsto ni d s.t.eitherdi qdoes not contain fi or di q ni .
this indicates that the changes between vi qandvi ciare too few in comparison with the changes induced by to be a real case of if i ..k s.t.
vi q v vi ci v it means would need to be carried out in a context containing v instances of the code feature fibut qiorci idoes not contain enough ii checkvqandvciagainst v m d and remove the query result ciif the following condition is true if i ..k s.t.
vq v vci v it means would need to be carried out in a context containing v instances of the code feature fibut qorcidoes not contain enough iii check all base and inlined vectors against code change rules specific for to remove possibly more query results iv we finally check the query results against each other if there are still more than one result at this step.
we remove all of the results if the following condition is true i j s.t.
i negationslash j vci negationslash vcj finally the code corresponding to the query and checked query results are reported as refactorings.
for the code fragments in figure one of the differences among theirconcrete vectors table rows and indeed match the vector difference operation simple name mapsto var.
decl.
stmt.
mapsto .
their contexts are also matched.
thus a a n d c i n l i n e dw i t h b a r er e p o r t e da sr e f a c t o r i n g s .
.
refactoring as vector abstraction concretization our approach is based on abstraction and concretization of characteristic vectors that capture various code features before and after certain refactorings.
the effectiveness of ourapproach is dependent on how well the vectors can represent code features.
as mentioned in section .
.
the vectors used in this paper only capture code features related to the number of occurrences of program elements in code.
thus our approach is tailored to detect refactoring operations that would change the number of occurrences of various program elements in code.
some refactoring operations can inducecode changes that are not represented by the vectors.
forexample pull up method moves a method from a child class to its parent class.
the moved method itself is the same before and after the refactoring but its containing class is changed.
rename method changes the name of a method.
the characteristics of such changes are not captured in the vectors and thus are not yet detectable by our approach.
it will be our future work to extend the capabilities of vectors to encode and index programs more comprehensively.
in this paper the sample refactored code used for constructing abstraction and concretization rules is all fromclassical collections .
we have rules for types of refactorings although not every type has detection results inour experiments.
due to our page limit table only lists 11types and uses simplified notations and descriptions instead of rigorous vector based operations.
abstraction rules that do not change the values for a feature are not shown.
some concretization rules are the same for all types of refactorings as described in section .
they are also omitted.table sample abstraction and concretization operations.
in addition to the notations used in section vectors superscripted with s are generated from source code while others are generated from bytecode.
many features used in the operations characterize bytecode instructions in our implementation but we use more high level names for the features here for illustration purposes.
due to space limitation we rely on the feature names to convey their meaning.
refactoring abstractions or simply concretization checks descriptions .
extract method vi inlined into v c s.t.
v q v i remove simple extraction methods .
inline method vi inlined into v q s.t.
v q v i remove simple extraction methods .
inline temp vq v c vq v c v q v c vqs v cs remove the declaration of a temporary variable and replace the use of the variable with the value of the variable.
.
introduce explaining variable vq v c vq v c v q v c vqs v cs extract a complicated expression into a temporary variable.
.
split temporary variable v v v v i vcs vqs v cs vqs v cs transform multiple assignments to a temporary variable into separate variable declarations for each assignment.
.
replace method with method object vi inlined into v c s.t.
vi vq v i v i f v i v q v ci v q transform a method into its own object so that all the local variables become fields.
abstraction involved ignoring new operators and encapsulation.
.
self encapsulate field aload 0 is used for loading this on the stack vq v ci an extra field to encapsulate vi inlined into v c s.t.
v i v i v i v i where op!
getfield op!
return op!
aload 0 replace direct accesses to a field with a getter method .
replace magic number with symbolic constant no abstraction needed as both are represented by the same bytecode.
vqs vcs query has more magic numbers literal string literal boolean literal num literal vqs v cs replace constants used in code with symbolic names for easier maintenance .
replace magic number with 4uery 0ethod no abstraction needed as both are represented by the same bytecode.
vi inlined into v c s.t.
vis op string literal boolean literal num literal v is v is replace constants used in code with a getter method that returns the constants.
.
reverse conditional v v v opp gt ge le cond eq neq or opp lt gt ge le v q v c !
v q v c !
treat the same as !
treat the same as and .
encapsulate downcast ignore type casts vq v c encapsulate type cast operations into a separate method returning the casted type .
empirical ev aluation this section presents our evaluation on four aspects how many historical refactorings are detected how many refactoringopportunitiesaredetected howaccuratearetheidentified refactorings and how scalable is our approach.
.
experimental setting in order to provide answers to the evaluation questions we have performed two case studies.
all experiments related to these studies were performed on a pc running ubuntu .
with intel xeon at .67ghz and 24gb of ram.
in the first case study we looked at three java programs from the software infrastructure repository sir jmeter xmlsecurity and ant.
for jmeter we performed experiments on versions to for ant on versions to and for xmlsecurity on versions.
the size of these subject programs ranges from 17kloc to 80kloc.
the projects were selected for comparing our prototype with the state ofthe art in detecting historical refactorings reffinder and for measuring the effectiveness of detecting refactoring opportunities by our prototype.
in the second case study we aimed to explore the scalability of our system.
as such we have applied the prototype toa large code base containing .
million lines of code and bundle projects from the eclipse ecosystem e.g.
eclipse jdt eclipse pde apache commons hamcrest etc.
.to evaluate the precision of the results detected by our approach a group of four graduate students with good knowl edgeofjavaandrefactoringwereinvitedtoinspecttheresults independently.
due to the large number of results we do not evaluate every one of them.
for refactoring opportunities detected for the three subject programs we chose to inspect the results for the first version of each program only.
each result inspector was required to verify that each of the detected refactorings is correctly classified.
a result was counted as a false positive if any of the inspectors considered it as a false positive.
for historical refactorings detected we chose to inspect all of them due to a more manageable number.
it is not our focus to evaluate the recall of our approach due to lack of ground truths.
however we tested our approach on a set of examples taken from fowlers catalog and found our approach can successfully detect all defined types of refactorings in the example set.
.
detection results the results of the experiments performed in the first case study are shown in table and .
each row in the tables shows the results obtained for one type of refactoring query the types having no detection results are not shown in the tables.
each column having a single number e.g.
as the header name shows the refactoring opportunities within a version of the project while each column having a numbertable result summary for jmeter.
program versions 0 11 1 22 2 33 3 4 4 5 .
extract method .
inline method .
introduce var .
inline temp .
replace assignment with initialization .
downcast encapsulate .
reverse conditional .
replace dagic eumber with ymbolic onstant .
self encapsulate field .
replace parameter with method subtotal table result summary for ant.
program versions 0 11 1 22 2 33 3 4 4 5 .
extract method .
inline method .
introduce var .
inline temp .
replace assignment with initialization .
downcast encapsulate .
reverse conditional .
replace dagic eumber with ymbolic onstant .
self encapsulate field .
introduce parameter object .split temp subtotal range e.g.
as the header shows the number of detected historical refactorings between two versions.
the number of historical refactorings we detected between versionsrangesfrom0to99whilethenumberofopportunities within each version ranges from to .
out of total refactoring opportunities detected within all versions of the three subject programs 5the students inspected and identified false positives giving a precision of for our approach in detecting refactoring opportunities .
we inspected all of the historical refactorings detected.
this validation was performed by the authors and the students to verify that the classification reported by our approach for an actual code change between two versions is correct.
we found false positives which resulted in a .
precision for detecting historical opportunities .
the tables show that the numbers of refactoring oportunities detected evolve from one version to another in a non monotonous manner.
an increase in the numbers of reported refactorings may imply that the size of the project increased due to code copy paste operations or refactorings that have only been applied to parts of the project.
a decrease may indicate that code was deleted that previously similar code has diverged in shape or that the opportunities were applied.
an example of the latter situation is exhibited by jmeter between the versions and for the refactoring encapsulate downcast row and columns and in table .
in the versions and of jmeter a large number of methods invoked method getproperty from class taskand downcasted its result to obtain a string.
another category of methods invoked method getpropertyasstring from class taskwhich had the downcast pushed inside the method.
the similarity between the methods that invoked getproperty and those that invoked getpropertyasstring 5a piece of code can be counted multiple times if it appears in multiple refactoring types in our results.table result summary for xml security.
program versions 0 11 1 2 2 3 .
extract method .
inline method .
introduce var .
inline temp .
reverse conditional .
replace magic number with symbolic constant .
self encapsulate field .
introduce parameter object subtotal resulted in a number of refactoring opportunities detected by our approach.
between versions and some of theseopportunities were applied and the methods that invoked getproperty were changed to invoke getpropertyasstring .
these cases were captured by our approach by comparing the two versions but not detected by reffinder.
we now discuss a few refactoring types that highlight the strength of our approach as opposed to using either clone detection to detect refactoring opportunities or tools in the literature that detect historical refactorings a classifying refactoring involving small changes precisely self encapsulate field is a refactoring that manifests itself in terms of changes to method bodies by a change from a direct field access to a call to a getter method.
this smallchange between the before and after methods can cause alarge number of similar methods to be returned by traditional threshold based similarity approaches.
unfortunately most of the returned results are irrelevant to the self encapsulate field refactoring leading to high numbers of false positives.
our approach on the other hand can detect a large number of self encapsulate field refactorings with a high precision.
specifically we detect more than historical refactorings that were not detected by reffinder between the ant versions and with a precision.
in comparison with reffinder we note that reffinder has a different refactoring definition for self encapsulate field its definition is based on changes between two versions of a program focusing on the creation of a getter method and does not capture the manifestation of self encapsulate field in the methods that access it.
this makes comparison between reffinder and our approach impractical.
reffinder definition of self encapsulate field encapsulate field ffullname there are no access to the field besides the new getter and setter self encapsulate field deleted fieldmodifier ffullname public added fieldmodifier ffullname private added getter mgetfullname ffullname added setter msetfullname ffullname encapsulate field moreover we note that reffinder cannot be applied within the same version thus is unable to discover many refactoring opportunities that occur within a version.
b detecting complex refactoring patterns replace parameter with method transforms a method m which invokes a method m1and passes its return value as an argument for another method m2 by moving the call to m1into a modified version of m2.
figure shows an example.
detecting an instance of this refactoring type requires a specific definition of similarity among the caller and the callees.
our approach can achieve the precision by specifying that the difference in the numbers of method calls in the two versions of vectors for the caller getprice is the additive inverse of that in the two versions of vectors for the callee discountedprice .public double getprice int baseprice quantity itemprice int discountlevel getdiscountlevel double finalprice discountedprice baseprice discountlevel double finalprice discountedprice baseprice return finalprice private double discountedprice int baseprice if discountlevel return baseprice .
if getdiscountlevel return baseprice .
else return baseprice .
public double getprice int baseprice quantity itemprice int discountlevel getdiscountlevel double finalprice discountedprice baseprice discountlevel return finalprice private double discountedprice int baseprice int discountlevel if discountlevel return baseprice .
else return baseprice .
figure example of replace parameter with method.
table result summary for eclipse.
z dlj no of zesultstime d d d s d z d z nj z d e z e w k z w d z d z d d k the second case study evaluated the scalability of our approach by applying it on a large scale ecosystem of projects.
the results are presented in table and show that our approach can efficiently detect a broad range of refactoring types in eclipse projects.
queries for each type of refactoring finished in about minutes on average.
the exceptions were consolidate conditional and replace nested conditionals which took minutes as the complex concretizations rely on comparing features from both bytecode and source code vectors.
as a contrast we note that for the biggest project in the first case study ant version the queries for each type of refactorings took at most seconds.
.
threats to validity future work our approach relies on characteristic vectors which results in a threat to construct validity stemming from whether the vectors can really represent refactorings.
although vectors ignore various information in code e.g.
the ordering or relations among program elements the specific names of identifiers they have been shown to be effective for code clone detection and the abstraction and concretization operations take the features of each type of refactorings into consideration making the vectors more tailored for refactoring detection.
however since the vectors only count the occurrences of basic program elements and do not encode features needed for many other refactoring types in classical collections we will need to encode more features inthe vectors to go beyond the types of refactorings we can detect now.
the features encoded in the vectors are languagedependent so are some refactoring types so our approach may need adjustments for different languages.
our vector abstraction and concretization operations are heuristic and learned from sample refactored code so their accuracies are dependent on the quality of the sample code.
we used sample code from classical collections and aimed to ensure precise encoding of the most essential changes for each refactoring type our results show good precisions.
however there may also be biases in the evaluation of the accuracy of the reported refactorings since we relied on manual investigation on selected samples by students had only compared with one previously existing tool for detectinghistorical refactorings and we need a better way to evaluate the recall rates of our approach.
in the near future we plan to extend vector operations for more refactoring types apply our approach with more sample refactored code to more subject programs port our implementation to other languages conduct more systematic user studies to alleviate the above threats and make our tool and evaluation data available for other researchers.
also we plan to automate the definitions of abstraction and concretization operations with ideas and techniques fromprogramming by examples and apply detected refactoring opportunities automatically.
.
conclusion this paper presents a new vector based approach for scalable detection of refactorings.
our approach builds on top of characteristic vectors that encode various code features.
most importantly it extends vectors with abstraction and concretization operations to capture the features of the code changes that may be induced by a refactoring operation.
such abstraction and concretization operations can be extracted and refined based on known refactored code samples.
both refactoring opportunities i.e code fragments that may be restructured according to a refactoring type and historical refactorings i.e.
code fragments that have been restructured according to a refactoring type can be encoded via concrete and abstracted vectors.
thus our approach reduces the problem of detecting refactorings to the problemof detecting matching vectors which can be solved efficiently in almost linear time with respect to vector numbers.
we have implemented our approach for java and applied the prototype to a large code base containing bundleprojects from the eclipse ecosystem and about .
million lines of code.
our prototype detects more than 32k instances of types of refactoring opportunities in about hours.
wehave also applied our prototype to versions of programs used in previous studies on refactoring detection and found instances of various types of historical refactorings across consecutive versions of the programs with a precision.
our prototype also detects more than .8k instances ofrefactoring opportunities within individual versions of the programs with a precision.
.