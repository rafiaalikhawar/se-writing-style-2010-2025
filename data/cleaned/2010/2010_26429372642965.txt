recommendation system for software refactoring using innovization and interactive dynamic optimization wiem mkaouer marouane kessentini slim bechikh university of michigan mi usa firstname umich.edu kalyanmoy deb michigan state university mi usa kdeb egr.msu.edu mel cinn ide university college dublin ireland mel.ocinneide ucd.ie abstract we propose a novel recommendation t ool for software refactoring that dynamically adapts and suggests refactorings to developers interactively based on their feedback and introduced code changes.
our approach starts by finding upfront a set of non dominated refactoring soluti ons using nsga ii to improve software quality reduce the number of refactorings and increase semantic coherence.
the gene rated non dominated refactoring solutions are analyzed using our innovization component to extract some interesting common features between them.
based on this analysis the suggested refactorings are ranked and suggested to the developer one by one.
the developer can approve modify or reject each suggested refactoring and this feedback is used to update the ranking of the suggested refactorings.
after a number of introduced code changes a local search is performed to update a nd adapt the set of refactoring solutions suggested by nsga ii.
we evaluated this tool on four large open source systems and one industrial project provided by our partner.
statistical analysis of our experiments over runs shows that the dynamic refactoring approach performed significantly better than three other search based refactoring techniques manual refactorings and one refactoring tool not based on heuristic search.
categories and subject descriptors d. general terms algorithms reliability keywords search based software engineering software quality refactoring .
introduction software systems rapidly beco me complex and difficult to maintain.
it has been reported that the cost of maintenance and evolution activities comprises more than of total software costs.
in addition it has been shown that software maintainers spend around of their time in understanding the code .
to facilitate maintenance tasks one of the widely used techniques is refactoring which improves design structure while preserving the overall functionality of the software .
there has been much work on di fferent techniques and tools for software refactoring that can be mainly classified into two categorie s manual and fully automated approaches.
for the first category several tools are proposed to provide support for the application of several types of refactoring manually .
the developers identify which refactoring type to apply and where.
thus the manual refactoring process can be a tedious task for developers.
in the second category of refactoring studies most of the proposed approaches generate as output a long sequence of refactorings that can be applied by developers to improve the quality of systems by fixing for example code smells .
here the developers have to accept the entire solution in spite of the fact that they prefer in general stepwise interactive approaches where they have total control of the refactorings being applie d. few studies consider the suggestion of refactoring operati ons based on interaction between the developer and the refactoring tool.
we propose a novel interactive recommendation tool for software refactoring that dy namically adapts and suggests refactorings to developers base d on their feedback and introduced code changes.
our approach star ts by finding upfront a set of refactoring solutions using a multi objective evolutionary algorithm nsga ii proposed by deb to improve software quality reduce the number of refactorings and increase semantic coherence.
the output of nsga ii is a set of non dominated refactoring solutions that find a good trade off between these three objectives.
one of the challenges when adapting a multi objective technique to a software engineering problem is how to select the best solution from the set of non dominated ones called the pareto front .
to this end we propose for the first time the use of innovization innovation through optimization to analyze and explore the pareto front interactively with the developers.
our innovization algorith m starts by finding the most frequent refactoring pattern ope rations between the set of nondominated refactoring solutions .
based on this analysis the suggested refactorings are ranked and suggested to the developer one by one.
the developer can approve modify or reject each suggested refactoring.
this feedback is then used to update the ranking of the suggested refactorings.
after a number of introduced code changes a local search is executed to update and adapt the set of refactoring solutions suggested by nsga ii.
we implemented our proposed approach and evaluated it on four open source systems as well as one industrial system provided by our industrial partner.
.
dinar dynamic interactive multi objective refactoring we first present an overview of our technique called dinar dynamic interactive refactoring and then provide the details of our problem formulation and the solution approach.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
.
overview the goal of our approach is to propose a dynamic interactive way for software developers to refactor their systems.
the general structure of the dinar approach is sketched in figure .
figure .
approach overview dinar.
the three main components of dinar are finding the best set of refactoring solutions that satisfies three objectives using nsga ii applying our innovization algorithm to rank the refactorings and suggest them to developers and updating the refactoring solutions after a number of interactions with developers using a multi objectiv e local search algorithm .
our refactoring framework starts by finding upfront the list of best refactoring solutions that represents a good trade off between improving software quality which corresponds to minimizing the number of code smells and improving qmood quality model for object oriented design quality metrics minimizing the size of the refactoring solutions number of refactorings and maximizing preserving the seman tic coherence of the design.
therefore we use a multi objective optimization algorithm nsga ii to compute this optimal sequence of refactorings based on our previous work .
the output of this first step is a set of non dominated refactoring solutions called the pareto front which optimizes the three objectives described above.
the second component of dinar explores this pareto front in an intelligent manner using an innovization algorithm innovation through optimization to rank recommended refactorings and suggest them to the developer one by one as a sequence of transformations based on several features number of occurrences of a refactoring operation in all the pareto front solutions the order of the refactoring in the sequence and developer feedback.
in fact the feedback from the developer can be to approve apply modify or reject the suggested refactoring.
this feedback is used by our innovization algorithm to guide implicitly the exploration of the pareto front to find the optimal solution that sometimes does not correspond exactly to a solution generated by nsga ii.
after number of interactions deve lopers may have modified or rejected a high number of suggested refactorings or introduced several new code changes new func tionalities etc.
.
in this case the third component of dinar is executed to update the last set of non dominated refactoring solutions using an indicator based local search based on the three objectives defined in the first component.
we selected indicator b ased local search since it is a well known quick local search algorithms that can update the solutions quickly based on new changes in the inputs.
the output of this third component is a new set of updated refactoring solutions that will be recommended to the developer one by one using the innovization component.
the second component of dinar is executed when the developers decide to stop refactoring the system and the third component is executed periodically after a high number of changes have been performed on the system.
.
solution approach we describe in the following secti ons the details of the two main interactive components of dinar.
.
.
interactive recommendation of refactorings after the multi objective optimization task described in the previous step a set of optimal re factoring solutions are generated that find a good trade off between the three objectives.
we can now analyze these solutions to investigate if there exists some common principles among all or many of these optimal refactoring solutions.
for example it is interesting to see if most of the refactoring solutions have some common features such as common refactoring operations among most of the solutions and or a specific common order in which to apply the refactorings.
such information is used to rank the suggested refactorings for developers using the following formula ref d recommender sim occurence numberoccurence numberr ranki kj k j i d ref recommende max where r i j is the refactoring operation number index in the solution vector i of solution number j. the first component of the ranking formula counts the number of occurrences of the refactoring operation r i j among all the pareto front solutions and normalizes it between and .
the second component compares the previous refactoring operations already applied by the developers feedback and the solution j. the ranking of refactorings is updated automatically after every feedback interaction from the developer.
dinar proposes three levels of interaction as describe d in figure .
the developer can check the ranked list of refactorings then he can apply modify or reject the refactoring.
if the selected action is apply then the refactoring will be automatically applied.
if the developer prefers to modify it then dinar can assist him during the modification process as described in figure .
in fact dinar proposes to the developer a set of recommendations to modify the refactoring based on the history of changes applied in the past and the semantic similarity between c ode elements classes methods etc.
.
for example if the deve loper wants to modify a move method refactoring then once the source method has been specified dinar can suggest a list of possible target classes ranked based on the history of ch anges and semantic similarity.
this is an interesting feature since developers may know which method to move but may not be certa in which the best target class is.
the same observation is valid for the other refactoring types.
another action that the developers can select is to reject delete a refactoring from the list.
after every action selected by the developer the ranking is updated based on developer feedback as described in the ranking formula where the second component is updated dynamically.
after a number of modified or rejected refactorings or the introduction of several new code changes the generated pareto 332front of refactoring solutions by nsga ii is updated since the system was modified in differe nt locations.
thus the next component of dinar is executed to update the refactoring solutions based on the new softwa re system.
the next section describes this step.
figure .
refactorings recommended by dinar.
figure .
recommended target classes by dinar for a move method refactoring to modify.
.
.
dynamic update of refactorings recommendation the input of this component is the new system after developers have made major changes to the original one and the latest set of good refactoring solutions.
the output is a new updated set of non dominated refactoring solutions that are adapted to the new system.
then the second component innovization is executed based on the output of this dynamic optimization component.
in the non interactive refactoring approaches the set of refactorings comprising the best chosen solution needs to be fully executed in order to reach the solution s promised results.
thus any changes applied to the set of refactorings such as changing or skipping some of them could de teriorate the resulting system s quality.
this represents a major limitation to the existing work since it limits the developer s in tervention to only choosing the preferred set of refactorings.
in th is context the goal of this work is to cope with the above mentioned limitation by granting to the developer the possibility to customize the set of suggested refactorings either by accepting modifying or rejecting them.
the novelty of this work is its ab ility to take into account the developer s interaction in term s of introduced customization to the existing solution by conducting a local search to locate a new solution in the pareto front that is nearest to the newly introduced changes.
as the ranking of solutions is updated with after interaction we use a quick mu lti objective local search algorithm to locate the best solution in the new ranking and then update the refactoring solutions based on the new changes performed by developers.
in fact this feature avoids executing again the nsga ii algorithm since the system to ref actor is only slightly modified from the original one.
thus the refactoring solutions will be quickly updated.
to this end we selected the indicator based local search with the same three objectives of the original problem.
this component is executed automatically to update the refactoring solutions but the developer can also select to run it at any time if it is found that the solutions should be updated.
our approach has narrowed the gap that exists between automated search based refactoring techniques and human intensive development by incor porating the search into the development process and allowi ng the developer the choice of the best recommended refactoring that best matches their coding preferences.
.
evaluation study .
research questions we defined four research questions to address in our experiments.
rq1 can dinar help developers to refactor efficiently their systems and improve their quality?
rq2 can dinar help developers to find useful refactorings quickly?
rq3 how does dinar perform compared to fully automated and manual refactoring techniques?
rq4 can dinar be useful for developers during the development of software systems?
to answer rq1 it is importa nt to validate the proposed refactoring solutions from both quantitative and qualitative perspectives.
for the qualitative va lidation we asked groups of potential users software engineers of dinar to evaluate manually whether the suggested operations are feasible and efficient in improving the quality and their maintainability objectives.
we define the metric manual correctness mc which corresponds to the number of meaningful operations over the total number of suggested operations.
the mc metric is computed after the user interaction and is given by the following equation gs refactorin proposed gs refactorin pplied coherent a mc for the quantitative validation we asked a group of developers to analyze and apply manually several refactoring types using eclipse on several code fragmen ts extracted from different systems where most of them corre spond to code smells identified using in previous studies that should be refactored .
then we calculated precision and recall scores to compare between recommended refactorings by dinar and those suggested manually operations expected operations expected operations suggested rc recall operations suggested operations expected operations suggested pr precesion to answer rq2 we evaluated the time t required by developers to refactor severa l code fragments extracted from several systems with dinar a nd without dinar.
this metric t includes all the activities from the execution time of the tool until finishing applying and validating a ll the refactorings developers reach all the objectives of refactoring session such as fixing code smells .
in addition we defined a metric prt that calculates the percentage of refactorings select ed by developers from the top 333refactorings of our recommendations list.
we define also another metric psc that corresponds to the percentage of selected code elements methods classes etc.
from the top ranked elements when developers want to modify a refactoring.
to answer rq3 we compare our approach to three other existing fully automated search based refactoring techniques kessentini et al.
ouni et al.
and harman et al.
.
we considered also in our experime nts another popular design defects detection and correction tool jd eodorant that does not use heuristic search techniques.
we used the metrics mc rc pr nf t and g for the comparison.
to answer rq4 we used a post study questionnaire that collects the opinions of developers on dinar.
.
experimental setting we used a set of well known open source java projects and one project from our industrial partner the ford motor company.
we applied our approach to four open source java projects xerces j jfreechart ganttproject and jhotdraw .
xerces j is a family of software packages for parsi ng xml.
table provides some descriptive statistics about these six programs.
table .statistics of the studied systems.
systems release classes kloc cod e smells refactorings xerces j v2.
.
jhotdraw v6.
jfreechart v1.
.
ganttproject v1.
.
jdi ford v5.
parameter setting influences significantly the performance of a search algorithm on a particular problem.
for this reason for each algorithm and for each system we perform a set of experiments using several population sizes and .
the stopping criterion was set to evaluations for all algorithms in order to ensure fairness of comparison.
the other parameters values were fixed by trial and error and are as follows crossover probability .
mutation probability .
where the probability of gene modification is .
stopping criterion evaluations.
for the indicator based multi objective local search we used iterations number of neighbors is fixed to number of genes to modify by mutation is of the solution length and the number of fails is the algorithm is stopped when there is no improvement in the fitness functions during iterations otherwise the stopping criterion is iterations .
each algorithm is executed times with each configuration and then comparison between the configurations is done using the wilcoxon test.
we used refactoring types in our experiments namely add parameter re name method encapsulate collection downcast fie ld collapse hierarchy hide method extract class interf ace method subcla ss superclass inline class method move field method pull up field method push down field method and rem ove parameter setting method.
our study involved subjects from the university of michigan and software engineers from fo rd motor company and another large software company.
subject s include master students in software engineering phd st udents in software engineering and software developers.
a ll the subjects are volunteers and familiar with java development and refactoring.
the experience of these subjects on java programmi ng ranged from to years.
we designed our study to answer our research questions.
the subjects were invited to fill a questionnaire that aims to evaluate our suggested refactorings.
.
results and discussions results for rq1 we reported the results of our empirical qualitative evaluation in figure mc .
as reported in figure the majority of the refactoring solutions recommended by dinar were approved by developers and dinar performed clearly better than all other existing approaches.
on average for all of the five studied systems of proposed refactoring operations were considered to be semantically feasible improve software quality and appear useful to the software engineers.
in addition to the qualitative evaluation we automatically evaluate our approach without using the feedback of potential users to give more quantitative evaluation to answer rq1.
thus we compare the proposed operations with some expected ones defined manually by the different groups for several code fragments extracted from the five systems where most of them represent code smells detected using previous work .
we used also ref finder to identify operations that are app lied between the program version under analysis and the next version.
figure and figure summarize our finding.
we found th at a considerable number of proposed operations an average of more than in terms of precision and recall that are already applied to the next version by software development team or suggested manually.
the recall scores are higher than precision ones since we found that the manual suggested refactorings by developers are incomplete compared to the solutions provided by dinar and this is was confirmed by the qualitative evaluation mc .
figure .
median manual correctness mc value over runs on all the five systems using the different refactoring techniques with a confidence level .
figure .
median precision pr value over runs on all the five systems using the different refactoring techniques with a confidence level .
results for rq2 we evaluated the ability of dinar to help software engineers to quickly find good refactorings.
figure evaluates the average time t required by developers to finalize a 334refactoring session using dinar.
the average time is around hour and a half including all the refactoring activities execution of nsga ii interactive refactoring with the developer and the local search.
there is a slight variation of the refactoring time required since it depends on the system to refactor.
an average of one hour and a half is reasonable since developers will use dinar during the development to maintain the quality of their systems and they can switch between modifying existing functionality and refactoring.
figure .
median recall rc value over runs on all the five systems using the different refactoring techniques with a confidence level .
we considered two other metrics prt and psc to evaluate the efficiency of dinar in ranking the refactorings and code elements to modify since this he lps the developers to find quickly good refactoring to apply.
figure shows that more than of applied or modified refactorings prt are among the top recommended ones by dinar at ev ery iteration.
in addition most of the code elements recommended to developers when they modify a refactoring are among the top also with an average of more than .
to conclude it is clear that dinar helps software engineers to quickly find good refactoring this answers rq2 .
figure .
average time t minutes required by developers to finalize a refactoring session.
results for rq3 figures and confirm the better performance of dinar compared to both fully automated and manual refactoring techniques.
figure shows that dinar provides significantly higher manual correctness results mc than all other approaches having mc scores respectively between and on average across the different systems.
the same observation is valid for the quality gain precision and recall as depicted in figures and .
figure shows that dinar can help developers to find suitable refactorings quicker than existing search based refactoring approach es and manual approaches with the notable exception of jdeodorant.
this can be explained by the fact that jdeodorant is not usi ng heuristic search but proposing a template solution to fix certain ty pes of code smells.
however the time required to use dinar is s till comparable to jdeodorant and is able to provide more effective refactoring solutions.
figure .
median value of refactorings prt and code elements selected from the top5 on all the five systems.
results for rq4 most of the participants mention that dinar is faster than manual refactoring since they spent a long time during manual refactoring to find the locations where the refactorings should be applied.
for example developers spend time in applying extract class to find the methods to move to the new created class or when a pplying move method then it takes time to find the best target class by manual exploration of the source code.
thus the developers liked the functionality of dinar that helps them to modify a refactoring and find quickly the right parameters based on th e recommendations.
furthermore refactorings may affect several locations in the source code which can be a time consuming ta sk to perform manually but can be performed in an instant using dinar.
the participants found dinar helpful for both floss refactoring to maintain a good quality of the design and also root canal refactoring to fix some quality issues such as code smells.
the developers justify their conclusions by the following interesting features in dinar a the list of recommended refactorings helps them to choose the desired refactoring very quickly b dinar offers them the possibility to modify the source code to add new functi onality while refactoring since the list of recommendations are updated dynamically.
so developers can easily switch between both activities refactoring and modifying the source code to augment or amend existing functionality c dinar allows developers to access all the functionality of the ide e.g.
eclipse .
d the suggested refactorings by dinar can fix code smells root canal refactoring or improve some quality metrics floss canal refactoring due to the use of the multi objective approach.
another important feature that th e participants mention is that dinar allows them to take advantage of using multi objective optimization for software refactoring without the need to learn anything about optimization and exploring explicitly the pareto front to select one ideal solution.
the implicit exploration of the pareto front in an interactive fashion represents an important advantage of dinar along with the dynamic update of the recommended list of refactoring using innovization.
in fact developers had a lot of difficulties in using the multi objective tool of ouni et al.
to explore the pareto front to find a good refactoring solution.
in addition they did not appreciate the long list of refactorings suggested in since they want to take control of modifying and rejecting some refactorings.
in addition the 335validation of this long list of re factorings is time consuming.
thus they appreciate that dinar suggests refactoring one by one and updates the list based on developer feedback.
.
threats to validity some threats need to be considered when interpreting our study results.
the first threat is the limited number of subjects and evaluated systems participants and systems which externally threatens the generalizability of our results.
in addition we cannot conclude that dinar can perform very well also when helping developers since our study was limited to the use of types of refactorings and evaluating ty pes of code smells.
future replications of this study are necessary to confirm our findings.
the second threat is related to the variation of correctness and speed between the different groups when using dinar and other tools such as jdeodorant.
in fact dinar may not be the only reason for the improved performance because the subjects have different programming skills and familiarity with refactoring tools.
however deve lopers were not assigned to groups randomly but according to their programming experience to reduce the gap between the different groups.
anot her threat concerns the data about the actual refactorings of the studied systems.
in addition to the documented refactorings we use ref finder which is known to be efficient.
indeed ref finder was able to detect refactoring operations with an average recall of and an average precision of .
to ensure the precision we manually inspect the refactorings found by ref finder by randomly selecting a set of detected changes and evaluate them by the participants of our experiments.
.
conclusion and future work we proposed in this paper a novel interactive recommendation tool called dinar for software refactoring that dynamically adapts and suggests refactorings to developers based on their feedback and introduced code changes.
to evaluate the effectiveness of dinar we conducted a human study with software developers who evaluate d the tool and compared it with the state of the art refactoring techniques.
our evaluation results provide strong evidence that dinar improves the applicability of software refactoring and propos es a novel way for software developers to refactor their systems.
future work should validate dinar with additional refactoring types new systems a nd code smell types in order to draw conclusions about the general applicability of our methodology.
we will also compare dinar with other refactoring techniques .
furthermore in this paper we only focused on the recommendation of refactorings.
we are planning to extend the approach by automating the test and verification of applied refactorings.
in addition we will consider the importance of code smells during the correction step using previous code changes class complexity etc.
another future research direction related to our work is to adapt our interactive refactoring recommendation tool to several other software engineering problems such as software remodularization change detection and the next release problem.