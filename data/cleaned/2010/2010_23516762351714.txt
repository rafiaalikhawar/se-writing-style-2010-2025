generating model transformation rules from examples using an evolutionary algorithm martin faunes diro universit de montr al montreal canada faunescm iro.umontreal.cahouari sahraoui diro universit de montr al montreal canada sahraouh iro.umontreal.camounir boukadoum univ.
de qu bec montr al montreal canada mounir.boukadoum uqam.ca abstract we propose an evolutionary approach to automatically generate model transformation rules from a set of examples.
to this end genetic programming is adapted to the problem of model transformation in the presence of complex input output relationships i.e.
models conforming to metamodels by generating declarative programs i.e.
transformation rules in this case .
our approach does not rely on prior transformation traces for the model example pairs and directly generates executable many to many rules with complex conditions.
the applicability of the approach is illustrated with the well known problem of transforming uml class diagrams into relational schemas using examples collected from the literature.
categories and subject descriptors d. .
miscellaneous general terms algorithms keywords model transformation by example genetic programming .
introduction the success of model driven engineering mde depends heavily on automating model transformation mt .
mt allows transforming a source model that represents a system from some point of view or at some level of abstraction into a target model that asserts facts of the same system but from another point of view or at another level of abstraction using a transformation program typically consisting of rules .
the source and target models must conform to corresponding source and target metamodels which define the point of view and the level of abstraction to use when expressing models for specific systems.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september u7 essen germany copyright acm ... .
.in recent years considerable advances have been made in modeling environments and tools.
from the point of view of the transformation infrastructure a large effort has been made to define languages for expressing transformation rules and thus make the writing of transformation programs easier.
however having a good transformation language is only one part of the solution the most important part is to define gather the knowledge on how to transform any model conforming to a particular metamodel into a model conforming to another metamodel.
for many problems this knowledge is incomplete or not available.
this is the motivation behind the research on learning transformation rules.
the idea of model transformation by example mtbe consists of deriving transformation programs by generalizing concrete transformations found in a set of prototypical examples of source and target models.
initially proposed by varr o in this idea is gaining popularity with many recent contributions e.g.
.
these approaches solve the problem of rule derivation only partially.
some of them require detailed mappings between the examples of source and target models which are often difficult to provide.
others cannot derive rules that test more than one construct in the source model and or produce more than one construct in the target model many to many rules a requirement in many transformation problems.
a third limitation is the inability of some approaches to produce complex rule conditions to define precise patterns to search for in the source model.
finally some approaches produce abstract non executable rules which makes it difficult to validate them empirically.
this paper describes an approach for example based rule generation.
this apporach does not require detailed mappings between models and produces executable many tomany rules with complex conditions thus allowing coverage of a large spectrum of transformations between pairs of metamodels.
to build this approach genetic programming gp is adapted to the particular problem of mtbe.
gp allows evolving programs in order to improve their ability to approximate a behavior that is defined by a set of valid pairs of inputs outputs.
in the context of mtbe the programs are transformation rule sets and the behavior is defined by example pairs consisting of source and corresponding target models.
the approach was evaluated on the well known transformation problem of uml class diagrams into relational schemas.
the obtained quantitative and qualitative results show that almost all the involved constructs are correctly transformed.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.
approach model transformation by example mtbe can be summarized as follows considering a set of transformation pairs source model target model given as examples derive a set of transformation rules that would transform an arbitrary source model into its corresponding target model.
for instance given a set of transformations of uml class diagrams into corresponding relational schemas derive a set of rules that would transform anydiagram into a schema.
regardless of its nature a generic rule derivation process takes two inputs the source and target metamodels and the transformation example pairs.
the rule derivation process could be simplified at the cost of providing extra inputs e.g.
detailed mappings traces between source and target example models or limiting the types of transformations that can be learned e.g.
no many to many transformation rules.
in the first case one has to make assumptions about the availability of the extra inputs which could be unrealistic in many cases.
similarly when restricting the types of transformations that can be derived the mtbe approach may become inapplicable to important pairs of metamodels.
existing mtbe approaches do not produce complex transformations and or require detailed mappings in the examples.
this work proposes a novel mtbe solution that does so.
the solution derives transformation rules without the need for transformation traces it produces many to many rules with complex and various types of conditions finally the derivation process is guided by the ability of the generated rules to successfully transform the provided examples which guarantees that they are executable with the right control sequence.
the reminder of this section presents and discusses the proposed approach.
.
overview because transformation rules are declarative programs mtbe can be seen as an automated process to derive such programs.
this observation motivates adapting genetic programming gp to the mtbe problem.
gp is a technique widely used to derive mostly imperative programs by specifying a program s behavior from a set of inputs and expected outputs examples.
the initial motivation of gp is that it is easier to give examples of inputs outputs than to manually write a program which is the case of many transformation problems.
the derivation process is done by iteratively improving an initial population of randomly created programs i.e.
by reproducing the fittest programs.
the reproduction is made by means of genetic operators similar to the ones observed in nature.
before starting the gp cycle the user must have a set of example pairs describing the expected program behavior in the form of inputs outputs .
the user must also define a way to encode and create the initial population of random programs.
finally a mechanism is needed to run the programs on the provided inputs and compare the execution results with the expected outputs.
this is typically done by defining a fitness function that evaluates a distance or error between the produced and expected outputs.
the first step of a gp cycle consists of creating the initial population of programs.
then the programs of the current population are run on the input examples to produce the expected outputs to evaluate their fitness.
if the current population satisfies a stop criterion e.g.
a predefined number of iteration cycles or a target fitness value the best obtained program isreturned otherwise the fittest programs are selected for reproduction.
although the selection process favors the programs with the highest fitness values it includes a random part to allow for novelty.
reproduction involves three families of operations i elitism to directly add top ranked programs to the new population ii crossover to create new programs by combining the genetic material from old ones and iii mutation to alter an existing program by randomly adding new genetic material.
once a new population is created it replaces the current one and the next iteration of the gp cycle takes place.
thus the programs progressively changes to better implement the specified behavior.
.
genetic programming adaptation gp applies mostly to imperative programs generally represented by trees and takes input output examples as simple structures.
gp must be adapted to the mtbe problem since the goal is to produce declarative programs rules and input output examples with complex structures models conforming to metamodels are used.
typical transformation problems require a set of transformation rules to cover all the patterns in the source models.
a program pis encoded accordingly as a set of transformation rules p r1 r2 ... r n .
each transformation rule ri is in turn encoded as a pair ri sp tp wherespis the pattern to search for in source models and tpis the pattern to instantiate when producing the target models.
the source pattern spis a triple sp gsc sjc g wheregsc is a set of generic source constructs sjc is a set of join conditions and gis a guard.
a generic source construct is the specification of an instance of a construct type that has to be matched with concrete constructs in the source model.
each generic construct has the properties of its construct type in the source metamodel.
when matched with a concrete construct from the source model these properties take the values of the latter.
join conditions sjc allow to specify a source pattern as a model fragment i.e.
a set of interrelated constructs according to the metamodel.
the guard gdefines a complex condition on the properties of the generic source constructs.
it is encoded as a binary tree containing elements from both terminal t and primitive i sets.tis the union of the properties of the constructs in gsc and a set of constants cthat depends on the property definition domains.
the set of primitives i is composed minimally of logical operators and comparators i and or not ... .
other operators such as arithmetic or string operators could be added to test values derived from the basic properties.
the target pattern tpis a tripletp gtc b tjc wheregtc bandtjc represent respectively a set of generic target constructs a set of binding statements and a set of join statements.
a generic target construct specifies a concrete construct to create in the target model when the rule is fired.
the set of bindings bdetermines how to set the property values of the created constructs from the property values of the constructs that match the source pattern.
finally the join statements allow to connect the created constructs to form a fragment in the target model.
for the initial population a number of rule sets nrs is created nrs is a parameter of the approach .
the number of rules to create for each rule set is selected randomly from a given interval.
for each rule we define a random procedure to create the source and target patterns.
to cre 251ate a source pattern sp a generic construct set gcs of a given size is selected from the source metamodel.
this is accomplished by a random walk through the metamodel such that each time a construct type is reached a corresponding generic construct is added to gcs .
the set of join conditionssjc is defined as the links between constructs in the random walk.
to define a random guard gto complete the source pattern a tree is created by randomly mixing elements from the terminal set t i.e.
properties of the selected constructs and constants consistent with their types and elements from the primitive set pof operators.
the creation of the tree is done using a variation of the grow method defined in .
the creation process must ensure the type consistency between the operations and the operands.
the creation of a target pattern tpfollows the same random walk principle as for the source pattern but with the target metamodel as the walked through structure.
this step allows creation of the generic target constructs and the join statements between them.
the binding statements are generated by randomly assigning elements in the terminal settto the properties of the generic target constructs that were not set by the join statements.
the random property assignment is done according to the property types.
during the evolution process all the generated rules are translated into jess a fact based rule language and executed using its rule engine .
as the target model is created by means of fact assertions it is possible for the same construct to be created several times by different rules.
for example if a class c1 is at the origin destination of many associations each time a rule that transforms an association is fired a table is created for c1.
however as the creations consist of asserting the same fact the table is created only once.
this particularity of jess is an advantage in this work since it helps in rule execution control.
there is no need to check if a construct already exists before executing a rule.
in gp the fitness function usually measures the difference between the produced and the expected outputs from a program.
accordingly the fitness function in this work measures the difference between the target models produced by a rule set and the expected ones as indicated in the example model pairs.
the fitness of a rule set is defined as the average of the transformation correctness of the model example pairs.
this average could be weighted by the number of constructs in the target models.
comparing a produced model with the expected one to evaluate the transformation correctness i.e.
comparing two graphs with typed nodes is a difficult task.
considering that in the proposed gp based rule derivation the fitness function is evaluated for each rule set and population iteration and for each example pair this cannot afford exhaustive graph comparisons.
instead a quick and efficient graph kernel gis used to compare the target model min the example pair and the target model m primeproduced by the rule set when transforming the source model of the same pair.
gis defined as follows g m m prime gf m m prime gn m m prime gfcalculates the percentage of constructs in mandm prime that exactly match.
two constructs exactly match if they are of the same type and have equal values for all their properties.gnmeasures the percentage of constructs that were not exactly matched nor by type matched.
a construct inm respectively in m prime have a type match if there exists a construct not exactly matched with the same type in m prime respectively m .
the percentages could be calculated regardless the construct types or as a weighted average by construct type.
in this last case construct types with few or lot off instances are equally considered.
in gp a population of programs is improved by applying genetic operators mutation and crossover .
these operators are defined according to the problem to solve and should guarantee that the derived programs are syntactically and semantically valid.
before applying the genetic operators the programs are selected depending on their fitness values.
some of them could be duplicated directly into the new population without reproduction i.e.elitist strategy.
in this work roulette wheel selection is used.
this technique assigns to each rule set in the current population a probability of being selected for reproduction that is proportional to its fitness.
this selection strategy favors the fittest rule sets while still giving a chance of being selected to the others.
the crossover operation consists of producing new rule sets by combining the existing genetic material.
it is applied with high probability to each pair of selected rule sets.
after selecting two parent rule sets for reproduction two new rule sets are created by exchanging parts of the parents i.e.
subsets of rules.
for instance consider the two rule sets p1 r11 r12 r13 r14 having four rules and p2 r21 r22 r23 r24 r25 with five rules.
if cut points are randomly set to for p1and forp2 the offspring obtained are rule set o1 r11 r12 r24 r25 and rule set o2 r21 r22 r23 r13 r14 .
because each rule is syntactically and semantically correct before the crossover this correctness is not altered for the offspring.
after crossover the obtained offspring could be mutated with a small probability.
mutation allows the introduction of new genetic material while the population evolves by randomly altering existing rules or adding new ones .
for the transformation problem mutation could occur at the rule set level or at the single rule level.
each time a rule set is randomly selected for mutation a mutation strategy is also randomly picked.
two mutation strategies are defined at the rule set level adding a randomly created rule anddeleting a randomly selected rule .
at the rule level many strategies are possible.
for a randomly selected rule one could add or delete a generic construct in the source pattern change the condition tree add or delete a generic construct in the target pattern and change the binding between source and target constructs.
these strategies are implemented preserving the syntactic and semantic validity of the produced rules.
.
evaluation to illustrate the ability of our approach to derive transformation rules from examples let us consider the transformation of uml class diagrams into relational schemas.
this transformation is not trivial and requires many to many rules with conditions on the properties values.
the examples used in this evaluation were collected from published material.
examples were selected with the goal of covering different application domains in order to simulate real situations.
the average size of the class diagrams was constructs the smallest diagram having constructs and the largest .
to test the proposed approach leave one out cross validation was used.
the rule derivation process was executed times using each time a different example for testing and252the remaining ones as examples.
for each execution the class diagram of the testing example was transformed using the obtained rules and the produced relational schema was manually checked with respect to the schema given in the example.
the manual checking consisted of matching constructs of the produced schema with those of the expected one and vice versa.
then each construct was classified as fully matched fm partially matched pm or not matched nm .
figure show the results of the leave one out runs.
these results are good in terms of fm and average for nm .
similar scores were obtained with and without considering construct types in the calculation of g. the percentage of matched constructed could be improved if we increase the size of the population and or the number of generations.
for instance we obtained an fm of by increasing the size of the initial population.
for a sanity check we compared these results with those obtained by randomly generating a large number of rule sets and by selecting the best set.
the difference is statistically significant for both fm p .
and nm p .
.
upon examining the generated rules we noticed that frequent situations are generally well captured.
the generated rules correctly transformed classes into tables attributes into columns and unique attributes into primary keys.
transforming associations is often impaired by cardinality problems.
for instance in the case of many to many associations a rule was found to create a table for the association which is the right transformation.
however in its guard rather than testing that both cardinalities were greater than one the rule tested the cardinalities for equality instead.
this happened because the examples contained a large number of many to many associations and very few to associations.
consequently the error of generating tables for one to one associations was not frequent enough to heavily penalize the fitness function.
for to many associations a rule was found that generates a foreign key with the wrong table