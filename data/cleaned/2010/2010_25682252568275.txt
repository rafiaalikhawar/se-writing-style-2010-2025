using dynamic analysis to generate disjunctive invariants thanhvu nguyen computer science university of new mexico new mexico usa tnguyen cs.unm.edudeepak kapur computer science university of new mexico new mexico usa kapur cs.unm.edu westley weimer computer science university of virginia virginia usa weimer cs.virginia.edustephanie forrest computer science university of new mexico new mexico usa forrest cs.unm.edu abstract program invariants are important for defect detection program veri cation and program repair.
however existing techniques have limited support for important classes of invariants such as disjunctions which express the semantics of conditional statements.
we propose a method for generating disjunctive invariants over numerical domains which are inexpressible using classical convex polyhedra.
using dynamic analysis and reformulating the problem in nonstandard max plus and min plus algebras our method constructs hulls over program trace points.
critically we introduce and infer a weak class of such invariants that balances expressive power against the computational cost of generating nonconvex shapes in high dimensions.
existing dynamic inference techniques often generate spurious invariants that t some program traces but do not generalize.
with the insight that generating dynamic invariants is easy we propose to verify these invariants statically usingk inductive smt theorem proving which allows us to validate invariants that are not classically inductive.
results on di cult kernels involving nonlinear arithmetic and abstract arrays suggest that this hybrid approach e ciently generates and proves correct program invariants.
categories and subject descriptors d. .
software program veri cation validation f. .
specifying verifying and reasoning about programs invariants f. .
mathematical logic mechanical theorem proving general terms algorithms experimentation veri cation theory permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.keywords program analysis static and dynamic analyses invariant generation disjunctive invariants theorem proving .
introduction program invariants are logical properties that hold at certain program locations.
invariants are important for defect detection e.g.
program veri cation e.g.
and even program repair e.g.
.
invariants can be found using static or dynamic program analyses.
static reasoning about source code can generate invariants without executing the program but is often expensive and therefore considers relatively simple forms of invariants.
in contrast dynamic analyses infer invariants from execution traces .
the quality and completeness of these traces determine the accuracy of the inferred invariants.
as a result dynamic analyses often produce spurious invariants that match some observations but are not sound with respect to general program behavior.
however dynamic analyses are generally more e cient and can be targeted to discover more complex forms of invariants.
existing invariant inference techniques tend to focus on conjunctive polynomial and convex invariants.
polynomial invariants which are relations among polynomials over numerical program variables are particularly important for many applications.
as one example polynomial inequalities are used to represent pointer arithmetic and other memory related properties .
inspired by abstract interpretation approaches in static analysis recent dynamic analysis methods use geometric shapes to represent polynomial invariants .
although these convex shapes capture conjunctions of polynomial relations they cannot represent disjunctive program properties.
disjunctive invariants which represent the semantics of branching are more di cult to analyze but crucial to many programs.
for example after if p fa gelsefa g neither a nor a is an invariant but p a p a is a disjunctive invariant.
disjunctive invariants thus capture path sensitive reasoning such as those found in most sorting and searching tasks as well as functions like strncpy in the c standard library.
existing approaches thus su er from the twin problems of soundness and expressive power sound static approaches are too ine cient to target complex and expressive invari permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
ants while e cient dynamic approaches often yield spurious invariants.
for example interproc a popular static analyzer that employs di erent abstract domains and astr ee a successful program analyzer used for verifying the absence of run time errors in airbus avionic systems consider only conjunctive invariants and thus lack expressive power.
dynamic convex hull methods capture complex structures but can yield many spurious invariants.
in fact such approaches are not used by default because of false positive issues and instead users are asked to specify invariant shapes manually.
we address both expressive power and soundness with a hybrid technique combining a novel method for inferring expressive invariants dynamically with a static approach for validating invariants by formal proof.
at the heart of our dynamic analysis is the insight that disjunctive invariants which are not classically convex can be reformulated in a non standard algebra.
once reformulated inference proceeds using a variant of existing geometric hull approaches.
our static veri cation technique rests on the observation that many practical program invariants are k inductive but not classically inductive .
that is they can be proved by considering kbase cases with an inductive step that has access to the kprevious instances.
our hybrid algorithm leverages the fact that it is easier to infer complex candidate invariants dynamically and verify them statically.
we build convex hulls for a special type of nonconvex polyhedra called max plus to capture certain disjunctive information.
a polyhedron using max plus algebra is a set of relations of the form max c0 c1 v1 c n vn max d0 d1 v1 d n vn over program variables viwith coe cients ci di2r f 1g .
for instance the max plus polyhedron max x y max z encodes the disjunctive information x y y z x y x z or simply y z x z. max plus polyhedra are the analogues of classical convex polyhedra in the max plus algebra which operate over the reals and with max as the additive and as the multiplicative operator .
dually we also consider min plus polyhedra and combined max and min plus relations capturing if and only if information.
we augment our dynamic analysis with a theorem prover based on k induction and smt solving to verify candidate invariants.
proven results are true invariants of the program.
iterative reasoning using k induction allows us to prove invariants that cannot be proved using standard induction and in some cases to prove results that are not k inductive.
moreover recent advances in smt solving e.g.
allow for e cient analysis over formulas in more expressive logical theories such as the theory of nonlinear arithmetic.
in summary the paper makes the following contributions a new algorithm to infer certain disjunctive invariants dynamically by constructing nonconvex max and minplus polyhedra over observed traces.
the de nition of a novel restricted class of max and min plus invariants called weak invariants that strike a balance between expressive power and computational complexity.
weak invariants express useful max and min plus relations and can be computed e ciently.
kip a theorem prover based on iterative k induction and smt solving to verify dynamically inferred invariants against program source code.
when parallelized kip e ciently and correctly processes many complex and potentially spurious invariants.
an experimental evaluation on di cult kernels involving nonlinear arithmetic and abstract arrays.
our approach is e cient both at learning disjunctive invariants and at proving them correct.
.
motivating example we illustrate our methods with a simple example program containing a disjunctive invariant.
void ex1 int x int y if x y x y while x if x y y x x assert y xy ...... ...... 11xy figure program ex1 the observed trace on input x and the geometric representation of its invariant x y x x y at location l. figure shows program ex1 adapted from gulwani and jojic .
the program ex1initializes yto and ensures x y then enters a loop that increments yconditionally on the value of x. figure also shows the trace values for x yat location lon the input x and it depicts the nonconvex region a bent line covering these trace points.
validating the postcondition y requires analyzing the semantics of the loop by identifying the invariants at l. from the given trace existing tools such as daikon and dig can generate only conjunctive invariants such as x y y x these relations are not expressive enough to capture the disjunctive dependency between xandy and they fail to prove the desired postcondition.
by building a max plus polyhedra over the trace points in figure we obtain relations that simplify to x y x y x y x x y note that the last relation is disjunctive.
next we verify these candidate invariants against the source code figure using k induction and remove the spurious relations x andx y .
the rest are true invariants at l. we note that the invariant y xis not directly k inductive fork .
however by using the previously proven results y and x y x x y as lemmas our prover also veri es this relation y x. further the prover shows that xis redundant i.e.
implied by other proved results and can be removed.
the remaining invariants are y x y609 x y x x y intuitively the code in figure has two phases either x at which point the ifinside the while loop is not true and y remains or xis between and at which point the ifinside the while loop is true and y xbecause they are both incremented .
the inferred invariants are mathematically equivalent to the encoding of that intuitive explanation x y x y x they are also the precise invariants of the loop and can prove the postcondition y .
this example required that the dynamic analysis be expressive and e cient enough to generate disjunctive invariants and it required that the static prover be expressive and e cient enough to remove spurious invariants and prove the others correct.
in the remainder of the paper we describe these methods in detail.
.
invariant inference algorithm this section describes our algorithm for inferring disjunctive invariants from dynamic traces.
we consider the construction of max plus weak max plus and min plus invariants.
we begin in section .
with a discussion of existing approaches to inferring convex geometric invariants.
we then explain how to apply such techniques to the inference of disjunctive invariants by reformulating the problem in the max plus algebra in section .
.
in section .
we formalize that intuition and present our algorithm pseudocode.
we then introduce in section .
an e cient and expressive restricted subclass which we call weak max plus invariants.
in section .
we describe the dual min plus invariants.
finally in section .
we analyze the guaranteed properties of our algorithm.
.
inferring convex geometric invariants figure a a set of points in 2d and its approximation using a b zone and c polygon region.
we review the problem of learning convex geometric invariants.
figure visualizes these invariants showing 2d points panel a and two examples of increasingly precise but also increasingly expensive convex shapes containing those points panels b and c .
the inferred invariants correspond to the relations de ning the enclosing shapes given the trace points from panel a. the dynamic analysis tool dig generates di erent forms of polynomial invariants by building geometric shapes such as those shown in figure enclosing the trace points.
dig rst determines if the points lie in a simple hyperplane.
if such a plane does not exist dig then computes a convex hull over the trace points.
such hulls are bounded convex polyhedra each polyhedron is enclosed by a nite number of facets and contains the line joining any pair of its points.
the half space representation of such a polyhedron is a set of nite linear relations of the form c1v1 cnvn c0.
the facets of the polyhedron corresponding to the solutions ofthe set of linear inequalities give a set of candidate inequality invariants among the variables vi.
figure 2c shows a 2d polyhedron with ve facets represented by ve linear inequalities.
for e ciency dig also considers more restricted forms of inequalities representing simpler geometric shapes such as the six edged zone relation in figure 2b and the eight edged octagon relation .
to support nonlinear relations dig lifts its analysis to terms representing nonlinear polynomials over program variables.
for example rather than analyzing variables v1and v2directly relations can be constructed among the terms t1 v1 t2 v1v2 note that t2is nonlinear .
thus equations such as t1 t2 can be generated which represents a line over t1 t2but a hyperbola over v1 v2.
when additional traces are available ltering step removes spurious invariants .
these existing approaches lack the expressive power to learn disjunctive invariants a gap that we address in the following subsection by reformulating in the max plus algebra.
.
max plus invariants as discussed earlier programs containing loops or conditional branches are not adequately modeled by purely conjunctive invariants.
figure depicts the nonconvex region de ned by the loop invariant x y x x y in our program ex1.
such disjunctive information cannot be expressed as a conjunction of polynomial relations including octagon or even general polyhedron forms.
although disjunctive invariants can be simulated using polynomials of higher order e.g.
a 0 b is equivalent to a b this approach generates terms with impractically high degree and computational cost especially when there are more than two disjunctions.
we thus require a fundamentally di erent approach.
to model disjunctive invariants we use formulas representing max plus polyhedra i.e.
nonconvex hulls that are convex over a max plus algebra.
max plus formulas allow disjunctions of zone relations inequalities of the forms v candv1 v2 c. formally max plus relations have the structure max c0 c1 v1 c n vn max d0 d1 v1 d n vn where viare program variables ci diare real numbers or and max t0 t m returns the largest ti.
that is max x y ifx y thenxelsey.
we note that max v0 v1 v2 v n max v0 v2 v n and thus we often drop max arguments.
the max operator allows max plus formulas to encode certain disjunctions.
for example the max plus relation max x y max x y i.e.
max x max y encodes the disjunction x y x x y ory 5 x y. max plus relations are analogous to polyhedra relations but use max instead of the of standard arithmetic.
these operators allow max plus relations to form 1for presentation purpose we abbreviate max plus notations e.g.
max x y zfor max x y z max x y z and x for max x y max x y .
an equality is also used to express the conjunction of two inequalities e.g.
max x y z for max x y z z max x y .610geometric shapes that are nonconvex in the classical sense.
for example the max plus relation x y y represents a nonconvex region consisting of two lines x yand y .
moreover the structure of max plus relations produces a relatively peculiar geometric shape.
figure 3a shows the three possible shapes of a max plus line segment in 2d.
in general dimensions two points are always connected by lines that run parallel perpendicular or at a degree angle to all the coordinate axes.
a max plus polyhedron consists of these connections and the area surrounded by them.
figure 3b depicts a max plus polyhedron represented by a set of four lines connecting the four marked points.
although a max plus polyhedron is not convex in the classical sense it is convex in the max plus sense using max plus algebra.
that is it contains any max plus line segment between any pair of its points.
this allows us to generate max plus polyhedra over a nite set of traces as shown in figure 3b.
where there is no confusion we shorten max plus resp.
min plus to max resp.
min when describing polyhedra formula or relations.
figure a three possible shapes of a max plus line segment max x a b y top max y a b x right max x a y b left and b a max plus convex hull built over four points using these line segments.
a bounded max polyhedron can have nitely many facets representing max relations e.g.
even a 2d complex polygon may contain multiple edges.
thus a disjunctive formula representing a max polyhedron has no xed bounds on the number of disjuncts used.
however computing a max polyhedron over npoints in ddimensions is computationally expensive o nd similar to classical polyhedron computations.
next we propose heuristics to avoid generating these high dimensional polyhedra in section .
.
section .
then introduces a simpler form of max relations that strikes a reasonable compromise between e ciency and precision.
.
dynamically inferring max plus invariants input set of variables v set of traces x max degree d output setsof polynomial inequalities t genterms v d p genpoints t x h createmaxpluspolyhedron p s extractfacets h return s figure high level algorithm for nding disjunctive polynomial inequalities.
we infer max invariants dynamically using a procedure similar to that used for classical polyhedra invariants.
figure outlines the main steps of the algorithm using terms to represent program variables instantiating points from terms using input traces creating a max polyhedron enclosing the points and extracting its facets to represent max relations among terms.because program invariants often involve only a small subset of all possible program variables we employ heuristics to search iteratively for invariants containing all possible combinations of a small xed number of variables.
we propose to consider max relations over triples of program variables i.e.
max c0 c1 v1 c2 v2 c3 v3 max d0 d1 v1 d2 v2 d3 v3 representing max polyhedra in three dimensional space.
our algorithm also supports nonlinear max relations by using terms to represent nonlinear polynomials over variables.
however the number of possible terms is exponential in the number of degrees and thus we target linear max relations by default for e ciency.
the user of dig can change the parameter din figure to generate higher degree relations e.g.
d for quadratic relations and can also manually de ne terms to capture other desirable properties.
for example a user with knowledge about the shape of the desired invariants might hypothesize a spherical shape max c0 c1 x2 c2 y2 max d0 d1 x2 d2 y2 .
with that as input the algorithm searches for that exact shape i.e.
computes the coe cients ci di from the polyhedron built over the trace points of the terms representing the nonlinear polynomials x2andy2.
example we illustrate the algorithm by deriving the invariant x y x x y at location lin program ex1in figure .
the trace values for x yin figure form a set of eleven points e.g.
the rst is .
we then compute a max polyhedron over these points.
the halfspace representation of that polyhedron consists of the max relations x y x y max x y the conjunction x y x max x y which forms the nonconvex region in figure is logically equivalent to the invariant x y x x y .
note that x and x y are spurious relations because xhas no lower bound.
additional traces such as running ex1onx would remove these spurious invariants.
more generally the static technique in section formally veri es candidate invariants and removes spurious results.
.
weak max plus invariants we introduce and de ne a weaker form of max relations that retains much expressive power but avoids the high computational cost of computing a max polyhedron.
our approach is inspired by earlier methods for nding simpler forms of inequalities e.g.
zone and octagon to avoid the cost of nding general polyhedra .
to the best of our knowledge this is the rst attempt to consider a simpler form of max inequalities for program analysis.
we de ne a weak max relation to be of the form max c0 c1 v1 c k vk vj d vj d max c0 c1 v1 c k vk where viare program variables ci2f0 1g dis a real numbers or and kis a constant e.g.
k .
unlike611general max relations weak max relations have some convenient properties .
they restrict the values of the coe cients citof0 1g .
the general form allows ci2r f 1g .
.
they x the number of variables kto a small constant.
the general form allows nvariables.
.
they allow only one unknown parameter d. the general form allows d0 d n. weak max relations are thus a strict subset of general max relations.
for example the weak max form cannot represent general max relations like max x y zor max x y max z w but it does support zone relations like x y x yand disjunctive relations like max x y zand max x y .
geometrically weak max relations are a restricted kind of max polyhedra.
while general max line segments have the possible three shapes shown in figure weak max line segments have only two shapes represented by the formulas max x b yand max y b x. that is weak max shapes include only lines that run in parallel or at a degree angle.
lines with a perpendicular shape cannot occur because their formula max x y is inexpressible using the weak max form.
the advantage of these restrictions is that they admit a straightforward algorithm to compute the bounded weak max polyhedron over a set of nite points in kdimensions.
the algorithm rst enumerates all possible weak relations overkvariables and then nds the unknown parameter d in each relation from the given points.
the resulting set of relations is the half space representation of the weak max polyhedron enclosing the points.
note that this algorithm does not apply to the general max form because the coe cients ciare not enumerable over the reals.
moreover the problem becomes more complex when more than one unknown is involved.
for instance it is nontrivial to compute the unknowns c din the max relation max c x y dbecause the values of candddepend on each other.
example we illustrate this algorithm by nding the weak max polyhedron enclosing the points f x1 y1 xn yn gin 2d.
first we enumerate relations of the weak max form by instantiating the coe cients cioverf0 1g .
for the form max c0 c1 x c y x dwe obtain eight max relations two choices each for three coe cients max x y x d max x x d x d the eight additional max relations for each of the other three forms max c0 c1 x c y y d x d max c0 c1 x c y y d max c0 c1 x c y are obtained similarly.
redundant relations can be removed e.g.
max y x implies max x y x .
next we compute the parameter din each of the obtained relations using the given points f x1 y1 xn yn g. for instance max y x dhasd min max yi xi andx d max y has d max max yi xi .
the resulting relations form an intersecting region that represents a bounded weak max polygon over the given points.in general the number of weak max relations enumerated overkvariables is o k2k and the time to nd the single parameter din each relation is linear in the number of points.
thus the complexity for computing a weak max polyhedron overnpoints in kdimensions is o n2k .
the complexity is therefore polynomial in the number of points when kis a constant and is exponential in the number of dimensions when kis not xed.
note that even this worst case is still smaller than o nd the complexity of building a general max polyhedron.
importantly the number of facets of a weak max polyhedron has a xed upper bound for each k. for example k has at most facets.
this is thus more manageable than the number of facets of general max polyhedron which can be arbitrarily nitely many.
.
min plus invariants we also consider min relations of the form min c0 c1 v1 c n vn min d0 d1 v1 d n vn where viare program variables and ci di2r f1g .
similar to its max dual a min polyhedron is a formed by the intersection of nite min lines.
however min and max relations describe di erent forms of disjunction information and have di erent geometric shapes.
for instance the relation min x y zencodes the disjunction x y x z x y y z that is not expressible as a max relation.
figure depicts the min version of the shapes in figure .
figure a three possible shapes of a min plus line segment and b a min plus polyhedron built over four points.
a conjunction of max and min invariants can describe information that is inexpressible using either max or min relations alone.
consider program ex2in figure which has the invariant y b at location l. by building max and min polyhedra over the traces given in figure we obtain b max y b and b min y .
given b the max relation implies b y and the min relation implies b6 y .
these disjunctions are mathematically equivalent to the i condition y b .
int ex2 int x int y b if x y x else y x b y return b x y b figure program ex2and its trace data at location lfor several input values.612dually we also de ne weak min relations max c0 c1 v1 c k vk vj di vj di max c0 c1 v1 c k vk where viare program variables kis a constant ci2f0 1g anddi2r f 1g .
the algorithm for computing weak min polyhedra over nite points is similar to the one for weak max polyhedra and has equivalent theoretical complexity as given in section .
.
.
algorithmic analysis we analyze important properties associated with our algorithm.
there are two key concerns the production of spurious invariants that underapproximate general program behavior too strong relations that hold only for some inputs and invariants that overapproximate2general program behavior weak invariants that may not be useful .
by building max or min polyhedra over trace points which are convex in the corresponding max or min algebra our algorithm guarantees that it produces candidate invariants that always underapproximate or are equivalent to program invariants expressible under the max or min plus forms.
the proof of this claim follows from the facts that the given set of observed traces is a subset of all possible program traces and our constructed max polyhedron over a set of points is the smallest max polyhedron represented by those points.
the proof details follow those of the underapproximation argument for inferring classically convex shapes .
thus if the program invariants are expressible in our system our algorithm never overapproximates.
this underapproximation property is important because its violation a candidate invariant strictly overapproximating the program invariant indicates a bug in the subject program.
for example if the expected invariant is t but our algorithm discovers t then the underapproximation property guarantees the value t exists in the observed traces.
the trace with t represents a counterexample that violates the expected property of tbeing positive.
underapproximation properties also represent spurious invariants.
one way of understanding why spurious results occur is that a max or min polyhedron has many facets in high dimensional space and inadequate traces may result in a constructed polyhedra with facets representing spurious relations.
for instance if x ycan take any value over the reals then an n facet max polygon built over any set of trace points for x yproduces nspurious invariants because no bounded max plus polygons can capture the unbounded ranges of x y. both ltering against additional traces and restricting attention to the weaker forms of max and min relations help reduce spurious invariants.
in the next section we describe a more general technique based on theorem proving to distinguish between true and spurious invariants.
.
verifying candidate invariants our algorithm and convex hull methods in general can generate many powerful but potentially incorrect relations due to trace incompleteness.
we augment dynamic invariant generation with static theorem proving to produce sound 2for instance if the true program behavior is x y the weaker candidate invariant x yis a strict overapproximation it is always true x y x y but is not the most precise answer.program invariants with respect to the program source code.
speci cally we verify program invariants using k induction.
in this approach kbase cases are speci ed and the kprevious instances are available for proving the inductive step e.g.
.
this additional power allows us to prove many invariants relevant to program veri cation that do not admit standard induction.
our theorem prover design called kip is based on iterative k induction and uses smt solving to verify candidate invariants.
in addition its architecture supports parallel checking of invariants dramatically improving e ciency.
recent advances in smt solving allow for e cient analysis over formulas encoding complex programs and properties in powerful theories.
this means that we can reason about and verify invariants involving theories such as nonlinear arithmetic and data structures such as arrays bit vectors and pointers.
int sqrt int x assert x int a s t while s x a t s t return a consider the program sqrt on the right which computes the square root of an integer using only addition.
from observed traces at location l our algorithm generates candidate loop invariants such as t 2a 4s t2 2t s a s t andx .
kip successfully distinguishes true and false invariants from these results.
speci cally we prove t 2a and s t2 2t are inductive invariants and s a 2is a inductive invariant i.e.
cannot be proved using standard induction .
by using proved results as lemmas kip is able to show the invariant s t which is not k inductive for k maxk where maxk is the default setting of kip.
the prover also rejects spurious relations such asx by producing counterexamples that invalidate those relations in sqrt.
the parallel implementation allows the prover to check these candidate results simultaneously.
.
analyzing programs using k induction a program execution can be modeled as a state transition system m i t with irepresenting the initial state of m andtspecifying the transition relation of mfrom a state n to a state n. to prove that pis astate invariant that holds at every state of m k induction requires that phold for the rst k states base case and that phold for the state n k assuming that it holds for the k previous states induction step .
formally k induction proves the state invariant pofm i t by checking the base case and induction step formulas i t1 tk p0 pk pn tn pn k tn k pn k if both formulas hold then pis ak inductive invariant.
if the base case fails then pis disproved and thus is not an invariant assuming that mcorrectly models the program .
however if the base case holds but the induction step fails then pis not a k inductive invariant but it could still be a program invariant.
thus k induction is a sound but incomplete proof technique.
by considering multiple consecutive transitions k induction can prove invariants that cannot be proved by standard induction induction in this formulation .
for instance the613invariant x6 yof the machine m i x y z tn xn yn yn zn zn xn that rotates the values through the variables x y z is not provable by standard induction but is k inductive with k .
the notation p idenotes the formula pwith all free variables subscripted by i e.g.
x y 0isx0 y0 .
.
k induction and smt solving input i t p output fproved disproved unprovedg fork 0tomaxk do base case ifk 0then sb assert i else sb assert tk if sb entail pk then return disproved sb cex induction step ss assert pk tk if ss entail pk then return proved return unproved figure procedure kprove for incremental kinduction using smt solvers sbandss.
figure outlines the procedure for verifying a property p using inductive k induction with smt solving.
the procedure consists of a loop that performs incremental k induction starting from k .
the loop terminates when either the base case fails pis not an invariant both the base case and the induction step hold pis an invariant or maxk is reached pis not a maxk inductive invariant .
we use two independent smt solvers sband ssto check the two formulas corresponding to the base case and induction step .3for a solver sand a formula f we append ftosthrough assertion and check if the assertions insimply fusing entailment .
if sdoes not entail f then the solver returns a counterexample cex satisfying a1 anbut not f. .
the architecture of kip at a high level verifying a candidate invariant against a program requires two steps computing a formula that encodes the program s semantics and proving whether the candidate invariant is consistent with that formula or not.
to increase expressive power in practice we also incorporate knowledge of all invariants learned thus far.
figure outlines the architecture of kip our k inductive parallel theorem prover to verify a set pof candidate obtained at location lfor program s. we rst generate from the program sand the location lthe formulas i t. these formulas can be thought of as representing the state transition system m i t described above.
equivalently i tcan be thought of as veri cation conditions vcs based on weakest preconditions wps from program analysis using hoare logic.
the backward analysis method provides the necessary rules to create i tfor imperative programming constructs such as assignments conditional branches and loops.
this area is well established tools such as microsoft boogie and esc implement various methods based on backward analysis to automatically generate vcs using wps.
3the two smt solvers can share the same implementation independent merely indicates that they may hold di erent assumptions at runtime.input s l p output pi pr pd pu i t vcgen s l pp pd pu repeat new p new u foreach p2pdo r kprove i t p ifr proved then pp add p new p add p else if r unproved then new u add p elsepd add p kip addlemmas new p p new u until new p new u pu p pi pr check redundancy pp return pi pr pd pu figure procedure to verify candidate invariants.
piand prare proved results however pr are redundant because pi pr.pdand puare disproved and unknown results respectively.
our algorithm progresses by trying to prove the invariants in the context of the vcs.
while unproved invariants remain the procedure attempts to re prove them by adding newly proved results as lemmas to kip.
in many cases this additional knowledge allows kip to prove properties that could not be proved previously see sections and .
.
a disproved invariant is likely spurious e.g.
assuming i t correctly models the program a proved invariant is de nitely correct and an unproved invariant e.g.
one that is notmaxk inductive can be conservatively rejected.
the algorithm supports parallelism which can check candidate invariants the forloop in figure simultaneously using multiple threads.
in a post processing step kip uses implication to partition all proved invariants into two sets those that are independent i.e.
strongest and those that can be implied by the others i.e.
weaker .
the implied invariants are redundant and need not be presented to the developer.
this partitioning uses the backend smt solver to check if each invariant p2ppcan be inferred by the conjunction of other proved invariants ppnfpg.
overall kip s design represents a novel combination of established techniques and provides the ve properties we desire for the e cient veri cation of complex invariants use of k induction for expressive power use of smt solvers for reasoning about program critical theories like nonlinear arithmetic learning of lemmas to prove otherwise non inductive properties explicit parallelism for performance and removing weaker implied results for human consumption.
.
experimental evaluation this section evaluates the e ciency and expressive power of our methods.
we consider the research questions rq1 can the hybrid algorithm e ciently generate powerful disjunctive invariants and prove them correct?
rq2 is the hybrid algorithm e ective on complex correctness properties such as those that are not classi 614table disjunctive invariant experimental results.
prog loc var gen t gen val t val hoare ex1 .
.
x strncpy .
.
x oddeven3 .
.
x oddeven4 .
.
x oddeven5 .
.
x bubble3 .
.
x bubble4 .
.
x bubble5 .
.
x partd3 .
.
x partd4 .
.
x partd5 .
.
x parti3 .
.
x parti4 .
.
x parti5 .
.
x total .
.
cally inductive or involve nonlinear arithmetic?
to investigate rq1 we applied our algorithms to a disjunctive invariant benchmark suite of kernels involving abstractions of string and array processing.
to investigate rq2 we used a nonlinear arithmetic benchmark suite.
each program comes equipped with gold standard full correctness annotations e.g.
assertions postconditions or formalized documented invariants .
each program was run on random inputs to provide traces for invariant generation and random inputs for ltering as described in .
for small kernels this yields su cient traces to generate accurate invariants .
our test programs come with annotated invariants at various locations such as loop heads and function exits.
for evaluation purpose we instrumented the values of variables at those locations and nd invariants among the resulting traces.
we use only the weak max and min forms given in section .
unless the number of variables is three or less in which case it is also practical to use the general forms.
we implemented our algorithms in the dynamic analysis framework dig using the sage mathematical environment .
our prototype uses the tropical polyhedra library tplib to manipulate max and min polyhedra and uses built in sage functions to solve equations and construct convex hulls for classical polyhedra.
the prototype kip prover uses z3 to check the satis ability of smt formulas.
as mentioned we consider linear max plus relations and set maxk by default.
the prototype constructs the veri cation conditions corresponding to m i t section .
directly a more e cient tool such as microsoft boogie could also be used.
the experiments were performed on a core .60ghz intel linux system with gb of ram kip used threads of parallelism.
.
rq1 disjunctive invariants we evaluate our approach on several benchmark kernels for disjunctive invariant analysis listed in table .
these programs typically have many execution paths e.g.
oddeven5 contains serial if blocks and thus 212paths.
the documented correctness assertions for these programs require reasoning about disjunctive invariants 4but do not involve 4we note that this suite is not exhaustive.
max plus algebra is still relatively new and while it has real world applications such as network tra c shaping and biologicalhigher order logic.
for example the sorting procedures are asserted to produce sorted output but are not asserted to produce a permutation of the input.
table report experimental results.
the loc column lists the number of locations where invariants were generated.
the var column reports the number of distinct variables involved in the invariants.
the gen column counts the number of unique candidate invariants generated by our dynamic algorithm.
the tgencolumn reports the generation and ltering time in seconds averaged over ve runs.
the number of generated invariants speaks to the expressive power of the algorithm higher is better indicating that we can reason about more disjunctive relationships over program variables.
time indicates the e ciency of our algorithm lower is better.
the valcolumn reports the number of generated invariants that kip proved correct and nonredundant with respect to the program.
the other generated invariants were disproved three times as often as they were proved redundant.
a few invariants just under on average could neither be proved nor disproved.
the tval column counts the time in seconds to analyze all of the generated invariants.
we desire validated invariants to statically prove each program s annotated correctness condition via hoare logic.
the hoare column indicates whether the validated invariants were su cient to prove program correctness.
for all of these programs the invariants generated and validated by our hybrid approach an average of per programs were su cient for a static proof of full correctness.
for example for the c string function strncpy which copies the rst ncharacters from a null terminated source sto a unconstrained destination d we inferred the relation n jsj j dj jsj n jsj j dj n this captures the desired semantics of the function if n jsj then the copy stops at the null terminator of s which is also copied to d sodends up with the same length as s. however if n jsj then the terminator is not copied to d sojdj n. as a second example for bubble nand oddeven n which sort the input elements x0 x nand store the results in y0 y n our inferred invariants prove the outputs y0and ynhold the smallest and largest elements of the input.
however we cannot show that yis a permutation of xbecause that is expressible only under higher order logics our results here are similar to those of purely static analyses .
table shows that our method is e cient.
we can infer about disjunctive relations per minute on average and validate about per minute.
the method is also e ective.
we produced non redundant proved correct disjunctive invariants and those invariants were su cient to statically prove each program s contract.
.
rq2 complex invariants we also evaluate our technique on more complex programs such as those that are not classically inductive or use nonlinear arithmetic by studying the nla nonlinear arithmetic test suite .
the suite consists of programs from various sources collected by rodr guez carbonell and kapur .
the programs are relatively small on average sequence alignment to our knowledge this is the rst paper on dynamic inference for max plus invariants and thus few benchmarks are yet available.615table nonlinear arithmetic experimental results.
prog loc var gen t gen val ki tval hoare cohendv .
.
x divbin .
.
manna .
.
x hard .
.
sqrt1 .
.
x dijkstra .
.
freire1 .
.
x freire2 .
.
x cohencb .
.
x egcd1 .
.
egcd2 .
.
x egcd3 .
.
x lcm1 .
.
x lcm2 .
.
x prodbin .
.
prod4br .
.
x fermat1 .
.
x fermat2 .
.
x knuth .
.
x geo1 .
.
x geo2 .
.
x geo3 .
.
x ps2 .
.
x ps3 .
.
x ps4 .
.
x ps5 .
.
x ps6 .
.
x total .
.
two loops of lines of code each.
however they implement nontrivial mathematical algorithms and are often used to benchmark static analysis methods.
for these programs we generate and check loop invariants of two polynomial forms nonlinear equations and linear max plus inequalities among program variables.
we consider at most generated terms per polynomial equality e.g.
invariants up to degree ve if four variables are involved.
the documented correctness assertions for these programs require nonlinear invariants mostly equalities among nonlinear polynomials.
table shows the results in a format similar to that of table .
the large number of candidate invariants generated over per program on average highlights the expressive power of our technique.
the generation is slightly slower than for the disjunctive benchmarks because these require equation solving for large numbers of terms representing nonlinear polynomials.
however our weak forms take an order of magnitude less time than do the general equality relations.
the overall generation process remains e cient averaging thirty seconds per program.
our hybrid approach is able to formally validate of those invariants or .
per program on average proving them correct and non redundant.
the validation is rapid .
seconds per candidate invariant on average compared to .
for the disjunctive benchmarks but here shows its reliance on the underlying smt theorem prover.
for of these programs some of the theorem prover queries issued caused the z3 smt solver to return an unknown error or stop responding.
this is likely due to the recent addition of support for nonlinear arithmetic and we reported these errors to the z3 developers.
in the interim however such candidate invariants must be rejected.
thekicolumn in table counts the number of invariants that require k induction to be proved or disproved.
sim ilarly an additional of the proved invariants required considering discovered invariants as lemmas and were not otherwise maxk inductive.
the signi cant presence of invariants requiring k induction or learned lemmas validates the kip architecture design choice.
ultimately the invariants generated and validated by our technique can be used to statically prove the correctness of of these programs using hoarse logic.
of the remainder two require novel invariant forms one requires invariants that are not k inductive and two are correct but beyond our current smt solver.
for the rst type divbin requires the invariant9k x 2k and our algorithm does not support exponential forms.
the hard program also has similar exponential invariants.
for the second type our dynamic algorithm generates three non linear equalities that precisely capture egcd1 s semantics and manual inspection veri es that they are not k inductive for any k and thus kip cannot prove them.
for the third type our dynamic algorithm generates invariants that precisely capture the semantics of prodbin and dijkstra and kip can process them but the backend smt solver hangs instead of proving them we have manually veri ed that they are otherwise correct .
thus we could prove two more programs with a better smt solver two more programs with a better theorem prover architecture and could not prove the last without a new algorithm for invariant generation.
.
related work dynamic invariant analyses.
daikon is a popular and in uential dynamic invariant analysis that infers candidate invariants using templates.
daikon comes with a large list of invariant templates and returns those that hold over a set of program traces.
daikon can use splitting conditions to nd disjunctive invariants such as ifcthenaelseb .
our algorithm does not depend on splitting conditions and our max and min plus disjunctive invariants are more expressive than those currently supported by daikon.
recently sharma et al.
proposed a machine learning based approach to nd disjunctive invariants.
their method operates on traces representing good and bad program states good traces are obtained by running the program on random inputs and bad traces correspond to runs on which an assertion or postcondition is violated.
they use a probably approximately correct machine learning model to nd a predicate representing a candidate program invariant that separates the good and bad traces.
for e ciency they restrict attention to the octagon domain and search only for predicates that are arbitrary boolean combinations of octagon inequalities.
finally they use standard induction technique to check the candidate invariants using z3 .
while our method shares their focus on disjunctive invariants a key di erence is that the strength of their results depends strictly on existing annotated program assertions.
for example in ex1 if the line assert y is not provided by the programmer then their method will only produce the trivial invariant true.
by contrast our approach does not make such assumptions about the input program and in some sense the purpose of our approach is to generate those assertions.
hybrid approaches.
nimmer and ernst integrated the esc java static checker framework with daikon allowing them to validate candidate invariants using a hoare616logic veri cation approach.
this work is very similar in motivation and architecture to ours.
key di erences include our detection of richer disjunctive invariants our veri cation with respect to full program correctness rather than proving complete program correctness esc detects only certain types of errors and our larger evaluation our system proves over four times as many non redundant invariants valid and considers over four times as many benchmark kernels .
static max plus analyses.
the static analysis work of allamigeon et al.
uses abstract interpretation to approximate program properties under the max and min plus domains.
in contrast to our work which computes maxplus formulas from dynamic traces their method starts directly from a formula representing an initial approximation of the program state space and gradually improves that approximation based on the program structure until a xed point is reached.
as with other abstract interpretation approaches for inferring disjunctive invariants such as their method uses an ad hoc widening operator to ensure termination.
the recent static analysis work of kapur et al.
uses quanti er elimination to nd max invariants over pairs of variables.
their method uses table look ups to modify max relations based on the program structures e.g.
to determine how the max relation is changed after an assignment a a .
for scalability the approach restricts attention to speci c program constructs.
for example they only support analysis on assignments or guards that do not involve multiplication.
a high level di erence between such techniques and our work is that we focus on the e cient inference of invariants from dynamic traces.
more generally we hypothesize that the weak max and min forms introduced in this paper would allow such static techniques to be practically applied to more general classes of programs.
uses of k induction.
the application of k induction is becoming increasingly popular for formulas that may not admit classic induction.
sheeran et al.
applied k induction to verify hardware designs using sat solvers .
the pkind model checker of kahsai and tinelli uses k induction and sat smt solvers to verify synchronous programs in the lustre language.
recently donaldson et al.
applied kinduction to imperative programs with multiple loops.
a key distinction between our kip architecture and these approaches is that none of them o ers all four of the other properties smt lemma re use redundancy elimination and parallelism that we nd critical for e ciently verifying large numbers of candidate invariants over programs with complex properties such as nonlinear arithmetic.
however we note that the programs and candidate invariants learned in this paper could serve as a benchmark suite for the evaluation of such theorem provers i.e.
hundreds of valid and invalid formulas involving nonlinear arithmetic many of which are k inductive .
.
conclusion program invariants are important for defect detection program veri cation and automated repair.
existing approaches struggle with soundness and expressive power and cannot learn disjunctive invariants.
we propose a hybrid approach to invariant inference that nds complex invariants dynamically and proves them statically.we present the rst dynamic algorithm to learn the maxplus class of disjunctive invariants allowing us to capture conditional behavior.
to do so we reformulate the problem of convex invariant detection in a non standard max plus algebra.
we gain expressive power with dual min plus constraints capturing if and only if behavior.
critically we also de ne and infer a new class of weak max and min plus invariants that retain useful expressive power while requiring only polynomial complexity.
to the best of our knowledge this is the rst use of a restricted for of max or min plus invariants.
these weak forms suggest new theoretical research directions for max and min plus algebras.
although we provide the algorithm for computing weak relations given points the dual problem for computing extremal points given relations remains open.
the cost of computing general polyhedra inspired general research work on weaker abstract domains e.g.
interval box zone and octagon and formal logic .
we see the relationship between our weak max plus form and general max plus as analogous to that between octagons and general polyhedra e.g.
xed coe cients only one open parameter etc.
and hope that other max plus researchers may nd our weak form somewhat as useful as polyhedra practitioners have found octagon forms.
we also propose a static approach to invariant veri cation based on iterative parallel k inductive smt theorem proving.
many program invariants are not classically inductive and k induction allows us to prove them.
similarly the re use of learned invariants as lemmas allows our system to prove non maxk inductive invariants in practice.
our design s explicit parallel structure is critical for performance.
by construction our algorithm never overapproximates if the real invariant is expressible in our system and validating each candidate against the program means that our system never underapproximates this approach helps address the issue of spurious or incorrect invariants.
we evaluate our algorithm by extending the dig framework and considering di cult benchmark kernels involving nonlinear arithmetic and abstract arrays.
our approach is e cient and e ective at nding and validating disjunctive non linear and complex invariants.
ultimately we nd and verify invariants that are powerful enough to prove of programs correct using hoare logic taking two minutes per program on average and producing no spurious answers.
.