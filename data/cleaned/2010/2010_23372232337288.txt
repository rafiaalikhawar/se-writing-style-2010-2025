slicing matlab simulink models robert reicherdt and sabine glesner technische universit at berlin germany reicherdt glesner cs.tu berlin.de abstract matlab simulink is the most widely used industrial tool for developing complex embedded systems in the automotive sector.
the resulting simulink models often consist of more than ten thousand blocks and a large number of hierarchy levels.
to ensure the quality of such models automated static analyses and slicing are necessary to cope with this complexity.
in particular static analyses are required that operate directly on the models.
in this article we present an approach for slicing simulink models using dependence graphs and demonstrate its efficiency using case studies from the automotive and avionics domain.
with slicing the complexity of a model can be reduced for a given point of interest by removing unrelated model elements thus paving the way for subsequent static quality assurance methods.
keywords slicing simulink dependence analysis matlab i. i ntroduction in the development of embedded systems matlab simulink is the most widely used industrial tool in the automotive industry.
modeling real world problems like braking systems or engine controllers result in simulink models containing several ten thousands of blocks and more.
these embedded systems are often deployed in safety critical areas which requires comprehensive quality assurance measures.
in practice quality assurance methods like testing are well established in the development of embedded systems with simulink.
but static methods are often limited to manual reviews and syntactical checks or are performed on the code generated from models.
due to complex structural hierarchies and model referencing it is hard to recognize data and control flow when reviewing complex simulink models manually.
we address the problem of reducing the complexity of a model by developing static slicing techniques for simulink.
therefore we remove those parts of the model that do not affect a block b. we require our slicing method to preserve the semantics of the model for being suitable for subsequent automatic quality assurance measures.
it also has to maintain the models structure and hierarchy so that it can support manual reviews by visualization.
the slice has to be as precise as possible since simulink models may consist of a huge number of blocks where each irrelevant block results in unwanted complexity.
in this paper we present a novel static slicing method for matlab simulink models using a dependence graph based approach.
the main contributions of this paper are a dependence analysis for matlab simulink models for control and data dependence.
a slicing approach for simulink that preserves hierarchy and semantics within the slice.
for the dependence analysis we show that in simulink models control dependence can be derived from conditional execution contexts cec .
cecs are an internal representation which cannot be accessed neither from the model file nor by matlab commands and can be propagated to other blocks and different levels through hierarchy.
this requires us to calculate cecs in simulink models to perform a dependence analysis.
our slicing approach eases model comprehension for manual reviews and allows impact analyses for simulink models.
in addition slicing results as well as results from our dependence analysis can be used for further quality assurance methods that were infeasible before due to the complexity of the models.
to evaluate our approach we use a case study provided by an industrial partner from the automotive industries as well as several models of the simulink demo library which are also from automotive and avionics domain.
the rest of this paper is structured as follows in section ii we briefly introduce slicing and present simulink.
in section iii we investigate control and data flow in simulink models.
in section iv we present our approach for calculating conditional execution contexts and the slicing of simulink models.
we give results from our case studies in section v and discuss related work in section vi.
finally in section vii we give a conclusion and outline our plans regarding future work.
ii.
b ackground a. slicing program slicing is a technique for extracting statements of a program that affect or are affected by the values of a set of variables at a specific point in the program.
these extracted statements are called a slice.
the point in the program and the variables of interest are usually referred to as a slicing criterion .
slices are either static ordynamic as well as executable ornot executable .
an overview for program slicing is given by tip in and silva in .
.
c ieee icse zurich switzerland 1read n 2i sum 4mul 5while i n sum sum i mul mul i i i write sum write mul a a example program b cfg figure .
a example program and its cfg while the original slicing approach was based on solving data flow equations slicing algorithms nowadays are using program dependence graphs pdg .
a pdg is a directed rooted graph with nodes representing statements and edges representing dependences.
using pdgs slicing can be mapped to a reachability problem.
depending on the direction of edge traversal a slice is called a forward orbackward slice.
while backward slices extract the statements that influence the program point given by the slicing criterion forward slices contain the statements that are influenced by the slicing criterion in the further execution of the program.
to build the dependence graph for a program a dependence analysis has to be done first.
a pdg consists of two types of dependence relations data andcontrol dependence.
these dependence relations are defined in terms of the control flow graph of a program.
data dependence is usually given by def ref relations of variables during the traversal of the control flow graph cfg on all paths.
definition data dependence .a node jis data dependent on a node iif there exists a variable xwith i xis defined at i ii xis referenced at j iii there exists a path from itojwhere xis not redefined at any node in that path.
control dependence between nodes in the cfg is usually given in terms of post dominance.
a node iis postdominated by a node jif all paths from ito the exit node pass through j. in figure 1b node 5postdominates node .
definition control dependence .a node jis control dependent on a node iif i there exists a path from itojsuch that jpostdominates every node in the path excluding i ii iis not post dominated by j in other words a node jis control dependent on a node iifihas at least two outgoing edges and jis not in all of the paths to the exit node starting from these edges.
in figure 1b the node 7is control dependent on node .
figure .
environment for fig.
figure .
simulink model corresponding to figure 1a control dependence can be determined by calculating the post dominator tree for a cfg or for programming languages with a well structured control flow directly from the abstract syntax tree.
in figure 1a we give a small example program that is often used to demonstrate slicing.
it calculates the sum as well as the product of the first npositive integers.
the highlighted statements are contained in a backward slice for the slicing criterion c mul where line 10is the program point and multhe variables of interest.
b. simulink simulink is an add on to the matlab ide by mathworks that allows for the graphical modeling and simulation of synchronous reactive systems.
simulink is a data flow oriented notation where blocks are connected by lines .
a simulink block either represents functionality or is552used for structuring the model.
lines represent signal flow and are connected to the inputs oroutputs of blocks.
simulink provides many different blocks that implement e.g.
arithmetical and logical functions relational operators or various tasks from electrical engineering.
there exists blocks used for structuring the model as e.g.
subsystem orport blocks and for structuring the signal flow such asbus ormux blocks too.
blocks used to structure the model are generally virtual .
virtual blocks do not influence the behavior of a model.
subsystems in simulink are either virtual subsystems oratomic subsystems .
virtual subsystems are only used for structuring the model by introducing visual layers of hierarchy.
atomic subsystems require all contained blocks to be executed as one atomic operation.
example .
figure shows a simulink model that corresponds to the program in figure 1a.
it calculates the sum and the product of the first npositive integers up to a given n. this is modeled using a whileiterator subsystem.
awhileiterator subsystem is executed as long as the signal supplied to the cond port is greater than zero.
a whileiterator requires an initial condition ic which is used to determine if the subsystem is executed at least once.
this ic has to be supplied from outside of the whileiterator subsystem.
thus we have embedded the whileiterator subsystem in an environment figure where nis supplied by a ramp function which increases n by1in each simulation step and icis aconstant .
we have named the blocks corresponding to the statements of our example program.
the initialization of the variables line is done with the initial values of the unitdelay z blocks.
a unitdelay block holds the value of a signal for a simulation step.
we have named the unitdelay blocks like the variables they correspond to.
the read andwrite operations are mapped to the inport andoutport blocks of the subsystem.
only subsystem blocks can contain other blocks.
the ports of a subsystem block correspond to port blocks within the subsystem.
a number is assigned to each inport oroutport block which corresponds to the vertical position of the input of the subsystem block.
the inputs of the subsystem block in figure are mapped to the inport blocks rounded rectangles read n no.
and ic no.
in figure according to their numbering top to down .
loops in simulink can be executed multiple times within one simulation step.
thereby loops do not consume simulation time and it is up to the modeler to ensure that the execution time of the loop is within the sampling rate of the model.
loops also allow state changes of the blocks contained in the loop subsystem.
hence a unitdelay block holds the value of the signal only for an iteration step of the loop.c.
simulation of a model even though the graphical notation in simulink models is concurrent the simulation of models is deterministic and sequential.
the simulink simulation environment determines a schedule for the execution of blocks.
basically the execution order is calculated according to the direct signal flow dependences between the blocks.
for more information to block scheduling we refer to .
simulink uses execution contexts ec to store and execute the calculated schedules.
an execution context contains a sorted list of blocks and nested execution contexts.
once an execution context is entered all elements contained in this context have to be executed before the context is left.
when scheduling the blocks the simulation environment creates one execution context for the whole model and one for each atomic subsystem within the model.
the execution are nested according to the hierarchy of the atomic subsystems within the model.
all blocks contained in an atomic subsystem and the virtual subsystems below are added to the execution context for the corresponding subsystem.
the elements in the ecs are scheduled locally within the context.
in the following sections we refer to the execution context created for the model as root context .
the simulation is done for a finite number of steps.
the time span between the simulation steps depends on the solver used to simulate the model and can be fixed or of variable size.
solvers can be continuous which is required for models containing continuous blocks or discrete for models only containing discrete blocks.
for embedded systems usually a discrete solver is used that executes the model at a constant sampling rate.
in each simulation step the environment starts with the first block of the root context and executes all the blocks within this context in the calculated order.
iii.
d ependence in simulink models simulink is a data flow oriented graphical notation where data flow is given by structure and control flow has to be calculated.
in this section we present how we determine data and control dependence for simulink models.
a. data dependence data flow in simulink is given by signal lines.
so data dependence can easily be derived by following signal lines.
the general case for specifying data flow in simulink is by defining a line lconnecting two blocks b1andb2.
this means that an output signal lofb1is used as an input signal forb2.lis defined in b1 referenced in b2and transmitted vial.
in this case b2is directly data dependent on b1.
definition data dependence simulink .a block b2is data dependent on a block b1if i b1andb2are connected by a line land ii lstarts in an output of b1and ends in an input of b2.553figure .
a multiportswitch b. control flow in simulink before presenting how control dependence is calculated for simulink we summarize the different ways of modeling control flow in simulink models.
basically control flow in simulink is modeled by a conditional subsystems or b loop subsystems or c multiportswitch andswitch blocks.
we explain these constructs in the subsequent paragraphs.
conditional subsystems conditional subsystems areenabled triggered enabled triggered action andfunction call subsystems.
conditional subsystems are atomic and characterized by a special port on which controls the execution of the subsystem.
dependent on the type of the subsystem the signal connected to the special port is checked for a specific property e.g.
if it is greater than 0in case of a enabled or for a falling or rising edge in case of a triggered subsystem.
blocks contained in a conditional subsystem are only executed if the condition given by the special port is fulfilled.
this behavior is analogous to an if statement with an empty else branch known from imperative programming languages.
although there exist switch case andif then blocks these are only specialized blocks that drive action subsystems.
the actual conditional execution is done by action subsystems.
loop subsystems loops like while and for in simulink are realized by atomic subsystems too.
similar to conditional subsystems they contain a special block which controls the execution of the subsystem.
this block is either a whileiterator or a foriterator .
a whileiterator block triggers the execution of the subsystem as long as a condition is true.
a foriterator block triggers the execution of the subsystem for a given number of times.
switches switch ormultiportswitch e.g.
figure blocks can also be used to model control flow in simulink.
these blocks offer a control port the topmost input in figure and a number of data ports.
depending on the value provided to the control port the signal attached a the conditional subsystem s within m b contents of the conditional subsystem s figure .
the model m to the corresponding data port is forwarded to the output port of the switch ormultiportswitch block.
to optimize the simulation of a model the simulink environment offers conditional execution behavior to avoid the unnecessary execution of model parts.
if conditional execution behavior is set active the simulink environment only executes those blocks that supply data to the selected input port of the switch ormultiportswitch block.
to realize the conditional execution of these blocks the simulation environment internally creates enabled subsystems for each data port.
as one can see all control flow i.e.
the conditional execution of blocks in simulink is realized by conditionally executed atomic subsystems.
to determine control dependence we have to investigate how simulink internally treats conditional subsystems.
c. control dependence and conditional execution contexts in this section we show how control dependence can be determined by analyzing the execution contexts given by the conditional subsystems in a simulink model.
as mentioned in section ii c for each atomic subsystem a new execution context is created.
due to all conditional and loop subsystems being atomic an execution context ec is created for each of these and the blocks contained in each of these subsystems are assigned to its ec and scheduled within.
all other blocks are assigned to the root context of the model and ordered according to their data dependences.
the ecs of the atomic subsystems are scheduled according to the data dependences of the corresponding subsystem blocks within the ec of the corresponding parent subsystem.
conditional subsystems and loops are only executed if the condition given by the special port or iterator block evaluates to true.
hence the corresponding ecs are called conditional execution contexts cec .
in the following we refer to this special port or iterator block as predicate block .
example .
to demonstrate the calculation of control dependence we use the model mcontaining a block v554figure .
cfg with execution contexts which is connected to a conditional subsystem s figure .
scontains a number of blocks and has one outport block bnconnected to a block w. the blocks v w and the conditional subsystem sare on the root level of the model.
the subsystem scontains the enable block cond that triggers the execution of subsystems and in turn also the execution of the blocks b1.
.
.
bn within s. the block vis connected to the input of sthat corresponds to cond .
when scheduling the blocks of the model m simulink creates two execution contexts the root context of the model and one for the conditional subsystem s namely cec s. this results in the schedule sched m angbracketleftbigg v b1 .
.
.
b n if cond else w angbracketrightbigg a control flow graph corresponding to this schedule of mis given in figure .
the execution contexts are indicated by the dashed lines.
simulink is used to model reactive systems that are potentially non terminating.
nevertheless simulink models generally have the following execution behavior a model is simulated for a given number of clock cycles.
in each of these time steps the model is executed as long as no runtime error occurs.
the simulation of a simulink model stops if the simulation loop is left after executing the model for a given number of clock cycles.
once an ec is entered allblocks within the ec have to be executed.
this also holds for the root context.
hence it follows that there is a simulation loop and a model is always completely executed in a simulationstep.
so there exists one start and one exit node in the cfg of a model.
in figure these nodes are drawn dotted.
due to the existence of an exit node the definition of control dependence of imperative languages becomes applicable for simulink models which is based on post dominance.
also there is a relationship between conditional execution contexts and control dependence.
our definition of control dependence in simulink makes use of this observation.
in general concerning the root context it holds that every node nof the root context is control dependent on the simulation loop because it post dominates all predecessors in the schedule but not the simulation loop and itself.
analogously every other node mof an arbitrary conditional execution context e.g.
cec s is control dependent on the nodecond representing the predicate block that controls the execution of this cec.
even though the cond node itself is contained in the subsystem mit has be to executed to determine if mhas to be executed.
so cond has to be assigned to the parent execution context and is therefore control dependent on the parent predicate block.
definition control dependence simulink .in a model mwith the root context emcontaining the blocks b1andb2 b2is control dependent on block b1if b2is within a conditional ec e negationslash emand b1is the predicate block controlling the execution of e. the blocks contained in emare control dependent on the simulation loop.
in this section we have presented our definitions for data and control dependence in simulink models.
while data dependence is given by signal lines control dependence can be derived from the nested conditional execution contexts within the model.
in the next section we show how we calculate data and control dependence to build up the dependence graph and slice the model.
iv.
s licing simulink models in this section we present our slicing approach for simulink models using dependence graphs.
first we define the slicing criterion and the slice of a simulink model.
then we show how we calculate dependences which includes the calculation of the conditional execution contexts.
finally we show how we build up the dependence graph and compute static slices for the model.
a. approach and basic definitions when slicing simulink models we are faced with both theoretical and practical problems subsystem blocks as nodes in the dependence graph may lead to imprecise slices due to their use to implement hierarchy.
the cecs computed by simulink are displayed but not accessible via the api.
even if they were accessible those cecs do not contain virtual blocks such as ports and buses that are needed for keeping structural information.
subsystem blocks in simulink resemble procedures in imperative programming languages.
for a number of input values a number of output values is produced.
most of the subsystem blocks are only used to implement hierarchy which is comparable to procedures that are only called once.
therefore to deal with we have decided to inline the subsystems instead of using a system dependence graph sdg based approach that would generate lots of unneeded nodes and edges in the graph.
to deal with and we have to calculate the conditional execution contexts to derive control dependence.
definition simulink slicing criterion .a slicing criterion cis a set of blocks b c b .
the set bcan contain any virtual or non virtual block except subsystem blocks.
the slicing criterion may be empty which results in the slice also being empty.
to slice for a subsystem block we use the corresponding inport oroutport blocks of this subsystem as slicing criterion.
a block cis relevant to a block bifcis directly or transitively data or control dependent on b. this also holds for virtual blocks that are connected by lines which in turn allows us to preserve hierarchy.
definition simulink slice .a slice of a simulink model mis a model m primethat only contains those blocks that are relevant to the slicing criterion c backward or only contains those blocks to wich the slicing criterion cis relevant and that preserves the hierarchical structure of the simulink model.
b. computing coditional execution contexts in section iii c we have shown that control dependence can be derived from conditional execution contexts.
unfortunately although each conditional and loop subsystem creates its own conditional execution context we cannot use a syntax directed approach for the calculation of control dependence because simulink allows the propagation of conditional execution contexts.
in simulink a cec can be propagated across subsystem boundaries.
this means that a block bcan be added to the cec of a conditional subsystem seven though the block bis not contained in s. this is a mechanism for the optimization of the simulation by executing only those blocks that are required to be executed in a simulation step.
the propagation is done in both directions forward propagation to determine those blocks that only require data calculated in the cec as well as backward propagation to determine blocks that are only executed to provide data for the cec.
figure .
propagation of the execution context 2to the gain block example .
figure shows a multiportswitch block and the cecs calculated by the simulink environment.
the small numbers e p .
.
.
in the top right corner indicate the execution context eand position pof the block in the schedule of e. in case of the switch block in figure themultiportswitch block itself is in the cec .
the numbers in the curly brackets e1 .
.
.
e n represents the execution contexts produced by this block.
for the multiportswitch the execution contexts 2and3are generated for the internally created enabled subsystems for each data input.
these cecs are propagated to the blocks connected to the data inputs of the multiportswitch .
figure shows the surrounding subsystem of figure .
the cec 2from figure is propagated across subsystem boundaries to a gain block connected to the input that corresponds to the inport block in3in figure .
there are two cases where a propagation of conditional execution contexts is necessary a conditional subsystem has its propexeccontextoutsidesubsystem parameter set to onor conditional execution behavior is set active for a model and the model contains switch and multiportswitch blocks.
mathworks specifies the following rules for the propagation of execution contexts definition conditional execution context propagation .a block can be added to an execution context if its output is required only by a conditionally executed subsystem or its input changes only as a result of the execution of a conditionally executed subsystem and its sample time is inherited and the output of the block is not a testpoint and the block is allowed to inherit its conditional execution context and the block is not a multirate block.
according to these conditions the simulink environment calculates the execution context for each block.
while requires us to analyze the paths leading to or from a block that propagates its execution context and can be directly5561 reassingsignalstoportblocks model findexecutioncontexts model root context function findexecutioncontexts parent current ec for block b in parent.childs if b is subsystem if b is conditional or loop new ec new ec b.predicateblock current ec.add b.predicateblock findexecutioncontexts b new ec if b.propexeccontextoutsidesubsystem on for signal in b.insignals propagatebackward signal new ec for signal in b.outsignals propagateforward signal new ec else findexecutioncontexts b current ec else current ec.add b if conditianal execution behavior on for block b in parent.childs if b is multiportswitch or switch for signal of b.data in new ec new ec new node signal.dstportnr propagatebackward signal new ec figure .
algorithm for cec calculation taken from the parameters of the blocks and ports.
for now we defer the aspects and for two reasons first the simulink documentation lacks for information which blocks are not allowed to inherit an execution context.
it only gives two examples.
second the simulink documentation does not specify exactly what a multirate block is.
deferring and weakens the conditions for the propagation of the conditional execution context such that additional blocks may be added to a execution context in some very rare cases.
this leads to an overapproximation of the existing control dependences and hence preserves the correctness of the slices computed by our approach.
to compute the conditional execution contexts we recursively traverse the model top down as shown by the algorithm in figure .
first after parsing the model we inline the subsystems by reassigning the signals connected to the ports of the subsystems to the corresponding inport andoutport blocks line .
then we traverse the model starting at the root level and with the root context line .
for each child block we check whether it is a subsystem or not.
if not the block can be added to the current execution context line .
if it is a non conditional subsystem it is recursively traversed using the current execution context of the parent subsystem or model line .
for a conditional or loop subsystem we create a new cec line and add the predicate block to the parent execution context line .
the recursive traversal of this subsystem is then continued with the new cec for its child blocks line .
subsystem blocks are not added to the execution contexts.
the recursive traversal stops if the lowest hierarchy level is reached.for each conditional subsystem found during the traversal we check if the parameter propexeccontextoutsidesubsystemis set line .
if so we traverse the model starting from the inport andoutport blocks of this subsystem to propagate the execution context line in forward and backward direction.
also if conditional execution behavior is enabled for the model we create an execution context for each data port of a switch ormultiportswitch block line .
then these new execution contexts are propagated to the blocks connected to the respective data port line .
the propagation of the execution contexts propagateforward andpropagatebackward is basically implemented in a work list algorithm that iterates over the input or output connections of blocks.
the traversal of a path starting from a block that propagates an execution context is stopped if one of the conditions to in definition is not fulfilled.
the blocks along this path are added to the execution context.
this algorithm can easily be extended for and in future.
c. building the dependence graph after all blocks have been added to an execution context we build the dependence graph.
first we create nodes for each block that is not a subsystem.
we iterate over all signals contained in the model and add the data dependence to the nodes.
then for each identified execution context we add the control dependence edges from the node that caused the cec to the nodes within.
if the cec is caused by a multiportswitch or switch block an additional node is created per possible choice.
this reflects the enableport block of the internally created enabled subsystem.
the nodes within the cecs are set control dependent on the corresponding virtual enable node.
the enable nodes are set control dependent to the switch because they are only evaluated if the corresponding data input is selected.
in figure the dependence graph for the simulink model from figure and is shown.
after calculating the cecs we have two cecs the root context and a cec for the whileiterator subsystem.
in this figure dotted edges represent control dependence and gray solid edges data dependence.
d. computing the simulink slice we compute the slice for a model by performing a reachability analysis in forward or backward direction and marking relevant nodes.
then we remove the unmarked blocks and finally all empty subsystems from the model.
in figure and we present a simulink model that corresponds to the example program in figure 1a.
performing a backwards reachability analysis for the slicing criterion c write mul leads to the marked dependence graph shown in figure .
the bold nodes and lines belong to the slice.
as we can see in figure all blocks that are not contained in the slice calculate the sum.557write sum mux icwhile iterator write mul sum i sum read n relational operatorconstant constant1 i 1scope i mul i mulramprootfigure .
marked dependence graph for c write mul figure .
sliced model from figure e. summary in this section we have presented our approach to calculate control and data dependence for simulink models.
while we can derive data dependence from signal lines the determination of control dependence requires us to calculate the conditional execution contexts first.
this also includes execution context propagation.
in contrast to the execution contexts calculated by the simulation environment of simulink our calculated ecs also contain virtual blocks.
this allows us to preserve the structure of the models.
v. e valuation we have implemented our slicing approach in a tool that parses a model calculates the control and data dependences and builds up a pdg corresponding to the model.
we have implemented our forward and backward slicing algorithm that performs the reachability analysis by marking nodes in the graph.
our tool is able to print the graph as well as to color or remove the blocks in the model using a script in m language which can be executed in the matlab ide.we have evaluated our tool on ten case studies.
eight of these case studies were taken from the simulink demo models which are shipped out with every matlab simulink distribution.
from these we have selected those models with the highest number of blocks and from different domains.
these models often demonstrate the various possibilities of simulink and are therefor feasible to evaluate our approach but may not reflect real world models where guidelines constrain the number of allowed modeling constructs.
furthermore we have used the model distance warning which is a model provided by a project partner from automotive industries and implements a system that monitors the distance to vehicles driving ahead.
finally our model control flow consists of synthetic data.
it is created by ourselves during the development of our slicing approach and contains nested conditional subsystems and a multiportswitch block.
we have resolved model