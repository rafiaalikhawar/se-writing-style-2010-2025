towards efficient optimization in package management systems alexey ignatiev ist inesc id lisbon portugal aign sat.inesc id.ptmikol janota ist inesc id lisbon portugal mikolas sat.inesc id.ptjoao marques silva university college dublin ireland ist inesc id lisbon portugal jpms ucd.ie abstract package management as a means of reuse of software artifacts has become extremely popular most notably in linux distributions.
at the same time successful package management brings about a number of computational challenges.
whenever a user requires a new package to be installed a package manager not only installs the new package but it might also install other packages or uninstall some old ones in order to respect dependencies and con icts of the packages.
coming up with a new con guration of packages is computationally challenging.
it is in particular complex when we also wish to optimize for user preferences such as that the resulting package con guration should not di er too much from the original one.
a number of exact approaches for solving this problem have been proposed in recent years.
these approaches however do not have guaranteed runtime due to the high computational complexity of the problem.
this paper addresses this issue by devising a hybrid approach that integrates exact solving with approximate solving by invoking the approximate part whenever the solver is running out of time.
experimental evaluation shows that this approach enables returning high quality package con gurations with rapid response time.
categories and subject descriptors d. .
domain engineering f. .
computations on discrete structures g. .
constrained optimization k. .
software maintenance general terms algorithms performance management keywords package management sat solving maxsat solving optimization minimal correstion subsets permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
.
.
introduction the complexity of package management systems stems from two main objectives personalization and reusability .
on the one hand di erent users are expected to use their computers for di erent purposes and thus requiring di erent software artifacts on their computers but on the other hand it is desirable to reuse software artifacts whenever possible.
nowadays package management systems such as those behind linux distributions enable handling hundreds of thousands of software artifacts.
this is possible due to organizing software into packages and explicitly recording relations between those packages.
once a user requires for a package to be installed a program called the package manager consults thepackage repository and determines the package s dependencies i.e.
which other packages also need to be installed.
or it might determine that some other package con icts with the one that is supposed to be installed.
due to such relations between packages maintaining a particular package con guration consistent poses a computational challenge.
indeed to determine whether a package can be installed into a given con guration of packages is npcomplete .
consequently current package management tools are known to be notcomplete i.e.
there are situations when they are not able to nd a solution even if it exists .
all of the above motivates the formulation of package upgradability problem orpackage installability .
the input to the problem is the initial con guration relations between packages con icts and dependencies and user s request .
the output to the problem is a con guration of packages that satis es the relations between them and also the user s request.
for the purpose of this article we consider a request to be a set of packages to be installed and a set of packages to be removed.
in our implementation however the upgrade request is also supported such can be modeled as removal of an old version and installation of a new version.
in practice users are not likely to be satis ed with an arbitrary solution to the package upgradability problem.
for instance users typically expect that the resulting con guration of packages will not di er too much from the initial con guration.
or the user may wish to bring all the packages up to date.
for this purpose we also enable the user to specify optimization criteria that are to be optimized in the resulting package con guration.
while optimization criteria are indispensable for practical application of package management they make the problem computationally more complex.
however number of approaches were developed in the recent years relying on vari permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm ous technologies such as answer set programming pseudoboolean optimization or maxsat .
it has been demonstrated that these approaches are mature enough to be applied in practice.
most notably the development environment eclipse ide employs the pseudo boolean based engine p2 to drive package management.
dedicated optimization solvers have an important advantage over heuristic based algorithms and that is they guarantee to nd the optimal solution given su cient amount of time.
the runtime however might be an issue from a practical perspective due to the high computational complexity of the problem.
it is unacceptable for a user to wait hundreds of seconds.
thus for successful integration of the tools into practice they must be able to nd a solution within a number of seconds .
therefore an optimization solver may be forced to stop in the middle of the computation and return some solution which is possibly non optimal.
this is indeed the case in the solver p2 which is used in eclipse ide.
observe that eclipse ide is used by literally millions of users and so millions of users use p2 on a regular basis.
to our best knowledge there is no approach to the package upgradability problem that would be dedicated to nding good approximate solutions within practical time limits.
instead the current approaches respond with a best so far solution which provides little or no guarantees.
the discussion above can be summarized into two main observations .
complete optimization solvers canbe successfully used in practice.
.
users require rapid responses and therefore it is likely that the solver will run out of time.
these observations lead to the following challenge if a complete package upgradability solver is running out of time it must be able to produce a good solution nevertheless.
in response to this challenge this paper proposes an approach for nding good near optimal solutions to the package upgradability system.
at the same time it enables construction of a hybrid solver .
this hybrid solver integrates a complete approach with the approximation approach in a way that the approximation approach is invoked only when needed.
thus it is providing us with the best of the two worlds completeness and rapid response.
we have implemented this hybrid solver on top of an existing tool for the package upgradability problem.
we have performed an extensive experimental evaluation where our hybrid approach was compared to the tool p2.
this evaluation demonstrates that the hybrid approach enables resolving much larger number of instances than p2 within a rapid timeout.
further the provided responses are signi cantly closer to the optimum than the responses of p2.
this article is organized as follows.
section introduces concepts and notation used throughout the paper.
section describes the proposed approach for solving package upgradability this section is the main contribution of the paper.
section presents an experimental evaluation of the proposed approach.
related work is summarized in section and nally the paper concludes by section .
.
preliminaries a number of formalisms exists to explicitly capture dependencies between software artifacts.
prominent examples arefeature models which capture dependencies of software a b c f d e con icts g h x y z w or or or figure example dependencies components of a software system including variability .
linux distributions rely on package management systems where software components are organized into packages captured in standardized formats such as rpm or deb .
apackage manager is used to maintain a particular conguration of the system in a consistent state i.e.
in a state where dependencies between packages are not violated.
such package manager must be able to receive requests from the user to install or uninstall certain packages.
whenever such request is obtained the package manager must compute a new con guration satisfying both the request and the package dependencies.
figure schematically shows a small example of dependencies between packages the diagram uses primitives similar to the ones used in feature modeling .
imagine now that we wish to install package aand at the same time we wish to minimize the number of installed packages.
since a requires both bandc these have to be installed as well.
now the packages f d andecan be used to ful ll dependencies ofbandc.
in this case as we want to minimize the number of installed packages we install das that satis es dependencies of both bandc.
now let us consider another scenario where we wish to install both aandgand again we wish to minimize the number of installed packages.
if we solve the problem greedily and install a b c andd we will end up with a suboptimal solution because package dexcludes the use of package fand therefore packages h x y z w have to be used to satisfy dependencies of package g. in this paper we consider packages described in the language common upgradability description format cudf e.g.
see .
cudf was developed by the scienti c community and thus is more amenable to scienti c analysis and is supported by a number of freely available tools .
at the same time cudf is a realistic language which was successfully integrated into existing tool chains .
for the sake of succinctness and clarity the presentation in this paper does not consider the full extent of the cudf language but the language was considered in full for the experimental analysis .
every package has a name and a version where a name is a string and version is a positive natural number.
a package may depend on some other packages or it may con ict with some other packages.
a package can also be attributed its sizeor the set of packages that are recommended to be installed with it.
the attribute installed tells us if the package is installed in the current package con guration.
an example of a package in cudf follows.
package openssl version depends libc6 libssl1.
.
zlib1g conflicts openssl installed true installedsize 1184746the package s name is openssl in its version is .
for its functioning the package requires certain versions of libc6 libssl1.
.
and zlib1g .
for instance if this package is to be installed there must be also installed a package libc6 with the version greater or equal to .
the conflicts speci cation in this case says that the package con icts with all packages with the same name except with itself.
a solver for the package upgradability problem is given a set of packages each described as the one in the example and it outputs a new package con guration as a set of packages that are installed in it.
.
package upgradability problem the problem that a package manager has to solve whenever it faces a user request is called the package upgradability problem .
a package manager operates on a package universe orrepository i.e.
the set of packages that are visible to it.
auser request comprises packages that the user wishes to beinstalled and the set of packages that the user wishes to beuninstalled .
additionally the package manager may be given a criterion according to which it should optimize when looking for the new con guration.
such criterion can be for instance minimizing the number of newly installed packages or minimizing the number of packages that were installed in the initial setup but are uninstalled in the solution.
more formally a package manager is given a package universeuand a user request represented as a pair i r where irepresents the packages that are to be installed and rare the packages to be removed.
the output is a set of packagesnsuch thatncontains all of the packages from i does not contain any of the packages from r and all the package dependencies and con icts are respected in n. if suchn does not exist the package manager reports a failure.
optimization criteria are a complex issue and it is beyond the scope of this paper to describe them in full detail.
we consider optimization criteria used in the misc competition .
these criteria typically rely on some additional attributes of a package e.g.
see openssl above .
most notably a package can have the attribute installed which signi es that the package is currently installed in the system if the attribute is not present it defaults to false .
this attribute enables specifying criteria that express that the new installation should di er from the original one as little as possible.
multiple sub criteria are combined by alexicographic ordering .
for instance a criterion speci ed as count removed count changed de nes a lexicographic order where we wish to minimize the number of removed and the number of changed packages and minimizing the number of removed packages has a higher priority than minimizing the number of changed packages.
.
boolean satisfiability and maximum satisfiability to decide whether a package upgradability problem has a solution or not is np complete .
hence appropriate tools for solving the problem need to be chosen.
the package upgradability problem naturally translates to boolean satis ability sat constraint satisfaction csp oranswer set programming asp paradigms.
in this paper we consider the sat paradigm and for the optimiza1the version numbers of the packages does not necessarily have to correspond to the version of the software component that the package encapsulates.tion part of the problem we consider a maximal satis ability maxsat formulation.
for such the following standard de nitions are considered.
aliteral is a boolean variable or its negation.
a clause is a disjunction of nitely many literals possibly none .
a formula is in conjunctive normal form cnf if it is a conjunction of nitely many clauses possibly none .
as is common whenever convenient a clause is treated as a set of literals and a cnf as a set of clauses.
an assignment to a set of variables xis a function from xto the constants and corresponding to true and false respectively.
an assignment satis es a formula i the formula evaluates to under that assignment.
the sat problem is the problem of deciding whether a cnf has a satisfying assignment.
given a cnf the maxsat problem consists in nding an assignment to the variables of that maximizes the number of satis ed clauses clauses that evaluates to under the assignment .
the partial maxsat problem is given as an input two cnf formulas the hard clauses hand the soft clauses s. a solution to such problem is an assignment that satis es all the clauses in hand maximizes the number of satis ed clauses in s. for instance for the cnfs h f x y g and s f x y gthe assignment de ned as x y is a solution satisfying one of the soft clauses.
in contrast the assignment de ned as x y is not a solution since it does not satisfy any of the soft clauses.
maxsat also has a weighted variant which is useful for optimization with weights.
a partial weighted maxsat consists of hard clauses hand weighted soft clauses s. a solution to a partial weighted maxsat is an assignment that satis es all of the hard clauses and maximizes the number of weights of soft clauses that are satis ed.
we will denote a weighted clause cwith weight was w c .
for example if hard clauses are de ned as h f x y gand soft clauses as s f x y g the problem has a single solution which is the assignment x y .
intuitively the hard clauses prescribe that one of the xand ymust be .
at the same time however the soft clauses force both of the variables to .
consequently we must pick one of the variables to be and one of them to be but because the clause x has a larger weight xis set to .
.
approach in our approach to the package upgradability problem we follow the popular techniques for translating dependencies between packages into boolean logic.
then we use weighted maxsat to express optimization criteria.
first we show how to decide whether a package upgradability problem has a solution or not can be encoded as a sat problem.
each package pis assigned a unique boolean variablevp representing whether the package is installed in the solution being constructed.
the clauses capturing the dependencies and con icts are generated according to the following rules.
if a package prequires one of the packagesr1 r n generate the clause vp w i21 nvri .
if a packagepcon icts with a package o generate the clause vp vo .
to encode the user request we follow the following two rules.
if a package pis requested to be installed generate the clause vp and when it requested to be uninstalled generate the clause vp .
once a cnf formula is constructed as described above we can invoke a sat solver to decide whether the considered747upgradability problem has a solution or not.
if it does a sat solver also provides us with a satisfying assignment to the constructed cnf.
this assignment tells us which packages should be installed.
in particular a package pis installed if and only if the variable vpis assigned to the value .
as noted above from the user point of view it is not sufcient to just nd any solution to the package upgradability problem but we want to nd a solution that is optimal with respect to some criteria.
we consider the encoding of the optimization problem as weighted maxsat.
for such all the clauses above are considered to be the hard clauses these must be satis ed by any solution.
soft clauses are used to encode the criterion to be optimized.
for succinctness reasons we will not describe all considered optimization criteria and their encodings the reader is referred to existing literature for further details .
for illustration let us consider the criterion where we wish to minimize the number of removed packages .
a package is considered removed if there is some version of the package in the initial package con guration and there is no version of that package in the nal con guration.
for such we rst collect the set of package names ifor which there is some package in the initial con guration.
then for each of these namesn2 i we construct the soft clause w p name nvp .
intuitively this soft clause enforces that at least one version of the package is installed.
recall that in maxsat soft clauses are not necessarily satis ed.
however a solution to a maxsat guarantees that the largest possible number of soft clauses is satis ed.
consequently in this particular case the smallest possible number of packages will be removed.
to show how weighted maxsat is useful consider the criterion where we wish to minimize the total size of the resulting package con guration.
for such for each package pgenerate the soft clause p size vp .
such clause tries to enforce that pisnotinstalled.
however more emphasis is put on larger packages.
observe that if all packages have the same weight the problem is the same as minimizing the total number of installed packages and then unweighted maxsat is su cient.
to illustrate the above consider the right hand side of figure under the assumption that we wish to install packageaand minimize the total number of installed packages.
the hard clauses are va vb va vc vb vf vd vb vd ve vf vd and va .
note that the last clause represents the user request to install package a. the soft clauses are va vb vc vd vf and ve .
observe that the soft clause va can never be satis ed in a solution because of the hard clause va .
.
boolean lexicographic optimization so far we have discussed how to translate a single optimization criterion into maxsat.
in practice however multiple criteria might be required.
for instance the user may wish to nd a package con guration that di ers the least from the existing con guration but at the same time it does not occupy too much space on the disc.
a natural way how to combine multiple criteria is via the lexicographic ordering where the individual criteria are given di erent priorities.
so for instance if we have two criteria c1andc2where c1is given the higher priority a total optimum must rst optimizec1and only then c2.
since maxsat does not have native support for criteria organized in a lexicographic order we need a way to com municate such order to the solver.
a lexicographic order can be encoded as an optimization of a single function by given appropriate weights to the individual criteria .
in practice however it has been observed that it is signi cantly more e cient to optimize for each of the criteria individually .
in particular a solver begins by optimizing the most important criterion and xes the weight of the optimum once it has found it.
then it proceeds with optimizing the second most important criterion etc.
this technique is referred to as boolean lexicographic optimization blo .
more formally package upgradability problem considered as boolean lexicographic optimization problem is represented as follows lexmax f1 f2 f k s. t. h where fi i kdenote the objective functions to optimize and hdenotes the hard constraints.
the function f1has the highest priority the function f2has the second highest priority etc.
recent work on package management problems proposes solving iteratively as follows maxfi s. t. h fj mj j i wheremjis the optimum value for the cost function fj given that preceding functions have already been optimized.
in recent years di erent approaches for implementing have been proposed.
a special place is occupied by methods based on sat namely maxsat pseudoboolean optimization asp etc.
among these the use of maxsat has been shown competitive with alternative approaches.
there have been developed a number of maxsat based package upgradability solvers e.g.
inescp packup .
the use of maxsat entails encoding each fias a set of soft constraints i s this is done as described in the previous section.
at each iteration iit must be guaranteed that optimal values of the functions fj j i which were already found are xed.
fixing the value of fjis done by introducing additional hard constraints cnf fj mj where cnfis a function that constructs a cnf encoding of the constraint fj mj.
there are several ways to implement the function cnf fj mj but their description is out of the scope of this paper.
the reader is referred to for further details.
at each iteration the maxsat problem to be solved is characterized by a set of soft constraints i sand a set of hard constraints i h h vi j 1cnf fj mj .
algorithm shows a general schema of the blo algorithm based on maxsat.
given a set of hard constraints hand a list of optimization functions fi i2f1 kg it rst makes an initial check whether the problem has a solution line .
if yes each function fiis iteratively optimized using a maxsat oracle line and its optimal value is stored inmi.
the value miis then xed line and the next function to optimize is considered.
for complex package management problems e.g.
with more than a couple of functions to optimize current blo based solvers can require excessive run times.
for instance solving748algorithm general schema of blo with maxsat input h f1 f2 f k output m1 m m k if his satis able false otherwise 1ifsat h falsethen initial check return false 3foreachi2f1 kgdo i s cnf fi 5mi maxsat h i s maxsat call h h cnf fi mi fixing value mi 7return m1 m m k a problem can take more than seconds2 which is of course inadmissible in real world applications.
the situation gets even worse for the case of weighted formulas.
a possible solution is to trade optimality for e ciency.
one option is to use local search e.g.
.
unfortunately our attempts were unsuccessful in part because of the many hard constraints that must be satis ed.
as a result we focus on approaches that guarantee that the hard constraints are still satis ed.
for example one can use speci c maxsat algorithms that re ne upper bounds on the optimal value.
by so after reaching a timeout one can stop the maxsat solver and get some upper bound which can be treated as an approximation of the optimum value.
however the quality of the approximation done in such a way is typically low see section for experimental results .
moreover usually it is hard to even compute the rst upper bound.
thus it is not guaranteed that an instance will be solved within a given timeout.
this leads us to a hybrid approach to the package upgradability problem which is based on computing a subset maximal set of satis ed soft constraints instead of computing a cardinality maximum set of satis ed soft constraints.
the method is described in section .
.
.
approximation.
hybrid approach as noted above using maxsat solvers for nding exact and even approximate optima of individual optimization functions for complex package upgradibility problems is often not e cient.
this section is devoted to a pragmatic approach to the considered problem which performs very well on the most of the practical instances and provides high quality solutions.
the idea of the method consists in combination of the blo strategy described in section .
with e cient approximate algorithms for solving maxsat namely algorithms based on enumerating so called minimal correction subsets mcses e.g.
see .
definition .given a set of hard clauses hand a set of soft clauses s a set of clauses sis called a minimal correction subset if .
h sn is satis able .
h sn nfcg is unsatis able for any clause c2 .
an mcs enables us to approximate maxsat.
an mcs set gives us a subset of the soft clauses whose removal make the problem satis able.
the smaller this set is the 2see values of the timeout used in the latest misc competitions .more soft clauses are satis ed and thus better approximation of maxsat is achieved.
an important property of mcs is that it cannot be made smaller by removing some clauses.
in contrast maxsat unsatis es the smallest possible number of soft clauses.
intuitively mcses correspond to local optima and maxsat provides us with the global optimum .
hence the cost of an mcs gives us an upper bound on the solution of the maxsat problem.
for the case of unweighted formulas the cost of an mcs is its size the number of clauses in it for weighted formulas the sum of weights of all the clauses in the mcs.
recent work proposes a number of e cient algorithms for computing one and enumerating all mcses of unsatis able cnf formulas.
these algorithms turned out to perform extremely well in practice.
there are di erent possible ways to apply computation of mcses of a maxsat formula to the package upgradability problem.
however we mainly focus on the hybrid approach represented in algorithm while other possibilities are mentioned in section .
.
assume that sat maxsat and bestapprox calls can handle a given timeout and stop if it is exceeded.
this can be done in a manner of line of algorithm .
note that algorithm is assumed to be able to asynchronously respect given timeouts and halt the execution of maxsat and bestapprox if necessary.
also assume that currenttime cnf and computeapprox calls can be done e ciently and do not take signi cant computational time.
similar to the blo case the arguments of algorithm are a set of hard constraints has well as a list of optimization functions f1 f k. note that one of the goals of the approach is to be able to stop and return a solution or its approximation within a reasonable timeout.
thus the other two arguments are the timeouts teand tafor the exact and approximate parts of the algorithm respectively.
in order to take into account the time used algorithm rst assigns current time to variable t0 line .
similar to the blo case the algorithm checks whether the hard constraints are consistent see line .
the lines of the algorithm represent an implementation of blo that takes into account a time limit.
the algorithm tries to nd exact optimal values for as many optimization functions as possible until it runs out of time see line .
the next phase of the algorithm is approximation of the functions that were not optimized by blo.
the rst function to approximate is the last one that was timed out in the blo phase see line where jis assigned to be equal toi .
during this phase of the algorithm the second timeout value tagets used.
we assume that calling a function bestapprox see line computes the cost m0 jof the best mcs found by enumerating all mcses of the j th formula withing the given timeout ta.
observe that approximate valuem0 jin some case can be equal to the exact optimum mj.
variableakeeps the corresponding satisfying assignment of the formula.
with each new function that is successfully approximated value of ais updated.
when the second timeout tais reached assignment ais then used to compute approximate values for the functions that were not optimized nor approximated before see line .
recall that calling function computeapprox is assumed not to take signi cant time.
as a result algorithm produces a vector of found values m1 m i m0 i m0 k where each mi is an exact optimal value while m0 jcan be both exact and approximate value of the corresponding function.749algorithm hybrid approach to blo input h f1 f2 f k te and ta 1t0 currenttime 2ifsat h t0 te falsethen initial check return false 4else if currenttime t0 tethen return false 6i 7whilei kdo i s cnf fi 9mi maxsat h i s t0 te maxsat call ifcurrenttime t0 tethen break h h cnf fi mi fixing value mi 13i i 14t0 currenttime 15j i 16whilej kdo j s cnf fj a m0 j bestapprox h j s t0 ta ifcurrenttime t0 tathen break h h cnf fj m0 j fixing value m0 j 22j j 23whilej kdo j s cnf fj 25m0 j computeapprox j s a 26j j 27return m1 m i m0 i m0 k .
other approximation strategies in this section we list and brie y describe other possible ways of approximation in the package upgradability problem.
the simplest option would be to enumerate mcses or compute one mcs for a cnf encoding of the rst optimization function within a given timeout ta.
after that approximate values of each function fi i can be computed by a computeapprox call in a way similar to line of algorithm .
another option is to use the approach described in section .
but without the exact part i.e.
it would approximate individually as many functions as possible until the timeout is reached.
another alternative is to divide the value of timeout tainto several timeouts each can be used for approximating one function.
here values of di erent timeouts are not necessarily the same instead one can use more time for approximating the most relevant criteria.
and nally one could construct a weighted maxsat formula comprising all the optimization functions.
as noted above in practice using a maxsat approach for such a complex optimization problem is proved to be not e cient.
however instead of calling a maxsat solver one can again run an mcs enumerator.
each mcs found for the complex formula would approximate all the functions of the original problem.although there are many alternative ways of obtaining approximate solutions of the package upgradability problem that are based on computing mcses this article emphasizes the hybrid approach described in section .
.
the strength of the hybrid approach is that if it ispossible to nd quickly the exact solution it is returned.
however for computationally hard problem instances the approximate approach enables us to nd a good approximate solution.
overall the hybrid approach gives us the best of the two worlds the exact and the approximate.
nevertheless alternative approaches are also interesting from the user perspective and we return to this subject in section .
.
experimental ev aluation experiments described in this section were performed on a large set of benchmarks from the mancoosi international solver competition misc .
the experimental results were obtained on an intel xeon 3ghz with 4gb of memory and running fedora linux operating system.
the experiments were made with a seconds time limit and a 2gb memory limit.
.
experimental methodology the hybrid algorithm algorithm was implemented on top of the tool packup .
packup provides a framework for solving the upgradability problem and its source code is available online under the gnu license .
the developed prototype is referred to as packuphyb .
it accepts problem instances in the common upgradability description format cudf which is a standard format of package description proposed within the framework of the mancoosi project.
the underlying sat solver of the packuphyb solver is minisat .
.
packuphyb has three general modes of operation.
the rst mode called exact mode makes use of a maxsat algorithm and does lexicographic optimization by nding the exact optimum for each optimization criterion of the package upgradability problem as described in section .
.
the second mode implements the hybrid approach described in section .
namely algorithm .
recall that the hybrid mode is parameterized by two di erent timeouts.
the rst timeout limits the time of the exact solving while the second one limits the time of the approximate solving.
if the exact solver is not able to solve a problem within its timeout it stops and the approximation process starts.
the approximation is made for the rst criterion that was not optimized by the exact solver.
the third mode is aimed at emulating the tool p2 which is a well known package dependency solver currently used in eclipse ide.5similarly to p2 this mode of operation hereinafter we call it p2 mode hinges on the idea of lexicographic optimization and hence optimizes all the criteria iteratively as described in section .
.
moreover as an underlying solver intended for optimizing a criterion we use a pseudo boolean solver eclipsep2 which is a part of 4cudf was developed in the mancoosi as a package description language with rigorous semantics and thus more amenable to scienti c analysis.
however the language is as powerful as the package description languages used in the linux distributions.
instances1101001000cpu time s exact mode sec p2 mode sec p2 mode sec hybrid mode a performance of di erent modes of packuphyb exact mode011010010005 sec hybrid mode b exact approach vs. hybrid approach figure performance comparison the sat4j library and the basis of p26.
in case the eclipsep2 solver s execution process has timed out it can produce an approximate solution of the problem.
this enabled us to organize the comparison of the approximation quality between solutions found by the hybrid mode and the p2 mode.
the goal of the performed experiments is to show the advantages of the pragmatic approach proposed in section and implemented as the hybrid mode of packuphyb over the existing exact solver that participated in a series of the misc competitions.
first we demonstrate the number of instances that can be solved by the considered approaches.
next we compare the quality of the approximation produced by the p2 mode and the approach proposed in section .
.
experimental material the misc competition has several benchmark categories each is intended to emulate a real situation that can 6note that there is a speci c variant of the p2 solver p2cudf intended for solving package dependency problems given in the cudf format.
however it is not presented in our experiments here.
the reason is that for all considered instances it performs much worse than our mode of packuphyb that emulates p2.
a possible explanation of this is that the sat solver which p2cudf is based on does not use the well known watched literals and vsids heuristics due to patent reasons .table number of solved instances exact mode hybrid mode p2 modetimeout5 not solved occur if a user makes a request to a package management system.
our experiments include all these categories.
each benchmark category represents a problem of optimizing a number of optimization criteria.
the performance of the exact approach di ers for di erent benchmark categories and depends on the optimization criteria used.
there are various cudf les in the competition.
thus for categories the total number of package upgradability instances to solve is .
note that the size of the package universe taking into accout unique package names but not package versions in the considered benchmarks varies from to with an average value which is close to the real repository size around packages in debianbased linux distributions.
therefore the obtained performance results should mimic the behavior of the solvers on real world problem instances.
.
comparing performance figure 2a shows a cactus plot illustrating the performance of the considered modes of operation of the packuphyb prototype.
here it is convenient to use a logarithmic scale for the cpu time.
a typical user of a package management system is interested in having an answer to his request shortly.
therefore it is essential for a package upgradability solver to be able to solve as many instances as possible in a short period of time.
for this reason we separately consider a seconds timeout.
in seconds the exact and hybrid modes of packuphyb perform identically and are able to solve instances this is around .
of the total instances .
given the seconds timeout the p2 mode can cope only with instances.
considering a seconds timeout the exact mode can nd a solution for instances including the solved in seconds while the hybrid mode solves all instances.
recall that the hybrid mode starts the approximation by enumerating local optima for the problem within seconds and choosing the best of them.
an interesting observation is that by this it is still able to nd exact solutions it does not reach the timeout for instances.
the p2 mode can solve only instances around .
in seconds.
finally observe that for instances around .
the exact solver does not succeed in nding a solution within seconds.
figure 2b shows a scatter plot that compares the runtime of the exact and hybrid modes of packuphyb.
given the timeout the p2 mode cannot nd a solution even approximate of instances .
.
overall numbers of solved instances for di erent timeouts are represented in table .
.
approximation quality a solution of a problem instance is a tuple of integer numbers each represents a value found for one of the optimiza 751table quality of the approximation by the hybrid approach criterion index 5category of benchmarksparanoidavg.
max.
.
paranoid sizeavg.
.
.
max.
.
.
embeddedavg.
.
.
max.
.
.
slowlinkavg.
.
.
.
.
max.
.
.
upgradeavg.
max.
dist upgradeavg.
max.
trendy sizeavg.
.
.
.
max.
.
.
tion criteria.
the quality of the approximation for a particular criterion is represented by a value of the approximation error i.e.
value va ve ve where veis the exact optimum value and vais its approximated value.
for instance given tuples and that are an exact solution and an approximate solution respectively the approximation quality can be represented as a tuple .
note that due to the properties of lexicographic ordering there are situations when the approximate solution for a criterion jis better than the exact one e.g.
see j in the previous example but only if there is a criterion i i j such that its approximate value is worse than the exact value.
also note that optimization criteria in the lexicographic optimization are sorted by their priority the value of the rst criteria is the most important to optimize while the last criterion is the least signi cant.
hence it is preferable to have a smaller approximation error for the rst criterion that is optimized.
although the hybrid approach is able to solve all instances we can evaluate the approximation quality only for instances that are solved by the exact solver7.
also note that some of the instances might not have a solution.
thus in this section we consider not instances but only that are solved by the exact approach and have a solution.
the number of optimization criteria vary from to for di erent categories of benchmarks.
in our comparison of approximation errors for the hybrid and p2 modes we consider each optimization level separately.
since all benchmark categories have at least optimization criteria we consider instances for the rst two optimization levels.
there are and instances for the 3rd 4th and 5th optimization levels respectively.
cactus plots corresponding to approximation errors for optimization levels and are shown in figure 4a figure 4b figure 4c figure 4d 7since initially we did not aim at analyzing the approximation quality the exact mode of the solver was run for seconds only.
however getting more representative analysis of the approximation quality with a greater value of the timeout and with the use of a computing cluster will be an interesting topic of future research.
instance051015202530approximation error for crit.
instance 20020406080approximation error for crit.
figure quality of the approximation for the paranoidsize benchmarks category by the hybrid approach instances are synchronized and figure 4e respectively.
again the logarithmic scale is used in the plots.
as one can see in the presented plots not only the number of instances solved by the p2 mode is signi cantly smaller than the number of instances solved by the hybrid approach but also the approximation error of the hybrid approach is orders of magnitude better than the approximation error of the p2 mode.
observe that this holds for both and seconds timeout for the p2 mode.
since the p2 mode solves fewer instances we do not compare average approximation errors for the approaches.
instead detailed information about the approximation error for the hybrid approach is shown in table .
as an example a detailed graph illustrating the approximation error for the paranoid size category is shown in figure .
there are instances in the paranoid size benchmarks category and the number of optimization criteria is .
observe that the rst optimization level is not presented in the gure since for all instances an exact solution for the rst level is found.
note that instances in the remaining 2nd and 3rd levels are synchronized in the gure so that one can see the quality of the full approximation for di erent instances.
the maximal approximation error for the second criterion is while the average is .
values for the third optimization criterion are and respectively.
observe that the negativity of the average value is caused by many instances for which the approximate solution is better than the exact one.
instances 10110100approximation error for crit.
sec hybrid mode sec p2 mode sec p2 mode a level instances 101101001000approximation error for crit.
sec hybrid mode sec p2 mode sec p2 mode b level instances 101101001000approximation error for crit.
sec hybrid mode sec p2 mode sec p2 mode c level instances 101101001000approximation error for crit.
sec hybrid mode sec p2 mode sec p2 mode d level instances 101101001000approximation error for crit.
sec hybrid mode sec p2 mode sec p2 mode e level figure comparison of approximation errors for the hybrid and p2 modes7535.
related work the importance of sat based approaches to package management has been acknowledged in recent years .
original work mapped the problem into a constraint programming formulation .
opium proposed optimization approaches for achieving better results which are based on pseudo boolean optimization pbo .
related work for the eclipse ide project includes .
recent solutions which allow for specifying a number of optimization criteria are based on lexicographic optimization.
a number of approaches have been proposed which exploit a number of sat related technologies.
these include inescp aptpbo packup aspcud and newer versions of p2 .
of these p2 is the only tool that has been deployed and is being used by millions of users.
despite the importance of recent work towards added modelling exibility and better quality solutions computation of the optimum solution is unfeasible because of the large required run times.
as a result deployed solutions return any solution identi ed within a short timeout e.g.
this is the case with p2.
furthermore the importance of additional analyzes of software package repositories is illustrated by .
.
conclusions and future work managing package repositories poses a number of challenges.
indeed it is not uncommon to encounter repositories with dozens of thousands of packages.
each of these packages represents a software artifact or component.
and each of these components may interact with other components.
consequently when a user wishes to add a package to his or hers current con guration of packages it must be done so with care.
namely a package must not be installed if it conicts with one of the other present packages and along with the package all required packages must be installed.
this on its own causes installation or uninstallation of packages to be a nontrivial computational task.
this task becomes even more computationally challenging once we want to respect user preferences over the resulting package con guration.
for instance a typical user requires that the resulting package con guration di ers from the original con guration as least as possible.
altogether package managers need to address two types of objectives respect the requirements and con icts of the packages.
try to optimize for user criteria as best as they can.
recently a number of approaches for exact optimization of user criteria have been developed.
however such approaches do not have guaranteed runtime.
indeed it is not uncommon for a solver to need hundreds of seconds to nd an optimal solution.
unfortunately users are not willing to wait that long.
this paper proposes a technique of how to enable an exact solver to provide good approximate solutions whenever it is running out of time.
the proposed technique hinges on the concept of minimal correction sets mcs .
intuitively an mcs provides us with a local optimum i.e.
a better solution might exist but larger change to the package con guration would be required.
computationally computing mcses is far more advantageous than computing the global optimum.
in practice this means that an mcs can be computed within seconds for instances where the global optimum is not found for hundreds of seconds.using mcses contrasts with the approximation approaches used up to date.
there a complete solver would simply output the best solution that it has found so far.
such approach does not give any guarantee while in mcses we have the guarantee of local optimality.
this advantage is indeed con rmed by our experimental evaluation which shows that using the approximation based on mcses enables us to solve a larger number of instances and with better proximity to the optimum than the best so far method.
this paper implements and evaluates a hybrid approach which uses a maxsat solver for computing exact optima and mcses for approximation.
the maxsat solver is used for a given period of time to optimize the most important criteria and then approximation is used.
this enables us to give a response within seconds.
further these responses do not deviate too much from the optimum.
it should be stressed that the proposed technique is not limited to the use of maxsat solvers.
any existing exact solver can be combined with our approximation technique in the same way.
as such the technique enables an exact solver to provide responses of good quality even in very short timeouts.
the use of an mcses opens a number of avenues for future work.
several alternative way to integrate the approximation where already outlined section .
e.g.
the total timeout can be distributed di erently between the exact and approximate calculation.
beyond these alternatives other applications can be envisioned.
for instance one could start enumerating mcses and order them by a criterion di erent than a lexicographic one.
this would allow considering for instance criteria like leximin .
leximin is extremely interesting from the user perspective because it does not require the user to pick an order on the di erent criteria considered.
and indeed it is often hard for the user to prioritize one criterion over another.
instead the user wants all these criteria to be all good at the same time which is made more precise by the leximin order.
to our best knowledge there is no publicly available package upgradability tool supporting leximin or any similar order.
it is also expected that computing the optimum in the leximin order will be computationally much more di cult than for the lexicographic order.
yet the mcs technique enables integrating any criterion at low computational cost.
there are also several topics of interest not covered by this paper.
although the p2 solver is heavily used in practice for the eclipse ide package management system which maintains dozens of thousands of packages there are other state of the art approaches for package dependency solving e.g.
opium aspcud .
thus an interesting subject of future work is the comparison of the developed method to such approaches as well as to the known software tools widely used by millions of linux users every day namely apt for debian based distributions and zypp for opensuse .
zypp which is based on a modern sat solver is one of the rst success stories of applying sat technology to package management in popular linux distributions.
.