porchlight a tag based approach to bug triaging gerald bortis and andr van der hoek department of informatics university of california irvine irvine ca u.s.a. gbortis andre ics.uci.edu abstract bug triaging is an important activity in any software development project.
it involves d evelopers work ing through the set of unassigned bugs determining for each of the bugs whether it represent s a new issue that should receive attention and if so assign ing it to a developer and a milestone.
current tools provide only m inimal support for bug triaging and especially break down when developers must triage a large number of bug report s since those reports can only be viewed one by one.
this paper presents porchlight a novel tool that uses tags attached to individual bug reports by queries expressed in a specialized bug query language to organize bug reports into sets so deve lopers can explore work with and ultimately assign bugs effectively in meaningful groups .
we describe the challenges in supporting bug triaging the design decisions upon which porchlight rests and the technical aspects of the implementation.
we conclud e with a n early evaluation that involved six professional developers who assessed porchlight and its potential for their day to day triaging duties .
index terms bug triaging bug trackers tags.
i. introduction bug triaging is the process of determining first if issues reported in the bug tracker describe meaningful new problems or enhancements and second if they do assigning them to the appropriate developers and target release mile stones for further handli ng .
bug triaging has a particularly visible role in open source communities where it is not uncommon to find projects with hundreds if not thousands of open bug reports .
it is as important however in commercial projec ts especially because such projects can ill afford to ignore incoming issues.
bug triaging is most frequently associated with dedicated meetings scheduled regularly to prepare for the next phase s of development whether these phases are a coarse grained series of major releases release planning or a fine grained set of sprints in a more agile project .
however bug t riaging also takes place outside of such meetings .
it is very common for bug reports to be reassigned because an initial assignment may rely on an inaccurate assessment of the root cause of a bug a wrong impression may have been had of whom the expert is to resolve an issue or a certain develo per might become overloaded and the work must be re balanced among the available developers .
in the eclipse project for instance about of reported bugs were reassigned at least once .
bug triaging then is an on going activity .
the de facto tools used today in support of bug triaging are bug trackers with some of the more popular tools being jira bugzilla fogbugz and trac .
these tools are typically positioned as supporting the entire life cycle of a bug report from developers and users first report ing a problem encountered or suggesting a possible enhancement they might like to see to keepi ng track of the stage at which the bug is in its resolution cycle to eventually closing the bug and providing the developer and organization should they be interested with a variety of statistics and reports.
as a resul t bug trackers serve many uses beyond being the repository for all open bug reports including as the developer s to do list a user facing portal and a key communication hub for large open source projects .
naturally b ug triaging is one of the activities supported by bug trackers as the assignment and possible reassignment at a later time of a bug to a certain developer and certain milestone is part of the life cycle of a bug .
unfortunately e vidence is emergin g that this support is rather limited .
particularly in the open source community where triaging bug reports is a highly visible process and a responsibility that is distributed across the community concerns have been openly voiced.
as an example a former contributor to the moz illa pro ject posted on his blog an explanation for no longer contributing to the project stating that triaging is broken.
period.
he continues by explaining that the bug tracker they use bugzilla is ill suited for handling the la rge influx of bug reports from the community as part of a new release process right now there is no real way to triage except here is a list of bugs.
start at the top and work your way down.
we need a way to mark bugs that need triage ... but we also need to remember bmo is being used for things it never was created for.
the author calls for a new type of tool to suppor t triaging this is why i have envisioned a separate bmo product of bugs.
that way we can separate end user bug submission from the development process at least in the beginning stage .
we can add flags to bugs that while useless for developers are incredibly useful for triagers.
the author is also not alone in these thoughts.
other examples of concerned developers can readily be found e.g.
with at le ast one academic study backing up the need for a role orien ted bug tracker interface that emphasizes certain aspects of the tracker s data while abstracting others away including during the process of searching and triaging .
.
c ieee icse san francisco ca usa342 this paper introduces a novel software development tool porchlight which we designed explicitly to support bug triaging.
porchlight recognizes that a key obstacle to effective triaging with existing bug trackers is that they force a developer to work with bug reports one by one with significant overhead to move from one bug to a next .
triagers however have a need to deal with bug reports in meaningful groups e.g.
bugs that do not include a screenshot bugs that were reassigned three times or more bugs related to component x and filed in the past two days which except for a handful of predefined filters are simply impossible to achieve with current bug trackers .
especially when the number of open bug s is large it therefore becomes very difficult to triage effectively .
porchlight ameliorates this problem by letting developers explore work with and ultimately assign bugs in groups .
it is based on a novel underlying bug query language through which its users can flexibly tag bug reports to create bug sets of their choosing with a predefined list of bug set s available by default .
thes e bug sets are explicitly represented in the porchlight user interface and by turning them on or off act as filters on the full set of bugs.
as a result developers can quickly group and then examine related bugs in all sorts of ways giving them access to the bug repository based on attributes time patterns and even relationships among bug reports.
together with a small number of additional features that provide at a glance inspection of the historical actions associated with a bug report drag and drop assignment of bugs and reflection on the emerging workload of different developers and milestones porchlight thus enable s developer s much greater control over how they choose to triage a large repository of bugs1 effectively .
we evaluated p orchlight with six professional developers who frequently triage bugs for a major healthcare open source software package.
we first presented porchlight then asked them to work through a limited triaging session with a copy of the real bug database and concluded with a short interview that focused on comparing their experience with porchlight to the ir current practice of using jira .
reactions were positive with all of the participants either agreeing or strongly agreeing that the porchlight interface provided functionality that improved upon their triaging experience .
naturally the evaluation also uncovered some areas where porchlight can be enhanced .
porchlight builds upon our previous work on teambugs a prior version of porchlight that we presented in a page paper at the chase workshop .
compared to teambugs porchlight provides the following contributions tagging as a way to group bug reports a bug query language through which new tag sets can be created and a new evaluation .
the remainder of this paper is organized as follows .
section ii presents related work in the area of bug triaging.
section iii presents a set of requirements unique to triaging tools.
section iv details porchlight.
section v presents our evaluation and in section vi we conclude with an outlook to our future work.
note that w e use the terms bugs and bug reports interchangeably throughout the paper .
ii.
related work prior work on the bug triaging process has fallen into three research areas duplicate detection assignment automation and field studies of the triaging process .
work in the first two areas duplicate detection and assignment automation aims to reduce the burden on the developers who are involved in the triaging process.
work in the third category field studies of actual bug triaging processes aims to improve our understanding of how bug triaging takes place in practice and informs the design of future bug triaging tools.
a. duplicate detection the goal of duplicate detection is based on the recognition that not every single bug report refers to a unique bug.
giv en that most software is used by many different users when a new release introduces a bug it is not uncommon for that bug to be reported multiple times .
while on the one hand this benefits the triager s since they can readily recognize a serious issue because of the multitude of similar bug reports that are likely to be filed and some reports may include additional detail e.g.
a stack trace screenshot that may help them in triaging it is still up to the developer to process them all manually one by one.
duplicate detection techniques address this issue by identifying similar bug reports and in some cases merg ing them into a single bug report.
some of the early approache s use natural language processing over bug text description s to identify possible duplicates .
more recent approaches attempt to improve over pure nat ural language processing by includ ing analyses over runtime execution traces or by incorporating clustering techniques .
b. assignment automation the goal of assignment automation is to lighten the load for a triager by recommend ing for a given bug report who might be appropriate to resolv e it .
to date two predominant types of approaches have emerged machine learning techniques and statistical analysis techniques of bug tossing graphs.
in the first type o f approach features such as keywords and metadata are extracted from past bug reports and together with data linking these bug reports to the developers who then fixed them used to train a machine learning model .
the trained learner is then used to predict the proper developer for any new bug report that is filed .
several other studies refine the pure machine learning approach for instance by applying latent dirichlet allocation to categorize bug report s leveraging fuzzy set based modeling to automate developer assignments or incorporating a combination of an information retrieval technique and processing of source code authorship information to recommend develope rs .
the second type of approach relies on statistical analysis of the bug tossing graph.
a bug tossing graph captures the history of bug report reassignments from developer to developer and is used as the source for a statistical ana lysis that aims to detect repeated patterns e.g.
any time a bug is assigned to developer a that pertains to component x it is tossed to developer b half the bugs assigned to developer c are reassigned to developer 343d .
this approach can significantly reduce the number of reassignments while at the same time improving the accuracy of first time automated assignments.
c. field studies bugs and particularly bug histories have been the subject of quite a few studies e.g.
.
the process of b ug tracking and more specifically b ug triaging as relevant to our work has received less attention with only a handful of studies emerging to date .
most influential on our work is a study in which its authors conducted interviews with industry and open source developers to understand coordination problems that arise when managing bug reports in large distributed teams .
among many other insights t hey found that developers use a bug s relationship to other bugs in terms of their functional dependencies in order to determine how they should be triaged and in which order they should be assigned and resolved .
the paper further recognize s particular classes of bugs that require attention such as zombie bugs bugs that have been dormant for a relatively long period of time and hot potato bugs bugs that continue to be tossed from developer to developer without being resolved .
both observations point to a quite different way of exploring a bug repository one in which bugs are not explored in isolation but in relationship to each other whether that relationship is one of functionality or of similarity in the type of bug or bug history .
another fie ld study of bug tracker usage this time in a smaller collocated team setting reveals that the bug tracker serves as a boundary object and that participants in different roles leverage the bug report information in different ways and have different perspe ctives with different needs .
these findings suggest that for triaging a new perspective is needed that meets the requirements of a triager.
iii.
requirements for bug triaging while existing approaches such as duplicate detection and assignment automation clearly have made advances in easing the job of the developer when it comes to bug triaging in their current state they still require a person to drive the process as their success rate is insufficien t to rely on automation only.
the developer thus still faces inspecting each bug report making an assignment for it either by confirming the suggestion or choosing one on their own and moving on to the next bug all through manually navigating the b ug repository using the features available in the bug tracker .
for most developers this means using a web based interface to first search through a vast amount of largely unorganized bug reports for a subset of bugs in which they are interested.
they must then select a single bug and after some inspection and thought either decide to assign it to a developer and milestone or skip the bug for now .
they then return to the previous search results to select another bug often in an arbitrary order and star t this process all over again all without much if any feedback during the entire process.
rather than attempting to provide more accurate duplicate detection algorithms or automated assignment techniques with yet more precision we took a step back and b egan to focus on this overall process of triaging what is it that developers need to achieve and how can they achieve it effectively ?
with this question in hand we began to realize much like the mozilla developer we quoted in section i that to provi de effective tool support for triaging it is necessary to part with the bug tracker and provide triaging support through its own dedicated tool.
to guide the development of such a tool we relied on the observations in the studies we described in section ii our own professional experience and the kinds of observations quoted in section i and made in the open source community to identify a set of five key requirements to supporting bug triaging.
a. bug management the number of bug reports that must be tria ged in a typical large project can be overwhelming.
for example in the spring of the mozilla firefox project had approximately unconfirmed bugs that were unassigned to either a developer or a milestone with a multitude of new bug s being filed each day.
to make th e process of triaging these bug reports manageable a triaging tool should provide developer s with ways to quickly organize and sort the bug reports that is developers should be able to quickly get to a subset of the b ugs that they find interesting and change th is subset at any moment in time when they want to take a look at a different slice of the overall set of bug reports.
it particularly has to be possible for the developer to control which subset they want t o see.
while predefined sets are useful if only such sets are available they necessarily limit the ability of the developer.
consider the following examples of advanced types of sets that a developer might want to explore .
bugs which have no comments or replies from the community .
.
bugs which have gone for days with no reply or activity .
.
bug reports that have been reassigned multiple times to different developers .
.
bug reports filed within a week after the most recent release that include a screenshot or stack trace and come from users who have filed reliable bug reports in the past .
these and other sets like it should be easily obtainable by the developers.
in fact if they so wish these sets should not just be viewable but also assignable in their entirety to a particular developer or milestone .
an especially realistic scenario is set above the bug reports likely contain enough information to be triaged relatively quickly.
b. ad hoc grouping situations arise when developers cannot immediately triage a bug until more information is obtained or other bugs are first triaged .
to support this a bug triaging tool should provide support for ad hoc grouping of bugs i.e.
the manual creation of sets of bugs that are seemingly unrelat ed but of importance for the developer to keep track of.
this allows developers to set aside bug s that may require follow up from the reporter need additional information from another developer or can only be triaged after the workload across the developers is determined from triaging other bugs.
344supporting ad hoc grouping is especially important in open source projects where many unconfirmed bug reports require follow up from the reporter with more details stack traces or screenshot s .
it should also be possible to persist any ad hoc groups across sessions so they can be used a starting point for a future triaging session.
new triagers too may want to use ad hoc groups as a way of putting bugs aside for review by mo re experienced developers while still contributing to the process in assigning th ose bug reports that they can clearly handle .
ad hoc groups also may be used as tentative plans.
rather than making definite assignments bug by bug a triager can use an ad hoc group to create a planned set of bug assignments for a given developer or milestone that they do not quite commit just yet .
if one of the developer s is already overloaded for instance it may still be desirable to assign him some bugs that he or she is most qualified to address.
so through an ad hoc group allows the triager to safeguard against dumping too many new bugs on the developer.
particularly if at the end of the triaging session only a few bugs exist in the ad hoc group they can then be assigned as a whole but if there clearly are too many some can be reassigned first to other developers .
c. instant feedback in existing bug trackers after a decision has been made to assign a set of bugs to appropriate developers and milestones all of that information moves to the background.
the triager has no easily accessible cumulative record of their decisions other tha n their personal memory.
this is a problem as triaging decisions are not just based on which developer is the suitable person to work on a bug but also on the desire to appropriately manage the emerging workload of each developer and evenly distribute new feature requests across release s .
having this information available instantly as bug reports are assigned can serve a s valuable feedback during the few minutes allotted to each issue and assure that one particular developer or milestone is not overloaded.
once an assignment has been made the effects of that action on the workload should be visible to provide awareness of the impact on the project.
similarly a triager should be able to gauge their progress in handling the current set of bug reports .
particularly they should be provided with up to date counts of how many bug reports are left to triage in each set that they are working with.
d. rich bug histories another important factor when assigning bugs is the history of activities related to the issue .
the fact that s ource code has been committed to the bug comments from developers and users and any status changes or reassignments are examples of the kind of information that should be at hand when developer s are making triaging decision s. for instance a bug that has been repeatedly reassigned to a later milestone may indicate that the bug report does not contain sufficient information or that it is difficult to identify a developer with sufficient expertise .
such information may well influence the actions of the triager who instead of simply assigning the bug may send a request for more information to the reporter or contact the developer who was originally assigned the bug to learn what e xpertise is needed to address the bug .
in the ideal case the information should be summarized for at a glance examination and interpretation but at the same time any details should be readily obtainable when they are needed to make an informed decision .
e. single context it goes without saying that t he process of assigning a bug to a milestone or developer must be lightweight and require little effort.
when dealing with hundreds or thousands of new bug reports developers should be able to efficiently work through the bugs and make assignments.
particularly assigning a bug should not disrupt triaging or alter the context created by the developer .
existing bug tracker interface s require developers to first search for a list of bugs to triage.
viewing more de tails about a bug creating a new filter or simply putting a bug aside for triaging at a later time all require leaving the list and losing the context.
it is crucial to avoid such context switching.
this means that the same interface must support bug ma nagement and ad hoc grouping visualization of bug histories feedback and assignment of bugs to developers and milestones.
iv.
porch light to explore these requirements we designed and developed porchlight a novel bug triaging tool.
in this section we detail the key design decisions underlying porchlight show how its basic features already change the process of triaging highlight the advanced features through which its full power is unlocked and provid e a brief look at its implementation details.
a. key design decisions we explored a range of alternative metaphors in designing porchlight including a stacking metaphor each bug report is represented by a notecard and notecards are sorted into stacks to represent desired groupings a network metaphor each bug report is a node in a network that the triager can navigate and configure and a grid metaphor each bug report is represented by a tile in a grid that the developer can reshuffle at will .
ultimat ely we chose to adopt a tagging metaphor.
tagging has emerged over recent years as a powerful technique that is applicable in many different situations e.g.
managing e mail collaborating through work items annotating online media .
moreover every bug tracker internally already relies on a set of predefined tags and in some projects it is now recommended to first organize bugs using tags before triaging them chromium being the prime exampl e .
tagging too is an easy way for a community to establish norms and communicate them to new contributors who may wish to help in the triaging process.
we thus choose to expand on this emerging practice instead of hiding or restricting the tags available porchlight puts them front and center to the experience.
this leads to the following four design decisions underlying porchlight .
leverage tagging to organize bug reports into tag sets .
it is not sufficient to just rely on the presence of tags to say that bug triaging is now better supported.
rather the tags should be leveraged to provide higher level functionality to a triager.
in porchlight every unique tag automatically 345provides an index into the full set of bug reports to create a tag set.
these tag sets become one of the primary ways of exploring working with and assigning bugs.
.
provide a set of de fault tag sets together with filters for common tasks.
triagers should not have to construct their view o f the bug reports from the ground up each time they triage.
porchlight therefore includes default tag sets that represent subsets of bugs commonly needed during triage of a bug database.
further it combines the default tag sets with filters that operate o ver the currently selected tag sets to reduce the number of bugs being viewed.
.
provide a bug tagging language to support attaching tags to individual bug reports .
it is impossible to predict all of the needs of triagers in terms of what exact subset of bug s they may be interested in at a given moment in time.
as a consequence it is necessary to allow a triager to construct their own tag sets.
porchlight provides a specialized bug tagging language called btl that allows for the creation of new tag sets.
b. basic features figure shows the porchlight user interface.
upon starting porchlight users are presented with a project selector top left currently mirth connect is selected that is populated with a list of projects recorded in the bug tracker to wh ich porchlight is connected as we shall discuss in section iv.
e porchlight is implemented as a separate interface to an existing bug tracker pulling all its data from this bug tracker and recording all of the triaging decisions in it as well .
selecting a project from the list leads to three other lists being populated a developer list on the left of the interface a milestone list on the right and the list of bug reports in the middle .
the developer list contains all individuals who to date have contributed to the data in the bug tracker in any way including opening resolving or commenting on a bug.
in a typical open source project this list can become very long given th at many different individuals may submit bug reports.
the list therefore consists of two blocks the first block listing developers and the second block listing people who only submit bugs or comment on them.
each block is sorted alphabetically to make it easy to locate developers to be assigned and the number of bug reports assigned is shown on the label for each developer i.e.
bug reports have overall been assigned to jacobb .
the milestone list holds all of the milestones for the project with t he labels providing a count of the number of bug reports that are assigned to each milestone.
note that the milestone list includes both released and unreleased milestones as it is not an infrequent occurrence that a release contains bugs that were not resolved yet.
in such cases the triager still has to have access to the bug for further handling and rescheduling it to an upcoming release and know where it was originally to be addressed.
the bug list is populated with all of the bug reports in the project presented linearly with newer bugs at the top and older bugs at the bottom.
the triager navigates this list by moving up and down either with the mouse or using the keyboard .
when they do so and encounter a bug that has already been assigned the de veloper and milestone to which it is assigned are marked.
for instance in the figure mirth is selected and shown to be assigned to geraldb and milestone .
.
.
selecting a bug from the bug list also displays details from the bug report .
this includes a summary of the bug any tags that have been associated with the bug see section iv.c a full description of the bug and the event timeline.
the event timeline displays in an at a glance manner the activity that has occurred on the bug repo rt.
the starting date for the timeline is the date the bug was created and the ending date is the date of figure .
porchlight user interface.
346the last activity.
actions taken in relation to the bug such as commenting committing source code or reassigning appear as colored markers.
each event type is assigned a different color to make it easier to distinguish them in the timeline.
clicking a marker reveals the details of the activity for instance in the case of a commit the list of files associated with that commit is shown togeth er with the types of changes made to each of the files added modified or deleted .
to make it easier to quickly iterate through the events on the timeline developers can use the left and right keys to scroll backward and forward through the timeline.
to quickly filter the bug list to a subset based on the status of the bug report developers can use the quick filters at the top of the interface.
marking any of these filters reduces the list of bugs in the center of the view to those that match the s tatus of the filter i.e.
bugs that are unassigned to either a developer or milestone have a specific status open resolved closed or belong to an active tag set see section iv.c .
finally a search box allows the developers to search the bug reports textually just like they currently can in an existing bug tracker.
any bug report in which some portion of the text or metadata matches the provided search term is included in the resulting bug list.
actual assignments are performed through drag and drop a bug or set of bugs that has been ctrl clicked is dragged onto a developer or milestone on the left or right of the interface.
the respective count of the developer or milestone is then updated to reflect the action taken after a bug or set of bugs is dropped.
together these basic features already change the nature of triaging.
they address requirements as presented in section iii developers receive visual feedback on the actions they take particularly on bug assignment a rich bug histo ry is available for the triager to take in at a glance and explore in more detail if so needed and perhaps most importantly porchlight offers all of its functionality in a single interface that avoids the need for explicit context switching i.e.
the b ack and forth syndrome of existing bug trackers .
our design makes it feasible to assign a bug without leaving the current triaging context.
organizing sorting and filtering bugs viewing of the details and history of individual bugs and assigning bugs are all available at hand.
c. tag sets porchlight s basic features make it possible for a developer to assign groups of bugs to developers and milestones i.e.
by using ctrl click to select multiple bugs and then dragging them to the desired developer or mil estone but not necessarily very convenient.
triagers still must manually select multiple bugs and there is nothing they can do with the collective other than assigning it.
to better support developers in exploring working with and assigning groups of b ugs porchlight employs the concept of tag sets.
a tag set is an explicit entity that provides an index into the overall set of bug reports to identify some subset.
each tag set has a name and a color associated with it and each can be selected or deselec ted independently from the other tag sets.
figure shows the tag set part of the user interface with at five tag sets available to the triager .
geraldb popular hot potato and zombie .
enabling a tag set has two effects in the bug list it colors every bug report belonging to it and to the left of the bug list it puts a colored marker making it possible to identify bugs that belong to multiple tag sets .
if so desired the bug list can be sorted by clicking the has active tag filter and then clicking on the tags column header.
the list will be sorted by number of tags that is bugs belonging to multiple tag sets will appear at the top and bugs belonging to none at the bottom of the list.
the four different kinds of tag sets supported by porchlight are predefined tag sets developer and milestone tag sets ad hoc tag sets user defined tag sets.
predefined tag sets .
porchlight includes predefined tag sets that provide groupings that are commonly used in triag ing.
the creation of such groupings should not be necessary for a triager to specify each time they work with porchlight.
this includes tag sets for bugs that popular bugs that have had more than three comments.
missing details bugs that do not have a screenshot or stack trace attached.
hot potato bugs that have been reassigned twice or more.
zombie bugs that have been open more than one month and have had no activity.
these tag sets are always available to the triager.
developer and milestone tag se ts.
sometimes it is useful for a triager to see all the bug reports associated with a developer or milestone.
in porchlight this is a very simple action to perform drag the developer icon from the list of developers on the left or the milestone icon fr om the list of milestones on the right to the tag set area.
this creates a new tag set automatically that can henceforth be used.
ad hoc tag sets .
the second requirement we discussed in section iii motivates the need for ad hoc tag sets setting aside bugs that cannot be immediately triaged grouping bugs that might seem unrelated but that the triager wants to keep together or keeping track of tentative plans to be confirmed later.
porchlight supports such ad hoc tag sets by allowing triagers to select an y bugs from the bug list and dragging them one by one or as a group after ctrl clicking them onto one of the listed tag sets.
if a new tag set must be created first they can drag to an empty area in the list which brings up the tag set settings dialogu e see figure in which the where field is pre populated .
user defined tag sets.
the same tag set settings dialogue can be used to create user defined tag sets tag sets where the set of bugs that is included is determined by a bug tagging language btl see section iv.d statement.
this feature is particularly important since triag ing is a dynamic activity where the set of bugs of interest changes over time and cannot be predicted a priori nor does it always follow convention.
triagers must be able to quickly get to such a set and btl provides this ability.
btl statements act like sql queries and dynamically select all of the bugs that match the criteria provided.
in figure for instance a new tag set is being created that represents all bugs assigned to geraldb with at least comments attached.
347combined these four types of t ag sets transform the central bug list of porchlight from a list to working area in which the bugs can be organized through enabling and disabling tag sets using the filters and sorting the list worked with by selecting bugs of interest and viewing t heir details assigning them to ad hoc tag sets and assigned by dragging either individual bugs or entire tag sets onto developer and milestone icons .
all the while porchlight gives clear visible feedback on the actions that the triager performs thr ough the already described counts on the developer and milestone icons the coloring of individual bugs in the bug list and the markers that indicate to how many tag sets a bug belongs.
given that this information is available at a glance a triager can f lexibly move back and forth between the higher level task of organizing and finding bugs and the lower level task of inspecting and if so desired assigning bugs without losing the overall context in which they are working.
combined then the basic featur es described in section iv.b and the tag sets described here cover all of the requirements we laid out in section iii.
we briefly note two additional functionalities.
first at any moment in time it is possible to update the btl statement of a tag set.
sim ply double clicking brings up the dialogue box with the current statement that can then be edited.
second all of the tags and tag sets persist across triaging meetings.
this means it is always possible to continue where one left off but also that the tag s and tag sets can become a vehicle for sharing common rules and criteria for grouping bug reports thereby establishing community norms .
d. btl btl is a sql like declarative language that allows for the specification of tag sets based on attributes both explicit and implicit that are available in bug reports.
explicit attributes are those captured as part of the bug report like the description or the affected release .
implicit attributes are those that are be derived by looking at a bug s history such as how often it has been reassigned .
table shows several e xamples taken from section iii .
the btl gram mar specifies three primary commands tag show and delete.
the tag command is used to tag a set of bugs using a series of clauses.
a clause can be a simple predicate e.g.
assignee geraldb a function e.g.
frequency comment or a time window expression e.g.
since last week s .
supported time window values for narrowing the scope of the clauses include free form expressions such as days or months .
the evaluation of a tag command results in a tag set being created and the associate d bugs being stored in a working memory section iv.e .
the show command is used to retrieve a tag set from the working memory so it becomes available to the triager in the user interface .
the delete command is used to remove a tag set and thus disassocia te all bugs with that specific tag.
the language is extensible since functions are not specified explicitly in the grammar but in the implementation.
it is thus possible to add new functions through plug ins.
for instance we plan to add support for functions that detect duplicates and functions that obtain relevant information from the configuration management system to allow statements such as tag bugs for gerald where committed geraldb true tag dupes of bug where status open and isdupe true e. implementation details since porchlight is not a standalone bug tracker but rather a new interface focused on triaging we implement ed it so that it integrates with and complements existing bug trackers.
this allows developers to cont inue using the ir preferred bug tracker for the roles for which it is best suited while triagers have a specialized interface to support the triaging process.
table .
example btl statements.
selection btl statement bugs which have no comments or replies from the community tag no comments from community where status open and frequency community comment bugs which have gone for days with no reply or activity tag no activity where frequency comment and since last day s and status open bug reports that have been reassigned multiple times to different developers tag reassigned multiple times where frequency assign and status open bug reports filed within a week af ter the most recent release that include a screenshot and stack trace and that stem from users who have filed reliable bug reports in the past tag new bugs where status open and has screenshot true or has stacktrace true and reporter in reliable reporters and since after figure .
tag set settings dialogue.
348porchlight consists of two components .
the first component is the user interface we have describe d in the previous sections shown in the top right of figure which presents the architecture .
the second component labeled tag set processor serves as the back end.
it specifically imports bug reports and their metadata from a bug tracker evaluates btl statements maintains a working memory of bugs and tag sets and provides a plug in mechanism for extending btl.
the importer is used to import and map bug reports and associated metadata users comments source code commits etc.
from di fferent bug trackers into tsp s internal data store.
an importer interface is provided to implement importers for new bug trackers and configuration management systems.
for our purposes we built a jira and subversion importer.
the evaluation process begin s when a btl statement is provided by the triager .
the statement is then parsed and the resulting query is evaluated by matching it against the bug reports as well and certain derived attributes such as comment and assignment counts .
on ce the bugs have b een identified a new tag set is created in the working memory and the bugs are associated with the tag.
as mentioned the set of functions that btl supports can be extended .
since the btl grammar allows for any function to be invoked as part of a clause these functions can be developed as java classes that implement a specific interface.
these plug ins are loaded on initialization of the tsp.
v. evaluation to evaluate porchlight we recruited six professional software developers and project managers who work at a nearby software development company and perform triaging on a regular basis .
with each participant we conducted a minute evaluation session.
before each session we populated porchlight with bug reports from three different ongoing project s that the participants regularly contribute to either by reporting or resolving issues or by assigning bugs to developers or milestones.
the bug reports were imported directly from the company s existing bug tracker.
we then provided each participant with a tutorial describing porchlight including an overview of performing assignment using drag and drop between lists the activity timeline quick search and filters and adding comment s or updating the status of a bu g report.
we also introduced the concept of tag sets and provided a brief tutorial on how to create tag sets from sample btl expressions or by using drag and drop from developer or milestone lists .
we then asked each of the participants to complete a ser ies of bug triaging tasks using the bug reports from their project.
we first asked the participants to identify all bugs that had been assigned to particular developer and version.
we then asked participant s to identify all bugs that had been commented on at least three times in the previous two months.
when then asked participants to locate two open bugs and assign one to a developer and another to a milestone based on their knowledge of the bug s history and the project.
finally we asked participants to locate several bugs that we had identified as particularly interesting and asked them to explain what could be determined based on the information available in the tool .
as a final task we asked the participants if they could identify and if possible specify in btl any tag sets that they thought could be useful when performing their own triaging.
after completing the se tasks we invited the participants to provide feedback regarding their past experiences with bug trackers ways in which the process could be improved as well as their impressions of porchlight and its approach to bug triaging.
we then asked them to complete a question fivepoint strongly agree strongly disagree likert scale questionnaire rating their experience using porchli ght for triaging tasks as well as their openness to adopting porchlight as their triaging tool.
a. results the porchlight interface was well received.
in performing the tasks virtually all of the features of porchlight were used including tag sets and btl statements .
in task s that involved making assignments the participants made use of the drag anddrop assignment feature and several commented on the ease with which assignment was possible without needing to modify search filters or lose one s context.
all six participants agreed or strongly agreed that porchlight made it easy to identify bugs that needed to be triaged q1 avg.
.
as well as to perform the actual triaging q2 avg.
.
.
one participant commented might make a bit quicker because the interface is simpler.
it s a lot easier to get around you don t have to click too much so i think it would be very helpful for pre planning meetings and backlog reviews.
most participants made extensive use of the activity timeline noting the frequency with which some of the issues had transitioned from open to resolved and the source code modifications that accompanied each status change .
we received positive feedback on this ability to display multiple aspects o f a bug report in a single view.
one developer commented i would honestly use .
with the timeline and the filters it has the information i need.
i would just have it open all the time.
participants also commented that tag sets helped them save significant time with triaging since their existing bug tracker forces them to continuously switch between creating and figure .
porchlight architecture.
349managing filters viewing bug report details and making an assignment .
with tag sets they were able to identify the bugs that ne eded to be triaged using btl merge the tag sets and make the assignment in the same view.
several participants attempted to write their own btl statements to generate custom tag sets.
one was unable to write the statement since the attribute he wanted to use the time estimate for the bug was not available an oversight on our part since we forgot to include it in the bug metadata we imported .
others had difficult y recalling the syntax and resorted to explaining what they intended to include in the sta tement unsurprising since it is unrealistic to expect them to master the full syntax of btl in the relatively short time frame available .
all six participants however agreed or strongly agreed that tag sets were useful for triaging q8 avg.
.
.
one p articipant commented if you know how to use the tag sets it s really powerful because it lets you do anything.
and you can also use the btl statements ... it has a steep learning curve but other than that it gives you every option possible.
during th e open ended discussion several participants provided examples of tag sets they would use including bugs that have been reported by customers within the last few weeks as opposed to by the open source community .
bugs that have been recently commented on by a project manager or boss .
bugs that have been in the sprint backlog for longer than a few months .
bugs that have no time estimate set on them .
regarding potential adoption all six of the participants either agreed or strongly agreed that porchlight had functionality that would improve their triaging experience compared to their current bug tracker q9 avg.
.
and they would use porchlight as their bug triaging tool if it were made available q10 avg.
.
.
one participant commented could definitely replace because you can just sort it by backlog.
we can even try using it for one of our sprints and see how it goes because it has all the information you don t have to go to a different page and it doesn t screw u p by hitting the back button.
b. suggestions for improvement during the open discussion following the evaluation tasks we received numerous suggestions for how porchlight could be improved.
some of the suggestions were minor user interface changes like changing the developer and milestone lists to use decorators on the icons to indicate the assignee rather than showing the items as selected since it led them to believe that the items could be clicked on .
another common suggestion was to provide more inform ation in the timeline event details including the author of a comment and the date and time when the event occurred.
we also received feedback on more conceptual issues .
for example several participants felt that the developer and milestone list could be used as a filtering mechanism without having to first create a tag set.
also some suggested that the bug counts listed for each developer and milestone should be broken down in a more meaningful way for instance by showing the number of open and closed bugs or the number of new bugs assigned in the current triaging session .
there were also several comments regarding the activity timeline.
particularly some bug reports involved many events within a short window of time making it difficult to identify and select individual events to view the ir details.
numerous suggestions were proposed including showing only the time periods when the activity occurred and skipping long period s of inactivity or providing a way to zoom in to areas within the timeline.
finally several participants commented during the evaluation that not knowing the full extent of btl s capabilities resulted in a learning curve and that a guide to the attributes and functions that can be used in a btl statement should be made available directly in the user interface.
we recognize this concern but at the same time find it a validation of our approach since it demonstrate s that the participants were actively looking to use btl to create tag sets to filter the bug list but did not have sufficient information to do so easily .
we can address this in a subsequent version by including rich documentation and active code completion within the btl statement editor.
c. threats to validity comparative setting and bug tracker not representative.
all six participants work at the same company and use the same bug tracker for triaging jira .
their collective response s might therefore be biased toward a single current practice and tool since o ther projects could well have different practices or use d ifferent tool s. however there are striking similarities between the comments made by the participants during our evaluation regarding issues with their current bug tracker and those quoted in section i .
specifically the inability to quickly identify bugs that need to be triaged and then to perform the assignment without losing one s context was emphasized by both parties even though they work in very different contexts with different bug tracking tools .
limited participant sample size.
we acknowledge t hat s ix participants are insufficient to draw strong conclusions as to the benefits of porchlight .
however as a preliminary study the level of enthusiasm displayed by the participants is indicative of the potential of porchlight in addressing pressing triaging problems and determining this potential was the initial goal for this evaluation.
it is also worth noting that the author of the blog post we quoted in section i when contacted to request permission for the quote and expla ined our goals became interested and has asked us to provide him with our paper and findings.
clearly people recognize that porchlight seems to fill an important gap in the current tool spectrum .
representativeness of the tasks.
we realize that asking the participants to perform a handful of triaging tasks is not the same as asking the m to actually perform triaging live using porchlight.
this risk is mitigated to an extent because we preloaded the tool with bug reports from the project s bug tracker and asked the participants to perform tasks that represent what they would normally do in a triaging meeting finding certain kinds of bugs assigning them etc .
350vi.
conclusion bug triaging is a crucial activity in any software project but has recei ved little attention to date particularly when it comes to dedicated tool support.
this paper contributes porchlight a novel bug triaging tool that offers a unique tag based interface.
shaped by a set of five requirements porchlight offers triagers the ability to explore work with and assign bugs in groups that are identified through queries expressed in btl our novel bug tagging language.
with porchlight triagers no longer need to manually click through pages and pages of bug reports manage filter s and bookmarks that are uncoordinated or experience the frustration of losing the context of a triaging session.
to assess porchlight we performed an evaluation with six professional software developers who frequently act as triagers.
we are encouraged by the results and the feedback particularly with the ready adoption of the concepts underneath porchlight in conducting the triaging tasks as well as the enthusiasm that the participants expressed and their desire to explore the use of porchlight in fut ure actual triaging meetings.
we are keen to continue this work.
first and foremost we will take the feedback from the participants in refining the user interface of porchlight particularly in providing triagers with more refined feedback in their actio ns and in assisting them in specifying btl statements .
second it is clear that the next step is to deploy porchlight and examine it in action in actual triaging meetings.
finally we see several opportunities for broadening the functionality of porchlight including integrating duplicate detection and automated assignment techniques by letting their results serve as advice to triagers.
acknowledgment s this work was sponsored in part by nsf grant iis .
we thank wayne huang for his help in implementing the porchlight user interface and also mirth corporation for their assistance with the evaluation.