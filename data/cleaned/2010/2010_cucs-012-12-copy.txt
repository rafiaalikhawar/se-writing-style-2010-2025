chronicler lightweight recording to reproduce field failures jonathan bell nikhil sarda and gail kaiser department of computer science columbia university new york ny email fjbell kaiser g cs.columbia.edu ns2847 columbia.edu abstract when programs fail in the field developers are often left with limited information to diagnose the failure.
automated error reporting tools can assist in bug report generation but without precise steps from the end user it is often difficult for developers to recreate the failure.
advanced remote debugging tools aim to capture sufficient information from field executions to recreate failures in the lab but have too much overhead to practically deploy.
we present c hronicler an approach to remote debugging that captures nondeterministic inputs to applications in a lightweight manner guaranteeing faithful reproduction of client executions.
we evaluated c hronicler by creating a java implementation c hronicler j and then by using a set of benchmarks mimicking real world applications and workloads showing its runtime overhead to be under in most cases worst case while an existing tool showed overhead over in the same cases worst case .
index terms debugging aids software maintenance error handling and recovery maintainability i. i ntroduction while software may behave properly under testing prior to deployment it can be difficult to fully anticipate all possible usage scenarios and configurations in the field where software is required to operate on different operating systems and in conjunction with various external systems.
reproducing field failures in the lab can be difficult especially in the case of software that behaves nondeterministically relies on remote resources or has complex reproduction steps.
even when endusers file bug reports it can be difficult to coerce users to provide detailed enough steps to reproduce the failure .
to bridge the information gap remote debugging tools aim to automatically capture information from the failing code and transmit it to developers.
a typical approach to remote debugging captures the state of the system just before a bug is encountered .
however unless such a system knows in advance that a bug is about to be encountered it is impossible to provide developers with the exact state of the system before the bug is encountered unless that state is constantly logged in anticipation of a defect.
this approach tends to produce high overheads reaching overhead in the deployed application which may make it unacceptable for many uses.
novel solutions that lower this overhead typically limit the depth of information recorded e.g.
to use only a stack trace rather than a complete state history or the breadthof information recorded e.g.
to only record information on a particular subsystem that a developer identifies as potentially buggy .
while these approaches can reduce overhead significantly to a best case of with worst cases over they do not guarantee reproducibility.
specifically limiting the depth of information gathered may fail to reproduce an error if the defect does not present itself immediately.
imagine a program that reports its stack trace along with each parameter for those methods upon encountering a bug and contains among others methods a andz.
method asets a heap variable v and method zreads it.
the program calls method a which sets vto an invalid value and later on calls method z which reads the invalid value in vand crashes.
in this situation a stack trace would show the invocation of zbut not the invocation of a as it occurred in another branch of the execution tree.
similarly by limiting logging to a specific subcomponent of an application it is only possible to reproduce the bug if it occurred within that subcomponent.
this technique requires that developers know a priori which sections of code will be likely to crash and if they select too many the performance of the system degenerates to the case where everything is logged.
these systems work well if it is clear to the developers what section of code is most likely to crash but if they select too large of a subsystem the performance benefit shrinks.
in this paper we present c hronicler a technique that supports remote debugging by soundly capturing program execution in a manner that guarantees accurate replay in the lab with very low overhead.
in addition to simple standalone applications c hronicler supports accurate and efficient record replay of execution of client server applications.
chronicler only logs sources of nondeterminism allowing for a lighter recording process while still supporting a complete replay for debugging purposes.
when a failure occurs c hronicler generates a test case that consists of the inputs that brought the system to fail which allows any bug that presents itself during execution to be replayed regardless of the time between failure and detection.
this is a general approach that can be applied to any language that runs in a vm for instance java or microsoft s .net clr requiring no modifications to that vm.
we demonstrate the feasibility of c hronicler by implementing it in java and found thatthe overhead for real world applications was minimal .
in the case of eclipse performance tests .
for tomcat .
the main contributions of this paper are a presentation of our remote debugging tool that guarantees bug reproduction c hronicler chronicler j an implementation of c hronicler for java available for download and use now on github .
a thorough evaluation of its performance demonstrating its low overhead on real world applications our approach relies on an efficient record and replay system that could be be used by the community to further explore areas such as test suite generation existing tools impose high overhead but could be run offline on captured executions process migration existing tools require os extensions or additional developer effort efficient checkpoint and restart for vm based languages existing tools are not suited to vm based languages the record and replay technique used by c hronicler can be applied to these lines of research to ameliorate performance burdens that have been holding back greater development.
the rest of the paper is organized as follows.
in section ii we discuss related work in the field of record and replay systems ubiquitous error reporting and test case generation.
we elaborate on the c hronicler approach in section iii and present implementation details for c hronicler j n section iv.
our empirical evaluation of c hronicler and a comparison with another bug reproduction tool is presented in section v. in section vi we discuss some of the limitations of c hronicler .
finally we conclude and outline some ideas for future work.
ii.
r elated work there are several widely used systems for collecting runtime information to diagnose failures.
microsoft s windows error reporting tool has been in use since and has collected billions of error reports since then .
this tool collects system information after the point of crash such as register contents thread stacks hardware specifications and with the user s permission transfers it back to the vendor for analysis.
apple s iphone os error reporter and firefox s breakpad are similar reporting system state after a crash.
while these systems have minimal runtime overhead they are dormant until after an error occurs their reports do not contain steps to reproduce the crash nor a test case.
the developer must still infer the cause of the crash a problem that c hronicler aims to solve.
more recently tools have been developed specifically to generate test cases to reproduce errors caught in the field.
bugredux uses symbolic execution to guide the synthesis of tests that can reproduce failures from four different kinds of execution data points of failure call sequences and complete program traces.
the runtime overhead imposed by logging call sequences varied from to nearly .
however its ability to reproduce an observed failure is dependenton the completeness of the set of intermediate states which are used to guide the synthesis of the tests.
if the states extracted from the execution traces are incomplete then the observed failure may not be reproduced.
c hronicler has the same end goal as bugredux to generate test cases that reproduce field errors but uses an approach that can guarantee reproduction.
bbr is a system that uses symbolic analysis to re create program runs that are isomorphic in execution paths for long running programs such as databases and web servers.
while the states generated by bbr might reproduce the execution path that lead to the error they are not identical to the original state.
with c hronicler the actual state of the system from the point when recording commences is preserved.
recrashj is a java based tool that automatically generates test cases when software crashes.
recrashj maintains a log of method arguments for the entire call stack and in the event of a crash uses the log to create a test.
the system is limited in performance showing overhead as high as or depending on the logging method used presented here in descending order of soundness the approach does not maintain copies of the state .
while a second recording mode exists that is lightweight in comparison it requires that a crash be reproduced a second time in the field which may be unacceptable if the crash leads to a loss of data.
recrashj is also limited in applicability to failures that present themselves in deep call stacks if the stack depth is too low the information collected may not be enough to reproduce the same failure.
scarpe is a bug reproduction tool that requires developers to annotate their application to show component boundaries and captures interactions between the classes of interest and external code.
this approach can be quite efficient when the component selected for logging has limited external interaction but in other cases the overhead is as high as .
in contrast to scarpe which captures inter component interaction within an application c hronicler records interactions between the application of interest and its environment.
at their core systems such as c hronicler recrashj and scarpe are essentially record and replay systems.
record and replay systems capture program execution and deterministically replay it.
some of the earliest such systems were machine wide aimed to debug operating systems .
unlike c hronicler these systems capture everything running on the machine rather than within a specific program and are invasive requiring custom hardware a modified operating system or a specialized virtual machine.
liblog and mugshot are two application level record and replay systems very similar to c hronicler .
liblog is a tool for c applications to record and replay all interactions between the application and the operating system by providing a libc wrapper.
however this approach is insufficient to capture all sources of nondeterminism in c programs which can interact with the outside system through mechanisms such as shared memory or asynchronous intercepts and therefore can not guarantee complete replaychronicler applicationinstrumented for loginstrumented for replayused in the fieldbug successfully reproduced in the labchronicler generatestest casecrashesdeployedbug fixed by developercreatescrashesfig.
high level overview of c hronicler concerns that are addressed by a vm .
additionally liblog does not support logging multithreaded applications which chronicler supports by maintains a log for each thread.
chronicler s approach is fundamentally very similar to liblog in that both systems log nondeterminism although key to our approach is the mechanism in which we intercept the nondeterministic calls.
a direct application of liblog to a vm based language would necessitate modifying the vm or the core language api whereas our technique involves instrumenting the byte code representation of the program.
chronicler takes advantage of the portability of vm based languages while liblog only runs on systems that use the libc library.
mugshot is a record and replay system targeting javascript applications with the same underlying technique as liblog using javascript reflection to intercept nondeterministic inputs.
mugshot imposes low overhead both in terms of storage and computation for interactive games .
c hron icler is very similar to both tools in that it too achieves low overhead record and replay by capturing sources of nondeterminism.
however the principles involved in mugshot s implementation are not generally applicable to vm based languages as the interception technique based on reflection can be a computationally expensive operation particularly in the jvm.
mugshot also is designed to function in the limited execution model of browser based applications based on non preemptive callbacks which is not the case for other languages such as java with a rich execution model full multithreading support and many more sources of non determinism than javascript.
r2 is an application level record replay system that is similar to liblog but improves upon it in a few ways.
while liblog intercepts calls to low level libraries such as libc r2 requires developers to annotate the application interfaces they wish to replay.
this allows developers the flexibility of choosing an interface whose interception will cause low overhead as well as to bypass liblog s limitation of not guaranteeing faithful replay.
conversely this implies extra work for the developers to manually annotate the apis they care about while c hronicler automatically determines the correct methods to annotate without developer input.
although several record replay systems have been describedin the literature only a few target the jvm.
dejavu was one of the earliest jvm based record and replay systems.
however it required invasive changes to the jvm which limited its potential for widespread adoption.
jarec and leap are record and replay systems for java applications that specifically target replaying thread interleavings.
jarec suffers from high overhead ranging from .
leap records less information only partial thread access information which allows it to display much less overhead around on tomcat and derby but up to in the worst case depending on thread accesses .
both only record thread interleavings and no other inputs however and cannot faithfully replay a recording unlike c hronicler .
jrapture is a java record and replay system designed to be used for profiling executions after they have been captured.
jrapture uses an overall approach similar to c hronicler but requires modifications to the core jre api libraries which complicate its widespread distribution.
preliminary performance testing showed jrapture to have overheads ranging from .
depending on the relative proportion of i o in the application being logged .
while test case generation tools e.g.
focus on generating test cases to increase test suite code coverage offline c hronicler generates test cases that specifically reproduce field failures.
iii.
a pproach the c hronicler approach relies on a simple principle if a bug occurs deterministically then reproducing it in the lab can be made trivial the developer need only run the program and the bug will present itself.
unfortunately software often fails to behave completely deterministically with inputs provided by outside systems via network file or console i o shared memory access etc from random numbers from system properties such as the current time or machine configuration or from thread interleaving.
hence chronicler records sources of nondeterminism in a program and replays them to reproduce the bug.
figure shows the overall approach to logging nondeterminism with c hronicler .
chronicler is designed to function in any vm style programming language where interaction outside of the vm is restricted to a finite set ofnondeterministic apilanguage vm .net clr jvm etc outside world sources of nondeterminism deterministic apiapplicationchroniclerlanguage apifig.
logging nondeterminism with c hronicler methods.
c hronicler runs completely within the vm and sits between the application and all sources of nondeterminism logging them as they enter the application code.
note that although thread interleavings are a source of nondeterminism that may manifest internal to the vm and are not logged.
this limitation is addressed further in section vi but does not prevent c hronicler from replaying non race bugs.
unlike systems like liblog and jockey that record nondeterminism at the granularity of system calls c hroni cler records nondeterminism at the granularity of the methods provided by the vm.
this distinction means that there will be a wider selection of methods that need to be logged as vm based languages such as java or .net typically provide a common library or api of utility functions.
for instance in order to read data from a file a programmer may have at their disposal methods to read by line by word or in a binary format into a byte array.
the liblog approach would record the underlying call from all of these methods that actually reads data from the file.
on the other hand c hronicler will record the invocation of each of the language utility methods such as to read a line rather than the native routine itself.
this approach removes the need to modify any languageprovided libraries and can result in performance gains for chronicler .
returning to our example of reading data from a file imagine an implementation of the readline method provided by the language that reads nbytes from a file into a buffer until it reaches a newline character.
rather than log the buffer every time that the underlying read method is called c hronicler simply logs the line that is eventually returned.
of course application code can also directly call native methods without utilizing the language provided api and these calls are logged as well.
once all nondeterministic method calls are identified chronicler instruments the application code to log the result of the call.
c hronicler logs a unique reproducible identifier for each thread to denote which log entry should be replayed in which thread.
the log is buffered in memory and flushed to disk as the log size increases.
we create a special case to handle event driven systems where the event dispatcher is part of the native code e.g.
swing in java .
in these cases nondeterministic input may drive the language api to fire events to listeners in client application code but the application never directly reads that input.
to reproduce these events we log each invocation of these listener methods so that we can fire them in the same ordering with the rest of our log.
this approach is complete by logging all sources of nondeterminism we can guarantee that we can reproduce the same execution and hence the same failure.
moreover this approach will reproduce a failure even if it goes unnoticed for some long time as long as the log files are retained for the entire period.
chronicler instruments the application to generate a test case and log file to transmit to developers upon encountering an error.
once the developers receive the test case and log reproduction is simple c hronicler re instruments the application code for replay rather than recording and then executes the instrumented application with the log file.
to instrument the application for replay we identify the same methods that we previously logged and replace the method calls with instructions to load the logged input values.
then we begin execution at the same entry point as the original failed execution and play back the log.
with this technique we allow developers to observe the entire execution and use existing automated debugging tools that they may already be comfortable with such as .
note that through the entire c hronicler approach no source code is necessary and all instrumentation can be performed directly on byte code.
in order to evaluate the performance of this approach we implemented c hronicler for java and the jvm although the approach is general enough to apply to other languages within the jvm e.g.
scala or other vms e.g.
.net .
iv.
i mplementation to further elaborate on the c hronicler approach we provide c hronicler j our java implementation of c hroni cler .
figure shows an overview of the c hronicler j implementation.
we describe its implementation in the following four core components a. detecting nondeterministic methods in the jvm our approach requires instrumenting the call site of every method in client code that receives nondeterministic input.
as we noted previously within the jvm the only way that code can receive nondeterministic input is if it makes a call that executes native non java code.
facilities for generating random numbers accessing system properties such as the current time ip address hostname etc or interacting with files and sockets are all implemented in native code.
therefore the first step to identifying nondeterministic methods in the java api is to scan the entire api and mark all methods that are native as nondeterministic.
however not all native methods are nondeterministic.
for instance the typicalin the labin the fieldin the labvisit each class in the application binary for deployment add logging code binary for replay in lab replace with replay codecopy value at top of stack completely cloning objects store cloned value and current thread identifier to logflush log to disk if fullread top value of this thread s logadvance pointer to next log entryadvance to next log file if reached the endapplication running in the field needs to logexecution replaying in the lab needs to read logfind every invocation of nondeterministic methodsinstrumentation timefig.
chronicler j implementation overview approach to copy the contents of an array is to use a native call system.arraycopy object source int sourceoffset object dest int destoffset int length .
while an array copy could be implemented in pure java the native approach is far more efficient as it results in directly copying the contents of the entire array stored contiguously in memory rather than an entry by entry approach.
this native method and many others implement basic tasks deterministically and efficiently.
we manually constructed a stop list of methods which are native but deterministic ensuring that the default classification for a native method was nondeterministic sacrificing performance for correctness rather than risking an incomplete log.
the next step in identifying all nondeterministic methods in the java api requires identifying all api methods that call the previously identified nondeterministic methods.
this process scans the api for all callers of nondeterministic methods and recursively marks those methods as well as their callers as nondeterministic.
c hronicler j also carries nondeterministic flags up the inheritance hierarchy this will for instance result in the interface method inputstream.read byte int int to be marked as nondeterministic since many of its implementers are.
since java exercises dynamic binding it may be impossible to know statically exactly which implementation of a method will be invoked at run time and therefore we err on the side of caution.
at this point we have identified all api methods that call a method which behaves nondeterministically or return a nondeterministic result.
the final step is to identify methods which can behave nondeterministically because they share state with a nondeterministic method.
c hronicler j performs a very simple analysis to determine these methods marking all fields set by a nondeterministic method as tainted and then marking all methods that read those fields as nondeterministic.
similarly all owners of methods called by a nondeterministic method are marked as nondeterministic.
a more advanced control and data flow analysis could limit the number of methods falsely flagged as nondeterministic but we found the performance of this technique to be certainly adequate moreinformation on the performance of c hronicler j appears in section v a .
this process of carrying flags through the hierarchy repeats until the list of nondeterministic methods is stable.
finally chronicler j checks all classes in the application of interest as well as included libraries to build a list of any methods that directly invoke native code.
with this approach we guarantee detection of all methods that behave nondeterministically.
in this way c hronicler j builds a list of approximately methods on jre .
.
running on mac os .
.
that must be logged when called by the client code.
this entire process is integrated into c hronicler j so that it can be re run by developers for new releases of java.
b. logging chronicler j instruments all calls to the identified nondeterministic methods to record return values and buffer s if applicable .
all byte code instrumentation is performed using the asm byte code framework .
this log is buffered in memory and written to disk at regular intervals flushing the log to disk is described further in the following section .
the log buffer can have a hard size limit or optionally expand as necessary until it is flushed.
c hronicler j is thread safe and protects each log call with a barrier so that no two threads can log at the same time.
logging code is embedded inline just after the value that we need to log a return value or parameter is pushed onto the stack.
the instrumentation copies the object grows the log if necessary writes the object to the log writes the current thread to the log and flushes the log if necessary.
for completeness we also record events dispatched nondeterministically by the language api e.g.
swing actionlisteners so that the replaying application can fire them at the appropriate time.
when writing values to the log immutable types such as language primitives integer long short float double byte character and boolean and other classes such as string are simply stored as pointer