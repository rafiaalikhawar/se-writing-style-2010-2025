pietrace platform independent executable trace yonghwi kwon xiangyu zhang and dongyan xu department of computer science purdue university west lafayette indiana usa kwon58 xyzhang dxu cs.purdue.edu abstract to improve software dependability a large number of software engineering tools have been developed over year s. many of them are difficult to apply in practice because their system and library requirements are incompatible with thos e of the subject software.
we propose a technique called platform independent executable trace .
our technique traces and virtualizes a regular program execution that is platform dependent and generates a stand alone program called the trace program .
running the trace program re generates the original execution .
more importantly trace program execution is completely indepe ndent of the underlying operating system and libraries such that i t can be compiled and executed on arbitrary platforms.
as such it can be analyzed by a third party tool on a platform preferred by the tool.
we have implemented the technique on x86 and sensor platforms.
we show that buggy executions of realworld windows and sensor applications can be traced and virtualized and later analyzed by existing linux tools.
we also demonstrate how the technique can be used in cross platform malware analysis.
i. i ntroduction to improve software dependability researchers and engineers have developed a large number of software engineering tools over years.
although many of them have very advanced capabilities they do not gain popularity in practice.
one o f the issues is that they often require certain environmental sup port such as specific operating system libraries and the presen ce of some infrastructure e.g.
valgrind .
these requirements m ay be incompatible with those of the subject software.
for instan ce windows software cannot make use of the large body of linux tools.
a subject software that requires a new version o f libc can hardly use a runtime tool based on an older version oflibc .
in our personal conversation with researchers and engineers from coverityr circlecopyrt one of the most successful software testing and debugging service providers it was mentioned t hat making coverity s tools run on the customers machines and their software is one of the most prominent challenges.
they indeed have a team of developers whose responsibilities are solely in ensuring compatibility.
the team is even larger th an most of their tool development teams.
compatibility and platform independence are not a new challenge in our discipline.
in fact people have made a lot of progress in mitigating such problems in recent years.
the invention of virtual machines allows running different gue st operating systems on a singe host operating system.
however virtualization is performed at the machine level and hence applying a cross platform software engineering tool is sti ll difficult.
for example one cannot apply an existing linux to ol on a windows program execution even with the help of vmtechniques.
we also have excellent cross platform analysi s infrastructures such as pin that support both linux and window s such that a pin tool developed for linux programs only needs small modifications to adapt to windows programs.
however only tools developed on pin can benefit from this feature.
moreover pin only supports a very limited set of instructio n sets.
for example one cannot use pin tools to analyze sensor program execution.
programs and tools written in languages such as java are by their nature platform independent due to the presence of java virtual machine.
however there are many programs that run natively without any virtual machine support.
pietrace is focused on those programs.
modern compiler infrastructures e.g.
llvm also try hard to improve portability and mitigate cross platform issues .
they can compile code written in different languages and for diff erent platforms to the same intermediate representation ir such thatstatic program analysis written on these infrastructures can be used to analyze software from different platforms.
howev er it is only good for static analysis.
the execution of a progra m compiled by these infrastructures is platform dependent.
i n other words these infrastructures offer limited help in cr ossplatform application of dynamic analysis tools.
in this paper we propose a novel technique called platform independent executable trace pietrace .
our technique traces and virtualizes a regular program execution or part of it t hat is platform dependent and generates a program called the trace program .
a trace program is a stand alone program that can be compiled and executed on other platforms.
running a trace program re generates the original execution.
more precisely it reproduces an execution that exhibits the same user space control flow values and program dependences as the original execution .
trace program execution is completely independent of the underlying operating system and any library such that it can be on arbitrary platforms.
the applica tion scenario is as follows.
we provide a tracing virtualizatio n component for each platform that we support.
such components are written in infrastructures such as pin and sensor emulators.
executing a program on the component produces the corresponding trace program.
the trace program can be compiled and executed on any environment that a third party tool prefers.
for example one can compile and execute a trace program generated from a sensor program execution on a linux platform such that linux runtime tools can be applied .
our technique also supports projecting the analysis result s back to the original platform to facilitate in context hum an inspection.
c ieee ase palo alto usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.48compared to the traditional tracing techniques we do not require tools to support a specific trace format.
exist ing third party tools on various platforms that analyze program execution can be used to analyze trace program execution.
th is would greatly improve tool applicability.
moreover our te chnique does not require the physical presence of trace which is very resource consuming.
compared to traditional loggin g and replay techniques trace program execution ca n be cross platform even cross instruction set without req uiring the original os or libraries.
trace programs execute on thei r own without any replay runtime support.
our contributions are summarized as follows.
we propose the novel concept of platform independent executable trace which can be considered as an adaptor for existing dynamic analysis tools.
we address the underlying technical challenges.
trace program is not a simple recording of the sequence of executed instructions.
it is more like a transformation of the original program.
an instruction in the original program has only one virtualized copy in the trace program even though it may be executed many times.
our technique suppresses dependences on the underlying hardware operating systems and libraries leveraging a novel lazy logging method.
the method does not require the tracing component to understand any system library interfaces to achieve independence.
our technique ensures that execution of the trace program generates the original control flow by handling direct indirect and even unexpected control flow transfers caused by interrupts and exceptions.
it also guarantees the same values and data flow to be reproduced by properly virtualizing memory and registers of the original program.
we have implemented pietrace on x86 and sensor platforms.
we evaluate pietrace by tracing virtualizing buggy executions of real world windows and sensor applications including acrobat reader .
we then use existing linux debugging tools to identify the root causes of these bugs.
we also show case that our technique can be used to virtualize windows malware execution including packed malware so that the malware trace programs can be executed and analyzed as many times as desired.
pietrace and its benchmarks are available at limitations.
pietrace guarantees to reproduce the user space behavior of the original execution.
library function execu tion is in the user space and hence faithfully reproduced.
in contrast system level behavior such as the execution insi de a system call is invisible to pietrace.
pietrace does not kno w the semantics of system calls either as it does not need to.
however it faithfully records system call invocations.
pi etrace has limited support for multi threaded executions.
it gene rates a trace program for each thread.
although it faithfully capt ures individual thread executions analyzing thread interleav ing requires additional work.
pietrace currently has non triv ial runtime overhead.ii.
d emonstrative example in this section we use a windows malware example to demonstrate our technique.
it is a browser helper object bho malware executing on internet explorer ie .
bho is a plug in of ie that can register callbacks for importa nt events.
the malware monitors all visited url so that an advertisement is displayed when some particular urls are detected.
in this case study we want to identify and underst and the malicious payload of the bho plug in.
firstly we observe that the dll binary file of the plugin has a non trivial size 300kb and complex structure.
the left side of fig.
shows the static call graph generated by ida the most popular binary analysis tool used in malware analysis.
the graph has nodes and edges.
it is difficult for a human to determine the malicious payload insi de the complex graph.
besides the graph is incomplete missin g many call edges through function pointers due to the difficul ty of static analysis.
the plug in has a lot of benign functions for initialization and normal processing.
an alternative is to observe the plug in execution.
however the plug in has to execute as part of ie.
that implies a tool has to load and monitor the ie execution which is highly complex and expensive to monitor.
in an execution in which we load pages with one of them triggering the advertisement the execution of the ie process is times larger than the sub execution of the plug in.
furthermore to the best of ou r knowledge there is not an existing scalable and publically available windows dynamic analysis tool that we can easily leverage to understand the malware.
therefore in this case study we use pietrace to trace and virtualize the execution of the plug in.
we then use a valgri nd based tool callgrind on linux to generate the dynamic call graph of the trace program whose execution regenerates the original plug in execution.
to further determine the malic ious payload we use a simple approach to prune the benign behavior.
particularly we trace and virtualize two ie execut ions one accessing the full set of pages including the one that could trigger the advertisement and the other accessing the two benign pages only.
we acquire the two trace programs with sizes of 453kb and .7mb.
we execute them on callgrind and generate two call graphs for comparison.
the right hand side of fig.
shows the result.
the shaded nodes are the functions that uniquely appear in the execution with the advertisemen t. there are totally such functions and we suspect they are the malicious payload.
since our trace program contains information of calls to external apis we are able to underst and the behavior of some of the functions by observing the extern al api calls in these functions.
in particular the malware first checks if there are other loaded bhos.
if so it unloads them in order to gain exclusive control of the browser in node a .
then it shows an advertisement dialog on the screen in node b and stops the current navigation of the browser in node c .
while the behavior of b and c corresponds to the observed symptoms of the malware the graph also reveals its stealth behavior a .
it calls cconnectionpoint enumconnection49a call graph from ida has nodes edges crossings main 0x09a229f7 0x09a2c168 0x09a23421 0x09a2a7d2 0x09a25fde c. cieframeauto stop ieframe.dll 0x09a26437 0x09a2ad13 0x09a24ba7 0x09a370fc 0x77e2cf41 0x77e1eb36 0x9a36ac0 a. cconnectionpoint enumconnection ieframe.dll b. showwindow user32.dll 0x09a2c168 0x09a25132 0x09a23a28 ... 0x09a2629a 0x09a36daf 0x0dce6ba1 0x09a2de14 0x09a2ddfd ... fig.
.
bho call graphs.
the one on the right is generated by ou r analysis.
shaded nodes denote malicious behavior.
inieframe.dll .
although this interface is supposed to be called by the browser to manage registered bhos the malicious bho uses it to disable other bhos.
iii.
b asic design program p s stmt s s1 s2 skip r le r lr ra wl ra rv gotol l1 if rl then goto l1 syscalll depinstl r mallocl rs freel r calll l1 retl operator op ... expr e r c a r1opr2 ropc register r sp r1 r2 r3 ... const c true f alse ... addr a ... label l l1 l2 l3 ... fig.
.
language language.
to facilitate discussion we introduce a low level language to model binary executables.
for simplicity we on ly model enough to illustrate the key ideas.
the language and th e discussion are general not bounded to a specific instructio n set.
the syntax is presented in fig.
.
memory reads and writes are modeled by r ra and w ra rv with raholding the address and rvthe value.
since it is a low level language we do not model conditional or loop statements but rather jumps using goto and guarded goto syscall denotes system calls1 depinst represents instructions that depend on the specific platform malloc r and free r represent heap allocation and deallocation.
function invocations and returns are modeled by call l and ret.
note that we use spto denote the stack pointer register and we assume all platforms have such a register.
our technique executes the original program p. during execution it constructs another program p that is platformindependent not depending on any os libraries input files 1we do not model their parameters as our technique does not req uire such information.or network connections.
running p regenerates the original execution.
more precisely it regenerates an execution that has the same user space control flow data flow and values as the original execution .
to simplify our discussion one can consider p a program in a sub language of the one in fig.
.
in particular p will not have any system call instructions platform specific instructions heap memory management instructions or registers except the stack register.
next we elaborate the technique from different aspects.
a. control flow tracing and virtualization the first aspect focuses on ensuring the trace program will regenerate the same control flow when it executes.
for each executed instruction in the original program we record it in a buffer.
for control transfer instructions e.g.
jumps a nd calls we patch the control transfer target to ensure corre ct control flow.
if an instruction gets executed multiple times our technique keeps only one copy of its virtualized version to minimize the size of the trace program.
upon execution of an instruction the technique checks if it is executed for the first time.
if so it is stored in the buffer.
at the end the buffer is the trace program.
in the tracing virtualization rules in table i function addstmt l s defined in fig.
is called upon execution of any instructio n with label l to record the instruction.
parameter sdenotes the virtualized version of the instruction which may conta in more than a few instructions to achieve platform independen ce.
we use a virtuallabelmap v l to map an instruction in the original executable to its virtualized version in the trace program.
hence inside addstmt we first test if the instruction has been traced before by checking vl.
if not the instruction is attached to the end of the trace program and th e mapping is updated.
for jump and call instructions rules jump and call we look up the new label of the jump call target using functio n getlabel l and redirect the control to the new position.
note that when we call getlabel the target instruction may not50p program s v l virtuallabelmap label label va virtualaddrmap addr addr m memstore addr const reg regstore register const sm shadowmemory addr const acc accessed addr boolean ls logstorage logid logentry id logid l z e logentry memlog a c reglog csp c1 c2 c3 ...cn hc hitcount label z v r r represents the global var.
in the trace program representin gr getlabel l ifv l l is empty then return the end position o f p else return v l l addstmt l s ifv l l is empty then vl l the end position o f p p p s logread l a hc l ifa ne ationslash null then ifsm a ne ationslash m a then ls l hc l memlog a m a sm a m a concretize l hc l t ls l hc l ift memlog a c then w va a c ift reglog csp c1 ... cn then vr sp csp ... v r rn cn fig.
.
definitions for virtualization rules be executed and virtualized yet.
in this case the function returns the end position of the trace buffer at which the tar get instruction will be put.
we also take special care of call and return instructions.
in particular we cannot simply use call and return instructio ns in the trace program because they entail implicit stack operat ions.
upon a function call the return address i.e.
the address of the instruction immediately following the call instructio n is implicitly pushed to the stack.
upon return the return address is loaded from the stack.
if we use a call instruction in p to virtualize a call in p the address pushed to the stack is the neighboring instruction in p which does not necessarily correspond to the instruction immediately succeeding the c all instruction in p leading to incorrect control flow upon return.
therefore as shown in rule c all our solution is to explicitly push the original return address i.e.
l and then use a jump instruction to virtualize the call.
upon return rule r et the original return address is read and then translated at runtime using vl.
b. data flow tracing and virtualization in the second aspect we discuss how to ensure execution of the trace program reproduces the same data flow in a platform independent fashion.
this is achieved by virtual izing memory layout memory management and registers whichare platform dependent.
for example the typical stack addr ess of linux applications is not available in windows because it is reserved for the windows kernel.
to virtualize memory we track all the memory locations and regions accessed in the original execution and then declare these locations and regions as global buffers in the trace program.
the original accesses are redirected to these buffers.
one critical prop erty we want to ensure is that all the original user space memory accesses including their addresses and the values accesse d can be preserved by our virtualization.
this is critical for cross platform debugging as unsafe accesses such as buffer overflows are preserved too.
registers need to be virtualize d too as different platforms support different registers.
we use a set of global variables to represent registers.
we use a mapping acc that maps an address to a boolean value to denote if the address has ever been accessed during execution.
hence in rules r ead w rite call the mapping is set.
in a call instruction the stack memory is implicitly accessed to store the return address.
observe in these rules vr r denotes the global variable in the trace program that is used to represent register r reg is the register store and hence reg r denotes the current value in r. after the original execution terminates we process the acc mapping to divide all the accessed addresses to a number of regions.
ideally we can allocate one variable in the trace program for each unique accessed address.
however this requires maintaining a very large address translation tabl e to map an original address to its corresponding variable in the trace program.
on the other hand we can allocate a large buffer to denote the entire virtual space in the origin al execution.
in such a case although we only need to perform linear address translation the space consumption is large .
hence we divide the accessed addresses to a few regions to achieve a good tradeoff between the memory overhead and the address translation overhead.
in particular we consider any two addresses with a distance less than a predefined threshold in this case belong to the same region .
for each identified region we declare a global buffer in the trac e program.
during execution of the trace program a memory address is translated on the fly right before it is accessed b y first performing a range query to determine the buffer for its region and then offsetting to the right location.
in rule r ead the second instruction added by addstmt translates the address to be read vr ra which is an address in the original execution to aby calling va which performs a range query and then offsetting.
its details are elided.
ru le write is similar.
so our scheme does not rely on any platform specific memory layout or memory management policy.
intuitively trace programs do not allocate any heap memory as heap allocation and deallocation functions are platform depend ent.
the original stack manipulations are virtualized and emula ted on a global region.
example .
assume x08000400 x08000432 x080004 b0 and 0x8000900 are accessed.
we determine the first three form a region and the last forms another region.
we allocate a buffe r51table i tracing virtualization rules .
statement action rule r lr ra acc reg ra true logread l reg ra read addstmt l concretize l a va vr ra v r r r a wl ra rv acc reg ra true addstmt l a va v r ra w a v r rv write gotol l1 l getlabel l1 addstmt l goto l jump if rl then goto l1 addstmt l if v r r then goto vl l1 cond jump syscalll depinstl ls l hc l reglog reg sp reg r1 ... reg rn addstmt l concretize l sysdep mallocl r freel r skip heap calll l1 acc reg sp true l getlabel l1 call addstmt l sp sp w sp l goto l retladdstmt l t r sp goto vl t ret register sp is the stack pointer register in the trace program.
note that the actions in the second column are performed during the original execution whereas the statements added by addstmt constitute the trace program and will be executed separatel y. awith the size x80004 b0 x8000400 for the first region.
assume during execution of the trace program x08000432 is about to be accessed the translation identifies that ais its buffer as it falls in the range of .
its actual address to access is hence a 0x8000432 0x08000400 .
square in our design the entire stack footprint i.e.
the maximum stack consumption of the original execution is often deter mined as a large region as stack accesses tend to be close to each other.
the heap is often divided into smaller regions .
a region identified by our analysis may not correspond to an allocated heap region.
however this does not affect the soundness of our technique.
theorem .
all user space memory accesses including buffer overflows in the original execution are preserved.
particu larly the same sequence of addresses and accessed values is regenerated by trace program execution.
intuitively all addresses are maintained and manipulated in their original form during execution of the trace program.
they are only translated right before the access.
hence assume in the original run a buffer ais overflowed and thus its neighboring buffer bis overwritten.
the write to the address within buffer bis faithfully reproduced as the same faulty pointer manipulation that overflows awill be faithfully replayed.
it is independent of the region identification in o ur virtualization process.
note that some memory related exce ptions such as null pointer dereferences will explicitly ter minate the tracing process they are essentially preserved by the termination of the trace program.
the formal proof is omitte d. maintaining identical original addresses during trace pro gram execution is critical even though they are not accessible.
some functions such as printf andfprintf take different execution paths according to the pointers.
also the execut ion path ofencodepointer anddecodepointer in windows depends on the given address.
furthermore some instructions require memory alignment.
in x86 sse and mmx instructions such as mov aps and movntps are examples.
to handle them we align all the base addresses of virtualize d memory regions according to the original base addresses.since the least common multiple lcm of alignments of sse and mmx is byte pietrace also applies byte alignment .
c. system level dependence elimination a real execution is most likely system dependent.
for instance it may have to perform system specific i o by system calls e.g.
read from a specific device it may execute syste mdependent instructions such as cpuid.
we have to eliminate such dependences in order to run the trace program on a different platform.
note that libraries are not a problem fo r pietrace as we are able to trace into library execution.
in ot her words library execution will be part of the trace program.
we also need to handle non deterministic instructions such as rdtsc read current timestamp .
otherwise they will cause execution differences.
currently we have limited support for concurrency.
pietrace generates a trace program for each thread.
while trace programs capture the user space behavi or of individual threads pietrace does not currently support reasoning about thread interleavings.
a typical solution to handle system calls by many existing logging and replay tools is to record the values read written by system calls e.g.
the packet receiv ed by a socket read .
during replay instead of interacting wit h the real device it simply restores the recorded values from the log.
despite its simplicity such a design is platform depe ndent because the logging and replay has to be aware of the entire system call interface such as which part of memory is being updated during a socket read.
we develop a new solution.
instead of directly tracking system calls or platform dependent instructions.
we develo p a lazy logging approach.
during tracing we maintain a shadow memory that can be considered as parallel to the normal memory.
when a user space instruction of the original program updates the memory which is visible to our tracing system we update the shadow memory in the same way.
when a kernel space instruction inside a system call upda tes the memory the shadow memory cannot be updated because such writes are invisible to pietrace.
later when the memor y updated by the system call is read the discrepancy between t he normal memory and the shadow memory suggests the previous52invisible update.
we then log the value in the memory.
it will be restored during trace program execution.
besides system calls the method also naturally handles other platf ormdependent instructions and non deterministic instructio ns including remote thread reads and writes.
as shown by rule r ead in table i function logread is called with the address.
the function is defined in fig.
.
it first updates the hit count of the instruction which count s the number of instances of the instruction.
it then compares the shadow memory and the actual memory.
if they differ a log entry identified by the instruction label and its hit coun t is added.
the hit count is to handle the case that a read instruction gets executed many times and only some instance s have their values updated by system calls.
others have their values updated by user space instructions and hence can be re computed during the trace program execution.
they do not need to be logged.
as part of the rule a call to function concretize is added to the trace program which will be executed when the trace is replayed.
symmetric to logread it also first increases the hit count and then it checks if there is a log entry associate d with the current instance identified by the label and the hit count.
if so it sets the corresponding memory or registers t o the recorded values.
in rule s ysdep even though we do not need to log any values in memory due to the lazy logging strategy we do log the current register values.
the reason is that register values may be changed by system calls or platform dependent instructions and such changes need to be captured.
iv.
i mplementation to make the technique practical we also need to address a number of implementation challenges.
handling indirect control flow transfer and long set jumps.
indirect control flow transfer and long set jumps are commonly used in x86 executables.
indirect control flow transfers are used to support function pointers virtual fu nction calls in object oriented programs and jump tables compiled fromswitch case statements.
long set jumps are usually used to implement control transfer to exception handlers.
t hey share the same characteristics that the control transfer ta rget of a jump call instruction is a runtime value.
for example the y may be in the form of goto r with rthe register holding the dynamic target.
hence the control transfer rules j ump cond jump and c all in table i are insufficient as their targets are a constant program label.
our solution is to look up the new target from the virtual label map vlduring the trace program execution.
for example we have the following rule for the indirect jump statements.
statement action gotol r addstmt l goto vl v r r indirect calls are similarly handled.
note that our techniq ue guarantees values generated in the virtualized registers d uring trace program execution e.g.
in vr r are identical to those generated in the real registers in the original execution.
t his guarantees the correctness of the above indirect jump rule.
theuse of the vlmap in the trace program also implies that we need to provide it as part of the trace program.
we declare it as a global array.
symbolic information preservation.
an important design goal is to allow the trace program to be analyzed by different tools on various platforms.
however we want to interpret th e analysis results on the original system.
as such we need to preserve the symbolic information of the original program i n the trace program.
in particular during the tracing virtu alizing process we generate an offline dictionary.
it maps each instruction in the trace program to an instruction in the ori ginal program whose symbolic information can be looked up from the original executable.
for each variable accessed in the original run as captured by acc we also preserve the mapping from its buffer address in the trace program to the variable.
supporting different instruction sets.
besides x86 pietrace can also trace mica2 sensor program execution and generate trace programs in x86 so that the wealthy set of x86 tools can be used to analyze sensor program execution.
the additional challenge lies in eliminating the instruction set differen ces.
for mica2 instructions that do not have direct correspondence i n x86 for example sbic we provide functions written in x86 to emulate them.
v. e valuation we evaluate pietrace with real world applications on x86 and sensor platforms.
for x86 we run real world buggy programs on windows and collected the trace programs of the faulty runs for cross platform analysis.
the five window s programs are downloaded from a vulnerability database .
note that although the database lists many vulnerabilities most of them do not provide the exploit inputs or the exploits cannot be reproduced.
after we randomly inspected a large set of the listed vulnerabilities of cots software we found these five that have the inputs available and can be reproduced.
we execute the subject programs with the provided vulnerable inputs to get the trace programs.
in the five applications castripper is a recording program and microsoft html help is the default html help file loader.powertabeditor is a guitar note editor program andfreeamp is a music player.
for the sensor platform we run buggy sensor applications on an emulator called atemu the supported instruction set isatmega128 a kind of risc instruction set.
the operating system is tinyos.
the five sensor buggy applications are mainly collected from existing literature .
we also evaluate pietrace on three malwares to show that we can effectively help malware analysis even when a malware is packed.
the ie bho case discussed in section ii is one of them.
the set of subject programs and the corresponding bugs are presented in the second column and the last column of table ii respectively.
pietrace and the test benchmarks are publica lly available at .
we also run pietrace on specint programs to study overhead.
these programs are bug free.53table ii benchmarks and virtualization results .
platform subject software of inst.
program size log size bug dynamic static originala trace program plaintext compressedb x86 acrobat reader .
208m 506k 342kb 31mb 78mb 31mb memory corruption x86 castripper 103m 230k 564kb 13mb 25mb 4mb buffer overflow x86 microsoft html help 7m 117k kb 6mb 4mb 1mb buffer overflow x86 powertabeditor 37m 186k .
mb 10mb 8mb 2mb seh eip corruption x86 freeamp 67m 120k kb 6mb 16mb 4mb buffer overflow atmega128csensor node by 8m 2k 31kb 204kb 2mb 1mb buffer overflow atmega128 multihoposcilloscope m 2k 54kb 214kb 2mb 1mb data race atmega128 cnttoledrfm m 1k 18kb 155kb 700kb 57kb concurrency bug atmega128 blinkfail 32k 6kb 78kb 22kb 3kb memory safety atmega128 rfmtoled 679k 1k 17kb 154kb 923kb 75kb zero length packets x86 packed malware 246m 239k kb 19mb 22mb 8mb x86 multi packed malware 322m 263k kb 20mb 47mb 12mb x86 bho 4m 33k kb 1mb 312kb 123kb a.application binary only not including dynamic libraries b.7zip utility was used c.atmega128 is a sensor instruction set.
table iii existing analysis tools tested on our system .
name tested extensions or functionalities pin program slicing tool and memtrace valgrind memcheck and callgrind dynamorio instrcalls ollydebugger watchman ollyscript hittrace immunity debugger fulldisasm and ariadne windbg pydbgeng and windbg script gdb reverse debugging reverse step reverse continue a. virtualization results the virtualization results can be found in table ii.
the thir d column shows the number of executed instructions static a nd their instances dynamic .
the static number is also the num ber of instructions that get virtualized.
column four shows the size of programs including the original and the correspondi ng trace programs.
observe that the trace programs are usually much larger than the original programs.
that is because an instruction is usually virtualized to a few instructions an d a trace program includes all the libraries used including tho se dynamically loaded.
furthermore we have to include the virtual label mapping vland the virtual address mapping va defined in fig.
as part of the trace programs.
however our later experiment will show that the trace program size does n ot change much over time.
column five shows the log size.
more detailed results about the instructions that trigger logging and their effects are presented in table iv.
the data columns present the numbers of instruction instances dynamic and unique instruction s static that need logging because of invisible system leve l memory writes.
their percentages over the total number of dynamic and static instructions respectively are also pr esented.
the control flow change columns show logging caused by unexpected control flow changes.
the platformdependent inst.
columns present logging for platform depe ndent instructions e.g.
cpuid .
the last two columns show the total.
observe that for most cases only a small percenta ge of all executed instructions triggers logging except for tw o sensor cases.
that is because those two cases are very i o bound.
for windows cases most loggings are caused by data differences whereas for sensor cases most are caused byplatform dependent instructions.
that is because sensors use the platform dependent instructions in and out to perform one byte hardware read and write.
another observation is tha t unexpected control flow happens very often at a very small number of places.
that is due to the event driven execution model i.e.
program execution is trapped to kernel through interrupt instructions and various user mode handlers may g et called depending on the events .
b. cross platform analysis an important goal of pietrace is to enable cross platform dynamic analysis namely using a tool on a specific platform to analyze an execution on a different platform.
in this expe riment we apply a set of tools as shown in table iii to the trace program executions.
the first column shows the infrastructu res of the tools.
the second column shows the tools which are usually implemented as infrastructure extenstions.
pin l inux x86 valgrind linux x86 and dynamorio windows are dynamic binary instrumentation engines.
ollydebugger immunity debugger windbg and gdb are debuggers that are widely used on windows or linux.
we applied two pin tools namely a dynamic slicing tool and the memtrace tool to the trace program executions.
the slicer detects both data and control dependenc es during execution and performs backward forward slicing gi ven a slicing criterion.
since pietrace preserves user space d ependences the slicer produces the same slices as the ones generated when it is applied to the original executions.
not e that the slices contain some instructions that are for the purpose of virtualization and hence not present in the orig inal programs .
these instructions can be pruned by the symbolic information mapping mentioned in section iv.
memtrace is a tool that traces all memory addresses.
as the addresses accessed in trace program execution are the global memory regions generated by virtualization pietrace has a script that translates such addresses back to the original address es leveraging the address mapping va. we applied two valgrind tools memcheck and callgrind.
memcheck is a tool that detects memory safety problems such as buffer overflows and null pointer accesses.
we modified the memcheck tool to print recent memory read operations as well54table iv instructions causing logging .
subject software data control flow change platform dependent inst.
total dynamic static dynamic static dynamic static dynamic static acrobat reader .
3m .
9k .
19ka3a21ka9k .
3m .
9k .
castripper 703ka6k 147ka3a147ka6k 998k 6k ms html help 226k .
3k .
952a4a1ka3k .
229k .
3k .
powertabeditor 261ka6k .
36ka3a36ka6k .
335ka6k .
freeamp 753k .
4k .
18ka1a19ka4k .
791k .
4k .
sensor node by 8ka18a9ka9a1.6m .
.
.6m .
multihoposcilloscope 9ka21a554a9a1.4m .
.4m .
cnttoledrfm 8ka18 3ka6a5ka7 .
17ka75 .
blinkfail 177a7 .
169a1a1k .
.
1k .
.
rfmtoled 8k .
.
7k 5a10k .
.
26k .
.
packed malware 1ma7k .
5ka2a5ka7k .
1ma7k .
multi packed malware 2ma5k .
6ka2a7ka5k .
2ma5k .
bho 15ka1k .
59a4a45a1k .
15ka1k .
a.its percentage is less than .
as instructions that defined the values that are read.
we call this new tool memcheck as it is a simple extension of the memcheck code base.
callgrind is a tool to generate dynamic call graph.
we applied two dynamorio tools.
memtrace is similar to pin memtrace.
instcalls is a tool that logs funct ion invocations and returns.
besides the above tools we have also applied a number of debugger plugins that provide advanced debugging and profiling capabilities.
they are very similar to instrument ation tools.
instead of using instrumentation they use breakpoi nts as the mechanism to monitor and inspect program state.
for instance hittrace logs program state automatically at giv en breakpoints.
reverse debugging is an advanced feature in x8 gdb that allows reverse execution e.g.
step backward and reverse continue .
all these tools run correctly with our trace program executions.
next we show a few case studies.
acrobat reader .
acrobat reader .
on windows can be crashed by a null pointer dereference when provided with a crafted pdf file.
there is not any published explanation of the crash.
in this case study we want to use our simple extension of linux valgrind memcheck called memcheck to understand the causality of the crash.
we generate the trace program from the crashing execution.
we then use memcheck to back track from the null pointer step by step.
we identify the definition point of the value at each step and backtrack to the definition point till we get to the first such definition.
since acrobat reader is highly complex and it doe s not have any symbolic information the identified chain is lo ng and crosses a few functions and dlls we simplify it in fig.
.
the boxes on the left show the memcheck output at each step.
each box reports a read instruction including its pc source location in the trace program value and the definiti on.
the corresponding read and write i.e.
the definition in the original program are shown in the middle.
the right column shows the corresponding function and its dll.
at the end we identify that the definition of the null pointer starts in t he acroform.api dll.
as shown on the top the loading of this dll is guarded by a predicate with branch target 0x4e6180a.
its branch outcome is determined by the input on the right which is a line in the crafted pdf.
we confirm the finding by the fact that any changes to this line makes the crash disappe ar.
searching it on the internet the keywords in the line seems to indicate it is an invalid acrobat form.
sensor case.
in qijun gu et al.
show that malicious packets can compromise sensor nodes.
we use their program that has a buffer overflow vulnerability and can propagate the malicious packet to other nodes automatically.
using th e provided input the sensor program crashes on an invalid ret urn address.
we use pietrace to generate the trace program of the crashing run.
and then we run the trace program inside a pin based dynamic slicer .
specifically we compute the backward slice from the faulty return address which contains all the executed instructions that have directly o r indirectly contributed to the given faulty value through da ta and control dependences.
the slice has instructions.
the data slice i.e.
a slice computed by considering data dependences only has instructions.
the data slice is sufficient to explain the crash.
part of it is shown in the left hand side of fig.
.
the corresponding source code is shown on the right.
we find that the invalid return address is dependent on receive.receive on the bottom stackcreator andstrcpy i.e.
crashed when returning from the function .
this clearly identifies the caus al path of the exploit.
the malicious packet is received by receive.receive .
it is passed to stackcreator which calls strcpy .
the buffer overflow occurs inside strcpy corrupting the return address.
note that in a trace program the original packets become concretized values th at are loaded from a file.
hence the bottom box of fig.
actually corresponds to several in instructions in tinyos kernel.
packed malware cases.
pietrace has the following two main advantages in malware analysis.
first since trace program s do not have any system calls one can analyze their execution without any concerns about harmful side effects.
second s ince the technique records all executed instructions it can be naturally used to analyze packed malwares which unpack themselves during execution.
compared to existing unpacki ng techniques that rely on specific heuris tics or target specific packers our technique is very general and55rd 0438172c re func17.s contents written by re func17.s rd 09cf4dc8 re func17.s contents written by re func17.s rd 09cf7c28 re func17.s contents written by re func17.s wr push dword ptr rd mov eax dword ptr wr push dword ptr rd push dword ptr wr push ebx rd pop ebx 0x4e6180a ... call 0x4e6189e ... 0x4e6189e ... call 0x4e61ce0 pluginmain test al al jz 0x4e6180a vm call imm ... 0x4e61ce0 0x04e61adb vm call imm ... 0x4e6189e 0x04e6184c jz func 04e6180a the branch outcome is determined by input acrotype btn call loadlibraryex to load acroform.api which is vulnerable.
at 0x4eb8be0 0x11 in acrord32.dll at 0x4eb8be0 0x1a0 in acrord32.dll at 0x54557fee 0xae in acroform.api at 0x544e8ebf 0x12 in acroform.api at 0x544e8ebf 0x12 in acroform.api crash at 0x545a6b46 0x4 in acroform.api ... ... ... ... ... ... fig.
.
analysis results from the acrobat reader case study ...ret re func.s func 22f2 strcpy func 0a7e stackcreator func 0010ac scheduler...runtask eventmessage t receive.receive ... ... stackcreator rcm ...voidstackcreator uint8 t str ... stringcopy str ...voidstringcopy uint8 t str ... strcpy ch str ... concretizedvalues incomingmaliciouspackets ... ... ... ... ... ... ...backwardslicingresult correspondingsourcecode fig.
.
backward program slicing on a sensor node.
easily applicable.
in this experiment we use a java runtime installer malware that downloads and installs another malware to the victim machine.
the malware is packed by an unknown version of the upx executable compressor.
we run the packed malware twice on pietrace one with internet connection and the other not.
in the second executi on the malicious payload is not executed.
we get two trace programs.
then we use the winmerge tool to compare the two trace programs.
the result shows that the first approx imately basic blocks of the two programs are identica l which implies they belong to the packer and the malware initialization.
the differences about basic block s denote the malicious payload.
from the trace programs we ca n also easily observe that the first basic blocks belong to a large loop.
cross checking with the original malware indica tes that they belong to the packer and the original malware entry is at the 679th basic block.
we can directly execute the malware by putting a goto statement that jumps to the entry.
note that with our technique we can easily identify about basic blocks that are in the malware but do not perform malicious actions which cannot be achieved by existing approaches.
in addition most universal unpackers are no t able to handle binaries packed multiple times.
we call them the multi packed malware.
pietrace can directly handle suc h malware.
hence in this experiment we use xpack to further pack the previous packed sample.
during execution the unpacking routines of xpack and upx are executed sequentially.
we repeat the previous process to get two trac e programs.
by comparing them we find that they share about basic blocks.
the differences the identified malici ous payload are the same as the previous case.
the malware entry point can be easily spotted at the 6781st basic blocks at the end of two large loops.
c. performance and scalability we use specint to evaluate the performance and scalability of pietrace we could not use the programs in table ii because they are mostly interactive.
we run the spec programs on test inputs and measure the slow down of the virtualization component.
the results are shown in fig.
.
for most tests our system incurs approximately 2000x slowdown or less except parser andcrafty .
further inspection shows that their executions constantly perform i o causin g a lot of data logging.
the average overhead is 2523x.
we also evaluate scalability by showing the changes of trace progra m size and log size over a duration of execution million instructions .
the results are shown in fig.
and .
we can observe that the trace program size quickly reaches a fixed point whereas the log size slowly grows over time except vortex .
further inspection shows that vortex performs more i o than others in that duration.
while we believe we can reduce the runtime overhead by optimization pietrace i s a heavyweight technique that may not be used in a production setting.
it is suitable for cases where the runtime overhead is less a concern e.g.
in house debugging but rather the mis sing capabilites on the current platform.
such capabilities cou ld be provided by cross platform tools.
vi.
r elated work logging and replay.
logging and replay has been widely studied .
however most of these existing techniques do not support cross platform replay.
most of them work by intercepti ng and logging system calls.
replay is by executing the same program with the support of a replay runtime that again intercepts system calls and then loads values from the log.
t he replayed execution requires the same set of libraries and th e56fig.
.
slowdown on spec int2000 mb bzip crafty eon gcc gzip mcf parser perlbmk twolf vortex mb bzip crafty eon gcc gzip mcf parser perlbmk twolf vortex vpr fig.
.
trace program size variation.
same platform.
in contrast we generate a trace program that can be compiled and executed on its own without any specific platform or runtime support.
transplay allows replaying a trace on different platforms.
however execution can o nly be replayed inside a replayer.
hence debugging a replayed execution discloses the state of the replayer not the origi nal execution.
a replayer has to be developed for each platform.
it has to map system calls and library calls across platforms .
creating such mappings requires a lot of manual efforts.
in contrast pietrace suppresses platform dependences by con cretization.
it does not need to understand either the origi nal system interface or the target system interface.
s2e al lows cross platform driver execution.
similar to transplay it requires a mapping between kernel apis across platforms.
xu et al.
proposed to use compiler to generate two instrumented versions of a program one for logging and the other for replay.
it works on java programs and assumes the same set of libraries.
in contrast pietrace does not requir e compilers and directly works on binaries which entails a different set of challenges.
tracing.
traditional tracing techniques generate traces that can be analyzed in a cross platform fashi on.
mb bzip crafty eon gcc gzip mcf parser perlbmk twolf vortex vpr020 mb bzip crafty eon gcc gzip mcf parser perlbmk twolf vortex vpr fig.
.
log size variationhowever analysis tools have to support the specific trace formats which precludes most third party tools.
storing tr aces is also very expensive.
virtualization and vm introspection.
there are many virtual machines and emulation infrastructures that allow cross platform execution.
their main disadvant age is that a subject program has to execute along with their system.
it is hence difficult to apply any third party tools to the execution of the subject program.
virtual machine introspection is a kind of technique that aim s to observe guest os state from the host os.
virtuoso and virtualize utility commands e.g.
ls in the guest os and make them executable on the host os so that one can directly observe the state of the guest os by running such commands on the host os.
these techniques need to be aware of the system interfaces of both os s and they do not support cross platform replay of application programs.
binary extraction and reuse.
inspector gadget is a technique that uses dynamic slicing to extract a part of a malware called a gadget which can be replayed for behavior analysis.
bcr tries to extract components of an executab le such as the decryption encryption function of a malware th at can be reused in other programs.
the extracted gadgets and components are essentially sub programs that can take inpu ts and perform certain functionalities such as downloading fil es.
they are platform dependent.
gadget execution also require s support from specific runtime.
top is a framework that decompiles a binary to c code by executing it.
the generated c code can take different inputs as the original binary wher eas pietrace only focuses on reproducing a specific execution.
top is not platform independent since it requires the presence of the same set of libraries kernel interfaces extern al resources and devices.
vii.
c onclusion we propose a novel technique called platform independent executable trace.
it generates a standalone trace program f rom a normal program execution that relies on specific operating system libraries hardware and instruction set.
the trac e program is platform independent without relying on any operating system or libraries.
it can be compiled and execut ed on any x86 platform.
running the trace program generates the original execution.
as such the large body of existing thir d party tools can be applied to analyze trace program executio n on the platforms those tools prefer.
we have implemented the technique on x86 and sensor platforms.
we show that leveraging our technique linux tools can be used to analyze windows and sensor program executions including packed malware executions.
acknowledgement this research has been supported in part by darpa under contract and by nsf under awards and .
any opinions findings and conclusions in this pap er are those of the authors only and do not necessarily reflct the views of darpa and nsf.57references daniel j. abadi don carney ugur c etintemel mitch che rniack christian convey sangdon lee michael stonebraker nesim e tatbul and stan zdonik.
aurora a new model and architecture for dat a stream management.
the vldb journal august .
gautam altekar and ion stoica.
odr output determinist ic replay for multicore debugging.
in sosp .
andrew ayers richard schooler chris metcalf anant ag arwal junghwan rhee and emmett witchel.
traceback first fault diagnos is by reconstruction of distributed control flow.
in pldi .
fabrice bellard.
qemu a fast and portable dynamic trans lator.
in atec .
chris benninger stephen w. neville yagiz onat yazir c hris matthews and yvonne coady.
maitland lighter weight vm introspecti on to support cyber security in the cloud.
in cloud .
sanjay bhansali wen ke chen stuart de jong andrew edw ards ron murray milenko drini c darek miho cka and joe chau.
fram ework for instruction level tracing and analysis of program executi ons.
in vee .
lutz boehne.
pandora s bochs automated malware unpack ing.
master s thesis rwth aachen university january .
michael d. bond nicholas nethercote stephen w. kent s amuel z. guyer and kathryn s. mckinley.
tracking bad apples report ing the origin of null and undefined value errors.
in oopsla .
juan caballero noah m. johnson stephen mccamant and d awn song.
binary code extraction and interface identification f or security applications.
in isoc ndss10 .
anton chernoff and ray hookway.
digital fx!
running bit x86 applications on alpha nt.
in nt .
vitaly chipounov v olodymyr kuznetsov and george can dea.
s2e a platform for in vivo multi path analysis of software syste ms.sigplan not.
march .
jim chow tal garfinkel and peter m. chen.
decoupling dy namic program analysis from execution in virtual environments.
i natc pages .
bob cmelik and david keppel.
shade a fast instruction set simulator for execution profiling.
sigmetrics perform.
eval.
rev.
may .
brendan dolan gavitt tim leek michael zhivich jona thon giffin and wenke lee.
virtuoso narrowing the semantic gap in virtual m achine introspection.
in sp .
george w. dunlap samuel t. king sukru cinar murtaza a .
basrai and peter m. chen.
revirt enabling intrusion analysis thro ugh virtualmachine logging and replay.
sigops oper.
syst.
rev.
si december .
yangchun fu and zhiqiang lin.
space traveling across vm automatically bridging the semantic gap in virtual machine introsp ection via online kernel data redirection.
in sp .
qijun gu and rizwan noorani.
towards self propagate ma l packets in sensor networks.
in wisec .
xuxian jiang xinyuan wang and dongyan xu.
stealthy ma lware detection through vmm based out of the box semantic view rec onstruction.
inccs .
joko.
xcomp xpack download page.
b.de joko .
min gyung kang pongsin poosankam and heng yin.
renovo a hidden code extractor for packed executables.
in worm .
dohyeong kim.
dualslicing.
u homes kim1051 .
clemens kolbitsch thorsten holz christopher kruege l and engin kirda.
inspector gadget automated extraction of propriet ary gadgets from malware binaries.
in sp .
yonghwi kwon.
platform independent trace project webs ite.
may .
james r. larus.
whole program paths.
in pldi .
peng li and john regehr.
t check bug finding for sensor n etworks.
in ipsn .
christian list dean grimm gal hammer jochen tucht k immo varis alexander skinner takashi sawanaka tim gerundt marcel g osselin and denis bradford.
winmerge.
oberhumer markus franz xaver johannes molnr lszl and reiser john f. upx the ultimate packer for executables.
l. martignoni m. christodorescu and s. jha.
omniunpa ck fast generic and safe unpacking of malware.
in acsac .
satish narayanasamy gilles pokam and brad calder.
bu gnet continuously recording program execution for deterministic repl ay debugging.
inisca .
joe polastre.
cvs tinyos1.x contrib ucb tos cc1000pulse cc1000radiointm.nc .
.
.
s contrib commits may .html.
jonathan polley dionysys blazakis jonathan mcgee d an rusk and john s. baras.
atemu a fine grained sensor network simulato r. in ieee secon .
paul royal mitch halpin david dagon robert edmonds and wenke lee.
polyunpack automating the hidden code extraction of unpackexecuting malware.
in acsac .
yasushi saito.
jockey a user space library for record replay debugging.
inaadebug .
christian schneider jonas pfoh and claudia eckert.
a universal semantic bridge for virtual machine introspection.
in iciss .
offensive security.
exploits database by offensive se curity.
stelios sidiroglou oren laadan carlos perez nicola s viennot jason nieh and angelos d. keromytis.
assure automatic software selfhealing using rescue points.
in asplos .
sudarshan m. srinivasan srikanth kandula christoph er r. andrews and yuanyuan zhou.
flashback a lightweight extension for r ollback and deterministic replay for software debugging.
in atec .
dinesh subhraveti and jason nieh.
record and transplay partial checkpointing for replay debugging across heterogeneous s ystems.
in sigmetrics .
berkeley webs wireless embedded systems.
download.
amit vasudevan ning qu and adrian perrig.
xtrec secu re real time execution trace recording on commodity platforms.
in hicss .
virustotal.
antivirus scan.
b581eba9eed76 787fb54b38f7119d301f6713856ee0a analysis .
guoqing xu atanas rountev yan tang and feng qin.
effic ient checkpointing of java software using context sensitive ca pture and replay.
in esec fse .
min xu rastislav bodik and mark d. hill.
a flight data r ecorder for enabling full system multiprocessor deterministic re play.
in isca .
min xu vyacheslav malyugin jeffrey sheldon ganesh v enkitachalam boris weissman and vmware inc. retrace collecting execut ion trace with virtual machine deterministic replay.
in mobs .
jing yang mary lou soffa leo selavo and kamin whiteho use.
clairvoyant a comprehensive source level debugger for wi reless sensor networks.
in sensys .
junyuan zeng yangchun fu kenneth miller zhiqiang li n xiangyu zhang and dongyan xu.
obfuscation resilient binary code re use through trace oriented programming.
in ccs .
xiangyu zhang and rajiv gupta.
whole execution traces.
inmicro .