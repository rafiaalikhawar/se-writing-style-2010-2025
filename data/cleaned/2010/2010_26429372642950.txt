diver precise dynamic impact analysis using dependence based trace pruning haipeng cai university of notre dame indiana usa hcai nd.eduraul santelices university of notre dame indiana usa rsanteli nd.edu abstract impact analysis determines the effects that the behavior of program entities or changes to them can have on the rest of the system.
dynamic impact analysis is one practical form that computes smaller impact sets than static alternatives for concrete sets of executions.
however existing dynamic approaches can still produce impact sets that are too large to be useful.
to address this problem we present a novel dynamic impact analysis called d iver that exploits static dependencies to identify runtime impacts much more precisely without reducing safety and at acceptable costs.
our preliminary empirical evaluation shows that d iver can significantly increase the precision of dynamic impact analysis.
categories and subject descriptors d. .
distribution maintenance and enhancement keywords dynamic impact analysis trace pruning dependence analysis .
introduction modern software is increasingly complex and changes rapidly posing serious risks to its quality and reliability.
thus it is crucial to analyze and evolve these systems efficiently and effectively.
a key activity in this process is impact analysis e.g.
which identifies the effects that the behavior of program entities or changes to those entities can have on the rest of the software.
different approaches to impact analysis provide different tradeoffs in accuracy costs and other qualities for computing impact sets i.e.
potentially affected entities .
static analysis can produce safe but overly conservative impact sets .
dynamic impact analysis in contrast uses runtime information such as coverage or execution traces to produce smaller and more focused impact sets than static analysis at the expense of some safety .
yet users looking for the actual behavior of the software as represented by a set of executions may afford unsafe results making dynamic impact analysis an attractive option.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
dynamic impact analyses also provide different cost effectiveness tradeoffs.
for example c overage impact is based on runtime coverage and ignores execution order which makes it very efficient but also very imprecise .
another technique p athimpact is more precise by using execution order but is less efficient because it requires tracing .
for intermediate tradeoffs optimizations of p athimpact have been proposed including an incremental version .
the most efficient one that preserves the precision of p athimpact is based onexecute after sequences eas which we call pi eas.
unfortunately approaches such as pi eas can still have too many false positives.
our studies show that they can have a lowchange impact prediction precision of on average.
an alternative is forward dynamic slicing but it works at the statement level which makes it expensive and would have to be applied to all statements in a method.
at the method level hybrid techniques combining static and dynamic analysis have been proposed to improve precision such as i nfluence dynamic .
however these techniques improve precision over pi eas only marginally and at a much greater cost .
another hybrid technique combines runtime coverage with text analysis but it remains unclear how it performs with more precise dynamic data.
to address this imprecision we present a new dynamic impact analysis called d iver that incurs the same runtime costs as pathimpact but can be much more precise.
pi eas uses the execution order of methods to find all potential runtime impacts of a method m which can be quite imprecise because in general not all methods executed after mare affected by m. d iver in contrast uses a one time static dependence analysis to safely reduce the impact set to only those methods that could have depended on mat runtime.
although applying that information increases the cost of querying for impact sets the cost per query is still acceptable and multiple queries can be processed in parallel.
we implemented d iver for a preliminary study on four java subjects and we compared the results with those of pi eas the most precise of the efficient techniques in the literature.
our implementation of d iver and pi eas is available to the public for download.
our results confirm the imprecision of pi eas whose impact sets often contain hundreds of methods.
d iver in contrast computed impact sets containing in most cases a few dozen methods.
our findings for these subjects are dramatic the impact sets of d iver are .
the size of the impact sets of pi eas for the same level of safety.
this means that d iver improved the precision of a representative existing technique by a factor of .
i.e.
by .
we also found that its costs are acceptable at less than half a minute per query on average.
1influence dynamic is marginally better but costlier.
2the d iver website is 1public class a static int g public int d string m1 int f int z int x f z y h if x y m2 x y int r new b .m3 h g string s m3val r return s void m2 int m int n int w m d if w n g w boolean b c.m5 this system.out.print b 16public class b static short t int m3 int a int b int j t if a b j b a return j static double m4 int x a.g i try a.g x i t new a .m1 i t catch exception e return x 31public class c static boolean m5 a q long y q.d boolean b b.t y q.d return b public static void m0 string args int a b a o new a string s o.m1 a b double d b.m4 string u s d system.out.print u figure the example program eused for illustration throughout this paper.
pathimpact m0 m1 m2 m5 r r m3 r r m4 r r x diver m0em1em2em5em2im1im3em1im0im4em4im0ix figure execution traces of eused by p athimpact and d iver .
.
motivation and background this section presents the motivation and necessary background of our technique.
figure shows the example program ewe use for illustration throughout the paper.
motivation.
in previous work we found that existing dynamic impact analyses such as pi eas can be too imprecise in practice on average only about half of the methods reported as impacted are really impacted.
in particular for methods at the core of a software system pi eas can include in the impact sets for such methods most or all methods in the system.
for example if querying the entry method of the java application jmeter the developer using pi eas will end up inspecting all methods executed by the test suite making impact analysis virtually impossible to use in practice.
therefore because analyzing potential impacts is critical before applying changes much smaller and precise impact sets are desirable for developers as long as safety is preserved i.e.
no real dynamic impacts are missed .
program dependencies.
program dependencies are classified as control or data dependencies .
a statement s1iscontrol dependent on a statement s2if a branching decision taken at statement s2determines whether statement s1is necessarily executed.
a statement s1isdata dependent on a statement s2if a variable vdefined written at s2is used read at s1and there is a definition clear path in the program for v i.e.
a path that does not re define v froms2tos1.
a dependence graph is astatic program representation where nodes represent statements and edges represent both control and data dependencies among those statements.
dynamic impact analysis.
in this paper we focus on analyses that identify dynamic impacts that occur on individual program versions without changes being necessarily involved .
such a dynamic impact analysis takes a program p a test suitet and a set of methods mand outputs an impact set containing the methods inppotentially impacted by mwhen running t. one example technique is p athimpact which collects runtime traces of executed methods.
for each method minmthat is queried for its impacts p athimpact uses the method execution order found in the runtime traces of pfort.
the analysis identifies as impacted mand all methods executed in any trace after m. figure shows an example trace for p athimpact where ris a method return event and xthe program exit event.
the remainingmarks are the entry events of methods.
for query m2 in addition tom2itself p athimpact first finds m5 m3 and m4as impacted because they were entered after m2was entered and then finds m0 andm1because they returned after m2was entered i.e.
parts of them executed after parts or all of m2 .
thus the resulting dynamic impact set of m2is m0 m1 m2 m3 m4 m5 for this trace.
when more than one trace exists p athimpact returns the union of the impact sets for all traces.
eas optimizes p athimpact by tracking only the first and last events per method.
thus we consider pi eas the most cost effective and representative dynamic impact analysis comparable to d iver .
one other technique is more precise than pi eas but for a very small margin and a greater cost .
.
technique for our new impact analysis d iver to be safe with respect to an execution set and also precise and practical we need something much better than the execute after relation of pi eas which is too conservative.
the problem is that reaching a method m0after a methodmat runtime is necessary for mto impactm0 but not all such methods m0necessarily depend on m. to fix this problem we propose to build first the whole program static dependence graph and then use it to find which of those methods really depend on m. .
overview the process of computing the dependence graph and using it for dynamic impact analysis is shown in figure .
it works in three phases static analysis runtime and post processing.
the inputs for the entire process are a program p a test suite t and impact set queries m. to optimize the static analysis phase the process first runs a profiler which executes the test suite on the program to quickly find whether any exceptions are raised by a method but are not caught there or not caught at all.
this lets the static analysis phase decide whether it can safely skip computing some control dependencies caused by unhandled exceptions.
after profiling the static analysis phase computes data dependencies dd and control dependencies cd .
for the cds the process first computes regular cds caused by branches polymorphic calls and intraprocedural exception control flows.
for the remaining exception control flows exintercds in figure the process computes the cds for the exception types that the profiler detected as not handled by the originating methods.
after all dependencies are found the dependence graph is built and passed to the post processing phase i.e.
not needed at runtime .
for the runtime phase the static analysis creates the instrumented versionp0ofpusing only probes for monitoring method entry 344runtimerun p with each test t in tinstrumented program p impact computationdependence graphper test method event traces query set m post processingcompute all ddscompute regular cdsbuild dependence graphdds regular cdscompute exintercdsddsprogram p dependence graph instrument p for method event tracingstatic analysis uncaught exception profilerdecisions on cds test suite ttest suite t impact set of mpdds all required cdsfigure process for dynamic impact analysis using d iver .
andreturned into events section .
the instrumented program p0is similar to that of pi eas except that instead of tracking two values per method it traces the whole sequence of method events as p athimpact does because d iver needs entire traces to determine transitive dependencies at post processing.
nevertheless d iver compresses these traces on the fly at reasonable costs as p athimpact does to make space costs acceptable.
in all the runtime phase executes p0with test suite t to produce one compressed method level trace per test case.
the post processing phase lets the user query the impact set of a method set m. any number of queries can be made at this point without re running the first two phases.
for each query d iver uses the dependence graph from the static phase and the traces from the runtime phase to identify all methods that depended directly or transitively on any method in mon any of those traces.
mis included in the result because every method impacts itself.
to illustrate consider the trace for input ha b 3i in figure where subscripts eand idenote the entry and returned into events respectively.
for a query m m2 d iver traverses the trace to find which dependencies from the dependence graph are exercised due to methods executed after m2and via those dependencies which methods depended directly or transitively on any occurrence of m2.
when d iver finds m2 the impact set starts as m2 .
then the only outgoing dependence from m2in the graph is exercised because its target m5occurs next so m5is impacted.
thus d iver finds the impact set m2 m5 in contrast with p athimpact which reports m0 m1 m2 m3 m4 m5 .
.
dependence graph and propagation the static dependence graph of the entire program is a key ingredient of our technique.
unlike the system dependence graph however the dependence graph built in the static phase of our technique does not include summary edges because d iver is dynamic after all and thus does not require context sensitive analysis.
d iver uses this graph only to prune runtime traces.
interprocedural i.e.
across methods dds in the dependence graph are classified into three types parameter dds from actual to formal parameters in method calls return dds from return statements to caller sites and heap dds from definitions to uses of heap variables i.e.
dynamically allocated variables not passed or returned explicitly by methods .
parameter andreturn dds are exercised at runtime only if the target method executes immediately after the source.
thus the type of a dd lets d iver at post processing decide whether the dependence was exercised and the target method of that dependence was impacted by the source.
to facilitate our presentation of d iver we refer to the specific target statements of incoming interprocedural dependence edges to and the source statements of outgoing interprocedural edges from a method as incoming ports ips and outgoing ports ops of that method respectively.
an impact propagating to a method via an incoming edge ewill enter the method through the ipfore.
if an impact propagates beyond this method through outgoing edges it will exit through all ops that are reachable via intraprocedural i.e.
within the method edges from the ipfore.
an impact that starts in a method will propagate through all ops of that method.
.
impact computation the post processing phase of d iver answers queries for impact sets using the dependence graph from the static phase and the traces from the runtime phase.
algorithm formalizes this process.
algorithm comp is dependence graph g tracel methodc impops map of edge type to set of impacted ops impactset fcg impact set of c start false pre m null preceding method occurrence for each method event e2l do if start then start m e c if start then continue ifeis a method entry event then ifm e c then for each outgoing edge oefrom n m e ingdo impops fsrc oe g pre m m e method occurrence continue for each incoming edge ieton m e ingdo iftype ie return src ie 2impops then continue impactset fm e g for each outgoing edge oefrom n m e ingdo ifsrc oe is reachable from tgt ie ingthen impops fsrc oe g else eis a method returned into event for each incoming edge ieton m e ingdo iftype ie parameter src ie 2impops then continue impactset fm e g for each outgoing edge oefrom n m e ingdo ifsrc oe is reachable from tgt ie ingthen impops fsrc oe g ifpre m m e then continue for each edge type t2 fparameter returng do impops n fzjz2impops m z pre mg pre m m e preceding method occurrence return impactset the algorithm inputs a dependence graph g an execution trace land a queried method c and outputs the impact set of c.m e gives the method associated with a method event e n m is the set of dependence graph nodes for all statements in method m m z is the method to which port zbelongs src d tgt d and type d are the source node target node and type of edge d respectively.
to maximize precision an interprocedural edge dexercised for theithtime in the trace propagates an impact to its target ip port only if the source op port of dfor thatithoccurrence has also been impacted.
to that end an impacted opset per edge type which starts empty at line is maintained at lines and .
these sets track impact propagations on ports to ensure that only the methods transitively reachable from cthrough impacted ports are reported as impacted.
the impact set starts with the queried methodc line and grows as the trace is traversed lines .
methods executed before the first occurrence of ccannot be impacted so their events are skipped using a flag start lines and .
methods executed after care checked to determine if they are impacted for which two key decisions are made.
first the algorithm decides that the impact of cpropagates into a method 345m e if there is an impacted port in impops that is the source of an interprocedural edge of the same type to m e lines for method entry events and lines for returned into events .
the second key decision is to determine whether an impact propagates out ofm e by finding the opports of m e that are reachable via intraprocedural edges inside the method from theimpacted ip ports of that method i.e.
the target ports of impact propagating edges according to the first decision .
those impacted ops are added to impops to continue looking for impacts in the rest of the trace lines for method entry events and lines for returned into events .
as for the queried method c all of its ops are added to impops whencexecutes lines .
to determine impact propagations through interprocedural edges on the dependence graph those edges can be classified into two categories described next.
all edges in each category share the same propagation rules.
adjacent edge.
dd edges of types parameter and return are classified as adjacent edges.
an adjacent edge from method m to methodm0models an interprocedural dd between the two methods.
through these edges an impact can propagate from m tom0only ifm0executes immediately after m. to realize this rule an opzthat is the source of an adjacent edge is added to the impacted opsetimpops as other impacted ops when found to propagate the impact beyond m z in the trace.
the port is then removed from that set lines after matching it to an ipin the immediate caller or callee because the corresponding parameter or return value should not be matched to ips of methods that occur later in the trace.
the method occurrence is tracked by pre m initialized at line and updated at lines and .
execute anytime after edge.
all other interprocedural edges are execute anytime after edges.
such an edge from mtom0models an interprocedural cd or heap dd between these two methods such that an impact in mpropagates to m0if and only if m0executes anytime aftermin the trace.
such edges propagate impacts to their targets if their sources ops are impacted when the targets are reached later.
thus the sources of these edges are never removed from the impacted opsetimpops once added to that set.
it is worth noting that the way in which propagations rules are applied depends on the type of method event being processed in the trace.
for instance no return edges are considered for impact propagation at method entry events lines and no parameter edges are considered at returned into events lines because of the semantics of those event types see section .
also all ops of the queried method care marked as impacted at each entry event found for c. thus it is not necessary to do the same for the returned into events of cbecause the ops ofcare already marked as propagated at the entry of cin the trace.
in sum according to the propagation rules of d iver for each event in the trace the method associated with that event is added to the impact set if it is determined that at least one of its ips is directly or transitively impacted by the queried method.
after all events of the trace are processed in order the algorithm returns as its output the resulting impact set for that trace line .
if multiple traces are available one run of the algorithm per trace is required and the result is the union of the individual impact sets.
also for the impact of multiple methods the algorithm can be run once per method or can be easily adjusted to treat cas a set for efficiency.
.
evaluation this section presents our preliminary empirical evaluation of diver .
our goal was to assess the precision of this new technique and its practicality in terms of time and space costs.
.
implementation exception handling fix for pi eas.
the original description of pi eas deals with exceptions handled in the raising method or its caller.
however if neither method handles the exception at runtime the returned into events for all methods in the call stack that do not handle the exception will not be logged and those methods can be mistakenly missed in the resulting impact set.
to address this problem we implemented a corrected version of pi eas which we call pi eas c. pi eas ccaptures all returned into events by wrapping the entire body of each method in a try catch block to identify uncaught exceptions.
the added catch block when reached by such an exception adds the corresponding returned into event which would be missed otherwise and then re throws the exception to continue the execution thus preserving the original semantics of the program.
diver .
to build the dependence graph we used our dependence analysis system dua f orensics .
for exceptional control dependencies our implementation takes the exceptional control flow graph excfg provided by soot and applies both the classical algorithm for control dependence computation and the extended algorithm for interprocedural control dependencies .
when computing interprocedural exception cds d iver includes in the throwable set of each excfg node all exceptions both checked declared and unchecked undeclared for that method thrown by that node due to a throw instruction in it or a method that it calls that can throw unhandled exceptions.
.
experiment setup subjects.
we chose four java programs of different types and sizes as summarized on the first three columns of table for this preliminary study.
the size of each subject is measured as the number of non comment non blank lines of code loc in java.
schedule1 is a priority scheduler.
nanoxml is a lean and efficient xml parser.
ant is a cross platform build tool.
xml security is an apache library for signatures and encryption.
we took these subjects and their test suites from the sir repository and picked the first available version of each one in that repository.
methodology.
for our experiments we applied pi eas cand diver separately to each subject on a linux workstation with a quad core intel core i5 .10ghz processor and 8gb ddr2 ram.
to obtain the method traces we used the entire test suites provided with the subjects.
to compare the analysis precision we calculated for each query the impact set size for d iver and pi eas cand the size ratio of the first one to the second one.
to measure and compare the efficiency of the techniques we first computed for each subject the time and space costs of their respective static analysis and runtime phases.
we did this only once per subject and technique because all queries performed later reuse the results of the first two phases.
then for the post processing phase we collected the time costs per query.
.
results and analysis in this section we report and discuss the relative precisions of diver and pi eas cand the costs that both techniques incur.
.
.
precision table presents the precision results for d iver and pi eas c with two statistics per subject and overall for all queries last row for the corresponding data points the mean and the standard deviation stdev of the impact set sizes and ratios.
the queries column lists the number of single method queries versus the method total per subject in parenthesis which is equal to the respective method level test coverage.
346table precision in terms of impact set sizes and their ratios for d iver to pi eas c. subject loc tests queries pi eas cis size diver is size is size ratio wilcoxon all methods mean stdev mean stdev mean stdev p value schedule1 .
.
.
.
.
.
.65e nanoxml .
.
.
.
.
.
.40e ant .
.
.
.
.
.
.94e xml security .
.
.
.
.
.
.79e average .
.
.
.
.
.
.29e table time and space costs of d iver and pi eas c including the overheads of profiling uncaught exceptions for d iver .
subject prof.static analysis phase runtime phasepost processing phase execution data sizepi eas c diver pi eas c diver normal pi eas cdiver mean stdev mean stdev pi eas cdiver schedule1 .7s .8s .6s .0s .1s .7s .7s .1s .6s .0s .0m .2m nanoxml .1s .3s .4s .4s .0s .4s .1s .1s .2s .8s .4m .4m ant .2s .3s .4s .2s .5s .0s .1s .1s .2s .6s .0m .0m xml security .1s .4s .7s .3s .8s .8s .0s .0s .4s .6s .5m .8m average .4s .8s .9s .5s .0s .3s .1s .1s .6s .6s .7m .9m the results in the table show that on average d iver impact sets were much smaller than for pi eas c especially for the two largest subjects.
large numbers of false positives for pi eas c were identified as such and pruned by d iver .
for example pi eas cidentified methods on average in its impact sets for ant whereas d iver reported only for a mean ratio of .
.
these values are means of ratios not ratios of means.
also the large standard deviations indicate that the impact set sizes fluctuate greatly across queries for every subject except schedule1.
the results suggest that d iver is even stronger with respect to pi eas cfor larger subjects which are more representative of modern software.
for the smaller subjects schedule1 and nanoxml d iver provides smaller gains possibly due to the proximity and interdependence of the few methods they contain.
we applied the wilcoxon signed rank one tailed test for all queries in each subject and also for the set of all queries in all subjects.
this is a non parametric test that makes no assumptions on the distribution of the data.
the last column in table shows the resulting p values.
for the null hypothesis is that d iver is not more precise than pi eas c. the p values show strongly that the null hypothesis is rejected and thus the superiority of d iver is statistically significant for these subjects and test suites.
in all d iver cansafely prune of the impact sets computed by pi eas c which amounts to an increase in precision by a factor of .
i.e.
by over the almost best existing technique.
.
.
efficiency table reports the time costs of each phase per technique including the uncaught exception profiling prof. static analysis execution for the non instrumented program normal and for both techniques and post processing.
for the last phase we show per subject and overall the means and standard deviations of query costs.
the last row shows averages weighted by queries.
the profiling numbers suggest that automatically finding the static analysis settings is cheap half a minute or less.
as expected for static analysis d iver incurred higher costs than pi eas c. for both techniques these costs increase with the size of the program with d iver growing faster.
however on average the d iver static analysis finished within .
minutes which seems reasonable because this is done only once per program for all possible queries.
for the runtime phase both techniques had small overheads.
for the post processing phase due to the traversal of longer traces d iver needed more time than pi eas c. yet the average cost of .
seconds per query still seems quite practical.the space costs for the runtime data for the two techniques are shown on the rightmost two columns of table .
as expected the d iver traces use more space than the pi eas cregisters.
one expected correlation is that longer traces lead to greater post processing costs.
in addition d iver incurs on average only 3mb cost for storing the dependence graph during static analysis.
in all d iver achieved significantly greater precisions for these subjects at acceptable time and space costs.
.
threats to validity the main internal threat is the possibility of implementation errors in d iver and our study scripts.
however d iver is based on soot and dua f orensics both of which have matured over the years and we verified the scripts manually for each experiment phase.
another internal threat is the risk of missing static dependencies due to java language features such as reflection and multi threading.
however we confirmed that for our study subjects running on their test suites there was no use of such features except for ant where reflection is used.
thus we refactored ant s code to obtain a reflection free yet semantically equivalent version at least for the test suite .
the main external threat is that the subjects we used do not necessarily represent all types of programs from a dynamic impact analysis perspective.
another external threat is inherent to dynamic analysis the test suites we used cannot exercise all behaviors of the respective subjects.
thus our results must be interpreted in light of the extent of the ability of those test suites to exercise their subjects.
to address these issues we chose subjects of diverse sizes and functionality types for which reasonable test suites are provided.
the main construct threat is that we used impact set sizes as inverse indicators of precision assuming that recall is not affected.
this is safe for analyzing individual program versions but for predicting the impacts that actual changes will have recall might be less than perfect if those changes modify the control flow of the program to execute methods not reported by d iver .
aconclusion threat is that we statistically analyzed only methods for which we could obtain impact sets i.e.
executed at least once but this is safe for our comparison with other dynamic techniques.
.
related work law and rothermel introduced p athimpact to compute dynamic impacts based on the execution order of methods and apiwattanapong and colleagues proposed eas to safely reduce 347the size of p athimpact traces.
this technique improves the efficiency of p athimpact but not its precision.
d iver also uses the whole method level execution traces as p athimpact does but it does so while improving its precision significantly.
impact analysis techniques based on dependence analyses other than static slicing have been explored as well.
sun and colleagues proposed oocmdg and locmd to model dependencies among classes methods and class fields.
their techniques were also extended for impact analysis with hierarchical slicing and for multiple levels of granularity.
these models however include only structural dependencies e.g.
call edges based on object oriented features whereas our dependence graph models all interprocedural data and control dependencies for all types of software.
influence dynamic combines dependence analysis and dynamic information for impact analysis.
however it considers only a subset of the method dependencies that d iver models and its precision improvements over p athimpact are only marginal.
huang and song extended i nfluence dynamic for objected oriented programs by adding dependencies between fields.
unlike d iver however these approaches model partial data dependencies only and none of them achieve a noticeably better precision than pi eas as d iver remarkably does.
.
conclusion we presented a novel dynamic impact analysis called d iver .
by tracking impacts via method level execution traces and applying static dependence knowledge d iver attains at acceptable costs a much better precision than existing dynamic impact analyses e.g.
pi eas .
our preliminary study on java software shows that diver can prevent almost of false positives from the impact sets produced by pi eas with strong statistical significance.