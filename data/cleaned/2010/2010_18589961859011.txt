resisting reliability degradation through proactive reconfiguration deshan cooray sam malek roshanak roshandel david kilgore george mason university department of computer science dcooray smalek ckilgor1 gmu.edu seattle university department of computer science and software engineering roshanak seattleu.edu abstract situated software systems are an emerging class of systems that are predominantly pervasive em bedded and mobile.
they are marked with a high degree of unpredictability and dynamism in the execution context.
at the same time such systems often need to satisfy strict reliability requirements.
most current software reliability analysis approaches are not suitable for situated software systems.
we propose an approach geared to such systems which continuously fu rnishes refined reliability predictions at runtime by inco rporating various sources of information.
the reliability predictions are leveraged to proactively place the software in the optimal configuration with respect to changing conditions.
our approach considers two representative architectural reconfiguration decisions that impact the system s reliabilit y reallocation of components to processes and changing the architectural style.
we have realized the approach as part of a framework intended for mission critical settings called resilient situated software system resist and evaluated it using a mobile emergency response system.
categories and subject descriptors d. .
so ftware program verification reliability d. .
software architectures.
general terms design reliability keywords reliability software architectur e self adaptation mobility .
introduction software systems are fast permeating a variety of domains including emergency response indus trial automation navigation health care power grid and civil infrastructure.
we call this emerging class of systems situated software systems which are predominantly mobile embedded and pervasive.
they are characterized by their highly dynamic configuration unknown operational profile and fluctuating conditions.
at the same time given the mission critical nature of the domains in which they are deployed e.g.
emergency response majority of situated systems are expected to satisfy stringent reliability requirements.
engineers of a situated software system typically spend significant effort to determine a good configuration for the system to ensure its adherence to functional and non functional requirements.
for instance they may perform a trade off analysis between the system s resource utilization efficiency and reliability when they decide the allocation of software components to operating system os processes.
clearly the overall reliability of such systems depends on problems both internal e.g.
software bugs and external e.g.
network disconnect ion hardware failure to the software.
the key underlying insight in our research is that some internal software problems may manifest themselves only under certain dynamic characteristics external to the software e.g.
physical location which is traditionally referred to as context .
due to variability in the execution context the optimal configuration for a situated system cannot be determined prior to its deployment and no particular configuration can be optimal for the system s entire operational lifetime.
thus runtime reconfiguration of the system ma y be necessary to achieve the system s maximum potential.
give n the mission critical nature of situated systems we define the optimal configuration as one that satisfies the reliability requirement while taking into consideration other quality attri butes of concern e.g.
resource utilization efficiency such as memory and cpu usage .
in this paper we describe and evaluate resilient situated software system resist a framework intended to address reliability concerns in mission critical dynamic and mobile setting.
resist furnishes a compositional approach to reliability estimation starting with analysis at the component level which in turn makes it possible to assess the impact of adaptation choices on the system s reliability.
the an alysis is performed continuously at runtime by incorporating vari ous sources of information.
in addition to the architectural models and the monitoring data resist incorporates contextual information to predict the reliability of the system in its near future operation.
resist uses the reliability pr edictions to proactively determine when the system should be adapted and find the optimal configuration for the near future operation of the system.
our evaluations show that our re liability predictions are accurate with respect to the observed system reliability.
we thus consider the predicted reliability as an indicator for decision making.
an important contribution of our work is proactive adaptation based on our reliability analysis that reconfigures the system at runtime prior to actual reliability degradation.
this trait clearly sets our permission to make digital or hard copi es of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.
work apart from the majority of existing self adaptive frameworks that are reactive in their decision making .
we have developed a prototype implementation of resist on top of a tool suite which consists of an existing context aware architectural middleware integrated with a visual architectural modeling and analysis environment.
finally resist is evaluated using a robotics emerge ncy response system.
the remainder of this paper is organized as follows.
section presents a motivating example.
section provides a high level overview of resist while section presents our failure model.
sections and present the co mponent level and system level reliability models respectively.
section details the configuration selection process.
a prototype of resist and evaluation of the approach are presented in sect ions and .
an overview of related work and avenues of future research conclude the paper.
.
motivating example emergency response is a domain that entails a high degree of mission criticality.
software systems designed for this domain thus have stringent reliabilit y requirements.
as a motivating example consider a mobile distributed emergency response system intended to aid the emerge ncy personnel in fire crises a prototype of which was developed in our previous work .
this system consists of several entities including a central dispatcher that serves as the headquarters for coordinating the crew activities smart fire engines that are designed to alert the dispatcher of the current locati on of the vehicle and provide its occupant with information c oncerning the crisis scene firefighters equipped with pdas capable of c ontrolling the robots and sensors and mobile robots that execute the high level commands.
while the entire system is high ly dynamic and could benefit from our approach for the clarity of exposition we focus on the robotic subsystem.
a robot consists of several electronic sensors and mechanical actuators that allow it to autonomously navigate detect smoke stream vi deo and extinguish fire.
it is constrained by limited battery life me mory processing speed and connectivity.
architectural design choices affecting the system at runtime aim at accommodating these constraints.
an example architectural strategy for improving the system s resource utilization efficiency is to use a thread based architecture.
software components are deployed as separate threads within a single os process thus allowing for the resources e.g.
stack memory to be shared among components while avoiding the overhead e.g.
context switching associated with managing many separate processes.
however since a process may exit prematurely due to an errant thread a disadvantage of the threadbased model is a potential decrease in system reliability.
figures 1a and b show two altern ative allocations of the robot s software components to os pr ocesses.
based on the above discussion from a system s persp ective it is reasonable to expect the architecture depicted in figure 1a to be more efficient in terms of utilization of system s resources while the one depicted in figure 1b to be more reliable.
de termining the best configuration depends on the device s fluctu ating resources e.g.
memory and cpu utilization available battery and the reliability of the system s constituent components which as detailed later may vary due to changes in context.
the above scenario demonstrates the impact of architectural decisions on system s quality attr ibutes.
such decisions while critical to system s dependability cannot be made effectively at design time.
it is only reasonable to assume that some of these decisions must be made at r untime requiring specialized methodologies that continuously ev aluate the impact of these decisions on system s dependability.
we use this system in the remainder of the paper to describe and evaluate our approach.
.
framework overview an overview of resist framework is depicted in figure .
the process is organized as a feedback control loop that continuously monitors analyzes and adapts the system at runtime.
resist consists of three conceptu al software components.
at design time and before the system s implementation is complete an initial set of architecture based reliability models are developed.
these models are used at runtime to assess a variety of configuration choices and to serve as predictors for the future reliability of the system.
unlike the traditional architectural models they embody contextu al properties necessary for reliability analysis of situated sy stems.
as described below these models are expected to be upd ated and refined at runtime.
architecture based reliability m odels along with contextual and monitoring information obtained from the system are used by the component level re liability analyzer to predict the reliability of system s components in their near future operation.
these finegrained reliability estimates are used by the configuration reliability analyzer to determine the reliability of alternative configurations for the system.
the configuration selector is in turn used to select a suitable configuration for the near future operation of the system.
the configuration selector may use other alert command result resultprocess navigatorsensorsensorsensor actuator planmission resultpda command process resultplan navigatorcontroller process a b alert command result resultprocess navigatorsensorsensorsensor actuator planmission resultpda command controller c alert command resultprocess sensorsensorsensor planmission resultpda command process 3processcomponent required interface provided interfacelegend navigatorprocess resultactuator controllerprocess figure .
componen t to process allocation alternatives.
quality attributes such as performance in the selection process.
the process for obtaining and estimating these properties is beyond the scope of this paper which is focused on reliability concerns.
once a new configuration is selected the context aware middleware adapts the system at runtime to reflect the changes in configuration.
the context aware middleware provides support for execution monitoring and adaptation of a software system in terms of its architectural construc ts e.g.
components connectors and configuration .
at runtime the middleware monitors the software system for information that is used to refine the reliability predictions.
this info rmation is obtained from multiple sources such as monitoring internal e.g.
frequency of failures exceptions and service requests and external e.g.
network fluctuations battery charge software properties changes in the structure of the software e.g.
disconnection of components due to network drop outs off loading of components due to drained battery and contextual properties e.g.
physical location .
since the monitored data represents the most recent operational structural and contextual profile of the system s execution it can be used to assess the system reliability more accurately.
note that unlike previous approaches we do not rely solely on the monitoring data.
instead we incorporate architectural knowledge monitoring data and cont extual changes at runtime in a complementary fashion to produce more accurate results.
.
reliability and failure model resist estimates reliability as the probability that a system performs its required functions under stated conditions for a specified period of time .
in situated software systems given the ongoing changes in system s operational conditions the reliability may change over time.
we consider a failure to be an inconsistent behavior of a system with respect to its specification.
faults are caused by defects e.g.
software or hardware error and are abnormal conditions that ma y cause a reduction in or loss of the capability of a functi onal unit to perform a required function.
thus faults are causes of failures .
consistent with other architect ure based reliability approaches we assume that the occurrence of a failure is stochastic and that com ponents failure model is fail stop .
failures are thus reliably detectable by middleware facilities.
furthermore failed components are assumed to eventually automatically or manually recover and resume normal behavior.
we consider two types of fail ure in resist component and process failures.
component failure is caused by a fault within the component s implementa tion.
its effects are contained within the boundary of the component except when it causes a process to fail.
process failure occurs when one of the components running as a thread within a process exits prematurely causing the os process including all of the comp onents deployed on it to fail.
resist s reliability model is targeted at distinguishing among alternative architectural configura tions and thus does not consider failures e.g.
wrong results mismatch ed data type that cannot be resolved through architectural means.
we assume either such defects are detected during the c onstruction of the system or the failure is contained within the component in which the fault occurred e.g.
through the use of appropriate pre and postconditions .
while resist could be extended to accommodate these additional types of failures we do not believe such failures could be treated effectively throu gh architectural reconfiguration.
.
component level analysis structural and behavioral kn owledge embedded in software architectural models provide an appropriate level of abstraction from which reasoning about system s quality attributes is feasible .
architectural models are typically compositional structure and behavior of complex systems are described in terms of their constituent components.
despite th is however as identified by recent surveys majority of existing architecture based reliability modeling approaches largely focus on analysis at the system level.
moreover those approaches that incorporate individual component reliabilitie s into analysis assume that component reliabilities are known apriori.
consequently existing approaches are not suitable for situated systems where the reliabilities of components a nd system fluctuate with the context in which they are deployed.
a purely system wide analysis offers little help in optimizing the system s architecture in this setting.
.
component reliability calculation our component level reliability model relies on dynamic learning techniques specifically hidden markov models hmms to provide continuous reliability refi nement.
component reliability is estimated stochastically using a discrete time markov chain dtmc and in terms of the fraction of the time spent in failure states by the component.
a dtmc is defined as a stochastic process with a set of states s s s2 ... s n and a transition matrix a a ij where aij is the probability of transitioning from state si to state sj.
reliability is computed by solving for the steady state probability obtai ned from standard numerical methods of not being in any failure state.
a number of approaches can be taken to ensure tractability if the state space size is determined to be too big .
obtaining transition pr obabilities matrix a can be challenging especially at design time.
our past research has explored a range of information sources that can be used to derive these probabilities at design time.
in th e case of mobile distributed and situated software systems obtaining these values are further complicated by the fact that the system s behavior changes at runtime in response to changes exte rnal to the system.
we rely on the availability of monitoring data obtained from the running system to determine the transition probability matrix a. while a maps to monitoring data effect changes revised configurationsystem and context info system and context infouses figure .
overview of resist framework.
standard markov based approach would assume that there is a one to one correspondence between observed runtime events and sequence of states in the mode l such correspondence may not exist in systems with realistic level of complexity.
as confirmed by our preliminary results in such circumstances hidden markov mode ls hmms can be used to learn from runtime data and to obtain behavioral transition probabilities.
an hmm is de fined by a set of states s s1 s2 ... sn a transition matrix a aij representing the probabilities of transitions between states a set of observations o o1 o2 ... om and an observation probability matrix e eik which represents the probability of observing event ok in state si.
the sets s and o of the hmm come from the component s architectural model e.g.
statechart diagram while runtime data obtained through monitoring becomes training data for the hmm.
we use the baum welch algorithm to train and solve the hmm.
the input to the algorithm is the data obtained from runtime monitoring of the softwa re system and consists of sequences of observations.
given an initial hmm constructed as described above the baum wel ch algorithm converges on the transition matrix a which as described above is used to calculate probability of failure or unreliability in a dtmc.
to clarify the approach consider the state machine depicted in figure for the controller component of the robot in the emergency response system introduced earlier.
when the controller is in idle state it can receive commands from the firefighter s pda and when it is in estimating moving or planning states the robot makes use of other components such as sensors and actuators.
from this diagram we can derive the sets states s s ...s f and observations o o ...o where f denotes a common failure state s1...s denote behavioral states idle estimating planning moving and o1...o denote the observations state transitions .
at runtime the system is monito red to obtain execution traces in the form of observation sequences.
these execution traces are then used to train the hmm using the baum welch algorithm.
the markov model obtained from this algorithm represents the operational profile of the system based on the training data which represents the system s behavior based on its current context.
to better illustrate the concepts consider the following transition probability matrix obtained by running the baum welch algorithm on sample data obtained from the robot s controller 01000 .
.
.
.
.
.
.
.
the steady state vector obtained from a represents the probability of being in any of the states as the system operates overtime .
.
.
.
.
.
here the last column represents the probability of being in a failure state.
the controller reliability based on its present runtime context is computed as rc .
.
.
incorporating context into analysis as mentioned earlier given the dynamism present in situated system s domain it is critical to incorporate the notion of context into the analysis.
context corresponds to conditions external to the software system which change the behavior of the system and hence impact its reliability.
as a result to satisfy their reliability requirements situated software systems may need to be reconfigured in response to contextual changes.
an important contribution of our re search is the incorporation of this contextual knowledge into our reliability pr edictions which enables proactive reconfiguration of the software prior to actual degradations in reliability.
in the case of this example the robot periodically takes snapshots of th e environment and using existing techniques determines the complexity of the terrain.
the robot then compares the complexity of the current terrain with previous snapshots.
in cases where the terrain seems less more complex than the past context th e model is updated to reflect the contextual change.
for example if there are many obstacles in the field the robot anticipates more bumps.
in the transition probability matrix the probabilities corresponding to the robot s behavior in presence of bumps e.g .
probability of transition from moving to estimating states are updated to reflect this contextual change.
more generally we define a set ... to denote a set of contextual parameters monitored by our runtime infrastructure.
our goal is to arrive at a revi sed transition probability matrix that more accurately reflects the near future operation of the component given the expected contextual changes.
if is a transition probability from state to state in matrix which is affected by changes in a specific contextual parameter then where is a context specific function quantifying the impact of contextual change on the transition probability.
in the case of the robotic system we have used the technique described in to update the probability of transitioning from moving to estimating states based on the complexity of the terrain.
when updating to the other elements in row of the matrix must also be revised to ensure the cumulative probability of all transitions in that row remains at thereby retaining the properties of a stocha stic matrix.
when revising the transition probabilities in row transition probability from state to failed state is unchanged since the failure probability is independent figure .
behavioral model of the robot s controller component.
of changes in context.
the remaining transition probabilities in the row are adjusted proportionately such that where is the transition probability from state to failed state and is a transition probability in row after proportional adjustment.
.
configuration level analysis once the reliability of all compon ents is obtained a compositional model is used to determine the reliability of specific system configurations.
configuration reliab ility is in turn leveraged to assess the adherence of a given configuration to the system reliability goals.
when a system does not meet the intended reliability threshold runtime adaptation becomes necessary to ensure that the system s reliability requirements remain satisfied.
while majority of runtime adaptation approaches take a reactive stance in response to degradati on of the system reliability our approach can be used proactively in anticipation of reliability degradation.
this is done by system monitoring and continuous reliability assessment that incorporates fluctuating operational context as described earlier.
in the rest of this section we briefly describe the system level reliability analysis approach and the role of architectural style and deployment architecture.
.
system reliability calculation our markov based system level reli ability estimati on approach is based on the model presented by wang et al.
where the system reliability is estimated compositionally based on the reliability of indivi dual components the architectural style governing their interactions and th e system s operational profile.
a dtmc is built by mapping the components and their interactions to a state diagram .
a state si maps to one or more components in concurrent executi on whose completion is required in order to transfer control over to the next state.
a state transition with a probability pij represents the probability of undergoing a transition from si to state sj.
accordingly system reliability r is computed as 1 where m is a matrix in which si is the entry state and sk is the exit state and whose elements are computed as follows m i j r p state s reac hes state s and i k ot herwise where ri is the reliability of state si and is the reliability of the exit state.
is the determinant of matrix while is the determinant of the remaining matrix excluding the last row and the first column of .
as an example consider the following deployment scenario for the emergency response robot.
a fi reman interacts with the robot using a pda.
the firemen issues a high level command e.g.
go into the restaurant and extinguish a grease fire which is received by the controller .
the controller decides upon the appropriate sequence of intermediate actions which will result in the successful completion of or inability to complete the original command.
to complete the task the controller makes use of a variety of sensors wh ich detect obstacles proximity and heat a navigator which plots waypoints and a mechanical actuator which is used to perform the physical activities.
let us assume that the initial component reliab ilities for the controller and navigator components are respectively computed to be controller c .
and navigator n .
using the approach described in sectio n .
for the purpose of this illustration we assume the remaining components and connectors in the system input communication connector ic touch sensors ts ts heat sensors hs hs proximity sensors ps1 ps actuator a and output communication connector oc are reliable.
the state model in figure 4a depicts the control flow interactions among the various components in this configuration and the transition probabilities between the components obtained through runtime monitoring.
as shown each of the components ic ts ts2 c n a and oc have been mapped directly to a state since they execute in a sequential manner.
components hs1 hs ps and ps have been mapped to a single state s since they all execute in parallel upon receiving control and upon completion the control transfers back to c. from this state model a corresponding transition matrix m is created with the matrix elements representing probability of successfully transitioning from state si to sj computed as .
in cases where a state transition occurs in a sequential manner ri is the reliability of the component executing in state si whereas when a transition occurs out of the parallel set ri is the multiplication of the reliabilities of all components in state si.
using the transition probabilities in the state model pij and the component level reliabilities we obtain the following for transition matrix m 000 .
.
.
.
.
solving the model according to equation yields a system reliability of .
.
.
impact of architectural style architectural styles are a set of constraints on the structure and behavior of a system to elicit pa rticular desirable qualities .
use of specific architectural styles is a way to apply preconceived solutions to similar recurring software problems.
runtime adaptation and reconfiguration of the system aimed at improving system s quality may often requi re changes to the system s architectural style.
the fault tolerant style for example improves figure .
a state model for the robot b state model with the navigator replicated.
reliability by replicat ing critical component s. a fault tolerant connector in the form of midd leware can be used to handle component failures and to manage the hot standby copies.
in the case of the robot the origin al architecture figure 1b demonstrates the system when the components are allocated to three processes with the navigator and controller components running on separate os processes.
applying the fault tolerant architectural style in this case can improve the reliability by replicating the navigator component which represents a critical point of failure.
recall from section that we have adopted a probabilistic failure model commonly used in the literature here an underlying assumption is that replicas fail independently.
figure 1c shows a replicated navigator component added to the original architecture while running on a new process.
the corresponding state model figure 4b shows the two replicated instances of the navigator n and n2 both mapped to state n .
the reliability of the new state n can be computed as the probability that at least one of them does no t fail .
hence the probability of state n executing correctly is .
.
assuming the reliability of all other components and each of the navigator components to be the same as before matrix m can be updated where state n is replaced by the new state n and the matrix element representing the transition from n now n to c increases to .
from .
.
solving the model above according to equation yields a system reliability of .
which is an improvement of .
.
.
impact of deployment architecture a system s deployment architecture is essentially an allocation of its software components to hardwa re hosts and os processes.
a system may be realized using more than one deployment architecture.
at the same time the deployment architecture has a significant impact on system s reli ability.
in this paper we focus on the component to process allocati on as another representative method employed by resist to pr event reliability degradations.
when multiple components are allo cated to the same process a failure in one component coul d cause all other components sharing the process to fail.
in this case redeploying components to separate processes could improve a system s reliability.
in the case of the robot consider two depl oyment configurations of the architecture one where the controller and the navigator are deployed as two separate proc esses and another where the two components are deployed as thre ads sharing the same process.
let s assume that n and c represent reliability of the navigator and the controller components respectively when they execute on separate processes.
when the tw o components are redeployed to share the same process the effective reliability of each component is simply where failure in either n or c will cause both components to fail.
for instance assuming that n and c to be .
and .
respectively the effective reliability of the two components would be n c .
.
intuitively the drop in the two components reliability results in a decrease in the overall system reliability.
therefore the deployment architecture in which the two components are deployed as separate processes yields better configuration reliability.
.
configuration selection the reliability estimation approach presented earlier can be used to determine the most reliable configuration for a situated software system.
however in practice reliability estimates are used in conjunction with the estimates of other quality attributes e.g.
resource utilization efficiency re sponse time to determine the optimal configuration for the system.
as you may recall the optimal configuration in resist is defined as one that satisfies the system s reliability requireme nt while improving other quality attributes of concern.
in other words in resist reliability takes precedence over other quality attributes.
this is a reasonable objective for the domains targeted by resist i.e.
mission critical but it may not be appropr iate for others.
consequently the configuration selection problem becomes one of an optimization problem .
specifically resist s objective is to find an architectural configuration c such that subject to where is a utility function indicati ng the engineer s preferences for the quality attribute q r is equation that calculates the expected reliability of a given architecture c as further detailed below.
a utility function is used to perform trade off analysis between competing conflicting quality concerns.
in the emergency response system we w ould need two utility functions one specifies the user s preference for improvements in reliability while another one specifies the same for resource utilization efficiency.
elicitation of user s preferences is a topic that has been investigated extensively in the literature e.g.
.
resist does not place a constraint on the format of utility functions.
arguably any user can specify hard constraints which can be trivially modeled as step functions.
altern atively a utility function may take on more advanced forms e.g .
sigmoid curve and elicited using the techniques in .
the optimization is subject to ensuring the specified reliability requirement is not violated.
resist may also use this constraint to determine when a reconfigurati on of the system is necessary.
thus for a system with number of software components where each component s reliability prediction has computed according to the method described in section and h is the number of processes an architectural configuration for the aforementioned optimization problem can be formally specified as follows decision variable represent the number of replicas for component i decision variable 0 1 to indicate if component is placed on the process the configuration is subject to the following constraints each component must be placed on a process 1 .. an architectural constraint may be applied to limit the number of replicas allowed for a component 1 .. w h e r e though a component is allowed to be both replicated and share a process with another component an architectural constraint is imposed such th at they may not both happen simultaneously.
this is because replication is most effective i.e.
achieves maximum improvement in reliability if both the component and its replicas are isol ated into separate processes.
thus we introduce binary variable which indicates if component is sharing a process with another component the analytical models used for estimating quality attributes other than reliability are outside the scope of this paper.
1 if the component shares a process if the component does not share a process where 1 .. and 1 1 thus the effective reliability of component is 1 where r is the effective reliability of component i when the component shares a process with a different component and 1 and is the effective reli ability of component when the component is re plicated with number of replicas and 1 1 the system reliability r c is computed by mapping the effective reliability of the components to states as described in equation .
there are o ht ways of allocating software components to os processes.
the total number of different architectures resulting from the application of fault tolerant style is o max w i t .
thus the size of the solution space for this optimization problem is o max w i h t .
clearly the solution space is large even for small values of w h and t. however the solution space may be significantly pruned by imposing architectural constraints such as the limit on the number of replications allowed.
many commonly available algorithms could be used to solve the above optimization problem.
for small problems resist finds the optimal solution using intege r programming solvers while for large problems it uses stochastic techniques such as greedy and genetic.
the details of these algorithms are outside the scope of this paper.
.
implementation we have developed a prototype implementation of resist that integrates an extended version of xteam as the environment for maintaining the structural behavioral and reliability models prism mw as the context aware middleware for obtaining monitoring data from the system and effecting reconfiguration changes and an off the shelf hmm toolbox for matlab.
xteam is an extensible archite ctural modeling and analysis environment that supports modeling of a system s software architecture using several well known architectural description languages e.g.
fsp and xadl fo r modeling the behavioral and structural properties of a syst em respectively .
we extended xteam s structural and behavioral meta models with the annotations needed for reliabilit y analysis.
to that end the traditional fsp support in xteam was extended to include the notion of failure states and associated a transition probability with each fsp actions.
we also extende d the traditional xadl model support in xteam to model re liability properties of the architectural constructs such as component reliability.
figure depicts a snapshot of the reliability annotated xadl and fsp models for a subset of th e robot s software system.
we have used xteam s api for accessing and modifying the reliability annotated models which are then used to develop resist s reliability analysis and proactive reconfiguration modules.
resist s analysis module reads th e reliabilityannotated architectural models to generate the appropriate hmm which is then solved using matlab s hmm toolbox.
the estimated reliability values are then used to find an optimal configuration for the system.
the running system is implem ented on top of prism mw middleware which is integrated with resist to facilitate monitoring and adaptation.
prism mw s monitoring services provide the runtime data and cont extual information needed for resist s analysis.
the reliability analysis may determine the need to change the system s configuration to prevent reliability degradation.
in turn a new conf iguration is effected by making the appropriate changes to x team s architectural models.
whenever xteam s models change i.e.
resist selects a new configuration an architectural diff is performed and the differences are effected through the dynamic adaptation services of prism mw.
the details of prism mw s support for mobility context awareness and adaptation are described in .
.
evaluation we have evaluated resist usi ng its prototype implementation and the mobile emergency response system described earlier.
the evaluation consists of three criteria the validity of reliability prediction based on expected changes in the context the effectiveness of proactive system reconfiguration and the performance overhead of runtime analysis.
we used xteam to control the system s operational profile i.e.
usage and prismmw for gathering runtime data.
neither the robotic software nor resist was controlled which allo wed them to behave as they would in practice.
figure .
reliability annotate d architectural models of a portion of robot s controller component in xteam a structural view in xadl and b behavioral view in fsp.
.
validity of reliability prediction as described in section resist uses the system s context to predict system s near future reliability by estimating the impact of contextual changes on a components internal behavior.
we have examined the validity of our results by comparing resist s predicted reliability values with those estimations obtained from the system s actual beha vior.
while we have evaluated the validity of our predictions for the entire syst em in this section we present details of the controller s reliability analysis.
for this experiment we controlled the influence of context by varying the probability of the ro bot encountering an obstacle on its path which we refer to as bump probability .
the bump probability correlates to the complexity of the terrain through which the robot navigates in order to accomplish an assigned task.
an increase in the bump probability causes the controller to transition from the moving state to the estimating state with a higher probability recall figure thereby altering its operational profile.
the techniques presented in together with multilinear regression were used in our experiments to derive function recall section .
that estimates the impact of change in terrain to change in bump probability with .
error at confidence level.
in addition to analyzing the effect of context we varied the failure probability of the controller specifically the probability of failure from the estimating state.
we compared resist s reliability predictions with the actual observed reliability of the robot during operation.
in this experiment the navigator and the controller were placed in separate processes and except for the controller all other components failure probability was fixed at .
figure shows the comparison of predicted reliability and observed reliability in three execution scenarios where different bump probabilities were predicted and varied the failure probability of the controller component from to .
.
as shown the controller s reliability decreases as the bump probability increases.
this is beca use an increase in transitions to the estimating state leads to more failures.
further the deviation between observed and predicted re liability both at the level of system and controller are extremely small.
note that since the function used in the experiment had a likely error bound of .
small deviation in results is to be expected.
however the deviation is small enough th at very accurate adaptation decisions could be made.
.
proactive reconfiguration we evaluate resist s ability to satisfy the system s reliability requirement through proactive reconfiguration.
we compared an instance of the robot using resi st against one without resist.
the failure probabilities of all components in both instances were fixed.
we varied the bump probab ility effectively changing the context and observed the proactive reconfiguration process.
the robot was required to maintain a system reliability of at least throughout its execution which formed the constraint in our optimization problem.
initially the navigator was placed in a separate process and the other components were placed together in one process.
this configuration was based on a desi gn time analysis of the system that satisfied the reliability requirement and minimized the resource utilization.
in order to predict the resource utilization we used an analytical model that gi ven a configuration of the system predicts its resource demand in terms of memory and cpu utilization.
the analytical model considers the number of required os processes the number of com ponent replicas together with the average memory utilization and the average cpu clock cycles required by each component.
the components memory and cpu utilization estimates were obtai ned through their design time benchmarking.
sigmoid curve f unctions were employed for expressing the user preferences for each of the quality attributes.
figure .
accuracy of reliability predictions a system reliability b controller s reliability.
figure .
context aware proactive reconfiguration.
a system reliability b resource utilization efficiency.
figure 7a illustrates the comparison between the two instances of the robot as they maneuver the same area within a building with varying levels of complexity i.e.
obstacles .
resist predicts the near future reliability of the system as it approaches an area with a complexity that is different from its current location.
for instance as the robot passes point b and be fore it reaches point c resist anticipates a drop in reliability since the bump probability increases to .
and proactively adapts the system to maintain its reliability above .
as a result the navigator is replicated and the controller is redeployed to a separate process.
this reconfiguration prevents the reliability from dropping below the requirement.
in contrast the re liability of the robot without resist deteriorates significantly falling below the requirement.
figure 7b shows the effect of r econfiguration on the system s resource utilization efficiency.
for instance at point c both cpu and memory utilization increase significantly due to the addition of the navigator replica and sepa rate processes.
similarly resist continues to proactively manage the system s configuration.
in points f and i in anticipation of a drop in reliability resist proactively places the system in a more reliable configuration albeit less efficient.
on the other hand in points d g and j in anticipation of an improvement in reliability resist proactively places the system in a more efficient configuration while meeting th e reliability requirement.
.
overhead of reliability analysis since resist is intended to manage situated software systems at runtime it is important to assess the performance overhead of resist s analysis.
table shows the benchmarking results of resist s reliability analysis on an intel core .
ghz gb ram platform which is representative of the average hardware capability present in modern mobile robots e.g.
.
the results show the time it took for performing the reliability analysis for varying number of commands i.e.
tasks sent to the robot .
each command on average resulted in different monitoring observations e.g.
component interface invocations to be collected and used for training the hmm.
the benchmark in the largest scenario consisting of commands and observations took .
seconds.
however in practice our experience with the emergency re sponse robot shows the analysis is often performed on much sm aller number of observations requiring only a fraction of a second for completion.
.
related work over the past three decades many software reliability approaches have been proposed.
the approaches most relevant to our work are those that consider the system s software architecture .
the underlying assumptions in these approaches make them unsuita ble for use in the domain of situated dynamic and mobile systems.
majority of these approaches focus on system level analysis and assume the reliabilities of the software components are fixed and known.
moreover many of these approaches assume sometimes implicitly that the operational profile of the system is known and does not change at runtime.
finall y none considers the impact of contextual change on the software system s reliability.
three recent surveys corroborate these observations.
our past research has addressed some of the uncertainties associated with design time reliability analysis by incorporating various sources of information .
we also identified the challenges of reliability analysis in the mobile domain .
our objective was to provide rough reliability predictions early in the software life cycle when an implementation of the system is not available.
in contrast to our prev ious work here we are concerned with runtime reliability of the system and rely on the availability of its implementation.
moreover we incorporate latest operational and contextual information to predict the system s reliability and proactively place it in th e optimal configuration.
few approaches combine software architecture and reliability analysis using runtime data .
while and target traditional and highly predictabl e software kami framework provides continuous dependability analysis using a model driven approach.
specifically kami uses runtime data to update the parameters of reliability and performance models.
the focus of resist has been different from kami.
kami reactively adjusts the system s models while resist proactively predicts near future reliability of the system .
moreover unlike kami resist furnishes reliability predictions at the component level.
we believe kami and resist to be complementary as the continuous refinement of parameters in kami could be utilized in updating resist s reliability models.
related to our work are the ge neral purpose architecture based adaptation frameworks .
in contrast to them resist is narrowly aimed at improving the re liability of dynamic situated systems.
while none of the existi ng frameworks directly achieves our objectives they form the founda tion of our research.
in fact our framework is compatible with the widely accepted three layer reference model of self adaptation .
finally related is previous re search on middleware intended for situated software systems.
aura is an architectural style and supporting middleware for ubiquitous computing applications with a special focus on user mobility context awareness and context switching.
xmiddle is a data sharing middleware for mobile computing.
mobipads is a reflective middleware that supports active deployment of augmented services called mobilets for mobile computing.
lime is a java based middleware that provides a coordination layer that can be exploited for designing a pplications which exhibit either logical or physical mobility or both.
unlike resist none of the above technologies provides reliabilit y driven support for optimization of situated software systems through proactive adaptation.
.
conclusion software systems are increasingly situated in mission critical settings which present stringent reliability requirements.
these systems are predominantly mobile embedded and pervasive which are innately dynamic a nd unpredictable.
in turn no particular configuration of the system is optimal for the system s entire operational life time.
we presented resist a framework intended to satisfy the reliability requirements while taking into consideration other qua lity attributes e.g.
efficiency through proactive reconfiguration of the software.
the three key contributions of resist are incorporation of multiple sources of information in particular co ntextual information to provide refined reliability predictions at runtime automatically find the optimal architectural configurati on that achieves the appropriate table .
execution time of re liability analysis in seconds.
num.
of commands num.
of observation execution time in sec .
.
.
.
.
.
.
.
level of tradeoff between reliability and other quality attributes and proactively adapt the sy stem by positioning it in the optimal configuration before the system s reliability degrades.
in our future work we intend to evaluate the scalability of resist in large scale software systems comprising of hundreds of components and hardware hosts.
we also intend to increase the types of reconfiguration decisions and dependability tradeoffs that resist supports.
finally we plan to investigate the use of other stochastic approaches e.g.
dynamic bayesian networks and hierarchical hmm and potentially an integration with kami to support incremental refineme nt of dtmc parameters as opposed to periodic assessment of the reliability at runtime.
.