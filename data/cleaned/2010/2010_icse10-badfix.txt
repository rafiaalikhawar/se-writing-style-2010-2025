has the bug really been fixed?
zhongxian gu earl t. barr david j. hamilton zhendong su department of computer science university of california at davis zgu etbarr davidjh su ucdavis.edu abstract software has bugs and fixing those bugs pervades the software engineering process.
it is folklore that bug fixes are often buggy themselves resulting in bad fixes either failing to fix a bug or creating new bugs.
to confirm this folklore we explored bug databases of the ant aspectj and rhino projects and found that bad fixes comprise as much as of all bugs.
thus detecting and correcting bad fixes is important for improving the quality and reliability of software.
however no prior work has systematically considered thisbad fix problem which this paper introduces and formalizes.
in particular the paper formalizes two criteria to determine whether a fix resolves a bug coverage anddisruption .
the coverage of a fix measures the extent to which the fix correctly handles all inputs that may trigger a bug while disruption measures the deviations from the program s intended behavior after the application of a fix.
this paper also introduces a novel notion of distance bounded weakest precondition as the basis for the developed practical techniques to compute the coverage and disruption of a fix.
to validate our approach we implemented fixation a prototype that automatically detects bad fixes for java programs.
when it detects a bad fix fixation returns an input that still triggers the bug or reports a newly introduced bug.
programmers can then use that bug triggering input to refine or reformulate their fix.
we manually extracted fixes drawn from real world projects and evaluated fixation against them fixation successfully detected the extracted bad fixes.
this research was supported in part by nsf career grant no.
nsf cybertrust grant no.
nsf ccf grant no.
and the u.s. air force under grant fa9550 .
the information presented here does not necessarily reflect the position or the policy of the government and no official endorsement should be inferred.
this material is based in part upon work supported by the u.s. department of homeland security under grant award number cs under the auspices of the institute for information infrastructure protection i3p research program.
the i3p is managed by dartmouth college.
the views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies either expressed or implied of the u.s. department of homeland security the i3p or dartmouth college.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.categories and subject descriptors d. .
software program verification d. .
testing and debugging d. .
distribution maintenance and enhancement f. .
specifying and verifying and reasoning about programs general terms languages reliability verification keywords bug fixes weakest precondition symbolic execution .
introduction according to idc software maintenance cost billion in accounting for as much as two thirds of the overall cost of software production.
developers spend of their time looking for understanding and fixing bugs .
fixing bugs correctly the first time they are encountered will save money and improve software quality.
researchers have paid great attention to detecting and classifying bugs to ease developers work .
in contrast not much effort has been expended on bug fixes.
when testing a fix programmers usually rerun a program with the bugtriggering input.
if no error occurs programmers hurried and overburdened as they usually are often move on to their next task thinking they have fixed the bug.
folklore suggests that bug fixes are frequently bad either by failing to cover i.e.handle all bugtriggering inputs or by introducing disruptions i.e.new bugs.
a bad fix can decrease the quality of a program by concealing the original bug rendering it more subtle and increasing the cost of its fix.
thus detecting and correcting bad fixes as soon as possible is important for the quality and reliability of software.
to gain insight into the prevalence and characteristics of bad fixes we explored the bugzilla databases of the ant aspectj and rhino projects under apache eclipse and mozilla foundations.
at the time of our survey these databases contained entries to july .
in bugzilla a bug is reopened if it fails regression testing or a symptom of the bug recurs in the field.
we hypothesized that a reopened bug might indicate a bad fix.
we read the comment histories of reopened bugs to judge whether or not the bug was reopened due to a bad fix.
programmers sometimes even admit they committed a bad fix in our survey we found statements like oh i am sorry i didn t consider that possibility and oops missed one code path.
of all reopened bugs we found that bad fixes account for in ant in aspectj and in rhino.
bugs reopened because they failed a regression test belong to the disruption dimension of 55a bad fix.
in our preliminary findings reopened bugs comprise .
of allbugs in these three projects1.
we also found that of bugs reopened due to a bad fix either had duplicates or blocked other bugs and were therefore linked to other bugs in bugzilla.
we found a total of 977bad fixes from reopened bugs2 and an additional 830duplicates i.e.bugs marked as a duplicate of a bad fix comprising of the total bugs in the apache database.
bad fixes need not manifest in reopened bugs we focused on reopened bugs because they often make bad fixes easier to identify.
our manual study undercounts the prevalence of bad fixes in the studied projects although we cannot say by how much.
in this paper we describe the first systematic treatment of the bad fix problem we introduce and formalize the problem and present novel techniques to help developers assess the quality of a bug fix.
we deem a fix bad if it fails to cover all bug triggering inputs or introduces new bugs.
an ideal fix covers all bug triggering inputs and introduces no new bugs.
we define two criteria to determine whether or not a fix resolves a bug coverage and disruption coverage many inputs may trigger a bug.
the coverage of a fix measures the extent to which the fix correctly handles all bug triggering inputs.
disruption a fix may unexpectedly change the behavior of the original program.
disruption counts these deviations from the program s intended behavior introduced by a fix.
given a buggy program a bug triggering input that results in an assertion failure a test suite and a fix the bad fix problem is to determine the coverage and disruption of the fix.
in theory dijkstra s weakest precondition wp can be used to calculate the coverage of a fix.
we start from the manifestation of the bug in the buggy version of the program to discover the set predicate of bug triggering subset of the program s input domain.
then we would symbolically execute the fixed program to learn whether starting from that set predicate inputs still exist that can trigger the bug.
however dijkstra s wp computation depends on loop invariants and must contend with paths exponential in the number of branches.
we propose distance bounded weakest precondition wpd to perform the wp calculation over a set of paths near a concrete path.
given a path and a distance budget wp dproduces a set of paths and computes the disjunction of the wp of each path.
in the context of the bad fix problem the bug triggering input induces this concrete path.
this process is sound and yields an under approximation of the set of bug triggering inputs.
we can improve our underapproximation by increasing the distance budget.
indeed in the limit when the distance budget tends to infinity wp dis precisely dijkstra s wp.
wp doffers two practical benefits.
first because we operate directly on paths we avoid both the loop invariant requirement and the path explosion problem.
second it is our intuition that paths closer to the bug triggering path are more likely to be related to the same bug and more error prone so adding them is likely to quickly approximate the bug triggering input domain at low cost.
kim et al.
showed that when a bug occurs in a file more bugs are likely to occur in that file a phenomenon they name temporal locality .
their results can be put another way defects are lexically clustered which supports our intuition since many execution paths that are close to each other are also lexically close.
1the absolute numbers are377 5200for ant 2162for aspectj and38 for rhino.
the number is2939 .
across all apache projects.
2here we restricted ourselves to bugs that had been reopened but not marked as duplicates.this approach may appear circuitous why not apply wp ddirectly to the fixed program to see if we can find an input that triggers the assertion failure?
the problem is that the original buggy input no longer triggers the bug in the fixed program.
thus the concrete path that triggers the bug in the buggy version of the program no longer reaches the assertion and may not even exist in fixed program.
computing wp based on this false path may lead to spurious or incorrect results.
regression testing is a measure of our disruption criterion a project s test suite is a parameter of the bad fix problem to take advantage of this fact.
we combine random and regression testing to calculate the disruption of a fix.
to demonstrate the feasibility of our approach we implemented a prototype fixation which automatically detects bad fixes in java programs.
given the buggy and fixed versions of a program a test suite and a bug triggering input fixation solves the bad fix problem.
our tool currently supports java programs with conditionals in boolean and integer domains.
when it detects a coverage failure it outputs a counterexample that triggers the bug in the fixed program see section .
when it detects a disruptive fix it reports the failing test cases or inputs see section .
.
from examining the counterexample or the failing test cases programmer can understand why the fix did not work and improve it.
the main contributions of this paper are we introduce the bad fix problem and provide empirical evidence of its importance by exploring the bug databases of three real projects to find that bad fixes accounts for as much as of all bugs.
we formalize the bad fix problem and propose distancebounded weakest precondition wp d a novel form of weakest precondition well suited for the bad fix problem that restricts the weakest precondition computation to a subset of the paths in a program s control flow graph.
we implemented a prototype called fixation to check the coverage and disruption of a fix.
we evaluated our prototype to demonstrate the feasibility of our approach fixation detects bad fixes extracted from real world programs.
the structure of this paper is as follows.
in section we illustrate the problem with actual bad fixes and show how our technique can detect them.
section formalizes our criteria for a bad fix and presents the detailed technique to measure them.
we describe our prototype implementation and evaluation results in section .
finally we survey related work section and conclude the paper with a discussion of future work section .
.
illustrative example this section describes an actual sequence of bad fixes for a bug from the rhino project and how our approach would have helped.
rhino is an open source javascript interpreter written in java.
javascript allows programmers to define nosuchmethod a special method that the javascript interpreter invokes instead of raising an exception when an undefined method is called on an object.
the bug which we name nosuchmethod was a lack of support for this nosuchmethod mechanism.
its fix is not complicated the final patch was less than lines.
however due to bad fixes the bug was reopened twice and three fixes were committed in three months.
figure contains the first committed fix.
on line the programmer admits that he was not sure whether this fix covered all relevant inputs.
the fix adds an if block which when an undefined method has been called extracts nosuchmethodmethod no idea what to do if it s a tail call 2if fun instanceof nosuchmethodshim op !
icode tail call get the shim and the actual method nosuchmethodshim nosuchmethodshim fun callable nosuchmethodmethod nosuchmethodshim .
nosuchmethodmethod ... figure first fix of nosuchmethod .
1if fun instanceof nosuchmethodshim 2if fun instanceof nosuchmethodshim op!
icode tail call get the shim and the actual method nosuchmethodshim nosuchmethodshim fun callable nosuchmethodmethod nosuchmethodshim.nosuchmethodmethod ... if op icode tail call callparentframe frame.parentframe exitframe cx frame null ... figure second fix of nosuchmethod .
green normal weight lines indicate changes added in this fix red strikeout lines indicate those removed and gray lines are those left unchanged.
from nosuchmethodshim and dispatches the undefined method on it passing the original test case.
however the clause op !
icode tail call could be false for an undefined method call.
the programmer missed this case.
under our criteria this fix fails the coverage check.
given buggy and fixed versions of the program fixation would compute the predicate of the bug triggering input domain and symbolically execute the fixed program with that predicate as the initial precondition.
upon reaching the exception fixation would determine the fix to be bad and return the counterexample fun instanceof nosuchmethodshim op icode tail call to the programmer.
in this example fixation can exploit the common idiom of asserting false at a code path not expected to be reached in general however the assertion that captures a bug can be more complex.
after the bug was reopened the programmer refined the fix as shown in figure .
the clause that restricted the operation mode was dropped.
inside this if block the programmer added a block to deal with the case when operation mode was set to icode tail call .
the fix handles all inputs that triggered the original bug.
however the fix failed when subjected to regression testing.
it fails the disruption check of a bad fix it excised the bug that motivated its application at the cost of introducing new bugs.
finally the programmer committed a third version of the fix which resolved the bug and passed the regression tests.
this sequence of fixes shows how easy it is to write a bad fix.
programmers considering only of a subset of the bug triggering input domain are likely to miss conditions and execution paths.
our technique can help programmers detect these conditions earlier and write better fixes more quickly.
.
approach to begin we formalize our problem domain then define the coverage and disruption of a fix.
we abstract the bug bas a failure of the assertion j. ideally we would directly compute whether dijkib ib ibbfi figure a program s input domain i the known input ibthat triggers the bug b all inputs that trigger the bug ib those inputs the fix fhandles ib new bugs bfthat fmay introduce and their inter relationships.
stra s wp from jin the fixed program is false.
this computation requires loop invariants and must contend with the path explosion problem.
we have a bug triggering input and its induced concrete failing path.
the key idea of our approach for computing whether a fix covers all inputs that can trigger a bug is to leverage that failing path to compute a sound under approximation of the bugtriggering input domain then test the fixed program against inputs from that domain.
in section .
we introduce wp dto compute that sound under approximation.
section .
shows how we use that under approximation to symbolically execute the fixed program to calculate a counterexample to the fix.
we close in section .
by presenting our algorithm for computing fix disruption which combines regression and random testing.
.
the bad fix problem a good bug fix eliminates the bug for all inputs without introducing new bugs.
we define two criteria to measure these dimensions coverage anddisruption .
we model a program p i!oas a function in terms of its input output behavior.
we assume that the bug bcauses an assertion failure in the buggy program pband that we know a bug triggering input ibsuch that equation holds.
concretely ibrepresents a failing test case i.e.
the output pb ib violates the assertion j. pb ib 6j j or equivalently pb ib j j many inputs may trigger j. definition .
specifies this set.
definition .
b ug triggering input domain .
ib fi2i pb i j jg a bug fix fcreates a new version of the program pf.
at the very least pf ib j j but pfmay not handle all of ib.
definition .
defines the subset of ibthatpfhandles.
definition .
c overed bug triggering inputs .
ib fi2 ib pf i j jg ideally a fix feliminates the bug band covers all of ib.
with respect to ib the set ibindicates the degree to which a fix achieves this goal viz.the first dimension of fix quality its coverage .
we use cov f to denote the coverage of a fix f. by definition pfis correct relative to b for the inputs in ib.
outside of ib a bad fix fmay introduce new bugs.
definition .
captures these bugs.
57definition .
i ntroduced bugs .letpobe the correct oracle for p i.e.
for all inputs poproduces the desired output.
bf fi2in ib pf i po i g thedisruption of the fix fis the set of new deviating input values it introduces viz.the set bf.
when fintroduces no new bugs bf 0and fis not disruptive.
since we do not have a program oracle in general we approximate powith the program s test suite tandpb the buggy version of the program.
section .
presents the algorithm we use to compute disruption.
along the disruption dimension we compare the quality of two fixes in terms of the bf sets they induce.
anideal fix covers all bug triggering inputs and introduces no disruptions ib ib bf figure illustrates the interrelations of the sets defined in this section.
with our coverage and disruption properties in hand we now define the bad fix problem.
definition .
b adfixproblem .given a buggy program pb a bug triggering input ib a test suite t i!o modeled as a partial function from itoo and the fix f determine the coverage and disruption of f .
we can also use our criteria to partially order fixes for the same bug.
the fix fais better than fbif and only if cov fb cov fa bfa bfb .
distance bounded weakest precondition to determine whether a fix covers the bug triggering we introduce the concept of distance bounded weakest precondition wp d which generalizes dijkstra s weakest precondition wp .
wp drestricts the weakest precondition computation to a subset of the paths near a distinguished path in the interprocedural control flow graph icfg of a program.
in the context of the bad fix problem the distinguished path is pib the concrete path induced by the known bugtriggering input ib.
in this section we explain how wp dtraverses the icfg of a program and uses levenshtein edit distance to construct the subset of simple paths over which wp dcomputes the weakest precondition.
by considering only a subset of simple paths wp dmitigates the path explosion problem and does not need loop invariants wp d programs predicates paths n0!predicates equation defines the signature of wp d which adds a path p and a distance dto the signature of standard wp.
an application of wp d p j p d first generates the set cof candidate paths at most d distance from p then computes the standard weakest precondition over only the candidate paths in c. equation defines the candidate paths wp dconsiders.
the metric dcomputes the distance of two paths.
currently we assign a symbol to every edge in the program s icfg map every path to a string and use levenshtein distance as our metric d. c fs2paths d s p dg an icfg represents loops with backedges.
thus a concrete path that iterates in a loop is not a simple path in an icfg.
to statically extract paths and compute their distance we eliminate all backedges by infinitely unrolling all loops to form an infinitely unrolled icfg denoted icfg .
figure shows a loop in an icfg and its unrolled a cfg with loop b icfg figure a cfg and its equivalent icfg .
algorithm generate paths levenshtein distance dfrom p input d distance input icfg input p g reversearcs icfg pr reverse p result paths q.enqueue hpr hii vertex path while not q.empty?
do hv pi q.dequeue ifv pr l p pr dthen result paths result paths fpg end if e min jpj jpj ifl p pr 2dthen p.append v q.enqueue hn pi 8n2hg v end if end while return result paths representation in an icfg .
all executions have simple paths in an icfg .icfg n a finite subgraph of an icfg unrolls all loops n times.
all terminating programs iterate each loop a finite number of times and can be captured by an icfg n. in particular all paths within distance dofpibstatically exist in an icfg nfor some n. hg v!2v l s s !n0 the function hgin equation returns the neighbors of a vertex in the graph g and lin equation calculates the levenshtein distance of two strings.
algorithm uses these functions to calculate c. for the sequence s algorithm uses the notation s to denote the ithcomponent of s s to denote the last component of s and s for i j jsjto denote the substring from itojins.
algorithm reverses pand the arcs in the given icfg before traversing each path until it exceeds a distance budget of 2d.
paths that reach the entry are retained only if they pass the more stringent distance das they can no longer become closer to p. algorithm handles either an icfg or an icfg but is easier to understand when traversing an icfg .
the set of candidate paths cthat algorithm outputs may contain infeasible paths such as ones that iterate a loop once more than its upper bound.
such paths are discarded in wp d s second phase.
each path in cis traversed.
when a path reaches a node a theorem solver attempts to satisfy its current predicate.
a path whose predicate is unsatisfiable is discarded.
for example a path that iterates a loop 58beyond its upper bound generates a predicate similar to i i .
the weakest preconditions of satisfiable paths are computed and combined to form a disjunction wp d p j p d c2cwp c j asdincreases wp dcalculates the weakest precondition of a larger subset of the paths over which standard wp computes in the limit wp dbecomes wp lim d!
wp d p j p d wp p j under standard wp the number of paths grows exponentially with the number of jumps in the target program.
polymorphism exacerbates this problem in object oriented programs.
in wp d the distance factor dcontrols the number of paths used in the weakest precondition computation.
when d wp donly computes wp on the path p. varying dallows one to trade off the precision of the computed predicate against the efficiency of its computation.
in contrast with standard wp moreover wp dselects paths close to the erroneous path pib.
thus wp dcan in principle find a counterexample using fewer resources than standard wp.
unlike wp wp ddoes not need loop invariants.
the difficulty of deriving loop invariants has hampered the application of wp.
indeed current tools have adopted various heuristics such as iterating a loop 5times loop condition twice its body once to circumvent the lack of loop invariants .
under wp d edit distance determines candidate paths and therefore the number of the loop iterations of each loop along the path.
wp dsupports context sensitivity via cloning the distance budget determines whether wp dexplores a path with one more or one fewer recursive calls.
though edit distance may construct infeasible paths wp computation along such a path will produce an unsatisfiable predicate which will cause wp dto discard the path.
.
detecting violations of coverage with the help of wp d the coverage of a fix f cov f can be computed in three main steps as shown in equation step 3z 9x1 xn se pf wp d pb j step 1z e pb ib d z step j .extract the concrete path pibthat the buggy input ibinduces .
compute wp d pb j pib d a and .symbolically execute pfusing ato derive pf s postcondition y and eliminate the non input variables xifrom the clause y jto yield cov f .
in the first step we run pb ib then apply eto extract pib.
recall that jis the failing assertion.
in the second step aunderapproximates the set predicate of ib the true bug triggering input domain.
in this step we compute afor various values of d depending on resource constraints.
the precision of our under approximation depends on d. starting from the weakest precondition computed for various din step anded with the assertion j the third step uses symbolic execution to compute the set of bug triggering inputs handled by the bug fix.
we eliminate non input variables i.e.intermediate and output variables from the clause as they are irrelevant to coverage which concerns only inputs.algorithm compute the disruption of a fix input i the program s input domain input pb the buggy version of the program input pf the fixed version of the program input t i!o the program s test suite r i o 2tdo standard regression testing ifpf i othen r r fig end if end for 8i2a random subset of ido ifpb i j pb i pf i then r r fig end if end for return r to decide whether fis a bad fix in terms of coverage we check the validity of y!j.
if it is valid the fix does not violate the coverage requirement.
otherwise we deem fa bad fix and report any counterexamples to the validity of y!jas new bug triggering inputs.
our assertion that fdoes not cover ibis sound because a under approximates ib i.e.
fi2i ag ib.
.
detecting violations of disruption to measure the disruption of the fix f we first run pfon the test suite as is conventional because test suites are crafted to exercise important execution paths .
each test failure is a disruption.
given a specification of a program s input i we then randomly choose an input i2in ib.
we compare the output of pbtopfto find errors not anticipated by the test suite.
each time pb i pf i we have found another disruption.
because ibunder approximates the actual bug triggering input domain ib we ignore inputs that trigger jinpb.
algorithm computes the disruptions of a fix returning a set of failing inputs.
the loop at lines samples inputs from i ignoring those that trigger the original bug.
we use the fact that pbfails the assertion jto discover such inputs.
in comparing pf andpbon those inputs we do not assume that pbhas only the one bugband works correctly for all other inputs instead we simply assume that we can consider each bug in isolation.
further outside of i bpbusefully approximates the ideal behavior of p when pb is a release deployed version of a program it presumably passed regression testing.
.
empirical evaluation our evaluation objective is two fold to demonstrate the feasibility and utility of our approach and to differentiate wp dfrom wp.
first we describe our implementation our computing environment and how we selected our test suite.
we then show that fixation detects the bad fix in our motivating example as well as five others.
we compare wp dto wp by showing how wp daccumulates path predicates and thus subsets of the true bug triggering input domain ib as a function of its parameter d. finally we close by describing how a developer might use fixation to discover bad fixes and instead commit good ones.
.
implementation many tools and techniques exist for detecting the disruption of a fix so we focused our implementation on determining fix cover59age.
we used the wala framework to extract the concrete buggy path induced by a bug triggering input and build a cfg from which we extract candidate paths using algorithm .
the extracted concrete path is the sequence of basic blocks traversed during a particular execution of the program.
icfg nis produced by traversing the cfg of each method and unrolling each loop the number of times it iterated in the concrete path and an additional xtimes according to an unrolling parameter x thus n x y where yis a loop that iterated the most times in the concrete path.
the unrolling parameter allows fixation to explore paths that loop more often than the concrete path specifies.
we then run our implementation of algorithm over this icfg nand feed each resulting path predicate to the smt solver cvc3 keeping only those that are satisfiable.
java pathfinder is the swiss army knife of java verification .
fixation uses jpf s symbc component to symbolically execute the fixed program using the weakest precondition produced above as the precondition.
if given this precondition the assertion fails in the fixed program symbc generates a concrete input that causes the failure and returns it as a counterexample.
.
experimental setup we built and ran our evaluations on a dell xps 630i with .4ghz quadcpu processors and .
gb of memory running ubuntu .
with kernel linux2.
.
generic.
fixation is built for and runs on jre .
although we found many bad fixes in the three projects we explored most of them were not fit for evaluation either the bug comments were unclear or no fix was uploaded.
no convention appears to govern the use of bugzilla.
some programmers tend to write detailed logs of their fix activity and upload their fix but most do not.
we selected the first six bugs we found whose comments proved the existence of bad fix and that had an attached fix.
five of the bad fixes are from rhino and multitask is from ant3.
currently fixation does not directly work on the original unmodified code since both wp dand symbc jpf v4.
support only java programs consisting of statements and expressions that use only boolean and integer variables.
thus we first manually sliced away all code not related to the bugs that caused the bad fixes.
we then transformed the code into an integer program that given the same inputs traverses the same paths as the sliced version of the original program.
since fixation simply ignores non integer language constructs like function calls and field or array accesses we left them in place to approximate the original program as closely as possible.
we manually transformed the conditionals in the original code into integer conditionals.
to rewrite fun instanceof nosuchmethodcall we introduced the integer variable fun int and the integer constant nosuchmethodcall int then replaced the original conditional with the conditional fun int nosuchmethodcall int .
we added logic as necessary so that fun int correctly tracked the type of original object fun.
at each point the bug manifested itself in the original program we added an assertion.
our principal goal was to faithfully retain the inherent complexity of the program s logic through the transformation.
table presents evidence that we succeeded it shows the raw lines of code the nodes and arcs in the icfg and the cyclomatic complexity cc of icfgs before p and after pitransformation.
for a program with one exit point cyclomatic complexity equals the number of decision points in the program plus one we increase it in all six cases.
.
experimental results 3the sliced and transformed versions of the bad fixes are available at .nameloc nodes arcs cc p p i p p i p p ip p i nosuchmethod multitask substring nativeerr loop pathexp table bad fix cfg complexity.
1instructioncounting ... 3stacktop indexreg 4if fun interpretedfun return processinterfun 7if fun continuation return processcon if fun idfunctionobject return processidfunobj ... assert false should never execute .
figure sliced integer version of nosuchmethod .
table details the results of evaluating the six examples.
the second column briefly describes each bad fix.
the third column contains the counterexample fixation reports.
the fourth column dpresents the edit distance used to construct the candidate paths.
c denotes the number of paths fixation explored before determining the fix to be bad.
as a point of reference for c pais the total number of paths.
time records the time to completion.
neglected execution paths the first four bad fixes in table are all due to a programmer s ignorance of potential buggy paths.
fixation detected the buggy paths missed by each of these bad fixes while exploring a limited number of paths.
once it detected a bad fix fixation reported a counterexample to help programmers refine their fixes.
since the bad fixes multitask substring and nativeerr all exhibit essentially the same symptoms as nosuchmethod we describe only nosuchmethod .
figure lists the original buggy code that required three fixes as chronicled in section .
the original bug triggering input fun nosuchmethodshim op !
icode tail call reminded the programmer that there was no block for nosuchmethodshim so the programmer committed the first fix in figure .fixation took the initial bug triggering input and buggy code ran with distance dset to zero and discovered the bug triggering input domain fun !
interpretedfun fun !
continuation fun !
idfunctionobject .fixation then symbolically executed the first fixed program imposing that predicate together with the set predicate of the program s input domain as the initial precondition4.
given that precondition fixation reached and implied an assertion failure then reported the fix bad and returned the counterexample fun nosuchmethodshim op icode tail call .
a bad fix in a loop standard wp needs loop invariants which are difficult to derive in general.
current tools usually adopt heuris4without the predicate of the program s input domain symbc may generate nonsensical inputs.
assume that a program s input domain isx x 10and the computed weakest precondition is x .
with only x symbc could generate the illegal input x .
60name description counterexample d c p atime s nosuchmethod neglect an input.fun nosuchmethodshim op icode tail call0 .
multitask forget targets size can be zero.
type vector size .
substring miss a condition.
i st sub null .
nativeerr miss handling an exception.
type nativeerror .
loop fail to detect bugs in loop.
i c m l .
pathexp miss bugs on different paths.tg ct t pri ci t null op t shne sc t true27 .
pathexplosion2 miss bugs on different paths.tg ct t pri ci t null op t sheq sc t false .
table f ixation results.
a loop b pathexp c pathexp figure feasible paths as a function of edit distance.
1private static final int m t 2private static final int i l ... 4public adapterclass createadapterclass string adaptername scriptable ins int adaptertype int i c int m l ... assert i c i l ... for int i i i c i assert i i l m l m t ... ... figure sliced integer version of loop .
tics at the cost of sacrificing precision .
here we show how wp dtackles the loop problem.
two bugs lurk in figure one outside the loop and the other inside.
the initial bug triggering input i c m l exposes only the bug outside the loop.
the first committed fix resolved only this bug.
we ran fixation with d 5on this first fix.
fixation explored candidate paths most of which were unsatisfiable.
for example computing wp on the path that takes the true branch inside the for loop in its 4th iteration generates the unsatisfiable clause i i .
disjuncting predicates from feasible paths fixation reported the bug triggering input domain i c m l i c m l i c m l i c m l .
given thispredicate as its precondition fixation output the counterexample i c m l .
in essence wp dis unaware of loops.
the candidate paths over which wp dcomputes the weakest precondition are all simple paths drawn from an icfg n. figure 6a shows the number of feasible path predicates wp ddiscovered as a function of the edit distance.
it illustrates that wp dcan produce useful results when given limited resources.
loop has infinite paths and therefore infinite feasible paths which we cut off at d .
by way of comparison we ran this example using esc java2 and jpf symbc without our path restriction.
using its default settings5 esc java2 failed to report a potential postcondition violation.
given the domain restriction we inferred in our first phase our backward symbolic execution from the assertion failure symbc does reach the assertion failure but at the cost exploring all loop iterations up to the failure as opposed to only those iterations within dof the failing iteration more importantly symbc continued searching until it reached loop iteration when we killed it.
path explosion wp dbalances scalability and coverage via its edit distance parameter d.pathexp illustrates how fixation detects potential bugs even when considering subsets of the potentially feasible paths.
pathexp occurred because rhino failed to ensure undefined null evaluated to false as required by the ecma javascript specification.
in figure six nested bugs 5esc java2 does not support assertions so we translated each assertion into a postcondition annotation.
611if tg if c t t pri c i t null bug assert op !
t sheq op !
t shne ... assignments to op bug assert op !
t sheq op !
t shne ... else if c t t pri c i t null ... bug assert op !
t sheq op !
t shne ... assignments to op bug assert op !
t sheq op !
t shne ... if op t eq op t sheq if sc t false marklabel popgoto popstack addbytecode bytecode pop bug assert op !
t sheq op !
t shne ... bug assert op !
t sheq op !
t shne figure sliced integer version of pathexplosion .
are distributed in different paths.
from the initial bug triggering input the programmer discovered and fixed only bugs and .
we ran f ixation onpathexp gradually increasing das shown in figure 6b .
as the figure depicts wp dfinds no additional paths until d .
exploring figure we find that bugs are all in the else block of the first ifstatement with conditional tg .
a path that traverses any of bugs shares few nodes with the original buggy path which traverses bugs and .
at d fixation finds the new feasible predicate tg !
c t t pri c i t null op t shne sc t true after exploring 234paths.
armed with this predicate fixation can symbolically execute the first fixed program and report a counterexample exposing bugs and .
perhaps as usual the programmer was harried and rushing.
in any case he committed a fix that corrected only bugs and .
had the programmer run fixation he would have been aware of the counterexample that his fix failed to handle.
figure 6c shows the result of running fixation with increasing don the partially fixed program.
at d fixation detects two new feasible weakest preconditions after exploring 237paths.
these predicates generate two counterexamples that identify the remaining two bugs.
wp d offers a flexible principled and resource judicious way to search paths near a bug triggering path.
.
threats to validity fixation s edit distance parameter dallows its user to trade off performance against the completeness of fixation s approximation of the bug triggering input domain.
determining the optimal setting ofdto obtain a better result is an interesting problem.
the paths wp dtraverses depends on das well as the structure of the cfg.
gradually increasing duntil detecting interesting paths or exceeding a resource threshold such as time or number of paths explored appears to be a good heuristic.fixation is currently not optimized.
caching the predicates of already explored paths would avoid redundant computation.
tabulating function summaries for reuse can also cache wp computations.
adopting lightweight predicate on the fly feasibility checking la snugglebug might remove infeasible paths at an earlier stage.
we model bugs as assertion failures.
thus fixation s applicability depends on assertions being available inferred or written by a programmer.
in many cases obtaining such an assertion is trivial as in thrown fatal exceptions .
in others it can be difficult and is an external threat to the validity of our approach an empirical study to investigate and classify those cases would help users know when fixation is and is not practical.
as with any manual study our results may exhibit selection bias.
a larger empirical study would also help in showing the technique generalizes.
we inherit our limitation to integer programs from our symbolic execution components.
this restriction makes the values of dwe report optimistic as we operate on slightly smaller sliced versions of the original program.
thus our reliance on slicing is both a construct and because slicing limits the applicability and scalability of our approach an external threat to validity.
as the state ofthe art in symbolic execution improves e.g.
via techniques such as delta execution so will the applicability of our approach.
nonetheless the evaluation results are encouraging.
fixation detects bad fixes and reports counterexamples that can help programmers realize the limitation of particular fix.
wp dhas shown itself to be a promising approach to managing the path explosion problem and side stepping the loop invariant problems.
.
related work our work is the first to offer a systematic methodology for assessing the quality of a bug fix.
it is related to the large body of work on software testing and analysis.
this section summarizes the most closely related efforts.
we divide related work into three categories practical computation of weakest precondition automatic test input generation and studies of bug fixes and code changes.
.
practical computation of wp dijkstra s weakest precondition has been extended to check the correctness of object oriented programs.
esc java pioneered its use in java .
esc java requires user defined annotations to specify the precondition postcondition and invariants.
by checking the validity of the verification condition generated from guarded commands esc java warns of potential bugs such as postcondition violations or null pointer dereferences.
esc java s checking is modular so it relies on user annotation for procedure calls.
to handle loops it heuristically iterates .
times.
snugglebug presents an interprocedural wp technique.
it introduces directed call graph construction generalization and a current search heuristic to improve the performance and precision.
polymorphism means that java programs face the dynamic dispatch problem when encountering function calls directed call graph construction helps find the exact callee without exhaustive search.
generalization enhances function summary reuse using tabulation.
the current search heuristic of snugglebug prioritizes paths with less looping or call depth.
path based wp computation complements wp computation over an entire program.
applying counterexample driven refinement blast and slam check an abstract path to see if it corresponds to a concrete trace of the program reaching an error state.
he and gupta proposed path based weakest precondition to locate and correct an erroneous statement in a function .
their path based weakest precondition is similar to our wp dwhen d .
we have assumed a fix at least covers the original bug triggering 62input so single path approaches may not handle the bad fix problem.
our approach generalizes path based wp by parameterizing the distance budget dand allowing arbitrary non zero distances.
our wp dfilters the paths over which standard wp computes.
instead of computing wp on all paths wp dapproximates the true bug triggering input domain by computing wp on paths that are close to the original buggy path.
users control the performance and coverage of wp dthrough its edit distance parameter.
as dincreases wp dgenerates more paths and takes more time to compute.
another insight of wp dis that computing the weakest precondition of simple paths near a known concrete path is precise and does not rely on heuristics the concrete path specifies how to resolve a dynamic dispatch target or determine how often to traverse a loop.
.
automatic test input generation automatic test input generation is an active area of research.
dozens of techniques and tools have been proposed.
for brevity we highlight only some of the closely related work.
cute and dart combine concrete and symbolic execution to generate test inputs for c programs.
java pathfinder jpf performs generalized symbolic execution to generate inputs for java programs.
we use symbc from jpf to generate counterexamples.
we impose preconditions to guide the symbolic execution given the set predicate of an approximation of the bugtriggering input domain as the precondition we ask whether the fixed program can reach the assertion failure or not.
this precondition restricts the search space and enhances the performance of symbc.
if symbc outputs a concrete input that causes the assertion to fail we deem the fix bad and return that input as a counterexample.
csallner et al.
s work combines static checking and concrete test case generation.
they perform random testing using the counterexample predicate generated by esc java.
random testing may miss some paths.
we symbolically execute all paths under imposed precondition.
beyer et al.
extend blast to generate testcases by finding inputs that satisfy predicates collected from all paths in the program .
we also collect predicates to generate inputs but for a different purpose beyer et al.
seek to exhaustively test one program while we use symbolic execution on a buggy and a fixed version of a program to evaluate fixes.
.
bug fixes and code changes research on bug fixes mainly falls into two camps mining software repositories and empirical study.
bugmem mines bug fix history to predict potential bugs.
kim et al.
predict faults by consulting bug and fix caches they build .
their work shows that bugs exhibit locality and inspired our design of wp d. anvik et al.
applied machine learning to find programmers who should be responsible for the fix .
weiss et al.
predict fixing effort needed for a particular bug and sliwerski et al.
proposed a way to locate code fixed using repository mining .
most of the work in this domain is probabilistic and may not be precise.
we propose a sound analysis for evaluating bug fixes every bad fix we detect is anactual bad fix.
code change is fundamental to software development.
ryder and tip propose change impact analysis to find failure inducing changes and thus judge the quality of change .
we consider a subset of the changes they consider specifically bug fixes.
change impact analysis applies delta debugging on a sequence of atomic changes drawn from the comparison of two versions to locate suspicious changes while we combine our distance bounded weakest precondition with symbolic execution to judge the quality of a fix.
differential symbolic execution seeks to precisely characterize the differences between two program versions.
dse exploitsabstract summaries of code that is common between two program versions as the effects of such code do not contribute to differences.
in contrast fixation seeks to identify not only issues of disruption but also coverage a subset of inputs for which both versions behave the same viz.by manifesting a particular bug.
mccamant and ernst compare operational abstractions of components and their potential replacements to predict the safety of a component upgrade .
our approach is more fine grained assertions need not refer to the modified component as operational abstractions must.
their focus is different from ours they seek to verify that a newer component will behave as expected under the conditions its predecessor was exposed to and we seek to verify that a component that does indeed behave differently due to a bug fix does so safely i.e.without disruption and completely i.e.handling all of ib .
regression testing validates modified software to ensure changed code has not adversely affected unchanged code .
the cost of regression testing has been extensively studied and shown that test suite size can be reduced without compromising safety .
currently we combine regression and random testing to check the disruption of a fix.
.
conclusion and future work when run on buggy and allegedly fixed versions of a program fixation reports a new bug triggering input drawn from an underapproximation of the true bug triggering input domain.
this new bug triggering input is a counterexample to the implicit assertion that the fix is good.
fixation can miss bad fixes if it fails to explore a buggy path but it is sound when it asserts that a fix is bad every counterexample fixation reports is certain to cause the fixed program fail the assertion.
we have introduced the bad fix problem and provided empirical evidence of its existence in real projects.
we have formalized the bad fix problem and proposed an approach that combined our distancebounded weakest precondition with symbolic execution to evaluate fixes and detect bad ones.
we implemented our idea in a prototype fixation and evaluated it fixation was able to detect bad fixes extracted from real world programs.
in the future we plan to extend fixation to support more language features in java and make it applicable to real code.
we intend to implement the optimizations mentioned.
unit testing is an immediate application of fixation .
a failed testcase is an ideal original bug triggering input for fixation .
self contained assertions in a test suite will allow fixation to work directly on the code and obviate manually constructing and inserting the assertion.
the fact that the distribution of code tested by unit testing is relatively local is likely to be a good fit for wp d.