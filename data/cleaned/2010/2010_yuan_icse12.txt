characterizing logging practices in open source software ding yuan soyeon park and yuanyuan zhou university of california san diego university of illinois at urbana champaign diyuan soyeon yyzhou cs.ucsd.edu abstract software logging is a conventional programming practice.
while its efficacy is often important for users and developers to understand what have happened in the production run yet software logging is often done in an arbitrary manne r. so far there have been little study for understanding loggi ng practices in real world software.
this paper makes the first attempt to the best of our knowledge to provide a quantitat ive characteristic study of the current log messages within fou r pieces of large open source software.
first we quantitati vely show that software logging is pervasive.
by examining devel opers own modifications to the logging code in the revision history we find that they often do not make the log messages right in their first attempts and thus need to spend a signific ant amount of efforts to modify the log messages as after thoughts .
our study further provides several interesting findings on where developers spend most of their efforts in modifying th e log messages which can give insights for programmers tool developers and language and compiler designers to improve the current logging practice.
to demonstrate the benefit of o ur study we built a simple checker based on one of our findings and effectively detected pieces of new problematic logging code from studied software of them are already confirmed and fixed by developers .
keywords log message log quality empirical study failure diagnosis i. i ntroduction writing software log messages is a well established programming practice to record the dynamic information during a program s execution.
it is often used in failure diagnosis auditing profiling etc.
figure shows how developers write log messages in real world open source software.
in a log message developers describe the logged event using static text and optionally record variable values related to the event.
each log message also has a verbosity level.
for instance figure shows four types of different verbosity levels fatal i.e.
abort a process after logging error i.e.
record error events info i.e.
record important but normal events debug i.e.
verbose logging only for debugging .
the verbosity levels for less critical events e.g.
debug naturally subsume those for more critical events e.g.error meaning that all the events logged under the latter are also recorded under the former.
using verbosity level users or developers can trade the benefit of sufficient log messages with their cost e.g.
performance overhead .
under the default production setting open source softwar e typically only log error events in addition to a few less than book keeping messages e.g.
info .
other gid1 gid2 gid3 gid4 gid5 gid6 gid7 gid8 gid9 gid8 gid10 gid11 gid5 gid12 gid3 gid13 gid14 gid5 gid3 gid15 gid5 gid16 gid1 gid16 gid3 gid17 gid18 gid19 gid20 gid21 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid22 gid23 gid24 gid3 gid25 gid14 gid4 gid17 gid1 gid26 gid27 gid10 gid23 gid22 gid28 gid29 gid30 gid2 gid3 gid4 gid30 gid1 gid17 gid17 gid3 gid17 gid5 gid6 gid31 gid32 gid32 gid11 gid5 gid12 gid33 gid3 gid13 gid2 gid34 gid5 gid35 gid3 gid14 gid5 gid3 gid29 gid1 gid35 gid5 gid33 gid36 gid28 gid17 gid25 gid1 gid14 gid5 gid37 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid33 gid3 gid35 gid38 gid1 gid17 gid25 gid39 gid3 gid35 gid5 gid33 gid3 gid35 gid15 gid39 gid4 gid5 gid15 gid39 gid2 gid1 gid5 gid40 gid25 gid19 gid11 gid5 gid1 gid2 gid3 gid4 gid3 gid5 gid6 gid7 gid20 gid21 gid5 gid2 gid3 gid4 gid39 gid14 gid5 gid6 gid41 gid42 gid7 gid43 gid11 gid5 gid12 gid8 gid13 gid14 gid36 gid1 gid35 gid14 gid39 gid33 gid28 gid14 gid39 gid3 gid35 gid5 gid17 gid1 gid15 gid13 gid25 gid1 gid34 gid44 gid5 gid40 gid25 gid19 gid11 gid5 gid8 gid9 gid3 gid7 gid20 gid21 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid5 gid22 gid23 gid5 gid5 gid43 gid29 gid1 gid35 gid26 gid26 gid45 gid5 gid5 gid23 gid22 gid1 gid2 gid3 gid4 gid6 gid46 gid31 gid47 gid48 gid49 gid50 gid11 gid5 gid12 gid28 gid17 gid33 gid36 gid39 gid38 gid1 gid34 gid5 gid14 gid17 gid28 gid35 gid25 gid28 gid33 gid14 gid39 gid3 gid35 gid5 gid2 gid3 gid4 gid5 gid15 gid39 gid2 gid1 gid5 gid40 gid25 gid19 gid11 gid5 gid10 gid8 gid2 gid11 gid20 gid21 gid5 gid22 gid23 gid24 gid3 gid25 gid14 gid4 gid17 gid1 gid26 gid27 gid10 gid23 gid22 gid5 gid22 gid23 gid5 gid5 gid5 gid5 gid8 gid29 gid28 gid33 gid36 gid1 gid5 gid5 gid5 gid5 gid23 gid22 figure .
log printing code examples from open source software.
verbose mode messages are typically used only during inhouse testing.
logs are particularly beneficial to diagnosing failures in the production environment which often require immediate resolutions as they directly impact the end users.
log messages printed during the production run are often the only data source available for the developers to diagnose such failures.
this is because it is often challenging to reprodu ce production failures.
first end users are often reluctant to release their failure triggering input due to privacy conc erns.
second it can be forbiddingly expensive for the vendors to recreate the exactly same execution environment e.g.
the same hardware third party library os etc.
as in the production setting.
consequently software engineers mostly rely on log messages for trouble shooting productio n failures.
besides developers logs are also used by system administrators to resolve failures caused by security atta cks hardware errors and misconfigurations.
the importance of logging has been widely identified .
consequently practically almost all open sourc e software print log messages.
for example the widely used openssh server contains log printing statements in its 81k lines of code and of them are printed under the default verbosity mode.
the importance of log message is also proved by its commercial acceptance.
it is an industry common practice for vendors to request logs or even have their systems to automatically sending the logs back periodically i.e.
call home .
as a result most modern systems today such as those from emc netapp cisco dell just to name a few are able to collect logs from at least of their customers .
once such logs are collected they can be either analyzed by human or by commercial log analysis tools e.g.
splunk or arcsight .
.
c ieee icse zurich switzerland 102a.
state of the art of logging design despite the importance of log messages logging is often a subjective and arbitrary practice in reality.
in general there is no rigorous specification or systematic process on software logging partially because logging is seldom a cor e feature provided by the vendors.
therefore in many cases log messages are written as after thoughts after a failur e happens and logs are needed.
there are a number of logging libraries such as syslog and log4j that provide better logging interface e.g.
multiple verbosity levels than general purpose output functions e.g.
printf .
but even with them it is still the developers arbitrary decisions o n when what and where to log.
recently a few research work proposed to systematically improve a few aspects of software logging.
logenhancer automatically suggest s which variable values need to be recorded in each existing log message.
however even with logenhancer developers still need to make majority of the logging decisions.
improving the current logging practice will significantly benefit from a deep understanding of the real world logging characteristics.
specifically we first need to assess wheth er the current practice is good enough and if not what are the common issues and what are their consequences.
not only it could provide programmers with useful guidelines and motivations for better logging but also shed lights to new tools and programming language support for systematic logging better testing of logging logging improvement e tc.
b. our contributions this paper makes the first attempt to the best of our knowledge to study the practice of software logging.
speci fically we try to answer the following questions i how pervasive is software logging?
ii is the current logging practice good enough?
iii if not how are developers modifying logs?
to answer these questions we study the logging practice in four pieces of large widely used open source software including apache httpd openssh postgresql and squid each with at least over years of developing history.
to understand the pervasiveness of logging we study the density of log messages in source code and the churn rate from the revision history.
answering question ii and iii is more challenging because judging the logging efficacy requires deep domain expertise.
we address this challenge by studying developers own modifications to their log messages.
specifically we systematically and automatically analyze the revision his tory of each log message.
we further separate those log modifications that are indeed modifying log messages as afterthoughts from those merely consistency updates together with other non logging code changes.
then we analyze each category separately with a focus on the former.
table i summarizes our major findings and their implications.
overall our study makes the following contribution s our work is the first to the best of our knowledge to provide quantitative evidences that logging is an important software development practice.
we find that despite the importance of effective logging unfortunately developers often are not able to make log messages right at the first time.
therefore many of the log messages need to be modified as afterthoughts .
by examining developers own modifications we identify the particular aspects in logging choices where developers spend most efforts to get them right.
such findings can shed lights on various new tools and program language supports to improve log messages.
to demonstrate the potential benefits of our findings we developed a simple checker to detect problematic verbosity level assignment inspired by our finding .
we detected new problematic cases in the latest versions of the four pieces of the studied software.
of them have already been confirmed and fixed by the developers as a result of our bug reports.
this result confirms that our findings are indeed beneficial to tool developers to systematically help programmers to improve their log messages.
while we believe that the open source software we examined well represent the characteristics of current loggi ng practice we do not intend to draw any general conclusions.
our findings and implications should be taken with the examined open source software and our methodology in mind see our discussion about threats to validity in section ii .
ii.
m ethodology a. software used in our study we study four large widely used software programs with over at least years of developing history namely apache httpd openssh postgresql and squid.
table ii provides the descriptions.
each of them is popular as it is ranked either first or second in market share for its product s category.
the lines of code loc is measured usingsloccount which excludes non functional code such as comments white spaces etc.
all of the software we study include server component.
we choose servers because first their availability and reliability are often important since they tend to be used as infrastructure software providing critical servic es e.g.
e commerce services and thus many users and other applications are depending on them.
second runtime logs are particularly important for diagnosing server failures which are hard to be reproduced due to the privacy and environment setting issues.
they typical ly run for a long period of time handle large amounts of data from users perform concurrent execution and are sometimes deployed in a large distributed environment forming server farms all of which make failure reproduction and diagnosis difficult.
2103table i our major findings on real world logging characteristics and their implications .
density of software logging section iii a implications on average every lines of code contains one line of log ging code.
similar density is observed in all the software we stud ied.logging is pervasive during software development.
benefit of log messages in failure diagnosis section iii b implications log messages can speed up the diagnosis time of productio n run failures by .
times .logging is beneficial for diagnosing production run failures.
churns of logging code section iii c implications the average churn rate of logging code is almost two times .
compared to the entire code.logging code is being actively maintained by developers.
in contrast to its relatively small density logging cod e is modified in a significant number of all the committed revisions.logging code takes a significant part of software evolution despite its relatively small presence.
of modifications on logging code are after thoughts.
the remaining ones are updates together with other non logging code changes within the same patch to make them consistent.
more t han one third of our studied log messages have been modified at least once as after thoughts.the current logging practice is ad hoc introducing problem s to the log quality.
developers take their efforts to address them as after thoughts.
overview of log modifications section iv implications developers seldom delete or move logging code accounti ng for only of all the log modifications.
almost all of the lo g modifications are to the content of the log messages.we surmise there is lack of documentations explaining the purpose of log messages so that developers are conservative in deleting moving log messages.
modification to logging content section v vii vi implications developers spend significant efforts on adjusting the verbosity level of log messages accounting for of all the log improvements.
majority of them reflect the changes in develope rs judgement about the criticality of an error event.tools that systematically exposing error conditions would help testing the logging behavior.
testing and code analysi s tools need to provide more information e.g.
error conditions for developers to decide the proper verbosity.
in of verbosity level modifications developers reco nsider the trade off between multiple verbosities.
it might indic ate that developers are often confused when estimating the cost e.g.
excessive messages overhead and benefit afforded by each verbosity l evel.the scalar design of current verbosity level may not be a good way to help developers with such logging decision.
more intelligent logging methods such as adaptive logging can help balancing the trade offs.
one fourth of the log modifications are to variable l ogging.
majority of them are adding new variables that are caus ally related to the log message.
it indicates that developers oft en need additional runtime information to understand how a failure occurred.logging tools that automatically infer which variables to log e.g.
logenhancer can help informative logging.
given failing and passing test cases delta debugging can also be used to infer the relevant variables to log.
of log modifications are modifying static content t ext in log messages.
more than one third of them are fixing inco nsistencies between logs and actual execution information i ntended to record.
software can leverage programming language supp ort to eliminate certain inconsistency as squid does.developers should pay more attention to update the log messages as code changes.
tools combining natural language processing and static code analysis can be designed to detect such inconsistencies.
table ii open source software we studied .
the third column shows the popularity of the software in its ow n product category .
a mong only open source database servers it has the second largest market share .
software descriptionmarketlocverbose log messages lines of locrcsshare levels total default mode logging code per log apache httpd .
.
web server top 249k warn svn openssh .8p2 secure shell server top 81k info cvs postgresql .
.
database server top 614k warn git squid .
.
caching web proxy top 155k info bazzar total .1m b. study methodology we study various aspects of the logging practice.
to study the density of logging code we measure both the lines of code loc of the entire program and the logging code shown in table ii .
note that the loc of logging code is larger than the number of log printing statements since a logging statement might occupy more than one code lines.
the code churn rate is measured in churned loc t otal loc .
the churn rate of logging code is thus measured in churned loc of logging code loc of logging code .
we analyze each revision in the recent five year s history of software to measure the churned code.
we first measure the churn rate for each of the years then take the average of these five one year churn rates.
for studying the modifications on logging code we only focus on the modifications to the log printing behavior including verbosity levels static content variable valu es and 3104log message location.
none behavioral modifications such as renaming log printing functions or verbosity levels e.g .
fromwarn towarning indent changes etc.
are excluded from our analysis.
with the collected modifications we study the types of modifications.
in the revision history there could be two types of log modifications some are merely for consistent update with other non logging code changes within the same revision and others are modifying the logging behavior as after thoughts.
to separate the modification types one possible policy is to check whether the revisions only inclu de changes solely to logging code but not to other code.
however this is too conservative in that developers tend to batch multiple patches into one revision.
instead we use a few simple heuristics following our observations on the common logging practice developers often log right after checking a certain condition e.g.
an error condition which is usually implemented with a branc h statement e.g.
if while etc.
.
in a revision if such a br anch statement is modified together with following logging code it may not be introduced for logging adjustment but for changing program semantic together with logging.
similarl y if a variable or a function is renamed consistently both in th e logging code and non logging code within the same revision it is also not modifying the logging behavior.
since our automatic analysis may not be accurate we further manually verify our analysis result on randomly sampled modifications from each program .
our manual verification suggests the accuracy of our analysis is .
we further study the details of those log modifications.
for some types of such modifications to reason about why the previous logging was problematic or insufficient we randomly sample the same modification cases and carefully examine the relevant source code comments commit log bug reports and discussions in mailing list if any .
if we cannot clearly understand the reason we always conservatively classify them as the other category when presentin g our results.
the confidence interval of our sampling is reported together with our result whenever sampling is used .
c. threats to validity as with all the previous characteristics study our work is also subject to a validity problem.
potential threats to t he validity of our characteristic study are representativene ss of the software and examination methodology.
to address the former we selected diverse open source software in terms of functionality including web server database server caching proxy shell server and together with their client utilities all of which are widely used in their product category as shown in table ii.
they have at least years of history in their code repositories and more than static log points in source code.
overall we believe that they well represent large software which embed the current logging practices.
however our study may notreflect the characteristics of logging practices in other ty pes of non server client software such as scientific applicat ions operating systems commercial software or software writt en in other programming languages.
as for our examination methodology we try to minimize our own subjective judgement on the quality of log messages by systematically analyzing developers own modifications to the log messages.
also we examine developers commit logs comments related bug reports etc.
together with th e source code to reason about the modifications.
furthermore our study includes all of the aspects typically considered by developers for logging including verbosity level stat ic content and variables to record and log placement in source code.
as a limitation for some logging problems unknown even to the developers our methodology may also miss them since the modification is not in revision history.
however if the problem is general enough it should have been fixed in at least one of the program we studied.
we do not study the additions of new logging code.
this is because our goal is to reveal issues with the current logging practices therefore we only focus on the modifications including deletions to the previously existing logging c ode.
however adding new logging code might also reflect issues with existing logs where it is a revival of the existing logging code that has been deleted once.
while we study the deletions in such addition deletion chains we will mis s the additions where they might have important meanings as well.
however our results in table v and table xii suggest that the deletions of log messages rarely occur less than among all of the modifications .
therefore we expect that such deletion addition chains are also rare.
overall while we cannot draw any general conclusions that can be applied to all software logging we believe that our study provides insights about efficacy and pitfalls of so ftware logging particularly in open source server applicati ons written in c c .
iii.
i mportance of logmessages in this section we study the pervasiveness of software logging in reality and the benefit of software logging to production run failure diagnosis.
a. code density of sofware logging finding on average every lines of code contains one line of logging code.
similar density is observed in all the software we studied.
implications logging is a pervasive practice during software development.
the code density of software logging is shown in the loc per log column in table ii.
it is calculated using the locs of logging code and the entire code.
even in the software with least log density squid there is still one l ine of logging code per lines of code.
apache openssh postgres squidchurn ratelogging code entire code base figure .
churn rates comparison between logging and entire code.
b. benefit of log messages in failure diagnosis finding benefit of log messages log messages reduces median diagnosis time of production run failures between .
and times on average .2x speedup .
implications logging is beneficial for failure diagnosis.
we randomly sampled user reported failures from apache squid and postgresql and compared the failure resolution time between the set of failures where user provided any log messages with the ones without any log messages.
the details are discussed in our previous work .
jiang et.
al.
revealed a similar finding by studying production failures in commercial systems.
c. churns of logging code finding as shown in figure the average churn rate of logging code is almost two times .
compared to the entire code.
interestingly except for postgresql all the software show that logging code have higher churn rates than the entire code base.
implications developers are actively maintaining logging code like other non logging code for software functionality.
logging is at least as important as other part of code in the maintenance perspective.
such churns on logging code are also scattered across many revisions indicating the logging code is continuously maintained as a significant part of software evolution finding in contrast to the relatively small density of logging code finding a significant number of all the committed revisions modify logging code.
implications logging code takes a significant part of software evolution despite its relatively small presence.
overall finding and together implicate that logging code is being continuously and actively modified.
to understand what these modifications are we studied modifications from the revisions of our studied software.
table iii shows the detailed classification of modifications to logging code which is from our automatic analysis tool on committed revisions with accuracy as described in section ii b. our tool identifies a modification as a consistent update with the other changes on non logging code if the same patch contains one of the following three types of changes i modification on the conditions thattable iii modifications in each revision to the log messages .
software totalafter following other code change thoughts condition variable function apache openssh postgres squid total table iv log messages that have been modified .
log msgs apache openssh postgres squid total modified total percentage table v type of log modifications as after thoughts .
softwarelog modifications total location verbosity text variables apache openssh postgres squid total the logging code is dependent on ii re declaration of the logged variable that is also changed in logging code iii modification on a function name that is also referred in the logging code as static text.
otherwise our tool classify th e modification on logging code as an after thought.
table iv shows the number of log messages that have been modified at least once as after thoughts by these modifications.
finding modifications on logging code are afterthoughts .
the remaining ones are consistent updates with the other changes on non logging code in the same patch .
as a result of the total log messages have been modified at least once as after thoughts.
implication in current practice logging is conducted in a subjective and arbitrary way introducing problems to the log quality.
developers take efforts to improve them as after thoughts.
in remainder of the paper we will use modifications to only refer to these modifications that are notconsistent updates with other non logging code changes unless otherwis e specified.
we focus on studying these modifications as they are likely to reflect more directly developers concerns ove r the previously problematic log messages.
iv.
o verview of logmodifications in table v we further break the modifications based on what developers modified the location of logging code within the source code verbosity level static content of a log message and variables to log.
for location change we consider the logging code s relative location within a basi c block including both move and deletion.
5106table vi verbosity level modification with error event logging and with non error event logging software total error non error apache openssh postgres squid total finding developers seldom delete or move the logging code accounting for only of all the log modifications.
almost all modifications are to the content of the log messages namely verbosity level static text and variables.
implications given the lack of specifications on logging behaviors developers would not delete move log messages unless they cause serious problems section viii .
v. v erbosity levels modification this section analyzes the modifications to verbosity levels table v which indicate developers often do not assign the right verbosity level at the first time.
in table vi we further break down the verbosity level modification into those for error event logging and non erro r event logging.
in the former at least one verbosity level before or after the modification is an error level e.g .
error fatal etc.
.
these indicate that developers might have misjudged how critical the event to log is at the first place.
please recall that in these modifications developer did not change the conditions typically the error condition leading to the log messages but only the verbosity level themselves indicating they are likely after thoughts .
in the other verbosity level modifications developers change between non error also non fatal levels such as info and debug which are supposedly to record non error events.
finding majority of the verbosity level modifications reflect the changes in developers judgement about the criticality of an error event table vi .
implications tools that systematically exposing error conditions would help test the logging behaviors.
for example fault injection tools can be used to inject faults to trigger an error and consequently its error loggin g. similarly software model checking can be extended to explore the execution paths reaching the logging code.
a. reconsidering error criticality table vii breaks down the verbosity level modifications for error event logging.
more than half of the cases are changing levels between non fatal and fatal.
this class is different from others in that they are introduced to change the system s execution behavior as well as logging behavior.
specifically with the modifications developerstable vii reconsiderations of error criticality and verbosity level modification .
softwarenon fatal fatal to non error error toothersto fatal non fatal to error non error apache openssh postgres squid total363 figure .
error verbosity level modifications from postgresql changed their decision either to enforce a system to abort after logging or allow it to continue to run.
the modification from a non fatal to a fatal level is to prevent a non survivable error from propagating which can lead to serious system malfunctions or security issues.
on the other hand the modification from a fatal to a non fatal level is to avoid an unnecessary system termination on a survivable error for better system availability.
for example in figure a postgresql developers originally record an error event i.e.
an access to an unini tialized pointer at error level which could potentially introduce security holes if not aborted right away.
later th ey provide this patch only to promote the level to a panic fatal in this software that will abort the entire database backend.
as an opposite example in figure b postgresql developers prevent non critical cases from taking down the entire database by demoting the original panic toerror .
in table vii some others are changing verbosity levels between an error level and non error levels.
in those cases developers may reconsider their original judgement s about whether the event to record is an error or not because recording a real error with non default verbosity level suc h asdebug would cause missing important error messages for failure diagnosis and recording a non error event with error level might either confuse the users and developers or cause unnecessary production run overhead.
for example figure c shows that postgresql developers originally 6107missed to report a configuration error by logging it with info which is not a default verbosity level for production run in postgresql.
after suffering from diagnosing it without logs they committed a patch only to change it to error .
b. reconsidering logging trade offs as shown in table vi of the verbosity level modifications come from non error event logging.
in general non error events are logged with one of multiple verbose levels such as debug1 debug2 ... or sometimes even with a default levels e.g.
info in squid.
table viii decomposes the verbosity modifications for non error events.
table viii reconsideration of logging trade off and verbosity level modification softwarebetween verbose default between verbose to default to verbose default apache openssh postgres squid total finding for non error event logging developers reconsider the trade off between multiple verbosity levels.
it might indicate that developers are often confused when estimating the cost e.g.
excessive messages logging ove rhead and benefit afforded by each verbosity level.
implications the scalar design of current verbosity level may not be a good way to help developers with such logging decision.
adaptive logging in runtime similar to adaptive sampling can help balancing the trade off by dynamically backing off the logging rate.
in table viii more than half of the non error verbosity level modifications are changing between two verbose levels.
in all the studied software verbose levels are not enabled by default meaning that they are mostly used during in house testing.
therefore the logging overhead may be less of concern when developers make such adjustments.
instead developers probably are more concerned about balancing the amount of logs too excessive logging would rather make noises for failure diagnosis but insufficient logging would miss important runtime information.
one of the possible causes for such many adjustments within verbose levels might be because no clear division among multiple verbose levels is given in terms of purpose of use benefit and cost resulting in confusing developers when deciding among the verbose levels.
for example in squid there are debug levels out of total verbosity levels but no guidance for which cases they should be used.
indeed in their header file developers wrote a comment saying level are still being discussed amongst the developers .
we surmise that developers would decide whichtable ix modifications to improve variable logging e.g.
from integer format to float format software.
totaladd replace delete change var.
var.
var.
format apache openssh postgres squid total level to use arbitrarily at the first place and often revisit t he decision later.
figure .
example from postgresql of a verbosity level demotion from default level non erroneous to verbose level toget her with developers commit log.
for non error logging with default level e.g.
bookkeeping withinfo developers may need to carefully consider more factors since it would directly affect production run.
for example figure shows that postgresql users complained about the excessive log messages and thus developers demote the previous default level log to verbose level debug .
interestingly the developers originally assigned a default level because the event was in some new code that potentially is buggy but it resulted in excessive logging a t a user site.
in addition of course developers may need to consider logging overhead in production run.
overall setting the verbosity level by considering all those factors may not be easy at the first place or need further adjustment as software and environment changes.
unfortunately the current scalar design of verbosity leve l does not provide enough information for developers.
to help developers systematic and dynamic logging tools or assists such as adaptive logging are needed.
instead of using a statically assigned verbosity adaptive logging exponentially decreases logging rate when a certain loggin g statement is executed many times only recording its 2n dynamic occurrences.
such strategy will reduce both the amount of logs and performance overhead while preserving the first several occurrences of each log message.
vi.
m odifications to variable logging table ix shows how developers improved variable logging.
majority of them are adding new variables to original logging code which could provide more dynamic information for failure diagnosis.
for example in figure a user o f 7108bug report from user user error when setting client encoding to utf with error message failed to commit client encoding gid1 dev cannot reproduce the bug... asking for more details... ... ... ... ... dev fixed the bug.
motivated by this report should always include the parameter value we failed to assign .
patch if !
conf assign hook newval true pgc s override gid1 elog error failed to commit s conf gen.name elog error failed to commit s as d conf gen.name newval figure .
example of adding variable values to log message.
patch ap log cerror aplog info c connection to child ld closed with s shutdown client s c id type c remote uri c id type commit log it is very important that you not log any raw data from the network such as the request uri or request header fields.
so makes the server vulnerable to a denial of service atta ck .
deleted figure .
logging a wrong variable causing apache vulnerable to denial of service attack.
postgresql reported a production run failure with an error message printed by the software.
unfortunately developer s could not diagnose the failure due to the lack of runtime information.
only after a couple of rounds of back and fort h discussion with users they resolved this.
from the lessons later they committed a patch only to a new variable causallyrelated to the logging point.
finding one fourth of the log modifications are to variable logging.
majority of them are adding new variables that are causally related to the log message.
it indicates that developers often need additional run tim e information to understand how a failure occurred.
implication logging tools that automatically infer which variables to log e.g.
logenhancer can help informative logging.
given failing and passing test cases delta debugging can be used to log those variable values that are specific to a failing run.
interestingly once variables are introduced into logging code they are seldom deleted as shown in table ix.
probably it is because recording unnecessary variables oft en would not introduce serious concerns besides one or two useless variable values in the log.
however there can also be certain variables that should not be logged considering security and privacy concerns and developers should be careful to avoid them.
figure shows that apache developers deleted a variable including a client s uri from the logging code since recording it could make the server vulnerable to denial of service attack .
to further understand why variables are deleted or replaced in the logging code we manually study such modifications that are randomly sampled.
as a result table x shows that i as the most dominant case the original logging code records wrong variables at the first place eith ertable x variable replacement and deletion .
the margin of errors are shown at confidence level .
wrong incon read redun othervar.
sistency ability dancy permanently set uid struct passwd pw if temporarily use uid effective fatal restore uid temporarily use uid effective fatal permanently set uid temporarily use uid effective function name mismatch!
figure .
example of inconsistency between log messages and the code in openssh.
this patch is just to fix this inconsistency.
only by mistakes or by not being aware of security or privacy concerns ii other non logging code was evolved but the variable logging was not updated together becoming inconsistent iii an error number such as errono was printed without interpretation requiring replacement to readabl e description iv a log message includes redundant variabl es preferred to be deleted.
the remaining cases where we cannot understand the modifications from their source code commit logs or comments belong to the other category.
vii.
m odifications to static content of the log modifications are modifying the static content text in log messages.
since it is challenging to automatically analyze the text written in natural language we randomly sampled modifications and studied them which are shown in table xi.
table xi improving static content of log messages .
the margin of errors are shown at confidence level .
incon clarifi spell incorrectotherssistency cation grammar content .
.
.
.
.
in some cases developers modified the out ofdate log messages that are inconsistent with the actual execution information which could mislead and confuse the developers or users please note that those consistent updates of both log and code in the same patch are excluded from our analysis by our analysis tool .
majority of them are related to function name changes.
for example in figure openssh developers changed a function name from restore uid to permanently setuid but forgot to update the logging code to record this name.
later they were confused with the out of date log message while trying to resolve a failure.
finally they committed this patch just t o fix the inconsistent logging code.
such inconsistency can be partly avoided by using programming language support.
for example c programming language provides a macro function as part of the ansi c99 standard which holds the function name within which the code is currently executing.
as a good logging practice as shown in figure squid started to use this in its logging code to automatically recognize a function here is a macro that you can use like this debugs here some message define here file line function patch if fd gid1 debugs blockingfile open got failure errno debugs here got failure errno fixing inconsistency using here figure .
the use of the programming language support to hold location information for log messages in squid.
name and log it.
this eliminates the need for developers to manually record or update a location information avoiding the inconsistent update problem at the first place.
to detect other inconsistent updates e.g.
an event to log and its description it would be beneficial to use natural language processing together with static source code analy sis similar to icomment which uses natural language processing to automatically analyze comment and source code in order to detect inconsistency.
finding more than one third of modifications to static content are fixing inconsistency between logs and actual execution information intended to record.
software can leverage programming language support to eliminate some of the inconsistency as squid does.
implication tools combining natural language processing and static code analysis can be designed to detect such inconsistency.
bug report from user confusing message in log file i changed the postgresql.conf file and see the following messages so i expect both newly enabled archive command and shared buffers not to take effect.... but in fact archive command does take effect.
patch ereport error gid1 parameter s cannot be changed after server start gconf na me gid1 configuration file change ignored attempted change of parameter s ignored gconf name this parameter cannot be changed after server start parameter shared buffers cannot be changed after server start gid1 configuration file change ignored gid1 figure .
example of a log message clarification from postgresql.
in some other cases developers modified static content of log messages to clarify the event description in it.
as an example figure shows that a log message in postgresql was unclear and thus it misled a user to believe that all his configuration changes would lose effect which was not true.
at the end the modification was made only to clarify the content of the log message.
viii.
l ocation change as we discussed in finding developers seldom delete or move logging code once it is written.
to understand under which cases developers delete move logging code we randomly sampled such cases from the location modifications and manually examined them.
the table xiitable xii reasons for moving or deleting log messages software misleading reduceothersfailure log msg.
noises sigusr2 handle int sig debug sigusr2 handle sigusr2 received.
n no debug here bad things happen if the signal is delivered during debug i o in signal handler can corrupt the system state.
figure .
deleting logging from a signal handler in squid.
summarizes the results with the sampling errors at the confidence level.
interestingly of the location changes were required because the original logging code was misplaced and resulted in software failures.
for example logging in signal interrupt handlers is dangerous since the non reentra nt i o operations during logging might corrupt system states and open up vulnerabilities.
figure shows a patch to delete such a problematic logging code from a signal handler in squid.
in addition logging variables before their initialization would result in system crash or misbehavior logging non error events with fatal verbosity level will unnecessarily terminate the software execution.
to identi fy these problems above in house testing tools and static analysis tools can be extended to explore logging place.
for example we can use static analysis to detect logging statements within interrupt handlers and the use of uninitialized variables.
in some cases developers delete some misleading log messages e.g an error message printed under a non error situation .
from several commit logs we find that some developers tend to actively log certain events simply with t he error verbosity level for the purpose of in house testing then forgot to completely delete them before the production release.
in other cases log messages are moved out of a loop body or combined into one that can summarize them probably in order to avoid overhead and noises from excessive logging.
finally the others category include s the cases that we cannot clearly understand.
ix.
v erbosity level checker to show the feasibility of automatic logging assistance from our findings we designed a simple verbosity level checker which helps identify certain type of problematic verbosity level assignment.
this is motivated by the signi ficant number of verbosity level adjustments finding .
our checker is based on the observation that if the logging code within the similar code snippets have inconsistent ver bosity levels at least one of them is likely to be incorrect .
first the tool identifies all the code clon es in the source code we used cp miner to detect code clones .
then it further checks each pair of clones to see whether they contain logging code and their verbosity level s are consistent.
9110table xiii verbosity level inconsistency detected .
apache openssh postgres squid inconsistency as a result our checker detected inconsistent pairs of logging code as shown in table xiii.
we reported cases to the developers.
of them are confirmed and fixed are confirmed as false positives where the cloned code snippets are in different contexts so they shoul d have different verbosity levels and the remaining one s are not being responded.
this result shows that based on our finding even a simple checker can effectively help for better logging.
it confirms that the first important step towards systematic and automat ic supports for better software logging is to understand the current manual efforts for logging which is exactly the goa l of this work.
x. r elated work logging effectiveness study two pieces of recent work studied the effectiveness of logging in fail ure diagnosis as one part of their work.
logerr characterized the problem of lacking of log messages for diagnosis and suggest to check generic error conditions and log all detected errors i.e.
where to log .
they further proposed a tool to automatically insert error messages for those gener ic error conditions.
in contrast we focus on many other aspect s of logging decisions such as verbosity levels static cont ent variable values etc.
in particular logerr studied failur es but not programmer s modifications on existing log messages.
also it only studied the default mode log messages where as we study allthe messages in this work.
therefore all of our findings except finding are unique to this work.
jiang et al.
mainly studied the correlations among root causes of storage system failures impact and diagnosi s time.
one of their finding confirms the benefit of logging but does not provide detailed efficacy of logging practices.
logging improvement there have been some work to help systematically improve logging.
some can help developers in inserting new log messages but only for error conditions .
smell detects some exception handling code which is not logged or inappropriately logged.
some other work propose to generate error checking code e.g.
assertions from a program specifications which provide natural logging plac es for error messages.
logenhancer can suggest new variable values to be recorded in each existing log message by analyzing the source code.
our work is complementary to the tools for log improvement as the characteristics of logging practice we reveal ca n be used to either support the usefulness of these tools and inspire future tools.log analysis work many systems analyze the productionrun logs for post mortem diagnosis .
some of them learn statistical signatures to dete ct and diagnose anomalies.
sherlog infers the partial execution paths by mapping log messages to source code.
mariani and pastore analyze logs to learn the correct dependency between log messages from the normal executions and use the information to identify anomalies in fail ed executions.
the effectiveness of these work depends on the quality of log messages thus can potentially benefit from our study.
xi.
c onclusions this paper presents the first to the best of our knowledge attempt to study the practice of software log messages using four pieces of large open source software.
we first quantify the pervasiveness and the benefit of software logging.
by further studying developers own modifications on their log messages we found they often cannot get the log messages right after the first attempts.
in particular developers sp end significant efforts in modifying the verbosity level stati c text and variable values of log messages in various ways but rarely change the message locations.
by identifying the se common log modification efforts that are done manually we reveal many opportunities for tools compiler and programming language support to improve the current logging practices.
such benefit of our findings is confirmed by a simple checker we built which is motivated by identifying developers large amount of manual efforts in modifying the verbosity level that can effectively detect new pieces of problematic logging code .
acknowledgement we thank the anonymous reviewers for their insightful feedback.
this research is supported by nsf cns0720743 grant nsf ccf grant nsf cns0615372 grant nsf cns career award nsf csr small grant and netapp gift grant.