orbs language independent program slicing david binkley nicolas goldy mark harmany syed islamy jens krinkey shin y ooy loyola university maryland baltimore usayuniversity college london london uk abstract current slicing techniques cannot handle systems written in multiple programming languages.
observation based slicing orbs is a language independent slicing technique capable of slicing multilanguage systems including systems which contain third party binary components.
a potential slice obtained through repeated statement deletion is validated by observing the behaviour of the program if the slice and original program behave the same under the slicing criterion the deletion is accepted.
the resulting slice is similar to a dynamic slice.
we evaluate five variants of orbs on ten programs of di erent sizes and languages showing that it is less expensive than similar existing techniques.
we also evaluate it onbash and four other systems to demonstrate feasible large scale operation in which a parallelised orbs needs up to less time when using four threads.
the results show that an orbs slicer is simple to construct e ective at slicing and able to handle systems written in multiple languages without specialist analysis tools.
categories and subject descriptors d. .
testing and debugging general terms algorithms experimentation measurement keywords program slicing delta debugging .
introduction since weiser introduced program slicing hundreds of papers and research prototypes have appeared.
despite significant and sustained work two long standing challenges remain open how to slice heterogeneous programs consisting of components written in di erent programming languages and how to slice systems that include binary components or libraries.
although one may be able to slice the components of the system written in a particular single language the resulting slice has limited utility because one either has to ignore e ects of the components written in other languages or use worst case assumptions.
it is typically too complicated to construct slicers for several languages and combine their analyses.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.slicing has many proposed applications including testing debugging maintenance re engineering reuse comprehension and refactoring .
however full development of these applications will not occur unless slicing can be used to slice programs written in multiple languages.
to the authors knowledge no tool exists that can slice a such system.
consider the code shown in figure which consists of three components a java and a c program connected by some logic implemented in python.
assume you want to know which statements can influence the value of the variable dots just after line of checker.java .
a slice would capture the set of influencing statements but almost no program analysis approach can handle such systems without requiring complex abstract language models or restrictions to particular fixed groups of languages .
the number of languages in a software system is often between two and fifteen and the costs of development and maintenance rise with the number of languages.
a multi language approach is likely to have much greater impact and utility than one for a single language alone and since neither traditional static or dynamic slicing is suitable an alternative approach is needed.
we present a technique that can compute slices for heterogeneous systems.
in addition to handling multiple languages it removes the need to replicate much of the compiler s work e.g.
parsing the code being analyzed when developing a slicing system by leveraging the existing build tool chain instead.
our approach thus provides a way to construct a slicer out of the build tools already being used by most programmers rather than requiring the costly development of a new language specific toolset.
figure shows the slice for the above example as computed using our implementation.
weiser defined a slice as a subset of a program that preserves the behaviour of the program for a specific criterion.
although he defined the slice subset in terms of statement deletion most slicers compute slices by analysing dependencies to establish which statements must be retained.
our approach actually deletes statements executes the candidate slice and observes the behaviour for a given slicing criterion i.e.
it observes a variable s state at a location as given by the criterion.
the resulting slices have the same observed behaviour for the criterion as the original program.
because we compute slices for a specific set of executions and inputs our slices are similar to dynamic slices.
however dynamic slicing typically uses dependence analysis to extract some information from an execution of a program to decide which statements should be retained to form the slice execute observe select .
in contrast our approach relies on observing the actual behaviour after deleting statements delete execute observe and is thus called observation based slicing.
there are two program reduction techniques that operate in a similar deletion oriented way critical slicing and delta debugging based approaches e.g.
stripe or delta .
c held by owner author.
publication rights licensed to acm.
this is the authors version of the work.
it is posted here by permission of acm for your personal use.
not for redistribution.
the definitive version will be published in the 22nd acm sigsoft symposium on the foundations of software engineering fse proceedings.checker.java 1class checker 2public static void main string args int dots int chars for int i i args .length i if args .charat i .
dots else if args .charat i args .charat i chars system.out.println dots slice here system.out.println chars reader.c include stdlib.h include stdio.h include locale.h 5int main int argc char argv 6setlocale lc all 7struct lconv cur locale localeconv 8if atoi argv printf s n cur locale decimal point else printf s n cur locale currency symbol return glue.py glue reader and checker together.
2import commands 3import sys 5use locale true 6currency ?
7decimal 9ifuse locale currency commands.getoutput .
reader decimal commands.getoutput .
reader 13cmd java checker currency sys.argv decimal sys.argv 15print commands.getoutput cmd figure example multi language application these techniques might also be considered as candidates for the observation based slicing we propose and will be discussed in detail.
the comparative study in section shows that critical slicing often produces incorrect slices while observation based slices are always correct by construction and observation based slicing using delta debugging is too expensive for practical use.
the contributions of this paper are a language independent algorithm orbs for computing observation based slices in a serial and a parallel version empirical studies that demonstrate the application operation and comparability of the approach an in depth case study that explores and illustrates characteristics of our approach and a parallelised implementation of orbs that significantly decreases the runtime.checker.java 1class checker 2public static void main string args int dots for int i i args .length i if args .charat i .
dots reader.c include locale.h 2int main int argc char argv 3struct lconv cur locale localeconv printf s n cur locale decimal point glue.py 1import commands 2import sys 3use locale true 4currency ?
5ifuse locale 6decimal commands.getoutput .
reader 7cmd java checker currency sys.argv decimal sys.argv 9print commands.getoutput cmd figure sliced example from fig.
.
slicing definitions program slicing is classified as either static or dynamic a static slice considers all possible executions while a dynamic slice considers specific executions.
we will show how to derive observationbased slicing from the traditional forms of dynamic slicing.
.
traditional slicing static slicing computes a subset of a program such that executing the subset will have the same behaviour for a specified variable at a specified location the slicing criterion as for the original program for all possible inputs.
dynamic slicing uses a specific input and only preserves the behaviour for that input.
most work on dynamic slicing e.g.
the work of agrawal and horgan o ers only a description rather than a definition of the term.
thus there exist many di erent formulations of dynamic slicing relating to the particular technique being reported to compute the slices rather than to a general definition.
we use a generalised definition of dynamic slicing that involves a state trajectory and a projection function proj .
informally each state in a trajectory gives the value of each of the program s variables while the projection function extracts those values relevant to a slicing criterion.
the generalised definition of a dynamic slice is based on weiser s definition of a static slice additions are shown in italics .
this definition is similar to korel and laski s definition dynamic slice adynamic slice sof a program pon a slicing criterion cand for inputsiis any executable program with the following two properties .scan be obtained from pby deleting zero or more statements from p. .whenever phalts on input ifromiwith state trajectory t then salso halts on input iwith state trajectory t0 and proj c t proj c t0 where proj cis the projection function associated with criterion c.the projection function and the criterion define the type of dynamic slicing.
usually the criterion for a dynamic slice includes the inputs iand is given as vi l i denoting variable vat location lfor the ith occurrence in the trajectory.
however this can also be specified as v l i denoting variable vat location lfor all occurrences in the trajectory.
naturally one is interested in the smallest slice possible.
a slice is considered to be minimal if no further statements can be removed from it.
there may be more than one minimal slice for a given program and slicing criterion .
.
observation based slicing the definition rather than the usual approach to the computation of a dynamic slice holds the key to solving the challenges of multilanguage slicing slicing by actually deleting statements in a file of interest and executing the program to observe if the projected trajectory changes.
slicing operations need only take place in the source file s of interest the remainder of the system i.e.
binary components or other source files can remain untouched.
for the slice taken with respect to a given slicing criterion i.e.
a variable at a specified location for a specific input the observationbased slicing tool must capture the state trajectory for the slicing criterion all other elements of the trajectory are removed must be able to delete statements from the components of interest and may leave intact other components including binary components and other source files.
using the observation based slicing approach one can slice any system where statements can be deleted from the components of interest the component containing the criterion can be instrumented to capture the projected trajectory for the criterion and the system can be built and executed with the modified components.
in one sense observation based slicing can be seen as drawing on the kind of ad hoc behaviours of developers when debugging through formalisation we gain reliability and repeatability.
observation based slicing is based on preserving the relevant part of the state trajectory from the execution of an original program p. observation based slice anobservation based slice sof a program pon a slicing criterion c v l i composed of variable v line l and set of inputs i is any executable program with the following properties .the execution of pfor every input iinihalts and produces a sequence of values v p i v l for variable vat line l. .scan be obtained from pby deleting zero or more statements from p. .the execution of sfor every input iinihalts and produces a sequence of values v s i v l for variable vat line l. .8i2iv p i v l v s i v l .
we call the sequences vtrajectories for the criterion v l i .
an implementation of observation based slicing produces v p i v l by injecting just before line l a statement that captures the value ofvand writes it to a file.
the comparison of the trajectories restricts the observable variables somewhat their values must be comparable between di erent runs requiring serialisation for objects for example .algorithm orbs orbslice p v l i input source program p fp1 png slicing criterion v l i and maximum deletion window size output a slice s ofpfor v l i o setup p v l v execute b uild o i s reverse o repeat deleted false i while i length s builds false forj 1to s0 s fsi smin length s i j g b0 build reverse s0 ifb0built successfully builds true break ifbuilds v0 execute b0 i ifv v0 s s0 deleted true else i i until deleted return reverse s we are interested in minimal subsets thus we delete as many statements from pas possible such that the subset is still an observation based slice i.e.
it is not possible to delete another statement.
however we are not aiming at finding the globally smallest possible subset global minimum as this search becomes computationally intractable.
we need our concept of a statement to be language independent.
therefore we delete lines from a source file and assume that the source files are formatted in such a way that there is no more than one statement on a single line.
when this assumption is violated the orbs slicer will still produce slices but may produce larger slices since the granularity of deletable objects will be coarser see section for a more detailed discussion .
usually a source code beautifier or formatter can be used to split lines that contain multiple statements.
.
orbs our algorithm for observation based slicing orbs works by iteratively deleting longer sequences of lines as long as the result is an observation based slice until no more lines can be deleted.
a single iteration of orbs attempts to delete from the source code and validates the deletion by compiling and executing the candidate and comparing the trajectory against the trajectory for the original program.
if a deletion produces compilation errors the deletion cannot produce a correct executable slice.
similarly if a deletion leads to a slice that produces a di erent trajectory from the original the slice is not correct.
a deletion is accepted as a part of a valid slicing action if it passes both checks.
.
algorithm and implementation algorithm presents orbs.
it starts by setting up the program to capture the resulting trajectory for slicing criterion v l and then executing it for all inputs i storing the trajectory.
the setup step simply inserts a line without side e ects just before line l1if x 2print x 4y slice on y figure example code for deletion window that captures the value of variable v. the main loop tries to delete lines as long as the deletion still results in a slice until no more lines can be deleted.
it does this using a moving deletion window mdw implemented by the forloop on line which tries to find the minimal sequence of lines that can be deleted such that the deletion results in a compilable program s0.
ifs0builds it is executed at line and the trajectory is captured.
if this trajectory is the same as the original trajectory the algorithm accepts s0as a slice i.e.
accepts the deletion and continues looking for deletion opportunities in s0.
otherwise it rejects the deletion and continues to the next line of the file being sliced.
for example figure shows the slice generated by orbs for the program shown in figure .
orbs has removed the code in checker.java responsible for counting digits and printing the results in reader.c the code for the currency symbol has been deleted and in glue.py one of the invocations of reader has been removed.
the deletion window size parameter places an upper bound on the number of lines that can be deleted together in one deletion operation.
higher values o er potentially more precise slices but at the cost of increased slicing time.
for example consider the code segment shown in figure .
orbs cannot produce the minimal slice i.e.
line by attempting to delete only a single line at a time.
while deleting line alone isa legitimate slicing action lines and can only be deleted in tandem because deleting only one of them results in a syntax error.
orbs avoids this issue by increasing the deletion window until the result compiles.
assume that the maximum deletion window size is .
in the initial pass mdw only supports the deletion of line other lines cannot be deleted either because of syntax errors from deleting line alone or lines and or trajectory comparison failures from deleting line when the slice s trajectory won t match the original trajectory .
after the deletion of line in the next pass the original lines and are adjacent and can be deleted together at which point we achieve the desired slice.
through experimentation we have found three to be a good maximum deletion window size.
orbs does not know anything about the programming language not even how comments are represented.
a deletion of a blank line or a line that is part of a comment will not change the behaviour of the program.
our implementation rather than undertake the expense of re testing in such cases caches intermediate results in b uild and execute.
if a subsequent build produces a cache hit then there is no need to run the test cases as the cached result can be used.
avoiding unnecessary builds and or executions is particularly beneficial when a deletion leads to a non terminating program detected using a timeout .
avoiding re executions that timeout saves a significant amount of time.
this approach is used in the experiments reported in section where the number of test executions needed is essentially halved as a result.
.
orbs variants the orbs algorithm considers the program from its last line to its first.
otherwise an additional iteration of the algorithm s main loop is often required because variable definitions are typically lexically earlier in code than their uses.
consequently the definition can only be removed after all uses causing the additional loop iteration .reversing the code means that the deletion of the definition will be attempted last.
forward orbs f orbs is defined by skipping the reverse lines and of the orbs algorithm and building s0 rather than reverse s0 in step .
two other variations are considered in the experiments.
these two are based on delta debugging .
a delta debugging based orbs replaces the deletion operations of the orbs algorithm with ddmin so that the program is split into large chunks on which the deletion is then attempted.
if no deletion is possible the size of the chunks is decreased until no more decrease is possible.
the first variant considered dd orbs uses plain delta debugging while the second mdw dd orbs uses the moving deletion window approach.
plain delta debugging continuously decreases the size of the deltas it deletes.
when the delta has reached the size of a single line delta debugging can no longer delete a line that can only be deleted together with one of more other lines.
mdw dd orbs therefore uses a deletion window as soon as the delta debugging has reached a delta size of one line.
the characteristics of these four variants are explored in section .
.
research questions we will study observation based slicing and our implementation orbs using the following research questions.
rq1 how does orbs compare to the results of related approaches?
the first research question addresses the features of orbs slices by comparing the computed slices to those computed on the same programs by alternative approaches.
the scope of the investigation is restricted to multi language capable slicing techniques thus ruling out most dynamic slicing approaches .
section compares results from stripe critical slicing manuallyidentified minimal slices and the four orbs variants described above.
rq2 how does observation based slicing scale?
assuming the answers to the first research question indicate that orbs performs as well or better than alternative approaches this question will investigate how it behaves on a larger case study the program bash .
results are described in section .
rq3 how can observation based parallelised?
orbs is a sequential iterative algorithm which needs large numbers of compilations and executions.
section will investigate a parallel version and compare the sequential with the parallel version in terms of runtime and slice sizes.
rq4 what are the impacts of external factors on orbs?
orbs depends only on the standard tools available to the programmer in his or her development environment.
it does not require bespoke dependence analysis tools hence its language independence.
since orbs relies on these tools to undertake its slicing operations the e ect of these must also be studied.
this research question investigates the e ect of the environment e.g.
compiler and operating system the e ect of source code layout and the ordering of files.
the results are described in section .
.
comparative study this section addresses rq1 looking at the operation of orbs on a range of programs.
most dynamic slicing approaches are simply inapplicable for observation based slicing by virtue of their use of the execute observe delete as opposed to the delete execute observe paradigm.
those that are amenable to a delete execute observe paradigm are critical slicing since it emphasises observation and approaches based on delta debugging since they emphasize the deletion operation .
we discuss some characteristics before undertaking a larger comparison.e s d c o dd 1j j j j j j int main int argc char argv 2j j j j int a 3j j int z 4j j j j j int x 5j j j j j int j 6j j a atoi argv 7j j j x 8j j j j j j j 9j j j a a 10j j j j if a j 11j x x else 13j z 14j j 15j j j j j j x x j 16j printf d n x slice on x 17j return 18j j j figure comparison of e executed s static slice d dynamic slice c critical slice o orbs dd dd orbs j shows that a statement is in the slice .
.
general characteristics figure shows a comparison of orbs to the approaches considered by demillo et al.
when they introduced critical slicing using a minor modification of their example.
the first column e shows the executed lines as measured by gcov.
the results of applying five techniques are then shown in the subsequent columns column s shows the static slice column d shows the dynamic slice column c shows the critical slice based on our own implementation of the algorithm of demillo et al.
column o shows the observation based slice computed by orbs and finally column dd for dd orbs.
note that only the critical and the observation based slices are actually executable.
.
.
critical slicing although demillo et al.
implemented critical slicing on top of a debugger they suggested but did not implement a simpler approach that independently deletes each individual line from the source code and then tests if the resulting code has the same behaviour on a test set.
the critical slice is the program without those lines for which the deletion produced the same behaviour.
we implemented this approach using the same framework as orbs so that we can compare critical slicing with orbs in detail.
critical slicing does not guarantee to produce legal slices although two lines may individually be removed without changing the behaviour at the criterion their joint removal may produce a program with changed behaviour or even fail to compile .
figure shows an example where either line or line can be removed without changing the outcome at line .
therefore critical slicing excludes these two lines as well as line .
however an execution of the critical slice will fail at line due to the division by zero.
observation based slices on the other hand are always correct by construction.
orbs will only remove line and line as it cannot remove line after it has already removed line forward orbs would remove line instead of line .
because critical slicing needs a fixed number of compilations one per line it may run faster than orbs.
to investigate this we retain critical slicing in our next set of experiments even though it may produce invalid slices.
.
.
stripe stripe uses delta debugging to identify the smallest subset of events in an execution trace relevant in producing a failure.
stripe first runs the program to obtain an execution trace and then1int main int argc char argv 2int a b x y 3a not in the critical slice 4b not in the critical slice 5x a b 6y x ?
7printf d n y slice on y 8return not in the critical slice figure example a critical slice is not a valid slice e st c o 1j j sum 2j mul 3j j j j print a?
a 4j j j print b?
b 5j j j while a b 6j j j j sum sum a 7j j j j mul mul a 8j j j j a a 9j j j 10j j j j print sum sum n 11j j j j print mul mul n figure stripe test case sample.pl uses a debugger to skip statements in the trace.
stripe works with perl programs and only one example is given by cleve and zeller shown in figure which is executed with the input for the slicing criteria sum in line and mul in line .
column e shows the lines that are executed for this input i.e.
all of them .
column st shows the lines that are not skipped by stripe.
stripe operates on full traces where individual statement execution instances in a trace can be omitted.
it seems that stripe never includes control structures e.g.
line and which leads to the skipping of statements that a ect the predicates e.g.
line .
orbs and critical slicing only remove the first two lines their removal does not change the outcome for the test .
stripe exhibits four disadvantages.
first it computes a trace subset which is not directly mapped onto source code.
second it does not include control structures and consequently statements a ecting them causing the result to be too small and thus not a valid slice at all .
the third is that it is prohibitively expensive not only because the use of a debugging infrastructure brings significant overheads but because the complexity of the delta debugging algorithm requires an order of magnitude more executions for the above example stripe needed executions while orbs needed only compilations and executions critical slicing only needed compilations and executions .
the last disadvantage of stripe in this context is that it operates only on a single language.
consequently we do not discuss it further in this evaluation but focus on our own delta debugging based variants.
.
empirical comparison we have now reported on our initial experiments that investigated the general characteristics of techniques that use the delete execute observe paradigm and that are candidates for observation based slicing.
we found that both stripe and critical slicing may produce invalid slices.
stripe is also prohibitively expensive and so it is omitted from the empirical study reported on in this section.
we now move on to report the results of an empirical study that compares orbs with its forward and delta debugging variants and critical slicing.
in all the experiments performed here orbs f orbs and mdw dd orbs use a deletion window size of three.
note that the variations may produce di erent minimal observation based slices depending on deletion order.table comparison of orbs variants c compilations e executions d deleted lines .
system criteria loc orbs f orbs dd orbs mdw dd orbs critical c e d c e d c e d c e d c e d fig.
dots checker.java 17z swig g runme.py 113z swig g example.c swig count example.c hanoi java ndiscs z hanoi c ndiscs 92y calendar js year calendar js year calendar js year calendar js days z calendar js days 238z calendar perl year 272y calendar perl year 275y calendar perl year y calendar perl days 274y calendar perl days y calendar php year calendar php year calendar php year calendar php days calendar php days calendar python year 199y calendar python year 200y calendar python year 200y calendar python days 201y calendar python days 200y printtokens token ind 292y printtokens cu state 259y printtokens token ind 283y printtokens state 288y printtokens state y printtokens state 293y printtokens token ind 293y printtokens state 269y printtokens token ind y notepad all concordance all 825y table shows key values for applying the four variants orbs forbs dd orbs and mdw dd orbs and our implementation of critical slicing on ten test programs and criteria.
the first column gives the test program the second the variable and location of the criterion and the third gives the number of lines.
for the five algorithms three values are reported the c column gives the number of compilations done the e column gives the number of executions done and the d column gives the number of deleted lines.
the best performing algorithm for each aspect in each case is shaded in dark gray as a visual guide.
in instances where a valid critical slice achieves the best results the second best values are shaded in a lighter gray as critical slicing often results in an invalid slice highlighted in italics .
the last column shows why a critical slice is invalid i.e.
either does not compile annotated with y or produces a di erent trajectory annotated with z i.e.
produces di erent values at the slice criterion.
it should also be noted that critical slicing never deletes more lines then orbs.
the first program is the example from figure the next three entries are an example taken from the swig distribution.
the example consists of three files a c source a swig wrapper definition and a python script using the wrapped library.
all three files are sliced and the table shows the results for three di erent criteria.
the next two tests are two towers of hanoi implementations in java and c .
four versions of a library generating an html calendar javascript perl php python have been sliced for six criteria.
we have also applied the algorithms to printtokens from sir where we used as the slicing criteria every formal parameter of type intat the beginning of its function and all 140tests for the input set.
the second to last test is the notepad example java from oracle s jdk where the criteria were the ten occurrences of a string parameter at the beginning of a method.
the final test is concordance c from sir where we used the three occurrences of the parameter locus at the start of a method as criterion.
when the system came with automatic tests we have used them as inputs.
otherwise an arbitrary input has been chosen.
we draw the following primary conclusions from this study the two delta debugging based approaches dd orbs and mdw dd orbs are an order of magnitude more expensive than orbs and f orbs making them less scalable for observation based slicing.
orbs usually needs fewer compilations and executions and deletes more lines i.e.
is faster and more precise than forbs making it attractive for observation based slicing.
in some cases mdw dd orbs can delete more lines than any other variant making it worthy of further study particularly where slice precision is paramount.
critical slicing needs the fewest compilations and executions but the critical slices are always considerably larger up to more than six times for swig and in out of cases more than twice.
since only out of slices are valid i.e.
incorrect slices we conclude that critical slicing is a poor contender for observation based slicing.
in summary we conclude that orbs and f orbs perform better than critical slicing or the various delta debugging based approaches to observation based slicing.table four files of bash which are to be sliced file lines sloc executable executed variables.c parse.y lib glob glob.c subst.c .
summary to answer rq1 we compared orbs to several techniques finding that it produces typically smaller slices that retain executability over the whole test set and that it incurs less computational expense.
although delta debugging has been used successfully in other areas it proved to be much more expensive than orbs for observationbased slicing.
since orbs has proved to be the most e ective and e cient of the techniques compared here we now investigate how it scales when applied to a larger system.
.
case study to address rq2 and as a real world case study we consider an often used non trivial application bash version .
a unix shell that is the default on linux and mac os x. the bash source package includes various tools and libraries required to build the executable.
the build is complex from a slicing perspective because during the build source code is generated from a grammar and the build itself is strongly tied to the target operating system.
together with its size this makes bash a challenge to statically or dynamically slice we are not aware of any slicer that is capable of slicing bash .
these properties make bash an excellent case study to explore in more detail the characteristics of observation based slicing using orbs.
another problem of dynamic or static slicers is that they either have to analyse the whole system including all libraries or have to know the e ects of all invoked external functions.
orbs does not need this and we will demonstrate this by applying orbs only to a small set of source files.
thebash package contains files and a total of source lines of code sloc as computed by sloccount .
it is written in eight di erent languages.
for this case study we define a scenario exercising the arithmetic functions of bash and four execution cases.
in the first two cases we explicitly choose two source files to be included in the orbs analysis.
the files to be sliced are variables.c as variables are used in the tests and parse.y as the grammar defines the input format.
the slicing of grammars has not previously been considered in the literature.
the third and the fourth cases each add an additional file to be sliced.
case adds lib glob glob.c which performs file name pattern matching and case adds subst.c which is the largest single source code file within bash.
table shows di erent line based measures for the four files the number of lines in the file the number of source lines of code sloc and the number of executed and executable lines as computed by gcov .
note that nothing in lib glob glob.c is executed in the scenario being considered because the execution of arithmetic functions does not involve file name pattern matching.
.
slicing criterion the slicing criterion we chose for all four cases is the variable valin line of file expr.c with the input given by a test file arith.tests .
at line the result of converting a string to an integer is returned to the caller of the function strlong .
it is expected that this function is called frequently while processing the test cases of arith.tests because these test cases test thetable results for four cases of applying orbs full partial trajectory files files files files lines deletions compilations cached executions cached time user 359m 287m 326m 847m lines in slice variables.c parse.y lib glob.glob.c subst.c slice size slice size sloc arithmetic functions of bash .
this expectation is confirmed by measuring the statement coverage with gcov the function strlong is invoked times causing occurrences of the criterion in the trajectory.
note that the file containing the criterion is not sliced it is not the target of the deletion in this case study.
.
executing orbs orbs relies on three operations setup b uild and execute.
for bash setup not only instruments expr.c but also runs the configuration script .
configure which configures the bash installation process for the local environment.
the compilation phase b uild strongly relies on incremental builds so that only the components dependent on the sliced files are rebuilt.
execute runs the built bash on the test suite arith.tests.
in the first two cases orbs is executed in two di erent modes.
the first referred to as full trajectory is described in section and has the criterion val expr.c .
the second referred to as partial trajectory considers only a prefix of the trajectory and is used to illustrate that we can restrict an orbs slice to a subset of the variable execution instances.
in this part of the experiment the first an arbitrary cut o entries from the trajectory are considered.
the criterion is then val expr.c .
restricting the trajectory can be used to focus on a range of computations.
we have chosen the restricted trajectory to demonstrate a di erence to dynamic slicing in dynamic slicing one usually specifies one single instance in the trajectory to be observed.
orbs can simulate this by restricting the trajectory.
case considers file lib glob glob.c part of a library included with bash .
the included libraries although they are available in source code are used as binary components in the build.
they are only compiled in the first build and all the following builds use the binary library.
case includes a fourth file to be sliced.
the file we chose to add is subst.c as it is the largest source code file within bash.
cases and use the partial trajectory.
.
results and discussion table compares the results obtained from the four cases.
it shows the number of lines that are considered and how many are deleted.
it also shows the number of compilations and executions performed by orbs the number of compilations and executions that were not necessary due to reuse of cached results and the total time taken.
for the four di erent sliced files it shows the number of sloc remaining.in the first case where two files are sliced based on the full trajectory of lines are deleted.
comparing sloc the numbers are lower from variables.c sloc have been removed leaving .
this is in line with the expectations the criterion and the files were chosen to exercise arithmetic functions involving variables less than half of the executable lines are actually executed for the test .
moreover the criterion is located in strlong converting strings to integers which results in the removal of code that deals with variables not holding integer values.
from parse.y sloc are removed leaving .
from the rules in the grammar have been completely removed and from others large parts have been removed from nonempty lines in the grammar part only are left .
most of the removed lines were in the declaration part and in the auxiliary function part in parse.y from non empty lines lines are removed leaving .
the resulting slice is very small much smaller than a static slice would be.
orbs needed compilations executions and took almost six hours on a standard pc.
this slice construction time means that orbs cannot currently be used for on demand slice construction.
however not all applications of slicing require on demand slices.
furthermore we used only standard desktop equipment more powerful equipment would reduce slice construction time and parallelisation might dramatically reduce it further.
it should also be remembered that no existing dynamic or static approach to slicing could even handle a system like bash .
section will present a parallel version of orbs which reduces the runtime to less than a third.
the switch from the full to the partial trajectory has a small e ect.
now out of lines are deleted more reducing the slice size down to .
in terms of sloc variables.c is of the original size and parse.y is of the original size.
the higher number of deletions a ects the number of compilations and executions which dropped causing a lower runtime down to less than five hours .
this change can be explained by the observation that only part of the input is considered with the partial trajectory and this part tests a smaller subset of the arithmetic functions.
the addition of the small file lib glob glob.c in case does not impact the slice of the other two files at all.
the file itself is deleted almost completely only six lines are left .
these six lines consist of three variable definitions and a function definition.
none of these six lines can be deleted because they are referenced elsewhere although the referenced function is never executed .
this observation is in line with the observation that nothing in this file is actually executed and cannot have any influence.
the fourth case adds file subst.c adding lines sloc to be considered for deletion.
so almost doubles the number of lines to be sliced thus the number of compilations and executions is also almost doubled in line with the expected linear complexity of the algorithm .
however the actual runtime has almost tripled because many more executions time out.
orbs deletes of the lines in subst.c of the sloc leaving only lines.
.
summary the case study in this section demonstrated that orbs can be used to compute slices of multi language production systems and that the resulting slices are significantly smaller than the original files.
orbs also allows the engineer to focus on slicing a specific set of files of interest.
the four cases illustrate the linear nature of the algorithm in terms of the number of lines to be sliced.
finally considering full and partial trajectories shows how only specific criterion instances can be focused on.table results of applying parallel orbs to bash full partial trajectory files files files files lines deletions serial orbs orbs orbs orbs compilations serial orbs orbs orbs orbs executions serial orbs orbs orbs orbs time user real serial orbs orbs orbs orbs .
parallel orbs orbs is inherently serial so it cannot be split up in parallel portions.
however the idea of a deletion window can be used to create a parallel variant in which a number of deletion windows of di erent sizes are tried in parallel.
the largest deletion window that succeeds i.e.
compiles and produces the same trajectory is accepted for deletion.
the other attempts are discarded.
the algorithm proceeds to the next line where again a number of deletion windows are tried in parallel.
we have implemented parallel orbs and applied it to the four experiments on bash plus four new programs.
table shows the results for serial orbs and parallel orbs with window sizes and .
as expected parallel orbs with a window size cannot delete as many lines as the serial orbs that uses a window size of .
parallel orbs with a window size of or can delete more lines than serial orbs serial orbs only increases the window size as long as the slice does not compile parallel orbs will use the largest window size that compiles and executes correctly.
the number of compilations and executions performed by parallel orbs does not increase much and often parallel orbs needs fewer compilations than serial orbs.
therefore the user time does also not increase it actually decreases which leads to a dramatic drop in real time parallel orbs with a window size of needs less time than serial orbs.
for another comparison we have sliced four more systems edis a line oriented text editor byacc is berkeley yacc bcis an arbitrary precision numeric processing language indent is a code beautifier.
in all four system we picked a formal parameter to an often called function as the slicing criterion executed the included test suite and sliced all c source files .
table shows the results which are not as clear as for bash .
parallel orbs with larger window sizes does not consistently perform better or worse than smaller window sizes or serial orbs in terms of slice size or number of compilations or executions.
however parallel orbs with a maximal window size of four is consistently faster than smaller window sizes and always much faster than serial orbs.
from the experiments above we can see that parallel orbs is much faster than serial orbs while producing similar results.
parallel orbs with a deletion window size of four needed up to less time than serial orbs.table results of applying parallel orbs to four systems ed byacc bc indent files lines deletions serial orbs orbs orbs orbs compilations serial orbs orbs orbs orbs executions serial orbs orbs orbs orbs time user real serial orbs orbs orbs orbs .
external factors this section considers rq4 discussing three external factors that impact orbs.
we have already seen in the previous sections how a small change such as the direction of deletion can make a di erence for an orbs slice.
.
file order we have seen in the discussion of the algorithm that it matters if orbs starts at the beginning and deletes in a forward direction or if it starts at the end and operates in a backward direction.
however as orbs operates on a list of files which is specified by the user the order of the files in the list may impact the slice too.
an additional experiment with the last bash case study confirms this.
reversing the order of the files led to orbs requiring compilations and executions to delete lines leaving .
not only are these numbers slightly di erent but the individual slices are too while the slices for lib glob glob.c andvariables.c have not changed the slices for subst.c andparse.y are slightly di erent.
.
environment the sliced version created by orbs is perfectly adapted to the specific configuration and environment but is fragile to deviations in the environment which can cause unexpected results.
for example even the change necessary to compute coverage information di erent arguments to the compiler may make the sliced program fail on the same input with a crash.
if the configuration of the build process forbash is changed to generate coverage information before orbs is applied then the generated slice is di erent but no longer fails.
the same sensitivity to the build and test environment holds if a di erent operating system is used a di erent compiler or just di erent arguments for the compiler.
as an example we considered the impact of optimisation when optimisation was enabled the results were significantly di erent.
other experiments with di erent operating systems osx instead of linux or di erent compilers llvm instead of gcc caused similar di erences.
in addition to di erences arising from di erent build environments and configurations some are due to explicitly undefined behaviour in programming languages.
a notorious example is c1if x 3print x 5y slice on y figure code from fig.
with di erent formatting 1main 2int x 3int j 4x j figure token level orbs slice for code in fig.
with its wide range of undefined behaviours.
this can actually generate illegal but compilable and executable programs an experience shared with similar program modifying approaches but which can be avoided by integrating validity checkers into the compilation phase.
.
source code layout clearly the layout of the code to be sliced influences orbs.
usually source code is formatted according to some guideline for example the java coding conventions or the gnu coding standards .
there is a subtle di erence between the two in c an open brace is placed on a separate line while in java it is placed at the end of the line containing the predicate.
figure shows the code from figure reformatted to place the opening brace on a separate line.
as discussed earlier orbs deletes lines of figure together.
if there are more statements between the and orbs will delete them in a first iteration.
the next iteration will delete the if statement and together.
however the code in figure has a di erent format and is processed di erently line can and will be removed independently of the following lines because the remaining statement block can be always executed without a ecting the criterion.
a question naturally follows from considering source code layout suppose orbs were to operate not at the line level but at token level i.e.
deleting tokens from the program .
here a token might be defined as a string separated by white space characters.
alternatively the definition of the underlying language may be used.
in an experiment we computed an orbs slice at the token level using the example in figure by placing each c language token on its own line.
after compilations and executions the slice in figure was produced.
it is clearly correct for the original criterion and input.
however the token based variant is much more expensive than the line based variant.
.
summary we found that the results orbs produced are strongly dependent on external factors.
however this is exactly what we want observation based slicing is to be based on the observed reality of the environment in which the code is to be built and executed.
we also found that this close coupling to the execution reality allowed orbs to produce smaller slices adapted to the specific environment in which the program is built and executed.
nevertheless orbs guarantees that the generated slice has the same behaviour as the original program for the slicing criterion.
this is a particularly attractive finding given the disappointingly large size of slices produced by existing approaches to slicing.
.
related work orbs computes observation based slices.
although there are few other techniques that do so the approach is in general similar to dynamic slicing.
dynamic slicing is a concept introduced by korel and laski .
they considered several algorithms to compute dynamic slices based on their definition.
in contrast most later work on dynamic slicing defines dynamic slicing based on the algorithms used to compute it e.g.
agrawal et al.
and demillo et al.
.
although many research prototypes and approaches exist all approaches are for a single specific programming language and use complex program analyses.
to the authors knowledge no tool exists that can slice a system written in multiple languages.
in dynamic slicing terms the closest work to observation based slicing is critical slicing where a statement is considered to be critical if its deletion results in a changed observed behaviour for the slicing criterion.
a critical slice consists of all the critical statements.
one limitation of this approach is that it considers statements to be critical although they may not be and thus could be deleted after another statement is deleted.
we have seen that critical slices are significantly larger than observation based slices and are often incorrect slices while observation based slices are correct by construction .
the idea to delete parts of a program or test input is most prominent in applications of delta debugging .
as plain delta debugging can be very expensive a few approaches have modified delta debugging so that it exploits syntax and semantics of programming languages.
hierarchical delta debugging exploits tree structures in inputs for a tree based delta debugging approach while delta is using a separate tool to flatten tree structures found in programs before applying delta debugging.
regehr et al.
exploit the syntax and semantics of c for four delta debugging based algorithms to minimize c programs that trigger compiler bugs.
one could integrate such approaches to observation based slicing.
however this would sacrifice the language independence of orbs.
the part of delta that manipulates the program after flattening is very similar to dd orbs and therefore su ers from the same problem that it cannot delete lines that can only be deleted together with the following line s .
another closely related approach is stripe which eliminates statements from an execution trace with the help of a conventional debugger.
the approach uses delta debugging to delete statements from the trace.
however stripe ignores control dependence and does not produce executable slices.
because of the use of a debugger stripe does not need any program analysis but cannot be applied to multi language systems.
two other related dynamic slicing techniques are union slicing and simultaneous dynamic program slicing .
like orbs the union slicing algorithm of besz des et al.
aims to approximate the realizable slice for a set of test inputs.
it does so by producing the union of the independently computed dynamic slices for each test case.
the algorithm uses static analysis to compute local dependency information instruments the source code and then executes it.
then it computes dynamic slices globally.
it is thus similar to orbs in requiring execution and instrumentation although orbs instrumentation is lighter weight but unlike orbs the resulting union slice is not guaranteed to be executable.
furthermore a union slice is not necessarily well behaved for the set of test cases being considered as a whole.
separate dynamic slices can interfere with each other when simply unioned together .
finally union slicing requires static dependence information which means that it is language dependent.simultaneous dynamic slicing sds addresses the problem of interference by iteratively building up a slice from a set of starting program points which may be initially empty and a dynamic slice for each execution in the test case set.
the set expands with each iteration and thus forms a partially complete slice that may be missing some dependence information until it converges.
this is e ectively a variation on the traditional union operator.
in this case rather than creating a union of program points after dependence computation sds unions slices in the light of their combined dependence information to ensure that existing dependencies are retained as the union gets bigger and that required but missing dependencies are included until no increase in size is observed.
like union slicing and unlike orbs sds requires the computation of dependence information and is thus language dependent .
it also requires a dynamic slicer meeting certain assumptions.
like orbs sds relies on instrumentation and execution for sds to generate full traces .
it also frames the slicing operation similarly to orbs as a problem of retaining the relationship between inputs and outputs and removing non influencing code.
there have been a few previous approaches to multi language slicing.
riesco et al.
parameterise languages and slice on their semantics.
however their approach is currently restricted to while languages where orbs has no such restriction and requires no semantic modelling.
finally p cza et al.
present an approach to dynamic slicing across languages on the .net platform .
their approach uses the common language runtime clr debugging framework to provide traceability between instructions and source code.
they compute a slice on the execution trace via the clr debugger.
however their approach still needs a specific analysis for every single language that not only extracts variable definitions and uses but also creates a control dependence graph.
they have only implemented their approach for a very limited subset of c .
not directly targeted at slicing mayer and schroeder advocate to explicitly specify and exploit semantic links dependences for cross language code analysis and refactoring.
they also built and evaluated an infrastructure to link artefacts between six javaframework based languages .
they use a static analysis for the java source code and link the identifier between di erent languages based on framework semantics with a hand crafted linker.
orbs is not restricted to any particular language group or underlying representation the tools that build the system can be used to undertake the slicing.
.
conclusion orbs1is the first language independent program slicer that can compute slices for systems written in multiple languages including systems which may contain binary components or libraries which cannot be analysed otherwise.
orbs uses statement deletion as its primary operation and observation as its validation criteria.
the approach leverages existing tool chains making it better suited to execution reality than previous slicing approaches based on models of dependence and semantics.
future work will use search based approaches to look for smaller observation based slices.
to reduce runtimes and produce smaller slices orbs could be extended with language specific extensions that exploit the syntax and semantics of a language without sacrificing the ability to slice multiple languages.
also other methods for making the approach faster with fewer compilations and executions will be investigated.
finally empirical study of the time versus slice size tradeo s of di erent deletion window sizes will be considered.
1available at crest.cs.ucl.ac.uk resources orbs .
.