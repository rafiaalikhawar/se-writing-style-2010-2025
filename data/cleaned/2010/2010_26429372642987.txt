automating regression verification dennis felsingy dennis.felsing student.kit.edusarah grebingy sarah.grebing kit.edu vladimir klebanovy klebanov kit.eduphilipp r mmerz philipp.ruemmer it.uu.semattias ulbrichy ulbrich kit.edu ykarlsruhe institute of technology germany zuppsala university sweden abstract regression veri cation is an approach complementing regression testing with formal veri cation.
the goal is to formally prove that two versions of a program behave either equally or di erently in a precisely speci ed way.
in this paper we present a novel automatic approach for regression veri cation that reduces the equivalence of two related imperative integer programs to horn constraints over uninterpreted predicates.
subsequently state of the art smt solvers are used to solve the constraints.
we have implemented the approach and our experiments show non trivial integer programs that can now be proved equivalent without further user input.
categories and subject descriptors f. .
specifying and verifying and reasoning about programs d. .
software program veri cation keywords regression veri cation program equivalence invariant generation formal methods .
introduction one of the main concerns during software evolution is to prevent the introduction of unwanted behavior commonly known as regressions when implementing new features xing defects or during optimization.
undetected regressions can have severe consequences and incur high cost in particular in late stages of development or in software that is already deployed.
currently the main quality assurance measure during software evolution is regression testing .
regression testing uses a carefully crafted test suite to check that a modi ed version of a program is equivalent to the original one in relevant behavioral aspects.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september v ster s sweden copyright acm ... .
.
veri cation is a complementary approach that attempts to achieve the same goals as regression testing with techniques from formal veri cation.
this means establishing a formal proof of equivalence of two program versions.
in its basic form we are trying to prove that the two versions produce the same output for all inputs.
in more sophisticated scenarios we want to verify that the two versions are equivalent only on some inputs conditional equivalence or di er in a formally speci ed way relational equivalence .
regression veri cation is not intended to replace testing as testing has unique capabilities.
tests can for instance validate non functional aspects of software e.g.
performance or its interactions with the underlying software and even hardware layers.
on the other hand regression veri cation especially if automated is an attractive additional instrument of software quality assurance.
if successful it o ers guaranteed coverage while not requiring additional expenses to develop and maintain a test suite.
at the same time regression veri cation o ers a more favorable pragmatics than standard veri cation of functional properties of individual programs.
for regression veri cation one does not need to write and maintain complex speci cations which can be a signi cant bottleneck in the verication process .
furthermore given two program versions that are both complex but similar to each other much less e ort is required to prove their equivalence than to prove that they satisfy an also complex functional speci cation.
the e ort for proving equivalence mainly depends on the difference between the programs and not on their overall size and complexity.
regression veri cation can exploit the fact that modi cations are often local and only a ect a small portion of a program.
a number of approaches and tools for regression veri cation exist already see section but the majority of them are not automatic and require the user to supply inductive invariants e.g.
.
we present an approach and a tool for automatic regression veri cation of imperative programs with integer variables.
we use automatic invariant generation techniques to infer su ciently strong coupling predicates1between programs and thus prove behavior equivalence.
our approach is targeted towards showing equivalence of programs with complex arithmetic and control ow.
this 1a coupling predicate is an inductive two program invariant that relates the two programs throughout their execution.
we are typically interested in coupling predicates that imply result equality upon termination of both programs.
p1 p2wlp vcgvc z3smteldarica3 figure architecture of our approach kind of programs is poorly supported by existing automatic approaches as these either require static i.e.
known at compile time control ow employ coarse abstractions on program computations or are overly restrictive e.g.
require small bounds on loops or that equivalent unbounded loops have equivalent bodies .
our method works well whenever su ciently simple coupling predicates over linear arithmetic exist that prove program equivalence.
this is often the case in practice as we argue throughout the paper.
in particular in section we demonstrate the e ectiveness of our technique using a collection of small but non trivial benchmarks.
in detail the contributions of this paper are a method for automatic regression veri cation for programs employing complex arithmetic on integer variables as part of the above a method for computing e cient veri cation conditions for program equivalence a tool implementing the approach available at the architecture of our approach is shown in figure and can be described as follows a frontend translates the two programs into e cient logical veri cation conditions vc for program equivalence using the algorithm presented in section .
the translation is completely automatic the user does not have to supply the coupling predicates loop invariants or function summaries.
instead placeholders for these entities are inserted into the vc formulas.
the produced vc are in horn normal form and are passed to an smt solver for horn constraints such as z3 or eldarica as presented in section .
the solver tries to nd a solution for the placeholders that would make the vc true.
if the solver succeeds in nding a solution and thus inferring among other things a coupling predicate the programs are equivalent.
alternatively the solver may show that no solution exists i.e.
disprove equivalence or time out.
.
illustration example .consider the function g1in figure a .
the function recursively computes the sum of integers in the interval also known as the n th triangular number .
the function g2in figure b computes essentially the same result but it has been optimized to employ tail recursion.
2our approach requires that the two programs which we prove equivalent have disjoint variable and function names.
to distinguish equally named identi ers from the two programs we add subscripts indicating the program to which they belong.
we may also concurrently use the original identi ers without a subscript as long as the relation is clear from the context.int g int n int r if n r else r g n n return r int g int n int s int r if n r s else r g n n s return r a basic version p1 b optimized version p2 figure computing the n th triangular number the advantage of tail recursive functions is that they can be executed without growing the stack.
to enable this optimization an accumulator parameter shas been added to the signature of g2for collecting and passing on intermediate results.
as another consequence g1performs summation from the end of the interval while g2starts from the beginning.
it is our goal to prove automatically using program verication technology that the two functions are equivalent in the sense that g1 n g2 n for anyn.
the conceptually simplest way to achieve this goal is to infer and compare a complete logical speci cation of each function such as g1 n n n 2forn and otherwise.
yet such a brute force approach is clearly infeasible at the moment or in the foreseeable future.
instead we exploit the similarities between program versions and attempt to infer coupling predicates i.e.
a relative speci cation that only states how the executions of two versions relate to each other but not what they compute in general.
of course we demand that the coupling predicate is such that the two executions terminate in the same state but in general it will be a stronger assertion.
to deal with unbounded recursion and loops the predicate must be inductive assuming that it holds at a key point of the computation i.e.
loop iteration recursive call should be su cient to show that it also holds at the next key point.
conveniently the complexity of such a relative speci cation is often proportional to the di erence between the two program versions and not the program size.
suppose we want to calculate g .
we call g1 resp.
g2 .
the functions descend recursively proceeding to compute g1 resp.
g2 and then g1 resp.
g2 .
at this point one could suspect that at every recursion step g1 n s g2 n s a simple induction proof can establish that our suspicion is indeed correct assuming this relation for the callees in both functions allows us to prove the relation for the callers.
thus the formula is a valid coupling predicate.
fortunately also implies the desired equivalence for the toplevel call with s .
indeed if one knows or guesses the formula then the fact that it is a valid coupling predicate and that it implies equivalence can be proved automatically with existing veri cation technology cf.
e.g.
.
in this paper we show that it is actually in many cases possible to automatically infer coupling predicates that imply program equivalence.
the horn encoding of the vcs for 350the illustrative example is discussed in section and can be solved by eldarica in roughly three seconds inferring the coupling predicate n1 n2!r1 s2 r2 wheren1 is the argument of g1 n2ands2are the arguments of g2 andridenote the respective return values.
we note that the coupling predicate is linear even though the mathematical function computed by the two programs is non linear.
.
program equivalence this section introduces the considered programming language and formalizes our notion of program equivalence in terms of dijkstra s weakest preconditions .
the resulting program equivalence condition can be reduced to a programfree veri cation condition by applying reduction rules for weakest preconditions.
a set of reduction rules optimized for equivalence proofs is de ned in section .
automation of the procedure is discussed in section .
the programming language.
we consider deterministic imperative programs with unbounded integer variables mathematical integers written in ansi c notation.
determinism means that program runs starting in the same state also terminate in the same state.
sequential real world programs are deterministic provided that all variables are initialized before they are used which can be e ciently checked by a compiler .
furthermore we require that all considered programs terminate for all inputs this can be checked with one of the existing termination checkers for imperative programs such as e.g.
.
to simplify presentation we assume that every function ends with a return statement and that return is always the last statement in a function.
further program features for instance heap or arrays are discussed in section .
but not the main focus of the present paper.
we also assume that all programs have a distinguished function that is the entry point of the program.
the entry point of the programs in our examples below is clear from the context.
syntactical conventions.
for reasons of presentation we require that the programs p1andp2checked for equivalence have disjoint sets of variables.
to distinguish equally named variables from the two programs we add subscripts indicating the program version or to which they belong.
we also establish the syntactic convention that program inputs i.e.
formal function parameters are designated as i1resp.
i2 returned result variables as r1resp.r2 and the vectors of all variables occurring in the programs as x1resp.
x2.
background weakest precondition calculus.
our reasoning about programs is formulated in terms of dijkstra s weakest precondition calculus .
the weakest precondition predicate wp p denotes the weakest condition that needs to hold before an execution of statement list3psuch that the execution terminates and the postcondition holds in the nal state.
the termination requirement is often considered optional.
relinquishing it one obtains the weakest liberal precondition predicate wlp p 3to simplify presentation we will use the terms statement list and program interchangeably.
the exact relation will be clear from the context.which only demands that holds after the execution of p ifpterminates.
thus the formula pre!wlp p post has the same intuitive meaning as the floyd hoare triple fpregpfpostg.
a weakest precondition calculus is a set of rules which allow the resolution of wp wlp predicates into formulas in pure rst order logic.
figure a lists a calculus for the wlppredicate for the considered programming language the rules are standard except that for technical reasons our calculus performs rewriting from the beginning of the statement list to its end while a presentation with rules operating in the opposite direction is more customary.
reduction in forward direction is more convenient however for identifying structural similarity between the programs whose equivalence is veri ed.
the calculus in figure a is complete in the sense that every wlp expression can be reduced to a pure rst order formula.
the rules and allow the direct resolution of assignments conditional statements and return statements remember that the latter may only appear at the end of function bodies .
the rule for while loops is parametrized by a loop invariant i x1 a formula which needs to hold before the loop and must be preserved by the loop body under assumption of the loop condition.
likewise the rule for a recursive invocation b f1 a of the function f1is parametrized by a function summary predicate sf1 a b that relates the arguments ato the result value assigned to variableb.
when the function summary sf1is used as abstraction for the behavior of f1 the correctness of the summary has to be justi ed globally by an additional veri cation condition wlp p1 sf1 i1 r1 in whichp1is the function body of f1.
the invariant rule and the recursive invocation rule may approximate loop or function behavior depending on the chosen invariant or function summary.
in this case the formula derived by applying the rules will still be a correct precondition but not necessarily the weakest one.
even when approximating nding suitable loop invariants and summaries is in general a di cult task.
stating program equivalence.
we consider two statement lists usually the bodies of two functions p1andp2equivalent in writing pre!p1 p2 when they behave equally return the same value for all inputs for which the precondition preholds.
we lift this notion to whole programs by de ning it as equivalence of the two program entry functions.
the precondition pre which can speak about variables from both p1andp2 makes our notion of equivalence conditional .
it is also possible to relax the equality between results to some other speci ed relation yielding relational equivalence.
these notions can be formalized using the wlppredicate introduced above.
since we assume that p1andp2have disjoint vocabulary their code can simply be combined sequentially.
we de ne pre!p1 p2 i1 i2 i1 i2 pre!wlp p1 p2 r1 r2 351this kind of construction is known as self composition .
the weakest liberal precondition predicate has been used in this de nition since we deliberately abstract from termination issues in this paper.
.
efficient conditions for program equivalence at this point one could in theory directly resolve the wlp predicate in by applying the rules from figure a to obtain a rst order veri cation condition for equivalence of p1andp2.
however the sequential composition of the two programs would require that they be analyzed individually without exploiting structural similarities between them.
instead we devise additional rules for the wlppredicate for the case that the program code given as the rst argument is composed of two pieces with disjoint vocabulary.
the disjointness allows us to use more rules than would be sound otherwise as the statements with disjoint data cannot interfere with each other.
the additional rules make use of two forms of coupling predicates that relate the states of the compared programs mutual invariants c which describe reachable states of two loops in the respective programs iterating in a synchronized manner and mutual function summariesrthat express the relative behavior of two functions in the programs.
the result of applying the new rules is a much more e cient rst order veri cation condition for equivalence.
in figure b we present the additional rules.
to make the composition of two programs with disjoint vocabulary explicit we use instead of as separator between them.
semantically both are equivalent.
in particular it is always sound to replace p1 p2withp1 p2.
conversely it is sound to replacep1 p2withp1 p2wheneverp1andp2have disjoint vocabulary.
rule allows us to swap the two programs thus enabling resolution of statements from both programs in an alternating fashion.
the rule is sound since the statements of the two programs cannot possibly interfere they have no common variables to refer to.
together with the rules and of figure a the swap rule allows us to resolve all statements but loops or recursion.
these are the di cult cases since they require nding a suitable loop invariant or a function summary.
the next two sections therefore introduce e cient rules for pairwise loops and function calls.
the wlpcalculus can isolate the relevant loop pairs from within their programs even if they are embedded into enclosing conditionals or loops.
proposition soundness and completeness .
let be a purely rst order formula derived from the condition wlp p1 p2 by rules from figure a and b .
if the program p1 p2is started in a state satisfying the precondition and terminates then holds in its nal state.
furthermore it is possible to choose suitable mutual invariants and summaries such that the derived formula is the weakest such precondition.
we give a justi cation for the validity of the proposition in the following.
.
while loops we rst consider equivalence of programs with loops but without recursive function invocations.
the loop rule forprogram equivalence is di erent from the rules discussed so far in that it talks about both programs at the same time and actually connects the two wlp while b1 p1 while b2 p2 c x1 x2 x1 x2 c x1 x2 !wlp b1 b2 c x1 x2 c x1 x2 !wlp b2 c x1 x2 c x1 x2 !wlp b1 c x1 x2 c x1 x2 !wlp p1 p2 the rule is parametrized by the mutual loop invariant c x1 x2 which is part of the coupling predicate that we are interested in.
unlike the invariant rule for a single program which has two cases loop condition holds or does not hold this rule has four possible evaluations of the two loop conditions to consider.
for the justi cation of this rule let us look at a particular reordering of the statements in the two loops.
the central idea behind the rearrangement is that the two loops can be subject to a loop fusion resulting in the following program equivalence while b1 while b2 while if b1 if b2 why is the single loop equivalent to the sequential execution of the separate loops?
running the two loops sequentially results in running the sequence of statements b1 b1 b z ntimes b2 b2 b z mtimes in which the rst loop body b1is repeated ntimes followed bymrepetitions of the second body b2.
let w.l.o.g.
the second loop be executed more often than the rst in this schematic example i.e.
m n .
due to disjoint vocabulary loop body executions from di erent programs may be swapped.
the run may hence be rearranged to b1 b2 b1 b2 b b2 z ntimes b2 b z m ntimes without changing the semantics.
one can make out miterations now of which the rst nexecute both loop bodiesb1 b2 while the remaining m nrounds only execute the second loop body b2.
the sequence is a run for the fused loop from .
it is the additional if statements that ensure that bodies are only executed as often as they would be executed in a sequential execution.
the disjunction in the guard ensures that the fused loop is iterated precisely as often as the maximum iterations of the individual loops.
applying the traditional while wlprule to the fused loop from has the same e ect as applying the twoprogram rule .
since the traditional wlpcalculus is sound and complete our extension thus inherits these properties.
mutual loop invariants are simpler than full functional invariants if the two programs are related.
to show equivalence between a while loop and a copy of itself for instance the simple invariant x1 x2is su cient regardless of what the loop computes.
352wlp x t p letx tinwlp p wlp if telsee p if then wlp t p else wlp e p wlp returnr wlp while b p i x1 x1 i x1 !wlp b i x1 i x1 !wlp p wlp r f1 t p 8r s f1 t s !wlp p a conventional wlpcalculus rules wlp p1 p2 wlp p2 p1 wlp returnr p2 wlp p2 wlp while b1 p1 while b2 p2 c x1 x2 x1 x2 c x1 x2 !wlp b1 b2 c x1 x2 c x1 x2 !wlp b2 c x1 x2 c x1 x2 !wlp b1 c x1 x2 c x1 x2 !wlp p1 p2 wlp r1 f1 t1 p1 r2 f2 t2 p2 8r1 r2 r f1 f2 t1 r1 t2 r2 !wlp p1 p2 b additional wlpcalculus rules for independent programs figure weakest precondition calculus .
recursion we now consider programs that have recursive function calls but no loops.
recursive calls of related functions in both programs can be abstracted by a single predicate a mutual function summary a term originated in that describes the relation between the arguments and result values of both invocations simultaneously and in relation to one another.
the calculus rule to handle simultaneous function invocations is wlp r1 f1 t1 p1 r2 f2 t2 p2 8r1 r2 r f1 f2 t1 r1 t2 r2 !wlp p1 p2 the rule is parametrized by the mutual function summary rf1 f2 t1 r1 t2 r2 .
abstracting function invocations with a mutual summary requires a global justi cation that the summary is a faithful abstraction and we need to add the proof obligation i1 i2 wlp p1 p2 r f1 f2 i1 r1 i2 r2 to the veri cation conditions of equivalence.
here p1and p2are the statement lists from the function bodies of the invoked functions f1and f2.
the justi cation of rule is as follows.
due to the disjointness of the program vocabulary the statements in the rule can be reordered r1 f1 t1 p1 r2 f2 t2 p2 r1 f1 t1 r2 f2 t2 p1 p2 condition guarantees that rf1 f2 t1 r1 t2 r2 is a faithful abstraction of p1 p2.
just as in the single program case it is thus sound to overapproximate the two recursive invocations with the mutual function summary.
as with mutual loop invariants mutual function summaries are simpler than individual function summaries ifthe two programs are related.
in case a recursive function is veri ed against a copy of itself the simple mutual function summary i1 i2!r1 r2can be used.
note that the same mutual summary rf1 f2 t1 r1 t2 r2 is used for every occurrence of the pair f1 f2of functions this is in contrast to the coupling invariant rule for loops where it is possible to choose di erent mutual invariants c x1 x2 for every application.
while our calculus could in principle be extended to support multiple mutual summaries perf1 f2pair the use of only a single such summary minimizes the number of required proof obligations .
.
automatic equivalence proofs the application of the wlprules in figure requires knowledge of speci c predicates namely loop invariants i i1 x1 in rule mutual loop invariants c x1 x2 in function summaries sf1 t s in and mutual function summaries rf1 f2 t1 r1 t2 r2 in .
together those formulas represent the coupling predicate that witnesses program equivalence.
derivation of summaries and invariants is in general a complicated process and can require creativity and manual intervention.
thanks to the specialized wlp rules for program equivalence however it is often possible to carry out equivalence proofs with comparatively simple predicates.
in section .
for instance it is possible to show the equivalence of programs computing non linear functions with the help of just linear predicates our experiments section show that such simple predicates are su cient for a wide range of realistic cases from regression veri cation.
we leverage recent methods for solving xed point constraints in order to compute required predicates fully automatically .
such methods are in principle incomplete but they are e ective for deriving predicates in practical cases arising from equivalence proofs.
353recursive horn clauses.
in order to derive invariants and coupling predicates veri cation conditions are represented in form of horn constraints over uninterpreted relation symbols including i c s f1 rf and then solved with the help of model checking techniques like predicate abstraction and craig interpolation.
more generally we x a set rof uninterpreted xedarity relation symbols and consider horn clauses of the form h b1 bn where is a constraint over variables occurring in the clause in our experiments is always a formula in quanti erfree presburger arithmetic but extension to other theories e.g.
arrays is possible eachbiis an application p t1 t k of a relation symbolp2r to rst order terms his similarly either an application p t1 t k of a symbolp2r to rst order terms or false.
his called the head of the clause b1 bnthe body.
in case true we usually leave out and just write h b1 bn.
first order variables in a clause are considered implicitly universally quanti ed relation symbols represent set theoretic relations over the universe of a rst order semantic structure.
a set of horn clauses hc over predicatesris called solvable if there is an interpretation of the predicates ras set theoretic relations such the universal closure of every clause h2hcholds.
example example continued .
figure shows the equivalence vc for the programs from the illustration example figure as horn clauses.
here ris the uninterpreted predicate symbol placeholder for the coupling predicate mutual function summary of g1and g2introduced by application of rule .
the uninterpreted predicatessg1andsg2are the function summaries for the respective individual functions and are introduced by .
clauses with head false result from equivalence proof obligations whereas the clauses with a head di erent from false are due to justi cation conditions and .
verification conditions as horn clauses.
for the encoding of veri cation conditions as horn clauses we assume that the set rcontains symbols that can act as summaries for individual functions and function pairs of appropriate arity as well as relation symbols i1 i2 i3 andc1 c2 c3 to represent loop invariants r fsf rf1 f2jf f1 f2functionsg fi1 i2 i3 c c2 c3 g we then consider the conjunction of the equivalence statement pre!p1 p2and the correctness of the summaries for all functions reachable from p1orp2 i1 i2 i1 i2 pre!wlp p1 p2 r1 r2 fa function8 if wlp pf sf if rf f1 f2 functions8 if1 if2 wlp pf1 pf2 r f1 f2 if1 rf1 if2 rf2 false n160 n260 n1 n2 s2 s2 false n1 n2 n1 n2 s2 r16 r2 r n1 r1 n2 n2 s2 r2 false n1 n260 n1 n2 s2 r16 s2 sg1 n2 r1 false n160 n2 n1 n2 s2 r2 sg2 n2 n2 s2 r2 sg1 n1 n160 sg1 n1 r1 n1 n1 sg2 n1 r1 sg2 n2 s2 s2 n260 sg2 n2 s2 r2 n2 sg2 n2 n2 s2 r2 r n1 n2 s2 s2 n160 n260 r n1 r1 n1 n2 s2 r2 n1 n2 r n1 r1 n2 n2 s2 r2 figure program equivalence vc as horn clauses intuitively any valuation of the relation symbols rthat makes valid is a witness for the equivalence of p1andp2 assuming preholds initially.
the next step is the elimination of the wlptransformer from by means of exhaustive application of the rules in figure .
when applying or to replace function calls f f1 f2with the corresponding summary the relation symbolsforrf1 f2is inserted in the formula similarly when applying the loop rules or a fresh relation symbolikorckis introduced.
we explain one possible strategy for applying the reduction rules below.
once application of the wlprules to has terminated horn clauses can be extracted from the reduct vc a pure rst order formula thanks to the following lemma lemma .suppose vc resulted from exhaustive application of rules in figure to .
then the clause normal form vc hof vc is horn.
the clause normal form vchis derived by rst distributing negations negation normal form in vc then pulling out all universal quanti ers prenex normal form and nally transforming to conjunctive normal form .
to see that the clause normal form vchis horn observe that only contains wlpin positive positions and that any two positive occurrences of relation symbols are separated by a conjunction both properties are preserved by application of wlp rules and entail that each clause in the clause normal form contains at most one positive relation symbol.
reduction strategy.
in some situations it can happen that more than one rule in figure is applicable to a wlpexpression so that in principle more than one veri cation condition vccan be derived from .
di erent vcs can represent di erent ways to match up loops and corresponding function calls in the two programs checked for equivalence and can therefore make 354the subsequent solving of the horn constraints vchmore or less di cult.
at the moment we resolve such choice points using a greedy application strategy .
as long as possible rules to eliminate assignments conditionals and return statements of the individual programs possibly together with to change the order of programs.
.
if no further rules from point are applicable try to use or for synchronous handling of loops or function calls if this succeeds go back to .
.
if no further rules from point or are applicable use or to eliminate single loops or function calls if this succeeds go back to .
this strategy matches up loops and function calls in the order in which they occur in the considered programs.
the strategy produces good results in our experiments but can clearly be re ned to take more sophisticated similarity measures into account.
further discussion is given in section .
solving horn clauses.
a number of algorithms exist to solve the horn clauses vch including predicate abstraction and propertydirected reachability pdr also known as ic3 implemented in z3 .
the procedures attempt to construct a symbolic solution of vchin a decidable logic for instance in quanti er free presburger arithmetic such a solution maps everyn ary relation symbol in rto a symbolic predicate overnvariables.
example example continued .
for the clauses in example the following predicates are found for the uninterpreted symbols r n1 r1 n2 s2 r2 !
n1 n2!r1 s2 r2 sg1 n1 r1 !
true sg2 n2 s2 r2 !
true which is the solution already discussed in section .
.
the function summaries sg1andsg2can be trivially chosen to be true since the horn clauses in which they occur in the body are already valid without them.
in general if it terminates a horn solver will produce one of two possible results i a symbolic solution of the processed horn clauses or ii a concrete counterexample tree that witnesses that no solution of the horn clauses exists.
the leaves in a counterexample tree correspond to entry clauses clauses without relation symbols in the body the root of the tree to an assertion clause with head false the counterexample shows that every attempt to satisfy the horn clauses has to lead to one of the assertion clauses being violated.
through additional bookkeeping and labeling counterexamples can be translated back to runs of the programs p1 p2 that are checked for equivalence the counterexample speci es the path taken through each program as well as the values of all program variables.
4due to reasons of computability sets of horn clauses exist for which neither i nor ii can be returned those are clauses that are solvable in a set theoretic sense but no solution can be expressed in the decidable language used for predicates.
in such cases usually non termination occurs.we summarize by stating the correctness of our procedure.
it is important to note that the procedure is correct independently of the order in which wlprules are applied for translating to vch in particular counterexamples are always genuine and point to an actual case of nonequivalence.
good strategies when applying the rules can however improve e ciency and prevent non termination of the horn solver.
theorem correctness .
if a horn solver applied to vc hterminates then one of the following holds a solution is found for vc h and in this case the considered equivalence pre !p1 p2holds a counterexample is found and the programs are not equivalent.
.
implementation and experiments implementation.
we have implemented our approach for a language close to a subset of ansi c in a tool named r eve.
program data is limited to local variables and function parameters of type int which is interpreted as unbounded i.e.
mathematical integers.
bounded integers can be simulated by instrumenting programs with modulo operations at the cost of increased reasoning complexity.
supported control structures are if then else and while statements function calls and returns.
for simplicity the return statement must always be the last statement of a function and must return a local variable.
recursive function calls may not occur within the conditions of if or while statements.
checking conditional and relational equivalence of programs is supported.
the tool i.e.
the wlpcalculus is implemented in standard ml.
as horn constraint solvers we used z3 unstable branch as of and eldarica as of .
experiments.
we have evaluated the e ectiveness and performance of our tool on a collection of benchmarks.
the benchmarks vary in size from lines of code for both programs together and are available with the tool at the url given in the introduction.
benchmark results are summarized in table .
we also give results from the only automatic tool that is directly comparable to ours due to scope cf.
section the regression veri cation tool rvt by strichman and godlin .
the programs in the rst group in table are recursive while the ones in the second group contain loops.
benchmarks where the two programs were not equivalent are in the third group and their names end with a bang !
.
all other benchmarks contain equivalent programs the 7outcome is in this case a false negative.
benchmarks limit1 tolimit3 were given by strichman and godlin as beyond the limits of their approach to regression veri cation.
benchmarks barthe2 big and barthe2big2 embed the benchmark barthe2 into a larger program that is syntactically identical in both versions.
we could not prove equivalent the ackermann benchmark as the result of a recursive function call is used as the argument to another recursive function call.
furthermore we originally could not 355prove the limit1 benchmark as two steps of the rst loop are equivalent to one step of the second loop an issue that we solve in the next section and illustrate with the larger digits10 benchmark.
the triangular mod benchmark corresponds to the illustrating example instrumented with modulo operations to simulate integer over ow.
as far as we are aware rvt does not supply additional information to assist the user in case of a failed proof attempt.
while in theory the model checker underlying rvt produces a counterexample such a counterexample can be spurious due to the xed abstraction employed.
the eldarica solver that we use in contrast returns a genuine counterexample for many failed proofs cf.
section .
we found these counterexamples useful in diagnosing problems with the programs even though we currently do not translate these counterexamples into source code terms.
.
an example for loop equivalence we consider a real world example from .
the programp1in figure a computes the number of digits in the decimal expansion of nthrough a series of integer divisions by .
the program p2in figure c computes the same result but asymptotically about seven times faster.
this speedup is accomplished by reducing the strength of operations.
the loop has been unrolled four times5andthe majority of divisions have been replaced by pure comparisons.
unsurprisingly p1andp2cannot be proved equivalent automatically.
to do so the tool would in the least need to gure out the very complex relation between one iteration of the loop in p1and four iterations of the same loop.
to overcome this barrier the software engineer needs to supply to the tool the knowledge that an unrolling transformation took place.
at the moment we achieve this transfer by manually carrying out the unrolling on p1and producing the intermediate program p0 1shown in figure b .
we then prove automatically that p0 1andp2are equivalent.
note thatp0 1is still signi cantly di erent from p2 as unrolling is not the only optimization that has been performed originally.
the program p0 1still performs four times as many divisions as p2.
the if conditions directly follow the divisions and depend on them which slows the program down while the four if conditions in p2are all dependent on the same division result.
after seconds r evewitheldarica succeeds in proving equivalence with the following automatically inferred coupling predicate b2 r1 r2 10n16n2 n2610n1 b2 r1 v2 n2 10n1 n160 here n1andr1denote the variables of p0 andn2 b2 r2 the variables of p2.
the variable b2indicates whether the loop will b2 or will not b2 be executed once more.
the coupling predicate is hence a disjunction over these two cases while the loop is iterated r1andr2hold the same value and n1is one division by ahead of n2 i.e.
n1 n2div10.
exactly this fact is expressed by the linear constraint n16n2 n2610n1 .
when the loop of p2 5loop unrolling is a simple transformation in which the loop body is replicated within the loop and guarded by the loop guard.
this transformation preserves the semantics of the program.table benchmark results run time seconds benchmark loc rv t r eve z3 r eve e ldaricaso urce recursion ackermann mccarthy91 limit1 limit2 limit3 add horn triangular triangular mod inlining loops simple loop loop loop2 loop3 loop4 loop5 while if digits10 barthe barthe2 barthe2 big barthe2 big2 bug15 nested while not equivalent ackermann!
limit1!
limit2!
add horn!
triangular mod!
inlining!
loop5!
barthe!
nested while!
loc non empty non comment lines of code in both programs together.
dash denotes timeout at seconds cross denotes that the tool terminates but cannot prove equivalence.
all times have been measured on a .
ghz intel core2 quad machine using only one core.
has nished its negated loop guard n160 holds and the nal results are stored in r1andv2.
.
discussion our method exploits structural similarities between the compared programs and can generally be expected to perform well when applied to programs with a high degree of similarity.
in other situations for instance when exchanging complete algorithms e.g.
replacing a bubble sort procedure 356int f int n int r n n while n r n n return r int f int n int r n n while n r n n if n r n n if n r n n if n r n n return r int f int n int r int b int v while b !
if n v r b else if n v r b else if n v r b else if n v r b else n n r result return v a basic version p1 b intermediate version p0 c optimized version p2 the programs p1andp2shown above are reformulations of those given in in order to comply with the input requirements of our tool.
the do while and forloops have been replaced by while loops.
the boolean ag band the temporary storage variable vinp2have been introduced to avoid premature returns from the function.
figure computing the number of digits digits10 from with quicksort or when changing the design of a system in a fundamental way it is less likely that an equivalence proof can be found automatically.
our method works well whenever su ciently simple coupling predicates exist that prove program equivalence.
this applies in a number of important cases as a baseline our procedure will always be able to prove that a program is equivalent to itself by applying the greedy reduction strategy from section and choosing the coupling predicates x1 x2.
the procedure is also complete when applied to two programs with the same control structure and locally equivalent though not necessarily identical loop and function bodies.
in this case the same coupling predicates x1 x2can be chosen for the entry points of the bodies.
the procedure is complete for program transformations that correspond to a ne mappings of program states this includes renaming or exchanging variables shifting the value of a variable by a constant o set or changing the sign of some variable.
we currently do not consider equivalence of programs that use arrays or heap data structures but we intend to work on lifting these limitations in the future.
it is for instance known that assertions about arrays can be encoded in horn clauses .
an approach to regression veri cation of programs with tree shaped heap structures can be presumably adapted from .
.
related work research on proving program equivalence is driven by a variety of applications including security veri cation com piler optimizations backwards compatibility and refactoring cryptographic algorithms hardware design and generalpurpose regression veri cation.
godlin and strichman present an approach for automatic general purpose regression veri cation.
in this approach loops in the programs are transformed to recursive procedures and matching recursive calls are abstracted by an uninterpreted function.
the equivalence of functions that no longer contain recursion is then checked by the cbmc model checker.
in our vernacular the approach can be described as an attempt to verify equivalence with the xed coupling predicate i1 i2!r1 r2for every related pair of recursive functions.
this abstraction imposes the limitation that function calls with di erent arguments or a di erent number of recursions of two matching recursive functions are not supported.
the technique is implemented in the rvt tool and supports a subset of ansi c. verdoolaege et al.
have developed an automatic approach to prove equivalence of static a ne programs.
the approach focuses on programs with array manipulating for loops and can automatically deal with complex loop transformations such as loop interchange reversal skewing tiling and others.
it is implemented in the isatool for the static a ne subset of ansi c. initially data ow analysis is applied to build a dependence graph abstraction of each of the two programs.
then the equivalence hypothesis for outputs is propagated through the graphs towards the inputs in a manner resembling veri cation condition generation.
the static control ow requirement means that the control ow of the program must be known already at compile time.
furthermore arithmetical operations in the loop function bodies are abstracted.
addition is e.g.
replaced by an associative and commutative uninterpreted function.
the abstraction prevents proving equivalence of such programs as x x x x and x x .
357barthe et al.
present a calculus for reasoning about relations between programs that is based on pure program transformation.
the calculus o ers rules to merge two programs into a single product program .
the merging process is guided by the user and facilitates proving relational properties with the help of existing veri cation technology the why tool in that particular case .
the veri cation process still requires user supplied annotations though.
almeida et al.
have veri ed the correctness of the openssl implementation of the rc4 cipher w.r.t.
a reference implementation.
the authors use self composition of programs together with interactively veri ed lemmas about particular program transformations and optimizations.
sinz and post prove equivalence of two aes cipher implementations by means of bounded model checking.
the approach unrolls resp.
inlines all loops and recursive calls.
such reasoning is only feasible if the program admits small bounds on loops or depth of recursive calls.
in the case of aes a complete unrolling of the main loop was not possible so the authors proved equivalence of loop bodies instead.
backes et al.
propose to leverage slicing and impact analysis to improve scalability of regression veri cation.
the idea is to subject both program versions to a dependency analysis then to remove the code present in both versions that has no data or control dependencies on the introduced change and to apply an existing technique e.g.
bounded symbolic execution to show equivalence of the reduced programs.
mutual function summaries have been prominently put forth by hawblitzel et al.
in and later developed in .
the concept is implemented in the equivalence checker symdiff where the user supplies the mutual summary and the veri cation conditions are discharged by boogie .
loops are encoded as recursion.
the bcverifier tool for proving backwards compatibility of java class libraries by welsch and poetzsch he ter has a similar pragmatics.
banerjee and naumann study equivalence of javalike programs from the perspective of data encapsulation.
they develop a programming discipline and a static analysis ensuring that changes in an object oriented data structure s implementation are con ned and cannot a ect its clients other than through speci ed public methods.
several relational program logics e.g.
have been developed for security applications.
proving in these logics requires user supplied inductive invariants.
a large body of work also exists on equivalence checking of hardware logic circuits see for an overview.
the approaches fall into two major groups.
one group builds the product machine of two circuits and exhaustively traverses the state space to ensure that the corresponding outputs of the two circuits are identical in every reachable state.
the other group recognizes that the incremental nature of the design process induces structural similarity between the circuit variants under veri cation and tries to exploit them.
the techniques to do so include functional equivalences indirect implications permissible functions and others see e.g.
.
.
conclusion and future work in this paper we have presented a novel approach that uses invariant inference techniques to automatically conduct regression proofs for two imperative integer programs.
to this end the two versions of the program are trans formed into horn clauses over uninterpreted predicate symbols.
these clauses constrain equivalence witnessing coupling predicates that connect the states of the two programs at key points.
a horn constraint solver is used to nd a solution for the coupling predicates if one exists.
the approach is implemented and we have demonstrated its e ectiveness on integer programs with non trivial arithmetic and control ow.
future work includes an extension to programs with arrays and heap structures as well as development of more ne grained coupling schemes.