taming reflection aiding static analysis in the presence of reflection and custom class loaders eric bodden andreas sewe jan sinschek hela oueslati and mira mezini software technology group technische universit t darmstadt center for advanced security research darmstadt cased bodden acm.org abstract static program analyses and transformations for java face many problems when analyzing programs that use re ection or custom class loaders how can a static analysis know which re ective calls the program will execute?
how can it get hold of classes that the program loads from remote locations or even generates on the y?
and if the analysis transforms classes how can these classes be re inserted into a program that uses custom class loaders?
in this paper we present tamiflex a tool chain that o ers a partial but often e ective solution to these problems.
with tamiflex programmers can use existing staticanalysis tools to produce results that are sound at least with respect to a set of recorded program runs.
tamiflex inserts runtime checks into the program that warn the user in case the program executes re ective calls that the analysis did not take into account.
tamiflex further allows programmers to re insert o ine transformed classes into a program.
we evaluate tamiflex in two scenarios benchmarking with the dacapo benchmark suite and analysing large scale interactive applications.
for the latter tamiflex signi cantly improves code coverage of the static analyses while for the former our approach even appears complete the inserted runtime checks issue no warning.
hence for the rst time tamiflex enables sound static whole program analyses on dacapo.
during this process tamiflex usually incurs less than runtime overhead.
categories and subject descriptors f. .
program analysis general terms algorithms experimentation measurement reliability keywords re ection static analysis dynamic class loading dynamic class loaders native code tracing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction researchers have developed many useful static program analyses ranging from analyses that compute call graphs and relevant program slices to analyses that determine the shape of custom data structures prove parameter immutability track an object s typestate or support model checking in program veri cation .
some of these are also coupled with program transformations i.e.
they optimize or instrument the analyzed program.
as one example in previous work we and others have used static typestate analysis information to optimize runtime monitors for typestate properties .
virtually all of these analyses are whole program analyses the analyses must consider the entire program to deliver sound results.
this is because most analyses operate under a closed world assumption for instance the analyses frequently assume that a call graph is complete in the sense that if a call graph contains no edge from a method mto a method nthen it can never be the case that mcalls n. obtaining information about the whole program yields many problems when analyzing java programs that use reection or load or generate classes using custom class loaders.
in figure we give an example program that although simpli ed highlights many of these problems.
in the example the generator in line runtime generates and returns the class object for foo lines .
the invoke statement at line therefore calls foo .foo c closing theconnection object referenced by c. unfortunately line writes to the closed connection leading to a runtime error.
static typestate analyses allow programmers to obtain compile time warnings for such situations.
in the past we ourselves have developed such an analysis.
it should warn 1class main public static void main string args throws exception connection c new connection class clazz generator.makeclass returns foo method m clazz.getmethod foo connection.class m.invoke null c calls foo .foo .. c.write what a risky method call c is closed!
10class foo public static void foo connection c c.close figure example program using dynamic class generationthe programmer of this program that the write at line may go to a closed connection.
however current static analyses have no way of being aware of runtime generated classes such as foo and frequently make the unsound assumption that such classes execute no code.
in our example this would cause virtually any state of the art typestate analysis to conclude that the above program is error free i.e.
cannot write to closed connections clearly an undesirable result.
even worse the problem is not restricted to generated classes when programs use custom class loaders e.g.
to load classes from nested jar les or from remote locations then static analyses will usually be unable to nd these classes and yield equally unsound results.
and even if static analyses were made aware of re ective calls and re ectively loaded classes further problems would remain.
for instance our earlier static typestate analysis contains a runtime component if the analysis detects that the program may write to a closed connection then the analysis instruments the program with runtime checks that will issue a runtime error message in case the program really does write to a closed connection at this point.
but in our example the analysis would have to add checks to the generated class foo because it is this class that closes the connection.
even if the static analysis has access to this class and can analyze and transform it one needs to re insert the instrumented version of foo back into the program.
current static analyses and transformations do not deal with these problems and thus virtually all existing static whole program analyses are inherently unsound for the majority of java programs.
while one cannot solve this problem in full generality we present tamiflex a tool chain for taming re ection as a pragmatic partial solution that works surprisingly well for a wide range of real world java programs.
tamiflex consists of two novel runtime components the play out agent and the play in agent which execute alongside the running program and an o ine component called the booster.
the play out agent logs re ective calls into a re ection log and gathers the classes that the program loads be it through custom class loaders or on they code generation.
this o ers a partial solution to the rst problem we mentioned the play out agent collects all loaded classes and all information about re ective calls for every recorded run .
but simply logging re ective calls is not enough as most static analysis tools would be unable to interpret these logs.
to avoid having to extend these tools we therefore developed the booster.
given the recorded log and class les the booster produces an enriched version of the program by materializing recorded re ective method calls into regular java method calls.
this enriched program version while guaranteed to be behaviorally equivalent to the original program aids static analyses the analyses will usually take the materialized method calls into account whereas they would have unsoundly ignored re ective method calls.
the booster ful ls a second important task.
as mentioned static analyses based on tamiflex logs are sound only with respect to a set of recorded program runs.
thus what happens if a later program run diverges from the runs previously recorded?
the booster inserts runtime checks into the program that will automatically warn the user in these cases as long as no warnings are issued the program is known to operate under sound assumptions.
if users of tamiflex simply wish to analyze a programstatically without transforming the program they only need to use the play out agent and the booster not the playin agent.
users can simply feed the enriched class les to any static analysis tool.
in many cases however users may want to use static analysis results to transform classes e.g.
to optimize or instrument them.
in these cases one faces the problem of re packaging the transformed classes in such a way that the original program nds the classes where it expects them.
without special tool support this can be either hard for instance if the program loads the classes from a remote location or even impossible if the program generates the classes on the y. the play in agent solves this problem by re inserting o ine transformed classes into a running program.
the agent even replaces classes that an application generates at runtime.
we study two applications of tamiflex evaluating static optimizations using the dacapo benchmark suite and statically analyzing nine di erent interactive real world applications.
static analysis without considering re ection produces inherently unsound results in both cases.
as our results show with tamiflex our approach appears complete for dacapo the runtime checks in the enriched program code never triggered for any run that we observed.
hence for the rst time our tool chain enables researchers to conduct static whole program analysis on this version of dacapo.
we further show that tamiflex induces a runtime overhead of usually below .
the play in agent in particular induces no overhead after all classes have been loaded.
because of this researchers can e ectively use tamiflex to run statically optimized versions of dacapo when iterating a benchmark the play in agent will only cause a runtime overhead during the initial warm up iteration.
for the other nine java programs tamiflex may need to record multiple program runs to cover a su cient amount of re ective calls.
however as we show often just a few recorded runs can signi cantly improve code coverage of the static analysis.
therefore while tamiflex does have its limitations it greatly improves over the state of the art even for programs that highly depend on user input.
to summarize this paper presents the following original contributions the design and implementation of two java instrumentation agents that can emit all loaded classes into a local class repository log re ective method calls and reinsert o ine transformed classes into a program even if the program uses custom class loaders.
the agents use the java.lang.instrument interface making them compatible with every modern java virtual machine.
a booster component that enriches a program s class les by materializing re ective method calls and at the same time inserts runtime checks that will warn the user when a program executes re ective calls that the play out agent had not recorded.
in combination the rst solution to allow researchers to conduct static whole program analysis and transformation on the current .
bach release of dacapo.
a set of experiments that prove that our tool chain is e cient yields call graphs for all dacapo benchmarks that are sound for all benchmark runs and largely improves analysis coverage for nine other interactive java applications.tamiflex all our experimental data and all tools to reproduce this data are available to the public at the remainder of this paper is organized as follows.
we explain tamiflex in section .
we report on our experiments in section discuss related work in section and conclude in section .
a technical report gives additional information on the implementation and experiments.
.
tamiflex we rst describe the overall architecture of tamiflex and then detail its individual components.
.
architecture of tamiflex figure on the next page gives an overview of tamiflex s architecture.
on the top left we show a program that potentially uses custom class loaders to load classes from arbitrary locations the cloud or even to generate classes on the y. the program may further call methods such as constructor.newinstance ormethod.invoke to construct objects or invoke methods through re ection.
let us now assume that the program executes with our rst instrumentation agent installed the play out agent which figure shows below the program.
in this agent the tracer transforms the classes class method and constructor so that calls to methods such as method.invoke generate entries in a log le shown on the bottom left .
the agent further comprises a dumper component which writes into a local repository i.e.
a at directory all classes that the program loads.
this includes classes that the program s class loaders have generated on the y. some runtime generated classes bear randomized names.
to allow re identi cation of such classes across multiple runs the dumper assigns normalized names to these classes.
to this e ect the dumper communicates with a hasher component see section .
.
executing a program with the play out agent will result in a repository that contains a re ection log le and all classes that the program loaded during the observed run.
to obtain a reasonably complete log le and set of classes users can run the program multiple times.
the agent will update the log appending information about re ective calls that had not previously been observed and dump classes that had not been loaded on previous runs.
the idea is to repeat this process until no changes are observed any longer.
there are now two options to enable static analyses based on the recorded information.
first shown dotted one can derive a specialized static analysis that is tamiflex aware.
in our technical report we describe such a solution tied to soot and spark .
extending the analysis is non trivial however and would have to be repeated for every static analysis tool.
therefore we propose another approach to use the booster to convert the original program as de ned by the collected class les into an enriched program version.
the booster inserts re ective method calls as additional regular method calls based on the information from the re ection log.
simultaneously the booster inserts runtime checks that will issue a warning in case the program executes a re ective call that the log does not contain.
next users can feed the enriched program to any staticanalysis tool to conduct static analyses and to transform e.g.
optimize or instrument the program code.
because the recorded re ective calls now appear as normal method callsin the program s code typical static analyses will correctly pick up the respective calls during call graph construction.
the right hand side of figure shows what happens when the user runs the program with the second agent the playin agent installed.
whenever the original program is about to load a class clazz a replacer within the agent tries to retrieve the o ine transformed version of clazz from the local repository.
for classes that bear a randomly generated class name the agent asks the hasher component to compute its normalized name.
this causes the replacer to look for the o ine transformed class under the same normalized name that the dumper used to store the class.
if the replacer nds a class in the repository it replaces the originally loaded or generated class with the found class on the y. otherwise i.e.
if the replacer cannot nd an appropriate class le for instance because no such class was loaded on previous runs the replacer executes no replacement in this case the program will instantiate the class that the class loader originally generated or loaded from the cloud .
optionally users receive a warning message in such situations.
note the exibility of this design tamiflex works with any java virtual machine that supports transforming classes through the java.lang.instrument application programming interface.
through this interface our agents are able to write out and replace classes that the program loads.
with the aid of our hasher component this even works in cases where the program generates classes with randomized names.
the booster makes tamiflex compatible with virtually every static analysis tool able to process java bytecode.
the current implementation of the play out agent has some limitations that can be lifted in future work.
there may be other native methods calling back into java bytecode not just re ective calls.
as our experiments show such calls are usually limited to nalizers and shutdown hooks sec.
.
.
support for such call edges could easily be added.
further programmers may use re ection to change the values stored in elds.
such store operations may make eld sensitive program analyses unsound.
in future work one could extend the play out agent to record such stores and the booster to materialize such stores similar to how we do now for other re ective calls.
.
play out agent figure shows the play out agent on the left hand side.
before the program starts up the play out agent registers two class le transformers the tracer and the dumper with the virtual machine vm .
the vm noti es such transformers about every class that the program loads no matter which class loader is used including such classes that the program generates on the y. when the program executes the dumper records the byte arrays of all loaded classes and writes them as .class les to disk.
at the same time the tracer waits for the classes class constructor ormethod to be loaded.
when encountering one of these classes it instruments the methods forname newinstance and invoke modifying their bytecode so that they will create a log entry whenever they execute.
we make sure to insert the logging code at the end of these methods just before every return statement.
this ensures that we do not log erroneous executions of these methods which throw an exception e.g.
because a certain class or method could not be found.program forname newinstance invoke class loaderclass loaderclass loader play out agenttracer dumper hasherconstructor method class refl.log.classrecorded program .class.class booster.class 1enriched program .class .class any static analyzer tamiflex aware static analyzer.class 2transformed pr.
.class .class 2play in agentreplacer hasherprogram class loaderclass loaderclass loader all classesall classes figure overview of tamiflex normalizing randomized class names.
when programs generate classes at runtime they sometimes assign these classes randomized names.
consider again the example from figure .
in the gure the generated class bears the name foo .
on the next run however the generator may generate the same class under another name for instance foo .
randomized names complicate our approach.
first we may not easily reach a xed point when recording program runs with the play out agent.
more importantly however it would likely happen that the play in agent would search for a class using a name di erent from the name that the playout agent used to store the same class.
this would break the play out transform play in sequence for such classes.
we therefore decided to extend tamiflex with a hasher component that detects classes with a randomized name using an extensible list of class name patterns and then creates a stable sha1 hash over the classes contents to assign normalized names to these classes.
sha1 hashes are very unlikely to clash.
both the play out agent and the play in agent use the hasher component consistently which allows both agents to re identify classes across multiple runs.
to maintain consistency among classes we not only change the name of class lesbut also rename class