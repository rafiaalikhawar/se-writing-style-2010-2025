con2colic testing azadeh farzan university of toronto canadaandreas holzer tu wien austrianiloofar razavi university of toronto canada helmut veith tu wien austria abstract in this paper we describe con2colic testing a systematic testing approach for concurrent software.
based on conc rete and symb olic executions of a concurrent program con2colic testing derives inputs and schedules such that the execution space of the program under investigation is systematically explored.
we introduce interference scenarios as key concept in con2colic testing.
interference scenarios capture the flow of data among different threads and enable a unified representation of path and interference constraints.
we have implemented a con2colic testing engine and demonstrate the effectiveness of our approach by experiments.
categories and subject descriptors d. .
testing and debugging general terms algorithms verification security keywords testing concurrency concolic interference .
introduction testing and bug finding for concurrent programs has been a very active area of research in recent years.
there is an array of tools that successfully discover errors in concurrent programs by using a wide range of heuristic techniques that have been developed to alleviate the interleaving explosion problem that is inherent in analysis of concurrent programs.
from a classical point of view testing sequential program testing to be more exact techniques are often coupled with a notion of coverage that the technique guarantees.
various coverage criteria have been introduced for sequential program testing over the years.
existing concurrency testing techniques can be divided into three categories of coverage guarantees on program runs inputs code assertions etc.
that they provide i no specific coverage guarantees heuristic based techniques are based on the philosophy of using permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august u26 saint petersburg russia copyright acm ... .
.heuristics to target interleavings that are more likely to contain bugs and testing as many of those as possible under the given time and space limitations .
these techniques have been extremely successful in finding bugs but cannot provide any useful information to the tester about what they have or have not missed during testing that is they cannot provide any coverage guarantees.
ii coverage guarantees over the space of interleavings search prioritization techniques take a more coverageoriented approach than the techniques in category i by using ideas like preemption bounding context bounding depthbounding and delay bounding to prioritize the search in the space of all program interleavings.
these prioritizations enable us to quantify in a meaningful way how much of the interleaving space is tested a property that the heuristic based search techniques of category i do not provide.
search prioritization techniques have been very successful in discovering bugs.
for example chess is a successful testing tool based on the contextbounding search prioritization.
nevertheless these techniques all work based on a fixed pre determined set of inputs and therefore if a bug cannot be discovered on the given set of inputs it will be missed see section for an example .
moreover coverage guarantees are only over the space of program interleavings.
iii coverage guarantees over the space of program inputs and interleavings there are also sequentialization techniques that based on context bounding or more recently other types of search prioritization translate a concurrent program to a sequential program that has the same behaviour up to a certain context bound and then analyze the sequential program statically for the property of interest.
to check if for example an assertion fails the space of both inputs and interleavings but up to the bound are searched.
these techniques are excellent at discovering bugs they are incomplete due to the bound for proving properties .
however the sequential programs generated are not appropriate models to be used for testing cf.
section .
more recently there has been some focus on exploring input and interleaving spaces of the program in a more systematic way.
however these techniques only explore a subset of the program behaviours and therefore cannot aim for maximum coverage.
we propose a concurrency testing technique that belongs in category iii .
our goal is to systematically test concurrent code such that meaningful coverage guarantees can be provided.
concolic conc rete and symb olic testing is the gold standard of sequential testing with exactly the same point of view for sequential programs.
there the set of possible inputs the only parameter that can change for sequential programs is systematically explored to provide standard code coverage guarantees such as branch coverage for the program and existing program errors are discovered meanwhile.
our proposed approach can be viewed as the general path exploration interference scenariosinterference exploration realizability checkmulti threaded concolic executionsymb.
trace yes realizableschedule inputs no not realizableseq.
schedule random inputs figure overview of con2colic testing.
ization of concolic testing to concurrent programs and hence we call it concurrent concolic testing or con2colic testing in short.
in section we introduce the running example of this paper.
targeting code coverage is a reasonable goal for a testing routine since it has been shown that most dynamic program errors can be encoded as program assertions which can easily be tested verified through branch coverage.
in con2colic testing we aim to achieve maximal code coverage for the program time and space allowing .
it is important to note that almost all existing concurrency testing techniques today use an under approximation of the set of concurrent executions as a model for testing.
most techniques in category i mentioned before use one or several program runs as a basis for predicting buggy runs.
the techniques in category ii use the set of program runs prioritized by one of the bounding techniques discussed above as the under approximation of their choice.
a common limitation among most of these techniques is that their under approximate model is fixed a priori.
once they start testing they are limited to performing the tests within their bounded model1.
specifically all techniques that we list in category iii which is our focus also have this limitation.
con2colic testing does not have this limitation.
similar to concolic testing we have the program at our disposal and we can keep expanding the set of behaviours that we consider for testing.
naturally our approach is also limited by the same constraints that hold concolic testing back namely the unavailability of external library functions or undecidable logics.
this aspect of con2colic testing has a very important consequence.
we can theoretically guarantee completeness in the limit by this we mean that if the testing algorithm runs for long enough then we can cover every program branch or declare it unreachable again within the limitations of concolic testing .
we implemented the con2colic testing approach as a tool for testing multi threaded c code.
we use a set of benchmarks found in concurrency research literature to demonstrate the practical efficiency of our approach in providing code coverage and finding bugs in these benchmarks.
in the next section we provide an extended overview of con2colic testing.
.
con2colic testing we start by a short overview of concolic testing in order to highlight what needs to be done to generalize it to concurrent programs.
concolic testing has three main components concolic execution engine path exploration and realizability checker.
the concolic execution engine executes the program on a given input vector concolically i.e.
using both concrete and symbolic values for inputs and as a result generates an execution trace that contains a sequence of path constraints on symbolic inputs i.e.
branch conditions encountered during execution .
the goal is to try to diverge from the just observed execution by taking a different side of an encountered branch.
the path exploration component hence selects some of these branch conditions and negates them in order to guide the execution along a different path.
in the realizability checker 1category ii techniques do not have this limitation theoretically but in practice only very small values for bounds are feasible.smt solvers are used to generate an input vector if possible that would satisfy the new path constraints with the understanding that such an input vector is likely to force the program to execute a different path.
for a deterministic sequential program each input vector specifies a single path in the program.
the behaviour of a concurrent program however is not only influenced by the input vector but also by the interleaving of execution of threads.
each interleaving of execution of threads determines a pattern of interferences among the threads.
an interference occurs when a thread reads a value that is generated by another thread.
an interference could substantially change the course of the local computation of a thread because the value generated by another thread may not be producible locally.
therefore the local behaviour e.g.
an assertion violation followed by this interference may never surface by pure sequential testing.
we propose con2colic testing see figure as a concolic testing approach tailored for concurrent programs.
we introduce the concept of interference scenario formally defined in section as a representation of a set of interferences among the threads.
conceptually interference scenarios are the essential information that define the important scheduling constraints for a concurrent program run in other words all runs with the same interference scenario arebehaviourally equivalent under the same input values.
the constraint system for sequential concolic execution is also modified to model interferences as well.
the con2colic testing engine is then able to produce schedules in addition to input vectors for concurrent programs.
to accommodate this change con2colic testing has one more component compared to sequential concolic testing called interference exploration that navigates the space of all interference scenarios in a systematic way.
in con2colic testing the execution engine is leveraged to execute a concurrent program based on a given schedule.
the important part of the observed execution is stored in a forest data structure formally defined in section that keeps track of various interference scenarios that have been explored already.
the path exploration component then decides what newscenario to try next aiming at covering previously uncovered parts of the program based on the set of interferences that have already been explored.
for each interference scenario the realizability checker investigates whether there exist a set of inputs and a feasible schedule such that a program execution based on these inputs and this schedule results in the same set of interferences.
if the answer is yes then the input and the schedule are used in the next round of concolic execution.
otherwise the interference exploration component generates new candidates by introducing new interferences.
next we briefly explain con2colic testing components and then we present an exploration strategy that we implemented.
concolic execution.
there are two input parameters for the concolic execution engine in con2colic testing an input vector and a schedule.
the engine executes the concurrent program with the given input vector and according to the given schedule.
the program is instrumented such that during the execution all important events are recorded and a symbolic trace is produced as a result.
these important events include synchronization operations accesses to shared variables and path constraints.
the symbolic trace contains all the necessary information for the con2colic engine to make progress.
however it excludes extra information such as details of local computations of threads that can safely be ignored in our approach to gain scalability and efficiency.
path exploration.
the role of the path exploration routine is to explore the input space for a new set of input values that may cover the yet uncovered parts of the program.
this module does not modify the set of interferences observed in the previous execution andonly guides the execution down a different program path by negating the conditions of branches observed along the last execution .
therefore the changes made in this phase are only changes of the input values and the essential structure of the schedule i.e.
interference scenario remains the same.
realizability checker.
the role of the realizability checker is to determine if there is a set of inputs and a feasible schedule that realize the given interference scenario.
each interference scenario imposes two constraint systems constraints on input values that are satisfied by all executions having the same interference scenario and constraints that define the temporal order of the events of different threads e.g.
a read event of one thread has to occur after the corresponding write event of another thread .
we formally define the resulting constraint systems in section .
if both constraint systems have a solution then an input vector and a schedule can be inferred which give rise to a real program execution with exactly the same set of interferences as defined in the interference scenario.
if at least one of the constraint systems does not have a solution then the interference scenario has to change.
to that end the current interference scenario is passed to the interference exploration module described below such that a new one will be derived from it.
in section .
we will discuss how to prune the exploration space of interference scenarios based on the reason for the unsatisfiability of the constraint system.
interference exploration.
interference exploration produces new interference scenarios from previously explored interference scenarios essentially by introducing a new interference.
this is done by picking a read from the given interference scenario that is not interfered by other threads and an appropriate write from the forest and adding an interference from the write to the read to generate a new interference scenario.
note that the occurrence of the write event itself may be conditional on the existence of other interferences.
therefore to preserve soundness all of those interferences should be included in the produced interference scenario as well.
we discuss the function of this module in detail in section .
exploration strategy and completeness.
with the above components con2colic testing can exploit different search strategies and heuristics to explore the interference scenario space.
we have implemented a search strategy that targets branch coverage section .
the search strategy then explores interference scenarios with an increasing number of interferences.
that is all interference scenarios with one interference are explored first and then interference scenarios with two interferences are explored and so on.
a nice feature of this exploration strategy is that it is complete theorem .
modulo the exploration bound and of course concolic testing limitations .
.
running example we use the buggy implementation of function addall in fig.
as a running example in this paper.
the example is a variation of theaddall method of the built in class vector in java.
the error in it is a real error.
we have rewritten it in c our tool s input language and simplified it a bit to make it suitable as a running example.
addall has two input parameters which are pointers to vector structures.
it appends all elements of the second vector to the end of the first vector.
each vector has three fields data which is an array holding vector elements size which represents the size ofdata and cnt which keeps track of the number of elements in data .
function addall uses a lock lkto synchronize the calls to this function.
it first checks whether there is enough space to insert all elements of u data intov data i.e.
v cnt u cnt v size cf.
line .
if not it increases the size of v datatypedef struct int cnt int size int data vector pthread mutex lk 1void addall vector v vector u int numelem v cnt u cnt pthread mutex lock lk if numelem v size v data realloc numelem v size numelem assert v size u cnt v cnt ... copy data from u to v v cnt v cnt u cnt pthread mutex unlock lk figure function addall a buggy concurrent implementation of vector concatenation.
accordingly.
the invariant v size u cnt v cnt is stated as an assertion in line .
finally it copies the elements and updates v cnt .
the bug in addall corresponds to the fact that the value ofv cnt is being read at line outside the lock block and hence v cnt can be changed by other threads before the lock block is executed leading to an inconsistent state.
for simplicity we just refer to v cnt andu cnt while in the real implementation these accesses are protected by locks.
therefore there is no data race on these accesses and the error that we discuss here is independent of that data race and exists in the original race free code.
imagine a concurrent program with two threads tandt0each of them calling addall with vanduas arguments where vis shared between the threads and uis an input of the program.
therefore each individual field of vis treated as a shared variable and each individual field of uis treated as an input.
also suppose that initially v cnt is and v size is .
consider the situation where u cnt and the program is executed as follows i the first thread texecutes line reading from v cnt from u cnt and storing value in numelem .
ii the second thread t0is executed completely.
it reads values and from v cnt andu cnt respectively at line and assigns to numelem .
then it enters the lock block.
since v size is greater than it skips lines and and assigns to the shared variable v cnt before exiting the lock block.
iii then tcontinues execution it skips lines and since numelem v size .
however when tgets to the assertion v cnt has value written by t0.
therefore we have v size and hence the assertion is violated.
this particular error occurs because the naive locking of individual vector s is not the correct way of copying from one vector that can change meanwhile to another.
the error is interesting because it requires a combination of a particular concurrent schedule combined a with particular relative values for the input vectors to manifest.
if the threads are executed sequentially back to back nothing goes wrong.
on the other hand if we execute the same interleaving as described above but start with u cnt having the value instead of then nothing goes wrong the first thread assigns to numelem the second thread skips lines and and assigns to u cnt .
then the first thread skips lines and since numelem v size .
this means that triggering this concurrency bug does not solely depend on the concurrent schedule nor does it solely depend on the chosen input values it depends on finding the right combination of input values and the choice of concurrent schedule.
any testing technique that does not explore the combination space systematically has the potential of missing on this bug.
.
basic definitions and notations we will now introduce some notions from concolic testing adjusted to our application.
classical sequential concolic testing logs a set of path constraints over input variables during concolic execution which describes the conditions on the values of the inputs that have to be true to drive the execution of the program along the same path.
however the same for concolic execution of multi threaded programs would result in a set of constraints that are closely tied to the specific schedule performed during program execution.
to solve this problem we proceed as follows instead of explicitly tracking scheduling decisions we introduce symbolic variables which enable us to track the information flow between threads.
more precisely we introduce an additional symbolic variable each time a shared variable is read and for each shared variable write we store the symbolic value based on symbolic inputs and symbolic read variables .
this will enable us to build constraints which capture the essence of a concurrent execution path.
a concurrent program consists of a set t ft1 t2 gof threadsti a set of input variables in a set of shared variables sv a set of local variables lv and a set of locks l. let symbin be a set of symbolic input variables fi0 i1 gandsymbrv be a set of symbolic shared read variables fr0 r1 g. let expr represent the set of all expressions over symbin andsymbrv and let pred expr represent the set of all predicates over expr .
then the set of actions that a thread can perform on a set of shared variables svand lockslis defined as frd x r jx2sv r2symbrvg fwt x val jx2sv val2exprg f tf ti jti2tg fac l rel l jl2lg f br j 2pred expr g action rd x r corresponds to reading from a shared variable x and the symbolic value of the shared variable xbecomes the symbolic variable r. each time we observe a read from a shared variable during concolic execution we introduce a new symbolic variabler2symbrv that is uniquely associated with that specific read.
action wt x val corresponds to writing to a shared variablexa symbolic value which is represented as an expression val.
to couple a read of xwith a write to x it is enough to connect the stored expression at the write to the symbolic value of the read i.e.
r val.
action tf ti represents forking thread ti.
actions ac l andrel l represent acquiring and releasing of lock l respectively.
finally action br denotes a branch condition which requires that predicate is true.
we model assertions in a program by two branches i.e.
one branch for passing the assertion and one branch for violating the assertion.
we denote the execution of an action by a thread as an event .
formally an event is a tuple ti a 2t .
letev denote the set of all possible events.
during concolic execution we observe a sequence of events a so called symbolic trace definition .
s ymbolic trace .a symbolic trace is a finite string 2ev .
by we denote the n th event of .
given a symbolic trace jtiis the projection of to events involvingti.
a symbolic trace is thread local if jtifor someti.
the inputs to our concolic execution engine are an input vector and a schedule which exactly specifies the resulting program run definition .
p rogram run .consider a deterministicconcurrent program p. a partial runofp represented by r p in is uniquely described by a valuation inof the input variables in and a schedule .
a schedule is defined byinitial thread t rd v cnt r0 context switch t!t0 rd v cnt r0 ac lk rd v size r0 br r0 i0 r0 rd v size r0 rd v cnt r0 br r0 i0 r0 rd v cnt r0 wt v cnt r0 i0 rel lk context switch t0!t ac lk rd v size r1 br r0 i0 r1 rd v size r2 rd v cnt r3 br r2 i0 r3 r0 r0 br r0 i0 r0 r0 r0 br r0 i0 r0 r0 wt v cnt r0 i0 14br r0 i0 r1 r3 r0 i0 17br r2 i r3 t0 t figure symbolic trace obtained from the assertion violating execution of the program in fig.
and its corresponding interference scenario is .i0represents the symbolic value of input v cnt .r0 r0 r0 andr0 4read initial value and r1 r2 r0 and r0 2read initial value and r3readsr0 i0 a sequence ti1 n1 ti2 n2 tim nm tim where tij2t for1 j m andnj for1 j m specifies the number of executed actions.
a tuple tij represents the execution of thread tijuntiltijterminates.
a run of program p isfeasible ifpcan be executed with input vector inand according to schedule .
each feasible program run ryields a symbolic trace r .
we assume that the program is instrumented in such a way that all program actions covered in ev are actually observed by r .
in fig.
on the left we show a symbolic trace obtained from the assertion violating execution of the program in fig.
discussed in section .
observe that the concolic execution engine only logs reads from and writes to shared variables but no reads from or writes to local variables.
internally the concolic execution engine keeps track of the symbolic values of local variables and is therefore able to correctly update the symbolic value of a shared variable when it gets written.
.
interference scenarios an interference occurs whenever a thread reads a value that is written by another thread.
we introduce interference scenarios to describe a class of program executions under which certain interferences happen during concolic execution.
intuitively an interference scenario is a set of thread local traces extended with an interference relation between write and read events from different threads.
we represent a set of interference scenarios in a data structure called interference forest.
formally an interference forest is a finite labeled directed acyclic graph whose nodes represent events and whose edges express relations between events.
definition .
i nterference forest .aninterference forest is a tuplei v e wherevis a set of nodes v!
ev is a labeling function which assigns events to nodes.
for v2 vwhere v ti a we also define th v tiand ac v awt y ...rd x ...rd x ......threadt1 wt z rd y wt x ...rd y wt x ......threadt2 n figure interference scenarios in an interference forest f to be the thread and the action of the corresponding event respectively.
the set of edges eis the disjoint union e el ei of thread local edges eland interference edges ei.
a threadlocal edge or simply a local edge is an edge s t 2elwhere th s th t .
an interference edge s t 2eiis an edge where th s th t and ac s wt x val and ac t rd x r for somex val andr.
we require that eiis an injective relation i.e.
each read is connected to at most one write by ei.
the thread local edges can be naturally partitioned according to their threads i.e.
el et1 et2 etn.
eachetiinduces a subforest gti which consists of all nodes with th v tiand edges in eti.
we require that each gtiis a rooted tree.
the number of interference edgesjeijis called the degree of the interference forest.
an isomorphism between two interference forests is a graph isomorphism which preserves the labeling function.
given an interference forest j ri j denotes the read nodes involved in the interference edges of j i.e.
ri j fnrj9nw nw nr 2eig.
figure shows an interference forest.
the nodes labeled with read write and branch actions are represented by squares and diamonds respectively.
local edges are presented by arrows and interference edges are presented by dotted arrows.
the left tree representsgt1and the right tree represents gt2.
the degree of the interference forest is .
definition .
i nterference scenario .we define an interference scenario is as an interference forest where each gti is a path.
as mentioned at the beginning of this section an interference forest is a compact representation for a set of interference scenarios.
definition .
c ausal interference scenario .let i v e be an interference forest.
the transitive closure e of the edge relation eis called the causality relation of i. given a noden the causal interference scenario cis ofnis the subforest ofiinduced by the causal predecessors of n i.e.
by the node set fvj v n 2e g. we denote it by c cis i n and callnthe sink ofc i.e.
sink c n. every causal interference scenario is an interference scenario.
this is also the crucial property why interference forests serve as compact representations for sets of interference scenarios.
in fig.
the causal interference scenario of node nis the interference scenario enclosed by dashed lines.
construction of new interference scenarios from existing ones and merging interference scenarios into an interference forest are two central operations in our testing approach.
but we cannot combine arbitrary interference forests scenarios they have to be compatible with each other definition .
c ompatible interference forests .
two interference forests i jarecompatible if there is an interference forestkand interference subforests i0 j0ofksuch thati0 andj0are interference forests themselves and iis isomorphic to i0andjis isomorphic to j0.
definition .
applies to compatible interference scenarios as well since each interference scenario is an interference forest.
remark .
.
compatible interference forests can be merged into an interference forest by naturally taking the minimal k i.e.
konly contains nodes and edges corresponding to i0andj0.
if interference scenarios iandjare not compatible then there is at least one thread for which iandjdescribe different computations.
each symbolic trace defines an interference scenario denoted byis .
intuitively each event represents a unique node in is which is labeled with that event.
for each thread ti thread local edges are added between the corresponding nodes according to the order in jti where jti i i i mdenotes the projection of events in on threadti.
an interference edge is added for each node labeled with a read event if the last write event to the same shared variable before the read event in is performed by another thread.
more formally is v e is defined as v s tifni jjni jis a unique node for event i jg ni j i jfor each node ni j eti f ni k ni k j0 k m 1g and ei f ni k nj h jth ni k th nj h ac ni k wt x val ac nj h rd x r for somex val r and i k is the last write to xin before j hg.
figure shows the interference scenario for the symbolic trace obtained from the assertion violating execution of the program in figure which is discussed in section .
definition .
r ealizable interference scenario .
an interference scenario iisrealizable iff there is a feasible partial program run rwith r such thati is .
we sayr realizesifor such a feasible program run r. realizable interference scenarios define equivalence classes on the set of program runs which represent the same flow of data among the threads.
note that interference scenarios are not monotonic wrt.
realizability.
let iandi0be two interference scenarios whereiis a subgraph of i0.
then the realizability of idoes not imply the realizability of i0and vice versa.
we will discuss the reasons for this behaviour in section .
interference scenarios specify partial program runs and therefore unanticipated behaviour can be observed definition .
u nforeseen interferences .letibe a realizable interference scenario and rbe a partial program run with r such thati is .
letr0be a run that extendsr i.e.
r0 and is a prefix of .
then is is a supergraph of is .
more specifically is might contain some additional interferences.
we refer to these interferences as interferences unforeseen by interference scenario iin runr0.
.
constraint systems for interference scenarios each interference scenario implies constraints on both data and temporal order of the events.
in this section we describe these constraints in detail.
in section we present our soundness theoremdata constraints dc i dc i dcbranch v dcinterfere i dclocal i dcbranch v v 2br v where br v f jv2v ac v br g dcinterfere i v vwt vrd 2eidcmatch vwt vrd dclocal i v vwt vrd 2eldcmatch vwt vrd whereelis the set of local write read matches.
dcmatch vwt vrd val r forac vwt wt x val ac vrd rd x r temporal consistency constraints tc i tc i v ti2tpoti fc lc1 lc2 wrc interfere wrc local poti v ni j2gti ni jis not a leaf tni j tni j fc v ti2t tntf ti tni lc1 v ti6 tjv l2lv 2lti l 2ltj l trl taq0 trl taq lc2 v ti6 tjv l2lv aq2norelti l 2ltj l trl0 taq wrc interfere v u v 2eicoupled v u wrc local v v62intreadscoupled v locw v coupled v u tu tv v n2wxnfug tn tu tv tn figure constraint systems dc i andtc i for an interference scenarioi v e thm.
.
that shows how these constraints can be used to check for the realizability of an interference scenario.
data constraints.
each interference scenario i v e defines a data constraint dc i as shown in fig.
.
any solution to dc i if one exists defines an input vector ifor the concurrent program.
the constraint dc i consists of three parts i dc branch ii dc interfere and iii dc local.
the constraint dc branch encodes all branch conditions occurring in i. the intuition behind this constraint is that the program execution should follow the control path represented by the respective branching conditions.
dc interfere relates reads from shared variables which should be interfered by writes from other threads to the symbolic values of the write the read should interfere with.
finally dc localrelates each read from a shared variable which should not be interfered by any writes from other threads to the most recent write to the same shared variable performed by the same thread.
if there is no such write before the read we constrain the symbolic value of the shared variable to the initial value of the variable.
temporal consistency constraints.
an interference scenario i also defines a temporal consistency constraint tc i .
this constraint is over symbolic traces and any solution to it defines a schedule for the concurrent program.
the constraints in tc i as defined in fig.
are divided into the following four categories i thread local program order consistency poti ii thread fork consistency fc iii lock consistency lc1 lc2 and iv writeread consistency wrc wrc .
for each node nini an integer variable tn timestamp is considered to encode the index of the event of the node in a symbolic trace .
in the constraints let ni j represent the jthnode ingti and letntf ti represent the node n whereac n tf ti .
the constraints of tc i are poti ensures that for thread ti the thread local program order is respected in the schedule.
fc ensures that no thread can be scheduled before it is forked.
lc1 lc2 each lock acquire node aqwithac aq ac l andth aq tiand its corresponding lock release node rlinti define a lock block represented by .
letlti lbe the setof lock blocks in thread tiregarding lock l.lc1ensures that no two threads can be inside lock blocks of the same lock l simultaneously.lc2ensures that the acquire of lock lby a thread that never releases it in imust occur after all releases of lock lin other threads.
in this formula norelti lstands for lock acquire nodes in tiwith no corresponding lock release nodes.
wrc interfere wrc local letwxrepresent the set of all nodes u withac u wt x val intreads be all nodes vwithac n rd x r such thatvis involved in an interference edge in ei and locw be a function that for each node vwithac v rd x r andth v tireturns a node uwithac u wt x val and th u tiinisuch thatuis the closest such node to vbefore vingti.
for each read node vand write node u the formula coupled v u ensures that the read event of vis coupled with the write event of uin by forcing all events that write to the corresponding variable to happen either before the event of uor after the event ofvin .
non monotonicity of realizability.
we can now explain the nonmonotonic behaviour of interference scenarios wrt.
realizability that was mentioned in the discussion following def.
.
.
let iand i0be two interference scenarios where iis a subgraph of i0.
then according to the data constraints all constraints in dc branch i and dc interfere i appear in dc branch i0 anddc interfere i0 respectively.
however the constraints in dc local i anddc local i0 are incomparable.
the same phenomenon exists in the temporal consistency constraints i.e.
wrc localiniandi0are incomparable.
this implies that by extending an interference scenario the resulting constraint systems do not change in a monotonic way.
.
testing algorithm we now present our con2colic testing algorithm.
the algorithm tries to increase branch coverage in concurrent programs.
recall that we model each assertion in the program by two branches and therefore implicitly target at finding assertion violations.
since we aim for branch coverage we are specifically interested in interference scenarios related to nodes labeled with branch actions definition .
i nterference scenario candidate .
letnbe a branch node i.e.
ac n br for some .
a causal interference scenario c is an interference scenario candidate isc fornif sink c n. note that each isc cwith sink c n if realizable defines a set of partial program runs where ac n is the last action in the run.
our algorithm enumerates all iscs of degree k starting atk checks their realizability and moves on to iscs of degree k .
to keep the exposition simple we will make the following simplifying assumptions i there are no unforeseen interferences for an isc c i.e.
each program run r0extending a partial run r with c is r results in an interference scenario is r0 which has exactly the same interferences as c. ii there are no barriers in a programp.
iii there are no locks in a program p. in section .
we will address assumptions i and ii and in section .
we will address assumption iii .
note that we state all these assumptions for ease of presentation and that our approach is not limited to settings where these assumptions are true especially all benchmark programs in section contain locks.
.
testing algorithm alg.
shows our con2colic testing algorithm.
given a concurrent program pand a threshold kmax the algorithm investigates all iscs whose degree is kmax.
for each such isc the algorithm tries to compute a corresponding test.algorithm test programp boundkmax 1iforest forest 2isc set w0 wkmax un0 unkmax fork 0tokmax do wk unk i random inputs foreach threadtjdo concolicexecution p i tj w0 w0 extractiscs fork 0tokmaxdo while wk6 do pick and remove cfrom wk result i realizabilitycheck c isc set iscs if result6 realizable then unk unk fcg iscs exploreiscs c write nodes forest else concolicexecution p i wk wk extractiscs wrts new write nodes forest forall the c02uni i k 1do iscs iscs exploreiscs c0 wrts foreach c02iscs do k0 degree c0 if k0 kmaxthen wk0 wk0 fc0g data structures.
we have three central data structures i a global interference forest forest that stores all interference scenarios explored by concolic execution ii a list of sets w0 .
.
.
wkmax where each wk for0 k kmax serves as a worklist for iscs of degreek and iii a list of sets un0 .
.
.
unkmax where each unk for k kmax stores all processed but unrealizable iscs of degree k. all these data structures are initially empty cf.
lines to .
during execution of alg.
each generated isc c of degreekis initially inserted into wkand later on if cis not realizable it is moved to unkfor further exploration.
initial path exploration.
we initialize w0by executing a test i tj for each thread tj line where iis a random input vector we use the same ifor each thread tj and the schedule tj allows only a sequential execution of thread tjwithout any interruption from other threads.
when the concolic execution engine reaches the end of thread tj the program execution is aborted without executing any other thread our approach can be generalized to handle barriers but for simplicity of presentation we ignore them here .
as the result of the concolic execution a symbolic trace is returned.
then at line extractiscs takes the symbolic trace and derives new iscs with the same degree as is for further exploration of program behaviour i.e.
during initialization it generates iscs of degree .
we describe algorithm extractiscs in the next paragraph.
we insert the returned iscs into worklist w0.
now after the initialization phase in lines to in alg.
w0 contains for each thread in pa set of iscs for further initially thread local exploration.algorithm extractiscs symbolic trace isc set 1f adddanglingnodes is 2mergeinterferenceforests forest f 3isc set iscs foreach dangling node nnewly added to forest do iscs iscs fcis forest n g return iscs 2t0 5br r0 i0 r0 8br r0 i0 r0 a interference scenario is t0 for a symbolic trace t0obtained by a sequential execution of thread t0 cf.
fig.
.
2t0 5br r0 i0 r0 8br r0 i0 r0 d1 br r0 i0 r0 d2 br r0 i0 r0 b interference scenario is t0 extended with dangling nodes d1andd2.
2t0 5br r0 i0 r0 8br r0 i0 r0 d1 br r0 i0 r0 d2 br r0 i0 r0 c interference scenario candidates cis forest d1 andcis forest d2 .
figure example showing initialization for thread t0 cf.
fig.
.
algorithm extractiscs .extractiscs shown in alg.
gets a symbolic trace as input.
each branch event in has a corresponding dual branch event where its symbolic constraint is negated.
alg.
first obtains is .
for example fig.
6a shows is where is the symbolic trace returned by the initial sequential execution of threadt0 introduced in fig.
.
in line in alg.
is is extended to an interference forest fby introducing for each dual branch event a so called dangling node e.g.
nodes d1andd2in fig.
6b.
then fis merged into forest cf.
line as described in remark .
.
for each dangling node which was not merged with an existing node we create an isc cf.
lines and e.g.
cis forest d1 andcis forest d2 in fig.
6c.
these iscs are returned to the main algorithm.
note that all generated iscs will have the same degree as is .
this is due to the fact that the dangling nodes which are not already present in forest occur after the sink of the isc which was used when generating the test for .
since forest is initially empty during the initialization phase an isc is generated for each dangling node in f. main loop.
the testing algorithm processes worklists w0 wkmaxin ascending order cf.
main loop at line .
while processing wk the loop at line each isc c2wkis removed from wkand its realizability is checked see section .
algorithm realizabilitycheck .
given an isc c realizabilitycheck returns a triple result i where result indicates whether cis realizable or not.
if cis realizable then i forms a test that realizes c. isc exploration.
ifcis not realizable then we store c intounkfor later processing.
since the realizability of iscs is not monotonic as discussed in section cstill has a chance to become realizable if we introduce some more interferences in it.
therefore we collect all write nodes stored in forest cf.
line and then use exploreiscs alg.
to extend cto a set of iscs2 5br r0 i0 r0 8br r0 i0 r0 14br r0 i0 r1 17br r2 i0 r3 d3 br r0 i0 r1 d4 br r2 i0 r3 d1 br r0 i0 r0 d2 br r0 i0 r0 t0 t figure interference scenario is from fig.
extended by dangling nodesd1 d2 d3 andd4.
the loosely dashed lines enclose the interference scenario candidate cis forest d4 .
for target branch sink c by introducing a new interference from a write in wrts to a read in c. each of the generated iscs has a degreei k and is added to wiin lines to .
since i k the newly generated iscs will be processed after wkis processed completely.
we discuss exploreiscs at the end of section .
.
path exploration.
ifcis realizable then the program is concolically executed with input vector iand according to schedule cf.
line .
the moment sink c is executed the schedule enforces an exclusive execution of thread th sink c without any interruption from other threads.
as in the sequential case the moment the end of thread th sink c is encountered the concolic execution engine aborts program execution.
the concolic execution returns a symbolic trace which is fed to extractiscs to derive iscs from similar to the k 0case described earlier see fig.
for an example with k .
all generated iscs are added to wk.
isc re exploration.
during concolic execution we might observe a write event we have not observed so far this might be due to the fact that we covered a new code location or that we observed a write to a shared variable combined with a symbolic value which was not observed before .
note that at line we extended an unrealizable isc by interferences resulting from writes stored inforest .
when we observe a write event which was not in forest back then we have to reconsider all previously unrealizable iscs and have to extend them by interferences from this new write event to reads in these iscs.
this happens in lines and .
there each previously unrealizable isc c with degree smaller than kis re explored with the newly observed writes.
each such write event must occur after sink c was executed and therefore has degree k. then the iscs generated in line have degree greater than kand are added to the according worklists in lines .
algorithm exploreiscs .algorithm exploreiscs explores iscs by extending existing iscs with new interferences.
let nrbe a read node in a given isc c. letnwbe a write node in forest and letiwbe the causal interference scenario of nw i.e.
iw cis forest nw .
to create an isc c00which extends cby the interference nw nr the algorithm checks the following conditions i nrandnware in different threads i.e.
th nr th nw .
ii nrreads from the variable to which nwwrites to i.e.
if ac nr rd x r for some symbolic variable r then ac nw is of the form wt x val for some expression val.
iii nris not involved in any interference in coriw i.e.
nr ri c andnr 2ri iw cf.
section .
iv candiware compatible cf.
def.
.
and remark .
.algorithm exploreiscs isc c write nodes wrts iscset 1isc set iscs foreachnr2read nodes c nri c do letac nr rd x r for somex foreach nw2wrts do if ac nw wt x val for somevalthen if th nw th nr then iw cis forest nw if nr 2ri iw andcompatible c iw then c0 merge c iw c00 extend c0by interference nw nr iscs iscs fc00g return iscs if all conditions are satisfied then in line candiware merged as described in remark .
and form an isc c0.
then in line c0is extended to isc c00by introducing the interference edge nw nr .
alg.
collects all generated iscs cf.
line and finally returns them in line .
note that each generated isc c00has the same sink as c i.e.
sink c00 sink c and has at least one more interference than c i.e.
degree c00 degree c .
the degree ofc00might increase by more than one interference because iw might contain interferences which are not present in c but due to the merge they show up in c0andc00as well.
.
soundness and completeness in section we discussed data constraints dc i and temporal constraints tc i corresponding to an interference scenario i. the following theorem shows how these constraints can be used to figure out whether an isc is realizable or not.
theorem .
s oundness .let c be an isc in wkwhere k kmax.
then c is realizable if and only if dc c and tc c are satisfiable.
algorithm realizabilitycheck .given an isc cwith sink c n the realizability of cis checked by determining whether dc c andtc c are both satisfiable.
assume that cis realizable and and iare solutions for tc c anddc c respectively.
then realizabilitycheck algorithm called in alg.
at line returns a triple result i where result determines that cis realizable and th n that forces the sequential execution of thread th n after .
according to thm.
.
our test generation approach is sound i.e.
if the program is executed with input vector i and according to schedule then the branch node nwill be covered.
theorem .
c ompleteness .given a deterministic programpand a bound kmax alg.
covers all branches of pthat require at most kmaxmany interferences to be covered.
like all completeness results in concolic testing thm.
.
relies on several idealizing assumptions.
the theorem states that for deterministic programs without non linear arithmetics and calls to external library functions our con2colic testing algorithm covers all branches of pthat require at most kmaxmany interferences to be covered.
in practice concolic execution falls back upon concrete values observed during execution to handle non linear computations or calls to external library functions for which no goodsymbolic representation is available.
for that reason it always underapproximates program behaviours.
note that if we do not stop alg.
after it performed kmax many iterations of the main loop or after full branch coverage is achieved then alg.
actually achieves in the limit a stronger coverage than branch coverage.
we leave an exact characterization of the coverage achievable by alg.
for future work.
.
unforeseen interferences in order to drop assumption i stated at the beginning of section we need to make the following changes the concolic execution engine stops as soon as an unforeseen interference is observed and returns a symbolic trace that ends with the read event of the unforeseen interference.
alg.
is extended as follows when building forest fin line we add a distinguished dangling node which is labeled with the read event of the unforeseen interference.
however we do not add the unforeseen interference tof.
as an effect alg.
will then in line create a causal interference scenario for this special dangling node.
consequently alg.
will then try to realize this interference scenario first without introducing an interference.
if this is not possible then it will introduce some interferences later.
this enables us to explore the interference space and build the interference forest in a systematic way i.e.
while processing wk the interference forest is updated with interference scenarios of degree k. observe that we have to extend the notion of cis to allow sink nodes labeled with read events.
since our algorithms never make use of the fact that the sink of a cis is a branch node the overall testing algorithm is not changed.
barriers can be handled in a similar way due to space restrictions we omit details.
.
lock protected writes consider an isc cwith sink c n. it might be the case that for a thread ti6 th sink c the last node in gtiis labeled with a write event that happened while tiwas holding some locks.
this may cause the following problems i cmight never become realizable e.g.
if nis also protected by the same locks thentidoes not have any chance to release the locks.
ii cmight be realizable but the test generated for cmay lead to a deadlock e.g.
thread th sink c acquires any of these locks later.
to solve these problems whenever we create a new isc c we extend all thread local sub scenarios of caccording to forest with the exception of thread th sink c such that for each thread tithe last node ingtiis not protected by any lock.
as an example consider the isc shown in fig.
.
there t0holds a lock at node .
therefore the isc is extended to include node where t0releases the lock.
note that this extension might not be unique if the release of a lock can happen in different code branches.
to preserve completeness we consider all possible extensions i.e.
we actually generate a set of iscs.
furthermore like in the case of re exploration of unrealizable iscs due to newly observed write nodes we have to re explore iscs whenever we observe new lock release events.
in our benchmarks the extensions until lock free nodes were unique.
.
optimizations for isc exploration unsat core guidance.
in alg.
isc exploration is performed by adding new interferences to iscs.
in case an isc is not realizable it might be the case that no extension of the isc by interferences will ever get realizable.
from the unsatisfying core of the constraint systems defined in section we can identify such situations.
let c v e be an isc.
data constraint dc c is then equal to dc branch v dc interfere c dc local c .
extending cto a new interference scenario c0by adding an interference to c removes some predicates in dc local c from dc c0 but the pred icates in dc branch v anddc interfere c remain as part of dc c0 .
therefore if the unsatisfying core of dc c does not involve predicates from dc local c we can conclude that dc c0 or any other extension of cwill not be realizable as well and therefore we can exclude cfrom further exploration.
analogously if tc c is not feasible and no constraints from wrc localare involved in the unsatisfying core then again we can conclude that cwill not become realizable by adding new interferences and we can exclude cfrom further exploration.
furthermore in both cases the unsat core can be used to guide the exploration by introducing an interference for a so far local read whose constraints are involved in the unsat core.
duplication freedom.
alg.
allows multiple instantiations of the same isc.
for example suppose that an isc cbecomes realizable by introducing interferences for two reads.
the algorithm can first select any of these reads and generate two iscs in which one of these reads is interfered.
then in the future these two iscs can be extended such that the other read is also interfered generating two instances of the same isc.
to avoid duplication of iscs we use a caching mechanism.
in this way an isc will be processed only if it is not already in the cache.
prioritized exploration.
while processing each worklist wk we can choose to prioritize the iscs in wk.
for example in our implementation we assign higher priorities to iscs which would cover some yet uncovered part of program code in case they are realizable .
based on this exploration strategy alg.
at line first processes iscs with higher priorities.
.
experiments our con2colic testing approach is implemented in a tool called concrest as an extension to c rest .
we use a standard collection of concurrency benchmarks to evaluate its effectiveness.
we ran our experiments on a dual core bit linux machine with .2ghz and 16gb ram.
benchmarks.
bluetooth is a simplified version of the bluetooth driver from .
sor is from java grande multi threaded benchmarks which we translated to c .
ctrace a andctrace b are two test drivers for the ctrace library.
apache a andapache b are test drivers for apache ftp server from bugbench .
splay andrbtree are test drivers for a c library implementing several types of trees.
aget is a multi threaded download accelerator.
pfscan is a multi threaded file scanning program.
finally art is an example designed by us to evaluate the scalability of our approach when the number of threads increase.
it has the property that there is a new assertion in it every time we increase the number of threads by one.
experimental results.
in our experiments we set kmax at most interferences and a timeout of hours.
the results are presented in table .
we learned the following important facts i concrest is effective at finding bugs.
all the known bugs were discovered.
ii all bugs discovered by c oncrest in benchmarks were the result of a branch which would not be covered sequentially.
iii all bugs were discovered under a relatively small number of interferences maximum .
iv on average a substantial number of branches were not sequentially coverable and were only covered after interferences were introduced e.g.
for rbtree which has fixed input branch coverage increases from to maximum number of coverable branches .
in the lack of a bug found reaching this maximum provides guarantees to the tester that e.g.
no assertions in the code can be violated.
v we set the maximum number of interferences to be but the actual bound explored by c oncrest is much smaller.
this is because in most cases with the exception of timeout cases we either achievedtable experimental results benchmark threads inputs branches branches max k reached branches bug found isc time total k ... reason k !max k k total total bluetooth full cov.
!
yes .
sor full cov.
!
yes .
ctrace a max cov.
!
yes .
apache a max cov.
!
yes .
splay max cov.
!
no .
apache b max cov.
!
yes .
aget max cov.
!
yes .
rbtree max cov.
!
no .
pfscan timeout !
yes .
ctrace b timeout !
yes .
art2 full cov.
!
yes .
art3 full cov.
!
yes .
art4 full cov.
!
yes .
art5 full cov.
!
yes .
branches number of static branches i.e.
number of basic code blocks.
k number of interferences.
full cov.
all branches are covered.
max cov.
all possible interference scenario candidates are explored.
isc number of explored interference scenario candidates.
means branches covered at k new branches at k and new branches at k .
!24indcates the difference between the number of branches covered sequentially and the total number of branches covered .
full branch coverage or explored all possible iscs i.e.
no more branches are coverable .
vi our approach scales well as the number of threads increase see art.
there are cases where maximum branch coverage is achieved but the number does not coincide with the total number of static branches.
these are due to sanity check type assertions in the code which were never meant to be violated.
table presents the effect of the optimizations discussed in section .
for pfscan as an example .
in this benchmark the bug i.e.
assertion violation is discovered at k .
when there is no optimization enabled it runs out of memory with k .
the efficacy of unsat core guidance is clear because without this optimizationkcannot go higher than .
in fact to move to k 4and catch the assertion violations both unsat core guidance and duplicationfreedom have to be enabled.
the effect of prioritized exploration can be observed by comparing rows and when prioritization is enabled the assertion violation is found earlier.
we compared our tool with poirot on some of the benchmarks.
poirot exploits context bounding sequentialization of concurrent programs and performs a static analysis to check for safety properties.
a side by side comparison with poirot when it does not aim for coverage in the same sense as c oncrest is not meaningful .
our experiments showed that poirot did not scale well for the programs that we checked.
for example the bug in sorwas found within a second by our tool but poirot was not able to find it for context bound of and within .5hrs for each bound .
.
related work in the introduction we surveyed a number of techniques for testing concurrent programs.
here we focus on a subset of them which are closer to con2colic testing and discuss how con2colic testing table effects of optimizations on benchmark pfscan .
row u p d assertion coverage t max k total t timeout timeout timeout timeout timeout out of memory timeout out of memory u unsat core guidance p prioritized exploration d duplication freedom.
symbols and represent optimizations being on and off respectively.
last three columns correspond to the time it took for the assertion to be covered the maximum k explored and the total time for testing.distinguishes from them in more detail.
extensions of concolic testing to concurrent programs have been proposed before.
in jcute the program is executed concolically and data races in the observed execution are identified.
then either the schedule is fixed and new input values are generated for the same concurrent schedule or a new schedule is produced by keeping the inputs fixed and simply re ordering the events involved in a data race.
in contrast to con2colic testing jcute is incomplete due to its race based schedule selection heuristic.
moreover if a timeout occurs it is impossible to quantify the partial work done as a meaningful coverage measure for the program.
similar to con2colic testing a recent related work generates tests with the aim of increasing code coverage of concurrent programs.
however it uses an under approximation of the program i.e.
a set of program runs as opposed to the actual program.
therefore it is incomplete.
furthermore test generation is done by solving a constraint system that encodes the scheduling constraints and the data flow constraints together while considering the whole computation in the runs.
however con2colic testing generates separate constraint systems for schedule generation and input generation which are based on only shared variable accesses and synchronization events this reduces the complexity of the constraint systems drastically and increases scalability.
some other recent work build a framework based on over and under approximations of interferences of the programs to check for safety properties.
like they build a constraint system which includes local computation as well as global computation.
therefore to reduce scalability issues they focus only on program slices obtained from program executions.
finally several sequentialization techniques have been proposed to reduce the problem of verifying concurrent programs to verification of sequential programs.
however one cannot apply traditional sequential testing techniques on the sequentialized programs obtained by many of them as they are highly non deterministic.
furthermore to execute sequential programs obtained by we should guess the values of shared variables at the beginning of each context.
however wrong guesses might result in reaching invalid program states.
.