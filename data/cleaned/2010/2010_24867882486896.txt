dynamic injection of sketching features into gef based diagram editors andreas scharf software engineering research group university of kassel kassel germany andreas.scharf cs.uni kassel.detill amma software engineering research group university of kassel kassel germany till.amma cs.uni kassel.de abstract software engineering in general is a very creative process especially in the early stages of development like requirements engineering or architectural design where sketching techniques are used to manifest ideas and share thoughts.
on the one hand a lot of diagram tools with sophisticated editing features exist aiming to support the engineers for this task.
on the other hand research has shown that most formal tools limit designer s creativity by restricting input to valid data.
this raises the need for combining the flexibility of sketchbased input with the power of formal tools.
with an increasing amount of available touch enabled input devices plenty of tools supporting these and similar features were created but either they require the developer to use a special diagram editor generation framework or have very limited extension capabilities.
in this paper we propose scribble a generic extensible framework which brings sketching functionality to any new or existing gef based diagram editor in the eclipse ecosystem.
sketch features can be dynamically injected and used without writing a single line of code.
we designed scribble to be open for new shape recognition algorithms and to provide a great degree of user control.
we successfully tested scribble in three diagram tools each having a different level of complexity.
index terms sketching recognition modeling graphical editor i. i ntroduction people use hand drawn sketches on a day to day basis in many different and heterogeneous fields.
there are different reasons why people sketch sharing as a major part of communication and externalizing internal thoughts groundingto clarify ambiguous interpretations of a conversation manipulating to support the collaboration part among team members after sharing and brainstorming to reveal unintended interpretations as well as to enhance creativity.
while the medium for sketching ranges from pen paper to whiteboards or flip charts the problem of insufficient editing flexibility remains and is fixed to edit operations such as adding and removing elements.
it is not possible to copy paste rotate or resize any drawn elements .
since sketch input enabled hardware like tablet pcs smartphones and smartboards become more and more available there is a shift from solely analog mediums to digital hand drawn sketches.
now it is possible to e.g.
rearrange copy paste scale and rotate the drawn content or even work with distributed teams .
a lot of research has already been done to further support andincrease user experience during sketching on digital devices .
calico e.g.
enhances the plain white surface with several concepts to easily create and modify sketches.
however most of these tools focus on creating informal sketches which of course enables the user to draw and modify arbitrary content in a very flexible way.
but especially in early phases in the software engineering process like requirements engineering or system design developers often use dedicated diagram types like uml use case diagrams composite structure diagrams or class diagrams .
the tool support for creating and modifying the mentioned diagram types is large e.g.
.
in general these diagram types have a strict syntax and most tools restrict editing operations to valid data.
this limits the users creativity and breaks the design flow which is one of the reasons why developers fall back to informal tool support .
as a consequence much work in these early phases is done several times first prototypes and ideas are captured on a analog whiteboard and later portrayed in a computer aided software engineering case tool to benefit from sharing validation code generation facilities and more.
to combine the strengths of informal sketching with the power of software engineering tools current research tries to integrate sketching capabilities into new and existing tools.
until now several tools already support freehand sketch functionality along with recognition of drawn content .
as grundy and hosking already state in the technique used to implement the sketch functionality is either unique for a given tool or lacks user control over recognition and formalization of drawn content.
therefore they integrated sketching features into their meta toolset called marama which allows any diagram centric design tool generated by marama to benefit from generic sketching based input.
however they also admit that this approach only works for diagram tools generated with marama.
beside marama we are only aware of one other framework which uses a similar approach sketch .
sketch aims to bring sketch features into new and already existing diagram editors based on the eclipse graphical editing framework gef .
using a small set of configurations the developer can specify the elements that should be recognized by sketch.
however a code review has shown that the extension capabilities and the extent the user can control the recognition process are limited.
.
c ieee icse san francisco ca usa822 furthermore the development seems to be stuck.
we propose the scribble framework a generic extensible framework which brings scribble functionality to any new or existing gef based diagram editor in the eclipse ecosystem.
scribble is generic because it can augment diagram editors with scribble features on the fly requiring the developer to write no code at all.
on the other hand it is extensible to a great degree for instance by allowing users to add new recognition algorithms and train the recognizer by providing new templates.
unlike other similar frameworks scribble is aware of the editor type under modification and thus can build a context between the editor type drawn scribbles and available tokens.
this context can be shared in an online database to take advantage of a larger community.
in the next section we discuss our motivation for creating scribble.
section iii delivers insight into the background of the scribble domain and discusses related work.
in section iv we outline requirements a good sketching framework should have.
we describe the scribble framework in detail and show the current implementation status in section v. we continue with an evaluation in section vi and finally finish with conclusions and future work.
ii.
m otivation and approach looking at the shortcomings of existing approaches outlined previously the main research question is is it possible to seamlessly augment existing complex diagram editors to support sophisticated sketching functionality?
this rather broad and ambiguous question includes but is not limited to the following problems is it possible to integrate parts of the framework into different environments by providing common components?
what are meaningful places concerning extensibility and adaptability?
how can different input methods like single multi touch and speech input be addressed?
can sketched content be formalized incrementally and can both coexist?
to what extent can and should end users have influence on the learning and recognition process?
how much training is required to get suitable recognition results?
and finally are sketch based techniques accepted by users of graphical editors?
as a first step to answer the above questions we propose scribble a generic and extensible framework for adding sketch features to any gef based diagram editor.
scribble allows the user to ad hoc equip their diagram editor with sketch features by simply installing the framework which requires the user to not write any code at all.
scribble then recognizes and tracks gef based diagram editors and dynamically injects the scribble tool and some new layers to hold hand drawn scribbles.
the framework automatically extracts elements supported by the diagram editor by analyzing the editor s tool palette.
we integrated the n algorithm and the approach used in sketch which is based on the levenshtein distance for shape recognition but scribble is open for any new algorithm by simply using the eclipse extension point mechanism.
if no training data is available for the editor in question scribble supports online training to incrementallytrain the recognizer.
a connection to an online service already containing training material for different editors is created right now and will be available soon.
iii.
b ackground sketching is used by people for plenty of reasons.
it is often used as a problem solving technique where thoughts and ideas are written down which enables the human brain to concentrate on the next step rather then keeping the big picture in mind all the time.
it serves as a communication medium in a team and ensures that everybody is talking about the same thing on the one hand while still have enough room for creativity on the other hand.
the scrawly informal style encourages users to perform modifications at any time instead of sticking to a possibly awkward design what often happens when dealing with more formal and beautified material.
sketchpad was the first system which presented a manmachine graphical communication system in .
although this dates back a lot of years adding sketch input to hardware as well as any type of software system remains an open and quite active research area.
sketching and the required computational technology is an interdisciplinary research area where fields like human computer interaction hci cognitive science computer science and artificial intelligence ai come together.
johnson et al.
recently published a review which is helpful in getting an overview of the current state of research.
there has already been done a great amount of work in nearly all sketch related areas.
in the field of low level sketch support plenty of algorithms and a few toolkits have been developed.
a well known feature based single stroke recognizer was introduced by rubine and has been used and evaluated many times.
other algorithms use neural networks to recognize handwritten text .
n is a more recent algorithm for recognizing multi strokes by using only simple geometry and trigonometry.
hse and newton created the hhreco library a recognition system for multistroke text and shape recognition which is used in several tools and frameworks e.g.
.
a remarkable amount of tools and frameworks where created in the last two decades which often make use of the mentioned algorithms and libraries.
silk was one of the first tools to support the creative process in userinterface design and is able to transform sketches into an operational interface.
a similar tool is denim which supports web designers in the early stages of design.
inkkit is another tool aiming to reduce the development effort to support sketching in specific types of diagrams.
whereas these tools try to solve a sketch related problem for a specific domain and were designed with little or no reuse in mind a few frameworks arose recently to address this problem.
the frameworks most related to the work we present in this paper are marama and sketch which both build upon the eclipse ide and provide sketch input features to new and existing diagram editors based on gef.
eclipse along823with the large set of available plugins and the vast community support is often used to create any kind of open source tool.
marama is a set of meta tools enabling the user to create complex diagram editors with sketch support.
marama sketch supports different approaches regarding the recognition mode whereby it is possible to sketch only no recognition is performed at all or even mix sketched and recognized content.
as grundy et al.
state themselves one of marama sketch s weaknesses is that it only supports marama based diagram editors.
also no information about extension mechanisms to e.g.
integrate additional recognition algorithms are provided.
sangiorgi and barbosa recently proposed the sketch framework .
like marama sketch is implemented as a set of eclipse based plugins and attempts to extend gef based diagram editors.
the main difference between marama and sketch is that marama only works for diagram editors generated by marama whereas sketch basically supports any kind of gef based diagram editor.
this certainly is a great benefit because most diagram editors in the eclipse environment are either pure gef editors or generated with help of the eclipse graphical modeling framework gmf .
sketch also supports a beautified and a sketched mode and allows to switch between these two modes.
although sketch theoretically provides a chain of recognition algorithms only one algorithm is integrated at the moment and a short code review did reveal any information if and how any custom algorithm could be integrated.
furthermore neither marama nor sketch support any interchange of training data and thus needs every user to re train the recognizer.
iv.
f ramework requirements a perfect sketch based framework works with every diagram editor without bothering a developer to implement a series of interfaces into their framework.
but from the other point of view the sketch framework should not make any assumption on the editor it is going to be attached to the client framework .
to get both frameworks to work together a contract has to be agreed upon.
in this contract the client framework gives the sketch framework a list of token objects that it knows how to handle.
these tokens resemble labels for recognized shapes.
once a shape has been recognized the appropriate token is passed to the client framework which initiates the element creation process.
the process of sketching on a sheet of paper should be emulated as close as possible.
this means that minimal assumptions on the input device have to be made.
the most basic device would be one with single touch without pressure recognition.
the graphical user interface has to be enhanced to perform tasks like resizing moving or deleting because they could not be distinguished from actual sketching.
thus there must be some sort of mode change via a gesture like a long press to initiate moving or double tab for resize.
if a lot of auxiliary modifications are possible one will eventually run out of gestures.
in that case a graphical aid is more useful for instance an overlay that annotates existing elements with needed element manipulation facilities.users have to be able to participate on the internal processes of the sketching framework.
this includes active roles such as labeling of sketched shapes on demand.
but also useful output of the framework to give an understanding of the internal decision process could be a benefit.
the framework needs to be extensible.
users may want to exchange a recognition algorithm or need multiple shape recognizers that perform better on unique subsets of shapes.
therefore the framework has to provide support to extend its features.
during diagram creation not only new strokes of user input have to be investigated but rather all strokes have to be reevaluated each time a new one is drawn.
imagine a couple of elements are drawn and diagram elements are created on thefly.
a stroke is added with the intention to change an already created object.
when only new strokes are passed through the recognition process the intended solution cannot be found.
finally responses of the framework should be in real time.
capturing time outs or calculations that delay responses on user input disrupt the natural sketching flow and make the use of the framework awkward and unpleasant.
v. t hescribble framework in this section we describe the present state of an implementation of a sketching framework with regards to the previously described vision scribble.
in the following passages we will use the terms stroke and scribble.
the basic elements of this framework are strokes.
strokes are a collection of points which are annotated with time stamps.
a scribble is a collection of strokes and has at least one corresponding element on the diagram of the client framework.
a. injecting scribble into gef gef is a framework that provides developers with highlevel support to create editors in the eclipse environment.
gef makes use of a series of well known design patterns such as request command and model view controller and contains predefined editor stubs featuring a palette with tools shown in fig.
and other constructs that can be utilized to achieve a generic sketching framework.
furthermore eclipse includes an extension point mechanism that is designed to allow thirdparty developers to enhance the functionality of a plugin.
the scribble framework is able to automatically connect to a gef diagram editor if it is implemented using a graphicaleditor and has a palette.
the scribble tool can then be injected into the palette by a single button click.
to create the contract tokens described in section iv the framework analyzes the entries of the palette and generates token objects based on found information.
to gain more control over the contracting between the frameworks the eclipse extension point mechanism can be employed to define tokens for editors.
the principle internal workflow for standard gef editors is a tool e.g.
create rectangle builds a request and sends it to an editpart which in turn asks its editpolicies to create a command for the request.
the command is returned and824rooteditpart clientdiagrameditpart scribbleeditpartfactory editpartfactoryscribbleboardeditpart scribble tool attach scribble tool palettefig.
.
simplified overview of the scribble architecture.
blue elements refer to the client framework red elements to the scribble framework.
subsequently the command s execution is triggered by the tool.
for commands that create diagram elements a creationfactory is provided via tool and request.
the implemented version of the token enhances the concept of it being a single arbitrary object as envisioned in the requirements.
to leverage the available tool mechanisms of gef the token mimics a tool.
once an element should be created a request is issued containing the token s creationfactory.
when tokens are defined via extension point the defined contract object is wrapped into a generic creationfactory to ensure the standard gef mechanisms can be utilized.
besides adding the scribble tool into the palette of the client editor an additional layer is injected to show a pane with scribbles and strokes.
the reason for this additional layer is of visual nature.
by having several layers it is possible to easily toggle visibility for strokes and scribbles on and off without altering the client framework.
during editpart creation gef will walk through all editparts to retrieve the proper parent element.
the last editpart to be asked is the rooteditpart that forwards the request to its content the sole child element which is the client framework s main editpart usually the one reflecting the diagram.
the client framework does not know how to create strokes or scribbles.
to achieve a proper segregation on the rooteditpart level more than one child element has to be present one for the client framework and one for the scribble framework.
therefore a switch has to be created in the rooteditpart.
because a rooteditpart is designed to hold only a single child it is necessary to use reflection to inject children into the rooteditpart.
gef then initiates the creation of the visualsand loading of model elements for both the client and the scribble framework.
for commands that are intended for either framework a switch is created via an editpolicy in the rooteditpart.
another point where gef relies on special framework knowledge is the editpartfactory where for a given model element a corresponding editpart is created.
here the same argument as above holds true the client framework does not know how to handle scribble objects.
our solution is to wrap the editpartfactory of the client framework once scribble is enabled for the editor.
strokes scribbles et cetera are handled by the wrapping factory.
unknown objects are passed to the client editpartfactory.
for each editor instance the scribble framework generates a context with a registry for tokens and a scribbleboard containing all strokes and scribbles for this editor as well as the current solution from the recognition process.
this allows to switch between editors in the workbench without losing information.
the token registry is a container for a mapping of tokens to a list of scribbles.
it also serves as the point to retrieve information on token themselves and stores user training data.
when a user explicitly labels a scribble with a token the scribble is appended to the appropriate list in the token registry.
for sketching on paper only one tool is necessary a pen.
diagram editors rely on multiple tools to create elements and connections to select move resize and so forth.
the scribble tool combines the simplicity of real life sketching with the benefits of manipulating drawn elements on digitally created diagrams.825we implemented an overlay to tackle the above mentioned problems.
with the scribble tool selected a simple click or touch that does not exceed a number of points determined by a threshold is interpreted to trigger the overlay instead of initiating a stroke.
the overlay annotates the targeted element with a series of buttons as shown in fig.
c .
with the buttons the element can be moved deleted and resized.
the overlay makes it possible to interact with diagram elements making the selection of a different tool from the palette superfluous while also keeping in mind a very simplistic input device.
even though one can achieve any kind of modification through the scribble tool one might change back to other tools to manipulate elements.
generally side effects that change a client diagram without direct interaction have to be addressed.
this circumstance makes it inevitable to track client elements for scribbles to change accordingly.
we implemented a series of editpolicies and listeners to register client element modification.
especially moving elements from one parent element to another is no trivial task because elements get deleted and recreated within the new parent.
therefore whenever an element is moved also the element under the cursor has to be tracked in order to register a creation of an object.
also moving or deleting a stack of elements should be mentioned.
gef treats locations of elements relative to their parents location and does not trigger an event for its child elements.
so not only the parent of an element has to be tracked but also all its ancestors to be able to track locations for scribbles.
a scribbles nature is to be transparent so clicks on the diagram pane are not captured by the scribble editpart but by the underlying client editpart and are recognized by the scribble through the attached listeners and editpolicies.
b. scribble core in the previous sections we mainly focused on how the scribble framework is integrated into a client framework.
this section deals with the actual process from sketching something over recognition to transformation.
sketching in the scribble framework starts by selecting the scribble tool and drawing a line on the editor pane as shown in fig.
.
once the tool recognizes a button up event the tool passes the drawn stroke to the core where it is added to the board and gets analyzed.
scribble s core is divided into three different modules evaluator decider transformator depicted in fig.
each of which encapsulates a unique step from the input of a stroke to finally creating a scribble and asking the client framework to execute changes.
the evaluation module takes care of the classical recognition task.
our generic approach supports the use of multiple recognition algorithms.
if an algorithm masters one task it could be bad in another algorithms could be optimized to recognize a special set of shapes another one could be focused on the recognition of connections.
thus we introduce the recognizer as extensible parts for the evaluator.
a recognizer is a classical recognition algorithm wrapped into a slim api.
it takes a set of strokes as input and returns a list of resultcontributions.
a resultcontribution comprises transformatordeciderevaluator resultcontributions winning resultcontribu tioncorescribble tool new stroke new scribblerecognizer1 ...classificator1 classificatorn... strategy1 strategyn...recognizernfig.
.
scribble core modules with input and results the stroke combination itself and the token calculated as a result together with an info string and a float value representing the recognizers certainty concerning this result.
currently we employ two recognition algorithms already using the recognizer api.
the first one calculates the levenshtein distance between strokes.
sketch features this recognition technique and we ported it to use our recognizer interface.
we also implemented the n algorithm.
n in contrast to levenshtein is able to handle multiple strokes.
for the levenshtein algorithm multiple strokes of a multi stroke sketch are connected into one single stroke.
the amount of required training data depends on the used recognition algorithm.
for instance the n algorithm has an error quote of while having one template for a certain shape .
training data like templates for template based recognition algorithms can be retrieved in several ways the user can provide new data during diagram modification.
another way could be the import of already existing training data from an online service.
all resultcontributions over all participating recognizers are aggregated in the evaluator.
but this is not the sole task of the evaluator.
imagine a vast amount of strokes have been drawn and a new evaluation process is triggered.
the naive approach is to let the recognizers find results on every possible combination of strokes.
this implies a power set over all strokes.
with every new stroke sketched each recognizer826strokes token certainty strokes source triangle .
recognizer1 line .
recognizer1 reactangle .
recognizer2 triangle .
recognizer2 trianglenr.
.
recognizer1fig.
.
drawn strokes and resultcontributions produced by two recognizers has to check for matches on each combination to find the best possible solution.
the effect of this is the loss of realtime reactions to user inputs an undesirable circumstance.
to circumvent this situation the evaluator generates a subset of interesting strokes to speed up the recognition process by sacrificing precision in the solution.
at the moment two classifiactors are implemented to evaluate strokes on how interesting they are time and location.
both classificactors use the last drawn stroke as a reference to check whether other strokes are close.
the time criterion is obviously the difference of time between one stroke s end and the next stroke s start.
a threshold on this difference determines if they should be considered to be counted as one shape or not.
for the location classificator a bounding box around the stroke is calculated.
every stroke intersecting this bounding box is considered part of the shape.
additional classificators can be introduced into the scribble framework using an eclipse extension point.
assume a triangle is drawn in two strokes multiple resultcontributions are created like shown in fig.
.
the results differ in the found token for a given set of strokes the certainty and number of used strokes.
this set consist of contradictory results identical stroke sets pointing to different tokens results and in fig.
or inconsistencies stroke sets using the same stroke for different results results and in fig.
.
those problems are targeted in the decision module.
the decider tries to find the best solution within all available resultcontributions using strategies to determine which result is best.
the first strategy is trust .
each recognizer can have a level of trust that is given as a certainty threshold.
if the result of a recognizer is located beyond its threshold the result is discarded.
another binary strategy is focused on the token itself and its context.
by analyzing the token s context it can be determined whether it makes sense to create an object described by the result.
analyzing a context for a given token is done by probing an editpart.
a set of strokes has a point of reference top left corner of the bounding box which is used to find a target editpart on the client framework via gef mechanisms.
this target editpart is then asked to return a command for a creation request based on the token of interest.
whether the returned command is executable or not indicates the tokens validity for creation and also the results validity.
other strategies are consulted to give a logical order to resultcontributions using certainty and number of strokes.
of course the result with the higher certainty is favored.
but in situations where the certainty can be considered equal see results and in fig.
another criterion has to be addressed to find a winner.
in this case we choose the result that comprises the most strokes.
the reason for this is to minimize stray strokes on the board.
the decider can be extended with additional strategies.
summarized the procedure of finding the best result is pick a resultcontribution check whether the certainty is beyond the one given as trust for the recognizer check whether the token is viable in the location of the diagram check whether the new candidate has a better certainty or combines a larger number of strokes as the previously selected remember winning stroke set do steps until all resultcontributions have been checked.
in the final step of the core the client diagram has to be adjusted based on the result of the previous step this happens in the transformator.
a transformation is actually the deletion and recreation of elements indicated by the picked resultcontribution.
during a transformation all previous objects that are connected to strokes of the winning stroke set are destroyed.
this happens by asking the client framework for an appropriate deletion command for the editpart referenced by the strokes.
after the execution of the delete command the creation of the new scribble comprised by the winning stroke set is handled in the same manner.
the reason why this process is divided into two disjoint commands is caused by how gef retrieves commands.
when combining both commands they are created first then executed.
as mentioned the creation process asks for a target editpart at the location of the stroke sets location point.
if that target editpart is resolved before the old element is deleted a wrong parent element is returned and the create command will execute with an unintended result.
since the client framework should not be bothered to handle the connection process the connection between scribble and client element is established using a trick.
because gef hides the actual creation of editparts in its framework the client element is not available through the command.
the only way to retrieve a reference of the client editpart is to monitor the editpartregistry during command execution.
a snapshot of the registry is taken before and after the creation command.
the difference between the snapshots resembles the required client editparts.827fig.
.
screenshot of the provided debug perspective c. development support to provide the user with further information about the internal state of the framework we provide the debug perspective shown in fig.
.
the contained views give the user insight and control over the token registry of the currently active editor an interface to select and label strokes without the scribble tool and a comprehensive listing of the latest resultcontributions.
also we included a special view to illustrate various information specific for the n recognizer about a selected scribble.
the developed views are intended to facilitate the process of developing new algorithms and understanding the scribble framework but their use is not mandatory.
vi.
s cribble in action we evaluated the scribble framework by injecting it in editors with different complexity.
the first candidate is the shapes editor which is shipped with the gef examples.
it is a fairly simple editor featuring two types of elements rectangles and ellipses as well as two types of connections solid and dashed.
injecting scribble into standard editors is a two step procedure open the editor in question click on the attach scribble tool button in the toolbar see fig.
a a new tool will be available in the editor s palette providing the scribble features as shown in fig.
b .
afterselecting the scribble tool arbitrary sketches can be added to the diagram.
recognition is performed in the background and transformation into corresponding diagram elements is done automatically if possible.
if the drawn element was not recognized at all or incorrectly recognized it is easy to reassign the correct diagram element.
selecting an element in the diagram dynamically populates an overlay with several edit operations and the possibility for reassigning the correct model element as shown in fig.
c .
the drawn element will now be added to the list of templates used by the recognizers which increases the probability of recognizing the element correctly for any subsequent drawings.
the second tool tested is the logic editor also shipped with the gef examples.
it is able to construct and visualize simple logic circuits.
available creation tools amongst others are circuits leds and several gates.
injecting scribble needs exactly the same steps as described above.
worth to mention are similar looking elements within a diagram editor circuits and leds both have roughly the same rectangular shape which makes it hard for scribble to determine the difference between those two elements while performing the recognition.
therefore the user can specify an arbitrary shape which can be associated with the given diagram element.
we defined simple rectangles to represent circuit elements and rectangles with a contained l to represent leds.
fig.
visualizes this example.
the last and most complex candidate is the class diagram editor of uml lab shown in fig.
.
as in the two828fig.
.
screenshot of uml lab showing scribble in action examples shown above injecting scribble needs just one click.
since class diagrams by definition basically contain simple boxes and lines scribble has to be trained with differently looking shapes for the recognizer to work correctly.
we used a simple rectangle for classes a rectangle containing an i for interfaces and a rectangle containing a d for data types as shown in fig.
d .
this approach is natural for class diagrams since the difference between classes and interfaces is the keyword interface which would also need to be written when using pen and paper.
however there might be cases where additional information has to be specified to solve possible disambiguation between multiple similar looking shapes.
we did not modify any code of the evaluated diagram tools to get scribble working.
while it may not be surprising that our approach performs well for simple diagram editors which where explicitly developed to show any gef specific best practices it is worth mentioning that even complex diagram editors having an unknown internal behavior are supported.
vii.
c onclusions and future work in this paper we presented a first prototype of the scribble framework a generic but also extensible framework which augments any new or existing gef based diagram editor with sketch features.
for standard editors which make use of default gef features like the tool palette the user does not have to write a single line of code to integrate scribble.
this kindof editor type constitutes the majority of diagram editors in the eclipse environment.
if no palette is available and thus scribble cannot analyze possible elements to create an eclipse extension point can be used to tell scribble what elements are available.
we evaluated our framework by augmenting three different diagram editors two relatively simple editors shipped with the gef examples namely the shapes and the logic editor.
to also evaluate the framework in a more complex environment we injected scribble into the uml class diagram editor of uml lab.
no code changes were made to any of the three editors and we only used scribbles generic features to analyze all diagram editors.
while it may not be very surprising that our approach works great for simple editors like the shapes or logic editor it is remarkable that the injected scribble features also work in sophisticated diagram editors like uml lab.
we found the n algorithm for shape recognition performing considerably better than the one based on the levenshtein distance.
one reason is n s flexibility concerning rotation invariance.
another is the freedom in drawing multi stroke shapes in different stroke order.
in most cases we achieved good recognition results with only four to six training templates using the n algorithm.
scribble along with some guidance on how to install and use it can be accessed online1.
however scribble is still in an early stage of development and there still is much to do major issue is the recognition of edges since we can not use standard template based recognition algorithms here.
a single edge type may have an arbitrary shape and the challenge is to find appropriate features along the edges path for identification.
we plan to integrate handwriting recognition.
even if the integrated algorithms for shape recognition would be able to perform basic single letter recognition a sophisticated word recognition engine which supports handwriting is still missing.
for example microsofts ink recognition api could be wrapped into a service and then integrated into our framework.
we plan to integrate automatic label detection if an editor contains elements which can be edited it would be nice to be able to edit these labels by using scribble and handwriting recognition support.
scribble could automatically detect editable labels and provide a special label input field which is triggered by a curved arrow gesture for instance.
connection to the online service to automatically download training data is currently integrated.
we will provide persistence of sketches.
each time the user closes the editor sketched content is lost which might not be desirable.
the reason why no persistence is currently performed is that the process of recreating the connection between a scribbled element and the correct element within the diagram editor is not very clear.
one possible generic solution would be to search for the correct diagram element for each scribble using a location based approach.
if that fails which might be the case if the diagram was modified by some external tool scribble could provide an identifier interface which clients could implement to return a unique identifier for a given scribble.
currently we assume the use of a single touch input device without any pressure information.
using more advanced input devices like multi touch capable smartboards or tablets familiar gestures for moving or magnifying could be used to enhance user experience.
the scribble prototype answers some of the questions listed in section ii especially the technical ones.
it is possible to dynamically inject sketch based input methods into existing graphical diagram editors without the need to write a lot of code.
however further research has to be done to answer the question if common components can be created to be shared with other environments beside eclipse.
a potential candidate would be visual studio although there seems to be no standard diagram creation framework like gef for eclipse.
to address the question if sketch based input techniques are accepted by users of diagram editors a larger end user evaluation is required.
due to the prototype status of the presented approach a comprehensive user study is missing.
we plan to evaluate scribble in one of our lectures namely programming methodologies in the upcoming winter term.
there students get first contact to modeling tools and makeuse of uml class diagram editors.
we would like to evaluate if the use of more natural input methods supported by modern devices as well as the not required switches between different tools of a palette lead to a better user experience.
acknowledgment we would like to thank prof. albert z ndorf for reviewing an early draft of this paper.