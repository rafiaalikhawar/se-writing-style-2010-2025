detecting bad smells in source code using change history information fabio palomba1 gabriele bavota2 massimiliano di penta2 rocco oliveto3 andrea de lucia1 denys poshyvanyk4 1university of salerno fisciano sa italy 2university of sannio benevento italy 3university of molise pesche is italy 4the college of william and mary williamsburg v a usa abstract code smells represent symptoms of poor implementation choices.
previous studies found that these smells make source code more difficult to maintain possibly also increasing its fault proneness.
there are several approaches that identify smells based on code analysis techniques.
however we observe that many code smells are intrinsically characterized by how code elements change over time.
thus relying solely on structural information may not be sufficient to detect all the smells accurately.
we propose an approach to detect five different code smells namely divergent change shotgun surgery parallel inheritance blob and feature envy by exploiting change history information mined from versioning systems.
we applied approach coined as hist historical information for smell detection to eight software projects written in java and wherever possible compared with existing state of the art smell detectors based on source code analysis.
the results indicate that hist s precision ranges between and and its recall ranges between and .
more importantly the results confirm that hist is able to identify code smells that cannot be identified through approaches solely based on code analysis.
index terms code smells change history information.
i. i ntroduction code smells have been defined by fowler as symptoms of poor design and implementation choices.
in some cases such symptoms may originate by activities performed by developers while in a hurry e.g.
implementing urgent patches or simply making suboptimal choices.
in other cases smells come from some recurring poor design solutions also known as anti patterns.
previous studies have found that code smells hinder comprehensibility and possibly increase changeand fault proneness .
in summary these smells need to be carefully detected and monitored and whenever necessary refactoring actions should be planned and performed to deal with them.
there exist a number of approaches that detect smells in source code to alert developers of their presence .
these approaches rely on structural information extracted from source code for example by means of constraints defined on some source code metrics.
for instance according to some existing approaches such as decor longmethod or largeclass smells are based on the size of the source code component in terms of loc whereas other smells like complexclass are based on the mccabe cyclomatic complexity .
other smells such as blob might use more complex rules.although existing approaches demonstrate good performances in terms of precision and recall they still might not be adequate to detect many of the smells described by fowler .
in particular there are some smells that rather than being characterized by source code metrics or other information extracted from a source code snapshot are intrinsically characterized by how source code changes over time .
for example aparallel inheritance means that two or more class hierarchies evolve by adding code to both classes at the same time.
also there are smells that are traditionally detected using structural information where historical information can aid in capturing complementary additional useful properties.
for example a feature envy may manifest itself when a method of a class tends to change more frequently with methods of other classes than with those of the same class.
based on such considerations we propose an approach named as hist historical information for smell de tection to detect source code smells based on change history information extracted from versioning systems and specifically by analyzing co changes occurring between source code artifacts.
specifically hist is able to detect five smells from fowler and brown catalogues.
three of them divergent change shotgun surgery and parallel inheritance are symptoms that can be intrinsically observed from the project s history.
for the remaining two blob andfeature envy there exist static detection approaches .
however as explained for the feature envy those smells can also be characterized and possibly detected using source code change history.
in the past historical information has been used in the context of smell analysis for the purpose of assessing to what extent code smells remained in the system for a substantial amount of time .
however to the best of our knowledge the use of historical information for the detection of smells remains a premiere of this paper.
we have evaluated hist on the change history of eight java projects namely apache ant and tomcat jedit and five different android api projects.
the study aims at evaluating hist performances in terms of precision and recall against a manually produced oracle.
furthermore wherever possible we compared hist with results produced by structural smell detectors such as jdeodorant and our reimplementation of the decor s detection rules.
the results of our study indicate that hist s precision is between978 .
c ieee ase palo alto usa268 versioningsystemversioning system addressinputfine grained changeschange history extractorcode smells detectordeveloper class a class aaffectedcomponents detectionalgorithmfig.
.
hist the proposed code smell detection process.
and and its recall is between and .
when comparing hist to alternative approaches we observe that hist tends to provide better performances especially in terms of recall since it is able to identify smells that other approaches omit because they do not consider historical information.
also for some smells we observe a strong complementarity of the approaches based on code analysis with respect to hist suggesting that even better performances can be achieved by combining these two orthogonal sources of information.
paper organization.
section ii presents the proposed approach hist.
section iii describes the design of the case study aimed at evaluating hist.
the results are reported and discussed in section iv while section v discusses the threats that could affect the validity of our study.
section vi discusses the related literature while section vii summarizes our observations and outlines directions for future work.
ii.
hist h istorical information for smell detection the key idea behind hist is to identify classes affected by code smells via change history information derived from version control systems.
fig.
overviews the main steps of the proposed approach.
first hist extracts information needed to detect the smells from the versioning system through a component called change history extractor .
this information together with a specific detection algorithm for a particular code smell is then provided as an input to the code smell detector for computing the list of code components i.e.
methods classes affected by the characterized code smells.
the code smell detector uses different detection heuristics for identifying target code smells.
in this paper we have instantiated hist for detecting five different smells divergent change this smell occurs when a class is changed in different ways for different reasons.
the example reported by fowler in his book on refactoring helps to understand this smell if you look at a class and say well i will have to change these three methods every time i get a new database i have to change these four methods every time there is a new financial instrument you likely have a situation in which twoclasses are better than one .
thus this type of smell clearly triggers extract class refactoring opportunities1.
shotgun surgery a class is affected by this smell when a change to this class i.e.
to one of its fields methods triggers many little changes to several other classes .
the presence of a shotgun surgery smell can be removed through a move method field refactoring.
parallel inheritance this smell occurs when every time you make a subclass of one class you also have to make a subclass of another .
this could be symptom of something wrong in the class hierarchy that can be corrected by redistributing responsibilities among the classes through different refactoring operations e.g.
extract subclass .
blob a class implementing several responsibilities having a large number of attributes operations and dependencies with data classes .
the obvious way to remove this smell is to use extract class refactoring.
feature envy as defined by fowler this smell occurs when a method is more interested in a class other than the one it is actually in .
for instance there can be a method that frequently invokes accessor methods of another class to use its data.
this smell can be removed viamove method refactoring operations.
our choice of instantiating the proposed approach on these smells is not random but driven by the need to have a benchmark including smells that can be naturally identified using change history information and smells that do not necessarily require this type of information.
the first three code smells namely divergent change shotgun surgery and parallel inheritance are by definition historical smells that is their definition inherently suggests that they can be detected using revision history.
instead the last two code smells blob andfeature envy can be detected solely relying on structural information and several approaches based on static source code analysis have been proposed to detect them .
thus we can compare hist directly to these code analysis based approaches for detecting blob andfeature envy smells to assess to what extent change history data might be of some value in the detection also of these types of smells.
in addition these two code smells are among the most studied smells in the literature .
thus considering smells that can be naturally identified through change history information and smells that can also be identified without using this type of information represent a good benchmark for providing a practical indication on the performances of hist.
the following subsections detail how hist extracts change history information from versioning systems and then uses it for detecting the above smells.
a. change history extraction the first operation performed by the change history extractoris to mine the versioning system log reporting the entire 1further details about refactoring operations existing in literature can be found in the refactoring catalog available at history of the system under analysis.
this can be done for a range of versioning systems such as svn cvs or git.
however the logs extracted through this operation report code changes only at file level of granularity.
such a granularity level is not sufficient to detect most of the code smells defined in literature.
in fact many of them describe method level behavior see for instance feature envy ordivergent change .
to extract fine grained changes the change history extractor includes a code analyzer component that is developed in the context of the markos european project2.
we use this component to capture changes at method level granularity.
in particular for each pair of subsequent source code snapshots extracted from the versioning system the code analyzer i checks out the two snapshots in two separate folders and ii compares the source code of these two snapshots producing the set of changes performed between them.
the set of changes includes i classes added removed moved renamed ii class attributes added removed moved renamed iii methods added removed moved renamed iv changes applied to all the method signatures i.e.
visibility change return type change parameter added parameter removed parameter type change method rename and v changes applied to all the method bodies.
b. code smells detection the set of fine grained changes computed by the change history extractor is provided as an input to the code smell detector that identifies the list of code components if any affected by specific code smells.
while the exploited underlying information is the same for all target code smells i.e.
the change history information hist uses custom detection heuristics for each code smell.
note that since hist relies on the analysis of change history information it is possible that a class method that behaved as affected by a code smell in the past does not exist in the current version of the system e.g.
it has been refactored by the developers .
thus once hist identifies a component that is affected by a code smell hist checks the presence of this component in the current version of the system under analysis before presenting the results to the user.
if the component does not exist anymore hist removes it from the list of components affected by code smells.
in the following we describe the heuristics we devised for detecting the different kinds of smells described above while the process for calibrating the heuristic parameters is described in section iii b. divergent change detection.
given the definition of this smell provided by fowler our conjecture is that classes affected by divergent change present different sets of methods each one containing methods changing together but independently from methods in the other sets .
the code smell detector mines association rules for detecting subsets of methods in the same class that often change together.
association rule discovery is an unsupervised learning technique used for pattern detection highlighting attribute value conditions that occur together in a given dataset .
in our approach the dataset is composed of a sequence of change sets e.g.
methods that have been committed changed together in a version control repository .
an association rule mleft mright between two disjoint method sets implies that if a change occurs in each mi2mleft then another change should happen in each mj2mright within the same change set.
the strength of an association rule is determined by its support and confidence defined as support jmleft mrightj tconfidence jmleft mrightj jmleftj wheretis the total number of change sets extracted from the repository.
in this paper we perform association rule mining using a well known algorithm namely apriori .
note that minimum support andconfidence to consider an association rule as valid can be set in the apriori algorithm.
we empirically calibrated these two parameters in section iii b. once hist detects these change rules between methods of the same class our approach identifies classes affected by divergent change as those containing at least two or more sets of methods with the following characteristics the cardinality of the set is at least all methods in the set change together as detected by the association rules each method in the set does not change with methods in other sets as detected by the association rules.
shotgun surgery detection.
to define the detection strategy for this smell we exploited the following conjecture a class affected by shotgun surgery contains at least one method changing together with several other methods contained in other classes .
also in this case the code smell detector uses association rules for detecting methods in this case methods from different classes often changing together.
hence a class is identified as affected by a shotgun surgery smell if it contains at least one method that changes with methods present in more than different classes.
parallel inheritance detection.
two classes are affected byparallel inheritance smell if every time you make a subclass of one class you also have to make a subclass of the other .
thus the code smell detector identifies the pairs of classes for which the addition of a subclass for one class implies the addition of a subclass for the other class using generated association rules.
these pairs of classes are candidates to be affected by the parallel inheritance smell.
blob detection.
ablob is a class that centralizes most of the system s behavior and has dependencies towards data classes .
thus our conjecture is that despite the kind of change a developer has to perform in a software system if a blob class is present it is very likely that something will need to be changed in it .
given this conjecture blobs are identified as classes modified in any way in more than of commits270table i characteristics of the software systems used in the study .
project period classes kloc apache ant jan jan apache tomcat mar jan jedit sep july andr.
api framework opt telephony aug jan andr.
api frameworks base oct jan andr.
api frameworks support feb nov andr.
api sdk oct jan andr.
api tool base nov jan table ii snapshots considered for the smells detection .
project git snapshot date classes kloc apache ant da641025 jun apache tomcat 398ca7ee jun jedit feb608el aug andr.
api framework opt telephony b3a03455 feb andr.
api frameworks base b4ff35df nov andr.
api frameworks support 0f6f72e1 jun andr.
api sdk 6feca9ac nov andr.
api tool base cfebaa9b dec involving at least another class.
this last condition is used to better reflect the nature of the blob classes that are expected to change despite the type of change being applied i.e.
the set of modified classes .
feature envy detection.
our goal here is to identify methods placed in the wrong class or in other words methods having an envied class which they should be moved in.
thus our conjecture is that a method affected by feature envy changes more often with the envied class than with the class it is actually in .
given this conjecture our approach identifies methods affected by this smell as those involved in commits with methods of another class of the system more than in commits with methods of their class.
iii.
e mpirical study definition and design thegoal of the study is to evaluate hist with the purpose of analyzing its effectiveness in detecting code smells in software systems.
the quality focus is on the detection accuracy and completeness as compared to the approaches based on static code analysis while the perspective is of researchers who want to evaluate the effectiveness of historical information in identifying code smells to build better recommenders for developers.
thecontext of the study consists of eight software projects namely apache ant3 apache tomcat4 jedit5 and five projects belonging to the android apis6.
apache ant is a build tool and library specifically conceived for java applications though it can be used for other purposes .
apache tomcat is a web container allowing the execution of java servlets and java server pages jsp web applications.
jedit is a text editor for programmers that provides syntax highlighting and native support for over file formats.
as for the remaining five software projects they are responsible of implementing parts of the android apis.
for example framework opt telephony apis for developers of android apps allowing them to access services such as texting.
table i reports the characteristics of the analyzed systems namely the software history that we investigated and the size range in terms of kloc and of classes .
a. research questions data analysis and metrics our study aims at addressing the following two research questions rq how does hist perform in detecting code smells?
this research question aims at quantifying the performances of hist in detecting instances of the five smells described in section ii namely divergent change shotgun surgery parallel inheritance blob and feature envy .
rq how does hist compare to the techniques based on static code analysis?
this research question assesses the performances of hist in detecting the five above mentioned smells by comparing it with the performances achieved by applying a more conventional approach based on static source code analysis.
the results of this comparison will provide insights on the usefulness of historical information while detecting code smells.
to answer rq 1we simulated the use of hist in a realusage scenario.
in particular we split the history of eight subject systems in two equal parts and run our tool on the corresponding snapshot.
for instance given the history of apache ant going from january to january we selected a system snapshot from june .
this was done aiming at simulating a developer performing code smell detection on an evolving software system.
in fact considering some early snapshot in the project history there was the risk to perform code smell detection on a very unstable snapshot still presenting ongoing design decisions.
on the other side by considering snapshots occurring later in the project history e.g.
the last available release there was the risk of replicating some unrealistic scenario i.e.
developers putting effort in improving the design of a software system when its development is almost motionless.
in fact as shown in table i for some of the considered software systems change activities have been stopped some time ago see for instance jedit .
the list of selected snapshots is reported in table ii together with their characteristics.
to evaluate the detection performances of hist we need an oracle reporting the instances of code smells in the considered systems snapshots.
unfortunately since there are no annotated sets of such smells available in literature we had to manually build our own oracle.
a master s student from the university of salerno manually identified instances of the five considered smells in each of the systems snapshots.
starting from the definition of the five smells reported in literature the student manually analyzed each snapshot s source code looking for instances of those smells.
clearly for smells having an intrinsic historical nature he analyzed the changes performed by developers on different code components.
a second master s student validated the produced oracle to271verify that all affected code components identified by the first student were correct7.
note that while this does not ensure that the defined oracle is complete i.e.
it includes all affected components in the systems it provides a certain degree of confidence about the correctness of the identified smell instances.
to avoid any bias in the experiment students were not aware of the experimental goals and of the way that hist identifies code smells.
once we defined the oracle and obtained the set of smells detected by hist on each of the systems snapshots we evaluated its performances by using two widely adopted information retrieval ir metrics namely recall and precision recall jcor detj jcorj precision jcor detj jdetj wherecoranddetrepresent the set of true positive smells those manually identified and the set of code smells detected by hist respectively.
as an aggregate indicator of precision and recall we report the f measure defined as the harmonic mean of precision and recall f measure precision recall precision recall to answer rq we executed the smell detection techniques based on static analysis of the source code on the same systems snapshots previously used for hist when addressing rq .
to the best of our knowledge we are not aware of any approaches detecting all the smells that we considered in our study.
for this reason for different code smells we considered different competitive techniques to compare our approach with.
as for the blob we compared hist with decor the detection technique proposed by moha et al.
.
specifically we implemented the detection rules used by decor for the detection of blob .
such rules are available online8.
for the feature envy we considered jdeodorant as a competitive technique which is an eclipse plug in publicly available9.
the approach implemented in jdeodorant analyzes all methods of a given system and forms a set of candidate target classes where a method should be moved in.
this set is obtained by examining the entities i.e.
attributes and methods that a method accesses from the other classes.
concerning the remaining three code smells we are not aware of publicly available tools in literature to detect them.
thus to have a meaningful baseline for hist we implemented three detection algorithms based on static code analysis and or quality metrics.
note that such an analysis was not intended to provide evidence that hist is the best method for detecting considered smells.
instead the goal was to provide some insight into the actual effectiveness of historical information while detecting code smells as compared to information extracted by static analysis of source code.
7only one of the smells identified by the first student was classified as false positive by the second student and classified as such after reaching a consensus.
detect classes affected by divergent change we implemented an algorithm from now on coined as dcca based on the connectivity metric .
connectivity is a class cohesion metric defined in the interval and computed as the number of method pairs in a class sharing an instance variable or having a method call among them divided by the total number of method pairs in the class.
our conjecture is that if a class has low values for the connectivity measure it is likely to contain unrelated subsets of methods that most likely change divergently during the software history.
dcca retrieves those classes affected by divergent change which have connectivity lower than a threshold .
as well as for hist parameters we also empirically calibrated as reported in section iii b. as for the shotgun surgery we analyzed method calls among classes.
the algorithm named as ssca detects all such classes containing at least one method invoking methods of at least external classes.
the conjecture is that if you are changing this method it is likely that you also have to change methods in other classes.
finally we detect classes affected by parallel inheritance as pairs of classes having i both a superclass and or a subclass i.e.
both belonging to a class hierarchy and ii the same prefix in the class name.
this detection algorithm named as pica directly comes from the fowler s definition of parallel inheritance you can recognize this smell because the prefixes of the class names in one hierarchy are the same as the prefixes in another hierarchy.
.
to compare the performances of hist with those of the above mentioned code analysis detection techniques we used recall precision and f measures.
moreover to provide a further comparison of hist with the experimented code analysis techniques we computed the following overlap metrics correct mi mj jcorrect mi correct mjj jcorrect mi correct mjj correct minmj jcorrect mincorrect mjj jcorrect mi correct mjj wherecorrect mirepresents the set of correct code smells detected by method mi correct mi mjmeasures the overlap between the set of true code smells detected by both methodsmiandmj andcorrect minmjmeasures the true smells detected by mionly and missed by mj.
the latter metric provides an indication on how a code smell detection strategy contributes to enriching the set of correct code smells identified by another method.
this information can be used to analyze the complementarity of static code information and historical information when performing code smell detection.
b. parameters calibration while for jdeodorant and decor the parameter tuning has already been empirically assessed by their respective authors to run hist and the three code analysis detection algorithms described above dcca ssca and pica we needed to calibrate their parameters.
we performed this calibration on a software system which was not used in our experimentation i.e.
f measure a f measure b f measure c f measure d fig.
.
parameters calibration for hist blob a hist feature envy b hist divergent change c and hist shotgun surgery d .
.
.
.
.
.
.
.
.
.
f measure a f measure b fig.
.
parameters calibration for dcca a and ssca b .
table iii parameters calibration technique parameter experimented values best value hist assoc.
rules support from .
to .
by steps of .
.
hist assoc.
rules confidence from .
to .
by steps of .
.
hist blob from to by steps of hist feature envy from to by steps of hist divergent change from to by steps of hist shotgun surgery from to by steps of dcca from to by steps of .
.
ssca from to by steps of apache xerces10.
also on this system we manually identified instances of five considered code smells and then evaluated f measure value achieved by the detection approaches using different settings.
table iii reports the values for each parameter that we experimented with and the values that achieved the best results that is the one that we used in answering the research questions .
results of the calibration are reported in fig.
for the hist parameters and and in fig.
for the dcca and the ssca parameters.
as for the confidence and support the calibration was not different from what was done in other work using association rule discovery .
c. replication package all the data used in our study are publicly available11.
in the replication package we provide i links to the git software repositories from which we extracted historical information ii complete information on the change history in all the subject systems iii the oracle used on each system and the code smells identified by hist as well as by the competitive approaches.
iv.
a nalysis of the results this section reports the results of our study with the aim of addressing the research questions formulated in section iii a. note that to avoid redundancies we report the results for both research questions together discussing each smell separately.
table iv reports the results in terms of recall precision and f measure achieved by hist and by the approaches based on static code analysis on the eight subject systems.
as explained in section iii a for divergent change shotgun surgery and parallel inheritance we used alternative code analysis approaches that we developed dcca ssca pica whilst for blob andfeature envy we used decor rules and the jdeodorant tool respectively.
when no instances of a particular code smell were present in the oracle i.e.
zero in the column affected components it was not possible to compute the recall that is division by zero .
in these cases a is indicated in the corresponding code smell row.
similarly when an approach did not retrieve any instances of code components affected by a particular smell it was not possible to compute the precision a n a is included in the code smell row .
for each code smell we also report the results achieved by considering all systems as a single dataset rows overall .
in addition table v reports values concerning overlap and differences between hist and the code analysis techniques column hist ca tech.
reports the percentage of correct code smells identified by both hist and code analysis technique column hist nca tech.
reports the percentage of correct code smells identified by hist but not by the code analysis technique column ca tech.nhist reports the percentage of correct code smells identified by the code analysis technique but not by hist.
in the following we discuss the results for each kind of smell.
divergent change.
we identified instances of divergent change in the five systems.
the results clearly indicate that the use of historical information allows hist to outperform dcca i.e.
the approach based on static code analysis .
specifically the f measure on the overall dataset of hist is of recall and of precision against of recall and of precision achieved by dcca.
this is an273table iv hist performances as compared to the static code analysis techniques tools .
code smell projectaffected hist code analysis techniques components precision recall f measure precision recall f measure divergent changeapache ant apache tomcat jedit android api framework opt telephony android api frameworks base android api frameworks support android api sdk android api tool base overall shotgun surgeryapache ant apache tomcat jedit android api framework opt telephony android api frameworks base android api frameworks support android api sdk android api tool base overall parallel inheritanceapache ant apache tomcat jedit n a n a n a android api framework opt telephony android api frameworks base n a n a n a n a n a n a android api frameworks support android api sdk android api tool base overall blobapache ant apache tomcat jedit android api framework opt telephony android api frameworks base android api frameworks support android api sdk android api tool base overall feature envyapache ant apache tomcat jedit android api framework opt telephony android api frameworks base android api frameworks support android api sdk android api tool base overall expected result since the divergent change is by definition see section ii a historical smell and thus we expected difficulties in capturing this kind of smell by just using source code analysis.
as shown dcca was able to detect only one occurrence of divergent change on jedit missing all other instances.
it is interesting to note how the only smell detected by dcca was not detected by hist.
this smell occurred in the class reof jedit having a low value of cohesion as measured by the connectivity metric used by the static code analysis technique but not enough historical information about divergent changes to be captured by hist.
this clearly highlights the main limitation of hist that requires sufficient amount of historical information to infer useful association rules.
given these observations the overlap between the smells detected by hist and dcca results reported in table v isquite expected among the set of correct smells detected by the two techniques there is no overlap as hist retrieves of the smells while dcca detects the one described above.
shotgun surgery.
shotgun surgery is the code smell with the least number of instances in the subject systems i.e.
with only four systems affected for a total of four instances one per system .
hist was able to detect all the instances of this smell of recall with of precision.
hist outperformed scca i.e.
the detection approach based on code analysis .
specifically scca was not able to detect any of the three instances of this smell present in the subject systems.
thus no meaningful observations can be made in terms of overlap metrics.
objectively this can be due to the limited capabilities of the scca detection technique that we formulated.
however 274table v overlap between hist and code analysis ca techniques .
for blob the ca t ech.isdecor for feature envy is jdeodorant .
code smell hist ca tech.
hist nca tech.
ca tech.
nhist divergent change shotgun surgery parallel inheritance blob feature envy we argue that it is quite difficult to identify characteristics of such a smell solely based on code analysis as the smell is intrinsically defined in terms of a change triggering many other changes .
it is worthwhile to discuss an example ofshotgun surgery we identified in apache tomcat and represented by the method isasync implemented in the class asyncstatemachine .
hist identified association rules between this method and methods in the system belonging to different classes.
this means that whenever theisasync method is modified also these methods generally undergo a change.
parallel inheritance.
among the instances of the parallel inheritance smell hist was able to correctly identify of them recall with a price to pay of false positives resulting in a precision of .
by using the detection rule based on code analysis i.e.
pica we were able to retrieve correct instances of the smell recall of while also retrieving false positives precision of .
it is interesting to analyze the overlap metrics reported in table v. among the set of correct smells identified by the two techniques there is an overlap of while of the correct instances are retrieved only by hist and a remaining is identified only by pica.
this highlights a tangible potential of combining structural and historical information for detecting this type of smell.
we plan to further investigate such a combination as part of our future work.
blob.
as for the detection of blobs hist is able to achieve a precision of and a recall of f measure while decor is able to achieve a precision of and a recall of f measure .
in more details hist achieved better precision values on all the systems on average .
this clearly results in less effort for a developer looking for instances of code smells in a software system due to the lower number of false positives to discard.
also hist ensured a better recall on four out of the seven systems containing at least a blob class and a tie has been reached on android framework base.
on the contrary hist was outperformed by decor on apache tomcat and jedit see table iv .
however on the overall dataset hist was able to correctly identify of the existing blobs against the identified by decor.
thus as also indicated by the f measure value computed over the whole dataset the overall performance of hist is better than that one of decor against .
noticeably the two approaches seem to be highly complementary.
this is highlighted by the overlap results in table v. among the set of code smells correctly identified by the two techniques thereis an overlap of just .
specifically hist is able to detect of smells ignored by decor and the latter retrieves of correct smells not identified by hist.
similarly to the results for the parallel inheritance smell this finding highlights the possibility of building better detection techniques by combining static code analysis and change history information.
an example of blob correctly identified by hist and missed by decor is the class elparser from apache tomcat that underwent changes in out of the commits occurred in the analyzed time period.
elparser is not retrieved by decor because this class has a oneto one relationship with data classes while a one to many relationship is required by the decor detection rule.
instead ablob retrieved by decor and missed by hist is the class standardcontext of tomcat.
while this class exhibits all the structural characteristics of a blob thus allowing decor to detect it it was not involved in any of the commits i.e.
it was just added and never modified hence making the detection impossible for hist.
feature envy.
for the feature envy smell we found instances of this smell in five out of the eight systems for a total of affected methods.
hist was able to identify of them recall of against the identified by jdeodorant recall of .
also the precision ensured by hist is slightly higher than the one achieved by jdeodorant against .
however it is important to remark that jdeodorant is a refactoring tool and as such it identifies feature envy smells in software systems with the sole purpose of suggesting move method refactoring opportunities.
thus the tool reports the presence of feature envy smells only if the move method refactoring is possible by checking some preconditions ensuring that the program behavior does not change after the application of the suggested refactoring .
an example of the considered preconditions is that the envied class does not contain a method having the same signature as the moved method .
to perform a fair comparison especially in terms of recall we filtered the feature envy instances retrieved by our approach by using the same set of preconditions defined by jdeodorant .
this resulted in the removal of three correct instances as well as of three false positives previously retrieved by hist thus decreasing the recall from to and increasing the precision from to .
still hist achieves better recall and precision values with respect to jdeodorant.
it is interesting to observe that the overlap data reported in table v highlights also in this case some complementarity between the historical and static analysis techniques with of correct smell instances identified by both techniques overlap identified only by hist and only by jdeodorant.
an example of correct smell instance identified by hist only is the method buildinputmethodlistlocked implemented in the class inputmethodmanagerservice of the android framework base api.
for this method hist identified windowmanagerservice as the envied275class since there are just three commits in which the method buildinputmethodlistlocked is co changed with methods of its class against the commits in which it is co changed together with methods belonging to the envied class.
instead jdeodorant was the only technique able to correctly identify the feature envy smell present in apache ant and affecting the method isrebuildrequired of class webspheredeploymenttool .
in this case the envied class is project and hist was not able to identify it due to the limited number of observed co changes.
summary for rq .hist provided good performances in detecting all code smells considered in our study f measure between to .
while this result was quite expected on smells which intrinsically require the use of historical information for their detection it is promising to observe that hist provided good performances also when detecting blob andfeature envy smells.
summary for rq .hist was able to outperform static analysis techniques and tools in terms of recall precision and f measure.
while such a result is somewhat expected for intrinsically historical smells divergent change shotgun surgery and parallel inheritance noticeably hist is also able to perform well on other smells blob andfeature envy provided that historical information is available.
last but not least for parallel inheritance blob and feature envy our findings suggest that static code analysis techniques and hist could be nicely complemented to obtain better performances.
v. t hreats to validity threats to construct validity concern relationships between theory and observation.
this threat is generally due to imprecision in the measurements performed in the study.
in the context of our study this is mainly due to how the oracle was built see section iii a .
it is important to remark that in order to mitigate the bias in such a task the people who defined the oracle were not aware of how the hist approach actually worked.
however we cannot exclude that such manual analysis could have missed some smells or else identified some false positives.
another threat is due to the terms of comparison.
while for blob and feature envy we compared hist with existing techniques tools decor and jdeodorant this was not possible for the other smells for which we had to define alternative static detection techniques that may or may not be the most suitable ones among those based solely on structural information.
last but not least note that although we implemented the decor rules ourselves these are precisely defined by the author of such approach12.
threats to internal validity concern factors that could have influenced our results.
in our study this is mainly due to the calibration of the hist parameters as well as of those of the alternative static approaches.
we performed the calibration of such parameters on one project xerces not used in our study computing f measure for different possible values of such parameters see section iii b .
threats to external validity concern the generalization of the results.
hist only deals with five code smells while there might be many more left uncovered .
however as explained in section ii we focused on i three smells divergent change shotgun surgery and parallel inheritance that are clearly related to how source code elements evolve over time rather than to their structural characteristics and ii two smells blob andfeature envy whose characteristics can be captured at least partially by observing source code changes.
however we cannot exclude that there could be other smells that can be modeled similarly.
we conducted the evaluation on eight java projects five of which belong to different android apis while others belonging to different domains.
it could be worthwhile to replicate the evaluation on other projects having different evolution histories or different architectures e.g.
plugin based architecture .
vi.
r elated work all the techniques for detecting code smells in source code have their roots in the definition of code design defects and heuristics for identifying those that are outlined in well known books .
the first by webster describes pitfalls in object oriented oo development going from the management of a project through the implementation choices up to the quality insurance policies.
the second by riel defines more than guidelines to rate the integrity of a software design.
fowler defines code smells together with refactoring operations to remove them from the system.
finally brown et al.
describe anti patterns together with heuristics for detecting them in code.
starting from the information reported in these books several techniques have been proposed to detect design defects in source code.
travassos et al.
define manual inspection rules called reading techniques aimed at identifying design defects that may negatively impact the design of objectoriented systems.
simon et al.
provide a metric based visualization tool able to discover design defects representing refactoring opportunities.
for example to identify blobs each class is analyzed to verify the structural relationships i.e.
method calls and attribute accesses among its methods.
van emden and moonen present jcosmo a code smell browser that detects and visualizes smells in java source code.
they focus their attention on two code smells related to java programming language i.e.
instanceof andtypecast .
marinescu proposes a mechanism called detection strategies for formulating metric based rules that capture deviations from good design principles and heuristics.
such strategies are based on identifying symptoms characterizing smells and metrics to measure such symptoms and then by defining rules based on thresholds on such metrics.
then lanza and marinescu describe how to exploit quality metrics to identify disharmony patterns in code by defining276a set of thresholds based on the measurement of the exploited metrics in real software systems.
also munro presents a metric based detection technique able of identifying instances of two smells namely lazy class and temporary field in source code.
in particular a set of thresholds is applied to the measurement of some structural metrics to identify those smells.
for example to retrieve lazy class three metrics are used number of methods nom loc weight methods per class wmc and coupling between objects cbo .
khomh et al.
propose an approach based on bayesian belief networks to specify and detect smells in programs.
the main novelty of that approach is represented by the fact that it provides a likelihood that a code component is affected by a smell instead of a boolean value like previous techniques.
this is also one of the main characteristics of the approach based on quality metrics and b splines proposed by oliveto et al.
for identifying instances of blobs in source code.
tsantalis et al.
presents jdeodorant a tool for detecting feature envy smells with the aim of suggesting move method refactoring opportunities.
in particular for each method of the system their approach forms a set of candidate target classes where a method should be moved.
this set is obtained by examining the entities i.e.
attributes and methods that a method accesses from the other classes.
moha et al.
introduce decor a method for specifying and detecting code and design smells.
decor uses a domain specific language dsl for specifying smells using high level abstractions.
four design smells are identified by decor namely blob swiss army knife functional decomposition and spaghetti code .
ratiu et al.
describe an approach for detecting smells based on evolutionary information of problematic code components as detected by code analysis over their life time.
the aim is to measure persistence of the problem and related maintenance effort spent on the suspected components.
this is the closest approach to the one defined in this paper since it discusses the role of historical information for smell detection.
however ratiu et al.
do not explicitly use historical information for detecting smells as done by hist but they only perform multiple code analysis measurements of design problems during the history of code components.
historical information have also been used by lozano et al.
to assess the impact of code smells on software maintenance.
all previously discussed approaches exploit information extracted from source code e.g.
quality metrics to detect code smells.
to the best of our knowledge hist the approach described in this paper is the first approach explicitly using change history information extracted from versioning systems for the identification of code smells in source code.
finally it is worthwhile to mention that co change analysis has been used in the past for other purposes for example by ying et al.
zimmermann et al.
gall et al.
and kagdi for identifying logical change couplings and by adams et al.
and canfora et al.
for the identification of crosscutting concerns.
although the underlying technique is similar i.e.
based on the identification of code elementsthat co change for our purpose smell detection appropriate rules are needed and as explained in section ii a finegrained analysis identifying co changes at method level is often required.
vii.
c onclusion and future work this paper described an approach named hist historical information for smell detection for detecting five different code smells by analyzing co changes extracted from versioning systems.
we identified five smells for which historical analysis can be helpful in the detection process divergent change shotgun surgery parallel inheritance blob and feature envy .
for each smell we defined a historical detector using association rule discovery or analyzing the set of classes methods co changed with the suspected smell.
we evaluated hist over a manually built oracle of smells identified in eight java open source projects and compared it with alternative smell detection approaches based solely on static source code analysis where possible for blob and feature envy available in literature i.e.
decor rules and jdeodorant .
the results of our study indicate that the approach exhibits a precision between and and a recall between and .
for intrinsically historical smells such as divergent change shotgun surgery parallel inheritance hist clearly outperforms static code analysis and generally performs as well as code analysis if not better forblob andfeature envy smells.
besides the better performance in terms of precision and recall the hist approach has a further advantage it highlight smells that are subject to frequent changes and therefore be possibly more problematic for the maintainer.
the main limitation of hist is represented by the need for having sufficient history of observable co changes without which the approach falls short.
finally it is important to remark that in most cases the sets of smells detected by hist and by code analysis techniques are quite complementary suggesting that better techniques can be built by combining them.
for the aforementioned reason our future research agenda includes the development of a hybrid smell detection approach combining static code analysis with analysis of co changes.
also we are planning to investigate the applicability of hist to other types of smells.
last but not the least we will further validate hist technique on more software systems.
acknowledgment the authors would like to thank the students defining the oracle used in the hist evaluation.
gabriele bavota and massimiliano di penta are partially funded by the eu fp7 ict project markos contract no.
.
denys poshyvanyk was supported in part by the nsf ccf grant.
any opinions findings and conclusions expressed herein are the authors and do not necessarily reflect those of the sponsors.277references m. fowler refactoring improving the design of existing code .
addison wesley .
m. abbes f. khomh y .
g. gu h neuc and g. antoniol an empirical study of the impact of two antipatterns blob and spaghetti code on program comprehension in 15th european conference on software maintenance and reengineering csmr march oldenburg germany .
ieee computer society pp.
.
f. khomh m. di penta y .
g. gu h neuc and g. antoniol an exploratory study of the impact of antipatterns on class change and fault proneness empirical software engineering vol.
no.
pp.
.
f. khomh m. di penta and y .
g. gu h neuc an exploratory study of the impact of code smells on software change proneness in 16th working conference on reverse engineering wcre october lille france .
ieee computer society pp.
.
n. moha y .
g. gu h neuc l. duchien and a. f. l. meur decor a method for the specification and detection of code and design smells ieee transactions on software engineering vol.
no.
pp.
.
n. tsantalis and a. chatzigeorgiou identification of move method refactoring opportunities ieee transactions on software engineering vol.
no.
pp.
.
r. marinescu detection strategies metrics based rules for detecting design flaws in 20th international conference on software maintenance icsm september chicago il usa .
ieee computer society pp.
.
t. mccabe a complexity measure ieee transactions on software engineering vol.
se no.
pp.
.
w. j. brown r. c. malveau w. h. brown h. w. mccormick iii and t. j. mowbray anti patterns refactoring software architectures and projects in crisis 1sted.
john wiley and sons march .
d. ratiu s. ducasse t. g rba and r. marinescu using history information to improve design flaws detection in 8th european conference on software maintenance and reengineering csmr march tampere finland proceeding .
ieee computer society pp.
.
a. lozano m. wermelinger and b. nuseibeh assessing the impact of bad smells using historical information in ninth international workshop on principles of software evolution in conjunction with the 6th esec fse joint meeting ser.
iwpse .
new york ny usa acm pp.
.
m. fokaefs n. tsantalis e. stroulia and a. chatzigeorgiou jdeodorant identification and application of extract class refactorings in proceedings of the 33rd international conference on software engineering icse waikiki honolulu hi usa may .
acm pp.
.
w. j. brown r. c. malveau w. h. brown h. w. mccormick iii and t. j. mowbray anti patterns refactoring software architectures and projects in crisis 1st ed.
john wiley and sons .
r. agrawal t. imielinski and a. n. swami mining association rules between sets of items in large databases in proceedings of the acm sigmod international conference on management of data pp.
.
t. zimmermann p. weisgerber s. diehl and a. zeller mining version histories to guide software changes in icse proceedings of the26th international conference on software engineering pp.
.
r. baeza yates and b. ribeiro neto modern information retrieval .
addison wesley .
l. c. briand j. w. daly and j. w st a unified framework for cohesion measurement in object orientedsystems empirical software engineering vol.
pp.
july .
g. canfora l. cerulo and m. di penta on the use of line co change for identifying crosscutting concern code in 22nd ieee international conference on software maintenance icsm september philadelphia pennsylvania usa .
ieee computer society pp.
.
a. t. t. ying g. c. murphy r. ng and m. c. chu carroll predicting source code changes by mining change history ieee transactions on software engineering vol.
no.
pp.
.
h. kagdi m. gethers d. poshyvanyk and m. collard blending conceptual and evolutionary couplings to support change impact analysis in source code in reverse engineering wcre 17th working conference on pp.
.
b. f. webster pitfalls of object oriented development 1sted.
m t books february .
a. j. riel object oriented design heuristics .
addison wesley .
g. travassos f. shull m. fredericks and v .
r. basili detecting defects in object oriented designs using reading techniques to increase software quality in proceedings of the 14thconference on objectoriented programming systems languages and applications .
acm press pp.
.
f. simon f. steinbr and c. lewerentz metrics based refactoring in proceedings of 5th european conference on software maintenance and reengineering .
lisbon portugal ieee cs press pp.
.
e. van emden and l. moonen java quality assurance by detecting code smells in proceedings of the 9th working conference on reverse engineering wcre .
ieee cs press oct. .
m. lanza and r. marinescu object oriented metrics in practice using software metrics to characterize evaluate and improve the design of object oriented systems .
springer .
m. j. munro product metrics for automatic identification of bad smell design problems in java source code in proceedings of the 11th international software metrics symposium .
ieee computer society press september .
f. khomh s. vaucher y .
g. gu h neuc and h. sahraoui a bayesian approach for the detection of code and design smells in proceedings of the 9th international conference on quality software .
hong kong china ieee cs press pp.
.
r. oliveto f. khomh g. antoniol and y .
g. gu h neuc numerical signatures of antipatterns an approach based on b splines in proceedings of the 14thconference on software maintenance and reengineering r. capilla r. ferenc and j. c. dueas eds.
ieee computer society press march .
h. gall k. hajek and m. jazayeri detection of logical coupling based on product release history in proceedings of 14th ieee international conference on software maintenance pp.
.
b. adams z. m. jiang and a. e. hassan identifying crosscutting concerns using historical code changes in proceedings of the 32nd acm ieee international conference on software engineering volume icse cape town south africa may .
acm pp.
.