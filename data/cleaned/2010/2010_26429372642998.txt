assertionguidedabstraction acooperativeoptimization fordynamicpartialorderreduction markuskusano e cedepartment virginiatech blacksburg va24061 usa mukusano vt.educhaowang ecedepartment virginiatech blacksburg va24061 usa chaowang vt.edu abstract we propose a new method for reducing the interleavingspace during stateless model checking of multithreaded c c programs.
the problem is challenging because of the exponential growth of possible interleavings between threads.
we have developed a new method called assertion guided abstraction whichleverages both static and dynamic program analyses in a cooperative framework toreducetheinterleavingspace.
unlikeexistingmethods thatconsider all interleavings of all conflicting memory accesses in a program our new method relies on a new notion of predicate dependencebased on which we can soundly abstract the interleaving space to only those conflicting memory accesses that may cause assertionviolationsand ordeadlocks.
ourexperimentalevaluation of assertion guided abstraction on open source benchmarks shows that it is capable of achieving a significant reduction thereby allowing for the verification of programs that were previously too complexforexistingalgorithmstohandle.
categoriesandsubjectdescriptors f. .
specifying and verifying and reasoning about programs d. .
software programverification generalterms algorithm verification reliability keywords statelessmodel checking partialorder reduction predicate dependence assertionguidedabstraction cooperativeanalysis.
.
introduction analyzing the behavior of a multithreaded program remains a difficulttaskdespitethe largebodyof existingworkonbothstatic and dynamic program analysis techniques.
the main reason is that the number of thread interleavings is often exponential in the program size which means that the naive approach of explicitly checking allpossibleinterleavingsispracticallyinfeasible.
dueto this well known interleaving explosion problem existing methods permission to make digital or hard copies of all or part of this work for personal or classroomuse is grantedwithout fee provided thatcopiesare notmade ordistributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than the author s mustbehonored.
abstractingwithcreditispermitted.
tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and orafee.
requestpermissionsfrompermissions acm.org.
ase september15 vasteras sweden.
copyrightisheldbytheowner author s .
publicationrightslicensedtoacm.
acm978 ... .
.
on static analysis often lack accuracyas a result of having to track all possible executions of the program simultaneously.
in contrast dynamicanalysismethodscanbemadesignificantlymore accurate since they only have to focus on a single execution trace atatime.
however withoutaglobalviewoftheprogrambehavior dynamic analysis methods oftenlack foresight.
forexample adynamicanalysismayhavedifficultycomputingevensimplefactsof theprogramsuchascontrolanddatadependencies.
we present in this paper a new cooperative analysis framework for multithreaded programs to allow static and dynamic analysis methods to share information between each other withthe goal of increasing the accuracy and speed of the analysis as compared to usingeachmethodalone.
specifically weshowthatthenewstatic dynamic analysis framework can be leveraged to efficiently check embedded assertions in a multithreaded program.
in this particularapplication thestaticanalysisisacontrolanddatadependency analysis and the dynamic analysis is a stateless model checking procedureaugmentedwithpartialorderreduction.
weshalldemonstrate through experiments that the use of both static and dynamic analysesinourcooperativeframeworkcansignificantlyoutperform eachindividualmethod.
from a static analysis standpoint assertions in a multithreaded programcanbecheckedwithaconcurrentdataflowanalysis.
however carrying out a precise whole program static analysis that is capableofresolvingallembeddedassertionsischallenginginpractice due to complex language constructs such as loops recursive functioncalls andheapallocateddatastructures.
fromadynamic analysis standpoint assertions can be checked byusing a stateless modelchecker thatsystematicallyexecutestheprogramunder all possible thread schedules.
however in the presence of interleaving explosion dynamicanalysisaloneisnotsufficientforsolving the problem.
our new cooperative static dynamic approach in contrast reduces the verification problem into two significantly simplersubproblems firststaticallycomputingtheapproximatedependence between statements and then dynamically pruning away theredundant interleavingsbasedontheprecomputeddependence.
toward this end we introduce the new notion of predicate dependenceoverconcurrent operations.
dependence isalwaysatthe heart of static and dynamic analysis methods for concurrent programs.
forexample dynamic partialorderreduction dpor relies on conflict dependence .
two operations are conflict dependentiftheyarefromdifferentthreads accessthesamememorylocation andatleastoneofthemisawriteoperation.
dporgroups execution traces into various equivalence classes and then picks a representative fromeach equivalence class tocheck.
accordingto the trace theory by mazurkiewicz which is the foundation of partial order reduction methods two traces are equivalent if they can be transformed into each other by repeatedly swapping the adjacent independent transitions.
for example a read of shared variablexinif x and a write in x 1would be considered define num threads define size define max inttable int thread routine int arg inttid int arg intm w h while if m max w m tid else thread exit h w size if h assert while cas table h w h h size intmain for inti i num threads i thread create thread routine i ... figure .
example from sv comp indexersafe where multiple threads share a hash table.
the assertion checks if a thread reads past the array bound.
casis an atomic compareand swapwhichmodifiesthestateofthetableatthepassedindex.
as conflict dependent whereas if x andy 1wouldnot since theyaccessdifferentmemorylocations.
however the definition of conflict dependence is overly restrictiveinmanycasesanddoesnotallowredundantinterleavingstobe prunedaway.
forexample thetwowriteoperationsin x 10and x 10areconflict dependentandyettheirrelativeexecutionorder isimmaterialforpropertyverification.
onecanimagineextending conflict dependence as follows two conflict dependent operations are saidtobe view dependent ifthe twodifferentexecution orders of them lead to different program states.
in other words x andx 10wouldnot be view dependent but x 10andx would be.
however even view dependence would not be able to pruneawaymanyredundant interleavings.
the most general extension along this direction is predicate dependence.
for example assume that the only place where the values writtento xareusedsubsequently intheprogram istocontrol the branching condition in if x .
in this case it is actually immaterialwhetherweexecute x 10beforeorafter x because both and are true.
for the purpose of checkingreachabilityproperties inamultithreadedprogram allwecare aboutiswhethertherelativeexecutionoftwooperationsaffectsthe reachabilityofabadstate e.g.
astatewhereanassertionfails.
consider the example infigure which is a variant of the running example used to illustrate the dpor algorithm in .
the program has a set of threads concurrently accessing data items in a shared hash table.
the assertion in this program checks if the generated hash table key in each thread is out of bounds of the array.
whenthenumberofthreadsisbelow12 allpossibleinterleavingsoftheprogramsbelongtothesameequivalenceclass meaning that only one representative needs to be checked.
however when thenumber ofthreadsreaches orgoesbeyond12 accordingtothe classicpartialorderreductionmethods thenumber ofequivalence classes goes up exponentially which quickly makes existing dynamicanalysismethodsintractable.
figure2shows theperformance ofthedporalgorithmaswell as our new method pred dpor .
the x axis is the number of threads in the test program and the y axis is the execution time.
although dpor performs well when the number of threads is below12 itsuffersfromtheinterleavingexplosionwhenthenumber11 numberofthreadsruntime s dpor pred dpor figure .
comparing baseline dpor with our new pred dpor methodon indexersafe withdifferentnumberofthreads.
of threads is above .
however our observation is that for the purpose of checking assertions in the program there is no need to explore the exponentially many thread interleavings.
since the hashkey h reliesonwandm noneofwhichareinterferedbyother threads the assertion cannot be violated due to thread scheduling.
whereatraditionaldynamic analysis methodwouldhavetocheck all possible thread interleavings of the program withthe help ofa conservative static analysis we can tell after onerun that this programneverviolatestheassertionsduetothreadscheduling.
wehaveimplementedournewmethodsbyleveragingthellvm platform to implement the new static analysis and a modified version ofinspect to implement the new dynamic analysis.
figure shows the overall flow of our method which takes a multithreaded c c program as input and determines if there are assertion violations or deadlocks.
first we parse the input program and instrument it to add logging control capabilities for dynamic analysis.
then we perform a conservative static analysis in subprocedure named dependence calculate to compute the predicate dependencyrelationsbetweenpotentiallyconcurrentoperations.
in the subsequent dynamic analysis which extends the dporalgorithm weleveragetheprecomputeddependency relationstoprune awayredundantthreadinterleavings.
c c programllvm instrumentdependence calculate program inputinst.
binarydependence relations dpor assertionguidedabstraction dpor figure3.
overallflowofournewmethod.
w e have evaluated our new method on a set of open source benchmarks and benchmarks from sv comp .
our experiments show that the cooperative analysis framework can greatly reduce the search efforts by focusing on the subset of the conflictdependent operations that actually affect the validity of the properties at hand.
in fact our results show that when compared to the default dpor algorithm our new method can quickly verify the assertionproperties of manyprograms that were previously intractable.
insummary thispapermakesthefollowingcontributions we introduce the new notion of predicate dependence and propose a new static analysis method for computing the dependence conservatively.
weproposeanewcooperativestatic dynamicanalysisframework that leverages the new dependency relation to reduce theinterleavingspaceatruntime.
we also propose twonew optimizations for the dpor algorithmtofurtherimprovetheperformance.
weimplementthenewmethodsanddemonstratetheireffectivenessthroughexperimentsusingopensourcebenchmarks.
the remainder of this paper is organized as follows.
we will establish notationinsection2before introducing predicate dependence in section .
we will present our new cooperative static dynamic analysis framework in section and the two additional optimizationsfordporinsection5.
ourexperimentalresultswill bepresentedinsection6.
wewillreviewrelatedworkinsection7 andfinally giveourconclusions insection8.
.
preliminaries thissectionprovidesthebackgroundinformationonexistingdynamicanalysismethodsformultithreadedprograms.
.
concurrentsystem a concurrent system is composed of a finite number of threads andafinitesetof communicationobjects .
individually eachthread executesasequence ofoperationsofasequentialprogram.
during dynamicanalysis operationsoncommunicationobjectsareconsideredvisiblewhereas all other operations are considered invisible they are not monitored during the program execution.
we also assume that each visible operation is atomic i.e.
it can be executed on one communication object at a time without interference from the other threads.
an operation is blockingif it cannot currently be executed.
for example a thread waitingfor a mutex locktobe releasedbyanotherthreadissaidtobeblocked.
aglobal state is reached whenever the next operation for each thread is a visible operation.
we assume that there exists at least one visibleoperation for eachthreadandthat there isa unique initialstates0.
atransitionfromonestatetoanotheristheexecution o f a visible operation followed by any finite number of invisible operations by the same thread ending just before another visible operation.
the state space of a concurrent program is simply all the global states reachable from s0and all the transitions between t hese states.
following the notation used by godefroid we combine local invisible operationswiththeprevious visibleoperation into one transition.
therefore the state space is reduced by avoiding unnecessary interleavings of local operations.
from here on wewillusetheterm statetomeanglobalstate.
formally a concurrent system can be modeled as a transition systemag s s0 w heresisthesetofstatesforthesystem s sisthetransitionrelation ands0istheinitialstate.
let tb ethesetofalltransitionsforthesystem and t bethesetofall fi nite words allsequences of transitions that can be created from t. we use st s to mean that executing t tfromsleads to states .
weuse sw s tomeanthatexecutingthefinitesequence o f transitions w t leads from st os .
a state s is said to be r eachablefromsifthereexistssome wsuchthat sw s .
a transition is disabledin the state sif its visible operation is blocking implyingthatthetransitioncannotcurrentlybeexecuted.
ifatransitionisnotdisabled itis enabledins.
twotransitionsare co enabled ifthereexistssomestatewheretheyarebothenabled.
.
statelessmodelchecking the state space of a concurrent system can be fully explored byusinga stateless model checking procedure whichsystematically executes the program under all possible thread schedules.
different from the classic model checkers which are typically stateful here the search is carried out without explicitly storing any system state.
instead a system state is uniquely identified by the sequence of transitions executed starting from the initial state s0.
inother words insteadofexploring thereachable statesof the system the procedure systematically explores the set of executiontraces.
when dealing with full fledged programming languages such as c c java where the system state consists of values for all memory locations that can be accessed by a thread stateless modelcheckingisafarmorepracticalmethod.
toexhaustivelyexploretheinterleavingspace wemustcheckat least one representative thread interleaving from each equivalence classofinterleavings alsocalledthemazurkiewicztrace .
this canberegardedasthetheoreticalfoundationofpartial orderreduction por .
more formally mazurkiewicz traces in the context of concurrent systems are defined as equivalence classes of sequences of transitions.
let d t t be a valid dependency relation between transitions.
two sequences of transitions over t are equivalent if the two traces can be obtained from each other bysuccessivelyexchanging adjacentindependent transitions.
consider two transitions tandt .
ifta nd t are independent then the s equencescontaining tt andt t respectively areinthesameequivalence class.
thisimpliesthat theconcurrent program willendup inthesamestateregardlessoftheexecutionorderof tandt .
c omputing the equivalence classes rests on the concept of a dependency relation.
in classic por methods such as dpor the dependency relationistypicallydefinedwithrespecttotheconcurrentsystemitself withoutconsideringthepropertiestobechecked.
godefroid formalizes the general requirement for a relation overconcurrentoperationstobeadependency relationasfollows definition .
lettbethesetoftransitionsand d t t be abinary reflexive andsymmetricrelation.
disavaliddependency relationforthesystemiffforall t1t2 t t1 t2 ne ationslash d t1andt2 areindependent impliesthatthetwofollowingpropertiesh oldfor allstatessinthestatespace agofthesystem .
ift1isenabledin sa ndst1 s thent2isenabledin si fft2 is enabled in s independent transitions can neither disable n orenableeachother and .
ift1andt2are enabled in ss uch thatst1t2 s andst2t1 s thens mustbethesameas s commutativityofenabled i ndependent transitions .
a stricter definition of the dependency relation would result in fewer equivalence classes which in turn corresponds to fewer executions to be explored.
however accurately computing the dependencecanbedifficult thedporalgorithmuses conflict dependencemainlybecauseitiseasytocompute.
a subset tof the transitions enabled at a state sis said to be persistent insif each transition not in tdoes not interact with t. it has been proved that exploring only transitions in the persistentsetofeachstateguaranteesdetectionofalldeadlockand assertionviolations.
belowisaformaldefinitionofpersistentsets.
definition .
asettoftransitionsenabledinastate sispersistentinsiffforallnonemptysequencesoftransitions s s1t1 s2t2 s3...tn sntn sn fromsi n agandincludingonlytransitions ti ne ationslash t i n tn isindependent withalltransitionsint.
.
dynamicpartialorderreduction early partial order reduction algorithms such as in staticallycomputedthepersistentset butlimitationssuchasimprecise pointer alias information often caused the persistent set to overapproximate dependence of transitions causing equivalent traces tobeexplored.
dynamicpartialorderreduction addressedthis issue by focusing on one execution trace at a time where precise aliasinformationcanbeobtained andbycomputingthenecessary transitionstoexploredynamicallyusing backtrack sets .
177algorithm1showsthepseudocodeofthedporalgorithm.
the algorithm performs a depth first search through the state space of agstarting with the initial state s0.
the stack represents a finite t ransition sequence s t t1t2...tn from the states s1...sn such that s1t1 s2t2 ...tn sn .
here d om s means the set ... n pre s i fori dom s refers to the state si l ast s refers tosn n ext s p is the unique transition to be executed by process pin states andproc t is the thread that executedthetransition t. ahappens before relationonasequence s i sp fori dom s and process pis a relationindicating causalitybetweenthetransitionexecutedat iandp.
each state shas a backtrack set denoted backtrack s .
the backtrack set of a state srepresents the set of processes at swith enabledtransitionsthatstillneedtobeexploredfrom s. thedporalgorithmstartsbycalling explore withanempty stack.
the stackrepresents the set of transitions executed toreach last s line .
line 4examines the next transitionof each process from s next s p .
the algorithm then examines sto find thelasttransition ifitexists thatis .
dependent with next s p .
maybeco enabledwith next s p and .i ne ationslash sp.
s tep uses the conflict dependency relation.
upon finding a conflicting transition iins a backtrack point is inserted in the state pre s i .
which process to add into the backtrack set is determined on line .
here the algorithm attempts to find the set e ofenabledprocessesin pre s i thathappen before next s p in thecurrentsequence.
thehappens before relationsignifiescausality executing a transition of a process in ewill cause the transitionnext s p to be executed.
if such a causality relationship is not found eis empty then the algorithm over approximates by addingalltheenabledtransitionsin pre s i tothebacktrackset.
overall thegoaloflines5 10istofirstidentifytwodependent transitionsinthecurrentsequenceandtheninsertabacktrackpoint to potentially reverse the order of execution of the dependent transitions in a future execution.
the algorithm on lines through continuesthedepth firstsearchbyexploringeachnon explored transition from a state s backtrack set.
the authors of proved that the backtrack sets explore a set of transitions from each state swhichispersistent in s. asaresult theyareabletoleverage the theoremsfrom toensurethatdporwillfindalldeadlockand assertionviolationsinanacyclicconcurrentprogram.
however neitherdpornoranyotherexistingpormethodconsidered the properties to be checked while computing the dependency relation.
we shall show in the next section that by taking the properties into consideration we can often obtain a more refineddependencyrelation whichleadstoadrasticreductioninthe numberofequivalence classes.
.
assertionguidedabstraction inthis section we introduce the new notion of predicate dependenceto soundly reduce the number of thread interleavings.
we refertothismethodas assertion guided abstraction .
.
predicatedependencyrelation we modify the general requirement for a relation over concurrent operations to be a valid dependency relation by considering the influence on the outcome of assertion checking.
the new requirement ascomparedtodefinition1 isgivenasfollows definition .
lettbethesetoftransitionsand d t t be abinary reflexive andsymmetricrelation.
disavaliddependency relationforthesystemiffforall t1t2 t t1 t2 ne ationslash d t1andt2 areindependent impliesthatthetwofollowingpropertiesh oldfor allstatessinthestatespace agofthesystem if cond x x x y x figure4.
examplesforcontrol left anddatadependency right .
.
ift1isenabledin sa ndst1 s thent2isenabledin si fft2 is enabled in s independent transitions can neither disable n orenableeachother and .
ift1andt2are enabled in ss uch thatst1t2 s andst2t1 s thens canleadtoabadstateiff s canleadtothesame b ad state commutativity of enabled independent transitions ispredicatedonpropertychecking .
inotherwords twotransitions t1andt2arep redicate dependent if and only if the relative execution order of t1andt2can affect w hetheranerrorstateisreachedornot.
otherwise theyareconsideredtobe predicate independent .
anerrorstateisanystatewhere apropertyisviolated.
wefocusontwotypeoferrorsinthiswork assertionviolationsanddeadlocks.
definition induces an abstraction of the system s interleaving spacetoignoreoperationsthatareconflict dependentandyetunrelatedtothevalidityoftheproperties.
alternatively theabstraction is transforming the original program into a simpler program containingonly those program statements thatcan cause anerror.
we calltheseprogramstatements essential statements .
inthenextsubsection weexplainthatbyusingpredicatedependencetoreplaceconflictdependenceindporwecanobtainanew dynamicanalysismethodthatismoreefficientandatthesametime guarantees that no error states are missed.
here the error state is a state where the assertion fails or a deadlock occurs.
the essential statements are all the statements whichcould affect assert and lock unlock calls.
throughout this section we shall focus our discussion on dealing with a single assertion statement.
the case for multipleassertionsand orlockcallswillbesimilar.
.
correctnessofthereduction first weintroducetheconceptofcontrolanddatadependencies.
figure left shows an example of the control dependency.
the statement on line determines if the statement on line is executed.
in other words line is control dependent on line .
in general a statement bis said to be control dependent on another statement aif and only if there exists a path from atobsuch that every statement c ne ationslash ainthe path is post dominated by bandais notpost dominatedby b. figure right shows an example of a data dependency.
the value ofyon line is dependent on the value of xon line .
a statement ais said to be data dependent on another statement bif and only if both statements access the same memory location and at least one of them stores into it and there is a feasible run time executionpathfrom atob.
furthermore the order in which statements are executed determines their dependency relation.
for example line of figure right isdata dependent online 2but notline .
thisisbecause the write online 2to xoverwrites the writeon line1.
the same idea applies if all three lines of figure right were executed by three different threads.
line would be dependent on either line or line depending on the thread scheduling.
we will use this conceptofchangesindependencies toproveourmethodissound.
to prove that predicate dependence based reduction is correct weusetheorem2.2from asalemma whichstates lemma1.anyreordering transformationthatpreservesevery dependence inaprogram preserves themeaning ofthat program.
178algorithm1 classicdynamicpartialorderreductionalgorithm.
initially explore procedure explore s s last s forallprocesses pdo if i max i dom s siisdependent andmaybeco enabledwith n ext s p andi e atio slash sp then e q enabled pre s i q p j dom s j i q proc sj j sp ife e atio slash then addany q etobacktrack pre s i else addallq enabled pre s i tobacktrack pre s i endif endif endfor if p enabled s then backtrack s p done while p backtrack s done do addptodone explore s.next s p endwhile endif endprocedure the proof for lemma in was based on the fact that a singlestatement will produce a different result if and only if its dependencies change.
thus if every statement has its dependencies preserved theprogramwillnotproduceadifferentresult.
definitions such as conflict dependence use lemma to test all possible outcomes of the program caused by concurrent nondeterminism.
each reordering performed by conflict dependence is a change in the dependencies of the program.
however this is oftenunnecessarilystrong.
wearenotinterestedinhowreordering affectstheentireprogrambutonlyessentialstatements.
wepresent thisideainthefollowingcorollary corollary .any reordering transformation that preserves every dependence of astatement willnot affect the outcome of that statement.
using corollary we can prove that using predicate dependence in dpor to replace the conflict dependence will result in a sound reduction whichisstatedformallyasfollows theorem .predicate dependence as defined indefinition3 willnot cause any error state tobe missed.
proof.
first two transitions t1andt2 affect the reachability o f an error state only if they are control or data dependent with theessentialstatements e.g.
assertions lock unlockcalls .
ifthey areneithercontrolnordatadependentwithanyessentialstatement thenbasedonthedefinitionsofcontrol datadependenceandessentialstatements theycannotaffectthereachabilityoftheerrorstate.
now we prove the theorem by contradiction.
assume that t1 andt2are not predicate dependent but one of their two execution o rderscanresultinanerrorstate serrbeingmissed.
s ince one of the two execution orders leads to serrbeing m issed by corollary this means that the order of t1and t2does not preserve the dependencies of the essential statem ents.
however ifthe dependencies of the essential statements are not preserved thenby definition t1andt2are predicate dep endent whichcontradictsourassumption thattheyarenot predicatedependent .
therefore ourassumptionisnotcorrect thetheoremisproved.however there is difficulty inusing theorem during a purely dynamicanalysis becausecheckingwhether t1andt2arecontrol d ata dependent atruntimeis notaneasytask.
although intheory we could have pre computed the control data dependency relation between all pairs of potentially concurrent operations in a purely static manner before starting the dynamic analysis it would be computationallyexpensive andatthesametime difficulttoobtain accurate results due to the limitations in a static inter procedural inter thread dependency analysis.
instead we propose a new cooperative static dynamic framework.
theideaistoget thebestof bothworlds sincestaticanalysisisabletogetanapproximationof theentireprogram whiledynamic analysis isable toprovideinformationonaliasingandfeasibleexecutions.
.
thecooperativeanalysis inthissection weprovideanoverviewofournewmethodshown in algorithm .
the input is the program under test p together with data input i .
subprocedure instrument adds monitoring and controlcapabilitiestotheprogramtoprepare itfordynamic analysis.
subprocedure ifconvertconvertsallassertionstatementsofthe formassert c intoif !c error .
subprocedure dependencecalculate analyzes the program and returns the dependency relationships.
subprocedure execrunstheprogram under testwith our scheduler.
subprocedure exploretakes the dependency relationsandperformsanexplorationoftheinterleavingspace.
algorithm2 highleveloverviewofournewanalysismethod.
p programundertest i programinputs p instrument p p ifconvert p dep dependencecalculate p exec p i explore dep algorithm4 the bulk of the static analysis takes place in dependencecalculate.
this procedure collects all the interprocedural control and data dependencies of each statement of interest e.g.
assert lock unlockcalls whileignoringaliasing.
wewillexplainhowwedeal withaliasing insubsection .
.
the process of collecting interpro179cedural control and data dependencies is the generation of the interprocedural slice of each statement.
wewill explainour method for computing the interprocedural slice in subsection .
.
for a more comprehensive description of existing methods for creating theinterproceduralslice pleasereferto and .
.
controlanddatadependencyanalysis in our cooperative framework we divide our approach to interthreadcontrolanddatadependencyanalysisintothreesteps .
intraproceduralcontrolanddatadependency computations .
interproceduralcontrolanddatadependency computations .
inter threadaliascomputations.
steps and are purely static and they are carried out only once beforethedynamicanalysisprocedurestarts whereasstep3isdynamic the alias information is updated incrementally while the dporalgorithmisrunning.
thestaticanalysismethods usedinthisapplicationarerequired to be over approximated.
that is as long as the execution order oftwoconcurrent operations t1andt2maya ffecttheproperty the staticanalysismethodmustensurethat t1andt2aredependent.
o urmethodusesanintermediateprogramrepresentationknown as theprogram dependence graph pdg .
for a given procedure a pdg explicitly provides both the control and data dependencies.
the transitive closure of control dependences is the control dependence graph a node in the control dependence graph is a statement and an edge from node xto nodeyindicates that yis control dependent on x. the data dependence graph can be created similarly.
whencombined for a single procedure the control and data dependence graphs are the twosubgraphs of the program dependence graph .
thesystemdependence graph isaninterproceduralversion of the program dependence graph.
it consists of the program dependence graphs for each procedure as wellas additional edges to include direct dependencies between call siteand calledprocedure and transitive dependencies due to calls.
as an example consider the program in figure top and its system dependence graph bottom .
controldependencies betweenstatements arerepresented as edges witha diamond head edges withan arrow head are data dependencies and dashed edges are dependencies due to functioncallsandparameterpassing.
theparameterinputsoffunction addarerepresentedinthenodes ainandbinand the output inthe node aout.
to handle parameter p assing twoadditional nodes in mainare added ain s umand bin i and connected to the addprocedure.
these extra nodes can be thought of as stack frames to handle pass by value semantics.
theprogramdependencegraphof mainandaddarethenodes reachablefromthenodes entermain andenteraddexcludingfunctioncallsandparameterpassing dashededges .
for a given node s statement inthe system dependence graph an interprocedural sliceis the graph containing all nodes that can reachs.
theusefulnessofasliceon sisthatitcontains allpossible statementsthatcouldinfluence s corollary1 .
.
computingaliasinformationonthefly forlanguagessuchasc c aliasingbecomesanissueforcreating slices.
consider a slice son program statement signoring aliasing.scontainsonlythestatementswhichcoulddirectlyaffect either the execution of s control dependencies or the value used bys datadependencies .
inthepresence ofaliasing salsoneeds tocontainanyotherstatement intheprogram whichcould aliasto anystatementalreadyin s. theseareadditionaldatadependencies causedbyaliasing.
together theyrepresentthecomplete setofall statementsthatcouldinfluence s. to see the effects of aliasing consider the example program in figure .
a thread is accessing the first six elements of a shared arrayof12elements.
similarly maintakesanindexasinputfrom1intadd inta b 2returna b 4intmain 5intsum i 6sum add sum i 7if sum!
assert sum i sum add out assert ain sum bin i if sum ne ationslash addout a ba ain b bin figure5.
aprogram top anditssystemdependence graph bottom .
diamondheadededgesarecontroldependencieswhilearrow headed edges are data dependencies.
dashed lines represent functioncallsandparameterpassing.
1intarray 2voidthread1 3for inti i i array array 7intmain intargc char argv 8intidx atoi argv 9thread create thread1 array array figure6.
aexampleprogramshowingtheeffectsofaliasing.
the user line and increments the array at that index.
aliasing couldoccurbetweenthetwoaccessestothearray lines4and10 .
the situation is complicated because the array index accessed by mainis based on user input a conservative static analysis would assume that the user could pass anything.
thus the statements on line4and10wouldalways alias.
wewillshow inthissubsection howourcooperativestatic dynamicapproachavoidsthisproblem.
the program representation shared between the static and dynamic analysis frameworks are program statement ids.
specifically each statement in a program is given a unique integer id.
intuitively this provides a method of communication between the twoframeworks.
inourcooperative analysismethod theoutputof the static analysis is a set of program statement ids representing the slice on each erroneous statement ignoring aliasing.
the goal ofourdynamic analysisistoextendthesliceswithinter threaddependency information.
dynamic partial order reduction dpor fitsthistaskperfectly thegoalofdporistodynamicallyenumerateallrelevanttracesofaconcurrentprogram.
thestatic analysis ismade simpler since itnolonger has toreason about complex thread interactions such as mutex locks or inter thread aliasing.
also the issue of calculating dependencies becomes not only simple for a dynamic analysis but it is also accurate itisguaranteedthatanypossibledependencies observedby the dynamic analysis are ones which could possibly occur in the program therearenofalsepositives .
dporgenerates a set of sequences of program transitions each corresponding to an execution of the program.
the entire set of sequences producedbydporcontainsatleastonesequencefrom each equivalence class.
the transitions are dynamic instances of eachprogramstatement.
duetotheirdynamicnature thesequences of transitions contain the memory address used in every memory 1801inta 2voidthread1 void 3a 5voidthread2 void 6a 7if a !
assert figure7.
exampletoshowstatic dynamicslicecreation.
readandwrite inthecontext ofstaticanalysis thismeansthatwe havecompletealiasinformationfortheentiresequence.
algorithm3showsthepseudocodefor updateslice whichtakes asinputatransitionsequence generatedfromdporandasetof statements on a slice sli.
it updates slito contain the inter thread dependencies observed in .
the for loop on lines checks eachpairoftransitionsaccessingthesameobjectin toseeifthey should be added to the slice.
we use obj t to represent the object accessedby t sli.contains t toreturntrueifthestatementexecuted by transition tis on the slice and sli.insert t inserts the statement executedby ttotheslice.
notethat denotesxor.
statementsshouldbeaddedtothesliceifoneofthestatementsis alreadyonthesliceandtheyareaccessingthesameobject.
thisis thesituationwhenastatementontheslicealiasestoonenotonthe slice.
theentireprocedure isafixpointcomputationuntiltheslice is no longer updated.
the fixpoint isrequired because whenever a transition tis added to the slice all the statements not on the slice whicharedependent with talsoneedtobeadded.
algorithm3 proceduretoupdatetheslice sliwiththedependence informationobservedinthesequenceoftransitions .
procedure updateslice sli sliceupdated true whilesliceupdated do sliceupdated false forallt1 t2 s uchthat obj t1 o bj t2 d o ifsli.contains t1 s li.contains t2 t hen sliceupdated true sli.insert t1 sli.insert t2 endif endfor endwhile endprocedure thecombinationofdynamicallycalculatedinter threadaliasing usingupdateslice and statically calculated control and data dependenciescompletestheslicingalgorithm.
inthenextsection we show how this algorithm is combined with dpor to implement predicate dependence.
note that intra thread aliasing is handled staticallyduringthecontrolanddatadependencyphase.
example.
consider the multithreaded program in figure where two threads access a shared variable a. assume that the line number of each statement represents the statement id.
first we generate the slice on the assertion ignoring aliasing.
the slice contains lines8 theassertionitself acontroldependency and6 adata dependency .
notice that the sliceis missinga crucialcomponent thealiasedwriteto abythefirstthreadonline3.
dporgenerates threesequences oftransitionsforthisexample.
theyare s1 s2 8a nds3 .
next we runupdateslice oneachsequence theresultsaresummarizedfor s1in table .
the table shows how the slice is updated for each p airexaminedin s1 i.e.
thetableisthefirstiterationofthewhile sequence pair slice sliceupdated?
initially s1 true s1 true s1 true table1.
exampleofrunning updateslice algorithm3 onasequenceoftransitionsgeneratedbydporfromtheprograminfigure .
theprocedure continues torunontheremaining sequences butnomodificationsaremadetotheslice loop in algorithm .
column is the value of sliceupdated in the fixpoint computation for s1.
while examining s1 the slice is u pdated column4staystrueuntilafterthefirstiterationofthefixpointcomputation.
duringthenextiterationon s1 noupdatesare m ade to the slice.
examining the remaining two sequences shows thatthefinalslicecontains theupdateto abythread 1isnowincluded.
.
dporbasedonpredicatedependence now we explain how dpor algorithm can be modified to includepredicatedependence.
theonlyadditionalinputisasetof program statements onthe slice ignoring aliasing of everyessentialstatement.
weincorporatethe updateslice algorithmtodynamicallycalculatealiasingfromtheprevioussubsection.
the major change to algorithm is that backtrack set is computed at the end of each execution.
this is required because we need to examine the entire sequence of transitions of anexecution inordertodynamicallyupdatethestatementscontainedintheslice.
algorithm introduces an additional notation to describe a sequence of transitions sand a state s. here predom s s is the setfrom ... n wherenisthenumber oftransitionsthathave occurred before the state s. this the same as dom s ifsonly containedthesequences oftransitionsleadingupto s. lines implement updating the backtrack set similar to lines3 11inalgorithm1 aftertheentireexecutioniscompleted.
line is the fixpoint computation algorithm to dynamically expand the slice to include alias information from the current sequence.
the dependency relation line is from definition .
other than these modifications algorithm is the same as algorithm1.
.
optimizingpredicateddpor in this section we introduce two new optimizations in dpor.
one optimization called critical section peeking is applicable to all properties whereas the other optimization called write write pruning isapplicabletocheckingassertions.
.
criticalsectionpeeking definitionssuchaspredicatedependenceandconflictdependence consider mutex lock calls to be dependent if they are locking the same mutex and never consider the items in the critical section of the mutex.
however they can be unnecessarily inefficient in manycases.
asmotivation considertheprograminfigure8.
two threadsareincrementingvaluesinanarrayof16integers.
thread1 isincrementingitems0 7andthread2isincrementingitems8 .
astandarddporimplementationrequires12 870runstotestthis program even though the two threads will never access the same memory location.
in contrast our new automated optimizations canreducethetheexplorationdowntoonerun.
we define critical section peeking as follows.
let m1andm2 be two mutex lock calls and c s1andc s 2be the statements in the c riticalsectionsprotectedby m1andm2 respectively.
twomutex l ockcallsaredependent iffcondition1istrueandeithercondition 2orcondition3istrue .
thetwolockcallsaretothesamemutex 181algorithm4 predicateddynamicpartialorderreductionalgorithm.
slices sliceofeveryessential statement ignoring aliasing initially explore slices procedure explore s slices s last s if p enabled s then backtrack s p done while p backtrack s done do addptodone explore s.next s p slices endwhile endif updateslice s slices algorithm3 forallstates s insd o forallprocessespdo if i max i predom s s siispredicatedependent andmaybeco enabledwith n ext sp andi e atio slash sp then e q enabled pre s i q p j predom s s j i q proc sj j sp ife e atio slash then addany q etobacktrack pre s i else addallq enabled pre s i tobacktrack pre s i endif endif endfor endfor endprocedure mutex array lock intarray voidthread 1 for inti i i lock array lock array array unlock array lock voidthread 2 for inti i i lock array lock array array unlock array lock figure .
a motivating example for critical section peeking.
a single mutex protects an entire array.
this causes a dpor algorithmtotestallorderings of arrayaccesses even iftwothreads are accessingdifferentitemsofthearray.
.
s cs1 c s2 si snotamemoryaccessingtransition .
s1 c s1 s2 c s2 s1isdependentwith s2 in dpor when two mutex lock calls are reordered the effect iveresultisthat allofthetransitionsinthecriticalsectionsarereordered.
in essence critical section peeking only reorders critical sectionswhenitisnecessary.
item2preventsdeadlocksfrombeing missed twocriticalsectionscontainingadditionalmutexlockcalls could when called in a certain order result in a deadlock even if they are not dependent on each other.
item results in the significant reduction for programs such as in figure the mutexes only need to reordered if they are protecting memory accesses which could interfere with each other.
when using critical section peeking noneofthemutexlockcallsinfigure8willbedependent this results in only onerun of dpor to be required.
critical section peeking is implemented dynamically by examining the statements inthecriticalsectionoftwolockcallstothesamemutexusingthe dependence rulesdefinedpreviously.
.
write writepruning there are three combinations of shared memory access events betweentwothreads read read read write andwrite write.
two read accesses even from two different threads can never affect eachother regardless of theirorder of execution.
thus inthis section we focus on read write and write write and show how supplementalinformationcangeneratefewermazurkiewicztraces.
inta voidt1 main a a voidt2 main a a intmain intargc char argv thread create t1 main thread create t2 main thread join t1 main thread join t2 main assert a !
return0 figure9.
aread write write conflictbetweenthreethreads.
we divide write write conflicts into two new categories write writeandread write write conflicts.
theorem .if two writes to the same shared variable x by differentthreads t1andt2 are adjacentinatrace thenregardless o f the order of the writes to xbyt1andt2 no assertion violations l ocal tot1andt2willbe missed.
t hekeyrestrictiontotheorem2isthatassertionsinsidethetwo threadsareneverviolated.
theremaybeassertionsinotherthreads thatcouldbeviolatedduetotheorderofwritesbythetwothreads.
this can be thought of as a read write write dependency the 182order of two writes affects the value read by another thread.
in dpor thiscanonlyhappenwhenthereisathirdthread t3 which r eadsthesamelocationinmemoryasiswrittentoby t1andt2 and t3may not be co enabled with t1andt2while they are writing to x. weformalizethisconceptinthefollowingtheorem.
theorem .if two different threads t1andt2 are executing a sequence of operations s1ands2respectively both including s omenumberofwritestothesamesharedmemorylocation x then the order of execution of t1andt2writing to xw ill only affect assertion violations if bothof the following hold .
there exists a shared memory read of xby a distinct third threadt3which cannot be co enabled with either t1ort2 durings1ors2 .
thewriteto xins1byt1isthelastwriteto xb yt1beforet3 is enabled and .
thewriteto xins2byt2isthelastwriteto xb yt2beforet3 is enabled.
t he case when t3can be co enabled during either s1ors2 vio lating condition one of theorem changes the problem from a read write write conflict to simply a read write conflict.
consider the example of a write write conflict between two threads and a single assertion check in figure .
furthermore maincreates and joins the two threads.
the key insight is that maincan never be co enabled with any of the writes.
this situation is captured by theorem the read by mainwill only be able to read the last value writtenby each thread either 6or .
dpor would require6runsbutinrealityonly2runsarenecessary.
.
experimentalresults we have implemented our new method in a tool called k se based on the llvm platform for static analysis and code instrumentation and on a modified version of inspect for systematic exploration of a concurrent program.
our tool runs both with andwithouttheproposedoptimizationsandcanhandleunmodified c c codeusingpthreads.
weusethedporimplementationin inspectasabaselineforcomparison.
ourexperimentsweredesignedtoanswerthefollowingresearch questions how effective is our new method?
in practice is it able to show significant improvement over dpor?
how scalableisournewmethod?
canithandlerealisticprograms?
we evaluated our tool on 46benchmarks from twogroups.
the first group are a set of small programs from the software verification competition sv comp as well as two of our own synthetic examples.
the second group is a set of real world open sourceprograms nbds isacimplementationofseveralnonblocking data structures.
nedmalloc is a thread caching mallocimplementation.
pfscanisaparalleldirectoryfilescanner.
whenpossible weusedtestsandinputsprovidedbytheauthors.
figures and summarize the results of all our tests.
the graphsshowacomparisonofourmethodsversusdporintermsof numberofrunsandruntimerequiredtotestaprogramrespectively.
figure shows that our method is always capable of testing a program in the same number of runs as dpor and in some cases canoffer significantreduction.
figure 11shows similarresultsfor theruntime.
inmostcases ourtoolincursaminimaloverheadand canresultsinsignificantreductioninruntime.
thecaseswherethe runtimewassignificantlyhigheroccurredwhenareductioninruns occurredbutthestaticanalysistooklongerthanthesavingincurred duringdynamicanalysis.
table2showsthe statisticsfromtestswhere areductioninruns occurred.
column 1shows the name of each benchmark.
column shows the number of lines of code in the benchmark.
column showsthenumberofassertionsinthebenchmark.
column4shows the maximum number of threads in the benchmark.
columns dporpred dpor figure .
results comparing the number of runs of predicated dporandbaselinedporon46benchmarkexamples.
dporpred dpor figure .
results comparing the execution time of predicated dporandbaselinedporon46benchmarkexamples.
show the time required to test the program for dpor predicate dependence andpredicate dependence withoptimizations respectively.
similarly columns show the number of runs for each method.
weallottedamaximumoftwohoursforeachtest an in columns indicates that the method exceeded two hours.
all testswererunonamachinewitha2.60ghzintelcorei5 3230m processorwith8gbramanda64 bitlinuxos.
first the results show that our method is more efficient than dpor.onthefirstsetofbenchmarks bothdporandourmethod can complete and the difference in runtime is small.
however on largeprograms suchas nbds pfscanandnedmalloc dpor couldnotfinishwhereasourmethodwasabletofinishinareasonableamountoftime.
forsomeexperiments ournewoptimizations wererequiredtohavegoodperformance sincetheprograms make heavyuseofmutexes.
second as a measure of the scalability of our method we conductedtestsontwoparameterizedprograms indexersafe and nbds hashtable .indexersafe isanimplementationoffigure1.
wevariedthenumberofthreadsfrom11to15 theresultsare summarized in figure .
the number of runs required for dpor grows exponentially with the number of threads while optimized predicate dependence stays at a constant one run.
critical section peeking was required for this benchmark since the compare andswap operations were implemented using mutex locks.
the programnbds hashtable was parameterized by the number of compare and swap operations used by two threads.
we varied the number of operations from four to eight.
the results are summarized in figure .
predicate dependence both takes a lower numberofrunsandhasslowergrowthwhencomparedtodpor.once 8operationsareperformed dporexceedsthetwohourtimelimit while predicate dependence is able to finish in just over two minutes.
experiments where predicated dpor finishes inone runare possible because our method concludes that the property does not dependonconcurrentnon determinism.
183table2.
experimentalresultsforasubsetofthetestprogramstoillustratetheimpactofpredicateddporandthetwooptimizations.
loc is the number of lines of code.
assertis the number of assertions in the file.
threadis the maximum number of threads running in the program.
resultsare givenfor different levelsof optimization dporisthe original dporimplementation.
pred dporis thepredicated dpor.
pred dpor opt is the predicated dpor with optimizations.
for the pred dpor columns the time includes the static analysis requiredtocreatetheslice.
themaximumtestingtimewastwohours testsexceedingthistimearemarkedwithan .
time s runs name loc assert thread dpor pred dpor pred dpor opt dpor pred dpor pred dpor opt accountbad .
.
.
bluetoothbad .
.
.
readreadwrite .
.
.
readwritelock .
.
.
stateful .
.
.
indexersafe12 .
.
.
indexersafe13 .
.
.
indexersafe14 .
.
.
indexersafe15 .
.
.
nbds list .
.
nbds hashtable4 .
.
.
nbds hashtable5 .
.
.
nbds hashtable6 .
.
.
nbds hashtable7 .
.
.
nbds hashtable8 .
.
nbds hashw01 .
.
.
nbds hashw02 .
.
.
nbds hashw03 .
.
.
nbds skiplistu1 .
.
.
nbds skiplistu2 .
.
.
nbds skiplist .
.
nedmalloc .
.
pfscan .
numberofconcurrentoperationsrunsdpor pred dpor figure12.
thenumber ofrunsversus thenumber ofcasoperationsperthreadintestprogramnbds hashtable.
.
relatedwork there is a large body of work in the model checking literature onsoundlyreducingthestatespaceofaconcurrentsystem including persistent sets stubborn sets ample sets sleep sets wakeuptrees symmetry andpropertydriven pruning .
therearealsopormethodsforsat smtbased bounded modelchecking .
however theydonotexploit the synergy between static and dynamic analysis in a cooperative framework.
godefroid and pirottin introduced additional dependence relationscomparedtoconflictdependence torefiningoperationsforvariablesofcertaintypes.
also theyintroducetheidea of conditional dependencies which are valid only at specificstates inaconcurrent programasopposedtoallstates.
however theydo notperformpropertydrivenreduction.
coverage guided approaches to reducing the interleaving space consider the space fully explored when a certain coverage conditionismet.
thesemethodsincludepreemptionbounds fair bounds delaybounding hapset variablebounds and thread bounds .
for example a preemption bound of n means that all sequences of transitions at which no more than n preemptive context switches occur will be explored.
the goal of thesemethodsisnotverificationbutacceleratedbugdetection.
our method of assertion guided abstraction can work along side coveragemetricstopotentiallyprovidefurtherreduction.there are non systematic techniques for testing concurrent programs as well.
recent empirical studies of these algorithms can be found in .
for example contest inserts delaysatsynchronizationpointstoattempttoincreasecontentionand forcedeadlocksduringtesting.
twostageanalysissystemssuchas ctrigger calfuzzer penelope and maple operate by first statically or dynamically analyzing a program to identify potentially buggy interleavings.
then the tools take control of the scheduler and attempt to force the buggy interleavings.
while these methods scale well our approach differs in that we guaranteenottoproduce anyfalsenegatives.
there is a large body of work on dynamic slicing which use a similar method of examining dynamic sequences of transitions for a given program input to build dependence information.
however their focus was primarily on slices of single executions.
ourworkexpands ontheirstohandle concurrentnon determinism across multiple executions.
zhang et al.
expand on the early work to create more precise and efficient dynamic slicing algorithms.
additional work has been done to limit the number of dynamic instrumentation points to reduce the overhead of dynamic slicing.
they are orthogonal to the method proposedinthispaper.
.
conclusions we have presented a new cooperative static dynamic analysis methodforreducingtheinterleavingspaceofmultithreadedc c programs.
wehave alsopresentedtwooptimizationsfordporto providefurtherreduction.
wehaveimplementedournewmethods andevaluatedthemonopensourcebenchmarks.
ourexperimental evaluationshowsthattheproposedmethodscanresultinsignificant speedupoverdporalone.
forfuturework weplantoincreasethe accuracyandefficiencyofourstaticanalysismethod.
.
acknowledgment thisworkwasprimarilysupportedbythensfundergrantccf1149454 markus kusano .
partial support was provided by the onrundergrantn00014 chaowang .
.