auto locating and fix propagating for html validation errors to php server side code hung viet nguyen hoan anh nguyen tung thanh nguyen tien n. nguyen electrical and computer engineering department iowa state university hungnv hoan tung tien iastate.edu abstract checking correcting html validation errors in web pages is helpful for web developers in finding fixing bugs.
however existing validating fixing tools work well only on static html pages and do not help fix the corresponding server code if validation errors are found in html pages due to several challenges with dynamically generated pages in web development.
we propose phpsync a novel automatic locating fixing tool for html validation errors in php based web applications.
given an html page produced by a server side php program phpsync uses tidy an html validating correcting tool to find the validation errors in that html page.
if errors are detected it leverages the fixes from tidy in the given html page and propagates them to the corresponding location s in php code.
our core solutions include a symbolic execution algorithm on the given php program to produce a single tree based model called d model which approximately represents its possible client page outputs an algorithm mapping any text in the given html page to the text s in the node s of the d model and then to the php code and a fix propagating algorithm from the fixes in the html page to the php code via the d model and the mapping algorithm.
our empirical evaluation shows that on average phpsync achieves .
accuracy in locating the corresponding locations in php code from client pages and accuracy in propagating the fixes to the server side code.
index terms fix propagation bug localization php dynamic web applications validation errors i. i ntroduction web applications have become a critical infrastructure in our society.
the world wide web consortium w3c has developed several standards to ensure the development of high quality and reliable web applications .
an important quality criterion for a web application is markup validity which defines the validity of a web document in html and other client side markup web languages according to their corresponding grammar vocabulary and syntactical rules.
although modern web browsers handle very well the parsing of even not well formed html pages some software defects in web applications are not always easily caught due to the client server and dynamic nature of web contents.
checking html validation errors could really help the process of finding and fixing bugs in web development.
in a survey conducted by w3c a majority of web professionals stated that validation errors is the first thing they check whenever they run into a web styling or scripting bug.
creating web pages according to a widely accepted standard also makes them easier to maintain and evolve even if the maintenance and evolution is performed by different developers .recognizing the importance of markup validity for web pages several organizations individuals have produced automatic web page validating tools also called html validators .
some html validators e.g.
tidy also provide automatic support for fixing markup errors to convert an html page into a well formed one that conforms to html grammar and syntax.
however such auto fixing tools work well only on static html pages and do not address several challenges in current web development.
the first challenge is that in a web application a client side html page is often dynamically generated from the server side code which is written in different languages.
for example the server code is written in php asp perl sql etc.
while a client side page is in html javascript css and so on.
the generated html code is embedded within the string literals or the values of variables in the server code.
moreover those values are also scattered in multiple locations in server pages.
for example to produce an html table multiple variables and string constants in different functions in the server code can be involved.
importantly because the server code dynamically produces different client pages depending on run time situations if a validation error is found and reported in a web page e.g.
via tidy it is challenging for its developers to manually map the buggy location s back to its source s in the server side code.
we propose phpsync an auto locating and fix propagating tool for html validation errors in php based web applications.
given an html page produced by a php server page phpsync uses tidy an html validating correcting tool to find any validation errors on the html page.
if errors are detected phpsync leverages the fixes from tidy in the given html page and propagates them to the corresponding location s in the php code.
in the cases that tidy cannot provide the fixes the auto locating function in phpsync will help developers to quickly locate the corresponding buggy locations in php code from the buggy html locations found by tidy.
phpsync does not require the input that produces the erroneous page.
the dynamic nature of a web application is addressed via our symbolic execution algorithm that symbolically executes the given php program to create a single tree based representation called d model which approximates its possible html client page outputs.
each d model represents a symbolic string based value that is resulted from the symbolic execution of any php expression s .
the d model for the entire php server page or function is composed by the d models resultedfrom the intermediate computations during the symbolic execution of the expressions in that page function.
symbols in a d model represent users inputs data retrieved from databases or unresolved values.
a node in a d model represents either a determined value e.g.
a string literal a non determined data value e.g.
a user s input a concatenation operation a selection operation or a repetition operation on other nodes values.
this allows phpsync to model the multi valued and scattered server side data and the multiple versions of client side code generated from the server code.
another fundamental technique in phpsync is csmap an algorithm that maps any text in the given html page produced by the given php program to the corresponding php code location by mapping that text to the node s of the corresponding d model.
then our fix propagating algorithm derives the fixing changes from tidy to the given html page and propagates them to the locations in php via the established client to server mappings.
csmap is generic and can be used in other applications such as locating the corresponding buggy php places for other types of errors found in an html page.
our empirical evaluation on real world web applications shows that phpsync achieves on average .
accuracy in locating the corresponding locations in php code from client pages and accuracy in fix propagating to server code.
the key contributions of this paper include phpsync an auto locating and fix propagating tool for html validation errors in php based web applications csmap a mapping algorithm from an html page produced by a php page to the corresponding php locations an empirical evaluation on several real world web applications to show phpsync s correctness and efficiency.
section ii presents a motivating example.
section iii discusses our representation model.
associated algorithms are described in sections iv and v .
section vi is for our evaluation.
related work is in section vii.
conclusions appear last.
ii.
m otivating example and approach overview this section presents an example that illustrates a bug caused by an html validation error and the challenges in fixing such errors in php based web applications.
a. an example of a bug on an ill formed web page this example is inspired from an online social network system in which users are able to connect with peers friends via posting and sharing news pictures and videos in their daily activities.
in this system a user can view and provide comments on the posts from his her friends pages.
figure 1a displays such a page when a short news item on ase is posted.
each post is followed by one or multiple comments and a textbox along with a submission button for a user to enter a new comment.
after the comment is provided and the button is pressed the new comment is expected to appear at the end of the comments list and the textbox and the button would be positioned at the bottom of the page for another comment as in figure 1b.
however when a user entered a comment the textbox and the submission button appeared before that fig.
.
output of php page in browser page index.php html head script language javascript src ajax.js script link rel stylesheet type text css href style.css head body div class out div class inimg img src aselogo.gif width div div class inpost ase br submission is now open.
div div div id divcomments class out div class incomment hung nguyen great news!
div !
miss closing the divtag on line div class out input id txtcomment type text input type button value comment onclick comment div body html fig.
.
html client side code for figure newly input comment see figure 1c .
assume that this bug was found and reported by a user on that page.
from the point of view of the developer of this web based social network application in order to understand and fix this bug s he would naturally first examine the html code of that web page figure to see if there was any error in its presentation structure.
s he could do this verification manually or use an automatic html validator such as tidy .
assume that s he found that the code missed a closing tag div for the opening tag div at line .
therefore s he discovered that the bug was caused by the missing div the last page division lines is included within the page division starting at line making the textbox and button belong to the same page division for the comment list.
when the user submitted a comment it was appended to the end of the page division for comments and appeared below the textbox.
b. challenges for validation and bug fixing on web pages the fix in the html code would be straightforward as the developer should add a div closing tag at line for the corresponding open tag at line .
however that html page wasdynamically generated from php based server code figure .
with a php based web application s he must locate and fix the corresponding buggy code in the server.
this task manually is challenging in general due to several reasons.
the mapping tracing from a client html page to serverside code is not straightforward.
a web application is a clientserver one and generally developed in multiple languages .
the server code could be written using a scripting language e.g.
php while the client side code is in html for presentation and javascript js for data processing and event handling.
when the server side code executes at the server clientside code is generated and sent to a browser to execute there.
that is php based server side code dynamically produces different html pages depending on different inputs.
for example depending on the login information of a user at run time different files are included different functions are executed different execution paths in php code are taken in order to generate a particular client page.
in this motivating example to fix the bug the developer would start examining the file index.php on the server side figure 3a because s he found the error in the client page index.php .
however the bug is not within the file index.php of the server side.
that php file is responsible for checking if a user has logged in line figure 3a via islogged infunction in the file functions.php line which also contains other utility and formatting functions in the system figure 3d .
the file main.php figure 3b contains the code handling the cases of correct logins while error.php figure 3c handles the incorrect cases.
in practice validation errors are found in a client page via an html validation tool and reported without corresponding input and action steps to produce that page.
thus to fix them a developer might have to check many server side files and execution paths to find the right execution path that produces that client page.
due to the dynamic nature of php html js and the generation of client side code in a web application code and data tend to be mixed especially client side code is often embedded in server side data .
for example the code of the divtags are embedded within php string literals.
moreover a piece of html code might be generated via many php string literals variables and functions that are scattered in different places in the server side code.
in this example the body element of the main html page is generated from the values of several scattered literals variables and function calls.
to locate the right place to fix the div tag the developer needs to check several literals and differentiate between many tags with the same name div that appear in several places in main.php and functions.php .
in this example the developer must determine that the error is in the addcomments function in functions.php line figure 3d .
in reality the numbers of included files functions variables literals and execution paths might be very high and they are scattered thus making it challenging for a developer to manually locate the bug.
in this example the php statement that prints out the erroneous html line is line of figure 3b echo addcomments ... .
however to fix that error a developer in fact must change line of figure 3d output .
n where the erroneous html line is composed and manipulated.
this example shows that html validation errors could cause run time bugs even when a browser can still display the page.
as a user submitted a comment by clicking the button a file index.php ?php include functions.php if !
islogged in include error.php ?
html head script language javascript src ajax.
js script linkrel stylesheet type text css href style .css head body ?php include main.php ?
body html b file main.php ?php connect to the database to get the content of the post and its comments and store them to the variables post and comments respectively 4echo div class out .
n .
addimage aselogo.gif .
n .
addpost post .
n div n 8echo addcomments comments 9echo div class out .
n input id txtcomment type text .
n input type button value comment onclick comment .
n div n ?
c file error.php html body ?php msg user not logged in echo msg exit ?
body html d file functions.php ?php 2function is logged in ... 3function addimage src ... 4function addpost post return div class inpost .
post.
div 5function addcomment comment return div class incomment .
comment .
div 8function addcomments comments output div id divcomments class out foreach comments as comment output .
n .
addcomment comment output .
n miss closing the div tag on line return output ?
fig.
.
php server side code example the js function comment not shown was invoked line figure 3b .
due to the missing div tag it incorrectly updated the corresponding division in the page via ajax framework thus causing the incorrect page as in figure 1c.
c. approach overview we propose phpsync an auto locating and fixing tool for validation errors in php based web applications.
given an html page produced by a server side php program phpsync uses tidy to find the validation errors on the page.
if errors are found it propagates the fixes from tidy on that html page to the corresponding location s in php code.
the ideas are as follows phpsync performs a symbolic execution to approximately represent all possible client side html outputs of a server page swith a single tree based model called d modeld it maps the given html page c i.e.
a concrete html output to the d model and then to the server side codes it uses tidy to validate fix the page cinto a wellformed page and recovers the fixes applied to c and it finally propagates these fixes to svia the mapping established betweencands viad .
let us describe our approach.
iii.
d model representation of client pages a. d model representation d model is a tree based representation for any symbolic string based value resulted from a symbolic execution on any portion of server side php code.
the d model for the entire php server page function is composed by the d models resulted from the intermediate computations during a symbolic execution of the php expressions of that page function.
that is phpsync also creates d models to represent possible values of intermediate computations and combines them into larger d models for later computations.
a d model often contains symbols to represent user inputs data retrieved from databases or unresolved values.
by performing a symbolic execution on a php page phpsync approximates all possible outputs client pages with a single d model.
let us explain it in details.
first the string outputs for a portion of php code are stream like i.e.
are produced via sequential writing or concatenation operations on php string values.
the string value tof a data related php expression or the string value resulted from a string computation in php can be produced using the following context free production rules rule .
t t rule .
t t .
t rule .
t t t rule says that the value of a php expression can be a string literal.
rule means that the value of a php expression can be concatenated from the values of two php expressions.
rule specifies that a php expression can have either one of two values depending on the actual execution path at runtime.
for example in figure 3a the output of the page index.php is produced using rule due to the ifstatement at line i.e.
it is either one of two strings while the string output at line ofmain.php is produced using rule i.e.
it is concatenated by four strings .
both production processes use rule .
rules and are also used to repeatedly produce a value.
for example the value of variable output of the function addcomments in functions.php is produced by repeatedly using a foreach loop via rule lines figure 3d .
those rules for output production of php code suggest the following structure.
definition ad model is a labeled ordered tree in which the leaf nodes represent the values and the inner nodes represent the operations for combining those values.
.
there are two kinds of leaf nodes aliteral node represents a determined string value e.g.
a php literal and asymbolic node represents an undetermined unresolved string value e.g.
a user input .
.
there are three types of inner nodes representing three kinds of operations on d models aconcat node represents a value that is concatenated from the values corresponding to the sub trees of that node.
the order of the sub trees represents the order of the concatenation operation.
aselect node represents a value that could be selected from the values corresponding to its sub trees.
arepeat node represents a value that could be repeatedly concatenated from the values corresponding to the sub trees of the only child node of that repeat node.
.
the nodes on d models have their attributes describing additional information such as the php expressions associated with literal and symbolic nodes.
figure illustrates a d model that represents the output of the page index.php in figure 3a.
as seen the root node of the d model is a select node representing that the corresponding output of this php page is selected from the two values of two corresponding sub trees of that root node.
the left and right subtrees correspond to the outputs if error.php or main.php is executed respectively.
the root node of the right subtree is a concat node representing the concatenation of the values of multiple literals represented as literal nodes e.g.
the string literal div div the variables post and comment represented as symbolic nodes and the return values from different function calls.
the return value of function call addcomments is represented as the d model rooted at the second concat node with its child node repeat representing the repetition in the foreach loop.
consecutive string literals are combined for a compact d model representation.
note that a d model approximates all possible symbolic outputs of php code by symbolically executing all of its execution paths.
however it does not represent all possible paths.
b. building d model via symbolic execution we develop an algorithm to evaluate compute the symbolic value for the output of any php code by building its dmodel.
it takes as an input the code of a php server page and performs a symbolic execution to create a d model for a special variable output to represent the output of that page.
during execution it creates the d models for the intermediate results and updates the d models for encountered variables.
the algorithm recursively evaluates all statements in all branches updates creates small d models and combines them into larger ones.
it processes the php statements as follows .e scalarvalue as a scalar string value is encountered a literal node is created to contain the corresponding string.
.e1 v e2 since a variable might have different values at different points in execution phpsync maintains for each variable va d model corresponding to its most recent value during the execution.
when meeting an assignment expression phpsync computes the d model for the expression e2 and assigns that d model as the most recent value of v. .e v when a variable vis retrieved for a computation its latest d model is used.
however if vdoes not have any d model phpsync returns a symbolic node representing an undetermined value.
this corresponds to the cases of user inputs data values from databases or unresolved computations.repeat div id divcomments class out concat html head script language javascript src ajax.js script link rel stylesheet type text css href style.css head body div class out div class inimg img src aselogo.gif width div div class inpost div div postselect html body user not logged in body html concat div class incomment div comment div class out input id txtcomment type text input type button value comment onclick comment div body html output concat fig.
.
d model representation for the outputs of the php page index.php of figure 3a.
.e1 e2.e3 for an expression with a concatenation phpsync processes the sub expressions to produce their dmodels and then creates the resulting d model with its root node being a concat node.
the sub trees of that root node are the computed d models of the sub expressions.
those subtrees are connected in the same order as the appearance order of the corresponding sub expressions.
phpsync also performs other standard string and arithmetic operations in a similar process.
un resolved results are represented as symbolic nodes.
.s echo e when seeing an echo print statement phpsync concatenates the current d model of the variable output and the d model of eto produce the new d model for output .
note that output holds the current output of the php page.
.s1 if e s2 elses3 for an ifstatement phpsync executes both branches and collects into a set v all variables v modified in either branch.
let us use vs2.dand vs3.dto denote the d models of vafter executing each branch respectively.
for each vinv phpsync updates its value with a new dmodel.
the new d model is rooted at a new select node whose children are vs2.dand vs3.d.
if the elsebranch is empty the latest d model for vbefore the ifstatement is used in place ofvs3.d.
the same treatment is for switch statements.
.s1 while e s2 first phpsync executes statement s2 once and collects all modified variables vinto v .
typically the string value of a variable is appended during the execution of a loop.
let us use dvto denote the d model that represents the symbolic string value appended to v. for a variable vinv phpsync updates its value with a new d model.
the new dmodel is rooted at a new concat node whose children are v.d and a new repeat node figure .
the repeat node has dv as its only child.
if the value of vis not appended in the loop phpsync currently does not handle it and retains the old value ofvbefore the loop.
the same treatment is for a forstatement.
.s return e when phpsync meets a return statement the d model of eis computed and collected into a set retvalues of all possible returned values of the current function file.
.function call .
when a function is called phpsync assigns the d models of the actual arguments to the formal parameters of the function and then performs a symbolic execution on thetable i symbolic execution rules on php c ode to build d models php syntax evaluation rule to build d model e scalarvalue e.d new literalnode scalarvalue e1 v e2 v .d e2.d e1.d e2.d e v if v .d null then e.d v .d else e.d new symbolicnode v e1 e2.e3 e1.d new concat e2.d e3.d s echo e output.d new concat output.d e.d s1 if e s2 v v v .d new select vs2.d vs3.d else s3 s1 while e s2 v v v .d new concat v .d new repeat dv s return e curfunc.retvalues cur func.retvalues e.d or cur file.retvalues cur file.retvalues e.d e func argi func.retvalues ifunc.param i.d arg i.d execute func e.d new select func.retvalues e1 include e2 file computevalue e2.d file.retvalues execute file e1.d new select file.retvalues e exit curprog.outputvalues curprog.outputvalues output.d prog si prog.outputvalues execute si prog.outputvalues prog.outputvalues output.d output.d new select prog.outputvalues function s code.
after executing the function it creates a new d model with its root being a new select node to describe the possibly multiple returned values of the function.
the children of that select node are the d models in the retvalues set of the function.
if the function has only one returned value the dmodel of that returned value is used.
if global variables and reference parameters are modified during the execution of the function their d models also updated accordingly.
if the code of the called function is unavailable e.g.
library functions it represents the returned value by a symbolic node.
.
e1 include e2 phpsync computes the string value from the d model of e2and considers it as a file name fname .
then it continues the execution on that file.
finally the d model of e1is assigned with a new d model whose root is at a new select node with its children being all returned values after executing fname as in the case of a function call.
.exit if phpsync meets an exitfunction call the d model of output is collected into outputvalues set of the current page.
.block of statements after executing all statements in the php program page phpsync creates a new d model with its root being a new select node to describe the possibly multiple outputs of the page .
the children of that select node are the d models in the set outputvalues of the page.
while building the d models phpsync also keeps the mapping between the d model leaf nodes and their corresponding php fragments.
for example the literal node div class ... under the lowest concat node in figure is mapped to the fragment div class ... on line of figure 3d.
for the mapping of a symbolic node phpsync also keeps its execution trace.
for example the node post of figure is mapped to line of figure 3d inside the function s body and the trace includes line of figure 3d line of figure 3b and lines of figure 3b.
that trace is useful for developers in examining the output corresponding to post i.e.
line of figure .
the limitation of phpsync lies in the approximation of the symbolic executions of ifand for while statements.
the condition of an ifis not evaluated and only string appending operations on variables are handled in a loop.
phpsync also does not handle well library function calls if the source code is unavailable.
iv.
csm ap m apping texts of client page to server page via d model let us present csmap algorithm that maps any text in an html page to the corresponding location in a server page.
it takes as inputs an d model dand a string c divides cinto proper sub strings and maps them to the corresponding literal or symbolic nodes in d and then to php literals or variables.
a. algorithm design strategies a d model dfor a server page can be considered as a context free grammar cfg and a string cis one of its concrete sentences.
however the traditional cfg parsing compiling techniques are not suitable and efficient here because the d model always contains multiple symbols i.e.
symbolic values that correspond to user inputs etc.
therefore we design csmap with the following heuristic strategies .
top down and divide and conquer with the goal of mapping texts to the leaf nodes in d it is natural to perform the mapping of the substrings in cto the sub trees in d. csmap follows the top down process as in top down parsers .
.
pivoting despite that the html pages are dynamically generated the shared static html code portions among some of those outputs of a php page occur very often.
csmap attempts to map the string cto these shared code portions indfirst and then uses them as the already mapped pivots for further dividing and conquering.
that is the process will continue on the substrings of cdivided by those pivots.
.
local best matching since there may exist many selection nodes csmap could face the combinatorial explosion if it1function csmap c d 2strtodmodel c r d.root 3end handling literal nodes 5function strtodmodel string str literalnode literal 6substring str.findfirstoccurence literal.val if substring is found substring.maplocation literal 9end handling concat nodes 11function strtodmodel string str concat concat if concat.numchildren return if concat.numchildren strtodmodel str concat.firstchild return pivot findpivot str concat.children if pivot null str .
split pivot firstsubstr secondsubstr concat.split pivot firsthalfnodes secondhalfnodes strtodmodel firstsubstr firsthalfnodes strtodmodel secondsubstr secondhalfnodes else strtodmodel str concat.
firstchild strtodmodel str.getunmapped concat.removefirstchild 23end 24function findpivot string str dmodellist list list .retainonlyliteraldmodels for dmodel list count findoccurrences str dmodel.stringval if count return dmodel end return null 31end handling symbolic nodes 33function strtodmodel string str symbolicnode node siblings node.parent.childnodes if node.getrightsibling siblings is a pivot str .maplocation node 37end handling select nodes 39function strtodmodel string str select select tstring fstring str strtodmodel tstring select.truebranch strtodmodel fstring select.falsebranch if tstring.mappedlength fstring.mappedlength str .maplocation tstring.maplocation else str .maplocation fstring.maplocation 46end handling repeat nodes 48function strtodmodel string str repeat repeatnode before str.mappedlength strtodmodel str repeatnode.childnode after str.mappedlength if before after strtodmodel str.getunmapped repeatnode 54end fig.
.
csmap algorithm mapping from html page to d model tries to exhaustively explore all combinations of their branches and perform optimal matching.
thus for a selection node csmap uses a local best matching strategy by first exploring all branches of the selection node and mapping to the branch with more matched characters.
this choice is made locally for each selection without considering globally optimal matching.
b. detailed algorithm figure shows the pseudo code for csmap algorithm.
it is designed as the recursive function strtodmodel whose inputs are a string cand the root node rof a d model.
there are five overloading functions strtodmodel corresponding to five types of d model nodes.
during the execution the attribute maplocation of each substring in cis assigned with at most one reference to a node in the d model i.e.
its mapped node .
csmap handles each of the five node types as follows .
ifris a literal node rhas a value val.
ifvalappears in str i.e.
is its substring then the characters of that substring are mapped to r. however since strmight have several occurrences of val by a greedy strategy csmap maps the first occurrence of valinstrtor i.e.
favoring the leftmost mapped string.
.
ifris a concat node csmap considers stras a concatenation of the values corresponding to the sub trees ofr.
to find the optimal mapping one might need to divide strinto all possible sub strings and map each of them to the corresponding sub tree of r. however to simplify the divideand conquer step csmap uses the pivoting strategy.
it finds a pivot by checking the string of a literal node among the subtrees ofrto see if it occurs only once in str.
if such a pivot exists it is used to divide strinto two sub strings and the list of child nodes of rinto two sub lists rooted at two new concat nodes for further mapping lines .
if such a node does not exist csmap maps strto the first subtree of rand recursively maps the remaining texts in str after the alreadymapped portions to the other subtrees of r lines .
.
ifris a symbolic node csmap checks whether the sibling node of ris a pivot.
if it is csmap considers the string stras the value generated from r thus maps all characters of strtor.
if a pivot does not exist csmap does not map strto rbecause it tries to map strwith other sibling nodes of r. .
ifris a select node stris considered to be produced from one of the d models corresponding to the sub trees of r. thus csmap recursively maps strto each sub tree of r and chooses the sub tree with the higher number of mapped characters as the mapping for str lines .
.
ifris a repeat node cis considered as the concatenation of the values produced by the sub trees of d after some number of iterations.
csmap attempts to map strto the child node of r which represents the appendix string in one iteration.
it will continue to map the remaining of struntil no more mapping is gained lines .
finally after determining the mapping between the clientpagecand the d model dvia csmap phpsync uses the mapping from dto php code established during building d to map the texts in cto php literals variables or statements.
example.
let us revisit the example in figure with the d model in figure to illustrate csmap.
csmap starts by mapping the entire html page to the d model rooted at a select node.
for a select node csmap first attempts to map the code to each branch separately.
in this case the first branch is the string ... user not logged in ... which does not exist in the html code thus it remains unmapped.
the second branch however starts at a concat node with several pivot nodes that are helpful for the mapping.
in particular its first third and fifth child nodes are string literals that occur exactly once in the html code hence csmap maps the corresponding substrings in the html code to those literal nodes.
the remaining sub strings ase br submission is now open.
line and lines of figure are mapped respectively to the remaining child nodes i.e.
the symbolic node post and the next concat node .
for that concat node csmap again finds that its first child node divid divcomments ... corresponding to line figure is a pivot.
therefore it maps the remaining substring on line to the repeat node figure .
for a repeat node its contained d model rooted at the child node concat is mapped to the substring repeatedly until no further mapping is found.
in this example the substring can be mapped to the two literal nodes and the symbolic node comment after one iteration.
even if line were repeated several times csmap would still map the text to the d model with the repeat node.
at this point csmap has evaluated both branches of the select node at the root of the top level d model.
comparing the mapping results it returns the mapping given by the second branch where all of the html code is successfully mapped.
since csmap works heuristically it is important that the mapping is done correctly in the top level steps of the divideand conquer stack.
a client page typically contains large chunks of texts that are likely to remain unchanged for different executions of the server page.
this nature of client pages makes it likely for csmap to find correct pivots in the early mappings.
incorrect mappings may occur at a later stage of the execution but produce less impact on the overall result since remaining texts to be mapped get much smaller.
v. a uto locating and fix propagating to php this section describes how phpsync helps in auto locating and fix propagating for the validation errors to php code.
the inputs include a given html page cproduced by a php pages.
phpsync uses tidy an html validator corrector to check cfor html validation errors.
if errors are found it uses tidy to produce the corrected version c ofc.
auto locating.
there exist the cases in which tidy is not able to provide the fixes however it points out the buggy locations in the html page c. in such cases for each error location in c phpsync uses csmap to automatically locate the corresponding literal node s in the d model of sand then locate the php literal s in s. for example via csmap the div opening tag on line of figure is mapped to the first literal node of the second concat in figure therefore is correctly traced back to line of figure 3d.
fix propagating.
if tidy can fix those errors phpsync will propagate those fixes through the mapping between sand cestablished by csmap.
because tidy does not provide the operations of the fixes but produces only the corrected version c we developed ccmap algorithm to map the texts between candc to derive the fixing changes.
the output of the algorithm is all the changes at the character level between c andc which are then used to propagate to the server code.
we design ccmap with three strategies .
token based processing ccmap treats the client code c as a sequence of tokens instead of syntactic units because c might not be fully parsable due to its validation errors.
.
divide and conquer due to the nature of validation errors missing closing tags missing tag brackets invalid tags etc.
the fixes from tidy leave the majority of cun changed i.e.
candc share similar texts.
ccmap maps the unchanged portions in candc and uses them as pivots as in csmap.1function ccmap c c 2t tokenize c d d is the set of delimiters 3t tokenize c d d r n t f 4lcs exact t t 5foreach two successive already mapped elements t andt l t .
map r t .
map use mapped elements as pivots lcs sim t t .
map similar elements for each mapped pair of tokens t and t lcs exact t t map characters in tokens for each two successive already mapped characters c and c l c .
map r c .
map use mapped characters as pivots lcs exact c map the delimiters only 13function lcs sim t t p array fori tot.length forj tot .length if sim t .
value t .
value p .
score p .
score sim t .
value t .
value p .
trace lu else ... standard lcs algorithm fig.
.
ccmap algorithm deriving fixes from tidy .
similar matching to capture the replacement operations betweencandc we modify the standard longest common sub sequence lcs to support the mapping of similar texts.
the pseudo code of ccmap is in figure .
it first tokenizes candc into two sequences of tokens tandt respectively lines .
then it uses the standard lcs algorithm lcs exact to find the pivot tokens line .
for each two successive mapped tokens t andt l r and their corresponding mapped tokens t andt it uses lcs sim to find the similar not yet mapped tokens in the aligned sequences t andt lines .
lcs sim at lines is almost the same as the standard lcs except the way it compares the elements between two sequences line .
in lcs sim two elements can be mapped if their string similarity exceeds a threshold .
function sim .
measures the similarity of two strings by the ratio between the length of their lcs and their average length.
for each mapped pair of token t and t both exact and similar ones ccmap runs lcs exact on the two sequences of characters to map the corresponding characters lines .
to map all the characters in the code it then translates the mapping results of the characters in the tokens in tandt to the characters in candc .
it maps the previously removed delimiters in candc using lcs exact taking already mapped characters as pivots lines .
all mapped characters are considered as unchanged.
the un mapped ones in candc are considered as deleted and added respectively.
finally from those derived changes to c phpsync finds the corresponding d model s literal nodes and then applies them to the corresponding php string literals in s. for example phpsync uses ccmap to detect that div is added by tidy at line of figure i.e.
is inserted after the n character between lines and .
that string is mapped by csmap to the literal n at line of figure 3d.
thus phpsync will make the change at line output .
n div .
vi.
e mpirical evaluation this section presents our empirical evaluation on phpsync.
our research questions are how accurately phpsync mapstable ii subject systems and d m odels subject systems d models name files klocs exfiles nodes control time s schoolmate .
.
.
timeclock .
.
weberp .
.
.
upb .
.
.
addressbook .
.
.
manhali .
.
.
table iii mapping and fixing result on schoolmate .
.
navi steps mapping fix propagating fragments characters err.
tidy ps all auto man corr.
all corr.
acc.
login .
.
school .
.
terms .
.
semesters .
.
classes .
.
users .
.
teachers .
.
students .
.
registration .
.
attendance .
.
parents .
.
announce .
.
terms add .
.
terms edit .
.
sem.
add .
.
sem.
edit .
.
classes add .
.
classes edit .
.
classes grid .
.
users add .
.
users edit .
.
.
.
.
html code to server code and how accurately it propagates the fixes from tidy to server code.
all experiments were carried out on a windows home premium bit computer with cpu intel core i3 370m .
ghz and 6gb ram.
we collected six php systems from sourceforge.net in different sizes and domains table ii .
we read the code to gain the knowledge and set up those systems on our server with required databases and sample data.
for each system we selected multiple server pages for testing and built their dmodels.
column exfiles shows the average number of executed server files for a page.
columns nodes and control show the average number of all nodes and that of control nodes select repeat in a d model.
running time is in column time.
a. accuracy of mapping client code and server code to evaluate phpsync s accuracy in mapping the texts in html to php code we first collected the html test pages from the subject systems by navigating through several html pages within that system on a web browser.
we recorded each page as an html test page by saving its corresponding html code and the navigation steps to get to that page for later reproducing the page and checking .
for each subject system we selected the html pages with different presentations to have the samples of client pages with diverse page structures.table iv accuracy of mapping and fix propagating on allsubject systems mapping fix propagating system test fragments characters complexity err.
tidy phpsync miss acc.
time s pages all auto man corr.
all corr.
acc.
files time s schoolmate .
.
.
.
.
.
.
.
timeclock .
.
.
.
.
.
.
weberp .
.
.
.
.
.
.
.
upb .
.
.
.
.
.
.
.
addressbook .
.
.
.
.
.
.
.
manhali .
.
.
.
.
.
.
.
our evaluation method is to use phpsync to map every character in an html test page cto the corresponding character in a php literal or php variable and then to verify those mappings for all characters by the combination of a checking tool and human subjects.
remind that given an html test page phpsync divides its html contents into several text fragments and maps each fragment into the php literals variables section .
because all of those fragments cover the entire html test page to verify phpsync s mapping for each character one can check the mapping for each of those fragments called test fragments .
the unmapped fragments are considered to have incorrect mappings.
to reduce the effort of manual verification from human subjects we wrote an evaluation program that checks phpsync s mapping from every test fragment fof the test page to a php literall.
iffis mapped to a php variable we examine the mapping manually.
otherwise that program replaces only the first character in the literal lin the php code swith a special character sc that does not appear in the page c. we then executed the instrumented php code s and followed the same recorded navigation steps to produce the new html page c .
if inc the first character position in fis replaced with that sc and all other positions in c are un changed we consider it as a correct mapping for that character .
moreover in such a case of correct mapping for that character if fis exactly identical to l we consider the mapping f l correct for all characters in the fragment f and consider fas a correctly mapped fragment .
when other positions in c besidesfhave been changed the evaluation tool cannot conclude that the mapping is incorrect.
for instance there may exist a correct mapping from some client code to a php literal inside a for while loop.
when the client code c is produced the sc character may appear multiple times in c due to the execution of the loop.
thus in all other cases we manually verified the mapping from ftolby understanding the program semantics.
in table iii column mapping shows the result on schoolmate v1.
.
.
we collected a total of html test pages.
in column fragments the sub columns all auto man and corr.
respectively show the number of all test fragments in the test page the numbers of auto evaluated manually evaluated and correctly mapped fragments.
in column characters the sub columns all and corr.
show the numbers of all characters and correctly mapped ones in a test page.
acc.shows accuracy i.e.
the ratio of the number of correctly mapped characters over the total.column mapping of table iv shows the results for all subject systems.
processing time is in column time.
as seen phpsync achieves very high accuracy an average of .
in character mapping with a small processing time an average of seconds for a test page of about characters .
column files shows us that on average a test page is produced by php files.
thus our tool could help reduce developers effort in finding the php locations for a given html text.
b. accuracy of fix propagating to server code we used the same set of html test pages in those systems for an experiment to evaluate phpsync s accuracy in fix propagation.
for each test page c we used tidy to detect validation errors.
if errors were found and tidy was able to fix the page into c phpsync would be used to derive the fixing changes between candc and propagate them to fix the php code sintos .
then we executed the fixed php codes and followed the same recorded navigation steps to produce the new html page c .
tidy was used to check on c for validation errors again.
after that the lists of errors that tidy had fixed c c and phpsync had fixed via fix propagation c c were automatically compared to determine how well phpsync propagated those fixes.
accuracy is measured as the ratio between the number of correctly propagated fixes over the total propagated fixes.
for the cases that tidy uncovered validation errors but could not fix one could use csmap to auto locate the erroneous php code.
the quality of such mapping was evaluated as in section vi.a.
the columns fix propagating in tables iii and iv display the fix propagation results.
columns err.
tidy and psshow the number of total html validation errors found by tidy that of errors fixed by tidy and that of errors fixed by phpsync via fix propagation.
as shown phpsync achieves high accuracy an average of in fix propagation with small processing time.
importantly it did not introduce any new validation error.
threats to validity.
our experiments were on only systems with test pages.
the selected systems and test pages might not be representative.
however the number of test fragments is very large of which were manually checked in hours.
during that process human errors could occur.
currently phpsync does not completely handle object oriented php thus most of the selected systems do not contain many classes.
four out of six systems have only reasonable sizes and do not contain many loops for complex computational logics.vii.
r elated work artzi et al.
introduced apollo a method to find bugs in web applications by combining concrete and symbolic execution.
it executes a web application on an initial empty or randomly chosen input.
additional inputs are derived by solving path constraints and conditions extracted from exercised control flow paths .
failures during such executions are reported as bugs.
in they extended apollo to also model interactive user inputs in a web application.
however it does not pinpoint the buggy php statements that cause such errors.
to support such fault localization in they combined a variation of tarantula with the use of a dynamic output mapping technique.
for each statement tarantula associates it with a suspiciousness rating that indicates the likelihood for the statement to contribute to a fault.
the rating is computed based on the percentages of passing and failing tests that execute that statement.
however they reported that in a web application a significant number of statements lines are executed in both cases or only in failing executions.
thus they combined tarantula with a dynamic output mapping technique which instruments a shadow interpreter to create a mapping between the lines in php and html code by recording the line number of the originating php statement whenever output is written out using the echo and print statements .
in comparison while their output mapping technique is based on dynamic analysis with run time instrumentation into an interpreter phpsync relies on symbolic execution.
their technique is lightweight however phpsync is better suited for this auto locating and fix propagating problem.
first for an erroneous html line detected by an html validator their tool will map it to the php statement responsible for printing it out.
however that php print echo statement might not always be the line that needs to be fixed because the erroneous content of the html line might be composed and manipulated in string variables in previous statement s see the motivating example in section ii.b.
.
second in practice validation errors could be found in a client page via tidy and reported without corresponding input and action steps to produce that page.
thus their dynamic mapping technique cannot be applied.
in this case a fixer can still use phpsync to fix the errors.
finally for fix propagation phpsync performs mapping at the character level while for the debugging purpose their tool maps at the line level.
tidy an html validator corrector works mostly on static html pages.
for php code it filters all the code within a ?php and the corresponding ?
and considers the remaining as html code.
that scheme does not work well because html code is embedded within multiple scattered php literals and variables see section ii .
similar to tidy other validating tools are limited to support validating or correcting only client pages in xml html css.
minamide s string analyzer takes a php program and a regular expression describing all of its possible inputs and then statically approximates and validates the output via a context free grammar.
in comparison his goal is tovalidate approximated html outputs from a php program without fixing support .
moreover phpsync performs symbolic execution requiring an input specification as in minamide s. using a string analyzer wang et al.
compute the approximated output of a php program and identify the constant strings visible from the browser for translation purpose.
several string taint analysis techniques were built for software security problems .
gould et al.
use string analysis to guarantee well typed sql queries generated by a java program.
the type system in is based on regular expressions with string concatenation and pattern matching.
a cfg based type system for string analysis is presented in .
phpsync complements to php debuggers however it does not need the inputs of php programs with symbolic execution.
viii.
c onclusions we propose phpsync an auto locating and fix propagating tool for validation errors.
given an html page produced by php code phpsync uses tidy to find its validation errors and propagates tidy s fixes to php code.
our core solutions include a symbolic execution algorithm on php code to produce an d model which approximates all possible client pages and the client server mapping and fix propagating algorithms.
our evaluation shows that it achieves high accuracy in both tasks.