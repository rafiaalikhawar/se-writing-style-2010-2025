achieving accuracy and scalability simultaneously in detecting application clones on android markets kai chen1 peng liu1 yingjun zhang3 1college of ist penn state university u.s.a. 2state key laboratory of information security institute of information engineering chinese academy of sciences china 3institute of software chinese academy of sciences china chenkai010 gmail.com pliu ist.psu.edu yjzhang tca.iscas.ac.cn abstract besides traditional problems such as potential bugs smartphone application clones on android markets bring newthreats.
that is attackers clone the code from legitimate android applications assemble it with malicious code or advertisements and publish these purpose added app clones on the same or other markets for benefits.
three inherentanduniquecharacteristicsmakeappclonesdifficulttodetect by existing techniques a billion opcode problem caused by cross market publishing gap between code clones and appclones and prevalent type and type clones.
existing techniques achieve either accuracy or scalability but not both.
to achieve both goals we use a geometrycharacteristic called centroid of dependency graphs to measure the similarity between methods code fragments in two apps.
then we synthesize the method level similarities anddraw a y n conclusion on app core functionality cloning.
the observed centroid effect and the inherent monotonicity property enable our approach to achieve both high accuracy and scalability.
we implemented the app clone de tection system and evaluated it on five whole android markets including apps million methods and billion opcodes .
it takes less than one hour to performcross market app clone detection on the five markets after generating centroids only once.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering general terms languages algorithms experimentation security keywords software analysis android clone detection centroid permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specificpermission and or a fee.icse may june hyderabad india copyright acm ... .
.
.
introduction code clones or similar fragments of source code bring unwanted problems such as inconsistencies potential bugs and code smells .
today with the rapidly increasinguse of smartphones code clones in smartphone applications appsfor short bring several kinds of new threats.
specially some attackers clone the code from legitimate android appsand pack assemble it with purpose added functionalities or modificationsafter reverse engineeringthose apps .
this new kind of code clone is referred to as app clones or repackaging .
after cloning an app attackers would upload it to the same market e.g.
google play or other markets.
app clones bring severe problems.
a smartphone malware prefers to use app clones as carriers for propagation.
zhouet al.
found of or .
malware samples are app clones with malicious payloads.
b legitimatedevelopers lost their advertising revenue and users to app clones.
according to a recent study of the advertising revenue and of the user base for a developer arediverted to app clones on average.
.
unique characteristics of app clones app clones meet two essential criterions.
a large portion of the core functionalities of one app are cloned in another app.
to separate app clones from shared libraries we do not view common frameworks and third party librariesas part of core functionalities.
app clones are developed by different authors companies.
based on the two criterions we find that app clones on android markets have thefollowing unique characteristics.
characteristic a billion opcode problem.
since two app clones could appear on different markets cross market analysis is necessary.
given multiple markets the app clone detection problem is a billion opcodeproblem.
since most developersdonotreleasethesourcecode weusethenumber ofopcodes to measure the amount of code to analyze.
an opcode is a part of a bytecode statement which determines different kinds of vm operations.
hanna et al.
analyzed apps from google play the official android market and found that the total number of opcodes in all apps is approximately .
billion.
characteristic gap between code fragment clones and app clones.
traditional clone detection is conducted inside a big software project e.g.
apache to identify similar code fragments not similar apps.
in contrast detecting appclones needs to pairwisely compare apps in multiple markets.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
a smartphone app is a set of code fragments.
although code fragment clone detection is still very useful two apps con taining code fragment clones are not necessarily app clonesdue to two reasons.
r1 the two apps could use common third party libraries.
r2 unless the core functionalities of two apps are cloned we cannot say that they are clones.
characteristic type and type clones are prevalent on android markets.
based on several studies many app clones on android markets are type and or type clones the four types of clones are defined in the footnote .
in contrast traditional code clones are not always type and type .
in fact many traditional clones are type .
type clones rarely exist in app clones.
this is mainly because attackers usually do not bother to understand and perform advanced transformation on the bytecode of legitimate apps.
.
prior work and motivation although considerable research has been conducted on clone detection unfortunately existing techniques are not suitable for detecting app clones on android markets.
we compare these techniques in table .
string based token based and ast abstract syntax tree based approaches have shown their scalability to handle millions of lines of code.
however they generate too many false negatives at handling type and or type clones characteristic .
pdg programdependencegraph basedapproaches capture the control flow and data dependencies between the code statements inside code fragments.
they can effectively detect type and type clones.
however pdgcomparison by graph isomorphism analysis is not scalable which cannot handle billions of opcodes in multiple markets characteristic .
three recent studies try to handle this problem.
gabel et al.reduce pdg comparisons to tree comparisons .
the time complexity of this reduction is o n nis the number of nodes in a pdg .
cbcd uses four optimizationsfor comparing two pdgs.
three of them assume that one pdg is small.
however pdgs of methods in a smartphone app could sometimes be very large.
the fourth optimiza tion needs extra effort of splitting and merging which still raises the bar substantially for handling billions of opcodes.
andarwin uses locality sensitive hashing lsh to find similar connected components of pdgs.
however when asingle operation is added or removed the lsh will change cannot keep it closer .
its false positive rate is .
for full app clone detection.
for core functionality clone detection its false positive rate could be very high.
hash based approaches are efficient to detect code fragments clones .
however they generate many falsenegatives at handling type and type clones.
kimet al.proposed a symbolic based approach to capture semantically equivalent procedures.
but simplifyingand comparing symbolic values are not scalable enough.
motivation insum string based token based ast based and hash based approaches are not accurate for detecting 1roy et al.
define four types of clones.
type identical code fragments except for variations in whitespace layout and comments.
type syntactically identical code fragments except for variations in identifiers literals types in addition to type s variations.
type copied code fragments with further modifications such as changed added or removed statements in addition to type s variations.
type code fragments that perform the similar computation but implemented through different syntactic variants.table comparison of literature work scalability accuracy string o l not accurate for type clones token o l not accurate for type clones ast o l not accurate for type clones pdg o n2 m2 robust for type clones pdg hash o nlogn can handle type clones fpr .
for full app clones.
for core functionality clones t h ef p rc o u l db ev e r yh i g h .
hash o m2 not accurate for type clones symbolic o s2 m2 can handle type clones based fpr centroid o c m accurate for type clones different implementations may have different time complexity.
we show the minimum one.
l the number of statements in all apps.
m the number of methods in all apps.
n the number of apps.
n the number of pdg nodes.
s the number of memory states.
c a small number c m .
based on our evaluation c .
.
fpr false positive rate.
app clones.
pdg based and symbolic based approaches are accurate but not scalable enough for app clone detection.
problem statements how to achieve accuracy and scalability simultaneously in detecting app clones on android markets?
.
insights and our approach our approach is based on two insights.
insight .
if a graph based approach can avoid graph isomorphismanalysis thenitcouldbecomebothscalable atcode fragment level and accurate in handling type and type clones.
we found that a dependency graph could be encoded in a particular way to avoid graph isomorphismanalysis while achieving the same clone detection goal.
insight .
to handle the billion opcode problem code fragmentslevelscalabilityisnecessary butnotenough.
scal able cross market clone analysis requires scalable pairwise comparison between all the methods i.e.
code fragments in multiple markets .
the complexity of this comparison is ashigh asc m mis the total number of methods .
we found that ideal complexity reduction is possible.
through such reduction we could reduce the complexity from o c2 m t o the level of o c m c m .
inspired by the insights we develop a three step approach to detect app clones as follows.
step geometry characteristic based encoding of dependency graph.
we develop a special encoding approach which can accurately compare graphs without using isomorphism analysis.
regarding characteristic of app clones if partof a pdg is sufficient to capture the type and type clones it is not necessary to encode the whole pdg.
based on our observation we found that we could encode the con trol flow graph cfg part of pdg.
we further use a geom etry characteristic called centroid of cfg to encode a cfg.
by comparing centroids instead of the whole cfgs we can achieve high scalability.
in most cases the information losscaused by encoding may bring inaccuracy.
however we are very surprised to find that centroids which are encoded using bothcfg structuresandopcodes are still very accurate.
we refer to the surprising finding as the centroid effect .
this observed property of centroids make cfg comparison both scalable and accurate.
step localized global comparison.
we found that centroids have another special property denoted monotonic2capturing type clones is obvious.176ity .
when a method changes a little its centroid will not change a lot.
that is a large difference between two cen troids shows that the corresponding methods are very un likely to be clones.
monotonicity can localize the crossmarket method comparison to a small number of methods which reduces the time complexity of pairwise comparison fromo c m t oo c m .
step core functionality based grouping.
different from most of other works we use an asymmetrical mech anism to group app clones.
for two apps as long as a large portionofthecorefunctionalitiesofapp1areclonedtoapp we assume that they are app clones no matter how many core functionalities in app are in app .
this mechanism could detect app clones that add lots of ads and libraries.
.
main contributions in summary we make the following contributions.
to the best of our knowledge this is the first work that takes a centroid based approach to clone detection.
accuracy we observe the centroid effect .i t h a s a surprising capability to distinguish cloned methods.
scalability we find the monotonicity property of centroid.it enables us to achieve o c m time complexity for pairwise comparison.
we designed and implemented the app clone detection system.
weevaluatedoursystemonfiveandroidmarkets.
the results demonstrate that our approach achieves highaccuracy and high scalability simultaneously.
.
overview we propose a new app clone detection approach that is both accurate and scalable.
using this approach we can de tect potentially app clones across different android markets in very short time.
.
a motivating example we looked into the bytecode in app clones.
due to the page limit we only show one example.
figure shows two corresponding methods in two app clones.
the apps have different names and are deployed in different markets.
theonly difference between the two methods is that one method in figure a adds a function call marked with an arrow to initialize an object touydig .
we viewed the code inside touydig and found that it will start several ads.
.
architecture motivated by the example in figure at a high level we use a bottom up approach to detect app clones across different android markets.
we compare different apps af ter performing to method level comparisons in multiple markets.
figure shows the architecture of our approach.
firstly after preparation including downloading all the apps from multiple markets and extracting methods from the apps we encode a projection form of cfg 3d cfg subsection .
to get the centroid geometry characteristicofa cfg.thiscentroidcouldbeviewed as the mass center of a 3d cfg.
secondly we measure method to method similarity using centroids in multiple markets subsection .
.
leveraging.class public lcom ladty gjump gstart .
method public oncreate landroid os bundle v invoke super p0 p1 landroid app activity oncreate landroid os bundle v invoke static p0 lcom gamegod touydig init landroid content context v new instance v0 ljava lang thread .......end method .class public lcom ladty gjump gstart .method public oncreate landroid os bundle v invoke super p0 p1 landroid app activity oncreate landroid os bundle v new instance v0 ljava lang thread .......end method a com.gamelin.gjump 17118600 0.apk from the anzhi market b jxty 1367648062215.apk from the dangle market figure two corresponding methods in two app clones are from different markets.
the first method has one morefunction call to initialize several ads.
the monotonicity of centroid based comparison we could reduce the complexity from o c2 m t oo c m mis the number of methods in multiple markets and c m .
thirdly we detect app clones by core functionality based groupingbasedonthemethod levelcomparisonresults subsection .
.
similar apps from the same authors companiesordevelopedusingthesameframeworks commonthird party libraries may not be real clones.
we use clone groups cgroups to separate the real app clones from similar but not cloned apps.
.
two properties of centroid the observed centroid effect and the inherent monotonicityproperty make our approach unique.
the centroid effect makes method to method comparison accurate and scalable in terms of method size.
the monotonicity property makespairwise comparison in multiple markets scalable in terms of the total number of methods.
centroid effect.
for any two methods in the android market they can form a method pair mp .ampis either clonedornot cloned .
the goal of method level comparison is to separate cloned pairs from not cloned pairs.
in other words the goal is to accurately pick cloned pairs out of thewhole set of mps.
we find that centroids have an amazing capability in this picking job.
on one hand if two methods in a mphave the same centroid this mpis almost certain to be cloned.
on the other hand if two methods in a mphave different centroids the mpis to be not cloned based on our experiments.
this means maximally of not clonedmps are missed.
we refer to it as the centroid effect .
this surprising and intriguing centroid effect enables us to achieve high accuracy without sacrificing scalability whendetecting cloned methods.
monotonicity .
besides the centroid effect we find that centroid has another property monotonicity when solving thisproblem whichgivesushighscalability.
whenamethodchanges a little its centroid will not change a lot.
this property of centroid makes the similarity between two methods monotonically correlate to the difference between two cen troids.
therefore after we sort the methods in multiple markets by their centroid values we only need to compare one method with its equal class in the sorted list.
we donot need to perform global comparison.
thus monotonicity enables us to decrease the time complexity of pairwise comparison without sacrificing accuracy.
.
can cfgs detect app clones?
pdg can effectively detect type type and type clones.
however in android markets type clones rarely177figure an architecture of our approach.
after extracting methods from android apps apkfiles we generate centroids for those methods.
then we perform app clone detection on the basis of centroids.
existinappclones.
themainreasonisthatattackersusually do not bother to understand and perform advanced transformations on the bytecode of legitimate apps.
type clones do not impact cfgs.
type clones will still keep the mainstructures of cfgs.
thus it is possible to use cfgs to detect clones on android markets.
compared to pdgs a clear advantage of cfgs is that cfg based method level similar ity checking is by nature much simpler and more efficient.
cfgs contain much less information than pdgs.
when cfgs are used one could be concerned with the possibility of resulting in a high false positive rate.
different methods may have the same cfg.
fortunately and surprisingly we find that the false positive rate could be broughtnear to zero by combining the cfg structures and the in formation of opcodes.
.
key results we fully implemented a prototype and systemically evaluated it on five real android markets.
accuracy ourapproachisveryaccurateatbothmethodlevel and app level.
scalability forfiveandroidmarkets including150 apps million methods and billion opcodes it takes less than one hour to perform cross market app clone de tection after generating centroids only once.
for a given method it takes less than .
second to find the method clones from the million methods.
.
our approach we use a bottom up approach to detect app clones.
based on the results of to method level comparisons we compare different apps and perform cross market analysis.
.
centroid of cfgs we use a vector called centroid to digest a cfg.
it is a geometry characteristic of a cfg.
.
.
physical model and challenge cfgis the control flow graph of a method.
each node in a cfg corresponds to a basic block in the method.
a basic block is a straight line piece of code with one entrypoint and one exit point.
jump targets start a block and jumps end a block.
directed edges are used to represent jumps in the control flow.
the code could be source codelike java assembling code like smali machine code like arm instructions or bytecode like dex dalvik executable .
remark.
physical model.
to digest and compare cfgs with both high accuracy and high efficiency we borrow the ideas of centroid from physics.
in physics especially when analyzing forces on a physical object people usually use thecenter of mass or the centroid to represent an object.
it issimpleforforceandmotionanalysissincepeopledonotneed to consider the structure of the object.
when two objects are identical their centroids are also the same.
when the structure of an object changes only a little its centroid willnot vary a lot.
similarity a cfg may also be viewed as an object.
nodes in the cfg could be viewed as balls.
edges in the cfg could be viewed as sticks.
so the whole cfgis very like an object with several balls connected by sticks.
since a centroid can be used to stand for the object it may be possible to use the centroid to stand for the cfg.
challenge.
the concept of centroid cannot be perfectly transferred from physics to method comparison.
in physics the structure of an object does not change.
so its centroid is deterministic.
but cfgs never count how long the edge would be.
thus strictly speaking a cfg is an object with several variable position balls connected by variable length sticks.
so its centroid is also variable which makes it notsuitable for comparison.
thus we cannot directly extract the centroid from a cfg.
we need an intermediate form of representation.
that is we need to project cfgs onto a dimensional space.
then the nodes would get coordinates and the lengths of edges would be determined automatically.
this new type of cfg is referred to as 3d cfg.
.
.
3d cfg android apps are written in java which is a kind of structured programming.
sequence selection or branch and repetition are three basic structures of structured programming .
we use these three basic structures to en code transform a cfg to a 3d cfg.
definition .
3d cfg a 3d cfg is a cfg in which each node has a unique coordinate.
the coordinate is a vector x y z .xis the sequence number in the cfg.
yis the number of outgoing edges of the node.
zis the depth of loop of the node.
thissequence number should make sure that the same node in a cfg will always get the same x coordinate.
then we could get a to mapping between a cfg and a 3dcfg.
we give each node a sequence number according to the order in which it executes.
the first node starts withnumber .
if a branch node has sequence number n w eg i v e n to the first node in the branch with more nodes.
if two branches have the same number of nodes we give n to the first node in the branch with more statements.
if the numbers of statements are also the same we give n to the first node in the branch whose first statement haslarger binary value.
we continue to give sequence numbers to the nodesin one branchuntilmeeting the immediate postdominator of the branch.
then we go to the other branchand continue to allocate sequence numbers until the last178figure a 3d cfg example.
figure a is a cfg.
we add a stop node to the end of cfg node f .
each node in the cfg corresponds to a basic block in the method.
figure b shows the 3d cfg.
node of the cfg.
we manually add a stop node to the end of the cfg.
return statements will flow to the stop node .
in this way every method has only one exit.
example.
figure a shows the cfg and the 3d cfg of a real method.
node a in the cfg is the starting node.
its sequence number is .
it has only one outgoing edge andit is not in any loop.
so its coordinate is .n o d e b is the second node to execute in this method.
it has two outgoing edges and it is also in a loop.
so its coordinateis .
b is a branch node.
its immediate postdominator is node e. the branch starting with c has two nodes.
the other branch does not have any node.
so thesequence number of node c is .
we add a stop node in theend.
its coordinate is .
.
.
centroid definition now we are ready to define the centroid of a 3d cfg.
a 3d cfg can be viewed as a set of nodes connected by edges.
it is similar to an object with several balls connectedby sticks in physics.
let s assume the weight of the ball is not zero and the weight of the stick is zero.
we define the centroid of a 3d cfg.
definition .
centroid ac e n t r o i d vectorcof 3d cfg is av e c t o r c x cy cz pi1 .cx summationtext e p q 3d cfg pi1pxp pi1qxq pi1 cy summationtext e p q 3d cfg pi1pyp pi1qyq pi1 cz summationtext e p q 3d cfg pi1pzp pi1qzq pi1 and pi1 summationtext e p q 3d cfg pi1p pi1q .
in the equation e p q is an edge in the 3d cfg.
this edge connects two nodes pandq.
xp yp zp is the coordinateofnode p. pi1pisthenumberofstatementsinthebasic blockofp.
itcorrespondstotheweightofa ballofa physical object.
after computing the centroid of the 3d cfg could be viewed as the mass center of the 3d cfg.
we use the 3d cfg in figure b as an example.
suppose the values of pi1ato pi1fa r e5 1a n d0 .
pi1 .
the value of xin centroid is cx .
.
in this equation in is the number of statements in node a. in 1i st h expart of the coordinate of node a. and in are similar.
in means that node b appears times in all edges in the 3d cfg.
similarly we can get vectorc .
.
.
.
by increasing the number of digits after the decimal point the precision canbe increased.
the definition of the centroid could be extended.
pi1is defined as the number of statements in a basic block.
we coulddefine pi1 i pi1 of invoke in the basic block .
so pi1iis impacted by the invokestatement in the method.
we give higher weights to invokestatement since android apps are highly dependent on the underlying framework apis.we can use pi1ito get the centroid vectorci.
by combining vectorcand vectorci we could decrease the false positive rate.
we can use other types of statements to further extend the definition of thecentroid.
in this paper we only use vectorcand vectorc ibecause they are accurate enough to distinguish millions of methods.
we use a centroid vector vectorc vectorci to represent a method.
.
.
monotonicity of centroids we leverage the monotonicity property of centroids to achieve high accuracy and high scalability.
this propertyincludes two parts p1 two same methods have the same centroid.
p2 when a method changes a little its centroid will not change a lot.
p1 keeps the correctness of the centroid approach.
if two of the same methods have different centroids a high false negative rate may result.
p2 makes the similarity betweenmethods m 1andm2monotonically correlate to vectorc1 vectorc2 .
when vectorc1 vectorc2 issmaller thesimilaritybetweentwomethods will be more.
when vectorc1 vectorc2 is larger there will be less similarity.
remark .
mostapproaches e.g.
hash basedandsymbolicbased donotmeetp2.
whenonlyonestatementischangedin a method we cannot estimate how much a hash sequenceor a symbolic value will change.
remark .
centroids are sortable.
based on p1 and p2 after sorting the centroids we only need to compare a cen troid with its neighbors but not all the centroids.
that is we are able to localize the global pairwise comparison to a small number of centroids which dramatically decreases thetime complexity of pairwise comparison.
.
method level similarity centroid difference degree cdd for two centroids cand c primeis defined as follows cdd vectorc vectorc prime max cx c prime x cx c primex cy c prime y cy c primey cz c prime z cz c primez pi1 pi1 prime pi1 pi1 prime .
ccdis the normalized distance for each dimension.
it can directly measure the difference between two centroids.
suppose there are two methods m vectorc vectorci andm prime vectorc prime vectorci prime .
methods difference degree mdd max cdd vectorc vectorc prime cdd vectorci vectorci prime .
mddcan be used to compare methods.
if two methods are the same mdd .
this meets p1 of monotonicity.
if a statement is changed inside a basic block the centroid vectorc will not change.
if we use the extended centroid such as vectorci we may find the difference.
changing the sequence of two statements inside a basic block does not change the centroid ofthemethod.
fromthedefinitionofthecentroid addingor removing a statement will make little impact to the centroid.ifmorechangesaremade vectorcwillalsochangemore.
thus the centroid approach meets p2 of monotonicity which makes it suitable for method comparison.
.
using centroid to detect app clones challenge method level similarity could be used to get similar apps.
however similar apps are not always appclones.
for similar apps they usually fall into the following three categories.
c1 apps from the same author c2 apps developed using the same framework or using common third party libraries e.g.
advertisement libraries c3 app clones.
we need to separate c3 from c1 and c2.
to address this challenge we first use application similarity degree to measure how similar two apps are us 179ing anasdthreshold and clone groups c groups w e separate category c1 c2 c3 apps from other apps in themarket we remove c1 by comparing public keys of apps we further remove c2 using a library whitelist.
then what remains is c3.
measure app level similarity.
app levelsimilarityismeasuredusingtheresultsofmethodlevel similarity.
definition .
application similarity degree for two apps a 1anda2 application similarity degree asd measures the extent to which a2contributes its methods to a1.
asd a1 a2 a2 a2 .
a1 is the number of methods in a1.a2 1is a set of methods.
for each method miin the set it meets the following two conditions mi a2 t h e r e is at least one m prime a1that satisfies mdd m prime m .
is a threshold for method level similarity.
a2 is the number of methods in it.
note that asd a1 a2 m a yn o tb ee q u a lt o asd a2 a1 .
we do not use a symmetrical definition.
this is because asdwill not change when an app clone adds lots of ads or libraries.
it is very common for an app.
for example we find an app named com.fgdfhghgh.turbofly 10255200 0 has at least ads.
current definition of asdcan detect this situation.
but a symmetrical definition of similarity between two apps cannot detect this.
using asd o n ec a n know the percentage of methods in a2that are cloned to a1.
get c1 c2 and c3.
a threshold can separate c1 c2 and c3 from the other apps in multiple markets due to this insight for any twoapps if they do not belong to c1 c2 c3 then their asd will not be high.
remove c1 and c2.
three observations of c1 and c2 are found.
for an app in android markets it uses the author s private key to sign each file and stores the corresponding public key inside the app for verification.
if apps are developed by differentauthors their public keys are different.
apps developedusing the same frameworks e.g.
phonegap or using common third party libraries directly store the libraries inside the app.
when two apps a 1anda2have very different sizes number of opcodes asd a1 a2 could be very high if the big app uses a large portion of the methods in the small app.
however this does not indicate app clones because thebig app usually supplies significant more functionalitiesthan the small one.
based on the three observations we use the concept of c groups to separate c3 from c1 and c2.
definition .
clone group a clone group c group is a set of apps.
it meets the following four conditions.
for any two apps a 1anda2 if max asd a1 a2 asd a2 a1 they are in the same c group.
is a threshold for asd.
for any app in android markets it is at most in one c group.
no two apps in the c group have the same public key.
we do not check which app is the original one.
due to the observation the size of small app is at least two thirds of the bigger app.
from condition in definition .
for any app a1in acgroup there is at least one app a2in thec group such thatmax asd a1 a2 asd a2 a1 .
from condition two c group can never share one apps.
from condition any two apps in a c group have different public keys.
basedon observation no two apps in the c group are from the same author.
so we can remove c1.
we do not use the app names or the author information in the market website sincethey can be spoofed.
asddoesnotcomparethemethodsinthelibrarywhitelist.
thus asdwill not be impacted by those libraries.
so c2 could be removed by a suitable .
we manually identify some known libraries e.g.
android support .
the full list is in .
if libraries outside the list make two apps be falsely viewed as app clones it is a false positive.
we evaluate the false positives in subsection .
.
.
.
implementation we implement a prototype to do preparation to generate centroids and to perform cross market app clone detection.
this prototype includes about lines of c code and lines of python code.
in the preparation step we use a python script to download apps apk files from five android markets.
then wetransform apk files to smali code using the tool called baksmali .
it is a disassembler for android s dex format.
we use this smali code since it could be assembled torunnable dex format again.
this code type is an attractive intermediate form for app clone.
we parse the smali code and generate 3d cfgs.
in the centroid generation step we give coordinates to the nodes in 3d cfgs and compute the centroids.
then we put the centroids into a database.
each record in the databasecorresponds to a method.
it contains the market name app filename classname methodnameandcentroids figure2 .
we generate smali code and centroids of different apps in parallel.
thus when more computers are used the analysistime will be decreased.
we use an incremental approach to update the database.
when a new app is added into the market we only need to generate centroids for methods inthe app and insert them into the database.
in the clone detection step we compare each method in one app with all the methods in other apps.
if one uses sqlqueries to do the comparisons we find that is very slow.
so we use in memory comparisons.
considering the two properties of centroids one can compare centroids after sortingthem.
so the time complexity for comparison will decrease fromo m t oo c m .mis the number of methods in multiple markets.
o m2 is the time complexity of traditional pairwise comparison.
cis the average number of methods with which one method needs to compare.
usually c m. based on our evaluation c .
.
.
evaluation we evaluated our approach on five typical third party android markets two american markets pandaapp and slideme two chinese markets anzhi and dangle and one european market opera .
we per formed a cross market analysis to find app clones.
ourexperiments were conducted on lenovo thinkcenters with core i5 .2ghz cpu and 4gb of memory.
.
cross market app clone detection the number of apps in c groups and the number of cgroups give a direct impression of the app clones in an 180figure histogram of the c group sizes on logarithmic scale.
droid markets.
two c groups never share the same app.
the threshold for application similarity degree impacts the results.
we use .
to perform the cross market app clone detection.
when .
the measured false positive rate through manual examination of randomlyselected c groups is subsection .
.
.
how many apps are in c groups?
when an app is in a c group it means that either this app is an app clone orat least one other app clones this app.
for the five markets we detected c groups and in total apps are in these c groups.
that is .
of the apps in all fivemarkets are in c groups.
among the apps apps are from the pandaapp market which takes .
of the apps in pandaapp.
apps are from the slideme market .
of slideme apps are from the anzhi market .
of anzhi apps are from the dangle market .
of dangle and apps are from the opera market .
of opera .
the ratio for the two chinese android markets anzhi and dangle are higher than others.
the ratio for the two american android markets pandaapp and slideme are on aver age.
the european market has the lowest ratio.
histogram of the c groups .
the number of apps in cgroups gives an overview of the app clones.
we use the histogram of c groups in figure to show the details.
the x axis shows c group size the number of apps in a c group .
the y axis shows the number of the c groups with a certain size.
from the figure we find that the majority of c groupsconsist of small number of apps.
of c groups contain two apps.
over of c groups contain less than apps.
only .
of c groups contain more than apps.
thelargest c group consists of apps.
how many c groups are cross market?
if a c group contains apps from different markets we say the c group is cross market.
after analyzing the c groups we find 779out of c groups are cross market.
that is of all the c groups are cross market c groups.
this shows that attackers would like to publish the app clones in differentmarkets for more benefits.
this also justifies the necessity to do cross market app clone detection.
figure shows the cross market app clone situation.
the five nodes are corre sponding to the five markets.
the number beside an edge shows how many c groups cross the two markets.
we find that the two chinese markets have more cross market c groups than other markets.112anzhi operadangle slideme pandaapp229398219 figure cross market app clone situation.
the five nodes are corresponding to the five markets.
the size of a node isproportional to the number of apps in a market.
two mar kets with deep color dangle and anzhi are chinese markets.
the market with light color opera is from europe.
the other two markets are american markets.
the number beside an edge shows how many c groups cross the two mar kets.
the thickness of an edge is proportional to the number.
.
accuracy to get good accuracy application similarity degree asd in subsection .
and its threshold must work well.
in other words they need to meet the following two requirements r1 asdneeds to measure the unbiased similarity r2 c groups should separate c3 from c1 and c2.
to satisfy r1 method level accuracy is essential.
so we measure the false positive rate and false negative rate at method levelin subsection .
.
and .
.
.
to satisfy r2 we manually verify the detected app clones false positive in subsection .
.
.
.
.
false positive rate at method level the centroid approachgives out similar method pairs.
we need to check whether they are real clones.
if not false positives occur.
checking not cloned pairs needs manual effort.
however even for a small testset 103apps with 106methods the number of similar method pairs usually exceeds .
if we randomly select a subset e.g.
pairs and manually check them it is not representative.
neither can wemanuallycheckallthepairs.
soanautomaticmechanism to approximate the number of real clones is necessary.
we use the longest common subsequence lcs of opcodes for approximating the number of method clones.
lcs is widely used in clone detection e.g.
and plagiarism detection e.g.
.
thus we use lcs to compute the sim ilarity between methods.
for two methods m 1andm2 w e view each method as a sequence of opcodes.
suppose l1and l2are the numbers of opcodes in m1andm2 respectively.
if the lcs between m1andm2contains lmaxopcodes the similarity between m1andm2islmax max l1 l2 .
we use the same threshold used in .
we select apps randomly from each android market to form a testset andr2500 .
then we use these apps to estimate the method level false positive rate mfpr .
the size of the testset is .2gb.
it contains methods and opcodes.
the curve in figure shows the estimated mfpr.
when the threshold subsection .
for method level similarity is less than .
mfpr .
when mfpr .
.
.
.
false negative at method level to get method level false negative rate mfnr we need to count how many method clones are not identified by ourapproach.
however we could not find such a benchmark181figure the estimated mfpr.
when mfpr .
.figure mfnr decreases with the increas of .
all the false natives are small cfgs with less than nodes .figure we manually check the app clones andr2500 testset re ported by our tool.
for android apps.
moreover generating method clones by arbitrarily transforming methods may not capture the characteristics of real clones on android market.
neither can we check all the method pairs in andr2500 testset over even using the automatic mechanism.
so how to use an unbiased way to get the ground truth of method clones which could also represents real clones on android markets?
to get the unbiasedmethodclones we firstget the ground truth of app clones by manually installing and comparing apps.
note that the results of app clones are not based on any method level analysis which will make our test moreunbiased.
secondly we manually compare the methods of these app clones and get the method clone pairs.
at last we use the centroid based approach to detect method clones.
suppose the number of method clone pairs manually verifiedby us ismpand the number of detected pairs is mp d.t h e n mfnr mpd mp.
to increase the possibility to find app clones we download apps from two aspects a1 similar names or a2 similar descriptions or keywords such as sudoku .
attackers would also like to use a1 and a2 to let users easily find the appclones.
afterdownloading installingandcomparingthe apps we got app clones in c groups with methods.
we randomly select methods and manuallyfind the method clones in the corresponding app clones.
after manually identifying method clones we randomly select pairs which serves as the unbiased ground truth.
figure shows the results.
from the figure we find that mfnr decreases with the increase of .w h e n t h e mfnr is .
.
when increases to .
the mfnris .
.
we checked these method pairs and found they areall small cfgs with less than nodes .
why the centroid approach has very low mfnr with controllable mfpr ?it has a unique capability to distinguish cloned methods.
based on the false negative test results figure we find that the method pairs with take more than of all the clone pairs.
when a method pair is detected as method clones the probabilitythat these two methods have the same centroid is or higher.
this is the reason why both mfnr andmfpr aresolow.
when isnon zero thenumberofclonedmethod pairs is surprisingly low less than .
this means when the centroids of two methods m 1andm2are different the probability that m1andm2are a cloned pair is less than .
so the centroid approach has the capability to distinguish method clones.
one main reason is that centroids keep part of structure information of cfgs.
we call it as the centroid effect .
it is a unique characteristic to make both the mfnr andmfpr low.
.
.
accuracy in detecting app clones we first use andr2500 as the training testset to get the suitable value of threshold for application similarity degree.
then we use this value to detect app clones in all the five markets and evaluate the false positive rate.
get from a training testset the value of impacts how well our approach separates app clones from other apps.
recall that we use c groups to perform this separation.
given the c grouping results if an app in a c group is not an app clone we call it a false positive.
so we can use the number of false positives to choose suitable .
we use andr2500 as the training testset and get cgroups by different .
for each app in the c groups we manually install it and look into the smali code.
then wecompare it with other apps in the same c group.
if it is notreally an app clone a false positive occurs.
figure shows the results.
for each the left bar shows the number of app clone detected by our tool and the right bar shows thenumber of app clones after manual check.
from the figure the number of false positives decreases with the increase of .
but when increases some manually confirmed app clones can no longer be detected.
we choose .
to detect app clones in all the five markets as the number of false positives and false negatives are both small at this point.
false positive rate on five android markets to get the ground truth of app clones we manually check the apps in c groups.
based on our manual check we confirmed the apps in the c groups.
for the five markets ourapproach detected c groups and in total apps are in these c groups.
it is not feasible to manually check all of them.
instead we randomly select of the c groups and then manually check each app in the c groups.
for any app in a c group if it is not really an app clone we view the whole c group as a false positive which is very conservative.
after manually checking the apps in the c groups we did not find any false positive.
remark in total there are c groups.
if the remaining c groups are checked based on the following ob servation the false positive rate should also be around zero.
false positives come from two aspects wrongly detected method clones.
since apps usually have many methods tosupport various functionalities impacting the results of app clones needs a large number of wrongly detected clones.
due to the low false positive rate .
at method level of ourapproach for a method with methods only method on average is wrongly viewed as clone.
this is almost impossible to impact the result of app clones.
commonlibraries.
if two apps use common libraries and the num 182figure number of occurrence vs size per app.figure number of occurrence vs number of opcodes per appfigure number of occurrence vs number of methods per app figure time to compute centroids.
besides linearly increasing with the number of apps the time also linearly de creases with the number of computers.figure time to perform app clone detection.
this time is almost linear with the number of apps.figure time to perform clone detection for new apps and time to update the market database.
ber of the methods in the libraries is far more than that of the core functionalities false positives will occur.
this usually happens when an app is very small and it uses a lot of libraries e.g.
ads .
however we whitelist popularlibraries which makes the possibility very low.
moreover when we add two apps into a c group the size of small app cannot be too small at least two thirds of the bigger app .
this will further decrease the false positive rate.
remark we did not attempt to measure the false negative rate since it is not feasible to get the ground truth ofapp clones i.e.
manually performing to comparison forall the apps .
however we compare the results with others and find our approach detects more app clones.
.
scalability we measure the scalability of our approach from the following three aspects the scale of the five markets the per formance on cross market app clone detection and updating.
.
.
dataset statistics we analyze all apps in the five markets to gain a general understanding of our dataset.
figure to show the distributionof the sizes of apk files in megabytes the distri bution of opcodes per app and the distribution of methods per app.
all these distributions are skewed to the right.
about of apps are less than 13mb and of apps are less than 3mb.
about of apps have opcodes less than and have methods less than .
the total file size of these apks is 869gb.
the total number of opcodes inall apps is approximately billion.
the total number ofunique methods in all apps is about million.
.
.
performance on cross market app clone detection whole market app clone detection can be divided into two steps centroid generation and clone detection.
centroid generation.
the time needed to generate the centroid depends on the number of apps in the market.
thisstep can be done in parallel.
we use computer comput ers and computers to measure the time.
figure shows the results.
from the figure we can see that the time linearly increases with the number of apps in the market.
the time also linearly decreases with the number of computers.if we use computers we can generate centroids for the whole market in about hours.
clone detection.
the performance of clone detection depends on the number of apps.
figure shows the timeto detect app clones.
from the figure we find that the time almost linearly increases with the market size.
it takes less than an hour to detect app clones on the five whole markets with apps.
what is the value of c in the time complexity o c m ?
ourapproachdetectsappclonesusingtheresultsofmethod level comparison.
different from other approaches the property monotonicity of centroid localizes the global pairwise comparison to a small number of methods which dramati cally decreases the time complexity of pairwise comparison.
the smaller the value of c the less time is needed for comparison.
in this cross market app clone detection process we record this value.
the average value of cis .
.
that is for each method our approach on average only needs to compare it with less than other methods instead of million methods.
this is the reason why we can process apps apps within one hour.
.
.
performance on clone detection for new apps and market updating adding new apps is very common in android markets.
after a new app is uploaded to the market it should first be checked whether it is an app clone.
in this process it will be compared with all the apps in the whole market.
if it is not cloned it can be added to the market and become available for downloading.
both the app checking time and database updating time should not be long.
we evaluate the performance using real data.
for the centroid database we use the current database of all the five android markets.
for the newly added apps we download them from another third party market 1mobile .
it is a183popular market in the u.s. considering the size of the new apps may impact the time we divide them into five groups.each group has five apps with similar sizes of apk files.
figure shows the results.
the upper curve shows the average app checking time for the group.
this process includes the time of generating smali files getting centroidsand detecting clone status of the new apps.
from the figure it takes about seconds to finish these steps on average.
we also find the time is not linear to the apk file sizes.
thismay be because resource files take some spaces in the app.
considering there are more than methods in each app on average it takes less than .
second to find the methodclones from million methods.
the lower curve shows the database updating time which is less than .
seconds.
.
limitations centroid based approach has several limitations.
firstly although our approach is extremely effective to detect type type and type clones it may not be effective to detect type clones.
type clones require the attackers to understand the code.
type and clones are effectivefor attackers to achieve their goals.
they would probably not pay the effort to understand and perform the advanced transformation on the bytecode of legitimate apps.
actually we did not find type clones on android markets.
secondly adding one node in smallcfgs with less than nodes may change the centroids a lot attackers may not deleteanodefromcfgssincetheywanttokeeptheoriginal functionalities .
but for bigcfgs with nodes or above centroid based approach is effective.
based on our evalua tion smallcfgs take about .
of all the opcodes in all the five markets.
we believe we can ignore them.
thirdly anappclonecouldevadedetectionbyonlycloning asmallnumberofmethodsintheoriginalapp partial cloning .
we note that there are no general solutions for handling partial cloning.
however core methods i.e.
functionalities need to be reused.
otherwise the cloned app may not workproperly.
one solution to detect partial cloning is to find the core methods in the apps and only compare these methods.
the core methods could be chosen by their sizes such as the number of nodes in the cfgs.
fourthly if an app clone has far more opcodes than the original app we may not detect it due to the condition inthedefinitionofc group .
thisusuallyhappenswhensomeapps are developed on the basis of open source apps e.g.
sample apps from android sdk .
if they have lots of new functionalities we should not view them as clones.
an ex ception is that an app is cloned by adding lots of ad libraries.
however the whitelist with popular libraries greatly increases the possibility to detect the app clones.
it could alsobe extended.
for the unpopular libraries attackers would probably not add lots of them at the same time.
.
related work centroid basedcloningdetectionismainlyrelatedtothree bodies of work as follows.
clone detection.
string based approaches view each line of source code as a string and detect clones based onmatching the sequence of strings.
token based approaches parse a program to a sequence of tokens and compare these tokens to find clones.
ast based approaches construct the abstract syntax trees ast from two programs and detect clones by finding the common trees.
lee et al.
introduced a multidimensional token level indexing using an r tree on deckard s vectors .graph based approaches generate cfgs or pdgs from programs and compare them by subgraph isomorphism.
kim et al.proposed a symbolic based approach to capture semantically equivalent procedures.
detailed analysis of these approaches is in subsection .
.
detection of similar android apps.
juxtapp detects code reuse in android apps by feature hashing.
droidmoss uses a fuzzy hashing technique to detect app clones.
dnadroid detects android app clones by performingsubgraph isomorphism comparison on pdgs.
androguard uses several standard similarity metrics to hash methods and basic blocks for comparison.
piggyapp extracts var ious features such as the requested permissions of primarymodules to detect piggybacked apps.
andarwin splits pdgs to connected components and extracts a vector which contains the number of specific types e.g.
binary operation type for each components.
then it uses locality sensitive hashing to find similar vectors as code clones.
its false positive rate is .
for full app clone detection.
for corefunctionality clone detection its false positive rate could be very high.
clan detects related java apps using api calls which could be potentially applied to android apps.
software birthmark.
a software birthmark is a unique characteristic of a program that can be used to determine the program s identity.
birthmark can be divided into twocategories static birthmark and dynamic birthmark.
static birthmarks areusuallythecharacteristicsinthecode that cannot easily be modified such as constant values in field variables a sequence of method calls an inheritancestructure and used classes.
lim et.al proposed an ngram flow path birthmark.
the bytecodes in ncontinuous basic blocks are concatenated to construct a possible flowpath.
to compare two flows the semi global alignment algorithm is used.
to compare two birthmarks i.e.
two sets of flows a maximum weight matching is performed on theset of all pairwise comparisons of those flows.
the matching sum is used for measuring the similarity.
a centroid could be viewed as a novel static birthmark.
dynamic birthmarks are usually as follows whole program path birthmark sequence of api function calls frequency of api function calls birthmark call sequences to java standard api system calls birthmark and invariant value sequences birthmark .
they need to dynamically analyze the program which is not suitable for cross market app clone detection.
.
conclusion wepresenta centroid based approachtodetectcross market app clones in five whole android markets.
the observed centroid effect and the inherent monotonicity property enable our approach to achieve both high accuracy and scalability.
it takes less than one hour to perform cross marketapp clone detection.
regarding future work more analyses of the detected app clones are yet to be done.
.