characterizing and detecting resource leaksin android applicationschaorong guo jian zhang jun yan zhiqiang zhang yanli zhang state key laboratory of computer scienceinstitute of software chinese academy of sciences beijing china guocr zj zhangzq zhangyl ios.ac.cn technology center of software engineeringinstitute of software chinese academy of sciences beijing chinayanjun otcaix.iscas.ac.cn university of chinese academy of sciences beijing chinaabstract android phones come with a host of hardwarecomponents embedded in them such as camera media playerand sensor.
most of these components are exclusive resourcesor resources consuming more memory energy than general.
andthey should be explicitly released by developers.
missing releaseoperations of these resources might cause serious problems suchas performance degradation or system crash.
these kinds ofdefects are calledresource leaks.
this paper focuses on resourceleak problems in android apps and presents our lightweightstatic analysis tool calledrelda which can automatically analyzean application s resource operations and locate the resource leaks.we propose an automatic method for detecting resource leaksbased on a modified function call graph which handles thefeatures of event driven mobile programming by analyzing thecallbacks defined in android framework.
our experimental datashows that relda is effective in detecting resource leaks in realandroid apps.index terms android apps resource leak static analysis i. introductionto enrich the user experience android phones come with ahost of hardware i o components embedded in them such asmedia player camera and sensor most of which are exclusiveresources or resources consuming more memory or energythan general.
these resources require explicit management.absence of their release operations results inresource leaks which may lead to performance degradation e.g.
huge energyor memory consumption or even system crash.unfortunately resource management bugs are common inandroid programs for which a number of reasons should beresponsible.
firstly unlike traditional programming languages the android framework transfers the burden of resource man agement to the developers but the developers might omita call to release a resource on the assumption that an droid framework would release the resource automatically.secondly developers tend to focus on the functionalities the performance related problems will not be their concerns.and they often don t conduct performance testing beforethey release the applications.
thirdly programmers need tounderstand all relevant api contracts on which they couldeasily make incorrect assumptions.
finally even a scrupulousprogrammer can easily fail to release all resources along allpossible invocation sequences of event handlers.in this paper we focus on resource leak problems in an droid applications.
we have built a lightweight static analysistool relda which can automatically analyze an application sresource operations and detect the missing release operationsto help programmers identify their root causes.
klocwork and findbugs are static code analysis tools which provideanalysis of java source code or java bytecode respectively.klocwork is a commercial software that delivers comprehen sive source code analysis solution and complete codebaseinspection for c c c and java.
it hasn t provided analysisof bytecode so far.
it inspects a few android related re sources which are not properly released after use such asmedia player and camera.
findbugs is a defect detection toolfor java that uses static analysis to look for bug patterns suchas null pointer dereferences infinite recursive loops bad usesof the java libraries and deadlocks.
it also adds detectors forandroid specific coding but the detectors findbugs providesonly inspect unclosed cursor instance and unclosed stream ofandroid .
compared with these works our work providesa strategy that focuses on android platform related resources with android platform and language features considered.
ourtarget specific tool is more comprehensive and precise.our analysis focuses on three kinds of resources ex clusive resources memory consuming resources and energy consuming resources.
their common characteristic is that theyshould be released explicitly as specified in the android apireference1.
we propose an automatic solution to detectingresource leaks based on a modified function call graph fcg analysis which handles the features of event driven mobileprogramming by analyzing the callbacks defined in androidframework.
we first collect a near complete resource tableafter examining through the relevant classes extractedfrom all the classes in the android api reference.
thetable includes all the resources that the reference requiresmanual release.
and then we describe how we automatically1 c ieee ase palo alto usa389detect resource leaks in android apps by analyzing theirbytecode.
finally we provide experimental data showing theeffectiveness of our tool in detecting various resource leaks inreal apps.the rest of this paper is organized as follows in section ii we present our resource leak analysis and detection techniqueand illustrate how it works.
experimental results are shownin section iii.
section iv discusses the related works.
insection v we give the conclusions and discuss the futurework.ii.
methodologybefore making further discussions we first give the defini tions of three terms used in this paper isolated entry points functions that are not invoked byany other function in the program.
callbacks handlers methods invoked when a user eventis triggered or a certain system state arrives which is afeature of event based programs.
children functions which are invoked by a certainfunction.in preparation for our study we collected some leak prob lems in android apps from mobile app forums and discussiongroups and we found that many users complained aboutproblems of memory shortage energy drain and applicationcrashes most of which are relevant to the use of camera or sensor components .
then we checked the an droid api reference about these components and categorizedthe resources into three classes if a resource is an exclusive resource a missing releaseoperation will cause other applications endless waitingfor it.
for the camera component the manual says call release to release the camera for use by otherapplications.
applications should release the camera im mediately in onpause and re open it in onresume .
as for the media player component the referencesays it is recommended that once a mediaplayerobject is no longer being used call release immediatelyso that resources used by the internal player engineassociated with the mediaplayer object can be releasedimmediately.
this is a memory consuming resource which consumes more memory than general resources.
another kind of resources are energy related resources.for example sensormanager lets you access the device ssensors through registering it to the sensorservice.we should cancel the registration for the sensormanagerobject when we don t need it.
as the manual says aboutthe sensor always make sure to disable sensorsyou don t need especially when your activity is paused.failing to do so can drain the battery in just a fewhours.
note that the system will not disable sensorsautomatically when the screen turns off.
in this paper we aim to detect resource leaks i.e.
situationswhere resources should be released manually by the developerbut he she failed to do so.
figure provides a high level fig.
.
high level overview of our systemoverview of our approach.
it consists of several key parts.
wefirst disassemble an application to get the dalvik bytecode using reverse engineering technique.
then we traverse thebytecode in sequential order to construct the fcg whichcontains analysis of resource operations and callbacks definedin the android framework.
finally we use depth first search onthe fcg and analyze the class hierarchy to identify unreleasedresources.a.
key resource operations1 extract relevant classes we downloaded the androiddeveloper reference manual and searched the summary sectionof methods of all the classes in reference folder withthe modification of the keywords table i e.g.
the keyword unregister is modified to the style unregister whichmeans matching any member method whose name starts withthe word unregister .
for example unregisterlistener insensormanager is one such case.table ikeywords tomatchresourcereleasemethods ofclassesabandoncancelclearcloseenddisablefinishrecyclereleaseremovestopunloadunlockunmountunregister2 check relevant method descriptions for all the 313classes which contain a member method whose name startswith one of these keywords we manually check the detaileddescription of all these methods to figure out if the requestedresource should be released manually.
after that we readthrough the training section of relevant classes manually andfigure out the appropriate event routine e.g.
onpause of activities to release these resources.
and we finally got 65resource operations which involve resources that need to bereleased manually.
these frequently used are summarized intable ii.b.
event handlersthe features of event driven mobile programming makeour task complicated.
in particular due to the large numberof callbacks used by the android framework android appsessentially expose a set of callbacks to the system instead of asingle main method .
our approach leverages the knowledgeof how these callbacks are defined in android to identify them.we divide them into two categories 390table iisummary offrequently usedresourcerequest andreleaseoperationsresource packageresource nameresource operationssuggested place to releaseandroid mediaaudiomanagerrequestaudiofocus abandonaudiofocus onpause audiorecordnew release onpause onstop mediaplayernew release create release onpause onstop start stop android hardwarecameralock unlock open release onpause startfacedetection stopfacedetection startpreview stoppreview sensormanagerregisterlistener unregisterlistener onpause android locationlocationmanagerrequestlocationupdates removeupdates onpause android ospowermanager.wakelockacquire release onpause vibratorvibrate cancel ondestroy android net wifiwifimanager.wifilockacquire release onpause wifimanagerenablenetwork disablenetwork ondestroy callbacks triggered automatically when a certain systemstate occurs according to android framework s defini tion.
we call them system handlers system callbacks for short.
callbacks triggered by user events.
we call them userhandlers user callbacks .
system handlers instead of a traditional main method of some kind android apps contain one or more componentsdefined in its manifest file.
each component can potentiallydefine multiple entry points.
figure shows the importantstate paths of an activity .
the colourless round rectanglesrepresent callback methods you can implement to performoperations when the activity moves between states.
theentire lifetime of an activity happens between the first calltooncreate bundle through to a single final call toondestroy .
the visible lifetime of an activity happensbetween a call toonstart until a corresponding calltoonstop .
the foreground lifetime of an activity hap pens between a call toonresume until a correspond ing call toonpause .
theoncreate onstart andonresume callbacks are defined entry points of anactivity the exit points areonpause onstop andondestroy .apart from them there are a large number of callbacksdefined in the android framework.
app executions oftenpass through the framework to emerge elsewhere in the app.for a concrete example consider thejava.lang.threadclass.
therun method is a common callback definedinjava.lang.thread.
a developer can simply extendthis class implement therun method and then call thestart method to schedule the thread.
but when weanalyze the code within the app therun method does notappear to be reachable from thestart despite the factthat after thestart method is called control flow goeseventually to therun method during the runtime figure .permission examining tool woodpecker leverages thesewell defined semantics in the android framework apis tolink these two methods directly in the control flow graph cfg resolving the discontinuity in the cfg construction.
fig.
.
activity lifecycle diagramand it applies this strategy to a number of callbacks e.g.
message queues gps .
according to our studies there arelots of other callbacks defined in the android framework.for example the camera service will initiate a series ofcallbacks to the application as the image capture progresses.2theshuttercallback occurs after the image is captured.this can be used to trigger a sound to let the user know that theimage has been captured.
therawcallback occurs when theraw image data is available.
thepostviewcallback occurswhen a scaled fully processed postview image is available.thejpegcallback occurs when the compressed image isavailable.
and a programmer can also define callbacks by2they are passed as arguments within the takepicture method of the cameraclass.391fig.
.
a discontinuity in the control flow introduced by the androidframeworkimplementing user defined interfaces.
these callbacks will beinvoked automatically without user interactions so we classifythem as system handlers too.in our approach we maintain a list to record the registrationof all callbacks except for user callbacks as described below then connect it to the callback itself when constructing fcg.
user handlers the other kind of events is usually anui event.
android provides two mechanisms handling them mechanism based on registered callbacks and based on eventlisteners which are also a kind of callbacks .
these eventscontain click and touch events e.g.
onclick onlongclick ontouch ontouchevent keyboard events e.g.
onkey statechange events e.g.
onfocuschange onitemselected and soon.
their common characteristic is that whether it will becalled or not is determined by the user s action.
for example in functiononcreate we register two listeners respec tively for button a and button b and then request a resourcein theonclick method which is triggered by a click onbutton a and the corresponding release operation is carriedout in anotheronclick which is controlled by button b.this is a potential resource leak because if the user just clicksbutton a and the app is interrupted by another activity startedby the user or system like switching to the home screen oran incoming call then the resource requested before is notreleased.
so in our scheme we don t connect the registrationof the user callback to the callback itself which indicates anormal case the user clicks on button a to request a resource then clicks on button b to release the resource .
so these userevent functions are still entry points in our fcg.c.
fcg constructionwithin an application we inspect all the resource operationsto collect the potential resource leaks it contains.
for a localresource resource declared in a function we suppose thedeveloper will release it when the method finishes.
for a globalresource resource declared in a class outside all the functions it should be released on all the paths that can be reachedfrom its request point to the end of path or in the exit pointfunction for activity or service class or its inner class or in atleast one callback of all interfaces implemented by the classes as described in figure .utrepresents user handlers strepresents system handlers andnrepresents normal functions.
fig.
.
feasible invocation orders of event handlersthe round rectangle in green represents a place to request aresource and the rectangle in orange represents a place torelease a resource.we use a free reverse engineering toolandroguard to generate standard dalvik bytecode of an app.
then wetraverse the bytecode in sequential order.
in the bytecode itis very easy to know the function calling relationships withinan app according to the invoke instructions especially formethods with parameters.
the definition and the invocationof a method have the same parameter declaration while inthe source code the formal parameter in method definitionis not the same as the actual parameter in method invocation.and for each resource request and release operation we checkinstructions starting with iget object and iput object tofind the resource object s reference then we use the methoddescribed in section ii b to handle event driven calls inandroid applications which adds links for system callbacks.finally we obtain an entire fcg.figure is a code snippet of an activity and figure 6shows an example fcg of the activity.
in figure theround rectangles in orange represent functions of the activity.the solid arrows represent calling relationship betweencalling functions and called functions.camera.open andmcamera.release are resource request andresource release operation respectively.oncreate onpause onshutter andonpicturetaken are system callbacks onclick is a user callbackandsetonclicklistener takepicture andmcamera.takepicture are normal functions as wedescribed in figure .d.
resource leak summary and reportthrough the above process we build the fcg of anapp.
and we obtain theentry points list whoseitems are functions which are not invoked by any otherfunction each function sop list whose items are either3921.public class mycamera extends activity .
public void oncreate bundle savedinstancestate .
mbutton.setonclicklistener new button.onclicklistener .
public void onclick view v .
mcamera camera.open .
takepicture .
.
.
.
private void takepicture .
mcamera.takepicture shuttercallback .
rawcallback jpegcallback .
.
private shuttercallback shuttercallback new15.
shuttercallback .
public void onshutter .
.
.
private picturecallback rawcallback new20.
picturecallback .
public void onpicturetaken .
.
.
private picturecallback jpegcallback new25.
picturecallback .
public void onpicturetaken .
.
.
protected void onpause .
mcamera.release .
.
fig.
.
code snippet of a sample appresource operations or child function calls and each function schildren list whose items are functions which areinvoked by this function .
the resource summary algorithm summarized by algorithm takes them as the input.
ituses depth first search to analyze the resource operationsand child function calls in all the entry points.
during thesearching process we use a few extra structures to markfunctions that have been analyzed before to avoid endlessalgorithm 1resource summary of all entry pointsinput entrypointslist all functions oplistandchildrenlistoutput all entry points reslistfor eachentrypoint2entrypointslist ifisresrelease opitem thenifrequest opitem 2entrypoint.reslistthenentrypoint.reslist.delete request opitem elseentrypoint.reslist.append opitem fig.
.
an example fcg of an activityloop when dealing with recursions and loops.
we traverseeach recursive function or loop just once.
the process willeventually generate resource summaries of all entry points.and we also provide a series of ui commands that can beused to query extra information.
you can input any functionyou are concerned with e.g.
oncreate to check theresource operations in this function and you can also query thecalling sequences between two functions by simply providingthe function s label.by observing the resource summaries of entry points wefind lots of system and user handlers exiting in inner classesof an activity or service.
inner classes are characterized by in dalvik bytecode which can be easily identified.
asfor resource operations in an activity or service or its innerclass if they are not released as soon as they are not needed we extra check if a resource request is released in exit pointfunctions e.g.
onpause of its corresponding activities orservices.
for resource requested in an ordinary class we scanall interfaces it implements.
then we check if the resourceis released in at least one callback of each of them.
asdescribed in figure the programmer requests audio focusin classassistantttsplayerand abandons the focusin system callbacks oncomplete andonerror ofall interfaces implemented byassistantttsplayer.
it isthe same situation when dealing with camera which usuallyimplements thesurfaceholder.callbackinterface.
wecan release the camera resource in itssurfacedestroyedcallback.iii.
eva l uat i o nwe now present experimental results of resource leak de tection using our tool relda.
we first present a summary oftable iiiresourceleaks in55 demoappsappunreleased resourcerequest methodmywifiwifimanagerenablenetworkmycameracameraopenmyaudiomanagermediaplayercreatemyseekplayermediaplayercreate393table ivsummary ofexperimentedapps withresourceleakappsbug descriptionrefagenda widget .
.17powermanager.wakelock is not released in several classes in packagewidget k9mail .006powermanager.wakelock is not released inmessagingcontrollerpushreceiver osmdroid r751openstreetmapactivityshould enable disable location updates inonresume onpause baidu map .
the listener for sensormanager is not released in packagear it is also not released in all cases of received messages inoncreate baidu voice assistant .
audio focus is not released inmusicservice baidu ime .
.
.
camera requested incaptureactivityis not released google email .
.
.
in several activities in packagegm contentproviderclient is not released .public class assistantttsplayer implements2.
ttsplayercompletelistener ttsplayererrorlistener3.
.
maudiomanager audiomanager mcontext.getsystemservice audio .
maudiomanager.requestaudiofocus .
public void oncomplete .
.
maudiomanager.abandonaudiofocus .
.
public void onerror int paramint .
.
maudiomanager.abandonaudiofocus .
.
fig.
.
release resource in one callback of each interfacethe detection results on android apps and then discuss thecauses for the reported leaks and overhead of the scheme.a.
experiment setupwe conduct our experiments in the following steps first we collected the source code of apps from anandroid application development book and realapp installers .apkfiles from google play3or fromindividual official app sites.
for the .apk installers we decompile the apps from theinstallers to java source code using dare andsuccessfully got decompiled source code4 decom pilation failed for the remaining apps .
thus we got55 98apps with source code or decompiled sourcecode.b.
resource leak reportsour experimental subjects are the .apk installers.
reldatakes them as input.
after it finishes running each app sresource leak items are reported as well as log files thatrecord where each resource is requested and released.
for 55apps in the development book all the leaks reported by ourtool have been confirmed manually by checking their sourcecode directly.
these resource leaks are about different kindsof resources but the patterns are similar.
the developer triesto release resources in user handlers which are not necessarilyinvoked before the app exits.
the resource leak report is shownin table iii.
of them are top free apps and most are used daily.4not all app installers could be transformed into meaningful source code especially the ones that have been obfuscated during compilation using toolslike proguard .for the apps that we successfully get decompiled sourcecode of them have one or more resource leaks andthere are reported leaks in total.
table iv presents typicalresource leaks we found in several popular apps includingconfirmed instances of resource leaks in osmdroid agenda widget and k9mail as well as some instancesthat are not confirmed entries with e.g.
resource leaksin google email and baidu maps .5the whole resource leaks summary are listed in table v. weuse a standalone graphical utility jd gui to display javasource codes of these .class files obtained by dare.
for theserelatively large apps it is not possible to manually enumerateall possible paths to verify the correctness of the tool dueto exponential explosion.
in our evaluation for each of theresource leaks reported by relda we check the decompiledjava source code manually if it s a real leak.
by analyzingsome relatively small apps and possible shortages of ourmethodology we infer certain patterns e.g.
if else cases ofreceived messages that may incur false negative a resourceleak relda doesn t report but it really is .
so we check thesepoints of decompiled java source code additionally.table vsummary of10 mostcommonresourcesunreleased inappsunreleased resourcerequest methodappcountmediaplayernew create1124mediaplayerstart815velocitytrackerobtain711powermanager.wakelockacquire612wifimanagerenablenetwork28vibratorvibrate510contentresolveracquirecontentproviderclient22androidhttpclientnewinstance22sensormanagerregisterlistener24audiomanagerrequestaudiofocus141the third column represents the number of apps containing unreleased resources.2the fourth column represents total number of the unreleased resources.we classify the leaks into three categories a true positive tp resource leaks reported by the tool are also foundmanually by checking the source code b false positive fp leaks reported by the tool but we do not find manually c false negative fn leaks we found manually but the tooldid not report as we mentioned above.
table vi summarizesthe results.
explanations of each entry will be discussed insection iii c. we found leaks in the tp set in the5we have reported the relevant bugs to google and baidu but have not yetreceived any feedback.394fp set and in fn set.
so the observed analysis precision is88.
and the recall is about .
.table visummary ofleaksbreakdowncauses of leakstotal92released resources in user handlers27forgot to release a resource19didn t release in callbacks of all interfaces14released in improper event routine e.g.
ondestroy 13false negatives8false positives11c.
resource leak classification by causes1 released resources in user handlers which may notbe invoked the largest category of leaks are of thiskind.
in this case the developer tries to release resources inuser handlers which are not necessarily invoked before the appexits.
in addition to the leaks found in the development book this kind of leaks also appears in real apps we downloadedfrom android market.
for example in baidu map .
.
theprogrammer tries to release locationmanager and audioman ager resources only in user handlers e.g.
onkey onclick .
agood suggestion is to release them in their corresponding exitpoint function as we point out in table ii.
forgot to release a resource the cause of theseleaks is that the programmer simply forgot to release a re quested resource throughout the code.
although it seems like asimple mistake this does happen in real apps.
for example ingoogle email .
.
contentproviderclient is not releasedin several activities in packagegm.
but all the resource leaksabout contentproviderclient have been repaired in googleemail .
.
.
in baidu map .
and baidu map .
theprogrammer forgot to release the listener for sensormanagerin packagear augmented reality .
the resource leak hasbeen repaired in baidu map .
.
.
failed to release a resource in callbacks of all theimplemented interfaces there are many different exe cutable paths invoked by different user actions and hardwarestates which depend on the external environment.
even acareful programmer can easily fail to release all resourcesalong all possible invocations of event handlers.
for resourcerequested in an ordinary class we extra check if it s releasedin at least one callback of all interfaces implemented bythe classes.
as we described in section ii d. in youku3.
the programmer only tries to close powermanag er.wakelock resource object in callbackonfinished of classdownloadlistenerimpl.
this is not enough.the suggested modification is to close the resource inoncancel andonexception too.
didn t properly understand the lifecycle of androidapps in this case programmers release resources onlywhen the app finally exits inondestroy of the activity.in android an app activity once started is always alive.
whenthe user exits any app android saves the state of the appand passes it back to the app if the user returns to it.
the1.public class mapactivity extends activity .
protected locationlistener mlistener .
protected locationmanager mmanager .
public void oncreate .
get a reference to system location manager6.
mmanager getsystemservice location service .
mlistener new locationlistener .
public void onlocationchanged location loc .
... .
.
.
gps listener registration13.
mmanager.requestlocationupdates gps ... mlistener .
.
public void ondestroy .
gps listener unregistration17.
mmanager.removeupdates mlistener .
.
fig.
.
resource leak in osmdroid application issue app is only completely killed when the phone is critically lowon ram or when the app kills itself.
this methodology isused to reduce the startup time of the app and to maintain itsstate.
this essentially means that the app may not actually bedestroyed for a very long period of time.ondestroy isonly called when the app component is about to be destroyed but many app developers try to release the requested resourcesin theondestroy callback instead of inonpause .as a result once an app with this leak is started the phone willfinally exit when it is running critically low on memory whichmay take a long period of time .
for a concrete example in open source project osmdroid our tool reported aresource leak resulted from the delayed unregistration of thelocation listener .
figure gives a simplified versionof the concerned code.
whenmapactivityis launched itgets a referencemmanagerto system location manager andregisters a location listenermlistenerwith the androidsystem line mlisteneris registered to listen to userslocation changes lines .
if the android system plans todestroymapactivity lines mlistenerwouldbe unregistered lines .
if osmdroid s users switch theirandroid phones to another application mapactivitywouldbe put to the background not destroyed and the registeredmlistenerwould still keep running for location sensing.all location data would be used to refresh an invisible map.then a huge amount of energy and memory would be wasted.
false negatives without considering intra procedural flow analysis certain patterns of programstatements incur false negatives e.g.
if else cases of receivedmessages.
according to our case studies false negativesregularly occur when handling received message problems.in this case a resource should be released in all cases ofreceived messages.
but our tool will not report a leak aslong as it s released in one case of them.
to solve thisproblem we modify our tool to present directly informationabout the resource operations in all cases and whether aresource is released in all cases.
we find several real appshaving this kind of resource leaks.
for example baidumap .
the programmer tries to release a registerlistenerfor sensormanager in one case of the received message in3951.
public static void oncreate .
demostart .
demohandler new handler .
public void handlemessage message message .
demostop .
.
call demostart here .
.
fig.
.
false positive due to registration orders of callbackshandlerandroidjni.w.
the leak is repaired in baidu map4.
.
we will consider using soot or wala to solvethe problem of intra procedural flow analysis in our futurework.
false positives of leaks are reported tocontain a leak but upon further manual analysis they turnout to be false positives.
there are two major reasons for thefalse positives in the reported leaks.one reason is useless isolated points that are not invoked byany other functions.
these functions are treated as entry pointsin our previous analysis but upon further manual analysis we find they are just useless functions.
they may come fromprogrammers carelessness for not wiping out the useless code.another reason for false positives is the registration or ders of callbacks.
as an example in figure program mers usually write the resource operations in the follow ing order request a resource in methoddemostart then release it indemostop .
when using our methoddescribed in section ii b1 i.e.
connect the registration ofa system callback to the callback itself the requested re source indemostart will be analyzed to be released indemostop during the depth first search.
but if a program mer places thedemostart line to the new place line7 the modification will incur a reported resource leak.
fromthis example it seems that we can solve the problem by simplypostponing the analysis of the registered handler e.g.
put itto the end ofoncreate .
we do not repair this for tworeasons it may occur that a resource request rather than aresource leak inhandler is invoked there may be a lotof other callbacks that also need to postpone the analysis.
infact with detailed resource operations information provided we easily locate the suspicious statement and figure out thefalse positives with a bit of manual work.d.
overhead of the schemeour tool conducts light weight static analysis without se mantic parsing of the program and focuses only on ourinterested resource operations thus the analysis overheadis considerably low.
table vii presents our tool s analysisoverhead for seven popular apps.
the table shows the numberof classes and methods of each app and the time spent torun the resource leak analysis.
the time does not include thedecompilation time of the .apk files.
our analysis finisheswithin about minute for each of the apps.table viioverhead ofresourceleakanalysis for7popularappsappsclassesmethodsanalysis time seconds mytrack .
.31037588215agenda widget .
.1762926247k9mail .0061025773335baidu map .234514476baidu voice assistant .11195819958baidu ime .
.
.4420380461google email .
.
.115121080043iv.
relatedworka.
resource leak detection in java programsresource leak detection is a classic problem in programanalysis.
it is hard for developers to avoid all resource leaks.there are two kinds of methods dynamic and static analysis that provide inspection for them.
qvm suggests anapproach to detect defects by using a specialized runtimeenvironment and it enables the checking of violations ofuser specified correctness properties.
static analysis tools likefindbugs and klocwork detect a wide range ofproblems including a few android platform related resourceleaks .
tracker performs inter procedural staticanalysis to find resource leaks in java programs and ensuresthat no resource safety policy is violated on any executionpath.
since android applications update quickly we adopt thelight weight static analysis method that can scan an industrial level android package efficiently.
comparing to those works our work focuses on android platform related programmingfeatures and resources and our target specific tool is morecomprehensive.among the studies of smartphone resources energy relatedissues have received attentions for the past several years.
someof them estimate energy consumption of an application or itscomponents.
pathak et al.
proposed eprof which is a fine grained energy profiler for smartphone apps.
it breakdowns thetotal energy consumed into per component energy consump tion by tracking the activities of energy consuming entities.and it also gives insights into energy breakdown per threadand per routine of the app.
there are also some works thatanalyze energy related defects in smartphone applications.yepang liu et al.
built a tool called greendroid on top ofjava pathfinder to find energy inefficiency problems.
similarto those works our work focuses on detecting resource leakproblems including several energy related resources so it canalso be used to detect energy inefficiency problems caused byincorrect release or absence of release of energy consumingresources.6androguard supports three decompilers dad dex2jar jad ded weused its default decompiler dad which is very fast due to the fact that itis a native decompiler and the decompilation is done on the fly for eachclass method.396b.
memory usage problemmemory usage problem is a long studied topic.
in traditionalprogramming languages e.g.
c memory recycling task isdone by the program itself the program allocates and freesthe memory occupied by variables explicitly.
there are someworks on detecting memory leaks e.g.
we proposed a staticanalysis tool melton in our previous work .
while themain part of android application program is realized usingjava programming language an outstanding feature of ja va language is that most memory transactions are managedthrough java virtual machine jvm and garbage collection gc mechanism.
java programmers allocate memory simplyby creating objects and don t need to care about how andwhen the objects should be recycled.
but leak may happenwhen you maintain reference to an object that prevents gc.so there are inevitable memory leak problems in java program.mat is an eclipse memory analyzer which is a fastand feature rich java heap analyzer that analyzes productiveheap dumps with hundreds of millions of objects.
it quicklycalculates the retained sizes of objects sees who is preventingthe garbage collector from collecting objects and generatesa report to automatically extract leak suspects.
in paper the authors analyzed reasons of android application memoryleaks and introduced how to avoid memory leaks when com piling application program using mat.
other commercial leakdetectors such as enable visualization of heap objectsof different types.
existing academic tools use growing type s i.e.
types whose number of instances continuesto grow or object staleness to identify suspiciousdata structures that may contribute to a memory leak.
butall of them gather memory related information using dynamicanalysis techniques.
they don t have an explicit definition ofresources and don t have the ability to pinpoint the cause ofa memory leak.v.
conclusion andfutureworkthis paper makes a comprehensive analysis of resourceleak problems in android apps and describes how we au tomatically detect resource leaks in android apps.
we firstobtain a near complete resource table which includes almostall the resources that the reference manual requires to releasemanually.
the table can also be expanded to define otherconcerned resources.
then we propose an automatic solutionto detecting resource leaks based on a modified functioncall graph fcg and it handles the features of event drivenmobile programming by analyzing the callbacks defined in an droid framework.
we build a light weight static analysis toolrelda it focuses on android platform related programmingfeatures and resources and incurs reasonable overhead andfalse positives.
further more with detailed resource operationsinformation provided by our tool we can easily locate thesuspicious statements and figure out the root causes with a bitof manual work.
our experimental data shows that our tool iseffective in detecting various resource leaks in android apps.our current research focuses on system resources whichcan lead to performance degradation and even system crash.the next step of our work is to make quantitative analysisof the performance.
and for the features of event drivenprogramming there exist many ui based events in androidapps extracting ui based event sequences and using modelchecking to do more precise analysis may be another directionof future work.acknowledgementsthe authors would like to thank the anonymous reviewersfor their helpful comments.
this work was partially supportedby the national natural science foundation of china undergrant no.
.