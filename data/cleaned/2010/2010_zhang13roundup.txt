round up runtime checking quasi linearizabilityof concurrent data structureslu zhang arijit chattopadhyay and chao wangdepartment of ece virginia techblacksburg v a usa zhanglu arijitvt chaowang vt.eduabstract we propose a new method for runtime checkingof a relaxed consistency property calledquasi linearizabilityforconcurrent data structures.
quasi linearizability generalizes thestandard notion oflinearizabilityby intentionally introducingnondeterminism into the parallel computations and exploitingsuch nondeterminism to improve the performance.
however ensuring the quantitative aspects of this correctness conditionin the low level code is a difficult task.
our method is thefirst fully automated method for checking quasi linearizabilityin the unmodified c c code of concurrent data structures.
itguarantees that all the reported quasi linearizability violationsare real violations.
we have implemented our method in asoftware tool based on llvm and a concurrency testing toolcalled inspect.
our experimental evaluation shows that thenewmethod is effective in detecting quasi linearizability violations inthe source code of concurrent data structures.i.
introductionconcurrent data structures are the foundation of many multi core and high performance software systems.
by providing acost effective way to reduce the memory contention and in crease the scalability they have found increasingly widespreadapplications ranging from embedded computing to distributedsystems such as the cloud.
however implementing concurrentdata structures is not an easy task due to the subtle interactionsof low level concurrent operations and often astronomicallymany thread interleavings.
in practice even a few hundredlines of highly concurrent low level c c code can posesevere challenges for testing and debugging.linearizability is thede factocorrectness conditionfor implementing concurrent data structures.
it requires thatevery interleaved execution of the methods of a concurrentobject to be equivalent in some sense to a sequential ex ecution.
this is extremely useful as a correctness conditionfor application developers because as long as their programis correct when using the standard sequential data structure switching to a concurrent version of the same data structurewould not change the program behavior.
although being lin earizable alone does not guarantee correctness of the program not satisfying the linearizability requirement often indicatesthat the implementation is buggy.in this paper we propose the first fully automated methodfor checkingstandardandquasilinearizability violations ofconcurrent data structures.
quasi linearizability is aquanti tative relaxation of linearizability which has attractedal o to fattention in recent years .
for many highlyparallel applications the standard notion of linearizability im poses unnecessary restrictions on the implementation therebyleading to severe performance bottlenecks.
quasi linearizabil ity preserves the intuition of standard linearizability whileproviding some additional flexibility in the implementation.for example the task queue used in the scheduler of a threadpool does not need to follow the strict fifo order.
one canuse a relaxed queue that allows some tasks to be overtakenoccasionally if such relaxation leads to superior performance.similarly concurrent data structures used for web cache neednot follow the strict semantics of the standard versions sinceoccasionally getting the stale data is acceptable.
in distributedsystems the unique id generator does not need to be a perfectcounter to avoid becoming a performance bottleneck it isoften acceptable for the ids to be out of order occasionally as long as it happens within a bounded time frame.
quasilinearizability allows the concurrent data structures to havesuch occasional deviations from the standard semantics inexchange of higher performance.while quasi linearizable concurrent data structures havetremendous performance advantages ensuring the quantitativeaspects of this correctness condition in the actual implemen tation is not an easy task.
to the best of our knowledge theredoes not yet exist any method for checking for example thedeqoperation of a relaxed queue is not over taken byotherdeqoperations for more thanktimes.
existing methodsfor detecting concurrency bugs focus primarily on simplebug patterns such as deadlocks data races and atomicityviolations but not this type of quantitative properties.broadly speaking existing methods for checking lineariz ability fall into three groups.
the first group consists ofmethods based on constructing mechanical proofs which require significant user intervention.
the second groupconsists of automated methods based on model checking which work on finite state models or abstractionsof the concurrent data structure.
the third group consists ofruntime tools that can directly check the source code but onlyfor standard linearizability.our method is the first runtime method for checking quasilinearizability in the source code of concurrent data structures.it does not require the user to provide specifications orannotate linearization points.
it takes the source code of aconcurrent objecto at e s tp r o g r a mpthat useso a n daq u a s ifactorkas input and returns eithertrueorfalseas output.it guarantees to report only real linearizability violations.we have implemented the method in a software tool calledround upbased on the llvm compiler and inspect .
itcan check c c programs that use the posix threads and7kuhdg 7kuhdg 7kuhdg r hqt 7lpholqh r hqt r hqt r ght r ght r ght r hqt r ght fig.
.
a threaded program that uses objecto.t h r e a d1s t a r t sb ya d d i n gvalues and to the queue before creating two child threads.then it waitsfor the child threads to terminate before removing another three data items.hereenq runs concurrently withenq anddeq in thread .gnu built in atomic functions.
our experiments on a largeset of concurrent data structure implementations show thatthenew method is effective in detecting both quasi linearizabilityviolations.
we have found several real implementation bugsin thescalsuite which is an open source package thatimplements some of the most recently published concurrentdata structures.
the bugs that we found in thescalbenchmarkshave been confirmed by thescaldevelopers.the remainder of this paper is organized as follows.
weprovide a few motivating examples in section ii and explainthe main technical challenges in checking quasi linearizability.we establish notation in section iii and then present the overallalgorithm in section iv.
we present the detailed algorithm forchecking quasi linearizability in section v. our experimentalresults are presented in sections vi.
we review related workinsection vii and finally give our conclusions in section viii.ii.
motivatingexamplesin this section we illustrate the standard and quasi lin earizability properties and outline the technical challengesin checking such properties.
fig.
shows a multithreadedprogram that invokes theenq deqmethods of a queue.
ifthread executesenq atomically i.e.
without interferencefrom thread there will be three interleaved executions all ofwhich behave like a single threaded execution.
the sequentialhistories shown in fig.
satisfy the standard semantics oft h equeue.
therefore we call them thelegal sequential histories.if the time interval ofenq w h i c hs t a r t sa ti t si n v o c a t i o nand ends at its response overlaps with the time intervalsofenq anddeq t h ee x e c u t i o ni sn ol o n g e rs e q u e n t i a l .in this case the interleaved execution is called aconcurrenthistory.w h e nt h ei m p l e m e n t a t i o no ft h eq u e u ei sl i n e a r i z a b l e no matter how the instructions ofenq interleave with theinstructions ofenq anddeq t h ee x t e r n a lb e h a v i o ro fthe queue would remain the same.
we say that the queue islinearizableif the sequence ofdeqvalues of anyconcurrenthistorymatches one of the three legal sequential histories infig.
.
on the other hand if the sequence ofdeqvaluesis in a concurrent history we say that it has a lvwru lvwru lvwru 7lpholqh r hqt r hqt r hqt r ght r ght r ght r hqt r ght r hqt r hqt r hqt r ght r ght r ght r hqt r ght r hqt r hqt r hqt r ght r ght r ght r hqt r ght fig.
.
the set oflegal sequential historiesgenerated by the program infig.
.
these legal sequential histories form thesequential specification.
d e f g fig.
.
an example implementation of1 quasi linearizablequeue whereeach of the linked list item is a segment that holds two data items.
the firstdeqrandomly returns a value from the set and the seconddeqreturnsthe remaining one.
then the thirddeqrandomly returns a value from the set and the fourthdeqreturns the remaining one.linearizability violation because the object no longer behaveslike a fifo queue.however being linearizable often means that the imple mentation has significant performance overhead when it isused by a large number of concurrent threads.
for a quasilinearizable queue in contrast it is acceptable to have thedeqvalues being out of order occasionally if such relaxation ofthe standard semantics can help improve the performance.
forexample instead of using a standard linked list to implementthe queue one may use a linked list of cell segments toimplement the quasi linearizable queue .
thedeqoperation may remove any of the two data items in the headsegment.
by using randomization it is possible for two threadsto remove different data items from the head simultaneouslywithout introducing memory contention.assume that the relaxed queue contains four values 4initially.
the first twodeqoperations would retrieve either 2or and the next twodeqoperations would retrieve either3 or .
together there are four possible combinations asshown in fig.
.
among them h1 ais linearizable.
the7 d e f g fig.
.
an alternative implementation of1 quasi linearizablequeue whichis based on the random dequeued queue.
the firstdeqrandomly returns avalue from and the seconddeqreturns the remaining one.
then thethirddeqrandomly returns a value from the new window and thefourthdeqreturns the remaining one.other three are not linearizable but are considered as1 quasi linearizable m e a n i n gt h a tdeqvalues in these concurrenthistories are out of order by at most one step.however implementing quasi linearizable data structuresisad i f fi c u l tt a s k .s u b t l eb u g sc a nb ei n t r o d u c e dd u r i n gb o t ht hedesign phase and the implementation phase.consider an alternative way of implementing the quasilinearizable queue as illustrated in fig.
where the first twodata items are grouped into a virtual window.
adeqoperationmay retrieve any of the first data items from the head basedon randomization.
furthermore only after both data items inthe current window are removed will thedeqoperation moveon to retrieve data items in the next window.
the resultingbehavior of this implementation should be identical to thatofthe segmented queue.however a subtle bug would appear if one ignores the useof thevirtual window.f o re x a m p l e i fdeqalways returnsone of the first two data items in the current queue theimplementation would not be quasi linearizable.
in this case it is possible for some data item to be over taken indefinitely thereby making the data structure unsuitable for applicationswhere a quasi queue is desired.
for example if every timethedeqoperation removesthe second data item in the list w ewould get a sequence ofdeqvalues as follows ... wherevalue is left in the queue indefinitely.the last example demonstrates the need for a new methodthat can help detect violations of such quantitative properties.existing concurrency bug checking tools focus primarily onsimple bug patterns such as deadlocks and data races.
theyare not well suited for checking quantitative properties inthelow level code that implements concurrent data structures.tothe best of our knowledge the method proposed in this paperis the first method for detecting quasi linearizability violationsin the code of concurrent data structures.iii.
preliminariesa.
linearizabilitywe follow the notation in to definehistoryas asequence of events denotedh e1e2...en w h e r ee a c he v e n tis either a method invocation or a response of an object.
whenthere are multiple objects let h odenote the projectionof historyhto objecto w h i c hi st h es u b s e q u e n c eo fe v e n t srelated to that object.
when there are multiple threads let tdenote the projection of history to threadt w h i c hi st h esubsequence of events of that thread.
two histories and primeare equivalent denoted prime i fa n do n l yi f ti prime tifor all threadti w h e r ei ... k.t w oe q u i v a l e n th i s t o r i e shave the same set of events but the events may be arrangedin different orders.asequential historyis one that starts with a method invo cation and each method invocation is followed immediatelyby the matching response in other words no two methodcall intervals are overlapping.
otherwise the history is calledaconcurrent history.l e t be the precedence relation ofevents in history .definition alinearizationof a concurrent history is asequential history primesuch that prime m e a n i n gt h a tt h e yshare the same set of events and ei ej ei ejimpliesei primeej.i no t h e rw o r d s t h en o n o v e r l a p p i n gm e t h o dc a l l si n retain their execution order in prime w h e r e a st h eo v e r l a p p i n gmethod calls may take effect in any order.asequential specificationof objecto d e n o t e dspec o i sthe set of alllegalsequential histories histories that conformto the semantics of the object.
for example a legal sequentialhistory of a queue is one where all theenq deqvalues followthe fifo order.definition ac o n c u r r e n th i s t o r y is linearizable withrespect to a sequential specificationspec o if and only if ithas a linearization primesuch that prime spec o .i no t h e rw o r d s as long as the concurrent history can be mapped to at leastone prime spec o i ti sc o n s i d e r e da sl i n e a r i z a b l e .b.
quasi linearizabilitythe notion of quasi linearizability relies on the permutationdistance between two sequential histories.
let prime e prime1e prime2...e primenbe a permutation of e1e2...en.l e t prime be thedistance between and primedefined asmaxe prime .we use and prime to denote the index of eventein and prime respectively.
therefore prime is the maximum distancethat some event in has to travel to its new position in prime.quasi linearizability is often defined on a subset of theobject s methods.
letdomain o be the set of all op erations of objecto.l e td domain o be a subset.letpowerset domain o be the set of all subsets ofdomain o .definition thequasi linearization factor or quasi factor for a concurrent objectois a functionqo d n w h e r ed powerset domain o andnis the set of naturalnumbers.for example a queue whereenqoperations follow the fifoorder butdeqvalues may be out of order by at mostksteps can be specified as follows denq a bracketle to.enq x vo i d a bracketri ht x x ddeq a bracketle to.deq x a bracketri ht x x qqueue denq 0qqueue ddeq kdefinition ac o n c u r r e n th i s t o r y isquasi linearizable with respect to a sequential specificationspec o and quasifactorqoiff has a linearization primesuch that either prime spec o m e a n i n gt h a t is linearizable andhence is also quasi linearizable or there exists a permutation prime primeof primesuch that prime prime spec o a n d prime d prime prime d qo d for all subsetd d.in other words primeneeds to be a legal sequential history or within a bounded distance from a legal sequential his tory.
linearizability is subsumed by quasi linearizabilityw i t hqo d .from now on given a sequential history prime w ec a l l prime prime prime d prime prime d qo d for alld d the set ofquasi permutationsof prime.quasi linearizability is compositional in that a historyhis quasi linearizable if and only if subhistoryh o f o re a c hobjecto i sq u a s il i n e a r i z a b l e .t h i sa l l o w su st oc h e c kq u a s ilinearizability on each individual object in isolation whichreduces the computational overhead.c.
checking quasi linearizabilitythere are at least three levels where one can check the quasi linearizability property.
l1 check if a concurrent history is linearizable linearization primeof history prime spec o .
l2 check if a concurrent programpis linearizable concurrent history ofp is linearizable.
l3 check if a concurrent objectois linearizable programpthat uses objecto pis linearizable.l3 may be regarded as the full fledged verification of theconcurrent object whereas l1 and l2 may be regarded asruntime bug detection.
in this paper we focus primarily onthe l1 and l2 checks.
that is given a terminating programpthat uses the concurrent objecto called the test harness we systematically generate the set of concurrent historiesofpand then check if all of these concurrent histories are quasi linearizable.
our main contribution is to propose anew algorithm for deciding whether a concurrent history is is quasi linearizable.iv .
overallalgorithmthe overall algorithm for checking quasi linearizability con sists of two phases see fig.
.
in phase we systematicallyexecute the test programptogether with a standard datastructure to construct a sequential specificationspec o w h i c hconsists of all the legal sequential histories.
in phase wesystematically execute the test programptogether with theconcurrent data structure and for each concurrent history check whether is quasi linearizable.for data structures such as queues stacks and priorityqueues a sequential version may serve as the golden modelin phase .
alternatively the user may use a specificallyconfigured concurrent data structure as the golden model e.g.
by setting the quasi factor of a relaxed queue to whicheffectively turns it into a normal queue.in phase we use a chess like systematic con currency testing tool called inspect to computeall the legal sequential histories.
we have modified in spect to automatically wrap up every method call in alock unlock pair.
for example method callo.enq becomeslock lk o.enq unlock lk w h e r ew ea s s i g nal o c klktoeach objectoto ensure that context switches happen only atthe method call boundary.
in other words all method callsof objectoare executed serially.
furthermore inspect canguarantee that all the possible sequential histories of thisform are generated.
our new method leverages theselegalsequential historiesto construct the sequential specificationspec o .in phase we use inspect again to compute the set ofconcurrent histories of the same test program.
however thistime we allow the instructions within the method bodiesto interleave freely.
this can be accomplished by invokinginspect in its default mode without adding the aforementionedlock unlock pairs.
in addition to handling the posix threadsfunctions we have extended inspect to support the set of gnubuilt in functions for atomic shared memory access which arefrequently used in implementing concurrent data structures.our core algorithm for checking whether a concurrenthistory is quasi linearizable is invoked in phase .
for each concurrent history w ec o m p u t et h es e t oflinearizationsof see definition .
if any prime matches a legal sequential history inspec o b yd e fi n i tion is linearizable and also quasi linearizable.
otherwise for each linearization prime w ec o m p u t ethe set ofquasi permutationsof primewith respect to thequasi factor see definition which defines the distancebetween primeand each prime prime .
if there exists a quasi permutation prime primesuch that prime prime spec o t h e n is quasi linearizable.
otherwise is not quasi linearizable and hence isnot linearizable.the pseudo code for checking quasi linearizability is shownin algorithm which takes a concurrent history and a quasifactorkas input and returns either true quasi linearizable or false not quasi linearizable .
the main challenge is togenerate the set of linearizations of the given history andthe set of quasi permutations of each prime .t h efi r s tstep which is straightforward will be explained in this section.the second step which is significantly more involved will beexplained in the next section.we now explain the detailed algorithm for computing the set of linearizations for the given history .t h ec o m p u t a t i o ni scarried out by subroutinecompute linearizations .
lethistory 0 inv1inv2 resp1 resp2...where and are arbitrary subsequences andinv1 inv2are theinvocation events of the first two overlapping method calls.we will replace 0in with the new histories 1and 2.in other words for any two method call pairs invi respi and invj respj in i ft h e yd on o to v e r l a p m e a n i n gt h a teitherrespi invjorrespj invi w ew i l lk e e pt h i sexecution order.
in they overlap we will generate two newphase deterministicfifo queue golden model under test phase quasi linearizablequeueit belongs tospec o sequential specificationconcurrent historiesspec o for each g e n e r a t ea l llinearizations prime quasi permutations prime prime for each prime g e n e r a t ea l lfor each prime prime c h e c ki f fig.
.
the overall flow of our new quasi linearizability checking algorithm.
algorithm 1checking the quasi linearizability of the concur rent history with respect to the quasi factork.
check quasi linearizability k compute linearizations for each prime if prime spec o returntrue compute quasi permutations prime k for each prime prime if prime prime spec o returntrue returnfalse compute linearizations while ac o n c u r r e n th i s t o r y 0 let 0 inv1inv2 resp1 resp2... 1 inv1resp1inv2 resp2... 2 inv2resp2inv1 resp1 .
.
.
1 2 0 return compute quasi permutations prime k state stack first run prime k while t r u e prime prime backtrack run s t a t e stack prime if prime prime n u l l break prime prime return histories where one hasrespi invjand the other hasrespj invi.example.consider the history in fig.
left .
the first twooverlapping calls start withinv1andinv2 r e s p e c t i v e l y .
first we construct a new history where inv1 resp1 is moved ahead of inv2 resp2 .t h i si ss t r a i g h t f o r w a r dbecause by the time we identifyinv1andinv2 w ec a ncontinue to traverse the event sequence to findresp1in 0and then move it ahead of eventinv2.s i n c et h er e s u l t i n ghistory 1still has overlapping method calls we repeatthe process in the next iteration.
second we construct a new history by moving inv2 resp2 ahead of inv1 resp1 .t h i si sal i t t l em o r einvolved because there can be many other method callsof threadt1that are executed betweeninv2andresp2.lqy uhvs lqy uhvs lqy uhvs lvwru lqy uhvs lvwru lvwru uhvs lqy lqy uhvs lqy uhvs lqy uhvs lqy uhvs fig.
.
example computing thelinearizationsof the given concurrent historyby repeatedly sequentializing the first two overlapping method calls denotedby inv1 resp1 and inv2 resp2 .we take all these events betweeninv1andresp2 a n dmove them afterresp2.i nt h i se x a m p l e t h en e wh i s t o r yishistory .according to definition when at least one of the lineariza tions prime is a legal sequential history is linearizable which means that it is also quasi linearizable.
otherwise isnot linearizable but may still be quasi linearizable .v.
checking forquasilinearizabilityto check whether history prime is stillquasi linearizable we need to invoke subroutinecompute quasi permutations prime k .
as shown inalgorithm the subroutine consists of two steps.
inthe first step first runis invoked to construct a doublylinked list to hold the sequence of states connected by eventsin prime d e n o t e dstate stack s1e1 s2e2 ...snen .e a c hstatesi w h e r ei ... n r e p r e s e n t sa na b s t r a c ts t a t eo fthe objecto.s u b r o u t i n efirst runalso fills up the fieldsof each state with the information needed later to generatethe quasi permutations.
in the second step we generatequasi permutations of prime o n ea tat i m e b yc a l l i n gbacktrack run.a.
example constructing quasi permutationswe generate the quasi permutations by reshuffling the eventsin primeto form new histories.
more specifically we computev v v ght ght ght ght v ght 2uljlqdoklvwru 3hupxwdwlrq ght v ght v ght 3hupxwdwlrq fig.
.
an example search tree for generating all1 quasi permutations of theinput sequencedeq deq deq .all possible permutations of prime d e n o t e d prime prime s u c ht h a tthe distance between primeand prime primeare bounded by the quasifactork.o u rm e t h o df o rc o n s t r u c t i n gt h eq u a s ip e r m u t a t i o n sfollows thestrict out of ordersemantics as defined in .consider queues as the example.
astrict out of orderk quasipermutation consists of two restrictions restriction e a c hdeqis allowed to return a value thatis at mostksteps away from the head node.
restriction t h efi r s td a t ae l e m e n t i nh e a dn o d e m u s tbe returned by one of the firstkdeqoperations.history deq deq deq res1 res2history deq deq deq ok okhistory deq deq deq ok okhistory deq deq deq no okhistory deq deq deq ok nohistory deq deq deq no noto illustrate thestrict out of orderdefinition consider the1 quasi queue above.
assume that the input history primeisdeq deq deq .t h eh i s t o r yc a nb ea r b i t r a r i l yr e shuffled into five additional histories of which only history1and history satisfy the above two restrictions.
they are thedesired quasi permutations of primewhereas the others are not.
inparticular history violates restriction because the firstdeqreturns the value that is two steps away from the head.
history4v i o l a t e sr e s t r i c t i o n2b e c a u s et h eh e a dv a l u ei sr e t u r n e dbythe thirddeqoperation which is too late.
history violatesboth restrictions.we compute the quasi permutations using a depth firstsearch dfs of the abstract states.
for the above example this process is illustrated in fig.
where the initial run isassumed to bes1deq s2deq s3deq .
in the first run we construct the state stack that holdsthe initial history.
then we find the last backtrack state which is states2 a n de x e c u t edeq instead ofdeq .this leads to the second runs1deq s2deq s prime3deq .
in the second run we again find the last backtrack state which iss1 a n de x e c u t edeq instead ofdeq .t h i sleads to the third runs1deq s prime prime2deq s prime prime3deq .
in the third run we can no longer find any backtrack state.therefore the procedure terminates.
we cannot generatean e wr u nb yc h o o s i n gdeq in states1 b e c a u s ei twould violate restriction .
we cannot generate a newrun by choosingdeq in states prime prime2either because itwould violate restriction .b.
elementary data structuresto enforce the restrictions imposed by thestrict out of ordersemantics we need to add some fields into each state.in particular we add anenabledfield into each state to helpenforce restriction and we add alatenessattribute into eachenabled event to enforce restriction .state stack w es t o r et h es e q u e n c eo fs t a t e so ft h ec u r r e n tr u nin a doubly linked list called state stack.
executing a methodcall event moves the object from one state to another state.each stateshas the following fields s.enabled is the set of events that can be executed ats s.select is the event executed by the current history s.done is the set of events executed atsby somepreviously explored permutations in the backtrack search s.newly enabled is the set of events that become enabledfor the first time along the given history prime.t h efi e l di sinitialized by the first run and is used to compute thes.enabled field in the subsequent runs.example s.newly enabled.t h ei n i t i a ls t a t eh a sa tm o s t k events in its newly enabled field wherekis the quasi factor.
every other state has at most oneevent in this newly enabled field.
for the given historydeq deq deq and quasi factor we have s1.newly enabled deq deq 1e v e n t si nt h ei n i t i a ls t a t e s2.newly enabled deq at most one event s3.newly enabled at most one event in other words each event will appear in the newly enabledfield of the state that is preciselyksteps ahead of its originalstate in prime.w ew i l le n f o r c er e s t r i c t i o n1w i t ht h eh e l po ft h enewly enabled field.example s.enabledands.done.f o rt h ea b o v ee x a m p l e s1.enabled deq deq s1.done deq s2.enabled deq deq s2.done deq s3.enabled deq s3.done deq bothdeq anddeq are ins1.enabled but onlydeq is ins1.done because it is executed in the current run.since the set s.enabled s.done is not empty for boths1ands2 w eh a v et w ob a c k t r a c ks t a t e s .a f t e rb a c k t r a c k ing tos2and executingdeq w ec r e a t ean e wp e r m u tationdeq deq deq .s i m i l a r l y a f t e rb a c k t r a c k i n gtos1and executingdeq w ec r e a t ean e wp e r m u t a t i o ndeq deq deq .for permutationdeq deq deq t h ee n a b l e da n dd o n efields will be changed to the following s1.enabled deq deq s1.done deq deq s prime prime2.enabled deq deq s prime prime2.done deq s prime prime3.enabled deq s prime prime3.done deq3 although s prime prime2.enabled s prime prime2.done is not empty we cannot createthe new permutationdeq deq deq becausedeq would be out of order by two steps.
we avoid generating suchpermutations by leveraging the lateness attribute that is addedinto every enabled event.lateness attribute each event ins.enabled has a latenessattribute indicating how many steps this event is later thanits original occurrence in prime.i tr e p r e s e n t sh o wm a n ys t e p st h i sevent can be postponed further in the current permutation.s lateness e k...s .select e lateness e ...s lateness e kexample consider the example above where eventeisexecuted in statesiof the given history.
fork quasi permuta tions the earliest state whereemay be executed issi k a n dthe latest state whereemay be executed issi k.t h el a t e n e s sattribute of eventein statesi kis k m e a n i n gt h a ti tm a ybe postponed for at mostk k 2ksteps.
the lateness ofein statesi kisk m e a n i n gt h a tehas reached the maximumlateness and therefore must be executed in this state.must select event this brings us to the important notion ofmust select event.
ins.enabled if there does not exist anyevent whose lateness reachesk a l lt h ee n a b l e de v e n t sc a nb epostponed for at least one more step.
in this case we canrandomly choose an event from the set s.enabled s.done t oexecute.
if there exists an event ins.enabled whose latenessisk t h e nw em u s te x e c u t et h i se v e n ti ns t a t es.example if we backtrack from the current historydeq deq deq to states1and then executedeq eventdeq will have a lateness of in states prime prime2 m e a n i n gthat it has reached the maximum delay allowed.
therefore ithas to be executed in states2.
s1.lateness deq lateness deq lateness s prime prime2.lateness deq lateness deq lateness s prime prime3.lateness deq lateness the initial lateness is assigned to each enabled event whenthe event is added tos.enabled byfirst run.e v e r yt i m ea nevent is not selected for execution in the current state it willbe inherited by the enabled field of the subsequent state.
thelateness of this event is then increased by .an important observation is that in each state there can beat most onemust selectevent.
this is because the first run primeis a total order of events which gives each event a differentlatenessvalue by definition theirexpiration timesare alldifferent.c.
algorithm constructingk quasi permutationsthe pseudo code for generating quasi permutations ofhistory primeis shown in algorithm .
initializing the late ness attributes of enabled events is performed by sub routineinit enabled and lateness w h i c hi sc a l l e db yfirst run.t h el a t e n e s sa t t r i b u t e sa r et h e nu p d a t e db yupdate enabled and lateness.each call tobacktrack runwill return a new quasi per mutation of prime.i n s i d et h i ss u b r o u t i n e w es e a r c hf o rt h el a s tbacktrack statesin state stack.
if such backtrack statesexists we prepare the generation of a new permutation byresetting the fields of all subsequent states ofs w h i l ek e e p i n gtheir newly enabled fields intact.
then we choose a previouslyunexplored event ins.enabled to execute.the previously unexplored event ins.enabled is chosen bycallingpick an enabled event.i ft h e r ee x i s t sam u s t s e l e c tevent ins.enabled whose lateness reachesk t h e ni tm u s tb echosen.
otherwise we choose an event from the set s.enabled s.done arbitrarily.
we useupdate enabled and latenessto fill up the events ins.enabled.
for events that are inheritedfrom the previous state s enabled set we increase their late ness by one.
we iterate until the last state is reached.
at thistime we have computed a new quasi permutation of prime.d.
discussionsour method is geared toward bug hunting.
whenever wefind a concurrent history that is not quasi linearizable itis guaranteed to be a real violation.
however recall thatour method implements the l1 and l2 checks but not thel3 check as defined in section iii.
therefore even if allconcurrent histories of the test program are quasi linearizable we cannot conclude that the concurrent data structure itselfi squasi linearizable.furthermore when checking for quasi linearizability ourruntime checking framework has the capability of generatingtest programs harness that arewell formed t h a ti s t h enumber ofenqoperations is equal to the number ofdeqoperations.
if the test program is provided by the user thenitis the user s responsibility to ensure this well formedness.
thisis important because if the test program is not well formed there may beout of thin airevents.
below is an example.thread thread hist1 hist2 hist3 enq enq enq enq enq enq deq ... ... enq ... ... ... ... enq deq deq deq 4here the sequential specification is hist1 hist2 .i nb o t hhistories eitherdeq 3ordeq .h o w e v e r t h edeqvaluecan never be .
this is unfortunate becausehist3is quasi linearizable but cannot match any of the two legalsequential histories hist1orhist2 b e c a u s ei th a sdeq .this problem can be avoided by requiring the test program tobe well formed.
for example by adding two moredeqcalls tothe end of the main thread we can avoid the aforementionedout of thin airevents.vi.
experimentswe have implemented our new quasi linearizability check ing method in a software tool based on the llvm platformfor code instrumentation and based oninspectfor system atically generating interleaved executions.
our tool calledround up c a nh a n d l eu n m o d i fi e dc c c o d eo fc o n c u r r e n tdata structures on the linux pthreads platform.
we haveimprovedinspectby adding the support for gnu built inatomic functions for direct access of shared memory sincethey are frequently used in the low level code for implementingconcurrent data structures.algorithm 2generatingk quasi permutations for history prime.
first run prime k state stack empty list for each e v e n tevin the sequence prime s new state state stack.append s s.select ev s.done ev init enabled and lateness s ev k returnstate stack init enabled and lateness s ev k lateness while s.enabled.add a bracketle tev lateness a bracketri ht if l a t e n e s s k s.prev null s.newly enabled.add a bracketle tev l a t e n e s s a bracketri ht break lateness s s.prev in state stack backtrack run s t a t e stack letsbe the last state in state stack such that26 pick an enabled event s e atio slash null if s u c hsdoes not exist returnnull for each s t a t ea f t e rsin state stack resets.select s.done ands.enabled but keeps.newly enabled while s e atio slash null ev pick an enabled event s s.select ev s.done ev s s.next update enabled and lateness s return sequence of selected events in state stack pick an enabled event s if a bracketle tev lateness a bracketri ht s.enabled lateness k if ev e atio slash s.done must select event45 returnev else47 returnnull if a bracketle tev lateness a bracketri ht s.enabled ev e atio slash s.done returnev else52 returnnull update enabled and lateness s p s.prev if sorpdo not exist return s.enabled for each a bracketle tev lateness a bracketri ht p.enabled ev e atio slash p.done s.enabled.add a bracketle tev lateness a bracketri ht for each a bracketle tev lateness a bracketri ht s.newly enabled s.enabled.add a bracketle tev lateness a bracketri ht we have conducted experiments on a set of concurrent datastructures including both standardand quasi linearizable queues stacks and priority queues.f o rsome data structures there are several variants each of whichuses a different implementation scheme.
the characteristicsof these benchmark programs are shown in table i. the firstthree columns list the name of the data structure a shortdescription and the number of lines of code.
the next twocolumns show whether it is linearizable and quasi linearizable.the last column provides a list of the relevant methods.table ii shows the experimental results for checking stan dard linearizability.
the first four columns show the statisticsof the test program including the name the number of threads concurrent total the number of method calls and whetherlinearizability violations exist.
the next two columns showt h estatistics of phase consisting of the number of sequentialhistories and the time for generating these sequential histo ries.
the last three columns show the statistics of phase consisting of the number of concurrent histories buggy total the total number of linearizations and the time for checkingthem.
in all test cases our method was able to correctly detectthe linearizability violations.table iii shows the experimental results for checking quasilinearizability.
the first four columns show the statisticsofthe test program.
the next two columns show the statisticsof phase and the last three columns show the statisticsof phase consisting of the number of concurrent histories buggy total the total number of quasi permutations andthetime for generating and checking them.
in all test cases wehave set the quasi factor to .our method was able to detect all real quasi linearizabilityviolations in fairly small test programs.
this is consistentw i t hthe experience of burckhartet al.
in evaluating their line up tool for checking standard but not quasi linearizability.this is due to the particular application of checking theimplementation of concurrent data structures.
although thenumber of method calls in the test program is small theunderlying low level shared memory operations can still bemany.
this leads to a rich set of very subtle interactionsbetween the low level memory accessing instructions.
in suchcases the buggy execution can be uncovered by checking atest program with only a relatively small number of threads method calls and context switches.we have also conducted experiments on a set of re cently released high performance concurrent objects in thescalsuite .
table iv shows the characteristics of thesebenchmark programs and table v shows the experimentalresults.
we have successfully detected two real linearizabilityviolations in thescalsuite one of which is a known violationwhereas the other is a previously unknown programmingerror.
in particular sl queueis a queue designed for highperformance applications but it is not thread safe and thereforeis not linearizable.k stack o nt h eo t h e rh a n d i sd e s i g n e dt obe quasi linearizable.
however due to an aba bug the datastructure is not quasi linearizable.our tool is able to quickly detect the linearizability violationinsl queueand the quasi linearizability violation ink stack.furthermore it generates detailed execution traces to illustratehow the violations can be reproduced during debugging.
interms of the aba bug ink stack f o re x a m p l e o u rt o o lshows that the bug occurs when one thread executes thepushoperation while another thread is executing thepopoperation concurrently.
due to erroneous thread interleaving it is possible for the same data item to be added to the stacktwice although thepushoperation is executed only once.
wehave reported the bug ink stackto thescaldevelopers whohave confirmed that it is indeed a bug.it is worth pointing out that existing concurrency bug findingtools such as data race and atomicity violation detectors a r etable ithe statistics of the benchmark examples.
class description loc linearizable quasi lin methods checked iqueue buggy queue deq may remove null even if not empty no no enq int deq herlihy wing queue correct normal queue yes yes enq int deq quasi queue correct quasi queue no yes enq int deq quasi queue b1 deq removes value more than k away from head no no enq int deq quasi queue b2 deq removes values that have been removed before no no enq int deq quasi queue b3 deq null even the queue is not empty no no enq int deq quasi stack b1 pop null even if the stack is not empty no no push int pop quasi stack b2 pop removes values move than k away from the tail no no push int pop quasi stack linearizable and hence quasi linearizable yes yes push int pop quasi priority queue implementation of quasi priority queue no yes enq int int deqmin quasi priority queue b2 deqmin removes value more than k away from head no no enq int int deqmin table iiresults of checking standard linearizability on concurrentdata structures.
test program phase phase class threads calls violation history time seconds history buggy total linearization time seconds iqueue yes .
.
herlihy wing queue no .
.
quasi queue yes .
.
quasi queue yes .
.
quasi queue yes .
.
quasi queue yes .
1m23s quasi queue yes .
5m8s quasi queue yes .
37m34s quasi queue b1 yes .
.
quasi queue b2 yes .
.
quasi queue b3 yes .
.
quasi stack b1 yes .
.
quasi stack b2 yes .
.
quasi stack no .
.
quasi priority queue yes .
.
quasi priority queue b2 yes .
.
table iiiresults of checking quasi linearizability on concurrent datas t r u c t u r e s. test program phase phase class threads calls violation history time seconds history buggy total permutation time seconds quasi queue no .
.
quasi queue no .
5m33s quasi queue no .
.
quasi queue no .
1m34s quasi queue no .
5m40s quasi queue no .
40m56s quasi queue qfactor no .
.
quasi queue qfactor no .
2m36s quasi queue qfactor no .
10m15s quasi queue qfactor no .
69m32s quasi queue b1 yes .
.
quasi queue b2 yes .
.
quasi queue b3 yes .
.
quasi stack b1 yes .
.
quasi stack b2 yes .
.
quasi stack b3 no .
.
quasi priority queue no .
.
quasi priority queue b2 yes .
.
table ivthe statistics of thescal benchmark examples totallocofscalis5 .
class description loc linearizable quasi lin methods checked sl queue singly linked list based single threaded queue no no enq deq t stack concurrent stack by r. k. treiber yes yes push pop ms queue concurrent queue by m. michael and m. scott yes yes enq deq rd queue random dequeued queue by y .
afek g. korland and e. yanovsky no yes enq deq bk queue bounded k fifo queue by y .
afek g. korland and e. yanovsky no yes enq deq ubk queue unbounded k fifo queue by c.m.
kirsch m. lippautz and h. payer no yes enq deq k stack k stack by t. a. henzinger c. m. kirsch h. payer and a. sokolova no no push pop table vresults of checking quasi linearizability for thescal benchmark examples.
test program phase phase class threads calls violation history time seconds history buggy total permutation time seconds sl queue enq deq no .
.
sl queue enq enq yes .
.
sl queue deq deq yes .
.
t stack push pop no .
.
t stack push push no .
.
t stack pop pop no .
.
ms queue enq deq no .
.
ms queue enq enq no .
.
ms queue deq deq no .
.
rd queue enq deq no .
.
rd queue enq enq no .
.
rd queue deq deq no .
.
bk queue enq deq no .
.
bk queue enq enq no .
.
bk queue deq deq no .
.
ubk queue enq deq no .
.
ubk queue enq enq no .
.
ubk queue deq deq no .
.
k stack push pop yes .
.
k stack push push no .
.
k stack pop pop no .
.
not effective for checking low level c c code that imple ments most of the highly concurrent data structures.
thesebug detectors are designed primarily for checking applicationlevel code.
furthermore they are often based on the locksetanalysis and condition variable analysis.
although locks andcondition variables are widely used in writing applicationlevelcode they are rarely used in implementing concurrent datastructures.
synchronization in concurrent data structuresm a ybe implemented using atomic memory accesses.
to the best ofour knowledge no prior method can directly check quantitativeproperties in such low level c c code.vii.
relatedworkour new method can detect quasi linearizability violationsin the code of concurrent data structures.
a closely relatedwork is a model checking based approach for formally ver ifying quantitative relaxations of linearizability in models ofconcurrent systems which we have published recently .however the method is not designed for checking the c c code.
another closely related work is line up which cancheck the code of concurrent data structures fordeterministiclinearizabilitybut cannot check for quasi linearizability.there exists a large body of work on verifying standardlinearizability.
for example liu et al.
verify standardlinearizability by proving that an implementation model re fines a specification model.
vechev et al.
use the spinmodel checker to verify linearizability in a promela model.cern y et al.
use automated abstractions together withmodel checking to verify linearizability properties in javaprograms.
there also exists work on proving linearizabilityb yconstructing mechanical proofs often with significant manualintervention .
however none of these methods cancheck quantitative relaxations of linearizability.there also exist runtime checking methods for other typesof consistency conditions such as sequential consistency quiescent consistency and eventual consistency .some of these consistency conditions in principle may beused to ensure the correctness of concurrent data structures.however none of these correctness conditions is as widelyused as linearizability.
furthermore they do not involve anyquantitative properties.for checking application level code which has significantlydifferent characteristics from the low level code that imple ments concurrent data structures serializabilityandatomicityare the two frequently used correctness properties.
there alsoexists a large body of work on detecting violations of theseproperties e.g.
and .
these bug finding methods differfrom our new method in that they are checking for differenttypes of properties.
in practice atomicity and serializabilityhave been used primarily at the shared memory read writelevel.
whereas linearizability has been used primarily at themethod api level.
furthermore existing tools for detectingserializability violations and atomicity violations do notc h e c kfor quantitative properties.viii.
conclusionswe have presented a new algorithm for runtime checking ofstandard and quasi linearizability in concurrent data structures.our method works directly on the c c code and is fullyautomated without requiring the user to write specificationsor annotate linearization points.
it guarantees that all thereported violations are real violations.
we have implementedthe new algorithm in a software tool calledround up.o u rexperimental evaluation shows thatround upis effectivein detecting quasi linearizability violations and generatinginformation for error diagnosis.acknowledgmentthe authors would like to thank christoph kirsch andmichael lippautz of university of salzburg for making thescalbenchmarks available and for promptly answering ourquestions.
our work is supported in part by the nsf grantccf and the onr grant n00014 .