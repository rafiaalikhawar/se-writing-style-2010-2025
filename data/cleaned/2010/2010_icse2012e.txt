askingandansweringquestionsaboutunfamiliar apis anexploratorystudy ekwa duala ekoko and martin p. robillard school of computer science mcgill university montr eal qc canada ekwa martin cs.mcgill.ca abstract the increasing size of apis and the increase in the number of apis available imply developers must frequently learn how to use unfamiliar apis.
to identify the types of questions developers want answered when working with unfamiliar apis and to understand the difficulty they may encounter answering those questions we conducted a study involving twenty programmers working on different programmingtasks usingunfamiliarapis.basedonthescre en captured videos and the verbalization of the participants we identified twenty different types of questions programmers ask when working with unfamiliar apis and provide new insights to the cause of the difficulties programmers encounter when answering questions about the use of apis.
the questions we have identified and the difficulties we observed can be used for evaluating tools aimed at improving api learning and in identifyingareas oftheapilearningprocesswheretoolsup port is missing or could be improved.
i. introduction modern day software development is inseparable from the use of applicationprogramminginterfaces apis .softwar e developers make use of apis as interfaces to code libraries or frameworks to help speed up the process of software development and to improve the quality of the software.
before leveraging the benefits of an api a developer must discover and understand the behavior and relationship s between the elements of an api relevant to their task.
given the increase in the size of apis and the increase in the number of apis developers have to work with even experienced developers must frequently learn newer parts of familiar apis or newer apis when working on new tasks.
recently researchers started investigating how de sign choices common to several apis affect the api learning process.
for instance ellis et al.
observed that the factor y pattern hinders api learning and a study by stylos et al.
observed that method placement for instance placing a send method on a convenience class such as emailtransport.send emailmessage instead of having it on the main type such as emailmessage.send hinders api learning because convenience methods are difficult to discover when learning to use an api .
in this paper we expand on the body of work on api learning by investigating the different types of questionsdevelopers ask when working with unfamiliar apis investigating why some questions are difficult to answer and researching the cause of the difficulty.
our study was inspired by the work of sillito et al.
who looked at the differenttypesof questionsdevelopersask when workingon maintenance tasks .
to investigate those questions abou t the use of apis that are difficult to answer we conducted a study in which twenty participants worked on two programming tasks using different real world apis.
the study generated over twenty hours of screen captured videos and the verbalization of the participants spanning differen t programming sessions.
our analysis of the data involved generating generic versions of the questions asked by the participants about the use of the apis abstracting each question from the specifics of a given api and identifying those questions that proved difficult for the participants t o answer.
based on the results of our analysis we isolated twenty different types of questions the programmers asked when learning to use apis and identified five of the twenty questionsasthemostdifficultfortheprogrammerstoanswer in the context of our study.
drawing from varied sources of evidence such as the verbalizations and the navigation paths of the participants we explain why they found certain questions hard to answer and provide new insights to the cause of the difficulties.
the different types of questions we have identified and the difficulties we observed can be used for evaluating tools aimed at improving api learning and in identifying areas of the api learning process where tool support is missing or could be improved.
as an example we identified some areas where support is limited from existing tools includin g the need for tools that would assist a developer in easily identifying types that would serve as a good starting point for searching for code examples or for exploring the api for a given programming task.
ii.
relatedwork api usability studies previous studies on api usability sought to identify factors that hinder the usability of apis and to understand the trade offs between design options.
ellis et al.
conducted a study to compare the usability ofthe factory pattern in contrast to constructors for object creation they observed that the participants experien ced difficulty and required significantly more time to construct objects with a factory than with a constructor.
stylos et al.
conducted a user study in which the usability of parameterless constructors was compared to constructors with parameters they reported that programmers strongly preferred and were more effective with apis that provide parameterless constructors .
in another study examinin g the placement of methods that is the class to which a methodbelongs styloset al.
reportedthat participantsw ere significantly faster at identifying relevant dependencies and combining objects when the methods of a starting class referenced its dependencies .
clarke uses the cognitiv e dimensions a framework for describing api usability problems to identify specific usability issues wit h microsoft apis and to help inform the design of more usable apis.
other studies have looked at the role of web resources in learning how to use apis in a lab study involving twenty participants and five tasks brandt et al.
observed that programmersused the web primarily for justin time learning of new skills and to clarify or remind themselves of previously acquired knowledge .
prior studies have either focused on the usability of different ap i design choices e.g.
factory pattern versus constructors or the usability issues of a specific api or a learning resource.ourstudycomplementspreviouseffortsbylookin g at the types of questions developers ask when working with unfamiliar apis investigating the cause of the difficultie s they encounter answering these questions and providing suggestions on how tool support for learning how to use apis could be improved.
information needs of programmers severalcontributions have been made in the area of the information needs of programmers in general.
ko et al.
conducted a study in which forty novice programmers were asked to complete several tasks using visual basic .net and identified learningbarriersandinformationneedsthatmustbesatisfi ed for the programmers to compete the tasks.
in a different study ko et al.
observed and transcribed the activities of seventeen developers working on different tasks during a ninety minutes session .
ko et al.
analyzed the transcrip ts for the type of information that developers sought the sources they used and the situations that prevented them from acquiring information.
they identified twenty one different information needs of programmers grouped into seven categories writing code submitting a change triag ing bugs reproducing a failure understanding execution behavior reasoning about design and maintaining awareness .
they also observed that the most difficult needs to satisfy were questions about the rationale for design decisions an d that questions about apis that could not be answered using the documentationor tools were answeredby consultingthecoworkers.sillitoetal.identifiedfortyfourdifferentty pesof questionsasked by programmerswhen maintainingsoftware code and investigated the degree to which existing tools support the questions programmers ask when modifying the sourcecode .thecontributionsofourstudyare similart o that of sillito et al.
that lookedat the questionsprogramme rs asked when maintaining the source code but ours is in the context of api learning.
in addition we utilized a more objectivecriterionfor determininghard to answerquest ions provide a catalog of qualitative evidence explaining why developers find certain questions hard to answer and used more varied sources of evidence such as navigation paths verbalizations and the time spent on various micro tasks i n our analysis than either sillito et al.
or ko et al.
iii.
programming study a. participants we recruited participants from the student population of th e department of computer science at mcgill university using on campus posters and mailing lists and promised a monetary compensation of .
respondents were prescreened using a questionnaire about their programming experience and their knowledge of java and eclipse.
we selected participants from the respondents for our study.
the participants reported a minimum of year programming experience with java year experience with the java api documentation i.e.
javadoc and some experience programming with eclipse.
our participants reporte d between1and6yearsofexperienceprogrammingwithjava with a median of .
years and an average of .
years of paid programming experience.
five of the participants were female our participant pool included ph.d. students m.sc.
students and senior undergraduate students.
although all of our participants were students they are representativeofthepopulationofinterestandtheirexpe rtise level is comparable to that of recent graduates in software development positions which is our target population sinc e our work aims to support novice programmers.
b. tasks we asked each participant to complete two programming tasks the first task using the jfreechart1api and the second task using the java api for xml processing jaxp .
jfreechart is a popular open source api for generating charts.
we used version .
.13of the jfreechart api which has packages and non exception classes.
jaxp is an api for validating and parsing xml documents developed by sun micosystems.
we used version .
of the jaxp api which has packages and non exception classes.
we selected tasks that involved combining multiple objects because previous work on api usability observed that experienced the most difficulty performing such tasks .
we reasoned that tasks requiring the combination of multiple objects are more likely to reveal a variety of questions developer want answered and typical challenges they encounter when learning to use apis.
the participants weregivenamaximumof35minutesperprogrammingtask.
all the participants were unfamiliar with the apis used in the study.
chart task.
we asked the participants to use the jfreechart api to construct a pie chart with three slices undergrads master s and ph.d.s and to save the chart to a file in a graphic format.
to complete this task a participant needed to construct and configure at least five api types jfreechart pieplot piedataset chartfactory andchartutilities and had to discover key relationships between the types for instance the relationship betweenjfreechart the type for representing charts and chartutilities the type needed to save the chart.
xml task.
we asked the participants to use the jaxp api to verify whether the structure of an xml file conforms to a given xml schema.
the participants were provided with both an xml file and an xml schema file and were asked to implement a solution that returns true if the xml file conforms to the given xml schema and false otherwise.
this task requiredthe combinationof at least four api types schema validator schemafacotry andsource and was selected because of the unique challenges it presents to object construction all the required types are abstract with no subtypes the types must be created from factory or public methods.
c. study setting participants completed the study using the eclipse ide version .
and were permitted to use any of the features of the ide.
two main information sources were used in the study the documentation of the apis and the web which provides access to example usages of the apis.
these information sources have been reported to be the primary learning resources for api users .
we provided the participants with the firefox browser to acces s theseinformationsources anddisabledthebrowser shist ory feature to prevent any learning effect between participant s. the programming studies were conducted individually in our research lab.
the participants began each study by watching a four minute video tutorial about the thinkaloud protocol.
participants were then given time to practi ce thinking aloud while working on a web search task.
soon after the participant was given the instructions for the chart task and was given a maximum of minutes to go over the task requirements and to ask questions relating to the requirements.
to avoid influencing the strategy of theparticipants we did not identify the classes or packages of the apisrequiredto completethetasks as wasthe case with previous studies .
also the participants were advised t o proceed as they would typically do when learning a new api.
once the participant was satisfied with the task requirement we loaded an eclipse project which contained a class with an empty main method and the libraries of the relevant api.
we then showed the participant how to use the firefox browser to access the javadoc pages of the apis from the bookmark menu.
at this point the screen and voice recording software camtasia version was started and the participant was asked to begin the task.
the participant was asked to move to the next task upon completion of the chart task or once the minutes allocated for the task elapsed.
the tasks were completed in the same order by all the participants.
d. data collection we used three data collection techniques in our study the think aloudprotocol screencapturedvideos andintervi ews.
in the think aloud protocol participants are asked to verbalize their thought process while solving a given task.
having participants think aloud was particularly useful i n our study as it permitted us to obtain an insight into the participants understanding of the structure of the apis to identify the types of questions participants ask when learning to use apis and to understand why a participant may have difficulty answering a given question.
we also conducted semi structured post study interviews in which the participantswere asked to commentabout the challenges experienced during the programming study.
the interviews lasted minutes.
the screen contents the verbalizationsof the participant s and the interview sessions were captured using camtasia.
the study produced a total of different programming sessions and about hours of screen captured videos and verbalizations of participants working with unfamiliar re alworld apis.
iv.
dataanalysis and results our analysis focused on the questions the participants want answered about the use of an api.
our goal was to identify those questions that are difficult to answer to understand why these questions proved difficult to answer and to recommend programming tools that could facilitate the api learningprocess.ourmethodforanalyzingthedatainvolve d three phases identifying the different types of questions asked by the participants categorizing the questions and coding the exploration patterns used by the participants when searching for answers to these questions.
we refer to a participant by their id for instance p5 for the fifth participant and to the tasks as t1 for the chart task and t2 for the xml task .table i different types of questions observed during the programmin g study generic questions with specific examples in italics of occurrences of participants q.1which packages or namespaces of an api provide types relevan t to my task?
i m trying to find out which package has classes for creating a pie chart p5 t131 q.2is there an api type that provides a given functionality?
the task says i should create a pie chart i m expecting some sort of a piechart class to be available p18 t111 q.3does an api type provide a method for performing a given opera tion?
is there a method on bufferedimage that helps to save?
p10 t158 q.4what is the functionality of a given api type?
let s look at what the validator class does p18 t232 q.5can a method intended to perform operation a be used to perfor m operation b?
i m hoping that the draw method can be used to save to a file but i m not too optimis tic about it p6 t13 q.6which keywords best describe a functionality provided by th e api?
i m going to use the firefox search to look if there s any thing involving schema p9 t238 q.7how is the type x related to the type y?
how isvalidator related toschema ?
p18 t2 q.8how do i get an object of type x from the type y?
i need to figure out how to get a bufferedimage from apieplot p6 t12 q.9which elements of the api are of the type x?
which classes of the api are comparable ?
p11 t14 q.10is the object x of the type y?
let s see if renderedimage takesbufferedimage p1 t12 q.11does the api provide a helper type for manipulating objects of a given type?
let s see if there are classes related to bufferedimage which can give me the possibility to write the image to a file p10 t119 q.12how do i create an object of a given type without a public const ructor?
the constructor is protected so how do i create a graphics2d object?
p11 t157 q.13which other api elements are necessary to use a given api type ?
i think i need something else that would save the chart to an image p1 t16 q.14which subtype of an interface or class is the most appropriat e for my task?
i don t know exactly which subtype of source to use for reading an xml file p6 t229 q.15which types of a given domain package namespace are relev ant to my task?
which classes of the parsers package could be used for validation?
p18 t227 q.16which method from a list of overloaded methods is relevant to my task?
i m trying to find the appropriate create piechart method because it seems to be o verloaded p16 t14 q.17what role do the arguments of a given method play in its usage?
we have a newinstance string method that takes a string argument and i have no idea what this string is suppose to be p9 t223 q.18what is the valid range of values for a primitive argument su ch as an integer of a given method?
i don t know if this value should be between and p10 t13 q.19is null a valid value for a non primitive argument of a given m ethod?
let s use null for comparable and see if the method throws an exception p1 t14 q.20how do i determine the outcome of a method call?
validator.validate source returns void how do i know the results of the validation?
p12 t215 a. identification of questions in this phase we went through the screen captured videos and the verbalizations to produce a list of specificquestions asked by each participants and to identify segments of the videos which we called episodes corresponding to each question.
each episode also captured the specific approach used by a participant to answer a given question.
some questions were explicit for instance participant p11 asked how do i create a graphics2d object?
while working on the chart tasks.
other questions were easily inferred from the actions and verbalizations of the participants for instance p1 came across the method imageio.write renderedimage ... and said let s see ifrenderedimage takesbufferedimage then went ahead and used a bufferedimage object where renderedimage was expected.
the actions and verbalization of p1 in this example is phrased into the question isbufferedimage of the type renderedimage ?
.
afteridentifying the list of specific questions for each particip ant we then developed genericversions of the questions that slightly abstract from the specifics of a given api.
for instance the question isbufferedimage of the type renderedimage ?
can be stated more generally as is the object x of the type y?
.
based on these generic questions weidentifiedtwentydifferenttypesofquestionsaskedbyth e participants across both tasks see table i .
we also provid e a specific instance for each generic question as an example initalics.
thegenericquestionshighlight toacertainex tent the type and scope of the information developers need when learning how to use apis.
the number of times each type of question was observed of occurrences and the number of participants that asked each type of question of participants are listed in table i. b. abstraction of developer behavior we needed a high level abstraction of the actions of the participants to facilitate the analysis of their behavior a ndthe challenges they experienced when learning to use apis.
since our analysis is centered around the questions asked about the use of the apis we transcribed the segments of the videos corresponding the time frame during which a participant asked and searched for answers to a given question.
specifically for each participant and for each episode corresponding to a specific question we transcribe d the video into a series of actions that summarizes the steps taken by the participant to answer the question.
we considered the following actions browse the participant looked through a list of api elements packages types or methods either within eclipse or in the documentation before making a selection.
the browse action has a targetto denote the items either packages classes methods or search result the participant was browsing through.
select the participant selected an item from a list of api elements or the results of a search query after browsing.
the select action has a target the name of the item selected and a flag yes no to indicate if the selected element was relevant to the question being answered.
the target of the select action could also be none if no item was selected.
read the participant focused on a portion of text or code.
the read action has a target the name of the element being read and a section e.g.
either the introduction section constructor section or the method description of an api element to indicate the location the participant focused on.
navigate the participant followed a dependency or a link to another element.
the navigate action has a target the name of the item navigated to a flag yes no to indicate if the targetled to information relevant to answering the question.
search the participant performed a search of the documentation or the web.
the search actions has a target documentation web and a flag yes no to indicate if the search query contained the name of an api element.
switch the participant moved from the documentation to the web or ide and vice versa.
use the participant attempted to use an api element or code example found on the web.
this action has a target the element or code the participant attempted to use and a flag yes no to indicate if the participant was successful.
backtrack the participant stepped back to a previous location of certainty then decides to explore a different path.
this action has a target the location the participant backtracked to.as an example table ii shows a partial transcript3of the participant p15 looking for information on how to save abufferedimage the transcribed actions is shown under the action sequence column.
p15 started by navigating to the documentation page of bufferedimage browsed through its subtypes and then selected the subtypewritableimage not relevant to saving an image.
p15 read the introduction section of writableimage then backtracked to bufferedimage .
p15 then browsed through the methods of bufferedimage focusing on thecreategraphics method before switching to the web.
p15 then searched the web with a query containing an api element selected the third results read through the code example and discovered the imageio.write renderedimage ... method.
p15 then used imageio.write renderedimage ... successful to save the image to a file.
table ii transcript excerpt for participant p15 c harttask time question action sequence how do i save a bufferedimage?nav browse select read backtrack browse read switch search select read use what is a difficulty?
as part of our analysis we intended to identify questions that proved difficult for the participants to answer and to understand the cause of the difficulty.
to accomplish this we needed an objective measure as to what constitutes a difficulty in the context of api learning.
we decided not to use the amount of time taken to answer a question as the main measureofdifficultysincesignificantperformancevariati ons have been observed amongst developers with similar level of experience .
at a higher level we observed that some of the actions or sequence of actions of a participant that reflected a lack of progress in the search for answers to a given question would serve as a good measure for capturing difficulty.
we used the following action sequence s asadefinitionofthedifficultyparticipantsencounteredwh en answering questions about the use of the apis use this action sequence captures instances in which a participant attempted to use an api element but was unsuccessful because the api does not support the given usage.
for instance the participants p6 and p8 commented how can i get an 3the entire transcripts for both tasks and for all the partic ipants are available as an online appendix eduala apistudy table iii asummary of the difficulties participants experienced answering different types of questions about the use of apis.
question id times instances participants difficulty q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. q. instance of validator?
after their attempt to instantiate validator anabstractclass fromthedefaultconstructor failed.
this object instantiation difficulty is captured by theactionsequence use .we observed that participants often had expectations about thedesignofanapiandexpressedfrustrationwhenthe structure of an api did not match their expectations.
browse select ... then backtrack ornavigate ... then backtrack theselect andnavigate target no action sequences capture instances in which a participant went down an irrelevant information search path.
once a participant realized the information on a givenpath was not relevant to answering their question they backtracked to previous location of certainty and then chose a different path to explore captured by thebacktrack action.
we consider action sequence select ornavigate followed by abacktrack as an indication of difficulty in searching for answers to a given question.
the participants relied on cues in the documentation or code examples when looking for answer to a given question.
at times the clues were not available or perceivable.
in the absence of strong cues participants were left to guess which search paths to follow and some participants inadvertently went down irrelevant search paths.
we summarize the difficulties the participants experienced answering the different types of questions in table iii.
for each question we provide the number of times the question was observed times the number of instances with a difficulty instances the number of participants who posed th e question participants and the number of participants w hoexperienceda difficulty answering the question difficult y .
as a baseline we considered a question difficult to answer if all of the following conditions apply at least half of the participants who posed a question experienced some difficulty answering the question.
at least five participants experienced some difficulty answering the question.
a difficultywasobservedinabouthalfthe totalnumber of the instances in which a question was asked.
for instance we considered the participants to have experienced difficulty answering question q. since eleven of the thirteen participants who posed the question experienced difficulty answering it and since a difficulty was observed in eleven of the fifteen instances in which the question was asked.
we identified five questions that proved difficult for the participants to answer boldfaced i n table iii q.6which keywords best describe a functionality provided by the api?
q.7how is the type x related to the type y?
q.11does the api provide a helper type for manipulating objects of a given type?
q.12how do i create an object of a given type without a public constructor?
q.20how do i determine the outcome of a method call?
c. observations we present our findings as observations of the challenges a developermayencounterwhenlearningtouseanapi along with the supporting evidence for each observation.
these observations are supported by the results of our analysis of the data from the study and by the verbalizations of the participants.
observation discovering relevant dependencies .
discovering relevant api types not accessible from the type a developer is working with is a major challenge to api learners.
three questions q. q. and q. of the five we identified as being difficult to answer involved a participant either looking for types related to and relevant to the use of a type they were working with let s see if there are classes related to bufferedimage which can give me the possibility to write the image to a file p10 t1 or a participant seeking to discover the relationship between api types how isvalidator related toschema?
p18 t2 .
although different these three questions illustrate a common problem the participants experienced significant difficulty when relevant api types were not accessible from the type they were working with i.e.
these helper types were not referenced or reach able from any of the public members of the type thetable iv acomparison of the search queries with and without an apielement .
search queries with an api element total queries reformulated queries successful queries search queries without an api element total queries reformulated queries successful queries developer was working with .
for instance in the chart task the participants could save the jfreechart object usingchartutilities.savechart jfreechart ... but most experienced difficulty locating chartutilities because it is not accessible from jfreechart .
twelve of the participants in our study experienced some difficulty findingchartutilities q. table iii and three of the participants were unable to complete the chart task because they could not locate this relevant dependency.thi s observation corroborates the findings of stylos et al.
that method placement the class on which a method is placed affects api usability.
however observation extends beyond method placement the participants also had difficulty discovering the relationships between types q. table iii or creating objects for types without a public constructor q. table iii because the relevant helpertypes were not accessible from the type they were working with.
participant p4 attributed this difficulty to the lack o f a cross reference in the api that says get a validator instance from a schema .
observation query formulation .
in the context of our study having an api element as one of the keywords in a search query was an effective strategy for locating relevan t code examples.
we analyzed the queries the participants formulated when searching for code examples on the web and observed that queries that contain an api element were more successful thatis ledtoarelevantcodeexample thanthosewithouta n api element see table iv .
there were a total of queries containing an api element and of those only four were reformulated and of the queries containing an api element led to a relevant code example.
on the other hand there were a total of queries without an api element of the queries were reformulated and only one of the queries led to a relevant code example.
as an example participant p18 started the xml task with the search query java xml processing tutorials but found no relevant code example.
he then turned to the documentation where he identified the schema class as relevant to the validation task.
participant p18 then reformulated the search queryto java xml validation against schema from which he found a relevant code example.
our observationabout query formulation corroborates the finding from the analysis of the koders search engine logs where queries with code elements lead to the most downloads .
a complementary observation about query formulation is the difficulty of guessing keywords that correspond to word usage in apis or their documentation.
this difficulty was captured by the question q. which keywords best describe a functionality provided by the api?
up to seven of the thirteen participants who asked this question experienced some difficulty guessing a correct keyword.
void validate file throws filenotvalidexception returnstatus validate file vs. a b figure .
two possibilities for communicating method leve l execution failures.
observation exceptions .
the use of an exception to communicate the outcome of a method execution hinders api comprehension.
there is a long standing debate in the software development community regarding whether an exception as in figure a or a return status object4 as in figure b should be used to communicate method level execution failures and when each design choice may be appropriate .
when an exception is used to communicate the failure of thevalidate file method the implication is that the fileis considered valid if the method does not throw an exception.
in other words the exception is used to communicate the return status failureorsuccess of the validate file method the validation is said to have failed if the method validate file throws an exception and successful otherwise.
however the extent to which this implicationis apparentto a developerlearningto use an api remains uncertain.
in the xml tasks the participants had to usethemethod validator.validate source thatused an exception to communicate outcome to validate an xml file.
we observed that the use of an exception to communicate outcome was problematic to the participants of the participants experienced significant difficulty realizi ng the implicationthat if the method validate source does not throw an exception then the source file is considered valid q. table iii .
the participants spent an average of .
minutes each before becoming aware of the implication that the xml file is considered valid if 4we used the word return status object to represent either an error code a primitive such as a boolean or an integer or an object tha t contains the return status of a method execution.the validation method does not throw an exception the average time spent to make this discovery increases to .
minutes if we consider just the participants that faced a difficulty.
participants p5 p14 and p20 were unable to make the discovery within the alloted time for the task even after spending minutes minutes and minutes respectively on this part of the task.
we looked at the verbalizations of the participants and the post study interviews in an attempt to understand why they could have missed the implication that the xml file is considered valid if the validation method does not throw an exception.
we identified two possible reasons for this difficulty.
the expectation of the participants.
the participants expected the api to provide a validation method with a return status object such as in figure b butvalidate source had no return status object validate source does not give us something like true or false i better look for a method that gives us a boolean p1.
not finding the expected method that is a validate method with a return status object participants wo uld initially assume that validate source is not the right method to use instead of making the connection that an exception is used to communicate the success or failure of the validation.theywouldthen spendtime lookingforother methods in the api with a return status object that could be used to validate the xml file.
not finding an alternative the participants would then return to the validate source method re readits documentation and realize that the xml file is considered valid if the validation method does not throw an exception.
disagreementbetweenapidesignersandparticipantsas to what constitute an error condition .the second reason expressedbythe participantsas to whytheyexperienced difficulty associating exceptionsto the success or failur e of the validation relates a disagreement as to what constitute an error condition.
according to expert api designers if a member cannot successfully do what it was designed to do what the member name implies it should be considered an execution failure and an exception should be thrown .
in other words an execution failure is said to have occurred if the validate source method cannot validate the xml file and an exception shouldthereforethrown.our participants on the other han d seem to associate the throwing of an exception to something catastrophic if you re just trying to validate something why would it throw an exception it doesn t make sense i expected it to return an object p14.
in my experience ... i find consensus that you throw exceptions only when you find an error.
in a validator you expect some thing to be valid or invalid.
and if its invalidthat should be a common occurrence just as much as it is valid.
so throwing an exception for common occurrence is not a good idea p11.
this disagreement between api designers and our participants reflects the debate as to when exceptions should be used.
some argue that exceptions are for exceptional conditions others argue that exceptions should be used to report all errors .
the software development community has yet to agree on what constitutes an exceptional condition.
our study indicates that this disagreeme nt has the potential for influencing api comprehension.
observation web versus documentation .
the use of the web had no effect on the number of tasks successfully completed or the time taken to complete a task.
in designing the study we had ten of the participants use the web and the api documentation as learning resources the web group wg and the other ten using just the documentation the documentation group dg .
we reasoned that partitioning the participants into two group s would help us identify the challenges programmers faced whenlookingforanswertothequestionsusingbothlearning resources.
we expected the participants in the web group to be significantly more successful since the web provides several code examplesfor both tasks.
however we observed no significant advantage either in terms of the number of tasks successfully completed or the average time taken to complete a task between the participants of the web group over the participants of the documentation group.
six participants from the documentation group and seven participants from the web group successfully completed task t1 and six participants from the documentationgroup and five participants from the web group successfully completed task t2.
we obtained a chi squared statistic of when we compared the number of tasks successfully completed between the two groups.
looking at the task completion times the participants of the documentation group spent an average of minutes on task t1 while participants from the web group spent an average of minutes.
we observed similar results for task t2 participantsof the documentationgrou p spent an average of minutes while participants from the web group spent an average of minutes.
we used the rank test to compare the task completion time between the two groups and obtained a p value of .
for task t1 and a p value of .
for task t2.
but why were the participants who used the web not significantly better than those who used the api documentation?
we observed that some participants often underestimate the time required to find code examples on the web extract therelevantcodesnippets andtocustomizethesnippetsin to the context of a task.
some participants spent a significant amountoftime extractingandcustomizingrelevantsnippet s. for example participant p13 found a code example for taskt2 at the minutes mark but was unable to complete the task in the remaining minutes because of difficulties in extracting and customizing relevant code snippets.
when asked about this in the post study interview participant p commented that the example had a different context from our task so i had to translate their ideas to ours and that takessometime .otherparticipantsstartedwiththewebbut soonrealizedthedifficultyoffindingrelevantcodeexample s with no knowledge of the types in the api.
for instance p18 started with the web but soon abandoned the web for the api documentation after two unsuccessful searches commenting having some knowledge of the classes in the api may actually be able to help me understand the information provided by the tutorials .
in general we observed that both learning resources provide complementary suppor t to programmers learning to use apis.
also the absence of a significant difference between the two groups suggests that the time required by novice api users to find extract and customize code snippets from code examples may be comparable to the time needed to learn how to use apis from the api documentationfor basic tasks such as the ones in our study.
v. implications a. api design and documentation proponents of the debate on how to communicate methodlevel failures typically endorse either the use of an exception or the use of a return status object but seldom both exceptions should be used to report all errors for all code constructs .
our results explain and document why the use of an exception to communicate the outcome of an operation may be problematic from an api comprehension perspective.
in such situations it seem reasonable for api designers to consider providing both a return status object to provide status informatio n in the case of a successful operation and an exception to communicate method execution failure .
steven clarke of the user experience group at microsoft research and a pioneer of the work on api usability echoed this view in a book on framework design guidelines although return codes should not be used to indicate failures you can still consider returning status information in the case of a successful operation .
in general our study underscores the need to investigate theimpactofapidesignchoicesonapilearningandusability beforeadoptinga givendesign choice.
apis are provided to improve programmers productivity but poorly designed orpoorlydocumented apismayproduceacountereffect.in our work with apis we have observedsituationswhere programmers had to re inventthe wheel because apis designed for their task were difficult to understand .
api usabili ty studies provide a venue for identifying and fixing usability and comprehension problems before an api is made public.b.
tool design the primary motivation for our study was to understand the natureofapi learningandhowbest to supportprogrammers learning to use a new api.
we have identified different types of questions the programmers asked about the use of apis and also five questions that proved the most difficult for the programmers to answer.
we believe these questions could help evaluate existing tool support and identify are as where support is lacking.
as an example we present three areas of difficulty where support is currently limited.
discovering relevant api elements not accessible from the type a programmer is working with.
jadeite uses a concept known as a placeholder to allow a developer to annotate the documentation of an api type with other api types or methodsnot accessible but relevantto it s use.
given a particular function altair and friar use heuristics and structural relationships to find other re lated functions.
jadeite is the only tool to our knowledge aimed at helping programmers discover types or methods not accessible from a main type.
we consider jadeite a precursor to an ideal tool for making relevant api elements not accessible from a type discoverable.
our ideal tool would automatically generate and recommend placeholders and would be integrated with the ide preferable with the content assist feature of the ide.
discovering the types of an api relevant to implementing a task.
the names of api types and methods provide a common vocabulary between api users and api designers consequently the use of types and methods for query formulation proved to be an effective strategy in the context of our study for locating code examples relevant to implementing a task.
surprisingly support for helping programmers discover the types of an api relevant to a task is limited.
in fact most code recommendation tools are based on the premise that programmers already know the types of an api relevant to their tasks but this is not often the case.
sourcerer helps programmers locate relevantapielementsbysuggestingwordsfromopensource systems that share concepts that are related to the terms in a search query .
jadeite leverages usage statistics fro m code examples on the web to display commonly used types of an api more prominently.
jadeite and sourcerer have one drawback they are unusable in the absence of a corpus of code examples consequently apis without a corpus of examples or less commonly used parts of an api may not be supported.
there is a need to further explore complementary approaches such as the relationships between api elements used by prospector for recommending api types relevant to a task.
unmasking the relationships between api types.
some of the difficulties we observed occurred when the dependen cies between related api elements were not obvious or not properly documented.
for instance although the validator class and schemaare related a validator object is created from aschemaobject this relationship cannot be inferred from the validator class.
participant p4 referred to this as the absence of a cross reference in the api documentation that says get a validator instance from a schema when commenting about the difficulty experienced relating these types.
one potential solution would be to explicitly documentsuchhiddendependencies.alternatively toolscould be developed to automatically identify and reveal such hidden relationships between api elements to developers through the content assist feature of ides.
c. threats to validity the results of our study are based on a systematic observation of programmers working with real world apis in a laboratory environment.
given this setting there are fact ors which limit the generalizability of our observations.
the types of questions we observed in the study the process of answering the questions and the challenges the participants experienced are related to a certain extent to the tasks and the experience of the participants.
some of the questions and the difficulties we observed in the study have been observed in previous api usability studies in differen t settings however given that our study wa s exploratory in nature and intended to probe whydevelopers experiencedifficulties andalsogiventhelabsettingandp redefined tasks the catalog of questions cannot be considered complete but a starting point.
the difficulty the participants experienced in associating the throwing of an exception to the success or failure of the validation could have been a result of their limited programming experience.
this threat was mitigated by our useofthethink aloudprotocolwhichshowedthatourpartic ipants had no apparentconfusionwith the validation domain they could implement a solution to validate the xml file .
rather the difficulty they encountered was well isolated to the use of exceptions to communicate method level failures the implication that an operation is considered successful if the method does not throw an exception was not apparent to our participants.
furthermore steven clarke is quoted as reporting similar observations amongst professional pr ogrammers in a book on framework design guidelines in oneapiusabilitystudywe performed developershadtocall aninsertmethod to insert ... records into a database.
if the method did not throw an exception the implication was that the records had been inserted successfully.
however this was t clear to the participants in the study.
they expected the method to return the number of records that were successfully inserted .
the results of our study closely corroborate clarke s observation amongs t professional programmers the extent and reasons for thedifficulty for the population of professional programmers would have to be determined by another study.
the size of our tasks the number of tasks and the number of participants also limits the generalizability of our observations.
although our tasks represented real usages o f real world apis they were limited in size to permit our participants to complete a task within the minutes time frame.withonlytwotasksand20participants thequestion s and the challenges observed in our study could be limited.
however our use of participants is equal or above the current standard of evidence in user studies of software engineering tools .
furthermore given the observation that programmersoften approachlargerprogrammingtasks by focusing on smaller subtasks we believe that the different types of questions and the challenges we observed possibly limited would generalize to other api learning tasks.
lastly our study involved only java apis and the java api documentation.
some of our observations may be different for apis and documentation in other languages.
also since our study focused on programmerslearning how to use unfamiliar java apis our observations may not be applicable to programmersworking with familiar java apis.
further studies on api usability are required to verify the generalizability of our observations to these contexts.
vi.
conclusion to understand the difficulties programmers encounter when working with unfamiliar apis the cause of the difficulties and to investigate how best to support api learning we conducted a study in which programmers worked on programming tasks using two real world apis.
the study generated over hours of screen captured videos and the verbalization of the participants spanning differen t programming sessions.
our analysis of the data involved generating generic versions of the questions asked by the participants about the use of the apis identifying those questionstheproveddifficulttoanswer andinvestigating the cause of the difficultyusing the verbalizationandthe actio ns of the participants.
based on the results of our analysis we identified different types of questions programmers ask when learning to use apis.
we also identified five of the questions as being the most difficult for the programmers to answer and provide observations to explain the potentia l causes of the difficulties.
we believe the questions we have identified and the difficulties we observed can be used for evaluating tools aimed at improving api learning and to identify areas of the api learning process where tool supportis lacking or could be improved.as an example we identified some areas where tool support is currently limite d including the need for tools that would assist a programmer easilyidentifythetypesofanapithatwouldserveasagood starting point for searching for code examples or a startin g point for exploring the api for a given programming task.