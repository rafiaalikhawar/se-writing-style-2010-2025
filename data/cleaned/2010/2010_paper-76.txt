an empirical study of optimizations in yogi aditya v. nori microsoft research india adityan microsoft.comsriram k. rajamani microsoft research india sriram microsoft.com abstract though veri cation tools are nding industrial use the utility of engineering optimizations that make them scalable and usable is not widely known.
despite the fact that several optimizations are part of folklore in the communities that develop these tools no rigorous evaluation of these optimizations has been done before.
we describe and evaluate several engineering optimizations implemented in the yogi property checking tool including techniques to pick an initial abstraction heuristics to pick predicates for re nement optimizations for interprocedural analysis and optimizations for testing.
we believe that our empirical evaluation gives the veri cation community useful information about which optimizations they could implement in their tools and what gains they can realistically expect from these optimizations.
categories and subject descriptors d. .
software program veri cation correctness proofs model checking d. .
software engineering testing tools symbolic execution general terms testing veri cation keywords software model checking directed testing abstraction renement .
introduction over the past decade we have seen several program veri ers and static analysis tools used in industrial practice.
the algorithms implemented in these tools are available in published literature and the principles behind these algorithms are well understood.
however the scalability and usability of these tools relies as much on careful engineering of optimization techniques as on the algorithms.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.thus it is important for the research community to understand which optimizations work well in practice and how much bene t each optimization brings.
knowledge about which optimizations work in practice is less widely known since papers about engineering optimizations are less fashionable than papers about new algorithms.
in addition several of the tools mentioned above are commercial tools and source code for these tools is not available to the research community at large.
as a result it is very difcult for the community to replicate these veri cation tools.
thorough evaluation of optimizations will help a researcher building a new veri cation tool decide which optimizations to implement.
part of the di culty in evaluating optimizations is that it is very di cult to design veri cation tools that are bug free!
for example a bug in an optimization technique for a model checker could lead to the state space being pruned in an unsound manner.
as a result the model checker could show impressive performance gains but the bug in the optimization could just remain unnoticed.
thus measurements about the e ciency of optimizations can be trusted only after the veri cation tool itself has been tested extensively.
the goal of this paper is to empirically measure the optimizations implemented in the tool yogi .
yogi is a program veri er that checks safety properties of sequential c programs.
yogi has the capability to certify whether a program satis es a property and it can generate a test case to demonstrate that a program violates a property.
over the past year yogi has been extensively tested using benchmark suites for the static driver veri er toolkit sdv .
the testing team for sdvhas created several test suites over the years.
one test suite consists of small examples that exempli es tool errors that have surfaced in the past.
another test suite contains device drivers and properties and hence a total of runs.
the testing team has thoroughly analyzed the test suite and determined the correct answer to each of these runs.
since yogi has been extensively tested using these test suites and the results inspected by several people we have su cient con dence about the correctness of yogi and believe that these test suites can be used to empirically measure the e ect of optimizations.
the optimizations themselves are not novel.
several of the optimizations are part of the folklore in the software model checking community and have been implemented before in tools such as slam and blast .
however they have never really been thoroughly evaluated before which is the main contribution of this paper.
the core premise behind yogi is that static veri cationcan be combined with testing to improve e ciency.
the algorithms in yogi have evolved over time.
we rst presented synergy which is the core algorithm but it worked only for single procedure cprograms without pointers.
next we discovered a new way to deal with pointers using the dash algorithm .
more recently we have added a way to perform interprocedural analysis such that information is reused from both tests and proofs using the smash algorithm .
orthogonal to the algorithmic development we have implemented a number of optimizations to make yogi scale to large and realistic programs.
in this paper we describe these optimizations and evaluate each of these optimizations empirically.
in particular we evaluate the e ect of the following optimizations initial abstraction using predicates from the property.
relevance heuristics to help pick suitable predicates for re nement.
optimizations for interprocedural analysis including global modi cation analysis and summaries for procedures.
using thresholding to limit the number of steps to run tests.
fine tuning stubs to make them executable so that yogi can work correctly.
we present detailed empirical results for the e ect of each of these optimizations over a large number of sample programs.
we believe that these optimizations represent a bulk of the engineering we had to do in order to make yogi scale and work on large programs.
.
overview a detailed description of yogi s algorithms can be found in .
here we give an overview of the algorithm with just enough detail to allow us to describe the optimizations which are the subject of this paper.
the goal of yogi is to solve the property checking problem.
an instance of the property checking problem consists of a sequential program pand an assertion .1an answer to the property checking problem is pass if every run of p satis es the property .
the answer is fail if there exists some run of pthat violates .
in the latter case the goal of yogi is to come up with a test input tsuch that the run of pobtained by giving input tviolates .
since the property checking problem is undecidable in general it is not possible for yogi to give correct pass or fail answers to all instances of this problem.
speci cally yogi might fail to terminate for certain problem instances.
static analysis and testing are complementary approaches to the property checking problem.
with static analysis we can obtain very good coverage and analyze program paths that are hard to exercise using testing but we are forced 1yogi can also check safety properties expressed in the slic language.
however these can be compiled down to assertions so there is no loss of generality by considering assertions.
2in practice we stop every run of yogi after seconds and say that yogi is unable to give a conclusive answer to the property checking instance.
figure the yogi algorithm.
to deal with scalability issues and false errors.
with runtime testing we can obtain only partial coverage but the approach scales to large programs and every error that is reported is indeed realizable.
yogi s algorithm combines static analysis based on abstractions which are region graphs together with testing based on light weight symbolic execution .
yogi simultaneously maintains a nite set of test runs and a nite abstraction of the program.
a test or test run is a nite sequence of program states starting from some initial program state.
an abstraction is a nite graph whose vertices are regions and whose edges are over approximations of transitions between states.
each region represents an innite set of states.
an edge exists in the abstraction from region 1to region 2whenever there exists states s2 andt2 2such that there is a transition from stotin the program.
the set of initial states are grouped together to form an initial region and the set of states that violate an assertion are grouped together to form an error region in the abstraction.
a set of tests forms an underapproximation of the set of all runs of the program since every test is a run and not all runs are represented in the set of tests.
a region graph forms an over approximation of the set of all runs of the program since every run has a corresponding path in the abstraction whereas every path in the region graph need not necessarily have a corresponding run.
the goal of yogi is to either nd a test that starts from the initial region and ends in the error region or nd an abstraction that is strong enough to show that no such test exists.
a high level view of yogi s algorithm is shown in figure .
yogi starts with an initial abstraction which can either be the control ow graph of the program or its re nement that is based on some predicates from the property as described below and a set of randomly selected tests.
during every iteration if a test has managed to reach the error region yogi declares test succeeded and outputs the bug found.
if no path in the abstract region graph exists fromthe initial region to the error region yogi declares abstraction succeeded and outputs the current abstraction as the proof that the program satis es the property.
if neither of the above two cases are true then yogi nds a path in the abstraction from the initial region to the error region along which a test can be potentially driven to reveal a bug.
yogi crucially relies on the notion of a frontier which is the boundary between tested and untested regions along the abstract counterexample that a test has managed to reach.
in every iteration the algorithm rst attempts to extend the frontier using test case generation techniques similar to dart .
if test case generation fails then the algorithm re nes the abstract region graph so as to eliminate the abstract counterexample.
for performing re nement the dash algorithm uses a new re nement operator wp which is the usual weakest precondition operator that uses information from executed tests in order to compute sound and succinct re nement predicate .
we have now provided enough background to describe the optimizations studied in this paper.
the rst set of optimizations are concerned with creating an initial abstraction that is better than the control ow graph of the program.
we use predicates from the slic property to split regions of the control ow graph and create an initial abstraction.
we can also choose other predicates to split based on data ow dependencies on these predicates.
however the more the initial predicates the greater is the cost in terms of both time and space to create the initial abstraction.
this tradeo is evaluated in section .
the second set of optimizations are concerned with choosing relevant predicates for re ning the abstraction.
here we study two optimizations one that performs cheap interpolant computation and another that uses domination relationships in the control ow graph to eliminate predicates from the program using a pre pass with the caveat that some of these removed predicates might be replaced later if necessary .
these optimizations are described and evaluated in section .
the third set of optimizations are concerned with interprocedural analysis.
techniques such as global modi cation analysis as well as storing and re using summaries from each analysis of a procedure can greatly improve the e ciency of interprocedural analysis.
these optimizations are described and evaluated in section .
the fourth set of optimizations are concerned with how long tests need to be run to be e ective.
every transition computed using a test can potentially save a theorem prover call in the future.
however running tests also costs in terms of time and space.
section evaluates the best parameter setting for how long to run tests.
the nal set of optimizations are concerned with writing accurate stub functions.
we painfully discovered that writing stub functions for yogi is more challenging than writing stub functions for tools based on purely static analysis such asslam orblast .
the main reason is that the stub functions for yogi need to be precise enough to be executable for the purpose of running tests.
section measures the amount of e ort needed to produce executable stub functions on our benchmark test suites.
.
evaluation setup currently the windows driver group is evaluating yogi as an engine to be used within microsoft s static driver ver i er toolkit .
as a part of this evaluation yogi has been fully integrated as the property checking engine inside sdv static driver veri er .
slam is another property checking engine for sdv.
one of the signi cant advantages of this integration is that it is possible to run yogi over large test suites that are maintained and evolved by the windows test team.
as a part of this evaluation the windows team has extensively compared results produced by slam andyogi over this test suite.
discrepancies between the outputs of the tools have been tracked and xed.
for the purposes of this paper we consider two benchmark test suites from the sdv toolkit .c test suite the rst test suite consists of cprograms that were created to test tool errors that have surfaced in sdv over the past years.
this suite called smallc suite consists of positive tests and negative tests.
yogi takes approximately minutes to run on this suite.
.wdm drivers the second suite called wdm suite consists of device drivers written for the windows driver model wdm and properties a total of checks also developed over the past years.
the total number of lines of code analyzed is kloc but each driver is analyzed repeatedly times for each of the properties and yogi takes approximately hours to run on this suite on a single processor.
for every run in these suites the expected result that is the property should pass or property should fail has been manually established by the windows group over the years.
sdv itself is routinely run over several millions of lines of driver code including drivers for the new kernel mode driver framework and user mode driver framework called kmdf andumdf respectively networking drivers that use the ndis driver model etc.
the anecdotal belief in the windows group is that any tool bugs that surface in these bigger runs are usually caught in the above two test suites .
our own experience with these test suites corroborates this belief whenever we make a mistake in implementing an optimization these tests usually nd them it manifests as some run where the buggy optimization says that the run passes but the property check is expected to fail on the run .
in this paper we measure the e ectiveness of an optimization by evaluating yogi with and without the optimization on the wdm benchmark suite.
we do not report performance numbers on the smallc suite because the runs in this suite nish quickly even without any optimizations and the optimizations have no e ect on the runtime.
however the smallc suite is very e ective in catching bugs in the optimizations.
we have tested each optimization we report in the paper on smallc suite to con rm that we have not implemented the optimization erroneously.
our earlier papers report comparisons between yogi and slam .
as a result of valuations over several hundreds of thousands of lines of code extensive comparison of results between yogi andslam and extensive comparison between results produced by yogi and results expected by thesdv team in these test suites we believe that yogi is 3since each check is independent we run this on an core machine usually to get the runs to complete quickly.
state enum locked unlocked state unlocked keacquirecancelspinlock.entry if state unlocked state locked else abort kereleasecancelspinlock.entry if state locked state unocked else abort figure slic speci cation for cancelspinlock property.
currently a stable and robust tool and we have con dence in the correctness of all the optimizations we report in this paper.
without such extensive testing empirical evaluations of optimizations could be awed since buggy optimizations can boost performance due to unsound pruning of the state space of the program being analyzed.
.
presentation methodology all evaluations are done using runs of yogi on the wdm suite.
we make a few remarks about how we present the results of our evaluations.
we group the optimizations logically so that interrelated optimizations are in the same group.
each of the subsequent sections presents a description and evaluation for one group of optimizations.
for each group we present two sets of empirical data.
we present aggregate numbers for total time taken total number of defects found and total number of defects found for every possible choice of enabling disabling each optimization in the group.
for instance table presents aggregate data for relevance heuristics.
since there are two relevance heuristics we consider possible choices with or without each relevance heuristic.
thus there are rows of data in table .
in addition we present scatter plots for comparing runtimes of individual runs between these possible choices.
as a convention the x axis of all scatter plots represent runtimes with all optimizations present .
in the y axis of each plot we consider various choices where at least one optimization is absent .
for example in section we evaluate two optimizations spandcdand show the e ect of these optimization in scatter plots figure figure and figure .
the x axis represents yogi s runtimes with both the spandcdoptimizations and the y axis in the each of the gures represents yogi s runtimes for the other three possible combinations of these optimizations without sp with cd with sp without cd and without sp without cd .
if most points in the scatter plots lie above the line x y then this is an indication that the optimization is e ective.
.
initial abstraction one possible choice for the initial abstraction used by yogi is the control ow graph of the program.
often we nd that splitting the abstraction based on predicates present in the conditionals of the slic property greatly helpsabstraction using total time no.
no.
slicpredicates minutes defects timeouts yes no table empirical evaluation of initial abstraction using slicpredicates using the wdm suite.
avoid exploring false counterexamples in the abstraction.
for example consider the slic property shown in figure which speci es constraints on sequences of operations on cancel spin locks in the windows kernel.
at a high level the property states that calls to keacquirecancelspinlock and kereleasecancelspinlock need to be performed in strict alternation.
a detailed description of the syntax and semantics of slic can be found in .
for the purposes of this paper think of a slic property as an object with some state here the state is an enum type which can take one of two values locked orunlocked and instrumentation added at appropriate points in the program to methods that manipulate the state here instrumentation is added to the entry of calls to keacquirecancelspinlock and kereleasecancelspinlock .
suppose we use yogi to check this property on a large program.
suppose further that the program indeed satis es the property.
we nd that an abstraction to establish this property needs to split all regions with the predicates state locked and state unlocked .
these predicates are typically discovered by yogi through several iterations of counterexample driven re nement.
thus it makes sense to juts add them upfront and compute an initial abstraction in which each region in the abstraction is split with these predicates motivating this optimization.
however there are several subtle choices in implementing this optimization.
sometimes predicates in conditionals of slic properties depend on argument or return values to function calls that they are instrumenting.
in such cases it is sometimes useful to propagate the predicates to the actual parameters or the variables that gets the return value assigned at the call site.
we experimented with adding such predicates as well and we found that this resulted in actually slowing down yogi substantially.
thus the sweet spot we have arrived at is to introduce predicates based on slic predicates that do not depend on parameters or return values in the initial abstraction.
we present empirical results to show this sweet spot produces performance bene ts.
.
empirical results table shows aggregate metrics for running yogi over thewdm suite with and without initial abstraction using predicates from slic.
the rst row of the table shows data from the run with the initial abstraction optimization and the second row of the table shows data from the run without this optimization.
as the results show the time taken byyogi improves due to this optimization and the number of timeouts with timeout threshold equal to seconds reduces considerably as well.
to drill down into these aggregate results further figure shows comparisons of runtimes of individual runs of yogi with and without this optimization.
this plot shows that while most runtimes improve due to the optimization most points are above the straight line x y there are severalfigure evaluating the impact of slicabstraction onyogi.
cases that degrade in runtime as well.
but the degradation never leads to a timeout and there are several runs that timeout without the optimization that indeed complete due to the optimization.
thus the overall e ect of the optimization is very positive and we have included it in yogi .
.
relevance heuristics yogi performs a re nement of the abstraction whenever a test cannot be extended across a frontier.
figure illustrates how yogi performs re nement.
the top picture in the gure shows the frontier between regions sk 1and sk where a test has reached the region sk 1along a path through region sk .
the state reached by the test is denoted by in the gure.
let denote the set of states obtained by performing forward symbolic execution along this test.
note that the set includes the state .
suppose that this test cannot be extended along the frontier.
then yogi performs a re nement as shown in the bottom picture of the gure.
in particular yogi splits the region sk 1using a predicate such that sk and there is no edge in the abstraction from sk tosk.
such a predicate is called a suitable predicate .
the quality of suitable predicates inferred during veri cation also related to the problem of computing invariants in program veri cation is important as it can critically a ect both the e ciency as well as the precision of yogi .
.
sp heuristic as discussed in yogi uses the wp operator to compute the suitable predicate .wp can be used to avoid considering an exponential number of aliasing conditions while performing weakest preconditions over assignments.
thus if the operator opin figure on the frontier is an assignment statement wp is very helpful in producing a simple predicate .
however if the operator opis of the form assume we have that wp op sk sk.
thus thewp operator accumulates conditions from all assume statements along the entire path.
several of the conditionals along the path may be irrelevant to the property we are trying to prove.
in general any interpolant between and sk would do as a suitable predicate.
our theorem prover z3 does not yet support computation of interpolants.
we have discovered a simple relevance heuristic called the spheuristic to avoid accumulating irrelevant conjuncts in the relefigure re nement using suitable predicates.
vant predicate.
the heuristic is as follows.
we rst check if sk 1is a suitable predicate.
if it is we use sk.
otherwise we use skas a suitable predicate.
.
cd heuristic though the spheuristic is useful it still does not fully avoid irrelevant conjuncts in suitable predicates used for renement.
we have found another orthogonal heuristic based on control dependencies.
we pre process the input program pas follows.
for each assume statement in the program4 we mark the assume statement as potentially relevant if some slic function is control dependent on the assume statement.
then we make one pass over the input programpand abstract every assume statement that is not potentially relevant using a skip statement producing an abstract program p0.
next we give the abstract program p0toyogi for checking.
if yogi is able to prove that p0 satis es the desired property then we have that psatis es the property as well.
however if yogi establishes that p0 does not satisfy the desired property and produces a test tthat executes along some control path to demonstrate this we are still not sure if pviolates the property.
thus we execute the path along the original program pto check if it is feasible.
if it is indeed feasible we report a bug in p. if not we add all assume statements that occur along the path top0and rerun yogi onp0.
note that it is possible that only a subset of the assume statements might su ce to explain the infeasibility of the path but this subset is hard to compute in general.
however we nd that adding 4a preprocessing step in yogi converts all if then else and looping constructs to assume statements.
int x void foo bool protect true ... if x protect false ... if protect keacquirecancelspinlock for i i i do stuff but no calls to acquire or release cancelspinlock a readbyte i if protect kereleasecancelspinlock figure example to illustrate relevance heuristics.
sp cd total time no.
no.
heuristic heuristic minutes defects timeouts yes yes yes no no yes no no table empirical evaluation of relevance heuristics inyogi using the wdm suite.
all assume statements along an infeasible path works well in practice.
.
example figure shows an example to illustrate the spand cd heuristics.
assume that the property we are interested in is the one about proper acquisition and release of cancelspinlock from figure .
in this example the call to keacquirecancelspinlock at line and the call to kereleasecancelspinlock are guarded by conditionals which checks if the boolean protect is true.
the other conditionals in the program such as the check x in line and the check i in line are irrelevant for proving the property.
the spheuristic is able to abstract the conditionals in lines and because there is no call to any of the slic functions which in this case are keacquirecancelspinlock and kereleasecancelspinlock that are control dependent on these conditionals.
the spheuristic preserves the conditional at lines and since the calls at lines and lines to the slic functions are control dependent on the conditionals at line and line respectively.
to illustrate the spheuristic suppose yogi needs to perform a re nement at line .
referring to figure supposeskis the region state locked and opis the operation assume i which is from the loop check at line .
the weakest precondition operator wp in this case will yield the conjunction of the two predicates state locked and i .
the spheuristic is able to eliminate the conjunct i from the re nement predicate and simplify the abstraction constructed.
.
empirical results table gives aggregate metrics obtained by running yogi over the wdm suite.
as seen by comparing the rst and second rows of table we see that spheuristic improves overall figure comparison of yogi runtimes with and without the sprelevance heuristic.
figure comparison of yogi runtimes with and without the cdrelevance heuristic.
runtime of yogi on the wdm suite by .
by comparing the rst and third rows we see that cdheuristic improves overall runtime of yogi on the wdm suite by .
by comparing the rst and fourth rows we see that the combination of spand cdheuristics improves the runtime of yogi on the wdm suite by .
to drill down into the individual runs better figure figure and figure compares runtimes from individual runs of yogi with and without the spandcdheuristics.
as seen in figure most points are close to the x y line which shows that the spheuristic does not really a ect a large number of runs.
this is actually due to the fact that the runtime reported for the x axis includes the cdheuristic which mitigates the e ect of accumulation of predicates.
however there are still several runs where the spheuristic helps and there are very few runs where the spheuristic increases the runtime.
as seen in figure most points are well above the x y line and there are some points below the line.
we investigated the points below the line and realized that these are because the cdheuristic sometimes aggressively abstracts the predicates.
sometimes even if a predicate in a conditional does not directly in uence the execution of a slic function it could a ect it indirectly by controlling assignments to some other variable which could later in uence the slic function.
in such cases we nd that more iterations need to be spent by putting these predicates back into the program and yogi runs slower.figure comparison of yogi runtimes with and without both spand cdrelevance heuristics.
however as figure shows the combination of the two heuristics works very well and there are only a negligible number of points below the x y line.
as a result both these optimizations are enabled by default in yogi .
.
interprocedural analysis yogi performs modular analysis one procedure at a time.
every query to yogi is of the formh p 2iwhich means is it possible to execute pstarting with some state from and reach a state in ?
.yogi performs optimizations to reduce the cost of interprocedural analysis and we describe these below.
interprocedural analysis in yogi arises in the case when the frontier is at a procedure call.
referring back to figure suppose opis a call to a function say foo.
then yogi attempts to extend the test across the frontier which is the function call or attempts to perform a re nement of the regionsk .
recall that is the subset of states in region sk 1that are obtained by performing symbolic execution along the test that reaches sk .
as before we desire to pick some state from such that it crosses the frontier or establish that none of the states from can cross the frontier and perform a re nement.
yogi approaches this problem by performing a sub query h foo ski.
to answer this sub query yogi performs the following steps .
first check if the query can be answered using global modi cation analysis.
using alias analysis yogi precomputes for each procedure qan over approximation to the set of all locations that qcan modify.
using this information yogi nds the weakest precondition ofskwith respect to the procedure foo.
in particular it analyzes every l value in the formula representing sk and nds out which of these l values can be modi ed byfoo.yogi then constructs an over approximation to the call foowhere it assumes that every l value that can be modi ed can take an arbitrary nondeterministic value.
using this over approximation suppose yogi is able to prove that from the set of states execution of foocan never reach any state in sk.
then this is a sound answer and yogi uses this to re ne the regionsk .
in particular a suitable predicate is found by computing wp of the region skwith respect to this over approximation just as in the interprocedural case.
if the over approximation fails to produce amodi cation summaries total time no.
no.
analysis minutes defects timeouts yes yes yes no no yes no no table empirical evaluation of interprocedural analysis optimizations with yogi.
suitable predicate for re nement then yogi generates a test that crosses the frontier using the above overapproximation for the call using modi cation analysis .
however this test is not guaranteed to reach sk at the end of the call since the formula used for modeling the call is an over approximation.
.
if the rst step fails then yogi attempts to answer the query using must summaries and not may summaries.
a must summary consists of triples of the form h q iinterpreted to mean that every state in can reach some state in by executing q. a not may summary also consists of triples of the form h q ibut is interpreted to mean that no execution of qcan start in a state from and end in a state in .yogi caches must summaries and not may summaries from every query.
recall that the current query of interest with procedure fooish foo ski.
suppose there is a must summaryh foo isuch that andsk fg.
then yogi uses this to deduce that any test in can extend the frontier.
dually suppose there is a not may summary of the form h foo isuch that and sk .
then yogi uses this to deduce that no state in can reach a state in skby executing foo and that can be used as a suitable predicate to perform re nement of the region sk .
.
finally if both the above steps fail then yogi analyzes the body of footo answer the query h foo ski.yogi then caches the results in the form of summaries so that these summaries can be used to answer future queries at call sites to procedure foo.
.
example consider an example where a procedure foodoes notmodify a global variable x. referring to figure suppose yogi encounters a situation where the operation opat the frontier is a call to procedure foo.
supposeskis the region x and is the region x .
due to modi cation analysis yogi is able to conclude that there is no way for any execution in footo start in a state from region x and end in a state in the region x .
further since foodoes not modify x the weakest precondition of x over the entire body of foois x which is a suitable predicate to re nesk .
.
empirical results table shows the aggregate metrics for running yogi over thewdm suite for various combinations of the interprocedural optimizations.
for each combination the table shows total time taken for all the runs in the wdm suite the number of correct defects detected by yogi and the total number of cases where yogi results in a timeout.
the rst row of the table modi cation analysis yes summaries yes figure comparison of yogi runtimes with and without modi cation analysis.
figure comparison of yogi runtimes with and without summaries.
gives empirical results with both optimizations are enabled the second row gives results with only modi cation analysis was enabled and summaries was disabled the third row gives results with only summaries were enabled and modication reference is not used and the last row gives results with both optimizations disabled.
we note that both summaries and modi cation analysis greatly help with reducing the runtime and decreasing the number of timeouts in the runs.
the total improvement due to modi cation analysis alone in terms of total runtime is considering improvement from minutes to minutes whereas the the total improvement due to summaries alone is considering improvement from minutes to minutes .
the total improvement due to both modi cation analysis and summaries is considering improvement from minutes to minutes .
also the number of runs where yogi runs out of time or space decreases with each one of these optimizations whereas the number of defects that yogi nds does not change much with or without these optimizations.
to drill down into these aggregate results further figure figure and figure show comparisons of runtimes of individual runs of yogi with and without these two optimizations.
these gures again show how useful these two optimizations are.
in all the gures the runtime of yogi with the optimization is given in the x axis and the runtime ofyogi without the optimization is given in the y axis.
in all the scatter plots almost all points above the straight figure comparison of yogi runtimes with and without both modi cation analysis and summaries.
test threshold total time no.
no.
minutes defects timeouts table empirical evaluation of test thresholds using the wdm suite.
linex y which says that except for very few runs there was a runtime improvement in every run due to each of these optimizations.
the gains from modi cation analysis seem bigger than those from summaries consistent with the aggregate numbers in table .
as seen in figure the combined improvement due to both the modi cation analysis and summaries is very signi cant.
the row of points at the top in each of the gures represent cases where the run times out since we have set the value of timeout to be seconds without the optimization whereas completes with the optimization.
.
testing in every iteration of yogi testing takes precedence over veri cation.
yogi rst checks if a test can be extended across a frontier.
if this is possible yogi generates a test that crosses the frontier and runs the test.
one parameter that needs to be tuned is the number of steps that the test should run beyond the frontier.
we call this parameter as test threshold .
the advantage in running a long test is that several potential future re nement queries can be avoided since every state transition made by the test potentially avoids reasoning between the actual existence of a transition between the corresponding regions using the theorem prover.
however running the test for too long creates too many states and consumes memory for storing states.
therefore one has to make a time vs. space tradeo in order to choose this parameter for optimal performance of yogi .
we have evaluated the performance of yogi empirically for various values of test thershold and arrived at a value of500.
table and figure compares results for test thresholds and respectively.
another optimization we have implemented is to save memory while storing all the states generated from tests.
for ev figure evaluating the impact of test thresholds onyogi.
ery test yogi generates a concrete program state at every program location in the control ow graph of the program.
in order to be memory e cient the whole concrete program state is not stored at every program location.
instead only the delta state that is only the di erence between two consecutive concrete states is stored.
this poses several engineering challenges for instance looking up the value of a variablexin a concrete state requires a series of lookup operations over a set of delta states5.
if the value of the variablexis not present in the current delta state this can happen ifxis not modi ed at the corresponding program location its parent is queried for the value.
in the worst case a lookup can result in traversing the test all the way up to its start state linear time in the length of the test per lookup .
therefore we have implemented a scheme that caches the results of lookup queries so that the amortized cost of the lookup operation is e cient almost constant time per lookup over all lookups.
we have found delta state optimization to be indispensable for running yogi on large programs.
without this optimization yogi runs out of time or space on a very large number of runs in the wdm suite.
consequently we do not present these results.
we believe it is not possible to build a tool like yogi and make it scale without an optimization such as delta state to reduce storage at each state.
an alternative is to not store states at all and only store test inputs and rerun tests from the initial state as done in dart .
however we nd that this option is also too expensive for yogi since unlike dart it also maintains an abstraction and needs values from the concrete state every time a region is partitioned so that each concrete state is assigned to the correct partition containing it.
.
modeling one of the most challenging issues we encountered in the development of yogi is to keep the testing runs and symbolic execution runs consistent with each other.
suppose we have a test tthat starts at some initial state and runs along a control path and results in a state s. further suppose we perform symbolic execution along the same path and produce a symbolic state .
for consistency we require that s2 .
however such a consistency requirement is di cult 5yogi performs this operation in order to decide which abstract region a concrete state belongs to .
if destinationstring destinationstring buffer sourcestring destinationstring length should be set to the length of sourcestring.
the line below is missing from the original stub sdv function.
destinationstring length strlen sourcestring if sourcestring null destinationstring length destinationstring maximumlength figure a sample code fragment from an sdvstub function.
issue type number of issues integers used as pointers uninitialized variables type inconsistencies table summary of changes made to sdvstub functions.
to achieve in practice in particular because the harnesses and stub functions used in our benchmarks are not type safe.
part of the reason for this is historical.
our benchmarks are obtained from static driver veri er and slam .
in this context the driver code is analyzed as is but stub functions are written for all the oscalls that the driver makes and a stub harness is written for how the osloads and calls the driver.
since slam performs only static analysis it was su cient to write rough non deterministic functions to model all the non determinism in a driver s environment.
for instance if the environment returned a pointer it was su cient for the purposes of analysis with slam to write a stub that returned an integer and later type cast it into a pointer.
this had the advantage that using rough models of the environment slam could still analyze the driver.
however the disadvantage was that error reports produced by slam could have false errors though a lot of e ort was put in to minimize this possibility .
with yogi since bugs are established by nding test cases that lead to the error we need higher quality osmodels.
stub functions for yogi need to be executable in the sense that running the program with the stubs should not result in memory crashes.
as a result we had to ne tune all the stub functions of static driver veri er so that they are executable.
for example consider the code fragment from an sdv stub function shown in figure .
the eld destinationstring length should be set to the length of the string sourcestring when sourcestring is not equal to null but is left uninitialized.
this causes yogi to miss bugs for some checks and xing this enables it to recover these bugs.
table summarizes some of the changes that we made to the stub functions for drivers there are a total of functions for the wdm os model .
each of these changes improved the quality of results produced by yogi eliminated false positives as well as false negatives .
indeed integers used as pointers uninitialized variables and type inconsistencies are issues due to which a program may crash thus rendering paths containing these issues infeasible.
while some of these issues such as making sure that in tegers are not type cast to pointers and all pointers are appropriately allocated can be identi ed by a codereview of the stub functions some others such as the issue in figure where we have missed assigning the length eld of the struct pointed by destinationstring under some conditions are very hard to identify by reading through the code.
as a result we discovered several of these by debugging cases with unexpected results from our test suites.
.
threats to validity there are two main threats to the validity of our results.
though our test suites are representative of device driver code and we have experiential and anecdotal evidence to this e ect we do not know if these empirical results generalize to other domains.
as yogi gets used as part of sdv more inside microsoft we expect to be able to experiment with a wider variety of test suites to evaluate and ne tune these optimizations.
though our experience is that bugs in optimizations are usually caught by the test suites we have we cannot be certain about the absence of bugs in our implementation.
.
conclusion we have described several optimizations for yogi and empirically evaluated them over a large number of runs from thewdm test suite.
we have used empirical data to drive decisions as to what optimizations to include in yogi .
there are other optimizations that we have tried but are absent from this paper because they did not give good results even though they intuitively sound appealing.
for instance we had another heuristic to choose relevant predicates see section where we favored choosing simple predicates over complex predicates where simplicity had to do with how small the syntax tree of the predicate is how many operators it has etc.
however this yielded bad results and we realized that choosing relevant predicates is more important than choosing simple predicates and this led to the sp heuristic described in section .
.
in another instance we designed some sophisticated decision trees to store and retrieve not may and must summaries with the property that storing the summaries would be expensive and lookup would be cheap.
but the performance bene t was not compelling enough.
for the optimizations that were successful the empirical data enabled us to make decisions on ne tuning the optimization.
for choosing an initial abstraction we decided to use predicates that are present in conditionals of the slic speci cation but do not contain