build code analysis with symbolic evaluation ahmed tamrawi hoan anh nguyen hung viet nguyen tien n. nguyen electrical and computer engineering department iowa state university atamrawi hoan hungnv tien iastate.edu abstract build process is crucial in software development.
however the analysis support for build code is still limited.
in this paper we present symake an infrastructure and tool for the analysis of build code in make .
due to the dynamic nature of make language it is challenging to understand and maintain complex makefiles.
symake provides a symbolic evaluation algorithm that processes makefiles and produces a symbolic dependency graph sdg which represents the build dependencies i.e.
rules among files via commands.
during the symbolic evaluation for each resulting string value in an sdg that represents a part of a file name or a command in a rule symake provides also an acyclic graph called t model to represent its symbolic evaluation trace .
we have used symake to develop algorithms and a tool to detect several types of code smells and errors in makefiles and to support build code refactoring e.g.
renaming a variable target even if its name is fragmented and built from multiple substrings.
our empirical evaluation for symake s renaming on several realworld systems showed its high accuracy in entity renaming.
our controlled experiment showed that with symake developers were able to understand makefiles better and to detect more code smells as well as to perform refactoring more accurately.
keywords build code maintenance build code analysis i. i ntroduction software building is the process that converts and integrates source code libraries and other data in a software project into stand alone deliverables and executable files.
the build process is managed by a build tool i.e.
a program that coordinates and controls others .
a build tool needs to execute the build commands according to the rules specified inbuild files which are written in a build language supported by the tool.
popular build tools are make ant and maven .
prior research found that build maintenance could impose from overhead on software development .
in a large scale system build files grow quickly and become very complex because they must support the building of the same software in multiple platforms with various configuration and environment parameters .
mcintosh et al.
found that from of tasks involving source code changes require an accompanied change in the related build code.
they concluded that build code continually evolves and is likely to have defects due to high churn rate .
importantly those studies call for better tool support for build code.
toward providing automatic tool support for developers to deal with complex build code we have developed symake an infrastructure and tool for the analysis of build code ingnu make .make is a scripting language in which a build file called makefile is used to specify the build dependencies among the configuration files in a project via make s program entities.
with a specific input environment make first evaluates a makefile into a dependency graph among concrete file names and commands.
then it executes the commands with those files.
with such dynamic nature in make s evaluation it is challenging for developers to understand and maintain over time multiple large complex and dependent makefiles.
importantly errors are hard to detect at static time and even at run time as the evaluation result depends on the input the operating environment and the files in the file system.
to address those challenges in the maintenance of build code in makefiles symake provides a symbolic evaluation algorithm that processes makefiles and produces a single symbolic dependency graph sdg to represent the build rules and dependencies among files via build commands.
it differs from a concrete dependency graph of make in that file names and commands in an sdg might not be completely resolved into strings.
instead the sdg s node for a file refers to a data structure called v model i.e.
a graph based representation for symbolic string values for the file s name.
a v model often contains symbols to represent the inputs or data retrieved from user environment.
sdg enables static analysis on makefiles and supports program understanding.
during the symbolic evaluation for each resulting string value that represents a part of a file name or a command of a rule in an sdg symake provides also an acyclic graph called t model to represent its symbolic evaluation trace .
that is the t model shows how that string value is initialized and manipulated via various makefile s program entities.
we used symake to develop algorithms and a tool to detect several types of code smells and errors in makefiles e.g.
cyclic dependencies rule inclusion duplicate prerequisites recursive variable loops etc.
the tool supports also build code refactoring e.g.
rule extraction removal target creation target variable renaming prerequisite extraction etc.
our empirical evaluation for symake s renaming on several real world systems has shown that it can achieve high accuracy in entity renaming.
we also conducted a controlled experiment whose result showed that with symake human subjects were able to understand the makefiles better and to detect more code smells as well as to perform refactoring more accurately in shorter time.
our contributions include .
c ieee icse zurich switzerland .
an ast building algorithm and a symbolic evaluation algorithm on makefiles to create sdgs sections iii and iv .
a symbolic evaluation tracing algorithm section v .
makefiles code smell detection algorithm section vi .
automatic refactoring algorithm for make elements that is able to handle fragmented identifiers section vii .
an empirical evaluation and a controlled experiment to show symake s accuracy and usefulness section viii .
ii.
m otivating example this section explains how make works via an example.
figure shows mymakefile a makefile inspired from gnu make s documentation .
the goal of this file is to tell make how to build the demo server and client programs in both linux and windows from its respective source and data files.
gnu make processes a makefile in two distinct phases evaluation phase for an input and environment make first resolves all variables and expressions into concrete values to produce a concrete set of rules and internally constructs a dependency graph .
each rule in that graph has a dependency between prerequisites and targets and a recipe i.e.
shellcommands to generate the targets from their prerequisites.
figure shows the rules after the evaluation as make runs on mymakefile onlinux.
execution phase make then uses the constructed dependency graph and executes the required rules based on their prerequisites and recipes.
for example assume that user s command is make all the rule for target allis executed which leads to the rules for server.o and client.o figure .
if the modifying time of a prerequisite file is later than that of its target file the command is executed to produce the updated version of the target file.
variable osmodels the current operating system line .
its value is obtained via a call to the shell built in function to execute the shell command uname .
depending on the value ofos linux or not the variables ext i.e.
file extension and cmd i.e.
build command are set with different values lines .
the server s and client s file names are stored inservernm and clientnm .
the variable programs line is evaluated into a list of both names server.o client.o .
four variables at lines are used to store the names of libraries and object files.
at line the name of the variable server.o libsis fragmented and is constructed from the value of expression servernm .
it is initialized with the concatenation of priv protocol and the file names in the current directory that match with the pattern .conf viawildcard .
line is a rule without a recipe for the target all.
after the evaluation phase make transforms that rule into line of figure where the variable programs is replaced with its actual value server.o client.o .
to update or build for the target all make needs to create or update each of its prerequisites which in turn can be either a file or a different target.
lines show another way for variable initialization.
variable programtmp is initialized with the string at line .1os shell uname 3ifeq os linux ext o cmd build.sh 6else ext exe cmd build.bat 9endif 11servernm server.
ext 12clientnm client.
ext 13programs servernm clientnm servernm libs priv protocol wildcard .conf servernm objs server impl.
ext server access.
ext clientnm objs client impl.
ext client api.
ext clientnm libs protocol 20all programs 22define programtmp objs libs 24endef foreach prog programs eval call programtmp prog programs cmd .conf .
ext genconf o 34ifeq os linux 35demo.o demo.c linux.conf install o 37else 38demo.exe demo.c win.conf install.bat o 40endef figure .
mymakefile an example of make build code 1all server.o client.o 3server.o server impl.o server access.o priv protocol sample.conf build.sh server.o server impl.o server access.o priv protocol sample.
conf 6client.o client impl.o client api.o protocol build.sh client.o client impl.o client api.o protocol 9linux.conf linux.o genconf linux.o o linux.conf 12sample.conf sample.o genconf sample.o o sample.conf 15demo.o demo.c linux.conf install demo.c linux.conf o demo.o figure .
internal representation after evaluation phase on mymakefile as it is evaluated the string at line will be evaluated.
in fact in this example programtmp is used as a user defined function with the built in function callat line .
line shows a foreach loop with the variable programs as the iteration list and progas its iterator.
the body of foreach is a call to evalbuilt in function which parses its argument into makefile s rules statements and considers them as part of the651current makefile.
thus a function call is made to evaluate programtmp and its parameters are assigned with the values of the temporary variables etc.
for example line contains the variable prog s value.
thus at the first iteration a reference to is resolved to server.o asprog s value is server.o .
the returned value from callis server.o server.o objs server.o libs which is a parameter passed toeval.
it is parsed into a new rule server.o whose prerequisites are the values of the variables server.o objs and server.o libs.
the same applies in the second iteration as prog s value is client.o .
thus lines and of figure show the rules created from evaluating line of figure .
lines define a rule for two targets named server.o and client.o via programs .
that is both targets share the same recipe at line .
since the target server.o occurs in the previous rule those rules are combined to form a complete rule at lines figure .
the same applies to client.o rule lines .
note that and areautomatic variables whose values are equal to the rule s target and prerequisites.
an implicit rule serves as a template pattern for any prerequisite file that does not have an explicit rule for creating updating.
lines specify the rule to produce any configuration file .conf from the corresponding .oor .exe file.
for example linux.conf at line is a prerequisite file for demo.o and there is no explicit rule to make that file.
make finds that linux.conf matches with .conf .
thus it creates a new rule for linux.conf lines figure .
the same process applies when make sees sample.conf at line of figure .
it creates a new rule sample.conf as in lines .
scenario .
assume that a user enters make f mymakefile on a linux machine.
make builds its dependency graph figure and runs the first rule i.e.
rule all .
it examines the prerequisites and then executes the rules at lines and .
it continues the same process and successfully builds for the rule all.
interestingly there is a subtle error in mymakefile if make all is requested.
the server.o rule depends on the configuration files fetched from the current directory via wildcard .conf line .
the error will occur if a configuration file in the current directory has the name server.conf .
in that case make will consider server.conf as a prerequisite of server.o .
it will match server.conf with the implicit rule at line create theserver.conf rule and add it to the dependency graph 1server.conf server.o genconf server.o o server.conf a cyclic dependency now occurs because server.o lists server.conf as one of its prerequisites and server.conf also has server.o as a prerequisite in the new rule.
that loop causes an error in the execution phase.
this bug is difficult to reveal at static time and even at run time because it depends on the users current environment directory and the input.
scenario .
the analysis for the names of variables or targets and automatic renaming for them is not trivial.
since make is dynamic the name of a variable i.e.
an identifier can be the result of the evaluation of other variables.
at line the prefix of an identifier is defined from the value of the variable servernm .
a regular text search tool cannot distinguish between the identifiers and the string values e.g.
line .
moreover the identifier of variable servernm objs line is fragmented and composed of multiple substrings.
if a tool renames the suffix objs it must also rename at line and line since line affects both of these lines.
scenario .
over time a different developer works on a different component of the project and mymakefile includes other makefiles e.g.
mk1 .
assume that s he adds into his her own file mk1a rule comp1.conf to handle the building of the configuration file for his her component as follows comp1.conf comp1.o genconf comp1.o o comp1.conf dealing with multiple dependent and complex makefiles s he might not be aware of the implicit rule at line in mymakefile that was designed to handle any .conf files.
such redundancy increases the complexity and decreases the maintainability of the makefiles.
if one wants to change the implicit rule at line s he must change comp1.conf rule in mk1.
thus it is helpful to detect rule inclusion redundancy.
summary.
the analysis of makefiles is challenging because the analysis for entities names and build dependencies is not trivial due to the dynamic nature of make .
it is also hard to detect code smells and errors at static time.
as a project evolves makefiles become more complex.
bad smells such as rule redundancy duplications circular dependencies etc create several maintenance problems.
understanding large complicated and dependent makefiles requires much effort and time from developers.
iii.
m ake sabstract syntax tree let us describe make s syntactical rules that we use to build an abstract syntax tree ast for a makefile.
we have read gnu make s documentation and source code and specified its grammar production rules as in figure .
.makefile node rule is the root of a makefile s ast.
a makefile consists of a list of statements rules .
the order of statements rules in a makefile is important in its execution.
.statement node rule a makefile s statement represents a source code line or block that occurs as a stand alone evaluation unit.
typical statements are in line of figure .
.assignment node rule an assignment to a variable can be either simple orrecursive .
in a simple variable assignment the right hand side rhs expression is evaluated and assigned to the variable.
a recursive one is similar to a pointer assignment with no update from lhs to rhs variables.
a variable can be referred by its name or an expression whose value is its name.
line of figure defines a variable server.o libssince servernm libsis evaluated first.
.definition node rule a variable defined within a define can be used in three ways.
first a defined variable6521 makefile statement rule statement assignment definition functioncall foreach if directive assignment id expr expr id idpart ws idpart idpart definition define id n n endef functioncall functionname functionname subst patsubst strip findstring filter ... expr term term term functioncall eliteral evaluation foreach if eliteral wliteral ws wliteral wliteral evaluation id expr rule expr assignment expr recipe n t recipeexpr n t recipeexpr recipeexpr recipeterm recipeterm recipeterm functioncall evaluation recipeliteral autoeval foreach if recipeliteral autoeval ?
... foreach foreach id expr expr recipeexpr if ifeq ifneq expr expr ifdef ifndef expr rule statement recipepart endif ifexpr expr recipeexpr recipepart n t recipeexpr n t recipeexpr directive include vpath export undefine include include sinclude include expr vpath vpath export unexport export undefine undefine id figure .
makefile abstract syntax production rules can be used as an assigned variable except that its value can contain multiple lines.
second it can serve as a user defined function as it is used with make s call programtmp line .
finally it can be used later with evalfunction and evaluated into a list of statements and or rules.
the resulting statements and rules are treated as part of the current makefile and make continues the evaluation to build the dependency graph.
.functioncall node rule represents a call to a built in function.
a few built in functions are listed in rule .
.expr node rule an expression represents a part of a line that will be evaluated.
it can be a concatenation of terms i.e.
terms with or without whitespaces in between.
a term can be a function call variable evaluation a foreach orifstatement rule .
it can also be a literal eliteral .
.evaluation node rule is for a variable s evaluation.
e.g.
programs is evaluated into server.o client.o line .
.rule node rule represents a build action.
it has a target which can be an expression that is evaluated into one or multiple targets.
e.g.
programs is evaluated to create targets server.o and client.o line .
an expression whose value after evaluation will result in a set of files forming the prerequisite list for the rule.
a recipe representing the shell commands of the rule.
a rule can be non terminal rule i.e.
it is executed as requested in a command line or if its target is a prerequisite of another to be executed rule or terminal rule i.e.
it is executed once its prerequisites exist.
the same target name can occur in multiple rules and those must be of the same type.
if they are non terminal they will be combined into a single one.
a rule can contain a local variable assignment.
.recipe node rule models a concatenation of recipe expression s that is evaluated to a string forming the rule s commands.
it will be evaluated into a list of shell commands.
the expression within a recipe recipeexpr is the same as a regular expr except that if it has a string literal the literal must not include a new line.
we call it recipeliteral rule .
.autoeval rule is used to evaluate automatic variables that can occur only in a recipe line figure .
.foreach node rule a foreach statement consists of three parts an identifier node as the loop iterator e.g.
progat line an expression whose value represents the iteration list e.g.
programs and an expr orrecipeexpr representing the loop body that will be evaluated e.g.
eval call programtmp prog .
the return value after executing aforeach is a concatenated string of all values resulted from the evaluation of the body expression at each iteration.
.ifnode rule represents a condition.
it can be either a conditional block e.g.
as in lines or an inline condition e.g.
if var1 var2 var3 .
in a conditional block a branch can contain any combination of makefile rules statements.
a branch can also be evaluated into a part of a rule s recipe represented by recipepart .
the value of anifstatement will be viewed as part of the current makefile.
an inline condition is used to check an empty string.
.
a directive is aimed to tell make to include another makefile include to undefine a variable undefine to add remove the variables from the environment un export and to setup make s searching path vpath .
iv.
m akefile symbolic dependency graph sdg an sdg captures the dependencies among prerequisites and targets and respective recipes.
an sdg s node refers to a data structure called v model representing a symbolic string value for a name.
a v model can contain symbols to represent the inputs or data retrieved from user environment.
definition asymbolic dependency graph sdg is a directed graph representing a makefile s rules and dependencies among prerequisites and targets through the recipes.
an sdg can contain the following types of nodes atarget prerequisite node represents a rule s target or prerequisite.
a target can be a prerequisite for another rule and vice versa.
it refers to a v model representing the symbolic string value of the target prerequisite.
arecipe node represents the recipe of a rule.
there is anedge from a target node to the recipe node representing the dependency of that target to this recipe.
similarly there is an edge from the recipe node to a prerequisite node.
a recipe node also refers to a v model.
aselect node represents alternative dependencies from a target to one of multiple recipes and prerequisites.
arule block contains all nodes edges related to a rule.
definition av model is a labeled ordered and directed acyclic graph representing the symbolic string values for the parts of a rule in an sdg.
in a v model leaf nodes653represent string values.
inner nodes model either operations for combining those values or