improved multithreaded unittesting vilas jagannath milos gligoric dongyun jin qingzhou luo grigore ro su darko marinov department of computer science universityofillinois atu rbana champaign urbana il61801 usa vbangal2 gliga djin3 qluo2 grosu marinov illinois .edu abstract multithreaded code is notoriously hard to develop and test.
a multithreaded test exercises the code under test with two or more threads.
each test execution follows some schedule interleaving of the multiple threads and different sch edules can give different results.
developers often want to enforce a particular schedule for test execution and to do so they use time delays thread.sleep in java .
unfortunately this approach can produce false positives or negatives and can result in unnecessarily long testing time.
this paper presents imunit a novel approach to specifying and executing schedules for multithreaded tests.
we introduce anewlanguage thatallows explicit specification of schedules as orderings on events encountered during test execution.
we present a tool that automatically instruments the code to control test execution to follow the specified schedule and a tool that helps developers migrate their legacy sleep based tests into event based tests in imunit .
the migration tool uses novel techniques for inferring even ts and schedules from the executions of sleep based tests.
we describe our experience in migrating over tests.
the inference techniques have high precision and recall of over and imunit reduces testing time compared to sleepbased tests on average .39x.
categories andsubject descriptors d. .
testing and debugging general terms verification reliability keywords imunit unit testing multithreaded code .
introduction multicore processors are here to stay.
to extract greater performance from multicore processors developers need to permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
esec fse september szeged hungary.
copyright acm ... .
.write parallel code.
the predominant paradigm for parallel code is that of shared memory where multiple threads of control communicate by readingand writing shared dataobjects.
shared memory multithreaded code is often afflicted by concurrency bugs which are hard to detect because multithreadedcode can demonstrate differentbehavior based on the scheduling of threads and the bugs may only be triggered by a small specific set of schedules.
to validate their multithreaded code developers write multithreaded unit tests.
a multithreaded test creates and executes two or more threads and or invokes code under test that itself creates and executes two or more threads .
each test execution follows some schedule interleaving of the multiple threads and different schedules can give differ ent results.
developers often want to enforce a particular schedule for a test.
for example consider two threads one executing a method mand the other executing a method m .
developers may want to ensure in one test that mfinishes before m starts and in another test that m finishes beforemstarts and in more tests that mandm interleave in certain ways .
without controlling the schedule i t is impossible to write precise assertions about the executi on because the results can differ in the two scenarios and it is impossible to guarantee which scenarios were covered durin g testing even if multiple runs are performed.
to control the schedule of multithreaded tests developers mostly use a combination of timed delays in the various test threads.
in java the delay is performed with the thread.sleep method so we call this approach sleep based .
a sleep pauses a thread while other threads continue execution.
using a combination of sleeps developers attempt to enforce the desired schedule during the execution of a multithreaded test and then assert the intended result for the desired schedule.
a sleep based test can fail when an undesired schedule gets executed even if the code under test has no bug false positive .
dually a sleep based test can pass when an unintended schedule gets executed even if the code undertest has abug false negative .
indeed sleeps ar e an unreliable and inefficient mechanism for enforcing schedules.
to use sleeps one has to estimate the real time duration for which to delay a thread while the other threads perform their work.
this is usually estimated by trial and error starting from a small duration and increasing it until the test passes consistently on the developer s machine .
the estimated duration depends on the execution environment hardware software configuration and the load on the machine .
therefore when the same test is executed in a different environment the intended schedule may not be en fse acm pp .
fse acm pp .
2011forced leading to false positives negatives.
moreover s leep can be very inaccurate even on a single machine .
in an attempt to mitigate the unreliability of sleep developers often end up over estimating the duration which in turn leads to slow running multithreaded tests.
researchers have previously noted the numerous problems with using sleeps to specify schedules in multithreade d tests and have developed frameworks such as conan concjunit multithreadedtc andthreadcontrol to tackle some problems in specifying and enforcing schedules in multithreaded unit tests.
however despit e these frameworks multithreaded unit testing still has man y issues that could be categorized as follows readability most current frameworks force developers to reason about the execution of threads relative to a global clock.
this is unintuitive since developers usually reason about the execution of their multithreaded code in terms of event relationships such as mfinishing before m starts .
some frameworks requireusers towrite schedules inexterna l scripts which makes it even more difficult to reason about schedules.
in other frameworks the schedule is implicit as a part of the unit test code and hence it is difficult to focus on the schedule and reason about it separately at a higher level .
modularity in some current frameworks the intended schedule is intermixed with the test code and effectively hard coded into a multithreaded unit test.
this makes it difficult to specify multiple schedules for a particular unit test and or to reuse test code among different tests.
reliability some current frameworks as well as the legacy sleep based tests rely on real time.
as explained this makes them very fragile leading to false positives ne gatives and or slow testing time.
migration costs most currentframeworks are verydifferent from the traditional sleep based tests.
this makes i t costly to migrate the existing sleep based tests.
we present a new framework called imunit pronounced immunity which aims to address these issues with multithreaded unit testing.
specifically we make the followin g contributions schedule language imunit introduces a novel language that enables natural and explicit specification of sch edules for multithreaded unit tests.
semantically the bas ic entity in an imunit schedule is an eventthat an execution can produce at various points e.g.
a thread starting finis hing the execution of a method or a thread getting blocked .
wecall theimunitapproach event based .
animunitschedule itself is a monitorable property on the sequence of events.
more precisely each schedule is expressed as a set of desirable event orderings where each event ordering specifies the order between a pair of events note that an imunit schedule need not specify a total order between all events but only the necessary partial order .
while the ideas of imunit can be embodied in any language we have developed an implementation for java.
syntactically the imunit constructs are represented using ja va annotations.
a developer can use eventand schedule annotations to describe the events and intended schedules re spectively for a multithreaded unit test.
automated migration we have developed two inference techniques and a tool to ease migration of legacy sleep based tests to imunit event based tests.
our inference techniques can automatically infer likely relevant events and schedules from the execution traces of existing sleep base dtests.
we implemented our migration tool as an eclipse plugin which uses the results of inference to automatically refactor a given multithreaded test into an imunit test.
execution and checking we have implemented a tool for execution of imunit multithreaded unit tests.
the tool can work in two modes.
in the active mode it controls the thread scheduler to enforce a given imunit schedule during test execution.
in the passive mode it checks whether an arbitrary test execution controlled by the regular jvm thread scheduler follows a given imunit schedule.
to enforce check the schedules our tool uses the javamop monitoring framework .
we also include a new runner for the standard junit testing framework to enable execution of imunit tests with our enforcement checking tool.
evaluation toguideandrefineourdesignoftheimunit language we have been inspecting over sleep based test s from several open source projects.
we manually translated of those tests into imunit adding events and schedules and removing sleeps.
as a result the current version of imunit is highly expressive and we were able to remove all sleeps from all but tests.
we evaluated our inference techniques by automatically inferring events schedulesfor theoriginal tests that we m anually translated the subprojects on manual translation an d automatic inference were performed by different authors to reduce the direct bias of manual translation on automatic inference .
computing the precision and recall of the automatically inferred events schedules with respect to the ma nually translated events schedules we find our techniques t o be highly effective with over precision and recall.
we also compared the execution time of the original tests and our translated tests.
because the main goal of imunit is to make tests more readable modular and reliable we did not expect imunit to run faster.
however imunit did reduce the testing time on average .39x compared to the sleep based tests with the sleep duration that the origina l tests had in the code.
as mentioned earlier these duration values are often over estimated especially in older tests that were written for slower machines.
in summary imunit not only makes multithreaded unit tests more readable modular and reliable than the traditional sleep based approac h but imunit can also make test execution faster.
this paper makes progress on our vision for improving multithreaded unit testing our position paper proposed the idea of event based specification of schedules but the imunit language and algorithms tools for inference and execution are completely new.
.
example we now illustrate imunit with the help of an example multithreaded unit test for the arrayblockingqueue class i n java.util.concurrent jsr .
arrayblockingqueue is an array backed implementation of a bounded blocking queue.
one operation provided by arrayblockingqueue is add which performs a non blocking insertion of the given element at the tail of the queue.
if addis performed on a full queue it throws an exception.
another operation provided by arrayblockingqueue is take which removes and returns the object at the head of the queue.
if takeis performed on an empty queue it blocks until an element is inserted into the queue.
these operations could have bugs that get triggered when the addandtakeoperations execute on different threads.
consider testing some scenarios for these opera fse acm pp .
fse acm pp .
test 2public void testtakewithadd 3arrayblockingqueue integer q 4q newarrayblockingqueue integer 5newthread 6newcheckedrunnable public void realrun q.add thread.sleep q.add addthread .start 13thread.sleep 14integer taken q.take 15asserttrue taken q.isempty 16taken q.take 17asserttrue taken q.isempty 18addthread.join a junit1public class testtakewithadd 2extends multithreadedtest 3arrayblockingqueue integer q override 5public void initialize 6q newarrayblockingqueue integer 8public void addthread 9q.add 10waitfortick 11q.add 13public void takethread 14waitfortick 15integer taken q.take 16asserttrue taken q.isempty 17taken q.take 18asserttick 19asserttrue taken q.isempty b multithreadedtc1 test schedule finishedadd1 startingtake1 startingadd2 4public void testtakewithadd 5arrayblockingqueue integer q 6q newarrayblockingqueue integer 7newthread 8newcheckedrunnable public void realrun q.add event finishedadd1 event startingadd2 q.add addthread .start event startingtake1 17integer taken q.take 18asserttrue taken q.isempty event startingtake2 20taken q.take 21asserttrue taken q.isempty 22addthread.join c imunit figure example multithreaded unit test for arrayblockin gqueue tions in fact the jsr tck provides over tests for various scenarios for similar classes .
figure1shows amultithreadedunittest thatarrayblockingqueueexercises addandtakein twoscenarios.
inparticular figure a shows thetestwritten as aregular junittest method with sleeps used to specify the required schedule.
we invite the reader to consider what scenarios are specified with that test without looking at the other figures .
it is likely to be difficult to understand which schedule is being exercised by reading the code of this unit test.
while the sleeps provide hints as towhich thread is waiting for anothe r thread to perform operations it is unclear which operation s are intended to be performed by the other thread before the sleep finishes.
the test actually checks that takeperforms correctly both with andwithout blocking whenusedwith addfrom another thread.
to check both scenarios the test exercises a schedule where the first addfinishes before the first takestarts and the second takeblocks before the second addstarts.
line13shows the first sleep that is intended to pause the mainthread1while the addthread finishes the first add.
line9 shows the second sleep which is intended to pause the addthreadwhile the mainthread finishes the first takeand then proceeds to block while performing the second take.
if the specified schedule is notenforced duringthe execution the re may be a false positive negative.
for example if both add operations execute before a takeis performed the test will throw an exception and fail even if the code has no bug and if bothtakeoperations finish without blocking the test will not fail even if the blocking takecode had a bug.
figure1 b shows the same test written using multithreadedtc .
note that it departs greatly from traditional junit where each test is a method.
in multithreadedtc each test has to be written as a class and each method in the test class contains the code executed by a thread in the 1jvm names the thread that starts the execution mainby default although the name can be changed later.test.
the intended schedule is specified with respect to a global logical clock.
since this clock measures time in ticks we call the approach tick based.
when a thread executes a waitfortick it is blocked until the global clock reaches the requiredtick.
theclockadvancesimplicitlywhenall threa ds are blocked and at least one thread is blocked in a waitfortick .
while a multithreadedtc test does not rely on real time and is thus more reliable than a sleep based test the intended schedule is still not immediately clear upon reading the test code.
it is especially not clear when waitfortickoperations are blocked unblocked because ticks are advanced implicitly when all the threads are blocked.
figure1 c shows the same test written using imunit.
the interestingevents encountered duringtest execution a re marked with eventannotations2 and the intended schedule is specified with a schedule annotation that contains a comma separated set of orderings among events.
an ordering is specified using the operator where the left event is intended to execute before the right event.
an event specified within square brackets denotes that the thread executingthateventis intendedtoblock after that event.
itshoul d be clear from reading the schedule that the addthread should finishthe first addbefore the mainthread starts the first take and that the mainthread should block while performing the secondtakebefore the addthread starts the second add.
we now revisit in the context of this example the issues with multithreaded tests listed in the introduction.
in ter ms ofreadability we believe that making the schedules explicit as in imunit allows easier understanding and maintenance of schedules and code for both testing and debugging.
in terms of modularity imunit allows extracting the addthread as a helper thread with its events that can be reused in 2note that eventannotations appear on statements.
the currentversionofjava ver.
doesnotsupportannotation s on statements but the upcoming version of java ver.
will add such support.
for now eventannotations can be written as comments e.g.
event finishedadd1 which imunit translates into code for test execution.fse acm pp .
fse acm pp .
schedule ordering ordering ordering condition basic event condition basic event block event condition condition condition condition condition basic event event name start thread name end thread name block event event name id .
id thread name id figure syntax of the imunit schedule language other tests in fact many tests in the jsr tck use such helper threads .
in contrast reusing thread methods from the multithreadedtc test class is more involved requiringsubclassing parametrizingtickvalues andprovi ding appropriate parameter values.
also imunit allows specify ing multiple schedules for the same test code section .
.
in terms of reliability imunit does not rely on real time and hencehasnofalse positives negativesduetounintendedsc hedules.
in terms of migration costs imunit tests resemble legacy junit tests more than multithreadedtc tests.
this similarity eases the transition of legacy tests into imunit in brief add eventannotations add schedule annotation and remove sleepcalls.
section 4presents our techniques and tool that automate this transition.
.
schedule language we nowdescribe the syntaxandsemantics ofthe language used in imunit s schedules.
.
concrete syntax figure2shows the concrete syntax of the implemented imunit schedulelanguage.
an imunitschedule is a commaseparated set of orderings .
each ordering defines a condition that must hold before a basic event can take place.
a basic event is an event name possibly tagged with its issuing thread name when that is not understood from the context.
an event name is any identifier possibly prefixed with a qualified class name.
there are two implicit event names for each thread startandend indicating when the thread starts and terminates.
any other event must be explicitly introduced by the user with the eventannotation see figure c .
acondition is a conjunctive disjunctive combination of basic and block events where block events are written as basic events in square brackets.
a block event in the condition cof an ordering c estates that e must precede eand additionally the thread of e is blocked whenetakes place.
.
schedule logic it is more convenient to define a richer logic than what is currently supported by our imunit implementation the additional features are natural and thus may also be implemented in the future.
the semantics of our logic is given in section3.
here is its syntax a start divides.alt0end divides.alt0block divides.alt0unblock divides.alt0event names t thread names e a t divides.alt0 divides.alt0usual propositional connectivesthe intuition for is threadtis blocked and for if held in the past then must have held at some moment before .
we call these two temporal operators the block and theordering operators respectively.
for uniformity all events are tagged with their thread.
there are four implicit events start tandend twere discussed above and block tandunblock tcorrespond to when tgets blocked and unblocked3.
for example the following formula in our logic a1 t1 start t2 a1 t1 a2 t2 a2 t2 end t1 a2 t2 a2 t2 says that if event a2is generated by thread t2then eventa1must have been generated before that and when a1 was generated t2was either blocked or not started yet and whena2is generated by t2 t1is either blocked or terminated.
as explainedshortly everyeventexcept for blockand unblockis restricted to appear at most once in any execution trace.
above we assumed that a1 a2 block unblock .
before we present the precise semantics we explain how our current imunit language shown in figure whose design was driven exclusively by practical needs is a smaller fragment of the richer logic.
an imunit schedule is a conjunction we use comma instead of of orderings and schedules cannot be nested.
since generating blockandunblockevents is expensive imunit currently disallows their explicit use in schedules.
moreover to reduce their implic it use to a fast check of whether a thread is blocked or not imunit also disallows the explicit use of formulas.
instead it allows block events of the form note the square brackets in conditions.
since negations are not allowed in imunit and since we canshow after we discuss the semantics that 1 2 equals 1 2 we can reduce any imunit schedule to a boolean combination of orderings e where is a conjunction of basic events or block events.
all that is left to show is how block events are desugared.
consider an imunit schedule a2 t2 saying that a1 t1and must precedea2 t2andt1is blocked when a2 t2occurs.
this can be expressed as a1 t1 a2 t2 a2 t2 a2 t2 relying on a2 t2happening at most once.
.
semantics our schedule logic is a carefully chosen fragment of pasttime linear temporal logic ptltl over special well formed multithreaded system execution traces.
program executions are abstracted as finite traces of events e1e2...en.
unlike in conventional ltl our traces are finite because unit tests always terminate.
traces must satisfy the obvious condition that events corresponding to threadtcan only appear while the thread is alive that is between start tandend t. using ptltl this requirement states that for any trace and any event a twith a start end the following holds a t end t start t where stands for eventually in the past .
moreover except forblock tandunblock tevents we assume that each 3it is expensiveto explicitly generate block unblockevents in java precisely when they occur because it requires polling the status of each thread our currently implemented fragment only needs through its restricted syntax to check if a given thread is currently blocked or not which is fast.fse acm pp .
fse acm pp .
2011event appears at most once in a trace.
with ptltl this says that the following must hold varodotis previously a t varodot a t for any trace and anya twitha block unblock .
the semantics of our logic is defined as follows e1e2...en eiffe en slash.left iff and or e1e2...en iff i n ei block tand i j n ej unblock t e1e2...en iff i n e1e2...ei slash.left or i n e1e2...ei and j i e1e2...ej it is not hard to see that the two new operators and can be expressed in terms of ptltl as unblock tsblock t boxdot wheresstands for since and boxdotfor always in the past .
.
migration we now describe the process of migrating legacy sleepbased tests to imunit event based tests.
first we present the steps that are typically performed during manual migration and then we describe the automated support that we have developed for key steps of the migration.
.
manual migration based on our experience of manually migrating over tests the migration process typically follows these steps step optionally add explicit names for threads in the test code by using a thread constructor with a name or by adding a call to setname .
this step is required if events are taggedwiththeirthreadname e.g.
finishedadd1 addthread in the schedule because by default the jvm automatically assigns a name e.g.
thread for each thread created without an explicit name and the automatic name may differ between jvms or between different runs on the same jvm.
step introduce eventannotations for the events relevant for the intended schedule.
some of these annotations will be used for block events and some for basic events.
step introduce a schedule annotation for the intended schedule.
steps and are the hardest to perform as they require understanding of the intended behavior of the sleep based test.
note that a schedule with too few orderings can lead to failing tests that are false positives.
on the other hand a schedule with too many orderings may lead to false negatives whereby a bug is missed because the schedule is over constraining the test execution.
step check that the orderings in the introduced schedule are actually satisfied when running the test with sleeps section 5describes the passive checking mode .
step remove sleeps.
step optionallymerge multipletests with differentschedules butsimilar test code intoonetest with multiple sche dules potentially adding schedule specific code section .
.
.
automated migration we have developed automated tool support to enable easier migration of sleep based tests to imunit.
in particular we have developed inference techniques that can computeenumentrytype sleepcall sleep return block call block return other call other return th start thend event classlogentry entrytype type threadid tid string info stmtid sid figure log entries likely relevant events and schedules for sleep based tests by inspecting the execution logs obtained from test runs.
we next describe the common infrastructure for logging the tes t runs.
we then present the techniques for inferring events and schedules.
.
.
lightweightlogging our inference of events and schedules from sleep based tests is dynamic it first instrumentsthe test code usingas pectj to emit entries potentially relevant for inference thenruns the instrumentedcode several times as explaine d below to collect logs of entries from the test executions a nd finally analyzes the logs to perform the inference.
figure3shows the generic representation for log entries although event and schedule inference require slightly diff erent representations.
each log entry has a type name id of the thread that emits the entry potential info parameters for the entry and the id of the statement that creates the entry which is used only for event inference .
the types of log entries and their corresponding infoare as follows sleep call invocation of thread.sleep method.
only used for inferring events.
sleep return return from thread.sleep method.
block call invocation of a thread blocking method locksupport.park orobject.wait .
block return return from a thread blocking method.
other call invocation of a method other than those listed above inthetestclass.
the infois themethodname.
only used for inferring events .
other return return from a method executed from the test class.
th start invocation of thread.start .
theinfois the id of the started thread.
only used for inferring schedules.
th end end of thread execution.
event execution of an imunit event.
the infois the name of the event.
only available while inferring schedules.
note that any logging can affect timing of test execution.
because sleep based tests are especially sensitive to timi ng care must be taken to avoid false positives.
we address this in three ways.
first our logging is lightweight.
the instru mented code only collects log entries and their parameters relevant to the inference.
for example other call is not collected for schedule inference.
also the entries are buffere d in memory during test execution and they are converted to strings and logged to file only at the end of test execution.
while keeping entries in memory would not work well for very long logs it works quite well for the relatively short logs produced by test executions.
second our instrumentation automatically scales the duration of sleeps by a given constantnto compensate for the logging overhead.
for example forn it increases all sleep times 3x.
increasing all the durations almost never makes a passing test fail but it does make the test run slower.
third we perform multiplefse acm pp .
fse acm pp .
2011runs of each test and only collect logs for passing runs.
this increases the confidence that the logs indeed correspond to the intended schedules specified with sleeps.
.
.
inferringevents figure4presentsthealgorithmforinferringimunitevents from a sleep based test.
the input to the algorithm consists of a set of logs as described in section .
.
and a confidencethreshold .
the output is a set of inferred events.
each event includes the code location where eventannotation should be added and the name of the event.
the intuition behind the algorithm is that sleep call log entries are indicative of code locations for events.
more precisely a threadtcallssleepto wait for one or more events to happen on other threads those will be finished events before an event happens on t that will be a starting event .
recall our example from section .
when the mainthread calls sleep it waits for addto finish before takestarts and thus finishedadd1 executes before startingtake1 .
for each log the algorithm first computes a set of regions each of which is a sequence of log entries between sleep call andthematching sleep return executedbythesame thread.
the log entries executedbyotherthreads within aregion are potential points for the finished events.
regions from dif ferent threads can be partially or completely overlapping but regions from the same thread are disjoint i.e.
each sleep call is followed directly by sleep return before any other statement is executed by the thread .
figure 5shows two regions for a simplified log produced by our running example.
in pseudo code each region is represented as a pair ofints that point to the beginning and end of the region in the list of log entries.
for each region the algorithm first calls addfinishedevents to potentially add some finished events for threads other than the region s thread.
if an event is added the algorithm calls addstartingevent to add the matching starting event.
the procedure addfinishedevents potentially adds an inferred event for each thread that executes at least one state ment in the region.
for each such thread the procedure first discovers a relevant statement which is one of sleep call block call andth end.
only threads that have exactly one relevant statement in the region are considered.
the intuition is that sleeps usually wait for exactly one event in eac h other thread.
if a thread executes none or multiple relevant statements it is most likely independent of the thread that started the region and therefore can be ignored.
figure5shows the relevant statements for each region.
the procedure then finds the other return statement immediately before the relevant statement for each thread.
this statement determines the name for the new finished staticevent whereas the relevant statement determines the location.
note that logging only method calls would not be enough to properly determine the previous statement since the call can come from a helper method in the test class.
for our example these before log entries are other return add addthread andother return take main .
the procedure addstartingevent adds an event for the thread that starts the region.
the eventis placed just befor e the first statement that follows the end of the region.
the type of the statement can be any including other call .
the same statement is used for naming the event.
in figure other call take main andother call add addthread are found following the algorithm.
input 2set list logentry logs 3float confidencethreshold output 5classstaticevent stmtid sid string name 6set staticevent events state 8bag staticevent inferred 10classregion intstart intend 12voidinferevents 13foreach list logentry loginlogs 14foreach region r incomputeregions log boolean addedfinished addfinishedevents r log if addedfinished addstartingevent r log 19filteroutlowconfidence confidencethreshold 20events inferred.toset 22set region computeregions list logentry log 23return newregion i j log i .type sleep call j min k log i .tid log k .tid log k .type sleep return 27boolean addfinishedevents region r list logentry log 28boolean result false 29foreach threadid t in log i .tid i r log r.start .tid 30set int relevant i r log i .tid t log i .type sleepcall block call th end j r log j .tid t log j .type sleepreturn block return 34if relevant.size slash.l ft continue 35intstarting max j relevant log j .tid t log j .type other return 37addevent relevant finished starting 38result true 40returnresult 42voidaddstartingevent region r list logentry log 43intfinished min j r.start log j .tid log r.start .tid log j .type other call th end 45addevent finished starting finished 47voidaddevent intlocation string nameprefix intsuffixidx 48stmtid sid log location .sid 49events newstaticevent sid nameprefix log suffixidx .info sid figure events inference algorithm region 1region calls returns if add is a helper methodth start main sleep call main sleep call addthread relevant in sleep return main block call main relevant in block return main other return take main 339other call add addthread sleep return addthread other call add addthread other return add addthread 330other return add addthread other call take main other call take main 339other return take main figure snippet from a log for inferring eventsfse acm pp .
fse acm pp .
.
.
inferringschedules figure6presents the algorithm to infer an imunit schedule for a sleep based multithreaded unit test that alread y contains imunit event annotations.
these annotations can be automatically produced by our event inference or manually provided by the user.
the input to the algorithm is a set of logs obtained from the passing executions of the sleep based test.
figure 7shows a snippet from one such log for our running example sleep based test shown in figure a .
the input also contains a confidencethreshold which will be described later.
the output is an inferred schedule i.e.
a set of orderings that encodes the intended schedule for the test.
the main part of the algorithm is the addsleepinducedorderings procedure.
it captures the intuition that a thread normally executes a sleep to wait for the other active threads to perform events.
recall line 13from our example in figure a where the mainthread sleeps to wait for the threadaddthread to perform an addoperation and line whereaddthread sleeps to wait for the mainthread to first perform one takeoperation and then block while performing the second takeoperation.
for each log the procedure scans for sleep return entries line31 .
as shown in figure the log for our example contains two sleep return entries one each in the mainthread andaddthread .
for each sleep return that is found the procedure does the following retrieves the next evententry for the same thread line33 .
this event will be used as the afterevent in orderings induced by the sleep return .
in the example log the twoafterevents are startingtake1 for the first sleep return andstartingadd2 for the second sleep return .
computes the other threads that were activebetween thesleep return and the afterevent line .
in the example for the first sleep return the only other active thread isaddthread and for the second sleep return the only other active thread is main.
finds for each active thread the last evententry that is before the afterevent.
this event will be the before event in the ordering induced by the sleep return with the corresponding active thread line .
note that this before eventon anotherthread canbe even beforethesleep return .
effectively this event is the currentlast entry and not the last entry at the time of the sleep.
in the example the two beforeevents are finishedadd1 andstartingtake2 for the first and second sleep return s respectively.
creates an ordering for each beforeandafterevent pair and inserts it into the inferred bag.
if a beforeevent is followed immediately by a block call within entries for the same thread a blockingordering is created otherwise anonblockingordering is created line .
in the example since startingtake2 is followed by a block call the ordering between startingtake2 andstartingadd2 will be ablockingordering while the other ordering between finishedadd1 andstartingtake1 will be a nonblockingordering .
before the addsleepinducedorderings procedure is invoked eachlogis modified by the preprocesslogs procedure.
this procedure looks for sleep return entries followed immediately by th start entries for the same thread.
for everysuch instance it swaps the sleep return andth start entries and sets the tidof thesleep return entry to be the id of the thread that is startedby theth start event.
the intuition is that a sleep return followed by a th start signifies that thestartedthread rather than the starting thread perform 1classevent string eventname threadid tid 2abstract classordering event before event after 3classnonblockingordering extends ordering 4classblockingordering extends ordering input 6set list logentry logs 7float confidencethreshold output 9set ordering orderings state 11bag ordering inferred 13voidinferschedules 14foreach list logentry loginlogs 15list logentry preprocessed preprocesslog log 16addsleepinducedorderings preprocessed 18minimize 20list logentry preprocesslog list logentry log 21list logentry result log.clone 22foreach i log i .type sleep return 23intj min j i log j .tid log i .tid 24if log j .type th start result j newlogentry sleep return log j .info result i log j 28returnresult 30voidaddsleepinducedorderings list logentry log 31foreach i log.indexes log i .type sleep return 32threadid t log i .tid 33intj min n i log n .tid t log n .type event 34set threadid active t n j log n .tid t log n .type event n i log n .tid t log n .type th end 37foreach threadid t inactive t intj max n j log n .tid t log n .type event event before newevent log j .info t event after newevent log j .info t if log min n j log n .tid t .type slash.l ft block call inferred newnonblockingordering before after else before.type block call inferred newblockingordering before after 46voidminimize list logentry log 47set ordering graph inferred.toset computeseqorderings log 48removecyclicorderings graph 49performtransitivereduction graph 50inferred.onlyretainorderingsin graph 51filteroutlowconfidence confidencethreshold 52orderings inferred.toset 54voidset ordering computeseqorderings list logentry log 55return newnonblockingordering log i log j i j log i .tid log j .tid log i .type log j .type event k i k j log j .tid log k .tid log k .type event figure schedule inference algorithm ordering1 ordering0block call mainsleep return mainth start addthread main sleep return addthreadevent startingtake1 mainevent finishedadd1 addthread event startingtake2 main event startingadd2 addthread figure snippet from a log for inferring schedulesfse acm pp .
fse acm pp .
2011ing the th start should wait for the other active threads to perform events.
many of the sleep based tests that we migrated included instances of this pattern.
effectively t his swap makes it appear as if the sleep was at the beginning of therunmethod for the started thread although the sleep was actually before the startmethod.
after each log is processed by the preprocesslogs and addsleepinducedorderings procedures the inferred bag is populated with all the inferred orderings.
however the inferred orderings may contain cycles e.g.
a bandb a and transitively redundant orderings e.g.
a b b c and a c where the last ordering is redundant .
the minimize procedure removes such orderings.
it first creates an orderinggraphby combining the edges from the inferred orderings with the edges implied by the sequential orderings of events within each thread the latter edges being computed by the computeseqorderings procedure .
it then removes all the edges of the graphthat participate in cycles.
it finally performs a transitive reduction on the acyclic graph and updates the inferred bag by removing all orderings not included in the reduced graph.
we use an open source implementation of the transitive reduction algorithm introduced by aho et al.
.
since the transitive reduction is performed on an acyclic graph we can use a simpler case of the general algorithm.
the last step of the minimize procedure is to remove the orderings thatwere inferred withlowconfidence.
recall tha t the input to our inference is a set of logs from several passing runs of the test being migrated.
the confidence of an inferred ordering is the ratio of the count of that ordering in theinferred bag and the number of logs runs.
for example an ordering may be inferred in only of runs say out of .
the confidencethreshold defines the lowest acceptable confidence.
all inferred orderings with confidence lower than the specified threshold are discarded.
.
.
eclipseplugin we have developed a refactoring plugin for eclipse to enable automated migration of existing sleep based unit test s into event based imunit tests.
the plugin is implemented using the generic refactoring api provided by eclipse.
the refactoring automates the most important steps required to migrate a sleep based test into an imunit test introduction of events and schedule using inference techniques an d checking of the introduced schedule.
the refactoring can also help the user name the threads in the test.
.
multiple schedules as mentioned in step of section .
after converting sleep based tests to event based imunit tests developers can merge several similar tests with different schedules int o one test with multiple imunit schedules.
recall our example sleep based test from figure a .
its intended schedule is anaddfollowed bya non blocking takeand a blocking take followed by another add.
suppose that the same test class contained another sleep based test whose indented schedul e is anaddfollowed by a non blocking takeand another add followed by another non blocking take.
although these two sleep basedtests wouldbealmost identical withthesleep at line9moved to before line they cannot share the common code without using additional conditional statements to enable the appropriate sleeps during execution.
in contrast after bothtests are migrated toimunittests theyca nbe easily replaced by just one new test.
this new test would have the same code as in figure a with two added annotations event finishedadd2 added after the add call and schedule finishedadd1 startingtake1 finishedadd2 startingtake2 added before the test method.
.
enforcing checking we now describe the imunit runner our tool for enforcing checking schedules for imunit tests.
it is implemented as a custom test runner for the junit testing framework.
it executes each test for each imunit schedule and has two operation modes.
in the active mode it controls the thread scheduler to enforce an execution of the test to satisfy the given schedule.
note that this mode avoids the main problem of sleep based tests that of false positives and negati ves due to the execution of unintended schedules.
in the passive mode our tool observes and checks the execution provided by the jvm against the given schedule.
our runner is implemented using javamop a high performance runtime monitoring framework for java.
javamop is generic in the property specification formalism andprovides several such formalisms as logic plugins including past time linear temporal logic ptltl .
although our schedule language is a semantic fragment of ptltl section3 enforcing ptltl specifications in their full generality on multithreaded programs is rather expensive.
instead we have developed a custom javamop logic plugin for our current imunit schedule language from figure .
since javamop takes care of all the low level instrumentation and monitor integration details after a straightforw ard mapping of imunit events into javamop events we here only briefly discuss our new javamop logic plugin.
it takes as input an imunitschedule and generates as outputa monitor written in pseudo code a java shell for this language then turns the monitor into aspectj code which is further woven into the test program.
in the active mode the resulting monitor enforces the schedule by blocking the vio lating thread until all the conditions from the schedule are satisfied.
inthepassive mode it simply printsan error when its corresponding schedule is violated.
a generated monitor for an imunit schedule observes the defined events.
when an event eoccurs the monitor checks all the conditions that the event should satisfy according t o the schedule i.e.
a boolean combination of basic and block events figure .
the status of each basic event is maintained by a boolean variable which is true iff the event occurred in the past.
the status of a block event is checked as a conjunction of this variable and its thread s blocked stat e. in the active mode the thread of ewill be blocked until this boolean expression becomes true.
if the condition contains any block event periodic polling is used for checking threa d states.
thus imunit pauses threads only if their events are getting out of order for the schedule.
note that the user may have specified an infeasible schedule which can cause a deadlock where all threads are paused.
our runner includes a low overhead runtime deadlock detection that detects and reports deadlocks.
as an example figure 8shows the active mode monitor generated for the schedule in figure c .
when events finishedadd1 andstartingtake2 occur the monitor just sets the correspondingboolean variables as thereis noconditi on for those events.
for event startingtake1 it checks if there was an event finishedadd1 in the past by checking the vari fse acm pp .
fse acm pp .
20111switch event 2casefinishedadd1 3occurred finishedadd1 true notifyall 4casestartingtake2 5thread startingtake2 currentthread 6occurred startingtake2 true notifyall 7casestartingtake1 8while !
occurred finishedadd1 wait 10occurred startingtake1 true notifyall 11casestartingadd2 12while !
occurred startingtake2 isblocked thread startingtake2 wait 15occurred startingadd2 true notifyall figure monitor for the schedule in figure c ableoccurred finishedadd1 ifnot thethreadwill beblocked untilfinishedadd1 occurs.
for event startingadd2 in addition to checking the boolean variable for startingtake2 it also checks whether the thread of the event startingtake2 is blocked if not the thread of the event startingadd2 will be blocked until both conditions are satisfied.
.
evaluation toevaluatetheimunitcontributions schedulelanguage automated migration and schedule execution we analyzed over sleep based tests from several open source projec ts.
table1lists theprojects andthenumberofsleep based tests that we manually migrated to imunit.
we first describe our experience with the imunit language.
we then present results of our inference techniques for migration.
we finall y discuss the test running time.
.
schedule language it is hard to quantitatively evaluate and compare languages be it implementation or specification languages in cluding languages for specifying schedules.
one metric we use is how expressive the language is i.e.
how many sleepbased tests can be expressed in imunit such that sleeps can be removed altogether .
note that imunit conceptually subsumes sleeps sleeps and imunit events schedules can coexist in the same test and developers just need to make sleeps long enough to account for the imunit schedule enforcement.
while every sleep based test is trivially an imu nit test we are interested only in those tests where imunit allows removing sleeps altogether.
we were able to remove sleeps from tests in fact all sleeps from all but tests.
while the current version of imunit is highly expressive we have to point out that we refined the imunit language based on the experience with migrating the sleep based tests.
when we encountered a case that could not be expressed in imunit we considered how frequent the case is and how much imunit would need to change to support it.
for example blocking events are very frequent and supporting them required a minimal syntactic extension adding events with square brackets to th e initial version of our language.
however some cases would require bigger changes but are not frequent enough to justify them.
the primary example is events in a loop.
imunit currently does not support the occurrence of an event more than once in a trace.
we did find tests that would require multiple event occurrences but changing the language to support them e.g.
adding event counters or loop indices to events would add a layer of complexity that is not justified by the small number of cases.
however as we apply imunitsubject tests events orderings collections jboss cache lucene mina pool sysunit jsr tck table subject programs statistics to more projects and gain more experience we expect that the language could grow in the future.
.
inference ofevents andschedules to measure the effectiveness of our migration tool in inferring events schedules we calculated precision and recall of automatically inferred events schedules with respect to t he manually written events schedules i.e.
the manual trans lations from sleep based schedules .
calculating precisi on andrecall requires comparingtheautomatically inferred a nd manually written events schedules.
for event inference t he input is a sleep based test and the output is a set of events.
our current comparison uses only the source code location line number of the static events and not their name.
for schedule inference the input is a sleep based test with manually written not automatically inferred events and the output is a schedule.
our comparison considers all orderings from the automatically inferred and manually written schedules two orderings match only if they have exactly the sameboth before and after events including their name and type that can be basic or block .
we performed the comparisons for all but discussed below of our tests.
table2shows for each project precision and recall values averaged over the tests from that project.
columns two and three show the results for event inference.
in most cases precision and recall are fairly high.
we inspected the cases with lower precision and identified two causes for it.
the first cause is due to our evaluation setupandnot thealgorithm itself.
namely our currentcomparison requires the exact match of source code locations.
if the locations differ the inferred event counts as a false neg ative evenifit was onlyafewlines from themanuallywritten event and even if those locations are equivalent with respe ct to the code.
in the future we plan to improve the setup by analyzing the code around the automatically inferred and manually written events to determine if their locations are equivalent.
the second reason is that some tests use sleeps that are not relevant for the thread schedule e.g.
jbosscache has such sleeps in the helper threads shared among tests and lucene has similar sleeps while interacting with the i o library .
these extra sleeps mislead our inference which assumes that every sleep is relevant for the schedule and infers events for every sleep.
columns four and five show the results for schedule inference.
the results are even more impressive than for event inference with precision and recall of over in all cases .
we identified two causes for misses.
the first cause is that some threads can be independent.
the algorithm always forms edges from all threads to the thread that invokes sleep method but this should not be done for independent threads.
in the future we plan to consider an abstraction similar to regions figure as a mechanism to detect inde fse acm pp .
fse acm pp .
2011subjectinferring events inferring schedules precision recall precision recall collections .
.
.
.
jboss cache .
.
.
.
lucene .
.
.
.
mina .
.
.
.
pool .
.
.
.
sysunit .
.
.
.
jsr tck .
.
.
.
overall .
.
.
.
table precision and recall for inference subject original crtrlc collections jboss cache lucene mina pool sysunit jsr tck table numbers of removed orderings pendent threads.
the second cause is the same as for event inference namely unnecessary sleeps.
a known issue in information retrieval is that some result sets may be empty which corresponds to infinite precision and zero recall.
for of tests our inference techniques returned empty sets of events schedules becaus e these tests do not use sleeps to control schedules.
instead these tests use while condition thread.sleep yield or wait notifyorcountdownlatch and other concurrent constructs to control schedules.
we excluded these tests from the evaluation of our inference techniques.
our inference algorithms use confidencethreshold to select some of the events schedules with the default value of .
for table .
we performed a set of experiments to evaluate how sensitive our inference is to the value of confidencethreshold .
we found that the results are quite stable.
for example for schedule inference when changing the value from .
to .
only for lucene the precision drops from to .
.
when changing the value from .
to .
only for jboss cache the precision and recall drop from .
and .
to .
and .
respectively.
for all other cases everything else is inferred exactly the same for the values .
and .
as for the default value .
.
the other input to our inference algorithms is the set of logs obtained from passing runs of the legacy tests.
by default we collect passing logs for each test for table .
different runs of the legacy test can produce different logs that can in turn result in different sets of events schedules being inferred.
therefore depending on the number of logs inferred events schedules could differ.
so we evaluated how sensitive our inference is to the number of logs.
we found that the logs are quite stable and almost identical results were obtained for and logs.
for instance going from to logs only the recall for jboss cache drops from .
to .
and everything else remains the same.
lastly our schedule inference algorithm runs a minimization phase after processing all the logs.
table 3summarizes the results of this phase.
it tabulates for each project th e number of schedule orderings originally inferred before mi nimization original and the numbers of orderings removed by cycles removal cr by transitive reduction tr andsubjectoriginal imunit speedup ddd dde ddd dde collections .
.
.
.
.
jboss cache .
.
.
.
.
lucene .
.
.
.
.
mina .
.
.
.
.
pool .
.
.
.
.
sysunit .
.
.
.
.
jsr tck .
.
.
.
.
geometricmean .
.
table test execution time.
ddd deadlock detection disabled dde deadlock detection enabled due to low confidence lc .
as it can be seen the minimization phase does not remove many orderings.
however it is important to remove the orderings it does remove.
for example without removing the cycle for jboss cache not only would inference have a lower precision but it would also produce a schedule that is unrealizable.
.
performance table4shows the execution times of the original sleep based tests and the corresponding imunit tests for imunit withdeadlockdetectionbothdisabledandenabled .
we ran the experiments on an intel i7 .67ghz laptop with 4gb memory using sun jvm .
.
.
our goal for imunit is to improve readability modularity and reliability of multithreaded unit tests and we did not expect imunit execution to be faster than sleep based execution.
in fact on e could even expect imunit to be slower because of the additional code introduced by the instrumentation and the cost of controlling schedules.
it came as a surprise that imunit is faster than sleep based tests on average .39x.
even wit h deadlock detection enabled imunit was on average .76x faster.
this result is with the sleep durations that the orig inal tests had in the code.
we also compared the runningtime of imunit with multithreadedtcon acommon subsetof jsr 166tck tests that themultithreadedtcauthorstranslatedfrom sleep basedt o tick based .
for these tests multithreadedtc was .36x faster than imunit.
although multithreadedtc is somewhat faster it has a much higher migration cost and in our view produces test code that is harder to understand and modify than the imunit test code.
moreover we were surprised to notice that running multithreadedtc on these tests translatedbythemultithreadedtcauthors canresu lt in some failures albeit with a low probability which mean s that these multithreadedtc tests can be unreliable and lead to false positives in test runs.
.
related work three areas of work are related to imunit unit testing of multithreaded code enforcement of schedules and automated inference of specifications.
we briefly discuss each of them.
conan and multithreadedtc introduce unit testing frameworks that allow developers to specify schedules to be used during the execution of multithreaded unit tests.
however the schedules in both frameworks are specified relative to a global clock real time for conan and logic time for multithreadedtc which makes it difficult to reason about the schedules.
also neither framework supports automated migration of sleep fse acm pp .
fse acm pp .
2011based tests.
concjunit extends junit to propagate exceptions raised by child threads up to the main thread and also checks whether all child threads have finished at the end of a test method.
threadcontrol proposes a tool to ensure that assertions are performed without interferen ce from other threads.
there has been some previous work on using formally specified sequencing constraints to verif y multithreaded programs .
the specifications are over sync events with ltl like constraints and the verification ensures that the implementation is faithful to the specifica tion.
in contrast imunit schedule specifications are used to enforce ordering between user specified events while the system is tested.
carver and tai use deterministic replay for concurrent programs.
leap is a more recent system usingasimilar record and replayapproach toreproduc e bugs.
in comparison our enforcement and checking mechanism targets ensuringtheuser specified schedulerather th an replaying a previously observed execution.
work on automated mining of specifications for programs is related to our automated inference of events and schedules.
however most existing work focuses on mining api usage patterns rules in a single threaded scenario while our tec hniques mine the intention of sleep based tests i.e.
interes ting events and event orderings across multiple threads.
.
conclusions current approaches for unit testing of multithreaded code have issues with readability modularity reliability an d or migration cost.
we presentedimunit anovelapproachthat addresses these issues.
imunit includes a new language that makes tests more readable and modular as it allows explicitly specifying schedules on the events during test executi on.
we described inference techniques and a tool that can help in migrating sleep based tests to imunit.
we also described a tool that can reliably execute the specified schedule to avoid false positives negatives.
the promising results wi th imunit encourage us to further explore this approach e.g.
for automatic generation of multithreaded tests both test code and schedules only from the code under test or for regression testing of code with imunit schedules .