automated memory leak detection for production use changhee jung sangho lee easwaran raman santosh pande virginia tech usa georgia tech usa google inc. usa georgia tech usa chjung cs.vt.edu slee431 cc.gatech.edu eraman google.com santosh cc.gatech.edu abstract this paper presents sniper an automated memory leak detection tool for c c production software.
to track the staleness of allocated memory which is a clue to potential leaks with little overhead mostly sniper leverages instruction sampling using performance monitoring units available in commodity processors.
it also offloads the time and space consuming analyses and works on the original software without modifying the underlying memory allocator it neither perturbs the application execution nor increases the heap size.
the sniper can even deal with multithreaded applications with very low overhead.
in particular it performs a statistical analysis which views memory leaks as anomalies for automated and systematic leak determination.
consequently it accurately detected real world memory leaks with no false positive and achieved an f measure of on average for benchmarks stress tested with various memory leaks.
categories and subject descriptors d. .
software program verification reliability statistical methods d. .
testing and debugging debugging aids monitors tracing d. .
processors memory management run time environments general terms language measurements performance reliability keywords sniper memory leak detection anomaly detection performance monitoring unit .
introduction memory management bugs are a common source of persistent errors in real world code.
memory leaks are particularly notorious since their symptoms and causes are insidious and hard to track .
leaks occur when allocated objects are not freed even if they permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.are never accessed again.
since they remain allocated consuming the heap memory they gradually affect the quality of service qos of the entire system.
that is they impact not only the leaking application but also all the others due to the limited amount of available system memory .
even worse piled leaks eventually crash the applications by exhausting system resources.
memory leaks can also result in software security reliability problems .
for example many cve entries this year including cve have detailed the problems and malicious exploits have been designed based on memory leaks to launch denial of service dos attacks .
in the manycore era leaks are more common than ever in multithreaded software.
when heap allocated objects escape their thread it is hard to determine when and which thread should deallocate them.
due to the difficulties of reasoning about the liveness of the shared objects programmers often end up leaving the objects allocated in the memory thereby producing leaks.
despite undergoing extensive in house testing leaks often exist in deployed software and show up in customer usage .
in fact they are common causes of bug reports for production software e.g.
over leaks in a firefox web browser were reported in the first quarter of .
that is mainly because memory leaks are very input and environment sensitive .
to effectively detect such memory leaks tools have to be usable in production environment to observe the real execution characteristics of an application which leads to leaks.
unfortunately existing tools cannot be used in production environment.
first their high overhead jeopardizes the qos demand e.g.
latency and throughput degradation for datacenter applications .
while state of the art tools leverage sampling techniques to track accesses to heap objects the resulting overhead is still unacceptable e.g.
.72x slowdown and more than dynamic memory increase for heapbound applications.
note that such memory consuming approaches including are prohibited for production use.
apart from that it just makes no sense to spend more memory for less memory leak.
more importantly existing tools are neither automated nor systematic.
their leak determination relies on a manually set threshold.
that is user intervention is required for each program and even worse such a high cost will have to be paid anew on environmental change e.g.
program input workload change.
it is unrealistic to ask users to set a new threshold for each environmental change.
the lack of a methodology for determining threshold forces users to seek a proper threshold for each application.
in reality they often end up blindly applying a fixed threshold to those applications that have different characteristics.
as a result existing tools can falsely blamepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
non leaking objects or miss real leaks.
thus the tools are inherently vulnerable to false positives and negatives.
given all this there is a compelling need for a practical memory leak detection tool usable in production software.
with that in mind this paper presents the design and implementation of sniper to automatically detect memory leaks in c c production applications.
it leverages instruction sampling using performance monitoring units pmu in processors to track accesses to heap objects without significant overhead.
it also offloads most of time and space consuming work e.g.
tracking heap organization and searching for the heap object accessed by a sampled instruction.
to achieve this sniper uses a trace driven approach based on the combination of a lightweight heap trace generation and an offline trace simulation.
during program execution sniper records full traces of malloc free as well as sampled pmu traces.
the offline simulator then analyzes those traces and calculates the staleness of heap objects which is a clue to potential memory leaks.
that is the simulator replays the program s heap related activities thereby catching every leak that occurred during the program execution.
in this way sniper rarely increases the execution time and the memory space at runtime.
the takeaway is that the same mechanism is applicable to multithreaded program with no synchronization overhead.
in particular sniper s leak identification is very accurate.
rather than relying on ad hoc efforts which require user intervention sniper provides a systematic and accurate methodology to identify leaks.
the main idea is to view memory leaks as anomalies.
sniper s anomaly detection is not only fully automated but also applicationtailored.
such a statistical analysis makes sniper robust against false positives negatives across applications.
for example even though thestaleness of innocent objects might be over estimated due to the sampling they are very unlikely to be falsely blamed.
finally sniper neither requires recompilation nor perturbs the application execution with instruction instrumentation or memory allocator modification.
along with the low overheads that makes sniper work transparently to the application.
in case qos requirement becomes more stringent it is possible to dynamically turn off sniper taking away all the overheads.
overall sniper is usable in production environment and therefore can observe real execution characteristics that actually cause memory leaks.
the following are the contributions of this work the first automated and systematic methodology for accurate leak identification based on an anomaly detection.
the most important issue is to automatically determine the staleness threshold which is an open problem.
our leak identification which is tailored not just for each application but for each allocation site as well effectively deals with the problem.
a new trace driven methodology to track how an application interacts with the heap it not only offloads heavy work to the simulator but also enables the statistical analysis of leaks.
to the best of our knowledge sniper is the first to effectively detect leaks for multithreaded software.
no heap size increase and very little time overhead.
.
background and motiv ation this section introduces basic concepts and terminologies used in state of the art leak detection tools and shows their limitations as well as the requirements for production use.
target memory leaks memory leaks are of two kinds unreachable memory i.e.
program cannot access it and dead memory i.e.
it is reachable but the program will never use it again thus it is not live.
the unreachable leaks can be effectively addressed figure threshold effect tideal is in between l2andi1 by garbage collection static analysis or model checking .
however the dead leaks are much trickier since it is in general undecidable to determine if certain memory will not be accessed in the remainder of the program execution.
this difficulty leads to the advent of those memory leak detection tools based on dynamic analysis techniques including sniper1.
the focus of this paper is to detect the dead leaks even though sniper can deal with both types of leaks.
staleness based leak detection chilimbi and hauswirth formulated the problem of memory leak detection based on how stale heap objects are in their pioneering work called swat .
they define the staleness of an object as how long it remains unaccessed since the last access time .
swat reports those heap objects whose staleness is greater than the length of timeout.
that is if an object has not been accessed for a long time it is likely to be a leak.
at time treport an objectois identified as a leak iftreport tlast access o threshold staleness .
to track the last access with low overhead existing tools leverage a sampling technique.
depending on the threshold they can end up reporting innocent objects as leaks false positives and miss real leaks false negatives .
figure shows the importance of accurate threshold determination.
in the figure circles on a time arrow represent the last access of heap objects whose staleness appears below the arrow.tncorresponds to each threshold while lnandinto leaking and innocent objects respectively.
here t1missesl2since thestaleness l2 is less than the threshold staleness t1 thus a smaller threshold is desirable.
alternatively t2correctly identifiesl2as a leak but falsely blames i1since the staleness i1 becomes greater than the threshold staleness t2 .
the ideal threshold tideal exists between tlast access argminx2lstaleness x andtlast access argmaxy2istaleness y wherelandiare the sets of leaking and innocent objects respectively.
however it is practically impossible to determine tideal since such a determination already requires perfect knowledge of what object is a leak.
note that the ideal threshold exists if and only if min x2lstaleness x max y2istaleness y that is if the inequality above does not hold then threshold s t jffalsepositiveg ffalsenegativegj meaning that there is no threshold to achieve perfect accuracy.
in reality since existing tools leverage a sampling technique thereby over under estimating the staleness the inequality is likely to fail i.e.
they suffer from false positives negatives.
note that the ideal staleness threshold is different across applications.
that is the leak determination should be application specific.
1the dynamic analysis techniques including sniper are inherently notcomplete due to their input centric nature.826in particular this work shows that even if the inequality does not hold in the first place sniper can still achieve good results with the help of its context sensitive leak detection see section .
.
.
requirements for production use since memory leaks are very input and environment sensitive production use is essential to observe real execution characteristics that actually cause the leaks.
there are several requirements for production use that the sniper must meet.
first sniper must not cause significant overhead that jeopardizes the qos requirements of the production service.
for example it should not increase heap size thus memory consuming approaches are prohibitive.
second due to the difficulty of the manual threshold determination and the need to reset it on environmental change sniper must provide an automated and systematic methodology for leak determination.
third it has to be precise it should not blame an application for the falsely reported leaks while real leaks must be detected.
lastly sniper should be able to effectively deal with multithreaded software.
otherwise it would be considerably less useful.
unfortunately existing tools do not meet any of above requirements thus not usable for production use.
in light of this sniper takes into account the requirements in its design.
.
sniper approach details the first goal is to provide a lightweight memory leak detection tool usable in production environment.
to achieve this we identified the key sources of runtime and space overheads in staleness based leak detectors.
the instruction instrumentation to track accesses to heap objects causes high runtime overhead.
most of the space overhead comes from tag meta data that abstracts the heap objects for each heap object tools need to maintain the staleness the allocation site the dynamic program point that accessed the object and the heap organization information e.g.
the address range of the object.
updating the staleness of the heap objects causes both space and time overheads.
in particular for every sampled load the tools need to determine if the instruction accesses a heap object.
this requires searching the tag directory which is a memory intensive data structure for the heap object whose range embraces the target address of the load instruction.
sniper addresses each source of the overheads effectively.
to remove the heavyweight instrumentation completely sniper exploits instruction sampling using hardware performance monitoring units pmu available in commodity processors.
to reduce the space overhead due to the tag data sniper buffers the full trace of malloc free and flushes each buffer into files when it is full.
similarly sniper maintains another buffer to keep information about pmu samples.
thus the additional memory consumption is bound to the size of the buffers.
sniper also offloads time and space consuming work of the staleness update to its trace simulator.
using the malloc free pmu traces generated at runtime as an input the simulator performs the expensive staleness update offline.
that way the memory hungry tag directory and the space needed for the staleness are no longer necessary at runtime.
instead it is during the offline simulation that a tag directory is constructed and searched for the staleness update.
in this manner sniper minimizes both time and space overheads during program execution by offloading much of the work.
the more important goal of sniper is to provide an automated and systematic methodology for precise leak determination.
again the lack of the methodology leads to blindly applying a fixed threshold to all the applications which may differ significantly in their behaviors.
to this end sniper leverages a couple of observations one size fit all threshold does not exist even within the same figure the sniper organization.
application i.e.
multiple thresholds should be carefully determined according to application characteristics.
separating objects based on program context where they are created and then performing leak detection on the separated sets can improve the accuracy i.e.
the inequality is more likely to hold.
in short the leak determination methodology should be tailored for each allocation site as well as each application.
with that in mind sniper leverages a statistical analysis on the trace information as well as detailed results of the trace simulation.
in particular this work reformulates the problem of memory leak detection as that of anomaly detection.
thus sniper views memory leaks as anomalies.
the reason for this is that the staleness of a leaking object should be extremely higher than that of considerably more normal objects in the entire application or even in the same allocation site.
the end result is that sniper can automatically determine the staleness threshold in an application specific manner.
figure shows a high level view of sniper.
first an application binary is fed into sniper s launcher.
it prepares a ptrace hook so that a ptrace monitor observes every pmu transaction from the core the application is running on.
that way sniper can collect the instruction samples without perturbing the application execution.
then the launcher preloads sniper s wrapper .so to hijack heap interfaces e.g.
malloc free and then it forks and executes the application.
at runtime the wrapper generates traces of the functions to track how the heap organization evolves.
they are buffered and later recorded in files.
pmu traces are recorded in a similar manner.
once the application completes its execution all the traces are fed into a trace simulator.
to extract program context information it consults the binary analyzer.
during the simulation it tracks the interaction between the application and the heap organization as well as the accesses to the heap allocated objects.
that is the simulator replays the application s execution in terms of its heap usage and updates the staleness of the allocated objects.
at the end of the simulation sniper finally reports leaks detected with its anomaly detection to bugzilla.
in particular sniper s report is rich with details about each object including the program context malloc free sites2 and various simulation results such as memory 2sniper records the return address of malloc and free at runtime.
later the offline trace simulator calculates the their actual site address from the return address by analyzing the application binary.827access growth analysis.
while prior work reports just the last access site of only leaking objects i.e.
a single instruction address sniper provides a snapshot of different instruction accesses to the objects whether or not they are a leak.
thus sniper can help developers to fix leaks while debugging.
for example using the techniques found in one can construct a dynamic slice to track down the offending memory allocation and find the program flow from that allocation site until the point of last use.
.
memory access tracking with pmu the key to detect leaks is the staleness of allocated objects in that if they have not been accessed for a long time they are likely to be leaks.
by its definition i.e.
the elapsed time from the last access thestaleness calculation requires tracking the memory access to the objects.
for efficient leak detection it is important to collect the last access with a low overhead.
with that in mind sniper obtains the memory access profile through the pmu without incurring a significant overhead.
this section briefly presents sniper s hardware software internals and the related issues.
an instruction sampling is a hardware mechanism that offers a good insight into program behaviors with a very low overhead.
the pmu on modern processors has a special mode called event based sampling .
for a given event this mode can configure the corresponding performance counter to raise an interrupt on overflow of its value i.e.
sampling period when an interrupt occurs the instruction that causes the overflow can be queried.
as an extension to that intel s pebs precise event based sampling not only provides precise location of the event in the instruction space but also provides a way to access the register contents of the instruction that causes the event.
likewise amd s ibs instruction based sampling supports reading the virtual address in the target register of the retired load store instruction together with its address.
similar sampling support is available on other microarchitectures such as intel pentium4 itanium ibm power5 sun ultrasparc etc.
sniper samples memory accesses i.e.
load store events to capture both the instruction and data addresses in the target register through the pmu based instruction sampling.
such information about each sample along with its timestamp is recorded in the trace files.
later the trace simulator determines whether the sampled instructions access a heap object.
that is if there exists a heap object that embraces the data address of the executed instruction the simulator updates the staleness of the object based on its timestamp.
currently sniper supports process and thread aware sampling with the help of perfmon2 kernel interface and ptrace system calls.
sniper intercepts process thread creation requests through the ptrace hook and creates a pmu context for each thread the context contains appropriate pmu configurations including event types and sampling periods.
sniper then attaches the pmu context to the corresponding thread to be created.
on a context switch the kernel reconfigures the pmu according to the attached pmu context and enables the sampling of memory accesses.
with this support sniper can monitor and save threadlevel information thereby effectively dealing with multithreaded applications.
during program execution sniper monitors the application s pmu transactions i.e.
memory access samples and fetches the samples through the perfmon2 kernel interface.
it is important to note that sniper does not interrupt the target application execution at all.
thus sniper keeps track of the heap accesses without perturbing the original application execution.
in particular to prevent a majority of samples from falling into a synchronized pattern in some loops sniper leverages the sampling period randomization i.e.
adding a small randomized factor to the period.
.
lightweight heap trace generation to track the staleness of the heap objects sniper has to be aware of the heap organization in terms of its allocation and deallocation during program execution.
for this purpose it is necessary to record full traces of malloc free and the related program context information.
even if the trace simulator takes over much of the heavy work such as tracking heap organization sniper still needs to minimize the overhead of the trace generation.
unfortunately the trace occupies a large amount of memory in order to store the tag data of each heap object.
for example the tag data includes its allocation deallocation last access sites heap organization information such as the range information of an allocated object and freed address and so on3.
to tackle the space overhead sniper buffers the tag data trace and flushes the buffer into a file when it is full.
in this way the memory consumption of the trace generation is bound to the buffer size.
especially for a multithreaded application sniper should take care of contention to the buffer and the file from multiple threads.
of course sniper should guarantee that multiple threads write their trace correctly.
one way to do that is relying on locking mechanism on the buffer and the file.
however this causes unacceptable performance degradation of the application due to the high synchronization overhead as the number of threads increases.
instead of using the locking mechanism sniper allocates both a buffer and a file into each thread thus they become thread private.
this makes the buffer accesses lock free as well as allows sniper to use fwrite unlocked for lockless file writing.
in particular it is important for the trace simulator to have a synchronized view of traces from multiple threads.
to achieve this sniper associates each of malloc free pmu traces with the timestamp when it is generated.
.
offline trace simulation sniper offloads the time and space consuming work of the staleness update for heap objects which requires tracking heap organization and searching for the heap object accessed by a sampled instruction.
to achieve this sniper leverages the lightweight heap trace generation and its offline trace simulator that takes over the heavy work.
in particular the simulator builds the tag directory based on recorded traces and performs expensive tag searches to calculate the staleness offline.
once the traces of malloc free pmu memory access are recorded at the end of program execution all the trace files are fed into the simulator.
an application binary is also fed into the simulator for its binary analyzer to extract an actual allocation site address the instruction address of call to malloc new is calculated based on the return address in the stack trace.
the same thing is with deallocation and last access sites.
then the simulator first merges the traces in the files and sorts them by the timestamp of each trace using mapreduce .
this gives the simulator a time synchronized view of all the traces.
while the simulator is running it decodes each trace in turn and performs appropriate actions according to the decoded results.
to keep track of the heap organization sniper models each heap object with the start and end addresses of the object in the tag and maintains a tag directory to manage the tags.
when the simulator processes a malloc free trace the corresponding tag is created inserted removed in the directory.
for a memory access trace the simulator determines if the address of the access corresponds to one of the heap objects.
this involves a search for the corresponding 3the space for the staleness is not necessary at runtime because it is calculated offline by the trace simulator.828tag whose range the start of the tagged object its end address embraces the queried address in the tag directory4.
if the search succeeds i.e.
the address of the memory access belongs to a heap object the staleness of the resulting tag for the object is calculated and recorded by the simulator.
since it tracks the heap organization each access is correctly attributed to the corresponding heap object.
in summary the trace simulator replays the program execution in terms of the heap usage updating the staleness of the allocated objects.
.
automated and systematic leak detection once the trace simulation finishes sniper is ready to report leaking objects based on the staleness .
an important issue is how to determine the threshold staleness .
it is very important to precisely determine the threshold since it directly impacts the number of false positives and negatives.
to the best of our knowledge no prior work deals with this issue thus users are left to determine the accurate threshold on their own.
unfortunately it is indeed difficult costly and error prone for users to set the threshold correctly.
upon any change such a high cost of threshold determination will have to be paid anew.
in particular the threshold should be different across applications and there is no one size fit all solution even in the same application.
with that in mind this work leverages a statistical anomaly detection i.e.
sniper views leaks as anomalies.
this is based on a couple of observations the staleness of a leaking object is very high compared to normal objects allocated in the same site which is the basic philosophy of staleness based leak detection.
the number of leaking objects is a lot smaller than that of normal objects.
this is because production software should undergo a number of extensive testing procedures from its creation to the release.
in fact large software companies such as microsoft and ibm have already adopted the test driven application development approach .
without passing various test cases developers cannot submit even a single line of change to the code repository.
that way naive leaks in applications are likely to be detected before its production release.
.
.
anomaly detection with adjusted boxplots sniper transforms the problem of leak detection into that of anomaly detection for univariate data sets which are comprised of thestaleness of objects.
the issue here is that most of the anomaly detection techniques assume an underlying distribution e.g.
boxplot approach works best for normal distribution as other approaches favor it .
however the leak detection problem does not follow normal distribution.
recall that leaking objects are very few compared to normal objects and the stalenesses of leaking objects is very high compared to that of normal objects.
thus the distribution of stalenesses data tends to be right skewed i.e.
having a long tail in the positive direction which can paralyze the anomaly detection capability of the boxplot approach.
that leads to a different approach i.e.
sniper leverages adjusted boxplots for the anomaly detection.
in contrast to the original boxplot approach that classifies all points outside the interval of whereq1andq3are 1st and 3rd quartiles respectively and iqr isq3 q1 aspotential anomalies theadjusted boxplot shifts the interval with the consideration of how the underlying distribution of the data set is skewed.
for the systematic leak determination sniper sets the threshold staleness as the upper bound of the adjusted boxplot defined as 4we implement the directory using a modified redblack tree whose asymptotic complexities remain the same i.e.
o logn time .
this fast range search is essential for accelerating simulation.threshold q3 0e3mciqr mc q3 0e4mciqr mc where medcouple mc i.e.
a robust measure of the skewness of an underlying distribution is defined as mc med xi q2 xjh xi xj whereq2is the sample median and for all xi6 xj.
that is mcis the median of the kernel function h results where his given by h xi xj xj q2 q2 xi xj xi more details of adjusted boxplots can be found in .
.
.
the granularity of the anomaly detection this section describes leak determination schemes that differ in the scope of the anomaly detection.
local detection sniper can apply the anomaly detection for each allocation site which is called local detection.
this scheme has potential to achieve higher accuracy since it performs allocationsite specific context sensitive leak detection.
even when the inequality does not hold for entire objects the scheme can still detect leaks with no false positive negative.
that is by narrowing down the scope of leak detection to those objects created in the same site the inequality is likely to hold.
however the local scheme can be misleading depending on the state of an allocation site.
this might occur for a couple of reasons insufficient amount of sample data if some site has a few objects e.g.
objects in which case no statistical method works.
similarity of sample data even with the abundant amount of sample data stalenesses of the objects could have not much difference in which case even humans cannot detect any anomaly.
for example it would be the case where every object created in one site is all leaking or no object is leaking.
global detection to deal with the problems sniper can perform the anomaly detection for entire objects within the application which is called global detection.
note that the global scheme still performs the application tailored leak detection but not in the allocation site specific way.
when the local scheme fails to detect leaks due to its high threshold local threshold staleness the global scheme would be a good alternative.
as an example when those objects created in the same allocation site are all leaking the global scheme is still able to detect them because its threshold global threshold staleness is likely to be smaller than their stalenesses.
then the question is how to make a correct decision to pick the right detection scheme for each case.
by that sniper can take advantage of the synergy between the local global schemes thereby achieving higher accuracy.
on the contrary an incorrect decision translates to false positives negatives.
with that in mind this work designs sniper s hybrid detection scheme.
hybrid detection sniper performs the local detection for each site in the first place.
the idea is that sniper respects the leak report of the allocation site specific detection scheme.
for only those allocation sites that report no anomaly leak does sniper consult the global detection scheme.
for the local and global schemes to generate a different result the staleness spectrum of the objects in the site has to be overlapped with the interval of the two thresholds of both the schemes.
that is the candidate sites for the hybrid detection is defined as candidate sites fsitejsite2s global threshold staleness max o2sitestaleness o local threshold staleness site g 829wheresis a set of allocation sites in an application.
for each candidate site the hybrid scheme simply uses the global scheme assuming that the site s objects are leaking.
the intuition behind the heuristic is two fold it follows the philosophy of the original staleness based leak detection i.e.
highly stale objects are likely leaking.
sniper must not miss leaks otherwise it loses its worth as a leak detection tool.
however the heuristic might end up with false positives in case the assumption is wrong.
note that this is rather a limitation of staleness based leak detection i.e.
it is possible to incorrectly blame the objects that are highly stale but that do not actually leak.
as an example even if gui objects might not be accessed for a long time after their creation they should not be reported as leaks .
to avoid such unnecessary false positives sniper focuses on users expectation for a leak detection tool.
in general users are interested in the critical leak that impacts overall memory consumption.
that is they would not care about a leak which rarely affects memory consumption even though it is highly stale .
in light of this sniper selectively applies the heuristic according to how much stale objects contribute to total memory consumption i.e.
the hybrid scheme switches to the global scheme only for the following sites hybrid sites fsitejsite2candidate sites x obj2sitesize obj x obj2allocated setsize obj g where allocated set is a set of the objects that have been allocated but not yet freed at time treport .
that is if it turns out that the stale objects detected by the global scheme do not contribute significantly the hybrid scheme remains at the local scheme.
note that is a configurable parameter which takes into account the application s qos requirement.
this work sets the value of to .
in the experiments.
.
false positives due to sampling since sniper leverages instruction sampling to update the staleness of the accessed heap object it could miss some memory access.
such an uncaught access to heap objects causes sniper to overestimate their staleness .
in a sense sniper might falsely report them as leaks thus causing false positives.
it is important to note that for frequently accessed objects the sampling does not have a significant impact on the false positives.
the reason is that often times leaks become manifest after longrunning execution.
that is it is practically impossible to generate false positives from frequently accessed objects for that long time.
the real possibility of false positives due to the sampling comes from those objects that are sporadically accessed.
for example if the last access to the objects with a long life time is not sampled sniper ends up overestimating the staleness thereby falsely reporting them as leaks.
in particular sniper turns out to be accurate even when the sampling frequency is low see section .
.
that is because even if staleness gets overestimated due to the low sampling rate sniper s anomaly detection adapts itself to the underlying sample distribution.
that is sniper adjusts the threshold appropriately according to the resulting staleness distribution.
thus sniper can effectively prevent unsampled objects from being falsely blamed as leaks.
.
discussion trace size simulation time without any optimization the largest trace file we evaluated was gb and its simulation took minutes including the time spent sorting the trace with mapreduce .
table summarizes both the trace size and the simulation figure typical datacenter like production environment table the trace size and the simulation time benchmark trace size simulation time omnetpp .
mb .
min dealii .
mb .
min xalancbmk .
mb .
min time of those applications whose trace simulation takes more than minutes.
for other spec2006 applications the trace size is mostly less than mb while the trace simulation takes a few minutes.
one possible optimization to reduce the trace size simulation time can be achieved by periodically processing partial trace files during program execution.
once simulation outputs are generated most of the trace files can be deleted.
those malloc traces having the corresponding free traces can be deleted too.
however for incremental staleness update any information necessary to track the heap organization should be maintained.
for efficiency the partial trace files can be transmitted to other available machines in a pipelined way for the remote simulation.
note that many production applications have already collected various traces for a monitoring purpose.
thus dedicated analysis machines often exist in datacenters to process the log and trace data of production machines.
sniper can thus leverage such machines to enable the remote simulation.
figure shows the datacenter environment.
in particular both production and analysis machines share a distributed file system e.g.
quantcast file system hadoop distributed file system which is connected to a separate gigabit network.
thus writing a trace file rarely affects the qos of the application which is serviced using another network e.g.
internet the production machines are equipped with two nics for each separate network to keep the overhead minimal.
limitation with virtualization the target of sniper is production software running on non virtualized systems where highperformance is critical.
in fact many commercial applications run on a non virtualized cluster node in the datacenter for performance reasons .
since the proposed pmu based technique does not assume a virtual machine vm sniper is not directly applicable to vms in its current form.
however this is not a fundamental obstacle for sniper to be used on virtualized systems.
in the vm environment pmu is shared among processes on different vms as well as on the same vm.
therefore pmu virtualization is a key to avoid mixing memory access samples of different processes.
recently operating system researchers have come up with a framework for the pmu virtualization .
currently kvm kernel based virtual machine has already supported intel s architectural pmu .
thus we expect that the support for other features of pmu to be available soon.
.
ev aluation to demonstrate the effectiveness of sniper we implemented it in c as a shared library on a linux operating system.
to access pmu we leverage perfmon2 kernel interface .
this section first analyzes the execution time overhead of sniper for both single and830 .
.
.
.
.
.
.
cfrac espresso gs roboop geo mean soplex povray gobmk sjeng mcf hmmer gcc sphinx3 h264ref bzip2 milc lbm xalancbmk omnetpp perlbench libquantum gromacs astar dealii namd geo meannormalized execution timebaseline sniperfigure execution time overhead of serial benchmarks multi threaded benchmark suites with their largest input available.
it turns out that sniper s memory space overhead is negligible for those benchmarks.
note that there is no increase in application s heap size.
the only source of the overhead is the small fixedsize trace buffers.
then it analyzes the accuracy of sniper using synthetic memory leak injection and presents a sensitivity analysis to sampling period.
finally it describes a case study of using sniper to detect realworld memory leaks in several open source applications vulnerable to malicious denial of service attacks.
all experiments were performed on a linux machine with two intel nehalem based quad core xeon processors i.e.
cores total in two sockets with 32gb of memory.
in particular trace files are written to a distributed file system.
except for the sensitivity analysis sniper runs with a sampling period of see section .
.
.
runtime overhead of serial benchmarks figure summarizes the execution time overhead incurred by sniper in serial applications including both spec2006 and allocationintensive benchmarks.
in the figure the dark bars correspond to a baseline execution time without sniper while light bars to the execution time with sniper enabled which is normalized to the baseline time.
for most of the spec2006 applications sniper s overhead is negligible except for xalancbmk perlbench and omnetpp .
note that prior work omitted the applications butxalancbmk in its evaluation e.g.
it failed to execute omnetpp due to its overhead.
for xalancbmk the prior work causes huge overhead almost 10x slowdown while sniper s overhead is only .
overall the execution time overhead incurred by sniper is on average for the spec2006 applications.
we also measure the overhead for several allocation intensive applications since they were used in the most recent work .
for these applications sniper causes relatively significant overhead despite its lightweight heap trace generation.
however such overhead is adequate in that the applications spend a considerable amount of the entire execution time for memory allocation deallocation.
in fact prior work causes much more overhead for the same applications.
on average sniper s execution time overhead is for the allocation intensive applications.
sniper can lead to performance degradation for three reasons.
first those applications are allocation and deallocation intensive.
thus sniper perturbs the application execution for a moment in order to store the meta data which is necessary to leave malloc free trace for each malloc free invocation.
second they create many small heap objects thus the meta data can become much larger than the the original size of the objects.
as a result the applications can cause more traffic to caches and tlbs.
finally such many allocations deallocation requests quickly make the trace buffers full.
thus the file write operation to flush the buffers also occurs relatively frequently.
.
runtime overhead of parallel benchmarks to evaluate the execution time overhead for parallel applications we chose parsec benchmark suite whose applications are heavily multithreaded and written in c c .
since the parsec applications run in parallel on multiple cores this section focuses on sniper s influence on the scalability of the original applications.
figure represents how sniper affects the scalability of the multithreaded applications as the number of threads increases.
the solid line corresponds to a speedup of a baseline execution without sniper while the dashed line to a speedup of the execution with sniper enabled.
overall sniper does not hurt the scalability of the applications.
the main reason for this is that sniper lets multiple threads have thread private buffers and file pointers to dump the buffers for efficient trace collection.
in this way sniper cannot only reduce contention to the buffers but also can exploit lockless file operations.
on average when the number of threads used is and sniper s execution time overhead is .
.
.
and .
respectively.
.
accuracy analysis with leak injection to evaluate the leak detection accuracy of sniper there is a need of a good set of applications containing various memory leaks.
with which the detection accuracy is measured and compared.
however there is no such standard applications to the best of our knowledge.
this work therefore creates leak benchmarks stress tested with the synthetic leak injection.
we inject two types of leaks i.e dynamic and static leaks into c c spec2006 applications5.
in real world applications memory leaks often times manifest only in certain program contexts e.g.
specific procedure calling sequence or malicious user input patterns .
to model this kind of memory leaks called dynamic leaks we first run the original spec2006 applications with sniper to collect the free traces and then randomly remove of deallocations from the traces.
on the other hand leaks sometimes occur irrespective of the contexts called static leaks e.g.
every object created in a single allocation site is leaking.
even if such leaks are relatively rare in deployed software due to extensive in house testing they become a serious problem whenever they occur.
that is because every created object gets lost and never reaches any deallocation site thereby leading to memory bloat.
to model this scenario we first pick the allocation site which is responsible for closest to of the entire allocations and then remove deallocations of the objects created from the site.
as metrics to evaluate the leak detection accuracy we use precision recall f measure that are commonly used to measure the quality of classifiers in the information retrieval community.
intuitively high precision leads to less false positives falsely blamed leaks while high recall to less false negative undetected leaks and the f measure is the harmonic mean of precision and recall which focuses on the balance between the other two metrics.
we test the ad hoc approach i.e.
using manual threshold used in prior tools and compare its accuracy to that of sniper approach which automatically selects the threshold using anomaly detection.
recall that due the lack of the systematic methodology prior tools end up using a fixed threshold across applications.
to model the ad hoc approach by selecting the appropriate threshold we first try candidates forming arithmetic series among which the smallest value results in no false negative while the largest in no false positive.
then we select a value with the best f measure as the threshold.
5the experiment omits mcf sjeng lbmsince these applications allocate very few objects i.e.
their results tend to be misleading.
812345speedup number of coresbaseline sniper a blackscholes 812345speedup number of coresbaseline sniper b bodytrack 8123speedup number of coresbaseline sniper c canneal 81speedup number of coresbaseline sniper d dedup 81234speedup number of coresbaseline sniper e facesim 812345speedup number of coresbaseline sniper f fluidanimate 812345678910speedup number of coresbaseline sniper g freqmine 81speedup number of coresbaseline sniper h raytrace 812345speedup number of coresbaseline sniper i streamcluster 81234567speedup number of coresbaseline sniper j swaptions 81234567speedup number of coresbaseline sniper k vips 81234567speedup number of coresbaseline sniper l x264 figure scalability of parsec parallel benchmark applications with and without sniper .
.
.
.
perlbench bzip2 gcc milc gromacs namd gobmk dealii soplex povray hmmer libquantum h264ref omnetpp astar sphinx3 xalancbmk geo meanprecisionad hocsniper hybrid ideal hybrid .
.
.
.
perlbench bzip2 gcc milc gromacs namd gobmk dealii soplex povray hmmer libquantum h264ref omnetpp astar sphinx3 xalancbmk geo meanrecallad hocsniper hybrid ideal hybrid figure precision recall of different leak detection approaches.
sniper is shown in the second bar i.e.
sniper hybrid thus the real ad hoc approach may perform worse than what we model here.
in particular to quantify and verify the effectiveness of sniper s heuristic for the hybrid anomaly detection see section .
.
we implement an ideal hybrid approach based on oracle information.
that is the ideal approach called ideal hybrid always selects the best between the global and local leak detection schemes.
figure compares precision recall of different leak detection approaches ad hoc the manual approach of prior work sniper hybrid sniper s leak identification based on the hybrid anomaly detection ideal hybrid the ideal version of sniper based on the oracle information.
for most applications hybrid outperforms ad hoc .
this is due to sniper s application tailored leak identification strategy.
sniper hybrid works comparably in namd omnetpp sphinx3 .
and it is less accurate than ad hoc only in gromacs .
inperlbench bzip2 gccandgobmk ad hoc does not work at all and the results translates to its low average of precision recall.
on the contrary sniper hybrid can fit itself into each problem instance by examining underlying staleness distributions and never has a case where it fails to detect all the presence of leaks.
ingromacs andastar sniper hybrid fails to detect static leaks which are supposed to be caught by the global anomaly detection scheme see section .
.
thus resulting in low recall.
however it .
.
.
.
.
.
.
.
.
libquantum h264ref astar perlbenchf measureglobal local sniper hybrid ideal hybridfigure the impact of the hybrid anomaly detection.
sniper s f measure is shown in the third bar i.e.
sniper hybrid turns out that the global detection could not detect the static leaks either.
the reason for this is that in gromacs of allocations end up with leaks due to the leak injection.
because of such a large number the leaks do not look like anomalies to the global detection i.e.
it cannot distinguish leaks from innocent objects.
similarly astar hasstatic leaks too thus sniper hybrid suffers from the same problem.
as an exception it achieves low precision and recall in namd .
that is because the stalenesses of innocent objects and leaks innamd are so severely overlapped that it cannot accurately separate leaks even with its allocation site specific local detection scheme.
note that sniper hybrid is near optimal for most applications i.e.
it is as accurate as ideal hybrid it turns out that most of the time sniper s heuristic for the hybrid anomaly detection correctly selects the best between the local and global detection schemes.
there are four exceptions namd soplex sphinx3 xalancbmk for which sniper hybrid is either too conservative or too aggressive.
for namd sniper hybrid is too conservative due to the severe overlap in the application while it is too aggressive for the rest of them.
overall sniper hybrid is very accurate its precision and recall are .
and .
respectively and the resulting f measure is .
.
one reason for the high accuracy of sniper hybrid is that its heuristic for the hybrid anomaly detection successfully selects the best between the local and global detection schemes.
figure shows the f measure of each scheme and highlights how sniperhybrid behaves when either the local detection scheme local or the global scheme global works better than the other.
in libquantum andh264ref global outperforms local .
that is because these applications have relatively many static leaks for which local is destined to fail.
here even the local detection reports no anomaly sniper hybrid detects the leaks by correctly switching to the global detection.832figure stalenesses spectrum of objects in perlbench .
.
.
.
.
.
sampling periodsprecision sniper ideal sniper hybrid figure impact of sampling period change on false positives on the other hand local outperforms global forastar andperlbench .
in particular they have relatively many dynamic leaks which are supposed to be caught by the local anomaly detection scheme section .
.
.
as a result the applications show considerable overlap in the stalenesses ofdynamic leaks and innocent objects which prevents the global scheme from detecting the leaks.
that is why global achieves the low accuracy for the applications.
in contrast the local detection scheme can solve this problem with the help of its allocation site based partitioning of objects.
figure displays four d scatter plots shown in a log scale demonstrating the benefit of such partitioning.
each point in the plot represents staleness of an object.
leaks are plotted in the upper part of the plot while innocent objects are plotted in the lower part.
as shown in figure a before partitioning there is huge overlap between stalenesses of leaks and innocent objects.
thus it is very difficult for global to recognize the leaks as anomalies.
however when the objects are partitioned according to their allocation sites the degree of overlap within each partition reduces considerably.
thus those objects of each partition become much more amenable to the anomaly detection.
to support this the rest of d scatter plots in figure i.e.
b c and d show three different allocation sites after partitioning.
here sniper hybrid makes a correct decision i.e.
adopting the local anomaly detection scheme.
overall sniper hybrid is comparable to ideal hybrid and thus performs better than both the local and global detection schemes.
comparing the impact of the local scheme only and the global scheme only it is clear that they have a constructive effect in sniperhybrid which is the combination of global andlocal .
that is sniper hybrid achieves better accuracy than either scheme can.
apart from that the fact that sniper hybrid achieves the optimal accuracy of ideal hybrid supports that sniper s hybrid leak identification is accurate and effective.
.
sensitivity to sampling frequency since sniper leverages the instruction sampling an unsampled access to heap objects causes their staleness to be overestimated thus possibly leading to false positives.
sniper should be robust against such false positives to be useful in production environment that might force the sampling period to be adjusted for the qos requirements.
figure shows the average precision of sniper on sampling period changes.
here the average precision is the geometric mean of theprecisions of c c spec2006 applications.
overall the precision change of sniper is not significant across different sampling periods.
for example when the period is i.e.
sniper observes a single access out of memory accesses seen by the pmu the resulting precision sniper hybrid is still high .
.
this is because even if the staleness overestimation due to the coarse sampling is inevitable sniper s anomaly based leak identification adapts itself to the resulting sample distribution of staleness .
in other words the automatic anomaly detection adjusts the thresholdappropriately to determine leaks.
in particular sniper hybrid is comparable to ideal hybrid across the sampling periods.
.
case study of real world memory leaks squid is a web caching proxy server.
it caches frequentlyrequested web pages and delivers the contents from its local cache upon request from many users clients thereby improving the response time and the network bandwidth.
squid has a memory leak which could potentially be used by malicious attackers to crash the program or cause some system failure i.e.
denial of service.
the root cause of the problem is that invalid http requests with an empty url trigger a control path in which the memory allocated to serve the request will not be deallocated.
to reproduce the leak we ran squid for several hours requesting many valid web site addresses along with the problematic url at a constant rate.
it turns out that sniper successfully detected the memory leak with no false positive.
in addition sniper found that based on its simulation outputs every non leaking object created for valid http requests has the same free site.
it was also found that all the objects including leaks have the same allocation site.
by simply checking the object counts and the free site the user can further recognize that most of the objects are not leaked e.g.
and freed in a single location.
then it would be a natural reaction for the user to attempt to deallocate the remaining leaking objects in the same location where all the non leaking objects of the entire objects are deallocated.
this is the exact solution to the leak problem of squid.
packet o matic is a multithreaded network packet analyzer.
it performs network forensics thus reading network packets and logging various information about the network connections.
it has a memory leak due to incorrect thread termination.
when the application reads an input file pcap capture file which generates the network traffic a new thread is created to process the file.
the problem is that even if each thread is supposed to joinat its termination i.e.
specified as joinable in the pthread create there is a case where it does not execute pthread join .
according to sniper the leaking objects are all allocated in the same function i.e.
pthread create .
that is they are a sort of threadlocal resources which should be returned to the system at the end of the thread execution such unredeemed objects accumulate as the application reads more input files.
here sniper s information of the last access to the objects can help the user find the appropriate location to put pthread join .
in fact the exact joining point was in the end of the pthread worker function.
in order to give users the context information such as the allocation site the pthread library was statically compiled in this experiment.
the alternative is to instrument the dynamic loader ld.so so that it can leave the information on where the pthread library is loaded in memory .
in particular sniper generated no false positive for this application.
usimm is an open source architecture simulator for memory scheduling .
it had severe a memory leak causing the simulator to eventually crash with an out of memory error when the simulation input was large.
the root cause of the leak is that memory requests already serviced are not deallocated even if they do not exist in the service queue any longer.
since there are billions of memory833requests being scheduled in the queue the simulation can eventually eat up all the available memory in the system.
sniper turns out to be very accurate with no false positive in detecting the memory leak in usimm.
note that in this case the last touch site information helps to figure out the cause of the leak.
sniper successfully reported the site where the memory requests are serviced.
for developers with a full understanding of how the simulator schedules the requests with the queue the site information motivates them to investigate the function of clearing the queue where free is supposed to exist to fix the leak.
.
related work path biased sampling chilimbi and hauswirth were the first who proposed the staleness based leak detection in their pioneering system called swat.
the staleness update relies on code instrumentation.
to reduce the overhead swat uses path biased sampling in tracking heap accesses.
it samples each program path at a different rate the sampling rate is in inverse proportion to the execution frequency.
that way swat can reduce the overhead since instructions on a hot path rarely get sampled.
however the sampling can result in overestimating the staleness of the objects in hot paths thus leading to false positives.
thus the effort to reduce the runtime overhead may end up undermining the quality of the leaks detection.
uniform sampling versus path biased sampling one might wonder which sampling is better.
the path biased sampling was invented to reduce overheads at the expense of hot path s precision.
thus only if the cold path hypothesis holds the path biased sampling is more precise than uniform sampling.
however there is doubt about the generality of the hypothesis.
as pointed out it does not hold for many cases e.g.
data structures suffering from memory bloat where the path biased sampling generates many false positives.
even if the hypothesis holds sniper is still robust against false positives.
that is sniper s anomaly detection effectively prevents unsampled objects from being falsely reported as a leak.
more importantly the path biased sampling is intrusive and memory consuming thus it cannot be used in production environment.
it does not make sense to spend much more memory to detect a memory leak in production environment.
page protection based sampling novark et al.
present hound that removes the heavyweight instrumentation for the staleness updates using a page level sampling .
the basic idea is to employ a memory protection mechanism of an os kernel to detect the accesses of the objects.
hound periodically protects every page and updates the last access time of all objects on the same page to theprotection time.
once a page fault occurs hound catches the signal and unprotects it for a performance reason here hound does not update the last access time of all objects on that page until it gets protected again.
that is actual staleness updates are always delayed to the protection time.
the resulting staleness is underestimated thus posing a risk of false negatives.
another cause of false negatives is that hound works at the granularity of a page it is possible that a page contains both live and dead objects and a single access to a live object can cause a reset to the staleness of dead objects in that page.
to mitigate that hound changes the underlying memory allocator to perform an age based segregation of the objects which can end up degrading the performance of the memory allocator.
nevertheless the page level false sharing can still occur depending on memory allocation patterns.
sniper versus swat hound there are key differences between swat hound and sniper.
first sniper is fully automated whereas others are not.
second sniper does not perturb the originalapplication execution.
in contrast swat inserts instrumentation code but also changes the original control flow for the path biased sampling.
hound changes the original memory allocator which is not acceptable in production runs due to the resulting allocation deallocation speed and heap size increase.
besides some applications are tightly coupled with the original memory allocator thus they may simply fail to run with a new allocator.
third sniper does not require any recompilation while swat relies on binary translation.
fourth sniper is more robust against false positives negatives due to its application tailored anomaly detection and its sampling operates at a much finer granularity compared to hound s page level sampling.
in particular even if those objects infrequently accessed are not sampled i.e.
their staleness is over estimated sniper is not likely to falsely report them as memory leaks with the help of its anomaly detection.
on the contrary swat hound are vulnerable to false positives negatives due to their ad hoc manual determination of the staleness threshold.
fifth sniper is detachable from an application for mission critical situations.
that way all the overheads due to sniper can be dynamically managed to meet the qos requirement of the application.
on the contrary the code transformed by swat permanently resides as a part of the application.
meanwhile the internal and external fragmentation caused by hound s memory allocator continuously affects the application performance.
finally sniper has much lower time and space overheads compared to swat hound.
their overheads particularly get worse for multithreaded applications that is why they can deal with only sequential applications.
in contrast sniper supports multithreaded applications with very low overhead.
.
conclusion memory leak detection in production environment is a critical step toward the qos enforcement and the reliability enhancement.
this work presents sniper an automated memory leak detection tool for production use.
its runtime overhead is negligible mostly and never increases the application s heap size.
sniper is also applicable to multithreaded applications without hurting the scalability.
thus sniper can be practically used in production environment and observe real execution characteristics in production runs thereby effectively detecting memory leaks which are inherently input and environment sensitive.
to the best of our knowledge sniper is the first to provide a systematic methodology for accurate leak identification.
sniper automatically determines the staleness threshold based on an anomaly detection.
as a result the leak identification is tailored not just for each application but for each allocation site as well thus sniper achieved an f measure of on average for benchmarks stresstested with various memory leaks.
we believe that our statistical methodology improves the accuracy of other leak detection approaches that leverage different sampling techniques.
in particular sniper is transparent unlike prior tools it does not change application behaviors by modifying the executable or replacing the original memory allocator.
the evaluation demonstrates that sniper is highly accurate in detecting critical memory leaks in real world software.
.