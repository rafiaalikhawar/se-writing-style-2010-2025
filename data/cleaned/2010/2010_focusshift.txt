focus shifting patterns of oss developers and their congruence with call graphs qi xuan y aaron okano premkumar t devanbu vladimir filkov qxuan adokano devanbu cs.
filkov cs.
ucdavis.edu department of computer science university of california davis ca usa ydepartment of automation zhejiang university of technology hangzhou china abstract developers in complex self organized open source projects often work on many di erent les and over time switch focus between them.
shifting focus can have impact on the software quality and productivity and is thus an important topic of investigation.
in this paper we study focus shifting patterns fsps of developers by comparing trace data from a dozen open source software oss projects of their longitudinal commit activities and le dependencies from the projects call graphs.
using information theoretic measures of network structure we nd that fairly complex focusshifting patterns emerge and fsps in the same project are more similar to each other.
we show that developers tend to shift focus along with rather than away from software dependency links described by the call graphs.
this tendency becomes weaker as either the interval between successive commits or the organizational distance between committed les i.e.
directory distance gets larger.
interestingly this tendency appears stronger with more productive developers.
we hope our study will initiate interest in further understanding of fsps which can ultimately help to improve current recommender systems to predict the next focus of developers and provide insight into better call graph design so as to facilitate developers work.
categories and subject descriptors d. .
metrics process metrics d. .
metrics complexity measures d. .
management productivity general terms theory measurement management keywords time series sequence analysis structural complexity layered network markov entropy permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse nov hong kong china copyright acm x xxxxx xx x xx xx ... .
.
.
introduction large software development projects are socio technical systems in which developer actions are governed both by the artifact and by the social interactions with co developers.
open source software oss projects are examples of large software development maintained by self organized groups of developers from around the world.
the complex dependencies between the large numbers of components make these projects challenging for developers to understand and explore as a whole and thus may have a signi cant e ect on both the e ciency of developers and the quality of the products .
while executing development tasks in large and complex software systems needed knowledge can typically only be found by navigating through many les .
these navigation patterns were found to be correlated with the effectiveness of developers to nish tasks .
the need for navigation arises from the inherent inter dependency of system components in addition to foraging for information developers often need to work on several les to complete a task shifting focus from one le to the other.
here our interest is in the focus shifting patterns fsps of developers i.e.
their dynamic work pattern as they shift focus among the di erent components of an oss project.
speci cally we ask what is the extent to which fsps are in agreement with the structure of the call graph?
and what relationships are there between developer productivity and their fsps?
focus is known to have an impact on software development.
more narrowly focused developers work on fewer speci c subsystems with less cognitive burden they introduce fewer defects while within a particular code change the increased number of subsystems that need to be touched also increases the risk of failure .
a strongly related concept emerging in the same area is code ownership i.e.
consistently lower ownership of a component has a negative impact on its code quality.
in general focus can be considered as an aggregated metric which is used to measure the commit distribution of a developer on a number of les.
it was proven that such entropy like metrics can provide valuable insights in the evolution of software systems and are valuable for predicting bugs .
however all these works are just based on the distribution of commit activities and none of them has studied the dynamic process of focus.
here we study focus shifting as a temporal process over a network of connected les where les are linked if they have been modi ed i.e.
committed to in succession by a developer.
as such these networks encode both the sequence of activities and the structure of repeated e orts.publicly available oss data sets record the social and commit activities of developers over a relatively long span of time providing us an excellent opportunity to quantitatively study fsp and its e ects on the code contributions of developers.
we describe fsps using time series analysis a much di erent approach from the static focus used in recent work to measure di erential attention of developers.
we make fsps speci c by de ning a focus shifting network fsn as a graph over the les present in all commits by a developer over a given time interval.
we build a le dependency network fdn for those same les based on the call graph links between functions in them.
then using layered network analysis we quantify the structural correlation between the fsn and fdn use information theory as well as the orthogonal decomposition to measure their complexities and adopt multiple linear regression mlr to reveal the e ects of fsp and other technical factors on the code contributions of developers.
by applying these methods to data from oss projects in the rest of this paper we nd that developers indeed tend to shift commit focus along the le dependencies.
there seems to be a negative relationship between the strength of this tendency and the directory distance between les.
we nd that developers in the same project have relatively similar fsps and those in di erent projects have relatively di erent fsps.
we relate fsps to productivity and show that more productive developers in terms of larger total lines of code added and deleted per day are more narrowly focused but shift focus more frequently between various les.
this is likely due to their broader responsibilities in the respective oss communities.
we also nd that more productive developers tend to contribute more to les that strongly depend on other les high out degree but less to les that are strongly depended upon high in degree .
.
related work network analysis in software system network analysis has been adopted very recently in software engineering to better understand the complex dependencies between different components.
several kinds of technical dependency networks were established including function call graphs and class collaboration graphs package dependency networks and software mirror graphs .
several structural properties of these dependency networks were adopted to build prediction models for defects and it was proven that such models are more accurate than those based only on code complexity.
for instance zimmermann and nagappan constructed dependency networks for binaries in windows server and found that central binaries with many neighbors and those in larger cliques tend to be more defect prone.
nguyen et al.
validated the above results in the oss eclipse project and showed that class level predictions are more signi cant in practice than package level predictions and the performance of network metrics decreases as they become less local.
herbsleb et al.
found that dependencies between developers or between software components slow down development but they don t signi cantly a ect productivity.
bird et al.
extended dependency networks to socio technical networks byintegrating developer contribution links.
they found that in windows vista and eclipse the network properties in such a combined network can be used to better predict defects than the methods that only use dependency or contribution information separately.
more recently cataldo and herbsleb studied the congruence between technical dependencies and coordinative actions in two large scale software projects and found that high socio technical congruence is associated with decreased software failures and increased development productivity.
on the other hand it was found that developers spend quite a large portion of their time navigating and e ective developers tend to investigate source code by following structural dependencies .
these ndings are echoed in several recommendation algorithms based on dependency networks to help developers quickly nd useful components.
however the empirical study of robillard et al.
was based on a relatively small number of developers.
in this study by utilizing a large oss data set we sought to validate and generalize those results in order to elucidate the factors in uencing the fsps of developers and to quantify fsp s relationship to developers code contribution.
structural complexity metrics in software engineering cyclomatic complexity cc is a popular structural complexity metrics de ned as the number of linearly independent paths between pieces of code and is used to measure the complexity of executing programs.
based on dependency networks several metrics for local structural complexity have also been proposed such as degree betweenness closeness and so on.
these metrics have been proven useful for predicting defects in large software.
mockus and weiss proposed several di usion metrics of code changes and found that increased di usion in terms of the larger numbers of touched les modules and subsystems increases the failure probability.
bird et al.
identied major minor dependency relationship in windows vista and windows i.e.
minor contributors to components are always major contributors to other dependent components and they found that these minor low expertise contribution do have a large impact on software quality removal of which largely decreases the performance of defect predictors.
rahman and devanbu studied the ownership in the context of implicated code that is modi ed to x a defect and found that implicated code is more strongly associated with a single than multiple developer s contribution.
most recently posnett et al.
introduced several ecological metrics to measure the focus of a developer which provides new insights for the structural complexity of the relationships between developers and software components.
they found that more narrowly focused developers tend to introduce fewer defects after controlling the number of commits and the number of touched les.
outside of software engineering song et al.
introduced several entropy metrics to measure the complexity of the mobility patterns of mobile phone users and found that human mobility is far more predictable than we think.
in this study we make an analogy between fsps in software and real world mobility patterns and will use these entropy metrics to measure the complexities of fsns and fdns.
.
research questions the development and maintenance of large software systems is complex often requiring considerable time for one tounderstand the system well enough to make correct changes .
following artifact dependencies in a forward or reverse manner is a common way to explore an unfamiliar software system and gain some understanding.
indeed a number of recommender systems which propose related components to developers for detailed exploration use dependency structures as the basis for their suggestions.
in addition modifying components without attending to dependencies can increase the risk of errors and often incidence of errors can be traced to dependencies .
all this leads to our rst question research question to what extent are developer focus shifting patterns following along the le dependency links in the call graphs?
social networks tend to be homophilic those with similar preferences and habits tend to associate and then further in uence each other s behavior .
in oss we would expect that this natural homophilic inclination together with the shared technical dependency structure of the software tends to push the focus shifting patterns of developers close together.
furthermore we expect that the di erent dependency structures of di erent systems would cause divergence between fsps of developers of di erent projects.
research question are the fsps of developers similar to each other in the same project while relatively di erent across projects?
developers arguably have a higher tendency to touch code already familiar to them and thus may centralize their attentions to respective highly coherent tasks in the same module or package rather than shift focus globally.
to study this we ask research question does the way les are organized into directories relate to fsps?
e ective developers are likely to investigate source code by following structural dependencies indicating that developers whose fsns are more strongly correlated with their fdns would tend to be more productive.
in addition active developers are likely to touch a large number of les in oss projects and they try to x bugs in time to preserve their reputation .
these may lead to complex fsps since bugs could be found anywhere at any time.
so we expected that the developers with more complex fsps are more active and thus may contribute more lines of codes.
on the other hand complex fsp imply frequent switching between different les bringing about a heavy cognitive burden which may decrease work e ciency.
this leads us to ask research question to what degree are the fsps of developers correlated with their code contributions in terms of loc day?
finally technical dependencies among parts of the code describe the information ow in a software system and thusmay have some impact on the coordination e ciency of developers and the quality of the product .
recently such dependencies were used to predict defects and select tests .
thus it is interesting to nd out research question how are speci c dependencies in the call graphs related to the fsps and to developer code contribution in terms of loc day?
.
methodology we collected the commits of developers in the git repositories1of oss projects from the apache software foundation on march 24th .
for each commit we record the developer id the commit time and the numbers of added and deleted lines of code.
date change rate of links figure the rate of link changes between every two sampled successive commits for axis2 java.
we used the doxygen tool to gather the call graphs for the java projects out of the .
for each project we randomly sample commits obtain the call graphs at those times and then integrate them as one i.e.
accumulate the weights of links for each pair of les.
we nd that the structures of the call graphs are relatively stable in these projects i.e.
the rate of link change between the common les in two commits is about per year on average.
take axis2 java for example.
we randomly sampled commits with the rst and last commits occurring on feb at and aug at respectively.
the rate of link change between every two sampled successive commits are shown in figure where we can see that the structure of the call graph changed relatively rapidly in the rst two years since it was created while it became much more stable as the project got mature i.e.
the rate of change is below per quarter after .
we only considered those commits to source les containing functions and we ltered the data as follows.
we remove the commits that modify more than les at a time since such commits likely consist of just copied or automatically generated les then we remove the developers with fewer than remaining commits and we only keep projects with at least such developers to get statistically meaning1note that some projects may use git mirrors of the apache subversion histories which will not in uence the following results since here we only consider the commit activities.ful results.
after this ltering we were left with projects2 and a total of developers.
we limit our focus on .java source les that have at least one function.
for each project that is our le set f. .
fsn and fdn layered networks we use and correlate two types of graphs for each developer one that captures their technical work activities and the other that describes the call graph le dependencies of the les in those work activities.
from the commit data we assemble a network for each developer that captures their fsp over the set of les that they have ever committed to.
a focus shifting network fsn for a developer dis a weighted directed graph over all the les fito whichdhas ever committed.
fiandfjare connected by an edge if they have been committed to by the developer in successive times with the edge pointing from the earlier commit le to the later.
we call those edges focus shifting links.
the weight wijis a sum of the contributions from every two successive commits in a given time interval such that the rst commit includes le fiand the second fj.
since multiple les may be involved per commit3 two successive commits may contribute to the weights of many links.
to normalize for this each weight contribution is divided by the numbers of les in these two successive commits and then summed to one.
in particular if ftandft 1are the sets of les committed to at successive times by a developer the time interval between them and fi2ftandfj2ft then the added weight on edge fi fj for that pair of commits is wij jftjjft 1jexp where the exponential decay term is introduced to discourage the focus shifting through long intervals and is the time window e.g.
smaller leads to emphasis of focus shifting within shorter intervals and we treat the focus shifting through di erent length of intervals equally when !
.
j jis the set cardinality.
from the call graph data for the same set of les as in the fsn we assemble a network for each developer that captures the artifact dependencies.
a le dependency network fdn for a developerdis a weighted directed graph over all the les fi to whichdhas ever committed.
an edge from fitofj means there is at least one function in ficalling a function infj.
we call these edges dependency links.
the weight of the edge is equal to the number of times that all functions in ficall those in fj.
in both fsn and fdn self links are allowed.
for each developer these two networks can be considered as layers in 2activemq ant axis2 java camel cassandra cayenne cxf derby hive lucene ode openejb solr wicket and xerces2 .
3in practice developers may submit all at once the changes they have done to a number of di erent les.
thus the commit time for those changes will be the same in our data.a two layer network since they are over the same set of les.
in this layered network each pair of les can thus be either connected by both shift and dependency links only one of them or disconnected.
given an fsn and an fdn we next describe how to calculate their congruence or agreement.
let w be the set of weights of the fsn edges that are also in the fdn regardless of edge directions and w be the set of weights of fsn edges that are not in the fdn.
for a particular time window we then de ne the congruence or agreement of fsn on fdn as that fraction of the average weights that is in agreement in the two networks4 cong hw i hw i hw i cong achieves values between and and is higher when the networks are in better agreement.
we will use the congruence to characterize each developer s tendency of shifting focus along the dependency links.
.
measures of network structure we sought to model developer behavior in terms of the connectivity of their fsn and fdn.
from the fsn we would like to measure the uncertainty in a developer s focus shifting behavior.
in the fdn on the other hand we want to measure the unevenness of the dependencies among a neighborhood of les.
those measures would serve as the structural predictors in our models.
here we adopt an information theoretic approach due to its appropriateness for capturing frequent vs infrequent patterns over time.
following the approach of song et al.
who proposed three types of entropy to measure the complexity of human mobility patterns we measure the complexity of a developer s patterns as they shift focus from one le to another as follows.
if a developer has already committed to a total of n les and no other information is known then it stands to reason that a developer will focus on any of these les with equal probability at any time step.
such uncertainty can be measured by random entropy er log2n which is intuitive since the uncertainty will certainly increase with the network size.
in this case both the fsn and fdn of the same developer will have the same complexity er.
in reality developers rarely contribute to di erent les uniformly e.g.
they tend to spend much more time on their own les than those of others.
in this case the next focus of a developer can be better predicted by utilizing the historical distribution of his commits on di erent les i.e.
a developer is more likely to commit to those les that have been committed to by himself many times consistent with the idea of ownership .
particularly suppose the developer has committed nitimes to le fi then the probability that the developer commits to this le at the next time step is pi nipn j 1nj 4cataldo et al.
used a similar metric to measure social technical congruence between coordination requirements and coordination activities in a revision for multiple developers.
in contrast here we investigate the relationships between code changes in successive revisions per developer.
a b source sink figure a source a and a sink b node.
which forms the basis for measuring uncorrelated entropy eu nx i 1pilog2pi we note that eu erand thateuis maximized only whenpi n i n indicating that prediction always bene ts from more information.
e.g.
compared to the random case here we also know the historical distribution of commits on di erent les.
for the fdn we only need change the de nition of niso thatnimeans the number of functions in le fi as we treat all functions equally.
since it is based on time series of commits the fsn provides even more information about the focus shifting behavior of a developer leading to better prediction.
if wijis the weight of the link from le fito lefj then the conditional probability that the developer shifts focus from fitofjis p jji wijp k2 iwik where iis the outgoing neighbor set of fiin the fsn.
if we consider focus shifting as a markov process that the next focus is totally determined by the current one we can de ne the markov entropy as em nx i pix j2 ip jji log2p jji intuitively eq.
says that the current commit behavior of a developer provides information for the location of his next commit.
similarly em eu andemis maximized when the next focus is independent from the current one.
for the fdn the markov entropy can be calculated by rede ningwijas the weight of the directed dependency link fromfitofj i.e.
the number of times that the functions in leficall those in le fj.
we call it forward markov entropy denoted by ef m. since developers may also shift focus in the opposite direction of the dependency link we also de ne a backward markov entropy denoted by eb m for the fdn.
in this case wijin eq.
is de ned as the weight of the directed dependency link from fjtofi.ef mandeb mmight be quite di erent for the same fdn.
for example the source node in figure a contributes to ef m log24 but it contributes to eb m while the sink node in figure b contributes to ef m but it contributes .
to eb m. we use all three of these entropies rather than any single one to measure the complexities of the fsn and fdn in a comprehensive way.
additionally that increase the robustness of our results to the entropies correlation with network size.
in addition we don t consider le size when calculating the entropies to avoid the trivial overlap between the fsp metrics and developer productivity.
.
multiple linear regression and orthogonal decomposition we sought out to use multiple linear regression mlr to model developer productivity against the above measures of complexity.
however the three types of proposed entropy are all strongly correlated with the network size n i.e.
they are not independent from each other and thus are not suitable to be considered together as predictors in the same mlr model.
we transform them by eliminating their dependency on n using orthogonal decomposition5 .
based on the relationship em eu er log2n and considering all developers together we de correlate the vectors euandemfrom er to get network size uncorrelated complexities pandq respectively.
we centralize these vectors rst and solve the following for pandq.
eu aer p em ber cp q subject to the constraint that the inner products her pi her qi andhp qiall equal to zero.
from eq.
we get heu eri akerk2 substituting afrom eq.
into into eq.
we get p eu heu eri kerk2er similarly from eq.
we have q em hem eri kerk2er hem pi kpk2p we refer to pas the distributional complexity .
in the fsn it captures the global heterogeneity of the commit distribution it is maximized if the developer is focused on all les equally and minimized if he is focused on one of them.
we refer to qas the structural complexity which in turn captures the local heterogeneity of the commit distribution it is minimized if the developer s next focus can be exactly predicted given his current focus.
the explanations for the fdn are quite similar except that there are two structural complexities qfforef m andqbforeb m. .
results and discussion .
rq1 shifting focus along call links we think of focus shifting here as a collective phenomenon.
whereas the behavior of an individual developer might look random signi cant phenomena may emerge by considering all developers together due to the latent software structure6.
to investigate the degree to which the focus shifting behavior of developers are aligned with their fdn we rst integrate the fsns of all developers by summing all the weights of directed links between the same pair of nodes and get the corresponding fdns in a project.
then we calculate the congruence between the overall fsn and fdn.
we nd that developers indeed tend to shift their focus from one le to another along fdn links the weights of fsn links between pairs of les also connected in fdn w 5alternatively principal component analysis pca could be used to extract linearly uncorrelated features.
however those new features may be di cult to interpret.
6we consider developer fsn and fdn congruence in rq .are on average about times larger with the signi cance p than those of fsn linked les that are not linked in fdn w for any project and over di erent time windows.
in other words when a developer commits to a le fiat one time with a much higher probability he will commit at the next time step to le fjthat is dependent on fiin the call graph than to a le fkthat is not.
inf0.
.
.
.
.
.
.
.
day cong figure the relationship between the fsn fdn congruence and time window .
by considering all projects together the relationship between the congruence cong of fsn and fdn as calculated by eq.
and the time window is shown in figure .
we can see that the congruence decreases exponentially as the time window increases from one hour to one week indicating that developers are more likely to shift focus along fdn links when the interval between the commits is shorter.
this is reasonable considering that developers tend to nish the same or related tasks in several successive compact commits while after relatively long breaks they tend to initialize new tasks which may be unrelated to the preceding ones.
note that the congruence of fsn on fdn doesn t decay to rather it is always larger than .
even when !
since long intervals between successive activities are rarer than short intervals.
we then calculate the pearson correlation7between the weights of the links in common between the overall fsn and fdn and nd a signi cant positive correlation p in both directions same and opposite see section with coe cient equal to .
and .
respectively on average for all projects when the time window is set to day .
note that when the self links are excluded the positive correlation is still signi cant for out of projects in at least one direction.
while relatively weak the positive correlations between the overall fsn and fdn in most projects are stable for time windows from one hour to in nity indicating that developers are more likely to shift focus along more strongly dependent les in the fdn.
the above results suggest that developers fsps indeed signi cantly correlate with their fdns answering rq in the positive .
the following speci c situations illustrate our results.
illustration inlucene the strongest one way link in the overall fdn is from testindexwriter.java toindexwriter.java with a total weight of .
meanwhile we also 7spearman correlation yields very similar results.
nd strong links between the two les in the overall fsn in both directions a weight of .
total times from testindexwriter.java toindexwriter.java and a weight of .
total times for the reverse when day .
illustration 28k.
a. hatlen id in derby added code to le drdaconnthread.java to provide a warning when a string is truncated sep .
in particular he added a conditional to the function buildsqlerrmc a couple of variables and conditionals to writefdodta along with modifying some function calls and also added an argument to writefdocaval and modi ed each call to that function correspondingly.
however he discovered later that the x introduced a bug when communicating with older clients and disabled the warning in that case.
at his next commit sep he added conditionals to the function writeldstring in le ddmwriter.java .
the git log commit message indicates that the modi ed writefdocaval calls to writeldstring introduced the bug.
this nding supports the design of focus recommender systems by following le dependency links in general it also indicates that two developers are likely to coordinate if the les committed by one are dependent on those committed by the other thus validating the studies of cataldo et al.
on socio technical congruence and expands our previous work on synchronous collaboration.
.
rq2 comparing fsps within and between projects developers in the same projects commit to the same les and in uence each other through various social means .
as a result they may have similar fsps.
in fact we indeed nd that the developers in the same projects have relatively more similar entropy either random uncorrelated or markov than those from di erent projects.
it may be argued that all the three types of entropy are related to network size and they are so such results may just mean that the developers in the same projects tend to touch a similar number of les.
next we show that the similarity between the fsp s in the same project is deeper than the number of les they ve touched.
we calculate the euclidean distances between the pairs of de correlated complexities p q for the fsns of developers within the same projects and between di erent projects and nd that the within project distances are signi cantly smaller p than the between project distances for a wide range of time windows from one hour to in nity.
this result indicates that developers fsps beyond the numbers of touched les recall that pandqare linearly uncorrelated with log2n are also similar within the same project while they are relatively di erent across di erent projects which positively answers rq .
this result is not trivial since developers in the same project may contribute to different parts of the project and they may have distinct commit habits resulting in di erent fsps.
it can be shown that this phenomenon partly arises from the overlap between the committed les of developers in the same projects.
we rank the les based on their commit times by a developer and select the top hof them with the most commits.
if the number of committed les of a developer is smaller than h we consider all of them.
then for a pair of developers in the same project if they committed to xsuch hoverlap figure the average overlap between the top h les most frequently committed to by two developers in the same projects.
common les we calculate the le overlap between them by overlap x min j dev 1j j dev 2j wherej dev 1j j dev 2jrepresent the respective number of top ranking les committed to by the two developers and both numbers are no more than h. then for di erent h we calculate the average overlap by considering all developers in the projects and the relationship between le overlap and hare shown in figure .
generally le overlap increases with h indicating that the more les the developers touched the heavier the overlap between them.
the average overlap is close to zero for extremely small h suggesting that developers focus on their own les which rarely overlap with other s. e.g when we consider the top les each developer has most committed to the average overlap between them is .
meaning that two developers committed to only one common le in this case.
while the relationships between le overlap and hin most projects follow the overall trend in figure hive seems to be an exception.
in this project the average overlap is .
whenh which is much larger than .
in the case of considering all the projects together.
this might be because hive is a relatively young project the rst commit occurred on sep lacking an e ective division of labor and thus most developers mainly focus on a number of common les.
the following example illustrates our reasoning.
illustration a pair of developers in hive committed to a maximum of eight common les ve of which form a connected fdn as shown in figure a where the link width is proportional to its weight.
the corresponding fsns of the two developers involving the ve les are shown in figure b and c where we can see that developer mainly contributed to le semanticanalyzer.java while developer mainly contributed to execdriver.java .
we observe strong self links for these two les in the respective fsns corresponding to the strong self links of these two les in the fdn.
we also nd relatively strong links between semanticanalyzer.java andhiveconf.java in the fsn and between execdriver.java andhiveconf.java in the fsn since both semanticanalyzer.java andexecdriver.java call functions in hiveconf.java as in the fdn.
this phenomenon is precisely con1015 hiveconf.java semanticanalyzer.java genmapredutils.java execdriver.java driver.java a fdn b fsn c fsn figure a pair of developers with ids and in hive committed to a maximum of eight common les when considering the respective top ten most frequently committed les.
five of these common les form a a connected fdn.
b and c the corresponding fsns of the two developers with the time window .
the link width is proportional to its weight and the le names are shown in the upper right corner.
sistent with bird et al.
s recent nding that a developer being a minor contributor to a component is partly because he she is a major contributor to a depending component .
both fsns seem to be positively correlated with the fdn thus it is not surprising to observe that the two developers have similar fsps i.e.
in this case the corresponding weights of the directed links in these two small fsns are also positively correlated with the pearson coe cient equal to .
p .
more interestingly we also nd strong links between semanticanalyzer.java andgenmapredutils.java in the two fsns although they don t directly depend on each other in the fdn.
we expected that these two les depend on the same part of the le hiveconf.java however while both of them indeed reference the same function in hiveconf.java the function has only two lines and doesn t change much over time.
these two les have relatively short directory distance equal to we thus attribute this phenomenon to other kinds of dependencies which are not discussed here and need to be validated in the future.
.
rq3 file organization and fsps the rationale for this approach is that les in the same java package have relatively shorter directory distance than those from di erent packages.
to see if fsp structure correlates with the les functional similarity we use le directorytable mlr for w the weight of link in fsn against the weight of link in fdn and its corresponding directory distance.
estimate std.
error z value pr jzj intercept .
.
.
2e wd .
.61e .
2e dir .
.
.
2e r squared .
adjusted .
rse .
distance9between two les as a proxy for their functional proximity similar to earlier work .
directory distance is the shortest path between two les in the le directory tree in which they reside.
we nd that while developers tend to shift focus through le dependency links they shift focus even more frequently if the two associated les have smaller directory distance indicating that the organization of les does in uence the fsps of developers.
when we consider all projects together and use the weight of links in fdn wd and its corresponding directory distance dir to linearly regress the weight of link in fsn w we get regression results shown in table when the time window is set to day .
the goodness of t including r squared adjusted r squared and residual standard error rse are also presented.
the results are similar for various time windows and show the signi cant negative impact of directory distance on the focus shifting weight although the r squared is relatively small here answering guardedly research question .
of note r squared is even smaller if we use just one of fwd dirgto build the regression model i.e.
.
for the model built on the weight of link in fdn and .
for that built on directory distance indicating their respective independent impacts on fsp.
regressing w in terms of a random re sampling of wdyields a non signi cant result and an r squared indicating that the above small e ect is very unlikely to be due to chance.
this nding suggests that putting highly dependent les into the same directory may slightly increase the probability of shifting focus along these dependencies and thus increase the congruence between fsn and fdn which may improve developer e ciency and decrease the risk of errors .
.
rq4 fsps and productivity even if most developers tend to shift their focus along dependency links some classes of developers may still behave di erently than others when navigating a complex software.
some studies have indicated that more e ective developers are more likely to investigate source code by following structural dependencies.
therefore it is expected that the congruence between fsn and fdn may have signi cant effects on the amount of code contribution of developers.
to assess that here for each developer we calculate the congruence between their fsn and fdn by eq.
.
then we use multiple linear regression mlr to model the code contribution of a developer in terms of loc day against the congruence cong while controlling for the number of commits c and the number of les per commit fpc.
the variance in ation factors for this model are all close to .
when we included the number of les committed to n to the model the vifs jumped to above indicative of the 9an alternative is to compare common name pre x length.table mlr for the loc day code contribution against the congruence cong between fsn and fdn while controlling for the number of commits c and the number of les per commit fpc.
estimate std.
error z value pr jzj intercept .
.
.
.
log2c .
.
.
.85e fpc .
.
.
.16e cong .
.
.
.
r squared .
adjusted .
rse .
correlation between nandc indicating using nwas not safe in this model we used cinstead ofnbecause that choice yielded a higher r squared model .
we logged the code contribution as well as the number of commits and the number of les to stabilize the variance and improve the model t. we do nd cong has a positive e ect on code contribution however it is not signi cant for relatively small time windows e.g.
day .
the signi cance is smaller than .
only when and is shown in table suggesting that the more productive developers are more likely to shift focus through fdn links consistent with the results in and answering rq .
this is reasonable since more productive developers tend to have fewer long breaks which enhances their tendency of shifting focus along fdn links as indicated by figure .
this result is further evidence of the bene t to investigating code along fdn links.
additionally we nd that the markov entropy of fsn is the best single predictor of code contribution out of the variables itself the number of commits the number of les committed to the number of les per commit and the uncorrelated entropy of fsn for the time window varying from one hour to in nity.
we use each of them alone to linearly regress the code contribution and the goodness of t is presented in table when the time window is set to day showing that the linear model established on the markov entropy em of fsn has the highest rsquared and adjusted r squared and the lowest rse.
in fact adding all variables in a single model does not yield a better performing model in terms of r squared than only usingem.
the relationship between the loc day code contribution of a developer and the markov entropy of the corresponding fsn can be well tted by the following linear model log2 loc day aem b with the parameters con dence bound equal to a .
.
andb .
.
for another answer to rq .
the linear relationship indicates that focus shifting of more productive developers in terms of larger loc day is less predictable.
arguably this is so since they tend to touch a larger numbers of les due to their broader responsibilities.
.
rq5 structural effects on productivity table goodness of t for loc day against r squared adjusted rse p value log2c .
.
.
.92e log2n .
.
.
.25e fpc .
.
.
.55e eu fsn .
.
.
.92e em fsn .
.
.
.2e 16table mlr for the code contribution against the distributional and structural complexities of fsn and fdn.
the time window is set to day .
estimate std.
error t value pr jtj intercept .
.
.
.
log2n .
.
.
2e p fsn .
.
.
.00e q fsn .
.
.
.61e p fdn .
.
.
.
qf fdn .
.
.
.
qb fdn .
.
.
.
r squared .
adjusted .
rse .
we already resolved that the three entropy measures are signi cantly correlated.
here we look into more speci c structural e ects on developers contributions once those correlations are removed.
the markov entropy of fsn can be decomposed into three uncorrelated parts using orthogonal decomposition the random entropy er log2n the distributional complexity p fsn and the structural complexityq fsn given by eq.
.
here we will use them as well as the three complexities of fdn p fdn qf fdn andqb fdn to build a higher resolution mlr model for the code contribution of a developer.
we logged the code contribution to stabilize the variance.
such a model can help to understand to what extent the complexities of focus shifting are correlated with developer s code contribution under the control of technical properties.
the model can also reveal technical e ects on code contribution given developers with the same level of focus shifting complexities.
we get independent variables with signi cance p for time windows from one hour to in nite while the forward structural complexity of fdn is signi cant p only when the time window day .
the regression results are shown in table when the time window is set to day .
since the number of variables is relatively large in this model we do some extra validations as follows we checked the magnitude of multicollinearity of the model by calculating the vifs and nd that vifs for all the variables are smaller than indicating that the multicollinearity is low we use bonferroni test to check outliers and don t nd any signi cant studentized residuals we also assess the model by using the global test and nd that the assumptions including global stat skewness kurtosis link function and heteroscedasticity are all acceptable.
these statistic results validate that the linear combination of the listed variables is feasible to explain the code contribution of a developer.
we learn the following from the mlr results.
after controlling for other variables the developers with a lower fsn distributional complexity and higher fsn structural complexity in terms of smaller p fsn and larger q fsn respectively contribute more lines of codes providing a more detailed answer for rq .
interestingly the developers with smaller distributional complexity can be referred as more narrowly focused and previous work indicates that such developers may also introduce fewer defects.
on the other hand after controlling for the fsp variables more productive developers tend to contribute to networks of les that have more heterogeneous distributionsof functions in terms of a smaller p fdn .
they are also more likely to contribute to the networks of les with higher forward structural complexity in terms of larger qf fdn signi cant only when the time window is relatively large but lower backward structural complexity in terms of smaller qb fdn indicating that they tend to contribute more to those les that strongly depend on other les but less to les that others strongly depend upon answering rq .
these results suggest a way to improve the productivity of developers by reorganizing functions into les so as to shape the fdn e.g.
increasing a le s dependence on other les may attract more code contribution from developers.
table the best model for each subset size by performing all subsets regression with the corresponding r squared also reported.
size intercept x x x x x x log2n x x x x x x p fsn x x x x q fsn x x x x x p fdn x x qf fdn x qb fdn x x x r squared .
.
.
.
.
.
we also perform all subsets regression using the regsubsets function from the leaps package in r. here we only report the best model for each subset size the number of variables as presented in table .
the distributional and structural complexities of fsn are always included in the best models when the subset size is larger than two indicating that fsp related properties are better predictors of the code contribution of a developer compared to the other technical properties.
the revealed technical e ects suggest that the code contribution of a developer may be in uenced by the local structure of the fdn i.e.
developers contribute more to les which are source nodes than those that are sink nodes shown in figure .
denote by outand inthe sum of weights of all outgoing and incoming links respectively for a le in the overall fdn of a project.
we consider a le a source node if out out in and a sink node if in out in with and out in .
then for various we get two groups of les as source nodes and sink nodes respectively and compare their loc changed per day.
we nd that developers indeed contribute more to les that serve as source nodes than those as sink nodes and the di erence between them is signi cant when and becomes even more signi cant as further increases as shown in figure answering rq .
such results are reasonable since developers tend to keep away from those les that other les strongly depend upon as commits to them may in uence the dependent les too.
it may also be because software development often makes use of common functions that are called by many others.
such functions are buses typically identi ed early in the design process and have well de ned stable interfaces .
illustration a good example of this is factory in the project derby .
for object oriented design a factory is an object which creates another object which is frequently called since the client always asks the factory for the new prod .
.
.
.
.
.
.
.
.
.
.
.
.
.
loc day source sink figure the box and whisker diagrams of the loc changes per day on source nodes the sink nodes in the fdn with various on the x axis where p p p p and p .
uct rather than create it directly using the constructor.
by adopting the factory pattern just like the oodesign website states10 the advantage is obvious new shapes can be added without changing a single line of code in the framework.
.
.
.
and there are certain factory implementations that allow adding new products without even modifying the factory class .
.
threats to validity there are a number of threats to this study.
first the data sets are collected from the same foundation and are all written in java.
the methods can be tested more broadly on more varied oss projects in the future.
we focused on le level fsps because les are an intermediary modeling level between classes methods and package.
in addition it allowed us to study the e ect of directory tree organization on fsps.
since the call relationships are actually at the class method level in the future our study can be re ned to class method level.
on the other hand a package level analysis may be used to investigate the e ect of package organization on fsp.
developers may change the name of a le in a relatively long time period of development for a project.
here we consider them as two di erent les.
such treatment may slightly in uence the structure of the fsns and fdns but we don t think it will signi cantly in uence our statistical results since renaming doesn t occur very frequently while these results are based on a large number of les.
we chose call relationships to establish fdns because they are widely used to capture software structure .
but there are other dependencies between les which may also in uence the fsp of a developer .
while our results stand on their own merit considering these other dependencies together with function calls will make for a more comprehensive study.
we also acknowledge that usingdoxygen to get a static call graph considers every possible run of a program and thus generally results in an 10oodesign factory pattern website since some call relationships that would never occur in actual runs of the program can also be included in our call graph.
removing these trivial dependencies is relatively di cult but may result in a more precise understanding of the network congruence.
there are di erent types of call relationships e.g.
illust.
shows a relationship between production code and its test code .
treating them separately and studying their different e ects on fsps is an interesting topic for the future.
we cannot observe fsps within a particular commit based on the current data sets.
in fact as we know the investigating trace of a developer within a particular commit is not recorded in any public repository.
since there is research indicating that e ective developers tend to investigate source code by following structural dependencies in a modi cation task it is reasonable to believe that the results could be similar when considering the fsp within each commit together in the future.
loc per day is an approximate measure of e ort and productivity.
alternative measurements e.g.
the development time of tasks and the number of defects may be better estimates for programmer e ciency or code quality.
using them may o er additional insight into the bene ts of the congruence between fsn and fdn.
however such measurements are relatively more di cult to obtain.
.
conclusions in this paper we studied the focus shifting patterns fsps of developers based on their commit activities in oss projects and made a dual contribution.
findings we found that developers tend to shift focus along le dependencies and this tendency is in uenced by the time interval between successive commits and the directory distance between committed les more productive developers tend to have stronger such tendency but have more complex fsps they are more likely to commit les that are strongly dependent on other les but less on les that other les depend upon.
methods we introduced layered network analysis which enables correlation analysis between di erent kinds of networked relationships which will be extremely useful as more diverse data are collected from di erent sources we proposed markov entropy to measure the focus shifting behavior of developers which will provide valuable insights for aggregating the metrics of time series data sets and we adopted the use of orthogonal decomposition which can improve the discerning power of linear models.
in the future more kinds of dependencies between les can be considered in the same framework to make the results more comprehensive the motif analysis method can be used to quantify the relationship between les in the same commit to asses if productive developers also tend to commit to dependent les at the same time and our developer behavior metrics can also be associated with metrics of code quality and e ciency of developers.
.