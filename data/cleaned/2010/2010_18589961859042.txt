jrf e using model checking to give advice on eliminating memory model related bugs kyunghee kim university of florida gainesville fl khkim cise.ufl.edutuba y avuz kahveci university of florida gainesville fl tyavuz cise.ufl.edubeverly a. sanders university of florida gainesville fl sanders cise.ufl.edu abstract according to java s relaxed memory model programs that contain data races need not be sequentially consistent.
executions that arenot sequentially consistent may exhibit surprising behavior such asoperations on a thread occurring in a different order than indicated by the source code or different threads having inconsistent views of updates of shared variables.
java racefinder jrf is an extensionof java pathfinder jpf a model checker for java bytecode.
jrfprecisely detects data races as defined by the memory model and can thus be used to verify sequential consistency.
we describe an extension to jrf jrf eliminator jrf e that analyzes information collected during model checking specifically counterexampletraces and acquiring histories and provides advice to the program mer on how to eliminate detected data races from a program.
if dataraces have been eliminated standard model checking and other ver ification techniques that implicitly assume sequential consistency can be soundly employed to verify additional properties.
categories and subject descriptors d. .
software program verification model checking d. .
concurrent programming general terms verification keywords data race memory model counterexample .
introduction virtually all approaches for reasoning about the behavior of concurrent programs both the informal reasoning practiced by programmers writing a concurrent program and formal methods and tools such as model checkers start with an assumption of sequential consistency sc .
with sc a concurrent program behaves as if all of its atomic actions occur in some global order that is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or co mmercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.ase september antwerp belgium.
copyright acm ... .
.consistent with the program orde r on each thread and thus that all threads have a consistent view of the way the memory has been updated.
in the past this was reasonable assumption and indeed one can find fairly recent concurrent programming textbooks that do not even mention memory models or sequential consistency.
however it is no longer appropriate for this issue to be ignored by programmers.
optimizations by compilers and hardware that significantly speed up programs without affecting their sequential semantics are not necessarily benign when executed on a mulitcore machine.
as an example consider the following program fragment.
computation done true the non volatile variable done is initially false and not accessed bycomputation which updates other variables.
since the two statements are independent the order could be reversed1without changing the sequential semantics.
however if this fragment occurs in a concurrent program and done is intended to be a signal to other threads that computation is finished then another thread finding done true may access state that reflects an incomplete execution of computation .
this scenario is legal according to java semantics but violates sc and the programmer s expectations.
exactly how threads interact with memory and how the programmer can control this is defined by a memory model .
traditionally memory models have been defined for hardware architectures and program behavior with respect to the memory model is constrained using low level operations such as fences and memory barriers.
more recently memory models have become part of a program ming language s semantics.
the java memory model jmm is an important example.
a situation that can lead to non scbehavior is called a data race .
a program that is free from data races will behave as if it is sc thus corresponding to programmer intuition and the implicit assumptions of model checkers and other tools.
in the example given above there is a data race between thewrite of variable done by the thread executing computation and another thread reading done which allows sc to be violated.
here the race could be eliminated by using the volatile keywordwhen declaring done .
the meaning of volatile will be described formally in section .
.
intuitively compilers must avoid certainoptimization and insert memory barriers around accesses to volatilevariables in order to prevent non sc behavior.
in previous work we have described java racefinder jrf an extension to the java pathfinder jpf model checking tool that detects data races as defined by the jmm precisely.
in most 1among other possibilities write buffers or holding values updated bycomputation in registers instead of writing to main memory could cause this effect.
other work on data race detection a data race is a situation where conflicting accesses2to shared variables are not ordered by synchronization sc is implicitly assumed and data races are of interest because they may indicate some sort of concurrency related bug e.g.
a forgotten lock.
in contrast we are interested in the specific notion of a data race given in the java memory model thatallows violations of sc.
in this paper we describe jrf e an extension to jrf that when a data race is detected attempts to diagnose the cause and provide advice to the programmer about how to modify the source codeto eliminate the race.
the tool analyses the counterexample tracewhich is provided as a result of model checking.
it also maintainsand analyzes the acquiring history which records information about how a variable involved in a data race has been accessed.
jrfe greatly simplifies the task of the programmer in detecting andeliminating data races in concurrent programs.
.
background in this section we give a brief and informal description of the jmm and the summary function hthat we use to detect data races.
we also describe java racefinder jrf our extension of jpf.
a more complete treatment can be found in .
.
the java memory model an execution of a java program is a set of memory model related actions read and write volatile read and write lock and unlock a monitor lock start a thread detect termination of a thread etc.
along with an order po which totally orders the actions on each thread and a synchronization order so that totally orders the synchronization actions.
in addition we have the value writtenfunction v that assigns a value to each write and the write seen function wthat assigns a write action to each read so that the value obtained by a read action risv w r .
the synchronization order so on an execution induces a partial order on synchronization actions called the synchronizes with order sw according to the following rules an unlock action on a monitor lock msynchronizes with all subsequent lock actions on mby any thread.
a write to a volatile variable vsynchronizes with all subsequent reads of v. the action of starting a thread synchronizes with the first action of the newly started thread.
the final action in a thread synchronizes with an action in any other thread e.g.
join or invoking the isalive method that detects the thread s termination.
the writing of default values of every object field synchronizes with the first access of the field.
in the descriptions above subsequent is determined by the synchronization order.
finally the happens before order hb is partial order on the actions in an execution obtained by taking the transitive closure of the union ofsw andpo .
well formedness constraints on executions include unsurprising requirements such as type correctness correct behavior of locks and consistency with the sequential semantics of the program.
in addition a well formed 2two operations by different threads conflict if they access the same memory location and at least one is a write.execution satisfies happens before consistency which requires that a read rof variable vis allowed to see the results of a write w w r provided that ris not ordered before w i .
e .
rhb w and there is no intervening write w primetov i .
e .
w prime whb w primehb r. well formedness still allows non determinism since normal actions on different threads need not be ordered.
also it is not required that the write seen function returns the most recent write to the variable in question or that the write seen functions for actions on different threads are consistent thus allowing sequentially inconsistent behavior3.
two operations conflict if neither is a synchronization action they access the same memory location and at leastone is a write.
a data race is defined to be a pair of conflicting operations notordered byhb .asequentially consistent sc execution is one where there is a total order sc on the actions consistent with po andso and where a read rof variable vsees the results of the most recent preceding write wsuch that wsc rand there is no intervening write w primetov i .
e .
w prime wsc w primesc r. a java program iscorrectly synchronized if all sequentially consistent executions are data race free.
it has been shown that any legal execu tion of a well formed correctly synchronized program appears to be sequentially consistent.
4this result justifies using a model checker to detect data races.
.
summarizinghb with h the function hsummarizeshb at each point in a sc execution allowing data races to be detected as they occur.
let addr be the set of abstract memory locations representing non volatile variables in the program synchaddr be the set of abstract memory locations representing variables with volatile semantics and locks and threads be the set of threads.
then h synchaddr threads 2addrmaps threads and synchronization variables to sets of nonvolatile variables so that x h t means that thread tcan read or write variable xwithout causing a data race.
for a finite sequentially consistent execution eof program p a set of static non volatile variables static p l e tenbe the prefix ofeof length n i.e.
the sequence of actions a0 a1 ... a n andhnbe the value of hafter performing all of the actions in en.
we assume that thread main is the single thread that initiates the program.
initially h0 z.ifz main thenstatic p else the way that hn 1is obtained from hndepends on the actionan.
first we define four auxiliary functions release acquire invalidate a n d new.
the function release t x takeshand yields a new summary function by updating h x to include the value ofh t .
it is used with actions by thread tthat correspond to the source of asw edge.
release t x h hatwide h the function acquire t x takeshand yields a new function by updating h t to include the value of h x .
it is used in actions that form the destination of asw edge.
acquire t x h hatwide h the function invalidate yields a new function by removing xfrom h z for all z negationslash t. it is used in actions where thread twrites non3legal executions are also required to satisfy additional causality conditions that constrain the behavior of programs with data races thus providing certain safety guarantees for program with races.
since our goal is to eliminate data races these conditions are not relevant here.
4jrf actually uses a slightly weaker but still sound notion of correct synchronization.
216volatile x. invalidate t x h hatwide z.if t z thenh z elseh z x the function newyields a new summary function by adding the set fields to the value of h t and initializing the previously undefined values of hfor the new volatile variables.
new t fields volatiles h hatwide z. if t z thenh t fields else if z volatiles then elseh z the definition of hn which depends on hnand action an i s given in figure .
anby thread t hn write a volatile field v release t v hn read a volatile field v acquire t v hn lock the lock variable lck acquire t lck hn unlock the lock variable lck release t lck hn start thread t prime release t t prime hn join thread t prime acquire t t prime hn t prime.isalive if t prime.isalive then acquire t t prime hn elsehn write a non volatile field x invalidate t x hn read a non volatile field x hn instantiate an object new t fields volatiles hn figure definition of hn to extend the model checker we maintain h and check that norace x t x h t holds before reading or writing non volatile xby thread t.w h e n this condition holds for all non volatile reads and writes in an execution the execution is h legal .
we have shown elsewhere that if all sc executions of a well formed program are h legal all of its legal executions are sc.
.
java racefinder java pathfinder jpf model checks java byte code by reading java class files and simulating their execution using its own virtual machine with on the fly verification of specified properties.
a property violation is reported by jpf along with a counterexample the execution path that led to the violation.
jpf provides a listener interface which we used to extend its functionality for jrf.
the interface provides a set of callback functions allowing low level operations such as object creation object locking and unlocking the start of a new thread and each execution of an instruction to be intercepted and augmented with usersupplied code.
jrf maintains a representation of the summaryfunction hdescribed in section .
the listener code intercepts relevant instructions and updates the representation as described infigure .
in addition the norace property which was defined in equation is checked prior to all non volatile reads and writes.
because everything including threads and locks are objects in java threads locks and variables are handled uniformly as memory lo cations in jrf additional information about the implementation including the data structures used for efficient implementation of hand the specialized search heuristics used during model checking can be found in .
jrf currently can handle all java language features related to the jmm except for finalizers.
.
counterexample analysis jrf inherits jpf s ability to provide the sequence of statements the counterexample path that leads to a data race.
this is extremely valuable information but it is a tedious job to parse the jrf output to determine the interleaving sequence of the threads and the reason why the data race has occurred.
jrf e adds ananalysis phase that analyzes the counterexample path and some ad ditional information gathered during model checking and provides the programmer with a concise diagnosis of the problem and suggestions for source code modifications to eliminate a race.
since a data race is defined to be the lack of a happens before edge jrf e can leverage the information in hto identify the statement containing the write involved in a data race which we call thesource statement a n dt h e manifest statement the read or write where the data race occurred i.e.
where the norace condition failed.
this information is then used to provide suggestions forways to eliminate the data race by creating a happens before relationship between those statements.
in addition to maintaining the hfunction jrf e also maintains the acquiring history .
the idea is to store the synchronization operation that enabled a thread tto access a memory location min a data race free way.
if accessing mby another thread t primeresults in a data race jrf e suggests that t primeperform the same synchronization operation that thread thas used before.
in any run of jrf e multiple races will be detected.
some of these may be manifestations of the same race i.e.
the race source and race manifest statements are the same occurring on different paths.
the analysis can be configured to stop when threshold number of data races have been detected or the whole state space is explored .
for each unique race jrf e generates a list of suggestions that will eliminate the data race on the corresponding execution paths.
a higher threshold may allow better suggestions to be provided at the cost of longer execution time.
a simple example will illustrate the practical benefits provided by jrf e. a java implementation of the program shown in figure was analyzed using jrf.
both xanddone are involved in races.
part of the output including the counterexample path for a data race involving xis shown in figure .
the omitted output gives similar results for additional more detected races.
g1 g17 g19 g23 g1 g26 g8 g1 g12 g20 g20 g18 g14 g11 g19 g1 g13 g20 g19 g14 g9 g15 g11 g18 g22 g14 g8 g1 g1 g1 g1 g1 g1 g1 g10 g16 g21 g14 g11 g13 g1 g5 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g10 g16 g21 g14 g11 g13 g1 g6 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g1 g1 g1 g1 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g1 g1 g1 g1 g1 g1 g22 g5 g7 g1 g26 g9 g5 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g23 g5 g7 g1 g25 g16 g17 g18 g14 g1 g3 g2 g13 g20 g19 g14 g4 g8 g1 g1 g1 g1 g22 g6 g7 g1 g13 g20 g19 g14 g9 g23 g21 g24 g14 g8 g1 g1 g1 g1 g1 g1 g1 g1 g23 g6 g7 g1 g11 g22 g22 g14 g21 g23 g1 g3 g26 g9 g9 g5 g4 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 figure thread notifies thread that xis set through flag done to understand what caused the detected race we need to decode the counterexample path given as trace .
clearly this is a tedious exercise even for this simple program where the length of the counterexample path is only six.
the path length may be several hundred in realistic examples.
in contrast figure showsthe output of the analysis produced by jrf e. for each unique racefound the race source statement the race manifest statement andsuggestions for code modifications that will eliminate that race are given.
note that the tool recognized that marking done as volatile is sufficient because of the transitivity of hb to also eliminate the race on x. g37 g42 g33 g1 g67 g55 g68 g70 g62 g69 g68 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g25 g1 g54 g51 g69 g51 g1 g67 g51 g53 g55 g1 g4 g14 g60 g67 g56 g11 g58 g52 g68 g55 g69 g11 g70 g69 g59 g62 g11 g35 g29 g31 g51 g69 g51 g42 g51 g53 g55 g32 g73 g53 g55 g66 g69 g59 g65 g64 g1 g51 g69 g1 g44 g35 g42 g32 g28 g31 g1 g1 g1 g1 g1 g1 g6 g68 g59 g63 g66 g62 g55 g11 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g5 g44 g58 g67 g55 g51 g54 g15 g27 g16 g13 g14 g1 g56 g67 g65 g63 g1 g3 g44 g58 g67 g55 g51 g54 g1 g69 g14 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g15 g6 g7 g24 g3 g1 g51 g69 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g18 g1 g59 g64 g1 g6 g63 g51 g59 g64 g7 g7 g1 g1 g69 g65 g1 g39 g32 g39 g41 g42 g46 g1 g1 g1 g1 g1 g1 g6 g68 g59 g63 g66 g62 g55 g11 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g73 g1 g56 g67 g65 g63 g1 g36 g40 g36 g44 g36 g28 g38 g36 g47 g32 g42 g7 g1 g1 g59 g64 g1 g36 g40 g43 g44 g42 g45 g30 g44 g36 g41 g40 g1 g6 g57 g55 g69 g68 g69 g51 g69 g59 g53 g7 g1 g65 g56 g1 g43 g41 g45 g42 g30 g32 g1 g1 g1 g1 g1 g1 g6 g3 g51 g68 g68 g55 g67 g69 g1 g6 g73 g25 g25 g14 g7 g24 g3 g1 g51 g69 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g20 g17 g7 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g1 g69 g67 g51 g53 g55 g1 g4 g14 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g13 g1 g69 g58 g67 g55 g51 g54 g23 g1 g13 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g26 g63 g51 g59 g64 g76 g1 g1 g1 g1 g1 g1 g48 g15 g19 g21 g21 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g17 g18 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g1 g1 g1 g1 g1 g1 g52 g65 g65 g62 g55 g51 g64 g1 g54 g65 g64 g55 g25 g56 g51 g62 g68 g55 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g17 g16 g1 g1 g1 g1 g1 g1 g23 g1 g66 g70 g52 g62 g59 g53 g1 g53 g62 g51 g68 g68 g1 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g1 g75 g1 g1 g1 g1 g1 g1 g48 g14 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g17 g1 g1 g1 g1 g1 g1 g23 g1 g44 g58 g67 g55 g51 g54 g1 g69 g13 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g14 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g13 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g53 g62 g51 g68 g68 g1 g44 g58 g67 g55 g51 g54 g14 g1 g55 g73 g69 g55 g64 g54 g68 g1 g44 g58 g67 g55 g51 g54 g1 g1 g1 g1 g1 g1 g48 g14 g21 g14 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g13 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g53 g62 g51 g68 g68 g1 g44 g58 g67 g55 g51 g54 g14 g1 g55 g73 g69 g55 g64 g54 g68 g1 g44 g58 g67 g55 g51 g54 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g17 g1 g1 g1 g1 g1 g1 g23 g1 g44 g58 g67 g55 g51 g54 g1 g69 g13 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g14 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g18 g1 g1 g1 g1 g1 g1 g23 g1 g44 g58 g67 g55 g51 g54 g1 g69 g14 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g15 g6 g7 g24 g1 g1 g1 g1 g1 g1 g48 g14 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g22 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g53 g62 g51 g68 g68 g1 g44 g58 g67 g55 g51 g54 g15 g1 g55 g73 g69 g55 g64 g54 g68 g1 g44 g58 g67 g55 g51 g54 g1 g1 g1 g1 g1 g1 g48 g14 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g18 g1 g1 g1 g1 g1 g1 g23 g1 g44 g58 g67 g55 g51 g54 g1 g69 g14 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g15 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g22 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g53 g62 g51 g68 g68 g1 g44 g58 g67 g55 g51 g54 g15 g1 g55 g73 g69 g55 g64 g54 g68 g1 g44 g58 g67 g55 g51 g54 g1 g1 g1 g1 g1 g1 g48 g14 g16 g17 g1 g59 g64 g68 g64 g1 g72 g12 g65 g1 g68 g65 g70 g67 g53 g55 g68 g49 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g22 g1 g1 g1 g1 g1 g1 g23 g1 g68 g69 g51 g69 g59 g53 g1 g53 g62 g51 g68 g68 g1 g44 g58 g67 g55 g51 g54 g15 g1 g55 g73 g69 g55 g64 g54 g68 g1 g44 g58 g67 g55 g51 g54 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g18 g1 g1 g1 g1 g1 g1 g23 g1 g44 g58 g67 g55 g51 g54 g1 g69 g14 g1 g25 g1 g64 g55 g72 g1 g44 g58 g67 g55 g51 g54 g15 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g19 g1 g1 g1 g1 g1 g1 g23 g1 g69 g13 g11 g68 g69 g51 g67 g69 g6 g7 g24 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g14 g1 g69 g58 g67 g55 g51 g54 g23 g1 g13 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g63 g51 g59 g64 g9 g26 g44 g58 g67 g55 g51 g54 g10 g13 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g19 g1 g1 g1 g1 g1 g1 g23 g1 g69 g13 g11 g68 g69 g51 g67 g69 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g20 g1 g1 g1 g1 g1 g1 g23 g1 g69 g14 g11 g68 g69 g51 g67 g69 g6 g7 g24 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g15 g1 g69 g58 g67 g55 g51 g54 g23 g1 g13 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g63 g51 g59 g64 g9 g44 g58 g67 g55 g51 g54 g10 g13 g9 g26 g44 g58 g67 g55 g51 g54 g10 g14 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g20 g1 g1 g1 g1 g1 g1 g23 g1 g69 g14 g11 g68 g69 g51 g67 g69 g6 g7 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g18 g21 g1 g1 g1 g1 g1 g1 g23 g1 g76 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g16 g1 g69 g58 g67 g55 g51 g54 g23 g1 g14 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g44 g58 g67 g55 g51 g54 g10 g13 g9 g26 g44 g58 g67 g55 g51 g54 g10 g14 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g17 g1 g1 g1 g1 g1 g1 g23 g1 g73 g1 g25 g1 g14 g24 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g17 g1 g69 g58 g67 g55 g51 g54 g23 g1 g14 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g44 g58 g67 g55 g51 g54 g10 g13 g9 g26 g44 g58 g67 g55 g51 g54 g10 g14 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g17 g1 g1 g1 g1 g1 g1 g23 g1 g73 g1 g25 g1 g14 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g18 g1 g1 g1 g1 g1 g1 g23 g1 g54 g65 g64 g55 g1 g25 g1 g69 g67 g70 g55 g24 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g18 g1 g69 g58 g67 g55 g51 g54 g23 g1 g14 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g44 g58 g67 g55 g51 g54 g10 g13 g9 g26 g44 g58 g67 g55 g51 g54 g10 g14 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g18 g1 g1 g1 g1 g1 g1 g23 g1 g54 g65 g64 g55 g1 g25 g1 g69 g67 g70 g55 g24 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g19 g19 g1 g1 g1 g1 g1 g1 g23 g1 g76 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g10 g1 g69 g67 g51 g64 g68 g59 g69 g59 g65 g64 g1 g4 g19 g1 g69 g58 g67 g55 g51 g54 g23 g1 g15 g57 g65 g71 g11 g64 g51 g68 g51 g11 g60 g66 g56 g11 g60 g71 g63 g11 g53 g58 g65 g59 g53 g55 g11 g44 g58 g67 g55 g51 g54 g30 g58 g65 g59 g53 g55 g33 g67 g65 g63 g43 g55 g69 g1 g75 g26 g44 g58 g67 g55 g51 g54 g10 g14 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g20 g16 g1 g1 g1 g1 g1 g1 g23 g1 g72 g58 g59 g62 g55 g6 g2 g54 g65 g64 g55 g7 g1 g75 g1 g12 g8 g68 g66 g59 g64 g8 g12 g1 g76 g1 g1 g68 g59 g63 g66 g62 g55 g12 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g20 g17 g1 g1 g1 g1 g1 g1 g23 g1 g51 g68 g68 g55 g67 g69 g1 g6 g73 g25 g25 g14 g7 g24 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g1 g68 g64 g51 g66 g68 g58 g65 g69 g1 g4 g14 g69 g58 g67 g55 g51 g54 g1 g59 g64 g54 g55 g73 g25 g15 g9 g64 g51 g63 g55 g25 g44 g58 g67 g55 g51 g54 g10 g14 g9 g68 g69 g51 g69 g70 g68 g25 g42 g45 g40 g40 g36 g40 g34 g9 g69 g58 g59 g68 g25 g68 g59 g63 g66 g62 g55 g11 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g5 g44 g58 g67 g55 g51 g54 g15 g27 g16 g13 g14 g9 g66 g67 g59 g65 g67 g59 g69 g74 g25 g18 g9 g62 g65 g53 g61 g30 g65 g70 g64 g69 g25 g13 g9 g68 g70 g68 g66 g55 g64 g54 g30 g65 g70 g64 g69 g25 g13 g1 g1 g53 g51 g62 g62 g1 g68 g69 g51 g53 g61 g23 g51 g69 g1 g68 g59 g63 g66 g62 g55 g11 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g5 g44 g58 g67 g55 g51 g54 g15 g11 g67 g70 g64 g6 g43 g59 g63 g66 g62 g55 g42 g51 g53 g55 g11 g60 g51 g71 g51 g23 g20 g17 g7 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g50 g1 g69 g67 g51 g53 g55 g1 g4 g15 g1 g11 g1 g11 g1 g11 g1 g6 g68 g59 g63 g59 g62 g51 g67 g1 g65 g70 g69 g66 g70 g69 g1 g56 g65 g67 g1 g21 g1 g51 g54 g54 g59 g69 g59 g65 g64 g51 g62 g1 g69 g67 g51 g53 g55 g68 g1 g65 g63 g59 g69 g69 g55 g54 g7 figure partial output from jrf for the program in figure .
eight similar traces have been omitted.
change a non array element variable to volatile or implement with an atomic class.
due to the semantics of volatile variables in java changing a variable involved in a race to volatile is always sufficient to eliminate a data race involving that variable.
since volatile variables inhibit compiler optimizations and accesses to volatiles incur runtime overhead the trivial way of eliminating races by making everythingvolatile is undesirable.
changing a variable to volatile likely to be the most appropriate in situations where this variable is being used for publication i.e.
making the reference to a new object instance visible to other threads .
unsafe publication is a common error in concurrent java programs written by programmers without a good understand ing of the jmm and can lead to a situation where another threadsees a partially initialized object.
another guaranteed solution is to replace the variable with a final 5reference to an instance of the atomic class corresponding to the variable s type in the java.util.concurrent.atomic package.
for example replace an int variable with an instance of thejava.util.concurrent.atomic.atomicinteger 5final fields must be set in the constructor cannot be modified and have special semantics in the jmm.
note that the value encapsulated in the atomic object can change just not the object itself.
g31 g35 g28 g8 g27 g1 g35 g27 g36 g38 g32 g37 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g1 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g4 g12 g52 g60 g48 g9 g50 g44 g61 g47 g62 g9 g63 g62 g51 g54 g9 g29 g24 g26 g43 g62 g43 g35 g43 g45 g47 g27 g66 g45 g47 g58 g62 g51 g57 g56 g1 g9 g1 g9 g1 g9 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g43 g56 g43 g54 g67 g68 g47 g1 g45 g57 g63 g56 g62 g47 g60 g1 g47 g66 g43 g55 g58 g54 g47 g1 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g61 g57 g63 g60 g45 g47 g1 g61 g62 g43 g62 g47 g55 g47 g56 g62 g1 g20 g1 g3 g58 g63 g62 g61 g62 g43 g62 g51 g45 g3 g1 g43 g62 g1 g61 g51 g55 g58 g54 g47 g10 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g52 g43 g64 g43 g20 g17 g15 g1 g1 g20 g1 g3 g66 g1 g22 g1 g12 g21 g3 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g55 g43 g56 g51 g48 g47 g61 g62 g1 g61 g62 g43 g62 g47 g55 g47 g56 g62 g1 g20 g1 g3 g49 g47 g62 g61 g62 g43 g62 g51 g45 g3 g1 g43 g62 g1 g61 g51 g55 g58 g54 g47 g10 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g52 g43 g64 g43 g20 g18 g15 g20 g1 g3 g43 g61 g61 g47 g60 g62 g1 g5 g66 g22 g22 g12 g6 g21 g3 g25 g50 g43 g56 g49 g47 g1 g62 g50 g47 g1 g48 g51 g47 g54 g46 g1 g3 g61 g51 g55 g58 g54 g47 g9 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g66 g1 g48 g60 g57 g55 g1 g30 g33 g30 g37 g30 g23 g32 g30 g39 g27 g35 g3 g1 g62 g57 g1 g64 g57 g54 g43 g62 g51 g54 g47 g9 g25 g50 g43 g56 g49 g47 g1 g62 g50 g47 g1 g48 g51 g47 g54 g46 g1 g3 g61 g51 g55 g58 g54 g47 g9 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g46 g57 g56 g47 g1 g48 g60 g57 g55 g1 g30 g33 g30 g37 g30 g23 g32 g30 g39 g27 g35 g3 g1 g62 g57 g1 g64 g57 g54 g43 g62 g51 g54 g47 g9 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g43 g46 g64 g51 g45 g47 g1 g48 g60 g57 g55 g1 g43 g45 g59 g63 g51 g60 g51 g56 g49 g1 g50 g51 g61 g62 g57 g60 g67 g33 g34 g33 g27 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g22 g1 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g4 g13 g52 g60 g48 g9 g50 g44 g61 g47 g62 g9 g63 g62 g51 g54 g9 g29 g24 g26 g43 g62 g43 g35 g43 g45 g47 g27 g66 g45 g47 g58 g62 g51 g57 g56 g1 g9 g1 g9 g1 g9 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g43 g56 g43 g54 g67 g68 g47 g1 g45 g57 g63 g56 g62 g47 g60 g1 g47 g66 g43 g55 g58 g54 g47 g1 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g61 g57 g63 g60 g45 g47 g1 g61 g62 g43 g62 g47 g55 g47 g56 g62 g1 g20 g1 g3 g58 g63 g62 g61 g62 g43 g62 g51 g45 g3 g1 g43 g62 g1 g61 g51 g55 g58 g54 g47 g10 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g52 g43 g64 g43 g20 g17 g16 g1 g1 g20 g1 g3 g46 g57 g56 g47 g1 g22 g1 g62 g60 g63 g47 g21 g3 g46 g43 g62 g43 g1 g60 g43 g45 g47 g1 g55 g43 g56 g51 g48 g47 g61 g62 g1 g61 g62 g43 g62 g47 g55 g47 g56 g62 g1 g20 g1 g3 g49 g47 g62 g61 g62 g43 g62 g51 g45 g3 g1 g43 g62 g1 g61 g51 g55 g58 g54 g47 g10 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g52 g43 g64 g43 g20 g18 g14 g20 g1 g3 g65 g50 g51 g54 g47 g5 g2 g46 g57 g56 g47 g6 g1 g69 g1 g10 g7 g61 g58 g51 g56 g7 g10 g1 g70 g3 g25 g50 g43 g56 g49 g47 g1 g62 g50 g47 g1 g48 g51 g47 g54 g46 g1 g3 g61 g51 g55 g58 g54 g47 g9 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g46 g57 g56 g47 g1 g48 g60 g57 g55 g1 g30 g33 g30 g37 g30 g23 g32 g30 g39 g27 g35 g3 g1 g62 g57 g1 g64 g57 g54 g43 g62 g51 g54 g47 g9 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g43 g46 g64 g51 g45 g47 g1 g48 g60 g57 g55 g1 g43 g45 g59 g63 g51 g60 g51 g56 g49 g1 g50 g51 g61 g62 g57 g60 g67 g33 g34 g33 g27 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g48 g60 g47 g59 g63 g47 g56 g45 g67 g1 g57 g48 g1 g43 g46 g64 g51 g45 g47 g40 g12 g62 g51 g55 g47 g61 g41 g1 g25 g50 g43 g56 g49 g47 g1 g62 g50 g47 g1 g48 g51 g47 g54 g46 g1 g3 g61 g51 g55 g58 g54 g47 g9 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g66 g1 g48 g60 g57 g55 g1 g30 g33 g30 g37 g30 g23 g32 g30 g39 g27 g35 g3 g1 g62 g57 g1 g64 g57 g54 g43 g62 g51 g54 g47 g9 g40 g13 g62 g51 g55 g47 g61 g41 g1 g25 g50 g43 g56 g49 g47 g1 g62 g50 g47 g1 g48 g51 g47 g54 g46 g1 g3 g61 g51 g55 g58 g54 g47 g9 g36 g51 g55 g58 g54 g47 g35 g43 g45 g47 g9 g46 g57 g56 g47 g1 g48 g60 g57 g55 g1 g30 g33 g30 g37 g30 g23 g32 g30 g39 g27 g35 g3 g1 g62 g57 g1 g64 g57 g54 g43 g62 g51 g54 g47 g9 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g42 g1 g61 g62 g43 g62 g51 g61 g62 g51 g45 g31 g35 g28 g1 g62 g43 g53 g47 g61 g1 g11 g20 g11 g20 g12 g1 g62 g57 g1 g48 g51 g56 g46 g1 g13 g1 g47 g59 g63 g51 g64 g43 g54 g47 g56 g62 g1 g60 g43 g45 g47 g61 g1 g65 g51 g62 g50 g1 g19 g1 g45 g57 g63 g56 g62 g47 g60 g47 g66 g43 g55 g58 g54 g47 g1 g62 g60 g43 g45 g47 g61 g9 g31 g35 g28 g8 g27 g1 g62 g43 g53 g47 g61 g1 g11 g20 g11 g20 g11 g1 g51 g56 g1 g19 g1 g60 g43 g45 g47 g61 g1 g43 g56 g43 g54 g67 g61 g51 g61 g9 figure jrf e output which explains the source of the race and suggests how to eliminate it class.
these classes are less convenient than volatiles because they must be accessed with get andset methods and are the better choice only if the lock free atomi c update methods they provide are needed.
these atomic update methods include compareandset which is frequently used in lock free algorithms and where appropriate for the type methods such as getandadd addandget getandincrement e t c .
change an array to an atomic array.
atomic arrays for various element types are provided int the java.util.concurrent.atomic package.
they provide volatile semantics for array elements and thus this change is always sufficient to eliminate data races involving array elements.
arrays are objects in java and a frequent error is to mark an array reference volatile without realizing that this does not provide volatile semantics for the accesses to the elements.
move source statement.
data races can sometimes be avoided by placing the source statement before a statement s1 that is the source of a happens before edge.
assume that the happens before edge is between s1and statement s2.
as long as the source statement and s1are executed by the same thread and hence ordered by happens before due to program order and similarly s2and the manifest statement are ordered by happens before the move creates a happens before edge between the source and the manifest statements due to transitivity of the happens before relation.
the algorithm in figure first calls the findhbedges algorithm in figure to compute all the happens before edges that result fromsynchronization actions on the counterexample path.
a happens before edge is a pair of instructions where the release instruction is the source vertex and the matching acquire instruction is the destination vertex.
instructions are identified by theirpositions on the counterexample path.
after having all pairs rep resenting the happens before edges on the counterexample path figure compares the source statement manifest statement pair racesourceindex racemanifestindex with all other pairs from the set of happens before edges.
if moving the source statement before a statement that is the source of a happens before edge and hasbeen executed before the source stat ement creates a happens before edge between the source statement and the manifest statement the move is suggested.
as an example consider the program in figure where goflag 218algorithm findhbedges pathinstr set of integer pairs stack pathinstr set of integer pairs hbedges forindexdest from size pathinstr to1do ifpathinstr indexdest is an acquire then forindexsource from indexdest to1do ifpathinstr indexsource is a release matching pathinstr indexdest then hbedges hbedges indexsource indexdest break return hbedges figure find the set of happens before edges through synchronization actions on path pathinstr .
algorithm makemovesourceinstructionsuggestions pathinstr racemanifestindex racesourceindex stack pathinstr integer racemanifestindex racesourceindex set of integer pairs hbedges findhbedges pathinstr foreach pair p i1 i2 hbedges do ifi1 racesourceindex and racesourceindex racemanifestindex intersects p and same thread executed pathinstr i1 and pathinstr racesourceindex andsame thread executed pathinstr i2 and pathinstr racemanifestindex then print move instruction at racesourceindex before i1 figure suggest moving instruction andpublish are shared variables.
since publish is a reference the object to which it refers can also be accessed by both threads.
thread creates an object at line s1which is currently accessible only by itself.
then it publishes the object by storing the reference in a shared variable publish at line s2.
the state of the object is updated at line s3and shared variable goflag is set to true at line s4declaring that object descriptor has been set and can safely be read by other threads.
thread checks whether publish is not null at line t1and if so spins until the global flag becomes true at linet2and reads the object descriptor in line t3.
figure shows part of the state space of the example in figure .
the data race can be eliminated by moving s4before s2as it creates a happens before edge between s4andt2 w h i c hf o l lows from the transitive property of the happens before relationship s4hb s2 s2hb t1 a n dt1hb t2implies s4hb t2.
use a synchronized block.
using consistent locking is one way of creating happens before edges between accesses to shared data.
using synchronized blocks is one way of implementing locking in java.
the algorithm in figure finds all the locks that are released after the source statement and before the manifest statement and suggests protecting the man ifest statement with these locks by referring to the specific sourcelines that performs the locking.
figure shows an example in which thread acquires a lock before accessing the shared data data whereas thread does not acquire any lock before accessing data .
figure shows the counterexample path that manifests the data race on data .a ts3 thread unlocks lock before the manifest statement t1.
the data 6since jpf is working at the bytecode level accessing a field potentially involves two bytecode instructions one to get a reference to the object and one to access the field.
g19 g29 g29 g27 g22 g18 g28 g1 g24 g29 g15 g27 g18 g24 g12 g36 g29 g27 g18 g34 g26 g27 g22 g1 g14 g18 g34 g18 g1 g30 g35 g19 g27 g26 g33 g25 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g17 g25 g32 g22 g18 g21 g1 g7 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g17 g25 g32 g22 g18 g21 g1 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g1 g1 g1 g1 g1 g1 g1 g1 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g13 g1 g1 g1 g1 g1 g33 g7 g11 g1 g1 g32 g1 g13 g1 g28 g22 g37 g1 g14 g18 g34 g18 g4 g5 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g34 g7 g11 g1 g26 g23 g1 g4 g30 g35 g19 g27 g26 g33 g25 g1 g2 g13 g1 g28 g35 g27 g27 g5 g1 g38 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g33 g8 g11 g1 g1 g30 g35 g19 g27 g26 g33 g25 g1 g13 g1 g32 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g34 g8 g11 g1 g1 g1 g1 g37 g25 g26 g27 g22 g1 g4 g2 g24 g29 g15 g27 g18 g24 g5 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g33 g9 g11 g1 g1 g32 g6 g33 g22 g34 g14 g22 g33 g20 g4 g3 g22 g3 g5 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g34 g9 g11 g1 g1 g1 g1 g16 g34 g32 g26 g28 g24 g1 g33 g1 g13 g1 g1 g30 g35 g19 g27 g26 g33 g25 g6 g24 g22 g34 g14 g22 g33 g20 g4 g5 g12 g1 g1 g1 g33 g10 g11 g1 g1 g24 g29 g15 g27 g18 g24 g1 g13 g1 g34 g32 g35 g22 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g34 g10 g11 g1 g1 g1 g1 g18 g33 g33 g22 g32 g34 g4 g33 g6 g22 g31 g35 g18 g27 g33 g4 g3 g22 g3 g5 g12 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g39 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 figure viagoflag thread notifies thread when object publish is ready to be used.
data racestate space r new data publish r goflag true if publish !
null s2 t1 s3 s4 s1 s2 s3 s4 t1 if publish !
null r new data publish r r.setdesc goflag true s1 while !goflag t2 r.setdesc data race source statementhappens before edge not ordered by happens before data race manifesting statement .
move goflag true before publish r1.
make goflag volatileways to prevent data race no data race figure part of the state space of the showing a data race free path and a path with a data race.
algorithm makeputinsynchronizedblocksuggestions pathinstr racesourceindex racemanifestindex stack pathinstr integer racesourceindex racemanifestindex set of instructionlocations syncloc forindex from size pathinstr toracesourceindex do ifpathinstr index is a monitorexit instruction or return instruction of a synchronized method then letlocdenote the source line for pathinstr index syncloc syncloc loc foreach source line loc syncloc do print put instruction pathinstr racemanifestindex in synchronized block as in line loc figure suggest a synchronized block.
g1 g20 g24 g29 g1 g17 g14 g29 g14 g10 g1 g36 g24 g14 g23 g1 g12 g15 g21 g18 g16 g29 g1 g23 g25 g16 g22 g11 g24 g18 g31 g1 g12 g15 g21 g18 g16 g29 g2 g3 g10 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g13 g19 g27 g18 g14 g17 g1 g6 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g13 g19 g27 g18 g14 g17 g1 g7 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g1 g1 g1 g1 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g11 g1 g1 g1 g1 g1 g1 g28 g6 g9 g1 g28 g32 g24 g16 g19 g27 g25 g24 g20 g33 g18 g17 g1 g2 g23 g25 g16 g22 g3 g1 g34 g1 g5 g4 g23 g25 g16 g22 g4 g5 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g29 g6 g9 g1 g26 g27 g20 g24 g29 g1 g2 g17 g14 g29 g14 g3 g10 g1 g1 g1 g1 g28 g7 g9 g1 g17 g14 g29 g14 g1 g11 g1 g6 g10 g1 g1 g28 g8 g9 g1 g35 g1 g5 g4 g30 g24 g23 g25 g16 g22 g4 g5 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 figure thread need to synchronize on lock to access data race can be eliminated by making thread acquire lock before t1.
change other memory locations to volatile or use atomic arrays.
one way of creating a happens before edge between the source and the manifest statement is to create a happens before edge between a pair of statements s1 s2 that come between the source and the manifest statement in the execution sequence i.e.
g13 g32 g15 g32 g19 g1 g31 g29 g15 g17 g19 g1 g31 g36 g27 g17 g22 g30 g28 g27 g23 g37 g19 g18 g2 g25 g28 g17 g24 g3 g1 g38 g6 g4 g25 g28 g17 g24 g4 g6 g1 g2 g31 g7 g3 g1 g18 g15 g32 g15 g12 g7 g11 g1 g1 g1 g2 g31 g8 g3 g1 g39 g1 g6 g4 g33 g27 g25 g28 g17 g24 g4 g6 g1 g1 g1 g2 g31 g9 g3 g1 g29 g30 g23 g27 g32 g2 g18 g15 g32 g15 g3 g11 g1 g1 g1 g2 g32 g7 g3 g1 g2 g1 g2 g1 g2 g1 g5 g3 g8 g3 g1 g7 g3 g4 g6 g1 g14 g15 g36 g31 g1 g32 g28 g1 g29 g30 g19 g34 g19 g27 g32 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g10 g1 g7 g5 g1 g26 g15 g24 g19 g1 g18 g15 g32 g15 g1 g34 g28 g25 g15 g32 g23 g25 g19 g1 g8 g5 g1 g31 g36 g27 g17 g22 g30 g28 g27 g23 g37 g19 g1 g28 g27 g1 g25 g28 g17 g24 g1 g16 g19 g20 g28 g30 g19 g1 g29 g30 g23 g27 g32 g2 g35 g3 g33 g27 g25 g28 g17 g24 g1 g28 g20 g1 g25 g28 g17 g24 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g26 g15 g27 g23 g20 g19 g31 g32 g23 g27 g21 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g31 g28 g33 g30 g17 g19 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g1 figure part of the state space with the unlock in between source and manifest statements source ... s s2 ... manifest .
for this to work we need sourcehb s1ands2hb manifest .
if our program modifications establish s1hb s2 then by the transitivity of the happens before relation we will have sourcehb manifest .
algorithm ishappensbeforeordered sourceindex destindex hbedges boolean integer sourceindex destindex set of integer pairs hbedges ifsourceindex anddestindex have same executing thread then return true if sourceindex destindex hbedges then return true foreach s1 s2 hbedges ifishappensbeforeordered sourceindex s1 hbedges and ishappensbeforeordered s2 destindex hbedges then return true return false algorithm makechangeothertovolatilesuggestions manifestindex sourceindex hbedges integer manifestindex sourceindex set of integer pairs hbedges for each write of vats1between sourceindex andmanifestindex do ifthere exists a read of vats2between s1andmanifestindex and ishappensbeforeordered sourceindex manifestindex hbedges s1 s2 then ifvis an array element then print use atomic array ... else print make vvolatile figure suggest changing a different memory locations to volatile ifs1ands2are the write and read of a variable v respectively then changing vto volatile creates a happens before edge between s1ands2.
figure shows the algorithm for checking the happens before relation and the algorithm for this type of suggestion using it.
figure shows another example with two threads sharing two variables done andx.
if jrf e is configured with threshold it is possible to find a counterexample that shows a data race manifested in statement t2as shown in figure .
it turns out that between the source statement s1 and the manifest statement t2 there is a write of done followed by read of done .s i n c e s1 ands2are executed by thread and t1andt2are executed by thread changing done to volatile creates a happens before edge between s1andt2and eliminates the data race.
in our experience suggestions from this class are often the most g2 g1 g2 g1 g2 g1 g13 g32 g15 g32 g19 g1 g31 g29 g15 g17 g19 g1 g36 g12 g8 g11 g1 g1 g1 g3 g31 g8 g4 g1 g18 g28 g27 g19 g12 g32 g30 g33 g19 g11 g1 g3 g31 g9 g4 g1 g35 g22 g23 g25 g19 g1 g3 g2 g18 g28 g27 g19 g4 g11 g1 g3 g32 g8 g4 g1 g15 g31 g31 g19 g30 g32 g1 g3 g36 g12 g12 g8 g4 g11 g1 g3 g32 g9 g4 g5 g3 g8 g3 g1 g7 g3 g4 g6 g1 g14 g15 g37 g31 g1 g32 g28 g1 g29 g30 g19 g34 g19 g27 g32 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g10 g1 g8 g7 g1 g26 g15 g24 g19 g1 g18 g28 g27 g19 g1 g34 g28 g25 g15 g32 g23 g25 g19 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g31 g28 g33 g30 g17 g19 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g1 g36 g12 g8 g11 g1 g1 g1 g3 g31 g8 g4 g1 g18 g28 g27 g19 g12 g32 g30 g33 g19 g11 g1 g3 g31 g9 g4 g1 g35 g22 g23 g25 g19 g1 g3 g2 g18 g28 g27 g19 g4 g11 g1 g3 g32 g8 g4 g1 g1 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g31 g28 g33 g30 g17 g19 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g26 g15 g27 g23 g20 g19 g31 g32 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g1 g26 g15 g27 g23 g20 g19 g31 g32 g1 g31 g32 g15 g32 g19 g26 g19 g27 g32 g1 g1 g5 g3 g8 g3 g1 g7 g3 g4 g6 g1 g14 g15 g37 g31 g1 g32 g28 g1 g29 g30 g19 g34 g19 g27 g32 g1 g18 g15 g32 g15 g1 g30 g15 g17 g19 g10 g1 g8 g7 g1 g26 g15 g24 g19 g1 g36 g1 g34 g28 g25 g15 g32 g23 g25 g19 g1 g9 g7 g1 g26 g15 g24 g19 g1 g18 g28 g27 g19 g1 g34 g28 g25 g15 g32 g23 g25 g19 g1 g35 g30 g23 g32 g19 g6 g30 g19 g15 g18 g1 g29 g15 g23 g30 g1 g1 g17 g15 g29 g15 g16 g25 g19 g1 g28 g20 g1 g28 g30 g18 g19 g30 g23 g27 g21 g1 g31 g8 g5 g1 g32 g9 g1 g1 figure part of the state space that change done to volatile can eliminate a race on x appropriate solution in lock free a lgorithms that e xhibit data races on multiple variables.
perform the same synchronization operation.
jrf e keeps track of the acquiring history to allow determination of how happens before edges were created for non racy accesses to a memory location.
formally we define the acquiring history as a function acquirehis addr synchaddr threads threads.f o r a memory location m v t acquirehis m means that at some point in the computation so far thread tperformed an operation on vthat resulted in mbeing added to h t .
the actions by thread tthat would result in v t being added to acquirehis m f o r somemcould be reading v locking v or joining v w h e r e vis a volatile field lock or thread respectively.
in contrast to the summary function h which only applies to a particular path the acquirehis is cumulative and contains information from all the explored paths.
figure finds out how previous accesses to the data race memory location m have been ordered by the happens before relation and suggests performing the same acquire operation.
three possible acquire operation choices are read lock a n djoin according to the type of memory location.
if the memory location is a field then it must be volatile an d the corresponding acquiring operation is to read it.
if the memory location is a lock the acquireoperation is to lock it.
when the memory location is a reference tothread joining it serves as an acquire.
algorithm makeperformsameacquiresuggestions acquirehis m mapping of memorylocation to set of threadid agentloc acquirehis memorylocation m loc foreach t loc acquirehistory do iflocis reference to thread andm h loc then print join thread locbefore manifest instruction else if locis a field then print read field locbefore manifest instruction else print lock the object locbefore manifest instruction figure suggest performing an acquire operation that can add the data race memory location to hof the manifesting thread.
the example in figure motivates the use of the acquiring history.
in execution sequence r1 r2 s1 s2 t1 as shown in figure there is a data race between r1 aw r i t eo f xby thread and t1 the read of xby thread .
thread also performs a read of xbut it does not result in a data race with thread because thread reads volatile done before reading xand this generates a happens before edge between the write of xby thread and the read of xby thread .
the acquiring history stores this information and jrf e uses it to suggest that thread reads volatile done before reading x to eliminate the data race.
g1 g17 g19 g24 g1 g27 g8 g1 g26 g20 g18 g11 g24 g17 g18 g14 g1 g12 g20 g20 g18 g14 g11 g19 g1 g13 g20 g19 g14 g9 g15 g11 g18 g23 g14 g8 g1 g1 g1 g1 g1 g1 g1 g10 g16 g22 g14 g11 g13 g1 g4 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g10 g16 g22 g14 g11 g13 g1 g5 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g10 g16 g22 g14 g11 g13 g1 g6 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g1 g1 g1 g1 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g9 g1 g1 g1 g1 g9 g9 g9 g9 g9 g9 g9 g9 g9 g1 g1 g1 g22 g4 g7 g1 g27 g1 g9 g1 g4 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g23 g4 g7 g1 g17 g15 g1 g2 g1 g13 g20 g19 g14 g1 g3 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g24 g4 g7 g1 g21 g22 g17 g19 g24 g2 g27 g3 g8 g1 g1 g22 g5 g7 g1 g13 g20 g19 g14 g1 g9 g1 g24 g22 g25 g14 g8 g1 g1 g1 g1 g1 g1 g1 g23 g5 g7 g1 g1 g1 g1 g11 g23 g23 g14 g22 g24 g1 g2 g27 g9 g9 g4 g3 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 figure acquiring history of thread shows thread can get race free access on xby reading done .
g11 g30 g13 g30 g17 g1 g29 g27 g13 g15 g17 g1 g33 g1 g10 g1 g6 g9 g1 g1 g2 g28 g6 g3 g1 g16 g26 g25 g17 g1 g10 g1 g30 g28 g31 g17 g9 g1 g2 g28 g7 g3 g1 g21 g18 g2 g16 g26 g25 g17 g3 g1 g2 g29 g6 g3 g1 g13 g29 g29 g17 g28 g30 g2 g33 g10 g10 g6 g3 g9 g1 g2 g29 g7 g3 g1 g27 g28 g21 g25 g30 g2 g33 g3 g9 g1 g2 g30 g6 g3 g1 g1 g1 g2 g1 g2 g1 g2 g1 g5 g3 g8 g3 g1 g7 g3 g4 g6 g1 g12 g13 g34 g29 g1 g30 g26 g1 g27 g28 g17 g32 g17 g25 g30 g1 g16 g13 g30 g13 g1 g28 g13 g15 g17 g8 g1 g6 g5 g1 g24 g13 g22 g17 g1 g33 g1 g32 g26 g23 g13 g30 g21 g23 g17 g1 g7 g5 g1 g28 g17 g13 g16 g1 g16 g26 g25 g17 g1 g14 g17 g18 g26 g28 g17 g1 g27 g28 g21 g25 g30 g2 g33 g3 g1 g1 g1 g20 g13 g27 g27 g17 g25 g29 g4 g14 g17 g18 g26 g28 g17 g1 g17 g16 g19 g17 g1 g16 g13 g30 g13 g1 g28 g13 g15 g17 g1 g24 g13 g25 g21 g18 g17 g29 g30 g21 g25 g19 g1 g29 g30 g13 g30 g17 g24 g17 g25 g30 g1 g1 g16 g13 g30 g13 g1 g28 g13 g15 g17 g1 g29 g26 g31 g28 g15 g17 g1 g29 g30 g13 g30 g17 g24 g17 g25 g30 g1 g1 g3 g4 g12 g16 g9 g13 g9 g10 g7 g1 g8 g9 g14 g15 g11 g13 g18 g1 g20 g17 g21 g1 g1 g1 g22 g1 g23 g1 g22 g1 g23 g1 g22 g20 g5 g11 g10 g6 g19 g2 g8 g13 g6 g3 g5 g24 g21 g23 g1 g22 g20 g5 g11 g10 g6 g19 g2 g8 g13 g6 g3 g5 g24 g21 g23 g1 g22 g20 g5 g11 g10 g6 g19 g2 g8 g13 g6 g3 g5 g24 g21 g23 g1 figure part of the state space with the acquiring history that guides how to eliminate the race the suggestions generated by the above algorithms are guaranteed to eliminate the data race on the path where the race was discovered.
the precision of the suggestions are improved by filter ing the set of suggestions to only include those that appear on all ofthe paths.
given the set of suggestions the programmer determines the best solution and implements it.
jrf e should then be rerun.
.
theoretical results in this section we prove that modifying the program according to the suggestions generated by our tool does not remove any happens before edges that existed before the modification.
specifically theorem and theorem show that this is the case for all execution paths considering changing a non volatile to volatile and adding a new synchronization action via putting in a synchronized block or following an acquiring history based suggestion respectively.
theorem shows a similar result for the move suggestiononly on the counter example path under certain conditions.
t heorem .changing a non volatile variable to a volatile variable does not remove any of the existing happens before edges that result from synchronization actions on any of the execution paths but it may introduce additional happens before edges.
proof .accessing non volatile variables are not synchronization actions so they cannot involve in the creation of happensbefore edges resulting from synchronization actions.
once a non volatile variable is changed to a volatile variable the write accesses will become release statements and the read accesses will become acquire statements and matching release and acquire pairs if any will create happens before edges.
g31 g35 g41 g1 g45 g16 g24 g36 g36 g34 g27 g23 g35 g1 g29 g36 g19 g34 g23 g29 g16 g43 g36 g34 g23 g41 g31 g34 g27 g1 g18 g23 g41 g23 g1 g37 g42 g24 g34 g31 g40 g30 g16 g20 g24 g32 g27 g25 g41 g1 g36 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g22 g30 g39 g27 g23 g26 g1 g8 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g22 g30 g39 g27 g23 g26 g1 g9 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g22 g30 g39 g27 g23 g26 g1 g10 g1 g1 g1 g1 g1 g1 g1 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g1 g1 g1 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g1 g1 g1 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g17 g1 g1 g1 g1 g40 g8 g15 g1 g1 g39 g1 g17 g1 g35 g27 g44 g1 g18 g23 g41 g23 g4 g5 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g41 g8 g15 g1 g31 g28 g1 g4 g37 g42 g24 g34 g31 g40 g30 g1 g2 g17 g1 g35 g42 g34 g34 g5 g1 g48 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g42 g8 g15 g1 g40 g46 g35 g25 g30 g39 g36 g35 g31 g47 g27 g26 g1 g4 g36 g5 g1 g48 g1 g40 g9 g15 g1 g1 g37 g42 g24 g34 g31 g40 g30 g1 g17 g1 g39 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g41 g9 g15 g1 g1 g1 g1 g44 g30 g31 g34 g27 g1 g4 g2 g29 g36 g19 g34 g23 g29 g5 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g42 g9 g15 g1 g1 g1 g31 g28 g1 g4 g37 g42 g24 g34 g31 g40 g30 g6 g29 g27 g41 g18 g27 g40 g25 g4 g5 g1 g2 g17 g1 g35 g42 g34 g34 g5 g1 g40 g10 g15 g1 g1 g39 g6 g40 g27 g41 g18 g27 g40 g25 g4 g3 g27 g3 g5 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g41 g10 g15 g1 g1 g1 g1 g21 g41 g39 g31 g35 g29 g1 g40 g1 g17 g1 g1 g37 g42 g24 g34 g31 g40 g30 g6 g29 g27 g41 g18 g27 g40 g25 g4 g5 g16 g1 g1 g1 g42 g10 g15 g1 g1 g1 g1 g1 g1 g29 g36 g19 g34 g23 g29 g1 g17 g1 g41 g39 g42 g27 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g40 g11 g15 g1 g1 g40 g46 g35 g25 g30 g39 g36 g35 g31 g47 g27 g26 g1 g4 g36 g5 g1 g48 g1 g1 g1 g1 g1 g1 g41 g11 g15 g1 g1 g1 g1 g23 g40 g40 g27 g39 g41 g4 g40 g6 g27 g38 g42 g23 g34 g40 g4 g3 g27 g3 g5 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g42 g11 g15 g1 g1 g1 g27 g34 g40 g27 g1 g1 g40 g12 g15 g1 g1 g1 g1 g1 g45 g17 g12 g16 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g49 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g42 g12 g15 g1 g1 g1 g1 g1 g1 g29 g36 g19 g34 g23 g29 g1 g17 g1 g28 g23 g34 g40 g27 g16 g1 g40 g13 g15 g1 g1 g49 g1 g7 g7 g1 g42 g35 g34 g36 g25 g33 g1 g36 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g1 g42 g13 g15 g1 g49 g1 g7 g7 g1 g42 g35 g34 g36 g25 g33 g1 g36 g1 g40 g14 g15 g1 g1 g29 g36 g19 g34 g23 g29 g1 g17 g1 g41 g39 g42 g27 g16 g1 figure viagoflag thread notifies thread when object publish is ready to be used.
thread can also notify thread by checking a field of the object pointed by publish .
theorem .changing a program by adding a synchronization action joining a thread acquiring a lock and reading a volatile variable that involves an existing memory location does not remove any of the existing happens before edges that result from synchronization actions or the program order on any of theexecution paths.
p roof .an existing happens before edge that result from synchronization actions can be removed only by changing the source or the destination statement of the happens before edge.
adding asynchronization action does not change such a statement.
also an existing happens before edge that result from program order does not change as a result of adding a synchronization action as happens before is a transitive relation and all such existing happens before edges would be preserved due to transitivity.
lemma .moving an instruction that accesses a non volatile variable does not remove any of the existing happens before edges that result from synchronization actions on any of the execution paths.
proof .same reasoning as in proof of theorem .
lettid i denote the id of the thread that executed instruction i on a given path.
lemma .moving a data race source instruction write x at step h before an instruction that is the source of a happensbefore edge represented by where d h i does not introduce a new data race that involves the moved statement on the same counter example path if and only if the following conditions hold .
condition the moved source instruction does not become a new data race source instruction.
for any read write xat step gs.t.d g h there exists a happens before edge represented by range s.t.d e f g and tid h tid e andtid f tid g .
proof .after the move the old data source instruction at step h would be at step d 1and would be ordered with the instruction at step gby happens before.
as a concrete example consider the sample program in figure and the corresponding counter example path in figure .a.
.
condition the moved source instruction does not become a new data race manifesting instruction.
for the first read write x at step athat precedes the instruction at d there exists a happens before edge s.t.a b c d andtid a tid b andtid c tid h .
221b ...publish r s2 step d...synchronized o s4 step c... unlock o u6 step b...goflag false u5 step a... ...if publish !
null t1 step i... while !goflag t2 step jpublish r s2 step d unlock o s6 step esynchronized o u1 step fgoflag true u3 step ggoflag true s7 step hif publish !
null t1 step iwhile !goflag t2 step j... ............ ...... move suggestion data race source statement manifest statementdata racesource statementdata race manifest statementdata race a goflag true s7 step h figure a instantiation of condition in lemma b instantiation of condition in lemma based on sample program in figure .
happens before edges formed by synchronization actions are shown by lines connecting the matching release and acquireinstructions.
p roof .after the move the old data source instruction at step h would be at step d .
the instruction at step aand the instruction at step d 1would be ordered by happens before.
as a concrete example consider the sample program in figure and the corresponding counter example path in figure .b.
theorem .moving a data race source instruction write xat step h before an instruction that is the source of a happensbefore edge represented by where d h i does not involve any new data races if and only if conditions71a n d2i n lemma hold.
proof .follows from lemma and lemma .
.
experimental results in order to evaluate the usefulness and determine good threshold values for number of data races to detect before stopping jrfe was used to analyze programs taken from a variety of sources including a textbook8on multiprocessor programming the amino concurrent building blocks library barrier implementations from a google concurrent data structures workshop the java grande forum benchmark suite and undergraduate students assignments implementing a multithreaded web server simulator.
jrf discovered a data race in out of examplesfrom races in junit tests 9a n d1 0e x a m p l e si n a n d of barrier implementations in .
we also found data races in out of examples from and out of students projects.these results show that data races are a common error in java programs whether written by students or experts.
representative results are shown in table .
these were performed on an i386 processor with 32gb ram using linux .
.
generic os jpf version and java .
with 1gb jvm heap memory.
the max length column contains the number of tran sitions in the longest counterexample path.
the memory requirement and elapsed time for jrf and jrf e are given in the next four 7checking of the two conditions in lemma has been implemented in jrf and the suggestion is made only if the conditions hold.
for brevity the algorithm in figure does not include checking these conditions.
8java implementations were obtained from the book s companion web site.
different functions are tested in amino junit tests 10these races involve features documented as not thread safe thus indicate bugs in client code not the amino library.columns.
the overhead of counterexample analysis is the time and memory spent in managing additional data such as the acquiring history and path elements and applying the algorithm to generatesuggestions.
the final two columns show the field involved in a de tected data race and the suggestions generated by jrf e. each rowgives results generated using three different values for the numberof races threshold.
the first items given in a normal font pertain to the single race found when the threshold is one.
entries pertaining to results with a threshold of ten are given in italic while entries from runs with a threshold of are given in this shape .i nt h e suggestion column the set of suggestions for each threshold value also includes those from smaller thresholds.
the suggestion in bold corresponds to a solution chosen by a knowledgeable programmer as the most appropriate way to eliminate that data race.
in the disbarrier test the log i n t e g e ra r r a yi sp a r to ft h e test driver not the barrier.
the race on its elements could be eliminated trivially by changing the array to an atomic array.
however the suggestions show that changing the flag to an atomic array will also correct the races on log and this is the best solution.
lockfreehashset is implemented using atomicintegers and abucketlist which is a list of node .
the bucket list should be changed to atomic array to guarantee the volatile semantics for each element access.
even though the elements of a bucket list are not protected at all the thread safe access of the bucketlist provides the required ordering of accesses to the internal list elements.
jrf e verifies that using an atomic array for bucket will also eliminate the races on node next ofnode a n d head ofbucketlist .
the race involvingnext is quite subtle.
the next field is declared to be an atomicmarkablereference node .
this means that the accesses of the objects referenced by the field can be safely accessed with volatile semantics.
since the data structure is a linkedlist accesses to nodes other than the first are safe.
the next nodeof the head of the list however exhibits data races.
inoptimisticlist each list element is represented by an entry object.
races on next andkey fields are both removable by marking next as volatile.
in mcslock three fields of qnode are involved in races but one change changing next to volatile does not resolve the other two.
from the suggestions we can easily deduce that one more fix is needed changing locked to volatile which will also correct the data race involving counter .
thegoogle.linearsensebarriervolatile test illustrates the limitations of jrf e s approach.
the race on value ofcounterwithbarrier which is part of the test driver not the barrier can be eliminated by marking it volatile.
however the problem is that the implementation has multiple threads set the vari able to the same value with each update after the first manifesting a data race.
a better solution is to avoid the multiple updates.
this sort of semantic reasoning cannot be done by jrf e. however the suggestion given would eliminate the data race.
twojgf examples have races on volatile arrays without volatile element access isdone and sync and nonvolatile array a .
these widely available benchmarks were implemented before the current jmm and before the issues relevant to the memory model were well known and illustrate the usefulness of a tool that can check for data races even in apparently correct code.
one test case using student code is shown.
several of the student projects showed significant problems related to concurrency which need to be corrected before one could expect the results of jrf e to be useful.
the tests showed that in most cases the tool gave the most appropriate suggestion.
this is especially true for programs where the problem is lack of attention or misunderstanding of memory 222test case max memory mb time sec race field suggestion threads iterations length jrf jrf e jrf jrf e ofclass flag use atomic array for flag herlihy shavit.
of node join the updater barrier.
use atomic array for log disbarrier log use atomic array for flag ofdisbarrier join the updater bucket use atomic array for bucket of lockfreehashset node u s ea t o m i ca r r a yf o rb u c k e t change head of bucketlist to volatile herlihy shavit.
read volatile field value of atomicreference before hash.
next unsafe publication of node lockfreehashset ofnode change next of node to volatile u s ea t o m i ca r r a yf o rb u c k e t change head of bucketlist to volatile read volatile field value of atomicreference before head unsafe publication of node ofbucketlist change head of bucketlist to volatile u s ea t o m i ca r r a yf o rb u c k e t next change next of entry to volatile of entry herlihy shavit.
entry change next of entry to volatile lists.
lock the lock optimisticlist key unsafe publication of node ofentry change key of entry to volatile change next of entry to volatile lock the lock next change next of qnode to volatile of qnode join the updater herlihy shavit.
counter change counter of qnode to volatile spin.
ofqnode join the updater mcslock change locked of qnode to volatile locked change locked of qnode to volatile ofqnode join the updater threaddonearray use atomic array for threaddonearray google.
of baselinearsensebarriervolatile join the updater linearsensebarriervolatile value change value of counterwithbarrier to volatile ofcounterwithbarrier join the updater amino.
cursor change cursor of deqiterator to volatile iterator ebdeque of deqiterator join the updater jgf.
isdone use atomic array for isdone lufact of tournamentbarrier move the source sync use atomic array for sync jgf.
of sor sor a use atomic array for a ofrandommatrix use atomic array for sync finishedtakingrequests change finishedtakingrequest of workerthread to volatile webserver.
of workerthread synchronized block using requestbuffer studenta empty change empty of requestbuffer to volatile ofrequestbuffer synchronized block using requestbuffer table selected results from jrfand jrf e. see section for an explanation.
model issues but the programs are basically correct.
jrf e allows programmers to confidently choose a solution where the volatility of one variable also guards other variables from data races.
in addition the results show that when a program has only one memorylocation involved in a race the threshold doesn t matter.
however if the program contains races involving more than one memory location then considering them together helps to find the most appropriate suggestions.
.
related work many tools have been developed to detect data races statically or dynamically using a variety of definitions of a data race.
most of these tools use a slightly different notion of a data race that is use ful for finding certain types of concurrency errors in sc environ ments rather than finding data races that indicate violation of sc.
for brevity we limit our discussion here to more recent memory model aware tools and tools that attempt to analyze counterexam ples.
a more complete discussion of related work can be found in .
recently several studies have incorporated memory model awareness into model checking.
uses model checking to compare two hardware level memory models.
the approaches presented in can verify sequential consistency.
considers a hardware level memory model and uses bounded model checking and a stateless model checker.
they use vectorclocks to capture the happen before relation.
since jpf is a statebased model checker we can store the happen before informationfor each state.
considers c s memory model and a bytecode level state based model checker tailored for c .
also provides simple program modifications in the form of inserting memory barrier fences to eliminate data races.
this type of suggestion is similar to our changing a non vo latile to a volatile.
however our tool provides a richer set of suggestions.
the technique presentedin guides the model checker in generating a subset i.e.
underapproximates the jmm of program executions which vary due to 223instruction reordering allowed in the jmm and thus generate the legal sequentially inconsistent behaviors.
since it is an underapproximation it can only be used for bug finding not verification.
our tool can verify sequential consistency of a java program with out generating all such subsets but does not deal with sequentiallyinconsistent programs except in the limited sense of allowing theuser to specify that certain races that the use considers to be benign are ignored.
compare a set of successful traces with a set of erroneous ones to localize the errors or to focus the debugging process on a relatively small part of the program.
considersboth transition and invariant differences on successful traces andthe counterexample paths.
it provides feedback on how successful traces can be transformed into counterexample paths.
however our analysis provides feedback on how to transform a counterexample path to a possibly successful trace.
generates multipleerror traces having independent causes and for each error cause re ports a single error trace.
uses dynamic analysis and machinelearning to classify program properties as fault revealing and non fault revealing and reports program invariants that are in the faultrevealing set.
focus on error traces only.
slices a counterexample path to find the statements that directly or indirectly affect the failure.
computes the transactional happens before edges on the dynamically generated execution traces to detect blocks that cannot preserve their atomicity and hence cannot be serialized.
.
conclusion our data race detection tool jrf is an extension of jpf that precisely detects data races as defined by the java memory model in java bytecode.
this is important since standard jpf is unsound forprograms that contain data races.
because it is based directly on thejava memory model jrf can handle all concurrent programming idioms supported by java includi ng lock free algorithms.
in this paper we described jrf e an extension of jrf that analyses the counterexample path and acquiring history and provides suggestions for eliminating data races.
the usefulness of the suggestionfacility was evaluated by applying to a number of examples.
ap propriate suggestions were provided in each case indicating that jrf e can be a practical tool.
.