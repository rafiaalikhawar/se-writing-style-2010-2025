recommending refactorings based on team co maintenance patterns gabriele bavota1 sebastiano panichella1 nikolaos tsantalis2 massimiliano di penta1 rocco oliveto3 gerardo canfora1 1department of engineering university of sannio benevento italy 2department of computer science software engineering concordia university canada 3department of bioscience and territory university of molise pesche is italy gbavota unisannio.it spanichella unisannio.it tsantalis cse.concordia.ca dipenta unisannio.it rocco.oliveto unimol.it canfora unisannio.it abstract refactoring aims at restructuring existing source code when undisciplined development activities have deteriorated its comprehensibility and maintainability.
there exist various approaches for suggesting refactoring opportunities based on di erent sources of information e.g.
structural semantic and historical.
in this paper we claim that an additional source of information for identifying refactoring opportunities sometimes orthogonal to the ones mentioned above is team development activity.
when the activity of a team working on common modules is not aligned with the current design structure of a system it would be possible to recommend appropriate refactoring operations e.g.
extract class method package to adjust the design according to the teams activity patterns.
results of a preliminary study conducted in the context of extract class refactoring show the feasibility of the approach and also suggest that this new refactoring dimension can be complemented with others to build better refactoring recommendation tools.
categories and subject descriptors d. .
distribution maintenance and enhancement documentation enhancement restructuring reverse engineering and reengineering keywords refactoring developers teams .
introduction software refactoring is a disciplined technique for restructuring an existing body of code altering its internal structure without changing its external behavior .
refactoring is usually a direct consequence of an undisciplined evolution due to the lack of a rigorous and documented development process poor design decisions or simply to the need for applying urgent patches to the software.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
recent and past years di erent approaches and tools have been developed to identify refactoring opportunities.
some of them use structural information to identify the need for refactoring and then suggest a suitable refactoring action.
others also exploit semantic information i.e.
textual information extracted from source code indicating the implementation of similar responsibilities or historical data to identify refactoring solutions.
we conjecture that a fourth dimension can be highly bene cial when recommending refactoring operations.
such a dimension relates to changes performed by teams and it is based on the assumption of congruence between social and technical activities .
we de ne a team as a group of developers that during the project history worked on common sets of source code entities note that in this de nition we do not necessarily assume that such developers communicate with each other .
the basic idea is that code entities frequently modi ed by the same team should be grouped together in a separate module .
a straight forward consequence of that refactoring would be easing the release of individual components of the project and or integration activities without waiting for other teams to complete their tasks.
suppose that two di erent teams tiandtjusually work on di erent code entities and thus they are responsible for maintaining and evolving di erent features of the system.
however both tiandtjwork on class c but on di erent parts of it e.g.
tiworks on members cmi whiletjon memberscmj wherecmi cmj ?.
this could be a symptom of heterogeneous responsibilities implemented in c and thus of an opportunity to perform extract class refactoring.
we claim that a better source code organization can be obtained by separating cmifromcmj because these distinct member groups of ccan be likely related to the features being maintained by tiandtj respectively.
note that as it will be clearer later in the paper relying solely in change history is insu cient.
this is because history would just identify co changes while in this context we need to identify code entities co maintained by the same team members.
in this paper we i introduce the approach named team basedrefactoring tbr to identify refactoring opportunities based on team co maintenance patterns ii instantiate tbr to support extract class refactoring and iii provide preliminary results showing that tbr is able to identify meaningful refactoring solutions and complementary in many cases to other sources of information.
this opens the road towards better refactoring recommendation tools being able to provide more accurate and or more complete suggestions by combining multiple sources of information.
versioningsystemfine grained changeschange history extractor refactoring recommender detection algorithmteam identifieremerging team 1refactoring opportunitiesfigure tbr team based refactoring .
approach figure overviews the main steps of tbr.
first the entire change history of a system under analysis is extracted by mining the versioning system through a component called change history extractor .
this information is then provided as an input to the team identi er component in charge of detecting teams as groups of developers usually working on the same code entities.
finally the change history information and the identi ed teams together with a speci c detection algorithm for a particular refactoring operation are provided to the refactoring recommender producing a list of refactoring recommendations for the operation of interest.
in the following we detail each of the main steps described above.
.
extracting change history information the change history extractor mines the versioning system log identifying changes occurred on the system les over time as well as the authors of each change.
note that when the mining is performed from git as in our study it allows to distinguish when this information is available actual authors of a change from committers.
the logs extracted through this operation report code changes at le level of granularity.
while this information is su cient to identify teams as groups of developers usually working on the same code les it is not enough for the refactoring recommender .
in fact to detect solutions for several refactoring operations the refactoring recommender needs to know the changes performed by developers in the code at a ner granularity level.
to extract this information a code analyzer developed in the context of the markos european project1 is used.
the code analyzer parses the source code by relying on the srcml toolkit and extracts a set of facts concerning the les classes methods and attributes that have been added removed and changed in each commit.
as it will be clear soon this information can be used by the refactoring recommender to support di erent refactoring operations.
.
identifying teams tbr identi es teams as groups of developers usually working on the same set of code les.
once again we remark that this may not correspond to actual teams of people structured by an organization company rather it is a mean to identify groups of people co changing sets of code elements.
in accordance with this de nition there is a link between two developers if they modify the same le during a speci c interval.
the strength of a link between two developers depends on the number of times the developers modify the same le s in the considered time period.
to identify teams during the history of a project the team identi er splits the history of the system into time windows identifying teams in each of them.
this step is needed for two reasons .
teams change during time.
thus computing the teams by considering the entire change history would not make sense.
a software engineer interested in identifying refactoring solutions on the current version of the system will focus her attention just on the last year s of development since very old teams are unlikely to exist anymore.
.
to consider two developers as part of the same team we need to ensure that they work on the same les in a speci c and limited period of time.
otherwise it could happen to consider two developers as part of the same team even if they modi ed the same le in two distant time periods.
choosing an appropriate time window length is important.
a longer time window captures more commits than a shorten one hence more information to cluster developers into teams.
however a long time window also implies the risk of grouping people not really working on the le in the same time period but rather in two subsequent time periods.
the choice of the time window length depends on factors that are very project speci c like for instance the frequency of commits the higher the commit frequency the shorter the time window could be the average release interval for projects issuing releases very quickly a shorter time window could be appropriate and the stability of the developers base the more stable is the developers base the longer the time window could be .
for each time window the ward s hierarchical clustering algorithm is applied to cluster developers into teams.
as a distance between the entities to cluster i.e.
developers we adopt an euclidean distance based on a dissimilarity measure taking into account the common les two developers modify in the considered time window.
in particular given the generic pair of developers di dj their dissimilarity d is computed as d d i dj jcommonlymodifiedfiles j min max min wherejcommonlymodifiedfilesj is the number of common les modi ed by dianddjin the considered time window andmin max is the minimum maximum value of jcommonlymodifiedfiles jmeasured among all pairs of developers.
as it can be noticed i dis normalized between zero and one and ii in d the higher the number of common les two developers modify in the considered time window the lower their dissimilarity.
the output of the ward s algorithm is a dendrogram a tree diagram where the leafs of the tree represent the entities to cluster developers while the remaining nodes represent possible clusters teams the entities belong to up to the root representing a cluster containing all the entities.
the distance between merged entities increases with the level of the merge starting from the leaves towards the root .
this means that nodes i.e.
clusters at a higher level group together entities having higher distance lower similarity between them.
to nd the dendrogram cut point 338we need to determine an appropriate number of clusters.
to this aim we relied on a widely adopted approach based on the silhouette coe cient a measure of the quality of the obtained clustering de ned as the ratio between the average intra clustering and the average inter clustering distance.
we compute the silhouette coe cient for each possible partition obtainable from the dendrogram produced by the ward s algorithm selecting the one exhibiting the highest silhouette value to cluster developers into teams.
.
detecting refactoring opportunities .
.
general approach when the refactoring recommender is invoked the following information is available for each time window i the teams existing in the time window and ii the ne grained changes performed by each team in the time window.
by exploiting this information it is possible to support di erent refactoring operations.
indeed as said before the general idea behind tbr is that code entities frequently modi ed by the same team should be grouped together in a separate module .
this idea can be instantiated to di erent refactoring operations by considering di erent granularity levels for code entities and modules .
table illustrates how tbr can be applied to di erent types of refactoring opportunities.
for instance by considering a group of classes maintained by a speci c team as the code entities it is possible to improve the system package modularization to better re ect the way developers work a typical refactoring in such a context is the extract package aimed at isolating a speci c responsibility into a package representing our module granularity .
going at a ner level of granularity and considering methods as the modules of interest extract method refactoring could be supported by two means a code fragment i.e.
a subset of statements within a method maintained by a speci c team of developers could indicate the existence of a distinct functionality that can be extracted in a separate method similar code fragments within di erent methods frequently modi ed by a speci c team could indicate the existence of change prone clones that can be merged into a single method.
additionally the modi cation of the code fragments by the same team indicates that the developers are aware of the existence of the clones and dedicate e ort to update them consistently.
according to the particular characteristics and relationships of the involved code entities we can develop algorithms for extracting di erent types of refactoring opportunities.
in the next subsection we will describe a prototype approach for the detection of extract class refactoring opportunities using tbr.
.
.
tbr for extract class refactoring in this paper we instantiate tbr to extract class refactoring as described in algorithm .
extract class refactoring is a technique for splitting classes with many responsibilities into di erent classes.
tbr identi es extract class solutions in a given time window tw.
note that a software engineer interested in identifying refactoring solutions in a system s today will look for teams and changes performed by them in the recent software history of length twlength .
tbr analyzes each class ci2sto verify for each team tjexisting in tw if there exists a set of methods mtj owned bytj lines from to in algorithm .
mtjisalgorithm tbr applied to extract class refactoring twlength year tw from today to twlength before teams teams detected by the teams identi er intw s the set of classes in the system under analysis refactorings ?
for each classci2sdo for each teamtj2teams do mtj ?
.methods owned by tj for each methodmk2cido iftjownsmkthen mtj mk end if end for ifjmtjj andjci mtjj then atj ciattributes used more by mtjthan by fci mtjg reftoadd extractmtj atjfromci ifsatis espreconditions reftoadd then refactorings reftoadd end if end if end for end for returnrefactorings owned bytjduringtw if for each method mkinmtj tj is responsible of at least of all changes performed on mk duringtw .
our conjecture is that the set of methods mtjrepresents a precise responsibility managed by tj that can be extracted from cito facilitate its maintenance.
in order to consider the extraction of mtjfromcias a valid extract class refactoring opportunity we check that i the cardinality of mtjis at least where is xed in our current implementation to three otherwise it is unlikely that mtjrepresents a well de ned set of responsibilities and ii the methods left in ciwhen extracting mtjare more than for the same reason explained above see lines from to in algorithm .
note that our choice of xing is not random but based on previous work .
however a deep investigation of such parameter is part of our future research agenda.
attributes of cithat are used by a greater proportion of methods in mtjthan by the methods left in ciare grouped in atjto complete the extract class refactoring solution lines from to in algorithm .
at the end of the process we examine the recommendations against the preconditions proposed by to lter out those that could change program behavior or are not applicable in practice lines from to in algorithm .
note that by using the above described algorithm it is also possible to identify di erent teams owning di erent subsets ofci s methods.
this would result in a whole new organization of the responsibilities implemented in ci.
.
preliminary evaluation the goal of our study is to evaluate the quality of the refactoring solutions identi ed by tbr and the complementarity of the information it exploits as compared to other sources of information typically used to support refactoring asstructural semantic and historical information.
the contextof the study consists of ve software projects belonging to the android apis chosen for being very active projects with a relatively large number of developers see table .
339table instantiation of tbr to di erent refactoring operations code entitiesmodulecode smellrefactoring granularity operation a subset of methods and attributes within the sameclasssingle responsibilityextract classclass frequently modi ed by the same team principle violation a method from one class source frequently co modi edclass feature envy move methodwith members of another class target by the same team a subset of statements within a method frequentlymethodnon cohesiveextract methodmodi ed by the same team method a set of similar code fragments within di erent methodsmethod duplicated code extract methodfrequently modi ed by the same team a subset of classes under the same package or di erentpackagepoor packageextract packagepackages frequently modi ed by the same team organization table software systems used in the study.
pro ject from andr.
api period kloc fram ework opt telephony aug jan frameworks base oct jan fram eworks support fe b nov sdk oct jan tool base nov jan our study aims at addressing two research questions rq is the information derived from teams useful to identify refactoring opportunities?
rq is the information derived from teams complementary to the sources of information typically exploited to identify refactoring opportunities?
to answer rq 1we simulate the use of tbr to detect refactoring opportunities.
that is given stthe system snapshot at time ton which we are interested to perform refactoring tbr identi es refactoring solutions by looking at changes occurred in the period .
releases of the android apis are generally issued every four six months2.
however since android apis are divided into sub projects see table we observed that some of them did not change or rarely changed in a four months time interval.
because of that we considered possible values of twlength between six months and one year nding one year to be su cient to capture enough changes for all subsystems without risking to merge teams working in very di erent time periods.
we plan to perform a thorough assessment of this parameter in the future with the aim of de ning heuristics to automatically set the time window length based on speci c characteristics of the project on which tbr is applied.
then to assess the quality of the recommended refactorings two phd students and one industrial developer none of them are authors nor they know how the approach works evaluated each of them by answering the following questions q1 how do you perceive the cohesiveness decoupling of the classes involved in the refactoring?
assign a score on a ve points likert scale de nitely worse slightly worse the same slightly better de nitely better than before .
q2 evaluate the e ort of implementing the refactoring operation by considering the impact on the source code e.g.
addition of getter setter methods update of