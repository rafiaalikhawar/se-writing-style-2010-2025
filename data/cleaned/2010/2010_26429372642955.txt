towards self healing smartphone software via automated patching tanzirul azim univ.
of california riverside riverside ca usa mazim002 cs.ucr.eduiulian neamtiu univ.
of california riverside riverside ca usa neamtiu cs.ucr.edulisa marvel us army research laboratory aberdeen proving ground md usa lisa.m.marvel.civ mail.mil abstract frequent app bugs and low tolerance for loss of functionality create an impetus for self healing smartphone software.
we take a step towards this via on they error detection and automated patching.
speci cally we add failure detection and recovery to android by detecting crashes and sealing o the crashing part of the app to avoid future crashes.
in the detection stage our system dynamically analyzes app execution to detect certain exceptional situations.
in the recovery stage we use bytecode rewriting to alter app behavior as to avoid such situations in the future.
when using our implementation apps can resume operation albeit with limited functionality instead of repeatedly crashing.
our approach does not require access to app source code or any system e.g.
kernel level modi cation.
experiments on several real world popular android apps and bugs show that our approach manages to recover the apps from crashes e ectively timely and without introducing overhead.
categories and subject descriptors d. .
software program veri cation reliability validation d. .
testing and debugging testing tools tracing keywords automatic patch construction automated software repair smartphone applications bytecode rewriting self healing software google android .
introduction as smartphones and tablets continue to increase in popularity more and more critical software e.g.
nancial military medical apps shifts to these new platforms.
unfortunately smartphone software from the os to libraries to apps has a high defect rate due to many factors including the novelty and rapid evolution pace of smartphone software the low barrier to entry for publishing software via app marketplaces as well as the myriad devices and user speci c con gurations on which it is run maintaining certain functionality such as the ability to place phone calls is critical on smartphones and unlike on desktop systems we cannot always rely on network connectivity for downloading and applying a patch to x the bug.
hence there is a strong impetus for self healing smartphone software.
we take a step towards this by presenting an approach for automating patch construction to recover from and prevent future crashes in android apps.
our approach is more suitable for smartphone apps than say desktop or server programs due to the compartmentalized nature of smartphone apps many pieces of functionality e.g.
gui elements can be turned o without a ecting user experience .
our implementation rst employs dynamic analysis to detect when an app has entered an error state and to identify the o ending part of the app then it implements recovery either by eliminating transient faults and continuing to run at full functionality or rolling back to a safe state followed by sealing o the o ending part and operating in a limited mode while avoiding further crashes.
an example would be a bug in the auto completion code that crashes the smartphone s dialer app whenever the user tries to dial a number when we detect the crash rather than rendering the whole app inoperable and unable to place emergency calls we create and apply a patch to turn o auto completion hence containing the damage and allowing the dialer app to continue to run albeit with some limitations .
while this is an incipient form of self healing in smartphone software it is compelling nevertheless.
exceptional conditions or bugs have many causes and manifest in a variety of ways unhandled exceptions assertion failures system overload our framework detects several such exceptional conditions and reacts accordingly depending on whether the fault is transient or persistent.
as the context of the error may be di erent in di erent situations it is unreasonable infeasible to expect the smartphone user to know how to circumvent the error and keep the app functional.
hence our system automatically detects the error and changes the app s behavior to respond to these circumstances so that most of the normal app workow is not hampered.
the approach is centered around several techniques which facilitate self healing extracting a high level model of app operation which captures legal app transitions as a graph continuous monitoring to detect crashes identifying and sealing o the o ending app component through app bytecode rewriting.
although crash prevention has value and is preferable smartphone software bugs are a fact of life so in this work we will outline our ideas regarding recovering potentially lim permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
ited functionality as follows.
using the statically constructed model and the crash point the app goes to a rollback point and depending on the nature of the fault transient or persistent it creates appropriate conditions potentially via seal o to avoid future crashes.
we have implemented a prototype that equips android apps with the aforementioned self healing functionality we have chosen android as a target due to its leader status .
our framework is robust running on actual phones and supporting widely popular apps such as k mail andfacebook mobile .
moreover our approach does not require access to the app source code or modi cations to the kernel or libraries rather we rely on static analysis and rewriting at the bytecode level.
we have evaluated our implementation on a set of bugs in real world popular android apps running on motorola droid bionic phones.
experiments show that our implementation manages to successfully perform self healing without prohibitive overhead and the self healing process is accomplished very e ciently in less than one minute.
we expect that the fault information revealed by our system could provide feedback to the app developers to help them develop bug xing patches.
.
approach we rst present a brief overview of the android platform discuss self healing in the context of the platform and then present our approach in detail.
android platform.
the android platform consists of the android os a linux kernel customized for smartphones the dalvik vm virtual machine and apps written mostly in java that are compiled to a bytecode format named dex and execute in the dalvik vm.
apps can also embed native code written in c c that is executed directly by the os.
apps have access to a rich set of libraries android application framework that o er services from hardware abstractions to orchestrating the gui control ow.
self healing in the context of android apps.
self healing computing systems capabilities include inferring ways of detecting failures e.g.
due to system malfunctions such as exceptions violations of operational constraints and strategies for applying corrections to restore some or all system functionality.
the key concept behind our selfhealing mechanism in android is that an app must resume to a normal gui state after the app experiences a failure.
hence it is key that we discover a model set of gui states beforehand so during recovery the app can be driven to an appropriate state and avoid future crashes.
for the purpose of this work we focus on two types of android app faults transient and persistent.
transient faults occur when operations fail as a result of resource unavailability and will disappear if the operation executes again if the resource becomes available a simple and e ective recovery strategy for these is re execution.
persistent faults do not go away via re execution e.g.
because they are due to errors in application logic in such cases sealing o the o ending operation is an e ective recovery strategy.
our approach consists of the following phases model construction and rollback point identication.
in this phase we identify discrete safe and unsafe points in the app which form the basis for our approach as well as transitions between them using static analysis.
model dynamic analysis log app self healing capable app seal off patch figure system architecture.
detection.
in this phase our framework performs dynamic analysis on systems s behavior and app output e.g.
system wide resource usage app method calls gui elements privileged actions to detect crashes and identify faulty components.
recovery.
our recovery mechanism works in two phases.
first after a crash point is detected we identify a safe rollback point and if needed depending on the nature of the fault we seal o the bytecode associated with the crash point by using the model to identify the faulty part of the binary and then rewrite the bytecode to avoid future execution of code associated with the crash point.
second we restart the app to a nearby safe point so that users can continue their work and interaction with the app.
.
architecture figure shows our system architecture centered around detecting crashes and in response applying seal o patches.
amodel is constructed rst via static analysis on the app bytecode the model includes rollback resume points where the app will be driven when recovering from a fault.
next the app is executed either manually by users or automatically via systematic exploration tools and its execution log is monitored via dynamic analysis.
when a failure is detected we employ bytecode rewriting code generation and instrumentation to create a patch .
we apply the patch via bytecode rewriting the patch seals o the functionality responsible for the crash yielding a self healing capable app.
we now describe our system s operation in detail.
.
model construction and rollback point identification the app model forms the basis for identifying safe and unsafe points in the app.
safe points will be used for rollback and unsafe points will be sealed o .
the model named static activity transition graph satg is a transition graph where nodes are app screens activity gui screen in android parlance and edges represent possible transitions between screens which will take place e.g.
as the user navigates around using the gui .
for example a directed edge from activity ato activity bpoints to a valid transition from atobas a result of the user exercising a gui object associated with a.
624a c b d crash e ac vity figure our static analysis infers bas the rollback point when the app crashes at point d. note that satg construction is not a contribution of this work but the satg is nevertheless essential to identifying rollback points and taking recovery actions in the case of a fault we calculate the nearest safe activity that can be used as a rollback point.
static analysis is important because it reveals the sequence of callbacks associated with activity transitions invoking these callbacks which in normal user interaction corresponds to exercising a sequence of gui elements allows us to reach the rollback point.
figure shows a satg constructed with our a3etool .
here the root node ais the initial activity.
each edge to the next node is labeled with the callbacks or events triggering that transition.
for example event is responsible for the transition from activity ato activity b. suppose the app crashes at activity d marked in the gure .
from the satg we can see that activity dwas reached via activity b so activity b is the nearest safe point to restart the app.
more generally rollback points can be obtained via a backward traversal from a crash point.
.
detection we now discuss what we detect classes of faults in android app and how we detect them via monitoring.
what we detect.
we begin by presenting several common classes of android apps faults along with app names that contain these faults in certain versions .
note that these faults are not particular to android as they a ect other smartphone platforms as well.
a resource shortage unavailability.
unlike the desktop or server platforms resource availability cannot be taken for granted.
for example smartphone multitasking is much more restrictive when an app is not in focus it is placed on a stack and essentially put to sleep its resources taken away and assigned to apps in focus.
apps not properly designed to work with this kind of behavior may experience failure because of resource shortage.
b unhandled exceptions.
these failures are mostly due to poor programming practices and inadequate testing that result in failure to anticipate and handle the potential exceptions raised by the app or the system e.g.
npr news soundcloud k mail .
c crashes due to semantic errors.
this is a broad class of errors for example the app fails to accepts certain types of input that otherwise should be accepted and dealt with by the program.
for example an app crashes because the input le is not in the correct format or broken hence the app crashes instead of generating appropriate warnings apv pdf viewer .
d crashes due to loss of network connectivity.
most android apps communicate with remote servers.
even the apps which do not require a network to carry on their functionality may still require network access for loading advertisements.
however internet connectivity might be intermittent hence apps must deal with situations where network access is temporarily unavailable e.g.
facebook mobile .
e permission violations.
in android access to sensitive resources is protected by a set of permissions.
when the app tries to access resources or functionality it does not have permission for the os will terminate the app.
f ipc errors.
inter process communication ipc is heavily used in android for isolation and security.
apps must abide by the ipc communication protocol failure to do so may lead to apps being terminated.
how we detect.
currently our detection strategy relies on android s system wide logging facility logcat .
in android the dalvik vm constantly monitors the app and when a fault is encountered the vm reports the potential cause of error and the associated methods or callback into the logcat.
to implement monitoring we add a listener in the dalvik vm s logging system and in the event of a fault we isolate the exact method and activity screen responsible for the fault.
.
recovery example recovering from a bug in npr news .we rst illustrate how our system recovers from an actual bug in thenpr news app figure .
app execution starts from the root activity newslistactivity .
the a3esystematic explorer clicks a menu button to get the hourly news update which takes the app to hourlynewsactivity .
then a3eplays the radio stream repeatedly.
this initiates a service component playbackservice .
at this time the program enters an illegal state and crashes the crash is captured in the log.
analyzing the log our system nds that the closest method associated with the crash is preparethenplay in the service class playbackservice .
this concludes the online fault detection phase.
next in the recovery phase we apply a seal o patch to preparethenplay as described next.
constructing seal off patches.
we sketch the construction of the bytecode patch inserting code in the app via binary rewriting achieving seal o in figure .
suppose erroneousmethod is the method associated with the fault.
first we surround the original method code with a generic exception handler.
upon failure the handler will just return because the original method s return type is void thus preventing executing the erroneous code.
custom code can be added at this point e.g.
to perform more extensive checkpointing.
in general though the returned value will have to be of the same type as the original mehtod s return type hence we create a return object of the appropriate type.
next for methods containing activities recall that an activity roughly corresponds to a screen in android we apply a similar technique inserting a try catch block around the oncreate virtual method from the activity class.
the oncreate method is called when the activity is loaded i.e.
the screen is displayed .
if the sealed o method execution generates further exceptions the handler will catch the exception and refresh the activity.
thus the activity will remain operational.
with the above technique we gain two 625systema c explora on newslistac vity hourlynewsac vity playbackservice onhandleintent playcurrent preparethenplay start monitoring app excep on illegal state recovery seal off method via binary rewri ng rebuild app binary restart monitoring news play back service started mehod mehod mehod figure example fault point detection and rollback in the npr news app.
inside the faulty method void erroneousmethod t param f surround method with try catch block try f original method code g catch exception e generic exception handler f write custom exception handling code return g g inside the activity override protected void oncreate bundle savedinstancestate f surround with generic try catch block try f initialize activity and load gui components g catch exception e f write custom error handling code refresh the activity startactivity getintent g g figure code sketch of patch construction.
advantages rst by sealing o just the actual problematic method we are ensuring the least amount of functionality loss second we are limiting the functionality seal o only in the time of an actual fault the rest of the time the app will behave normally.
we thus implement a demand driven approach with self healing taking over only when necessary and minimizing operational limitations.
the general technique.
our failure detection is dynamic hence it takes an actual execution to nd and recover from a crash.
when the system is used in the wild users interact with the app as they normally do and if the app crashes users will experience a small delay due to recovery.
for this paper however we used an automated exploration tool we develop in prior work a3e to drive the execution so we could reliably drive the app into a state where it crashes.
in the background we constantly monitor the vm log for events that may indicate failure section .
.
when a failure does occur we determine the nest granularity level for inserting our fault avoiding code.
note that we have several options here.
first we could mark the entire current activity as the potential fault point and deny access to the activity but this is not realistic as an activitycontains many other gui features that may be completely unrelated to the fault observed.
second we could limit the functionality of the associated gui object.
for example if the crashing gui object is a button we can disable it.
but this may be also unrealistic.
for example for some inputs the button code may fail but it will work on other inputs.
third we can operate seal o at the method level.
therefore the method is the nest seal o granularity we employ this granularity level in our approach by assigning the fault to the crashing method.
for example in figure we will seal o the third method preparethenplay using the patching procedure explained above because it is on the lowest level of the exception trace.
once a crash point is reached we rollback and resume the app.
the rollback point depends on whether the crash is transient or persistent.
for transient errors generated in response to external events such as illegal sensor data unexpected shared memory deletion by the android os background services shutdown due to low energy network unavailability resource shortage etc.
the rollback point is the point of the crash.
the idea is that after rollback and restart these transient environmental exceptions may not be raised and the app can resume its functionality normally.
forpersistent errors e.g.
unhandled exceptions semantic errors ipc communication errors unauthorized access we rollback to an earlier point previous node in the satg and use bytecode rewriting to seal o the faulty method in the faulty satg node.
while this limits functionality it ensures that the app will not call the o ending method again.
.
implementation platform.
we implemented our approach and conducted experiments on a motorola droid bionic phone running android .
.
note however that the test results can also be achieved by running the app in the emulator .
tools.
for model construction we used the satg extraction component static analysis based of a3e.
to drive exploration we used the systematic exploration component of a3e.
bytecode rewriting was done using the smali dalvik assembler disassembler .
we wrote the main instrumentation code in java.
in our current setup the phone was tethered to a laptop this was necessary for running a3e smali and initiating rollback restart.
however we expect that in the future the approach will run solely on the phone as we envision it should run in the wild with no tethering required.
626app ve rsion bug type siz e kin st.kby tes fa cebook mobile .
.0net work unavailability npr news .
bsem antic error k mail .
.
.
un handled exception so undcloud .
.2un handled exception apv pdf viewer .
.7sem antic error table examined apps.
.
ev aluation examined apps.
for evaluation we chose several sizable popular android apps that contained known bugs.
in table we present the apps version type of bug and app size.
according to google play each app was highly popular with more than million downloads.
we have evaluated our approach in terms of e ectiveness i.e.
can the system recover from actual bugs in popular sizable apps?
and e ciency i.e.
is the overhead of our approach acceptable?
effectiveness.
our approach was e ective at performing self healing in response to three categories of bugs encountered in ve popular apps.
efficiency.
our approach incurs a one time overhead for model extraction via static analysis to enable rollback point detection.
the second column of table shows the static analysis time for each app.
model extraction time is solely depending on the app s binary size and code complexity and as it is a one time cost incurred before running the app we believe that the seconds gure is acceptable.
we drove the apps to crash points via systematic exploration.
depending on the bug exploration time will vary though techniques such as targeted exploration or fastforwarding record and replay can signi cantly accelerate the procedure.
the time to crash is presented in the third column of table .
for example for facebook mobile the actual fault was in the initial login screen hence the systematic exploration time seconds was much lower than for the other apps.
as mentioned in section .
self healing might require bytecode rewriting if seal o is involved and always requires rollback and restart.
the bytecode rewriting time performed only once after the crash for non transient bugs depends on the size of the app.
this time is shown in the fourth column of table seconds.
facebook mobile required no rewriting because it experiences a transient bug hence the gure for rewriting time.
finally the time required for rollback and restart is shown in the last column of table .
the rollback time involves uninstalling the current version installing the modi ed app and rolling back to the nearest safe point within the app.
while just rolling back requires very little time in our case not more than second uninstalling the current faulty app and reinstalling the modi ed app takes longer seconds.
however this is much shorter than any manual rollback and restart because not only a human would require longer time to uninstall and reinstall but also a human would restart the app from the home screen and therefore would take longer to reach the former point the point where the app was before the crash .
as we rollback to the nearest safe point we can ensure faster exploration to the safe state.
as shown in the last column of table our automated rollback required at most seconds for the apps.
hence the total self healing time is seconds which we believe is acceptable.
for transient faults recovery is faster because we do not rewrite the app a simple rollback is usually enough to re app stati c sys tematic sel f healing anal ysis exp loration byt ecode rol lback tim e to crash rew riting and restart sec onds sec onds sec onds sec onds fac ebook mobile npr news k mail so undcloud apv pdf viewer table e ciency measurements results.
sume normal behavior.
for example our examined version offacebook mobile failed when there was no network connectivity.
a rollback restored the app and as the connectivity was reestablished the app resumed its normal operation.
hence recovery was faster than for the other apps as no bytecode rewriting was performed.
note that app performance is not a ected by seal o since only a speci c part of a method s bytecode i.e.
the prologue is rewritten.
.
limitations our prototype is subject to several limitations that we intend to address in future work.
first mobile apps tend to be gui centric so upon rollback and restart we only lose gui state such as previouslyentered data or selected items.
for more stateful scenarios we will have to perform more sophisticated healing operations e.g.
more sophisticated fault detection analyses and more extensive checkpoint and rollback .
second our approach is reactive responds to bugs after they manifest rather than proactive .
we expect that using techniques such as consistency constraints or invariant checking we can detect and x errors before they develop into fulledged crashes.
third in our current implementation the phone was tethered to a laptop.
there is however no fundamental hurdle to running the approach entirely on the phone.
we used tethering for systematic exploration which will not be necessary when apps crash in the wild and to bene t from existing app rewriting support o ered by desktop tools.
.
related work self healing and automated patch construction have been studied in many contexts from clusters of internet servers to web browsers .
demsky et al.
use formal speci cations for data structures that allow integrity properties in data structures to be monitored and data structures to be repaired in case the speci cation is violated.
perkins et al.
introduced a system named clearview that monitors an application s execution to learn application invariants detect failures and in case of failure automatically constructs and applies a patch to heal the application.
clearview has been applied to firefox with a high degree of success and resilience to attacks.
sidiroglou et al.
developed an approach named assure that employs rescue points to recover from unanticipated failures in desktop server linux applications.
assure utilizes online code injection and restores program execution to a rescue point where existing error handling mechanism is used to inject fault recovery code.
candea et al.
have proposed microreboots rebooting small components instead of entire applications as a recovery technique for internet services.
sultan et al.
and bohra et al.
use remote dma to perform peer monitoring and take over in a cluster.
to provide seamless service to clients.
however to the best of our knowledge we are the rst to study self healing on the smartphone platform.
627wei et al.
proposed an automated patch generation technique based on contracts.
their approach is limited to systems built using the design by contract pattern.
although their strategy has shown promising results smartphone apps are not developed using design by contract.
weimer et al.
demonstrated a fully automated genetic programming approach for nding and xing bugs.
their tool genprog identi es legal program variants for positive test cases and they generate xes with the means of structural di erences and delta debugging upon the correct program variant for the faulty input.
michail et al.
proposed a scheme to use user generated bug reports to predict future bugs in a software execution path to warn the users to avoid that path.
their scheme is based on predicting the presence of faults in a particular execution based on previous reports from the users.
the work of kim et al.
generates automatic patches from already existing patches written by human developers.
they manually inspected the human written patches and automatically develop the repair code by identifying common x patterns.
their approach requires manual e ort and might not be always practical to employ in a quick succession which is required in mobile platforms with shorter update cycle.
in contrast to these three e orts our approach does not rely on test cases or bug reports but rather reacts dynamically to a set of prede ned errors.
dallmeier et al.
s approach automatically extracts anomalies in object behavior and generate patches accordingly.
this idea may be useful on smartphone apps but it does not guarantee sealing o faulty code in a deterministic manner e.g.
random events can occur in a particular executions and the same set of faults can manifest di erently.
carzaniga et al.
employ code rewriting to work around api related faults in web applications.
they have showed their approach in popular web apis such as google maps and youtube.
while the are similarities e.g.
event driven between smartphone and web apps there are signi cant differences smartphone apps are centered around rich gestures and sensors so it is unclear how their approach would translate to smartphones.
.
conclusions we have presented an approach that uses automatic error detection and patch construction towards providing a certain degree of self healing capabilities to android apps.
we use dynamic analysis to identify crash points static analysis to identify rollback points and binary rewriting to seal o methods associated with crash points so that apps can continue to function even after a crash albeit with limited functionality.
through experiments on actual bugs in several popular apps we show that our approach is e ective and reasonably e cient.