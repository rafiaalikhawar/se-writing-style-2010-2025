frequency and risks of changes to clones nils g de university of bremen bremen germany nils informatik.uni bremen.derainer koschke university of bremen bremen germany koschke informatik.uni bremen.de abstract code clones duplicated source fragments are said to increase maintenance effort and to facilitate problems caused by inconsistent changes to identical parts.
while this is certainly true for some clones and certainly not true for others it is unclear how many clones are real threats to the system s quality and need to be taken care of.
our analysis of clone evolution in mature software projects shows that most clones are rarely changed and the number of unintentional inconsistent changes to clones is small.
we thus have to carefully select the clones to be managed to avoid unnecessary effort managing clones with no risk potential.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering general terms experimentation measurement keywords software maintenance clone detection clone evolution .
introduction code clones are similar fragments of source code.
there are many problems caused by the presences of clones.
among others the source code becomes larger change effort increases and change propagation bears the risk of unwanted inconsistencies for example incomplete removal of defects.
consequently a variety of clone detection techniques and tools has evolved to identify duplicated source code within a system.
in addition various tools have been created that support developers in managing clones.
these include refactoring support automated change propagation and change monitoring to prevent unintentional inconsistencies .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.there certainly exist clones that are true threats to software maintenance.
nevertheless recent research doubts the harmfulness of clones in general and lists numerous situations in which clones are a reasonable design decision.
from the clone management perspective it is desirable to detect and manage only the harmful clones because managing clones that have no negative effects creates only additional effort.
unfortunately state of the art clone tools detect and classify clones based only on similar structures in the source code or one of its various representations.
when it comes to clone related problems however the most important characteristic of a clone is its change behavior and not its structure.
only if a clone changes it causes additional change effort.
only if a clone changes unintentional inconsistencies can arise.
if on the other hand a clone never changes there are no additional costs induced by propagating changes and there is no risk of unwanted inconsistencies.
our hypothesis is that many clones detected by state ofthe art tools are structurally interesting but irrelevant to software maintenance because they never change during their lifetime.
up to date clone detectors can efficiently process and detect clones within huge amounts of source code consequently delivering huge numbers of clones.
in contrast clone assessment and deciding how to proceed can be very costly even for individual clones as we have experienced with clones in our own code .
hence having many unproblematic clones in the detection results creates enormous overhead for assessing and managing clones that do not threaten maintenance because they never change.
to gain a better understanding of clones threat potential we conducted an extensive study on clone evolution in different systems and performed a detailed tracking to detect when and how clones had been changed.
for this study we concentrated on two prominent clone related problems the additional change effort caused by clones and the risk of unintentional inconsistent changes.
our research questions are the following question how often are clones changed throughout their lifetime?
question how many changes to clones are unintentionally inconsistent?
contribution.
the contribution of our work is a detailed analysis of how individual clones were changed throughout their lifetime.
this includes the frequency of changes andpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
the risk of unintentional inconsistencies.
we provide an evaluation of the threat potential of clones detected by a stateof the art tool.
outline.
the structure of this papers is as follows.
section introduces important terminology and concepts.
related work is given in section .
section describes our technique to extract the necessary clone evolution data.
the setup of our study is outlined in section .
the data we collected and our results are presented in section .
we discuss our results in section .
our conclusions are provided in section .
.
terminology in this section we introduce relevant terminology.
clone detection representation and analysis can be done on different abstractions of a system each of which has advantages and disadvantages.
approaches may be based on text tokens abstract syntax trees graphs or metrics .
we use a token based approach that treats the system s files as sequences of tokens.
tokenbased approaches are language independent except for the lexer that translates source text into a sequence of tokens and scalable while maintaining a basic understanding of the program s structure.
afragment is a contiguous section of source code.
as such a fragment has a well defined start and end and is contained in exactly one file in exactly one version of the system.
a fragment has an arbitrary number of ancestors which are its occurrences in the previous version of the system.
each fragment has zero or one descendant which is its occurrence in the next version of the system.
aclone pair relates two fragments that are similar to each other and are contained in the same version of the system.
the degree of similarity is expressed by different types type .
the token sequences of both fragments are identical disregarding whitespace and comments.
type .
a type clone pair but values of identifiers and literals may differ.
type .
a type clone pair with gaps that is some tokens exist in only one of the fragments.
in contrast to a clone pair a clone class groups two or more similar fragments.
like a clone pair we assign one of the three types to a clone class to describe the similarity between its fragments.
regarding type clone classes it is important that the clone class relation is not transitive fragment abeing similar to bandbbeing similar to cdoes not imply that ais similar to b. details on how we construct type clone classes are given in section .
.
cloned fragments and the relations between them can be represented as a hypergraph where fragments are vertices the clone class relation are hyperedges connecting two or more fragments of the same version and the ancestor relation are normal edges connecting two fragments from subsequent versions.
let this be the clone evolution graph .
figure shows our visualization of a sample graph.
each horizontal layer represents a version of the system.
cloned fragments the vertices are represented as circles.
rectangles are clone classes hyperedges containing the respective fragments.
a shaded rectangle indicates that the fragments of the clone class have been changed between this version where the clone class is shaded to the next.
a light shade indicates a consistent change that is exactly the same modifications have been applied to each fragment of the clone v4v3v1 v2 cf cf cf cf figure example of an evolution graph class.
a dark shade indicates an inconsistent change that is at least one fragment has been changed but not all fragments have been changed in the same way.
fragments are connected to their ancestors and descendants by lines normal edges .
aclone genealogy is a connected component in the clone evolution graph.
as such it is a set of classes all of which are connected by the ancestry of their fragments.
for example the graph in figure shows four clone genealogies.
.
related work this section presents previous research related to ours regarding the impact of clones on maintainability.
for a general overview of research on software clones please refer to .
previous work can be roughly classified into two categories.
first studies targeted at clone evolution and the ways in which clones change.
second studies analyzing the harmfulness of clones.
.
clone evolution one of the first studies on clone evolution has been conducted by kim and her colleagues .
they analyzed the lifetime occurrence of consistent changes and suitability for refactoring of clone genealogies in two small java systems.
although their study has been a major inspiration our work differs in the way that we use a more detailed clone tracking based on individual fragments and we analyze changes for individual genealogies in more detail.
aversano and her colleagues extended kim s study with focus on the consistency of changes.
they inspected individual changes and classified them according to whether clones evolved independently or were unknowingly changed inconsistently.
in contrast to our study they inspected individual changes not considering repeated changes to the same clones.
furthermore clones that never changed were not considered.
bakota and colleagues analyzed change anomalies in the evolution of clones.
they map individual fragments instead of clones classes between versions.
in their case study they found anomalies in the evolution of mozilla firefox of which six have been classified as true defects.
the change frequency of clones has not been investigated.
the consistency of changes to clones has been quantitatively investigated by krinke .
analyzing changes to clones in five different systems he found that the number of consistent changes and inconsistent changes are roughly the same.
clones that never change repeated changes to312the same clones and harmfulness of changes have not been analyzed.
in one of our previous studies we analyzed clone evolution in nine different systems.
although we performed a quantitative comparison of change consistency we did neither analyze the frequency of changes for individual clones nor evaluate the harmfulness of changes.
thummalapenta and colleagues analyzed change patterns in the evolution of code clones.
they found that most clones were consistently changed or deliberately evolved independently.
hence most inconsistent changes were intentional.
the change frequency of clones has not been considered.
while changes to clones have been analyzed in various studies the clones that never change have been neglected.
furthermore repeated changes of the same clone have not been analyzed so far.
.
harmfulness of clones while it is frequently stated that clones negatively affect software maintenance there is not much proof that they really do.
regarding the problem of clones increasing the effort to change the code there is hardly any work to quantify the additional effort.
while it is not known how much additional change effort is caused by clones and how many clones are responsible for this previous studies have shown that some additional effort must exists since numerous consistent changes to clones have been detected.
lozano and her colleagues analyzed whether functions change more often when having clones.
their initial results suggest that functions change more often when they have clones compared to when they do not have clones.
nevertheless the following study by lozano and wermelinger showed that change effort did not increase for more than half of the methods despite having clones.
only recently juergens and deissenboeck presented an analytical model to quantify the additional maintenance costs caused by clones.
the model has not been evaluated yet.
regarding the risk of unintentional inconsistent changes to clones different studies have shown that this problem exists.
li and colleagues identified defects based on similar clones that have similar but not identical sets of identifiers.
they found defects when analyzing suspicious clones.
bakota and colleagues detected six defects based on their analysis of change anomalies in the evolution of clones.
clones in linux and eclipse have been analyzed by jiang and colleagues .
in addition to the clone itself they analyzed each clone s context to find defects.
out of spurious clones and their context they detected defects.
juergens and his colleagues with the help of system experts checked clones that are similar but not identical for defects.
out of candidates were found to contain defects of different severity.
the studies show that at least some clones facilitate defects.
nevertheless all studies except for the one by bakota and his colleagues analyzed clones in a single version.
it is thus possible that the defects were caused by something else than an inconsistent change.
.
extracting genealogies this section explains how we extract the clone evolution graph from the history of a system.
the process is based on our incremental clone detection algorithm for efficientlydetecting clones in multiple versions of a system .
the algorithm processes versions of the system one after another.
for each version the following steps are performed process changed files and update data structures.
detect clones for the current version.
map clones between previous and current version.
these steps are repeated for every version until no more versions are available.
.
processing changed files processing changed files is done as in the algorithm s original version.
we distinguish three primary ways in which a file can be changed addition deletion and modification .
apart from that the algorithm also supports renaming of files.
which files have been changed or renamed is given as input to our algorithm.
the algorithm internally uses a suffix tree to detect duplication.
for details on how changed files are processed and the suffix tree is updated please refer to .
when a modified file is processed we calculate the difference between the file s old and new version.
this information is needed later when fragments are mapped.
we use our implementation of myers algorithm which we adopted to work for token sequences.
.
detecting clones in this phase the clones that exist in the current version of the system are detected using a two step process.
first type clones are extracted from the suffix tree.
we deliberately do not extract type clones at this point because this yields repetitive structures with a high ratio of identifiers which are primarily irrelevant clones.
by first extracting only type clones we ensure that there are identical parts of sufficient length before allowing any differences.
in the second step neighboring type clones are merged to larger clones of types and .
we use a simple algorithm inspired by baker s approach to extract type clone classes identical fragments from the suffix tree.
to exclude irrelevant clone classes for example where each fragment is a single token we apply a minimum length that fragments are required to have.
note that this is not the minimum length for the final clones as specified by the user.
detection of type and type clones is done by merging neighboring type clones and inspired by previous work by ueda and colleagues .
the type clone classes that have been extracted from the updated gst are first expanded to type clone pairs.
these pairs are sorted into buckets according to the two files that contain the fragments.
each bucket is sorted based on the location of the pairs fragments.
each bucket is processed separately.
the pairs are processed in sequence.
for each pair the algorithm checks whether it can extend one of the previous pairs.
two fragments are close enough if the distance dbetween the fragments equals or is less than the shorter of the two fragments.
this is driven by the assumption that the differences may not be larger than the similarities.
in practice we have observed that the differences are always much less than the similarities if pairs are merged using this rule.
if the corresponding fragments of both pairs are close enough the clone pairs can be merged.
we provide an example in figure with two files aandb and three clone pairs a b c each of which has one fragment3132 a c b a8 9b b c a 12d figure merging clones in each file.
assume that the pairs are processed c b a .
the first pair ccannot extend any pair because it is the first one to be processed.
pair bcannot extend c because the fragments are twisted that is in file a c s fragment is located before b s fragment whereas in file b c s fragment is located after b s fragment.
nevertheless clone pair acan extend clone pair b because the gaps are one and two tokens long and the shortest fragment is two tokens long.
using the described procedure our algorithm establishes chains of clone pairs that can be merged into a single but larger clone pair.
that is the algorithm merges an arbitrary number of clone pairs into a single pair obeying a user specified minimum length.
the algorithm has worst case quadratic complexity with respect to the number of identical pairs.
nevertheless the number of identical pairs is usually small and we exploit the sorting to eliminate unnecessary calculations where possible.
after the gapped clone pairs have been created they are grouped again into clone classes according to their similarities.
this is done based on the common subsequence of the pair s fragments.
for a gapped clone pair that has been merged from smaller type clone pairs the common subsequence is the concatenated token seqeunce of the type pairs.
we combine the fragments of two pairs into a single clone class when the common subsequences of both pairs are identical.
finally we check the type of each merged clone class.
if the gaps the non identical parts between the fragments consist of only identifiers and literals the clone class is of type otherwise of type .
the final set of clones contains type clone classes the ones initially extracted as well as type and type clone classes that have been merged.
we then discard all type1 clone classes whose fragments are shorter than a userspecified minimum clone length.
this cannot be done earlier because we required the shorter type classes for merging.
furthermore we exclude all type clone classes whose fragments are completely contained in the fragments of another clone class of type or this can happen when the fragments of the type clone class have been merged .
.
mapping clones the goal of mapping fragments is to find for each fragment in the current version its ancestors in the previous version.
mapping fragments is relatively simple for files that are added or remain unchanged.
all fragments in an added file have no ancestors.
note that duplicated files are also treated as added.
for unchanged files each fragment has exactly one ancestor which is found at exactly the same location.
for modified files we exploit the difference information which has been calculated when changed files have been processed.
for each fragment of the system s previous versionthat is contained in a modified file we calculate its occurrence in the current version using the difference information being a list containing information about added or deleted token chunks.
the occurrence is calculated by processing all modifications that affect the fragment.
if tokens are added or deleted before the fragment its location is adjusted accordingly.
if tokens are removed or added within the fragments bounds the fragment becomes shorter or longer respectively.
after the relevant modifications have been processed the calculated occurrence of the fragment describes how the fragment would look like in the current version if it still existed.
after calculating a fragment s hypothetical occurrence the algorithm checks whether there exists a cloned fragment in the system s current version that equals the calculated occurrence.
the check can be done in constant time using a hash value computed from the fragments locations.
if such a fragment is found the fragment from the previous version is added to the set of ancestors of the fragment in the current version.
note that our mapping technique is independent from the source of the difference information.
we currently use a standard differencing algorithm but the information might also come from other sources for example an ide.
.
study setup this section describes the setup that we used to collect the data we need to answer the research questions.
the setup includes our choice of subject systems parameters for our clone detection tool and an overview of our procedure to collect relevant data.
.
subject systems we used the following three subject systems for our study.
our first subject system is our token based clone detection tool clones itself.
clones is written in ada and part of the bauhaus project1.
we included this system because our knowledge of the code allows us to much better assess clones and changes to clones in the code.
the second system is the web server httpd .2httpd is part of the apache project and written in c. our third subject system is jabref .3jabref is a