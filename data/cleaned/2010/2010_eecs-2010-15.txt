oracle guided component based program synthesis susmit kumar jha sumit gulwani sanjit a. seshia ashish tiwari electrical engineering and computer sciences university of california at berkeley technical report no.
ucb eecs february 2010copyright by the author s .
all rights reserved.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission.
acknowledgement the uc berkeley authors were supported in part by nsf grants cns0644436 and cns and by an alfred p. sloan research fellowship.
the fourth author was supported in part by nsf grants cns0720721 and csr .oracle guided component based program synthesis susmit jha ucberkeley jha eecs.berkeley.edusumit gulwani microsoftresearch sumitg microsoft.comsanjit a. seshia ucberkeley sseshia eecs.berkeley.eduashish tiwari sriinternational tiwari csl.sri.com abstract we present a novel approach to automatic synthesis of loopfree programs.
the approach is based on a combination of oracle guided learning from examples and constraint bas ed synthesis from components using satisfiability modulo theo ries smt solvers.
our approach is suitable for many applications including as an aid to program understanding tasks such as deobfuscating malware.
we demonstrate the efficiency and effectiveness of our approach by synthesizing bit manipulating programs and by deobfuscating programs.
categories andsubject descriptors d. .
automatic programming i. .
program synthesis k. .
concept learning keywords program synthesis oracle based learning smt sat .
introduction automatic synthesis of programs has long been one of the holy grails of software engineering.
it has found many practical applications generating optimal code sequences optimizing performance critical inner loops genera ting general purpose peephole optimizers automatin g repetitive programming tasks and filling in low level details after the higher level intent has been expressed .
two applications of synthesis are of particular interest in this paper.
the first is that of automating the discovery of non intuitive algorithms e.g.
.
the second applic ation as we show in this paper is program understanding and more specifically program deobfuscation .
the need for deobfuscation techniques has arisen in recent years especially due to an increase in the amount of malicious and mostly obfuscated code malware .
currently human experts use decompilers and manually deobfuscate the resulting code see e.g.
.
clearly this is a tedious ta sk that could benefit from automated tool support.
a traditional view of program synthesis is that of synthesis from complete specifications.
one approach is to give a specification as a formula in a suitable logic .
another is to write the specification as a simpler but possibly far less efficient program .
while these approaches have the advantage of completeness of specification such specifications are often unavailable difficult to write or expensive to check against using automated verification techniques.
in this paper we propose a novel oracleupdated version is available at the following url icse10.htmlguided approach to program synthesis where an i o oracle that maps a given program input to the desired output is used as an alternative to having a complete specification.
the key idea of our algorithm is to query the i o oracle on an input that can distinguish between non equivalent programs that are consistent with the past interaction with the i o oracle.
the process is repeated until a semantically unique program is obtained.
our experimental results show that only few rounds of interaction are needed.
we apply the oracle guided approach to automated synthesis of loop free programs those that compute functions of their input and terminate.
such programs arise in a variety of application contexts such as low level bit manipulati ng code scientific computing kernels parts of control softwa re in graphical languages such as labview and even applications in high level scripting languages such as javascri pt and ruby that are formed by chaining multiple high level operators.
a key characteristic of our method is that it is component based meaning that we synthesize a program by performing a circuit style loop free composition of comp onents drawn from a given component library.
we can also address the challenge of identifying whether the given set of components is insufficient to synthesize the desired program.
for this purpose we additionally require making only one query to a more expensive validation oracle that checks whether the program is correct or not.
our synthesis algorithm is based on a novel constraintbased approach that reduces the synthesis problem to that of solving two kinds of constraints the i o behavioral constraint whose solution yields a candidate program consistent with the interaction with the i o oracle and the distinguishing constraint whose solution provides the input that distinguishes between non equivalent candidate programs.
these constraints can be solved using off the shelf smt satisfiability modulo theory solvers.
traditional synthesis algo rithms perform a expensive combinatorial search over the space of all possible programs.
in contrast our technique leaves the inherent exponential nature of the problem to the underlying smt solver whose engineering advances over the years allow them to effectively deal with problem instances that arise in practice which are usually not hard and hence end up not requiring exponential reasoning.
contributionsandorganization.
we propose a novel oracle guided approach to synthesis where an i o oracle obviates the need for complete specifications.
our approach has interesting connections to results from computational learning theory section .
we present an instantiation of the oracle guided approach to synthesis of loop free programs over a given set of components see problem definition in section .
this is enabled by a novel constraint based technique that involves an interaction between smt solvers and the i o oracle section .
we also present an interesting optimization that leverages biased sampling section .
.
we demonstrate the utility of our synthesis technique to discovery of bit manipulating programs which are often needed for optimizing performance section .
.
these programs are quite unintuitive and can be difficult for even expert programmers to discover.
the upcoming 4th volume of the classic series the art of computer programming by knuth has a chapter on bitwise tricks .
we propose a novel application of program synthesis to program understanding.
we demonstrate this in the context of malware deobfuscation by deobfuscating examples drawn from and inspired by the conficker and mydoom viruses using our synthesis technique section .
.
.
motivatingexamples we present two examples in this section to introduce the synthesis problem and motivate our approach.
.
bit manipulation consider the following programming problem given a bit vector integer x of finite but arbitrary length construct a new bit vector ythat corresponds to xwith the rightmost string of contiguous 1s turned off i.e.
reset to 0s.
such programming problems often arise while developing low leve l embedded code network applications or in other domains where bit level manipulation is needed.
let us contemplate writing a formal specification for this problem.
the most natural and easiest specification involve s the use of alternating quantifiers where nis the length of x i j. i j n k.j k i x k. k j x x i n k.i k n x y k. k i y the above specification is not easy to write.
moreover verifying any candidate implementation against the above specification is challenging due to the presence of quantifiers.
let us consider writing some sample input output pairs or examples for the problem.
for any input x it is easy to provide the corresponding output y. some example x y pairs are .
finally let us contemplate writing a program for the above problem.
a straightforward but inefficient implementatio n is a loop that iterates through the bits of xand zeroes out the rightmost contiguous string of 1s.
can we synthesize a shorter and more efficient implementation?
it is difficult to answer this but it is easy to speculate that the elementary operations that may be used inside such an efficient implementation will be the standard bit vector operators bit w ise logical operations and basic arithmetic operations .
given a set of possible elementary operations and an ability to generate outputs for given inputs our oracle guided synthesis tool brahma will synthesize the following nontrivial and tricky procedure for solving the above problem.
1turnoffrightmostonebitstring x t1 x t2 x t1 t3 t2 3t4 t3 x return t4 a programmer will require considerable familiarity withbit level manipulations to come up with such an implementation.
hence automated synthesis of such difficult to wri te programs is of great practical significance.
.
deobfuscation a major challenge of dealing with malware is simply to understand what the malicious code is we introduce here an example inspired by the obfuscations introduced in variants of mydoom an e mail virus affecting microsoft windows that became the fastest spreading virus when it was first released in .
the example involves the construction of the smtp header for the e mail sent by the virus.
smtp requires a prescribed sequence of messages of different types initially starting with a hello message followed by the from reply to and other similar control fields followed finally by the data segment of the e mail.
the fragment we have constructed is a program genstringobs given in figure which constructs a string corresponding to the message type.
we used two types of obfuscations in this example.
the first is a control flow obfuscation drawn from several obfuscations given by collberg et al.
.
the second obfuscation is one that is directly used in mydoom involving the modification of each alphanumeric character in the message type string by the rot13 substitution cipher .
the reader can appreciate the difficulty of decoding exactly what this program is is there a simpler deobfuscated program that performs the same function as genstringobs ?
it is difficult to answer this question.
however looking at the obfuscated code in figure it is easier to guess that a deobfuscated program will probably use the following types of components conditional if then else ternary operators boolean expressions that occur in genstringobs and operators that return strings of size bounded by size of the largest string in genstringobs .
given these components and the obfuscated program genstringobs our oracle guided synthesis tool brahma automatically computes the deobfuscated program given in figure .
the reader can appreciate how much easier this program is to understand.
.
problem definition the goal is to synthesize a loop free program using a given set of base components and using input ouput examples.
we assume the presence of an i o oracle that can be queried on any input.
the i o oracle when given an input returns the output of the desired program that we wish to synthesize on that input.
we also assume the presence of a validation oracle that validates the correctness of a candi date program.
finally we assume that we are given a set of base components that should be used as building blocks in the synthesized program.
each component is given in the form of its input output specification which is written as a logical formula relating the inputs and the outputs of that component.
for ease of presentation we assume that all components have exactly one output.
we also assume that all inputs and outputs have the same type.
these restrictions are easily removed.
formally the synthesis problem in our proposed programming methodology requires the following a validation oracle vthat given any candidate program1genstringobs int input 3a1 a2 b1 b2 c1 c2 4if input a1 a2 b1 b2 6else if input c1 c2 8else if input a1 a2 c1 c2 10else if input b1 b2 c1 c2 12else return null 13c c1 c2 14if c return rot13 epcg gb 15else 16if c if input input return rot13 epcg gb else return rot13 ruyb 22else if b1 b2 return rot13 znvy sebz else if a1 a2 b1 b2 return rot13 ruyb else return rot13 qngn 29rot13 char buf int sz 31char buf1 malloc sz sizeof char 32char a 33while a buf buf1 a a 36buf buf1 38return buf1 figure obfuscated program inspired by mydoom 1genstring int input if input return ehlo 3else if input return rcpt to 4else if input return mail from 5else if input return data 6else return null figure deobfuscated version of genstringobs constructed from base components returns a boolean answer indicating whether the candidate program is the desired one or not.
we discuss how a validation oracle can be implemented for the program classes considered in this paper in sections .
and .
.
an i o oracle ithat given any program input returns the output of the desired program on that input.
a set of specifications an bracketle t vectorii oi i vectorii oi an bracketri ht i ... n called a library where vectorii oi i vectorii oi an bracketri htis the specification for the base component fi which includes a tuple of input variables vectoriiand an output variable oi an expression i vectorii oi over variables vectoriian specifies the input output relationship of the i th component.
all variables vectorii oiare assumed distinct.
the goal of the synthesis problem is to synthesize a programpthat can be validated by the validation oracle v i.e.
v p true.
furthermore program pshould be constructed using only the set of base components in the library i.e.
programpshould take vectorias its inputs and use the set o1 ... o n as temporary variables in the following form p vectori o 1 f 1 vectorv 1 ... o n f n vectorv n returno n where c1.
each variable in vectorv iis either an input variable from vectori or a temporary variable o jsuch thatj i and c2.
1 ... nis a permutation of ... n .
programpabove appears to be a straight line program but in fact it can be more complex because the base componentsfi s can be complex.
in particular base components can be if then else functions and using these component s programpcan describe arbitrary loop free programs.
we note that the program pabove is using allcomponents from the library.
we can assume this without any loss of generality.
even when there is a correct program pusing fewer components that program can always be extended to a program that uses all components by adding dead code.
dead code can be easily statically identified and removed in a post processing step.
we also note that program pabove is using each base component only once.
we can assume this without any loss of generality.
if there is a program pusingmultiple copies of the same base component we assume that the user provides multiple copies explicitly in the library.
such a restricti on of using each base component only once is interesting in two regards.
first it can be used to enforce efficient or minimal programs.
second it prunes the search space of possible programs making the synthesis problem finite and tractable.
informally the synthesis problem is to come up with a program using only the base components in the given library that is accepted by the validation oracle.
.
oracle based synthesis in this section we provide our solution for the program synthesis problem formally described above.
our solution is based on encoding the space of all possible programs by a formula section .
.
given a set of input output pairs we then constrain this formula further so that it encodes only those programs that work correctly on the given inputoutput pairs section .
.
by solving this constraint we generate a candidate solution.
if the candidate solution is not the desired program we provide a way to generate a new input output pair section .
.
the overall procedure tha t combines these parts to solve the program synthesis problem is presented in section .
.
we present enhancements to our basic procedure in section .
.
.
background encoding programs we present an encoding of the space of well formed candidate programs that is of programs psatisfying constraints c1 and c2 as formulas.
this encoding is drawn from recent work .
note however that the material in subsequent sections depends only on the existence of such an encoding.
our proposed approach can be used with alternative encodings as well.
intuitively the encoding we use involves viewing the space of candidate programs as all ways of connecting components from the library that satisfy syntactic and semantic wellformedness constraints.
each connection is encoded using a n integer valued location variable .
put another way the value of a location variable determines which component goes on which location line number and from which location lin enumber or circuit input it gets its input arguments.
the main property of the encoding that our approach relies upon is distilled into the following theorem.
this theorem states the existence of two formulas encodings the first formula wfprepresents the set of all syntactically wellformed programs whereas the second formula funcrepresents the set of all semantic input output behaviors of a well formed program.
theorem .there exists a set of integer valued location variablesl awell formedness constraint wfp l overl a mapping lval2prog and a functional constraint func l vectori o overl vectori o such that the following properties hold lval2prog is a bijective mapping from the set of values l that satisfy the constraint wfp l to the set of programs that satisfy constraints c1 and c2.
letl0be a satisfying assignment to the formula wfp.
if and are any candidate input and output values then the formula func l0 is true iff the program lval2prog l0 returns the value on the input .
the proof of theorem follows from the results stated in .
we now describe the encoding more formally.
let pand rdenote the union of all formal inputs parameters and formal outputs return variables of the components respec tively that is p sn i vectoriir sn i oi o1 ... o n any straight line program constructed using ncomponents can be described by a set of location variables l l lx x p r that contains one new variable lxfor each variable xin p rwith the following interpretation associated with each of these variables.
ifxis the output variable oiof the component fi thenlx is the line number in the program where the component fiis used.
ifxis thejthinput parameter of the component fi then lxis the line number from where component figets its jthinput .
in the above description line number refers to either a line of the program or to some input.
for uniformity each input in vectoriis assigned a line number from ... vectori and the program line numbers then take values from vectori ... vectori n .
letm vectori n. the variables ltake values in the range ... m and these new line numbers have the following interpretation.
for j vectori line number jis blank it takes the valueof thejthinput of the program.
for vectori j m line number jcontains the j vectori th assignment statement of the original program p. the well formedness constraint wfp l defined below encodes the interpretation of the location variables lxalong with syntactic well formedness constraints such as consi stency and acyclicity constraints.
wfp l def x p lx m x r vectori lx m cons l acyc l consdef x y r x ne ationslash y lx ne ationslash ly acycdef n i x vectorii y oilx ly the consistency constraint consencodes that every line in the program should have at most one component while the acyclicity constraint acycencodes that every variable should be initialized before it is used.
the function lval2prog returns the program corresponding to a given valuation las follows in the ithline of lval2prog l we have the assignment oj fj o .. o t ifloj i lik j lo k fork .. t wheretis the arity of component fj and i1 j .. it j is the tuple of input variables vectorijoffj.
the well formedness constraint describes syntactically correct programs but it does not describe th e semantics of these programs.
the functional constraint func l vectori o is obtained by taking wfp l and adding to it constraints capturing the dataflow semantics and semantics of components.
func l vectori o def p r wfp l lib p r conn l vectori o p r lib p r def n i 1 i vectorii oi conn l vectori o p r def x y p r vectori o lx ly x y where librepresents the semantics of the base components that relates the inputs and outputs of each component and connrepresents the dataflow semantics that matches the inputs and output of the different components and the inputs and output of the overall program with each other in accordance with values of location variables .
the formula func l vectori o represents the class of all syntactically well formed programs p constructed using only thenbase components that on input vectorireturn output o. hence we can solve the program synthesis problem by finding appropriate values for the lvariables.
we need to find values forlsuch that the input output behavior of the resulting program matches the input output behavior specifie d by the i o oracle.
a key step in our solution of the program synthesis problem is to synthesize programs that work for finitely many input output pairs .
we discuss this next.
.
i o behavioralconstraintin this section we show how to generate a constraint whose solution provides a candidate program whose inputoutput behavior matches a given finite set of input output examples.
given a set eof input output examples j j j we use the notation behave eto denote the following constraint which we refer to as i o behavioral constraint .
behave e l def j j e func l j j letl0be a set of values such that behave e l0 is true.
it follows from the definition of the i o behavioral constrain t that the program encoded by l0will give output j whenever it is given an input j for all pairs j j ine.
this property of the i o behavioral constraint is stated below.
theorem i o behavioral constraint .
for any satisfying solution l0to the i o behavioral constraint the input output behavior of the program lval2prog l0 matches all the input output examples in the set e. the proof of the above theorem is immediate from the definition of an i o behavioral contraint and theorem .
we next check if the program which is synthesized by considering finitely many input output pairs is the desire d program.
we want to avoid the use of the validation oracle since it is expensive.
here we use what is perhaps the central idea of our approach generate a distinguishing input that differentiates this program from another candidate program .
.
distinguishing constraint in this section we show how to generate a constraint whose solution provides an input that distinguishes a given candidate program from another non equivalent candidate program both of which have a given set of input output pairs in their respective input output behavior.
letebe a set of input output pairs.
let pbe a candidate program defined by values l whose input output behavior matches the set e. supposepis not the desired program.
then there should be some input vectorisuch thatp gives incorrect output on vectori.
but how do we find such an vectori?
ifpis not the desired program then let us assume that there is a correct program p .
clearly for all input output pairs j j ine the program p should return jwhen it is given input j. but since pis not the desired program whereasp is the desired program pandp should give different outputs on some new input.
we say vectoriis a distinguishing input if there is another programp whose input output behavior also matches e but pandp give different outputs on the input vectori.
the constraintdistinct e p vectori defined below represents the set of all distinguishing inputs vectoriand we refer to it as distinguishing constraint .
distinct e l vectori def l o o behave e l func l vectori o func l vectori o o ne ationslash o theorem distinguishing constraint .
if is a satisfying solution to the distinguishing constraint distinct e p vectori then there exists a program p such that pandp have different behaviors on input but have the same behavior on all the inputs in the set e.the proof of theorem follows from the definition of the distinguishing constraint theorem and theorem .
we now have all the ingredients for describing our overall procedure for solving the synthesis problem.
.
oracle guided synthesis in this section we describe our oracle guided iterative sy nthesis procedure.
the description uses the i o behavioral constraint and the distinguishing constraint described ab ove.
the procedure works by iteratively synthesizing new programs that work correctly on more and more inputs.
it starts with a set containing just one arbitrarily chosen inp ut.
in each iteration the procedure synthesizes a program that works correctly on the current finite set of inputs.
if such a program is found then the procedure attempts to find a distinguishing input.
if a distinguishing input is found then it is added into the set of inputs for subsequent iterations.
in all other cases the procedure terminates.
it either return s the correct program or it notes that the components provided are insufficient for synthesizing the correct program.
for solving the i o behavioral constraint and the distinguishing constraint the procedure makes use of a functiont sat .
given a formula a the function t sat a searches for values for athat will make the formula true.
if successful then t sat a returns one such specific value fora.
otherwise it returns .
the function t sat is implemented as a call to a satisfiability modulo theory smt solver.
smt solvers check for satisfiability of a first order formula with respect to underlying background theories .
the pseudo code for the procedure is given in figure .
the procedure maintains a set eof input output examples constructed by querying the i o oracle ion a new input at the start of the while loop line and in each iteration of the while loop line .
in each iteration of the while loop the procedure attemps to synthesize a candidate program p represented by l that satisfies the set eof input output examples line .
if it fails then it returns failure line .
otherwise it checks in line whether the candidate programpis the semantically unique program that satisfies the given set of input output examples.
a program is semantically unique if any other program that satisfies the given set of input output examples produces the same output as the program for any other input.
if pis the semantically unique program then the procedure either returns p line or failure line depending on whether the validation oracl e vvalidatespor not.
if the candidate program is not semantically unique then an input is obtained that is added toeto help narrow down the choice of candidate programs line .
the following theorem states the correctness of procedureiterativesynthesis .
note that if the inputs vectoritake values from a finite domain then the number of iterations of the loop in the procedure is bounded by the total number of different inputs and hence in such cases the procedure is guaranteed to terminate.
theorem .if procedure iterativesynthesis given in figure returns a program p then v p is true.
if procedureiterativesynthesis returns components insufficient then there does not exist any program pconstructed from the set of base components such that v p is true.
furthermore procedure iterativesynthesis is guaranteed to terminate when the inputs vectoritake values from a finite domain.iterativesynthesis input set of base components used in construction of behave eand distinct e l output candidate program 4e 0 i 0 0is an arbitrary value for vectori 5while 6l t sat behave e l 7if l return components insufficient 8 t sat distinct e l vectori 9if p lval2prog l if v p returnp else return components insufficient 13e e i figure oracle guided synthesis procedure valid program exists with given components no program exists with given components 2step discovered semantically unique program p is found ba for synthesizing valid program.step set e of i o examples show components insufficient incorrect by the validator no synthesis feasible.
step valid program p is returned.
figure termination cases of synthesis procedure.
the validation oracle is needed only to ensure correctness in case 1b.
the proof of the correctness theorem follows immediately from the description of the procedure in figure combined with the properties stated in theorem theorem and theorem .
we also illustrate in figure all three cases in which procedure iterativesynthesis terminates.
the first case corresponds to step and the second and third cases correspond to step and step respectively.
.
illustrationonrunning example we illustrate the oracle guided synthesis approach on the running example presented in section .
.
the problem was given a bit vector integer x of finite but arbitrary length to construct a new bit vector ythat corresponds to xwith the rightmost string of contiguous 1s turned off.
our technique starts with a random input and the i o oracle i the user is used to obtain the corresponding expected output .
this step corresponds to line of the algorithm presented in figure .
given the input output pair our technique generates the following candidate program line we giv e only the expression returned x x then it checks whether a semantically different program can be generated in line .
in this case our technique generates the following alternative program and the distinguishing i nput x x the i o oracle is used to obtain the output for this input line .
this is added to the set of input output pairse.
note that the newly added pair rules out one of the candidate programs namely x x .
in the next iteration with the updated set e the technique finds the program x x and the check in line generates the alternate program x x x x x and the input .
hence we add toe.
this rules out x x x x x. note that at this stage the program x xremains a candidate since it was not ruled out in the earlier iteratio ns.
in next four iterations brahma generates and as inputoutput examples and adds them to e. the semantically unique program generated from the resulting set eis the desired program x x x. .
optimization the basic procedure described above can be improved by using alternate ways to generate the inputs that are used by the procedure for synthesis.
iterativesynthesis uses an smt solver in two ways a first an smt solver is used to generate a candidate program that works for the current set of inputs.
b second an smt solver is used to generate a new distinguishing input on which the currently synthesized program and the desired program potentially differ.
although smt solvers are fast and capable of handling very large formulas using them in every iteration compromises efficiency.
it is tempting to speculate that the use of smt solvers for generating a distinguishing input case b above can be avoided for example by replacing it by a function that finds new inputs by sampling the input space in some way.
we explore two alternative ways for sampling the input space.
samplinguniformlyatrandom letinputs be the set of all possible valuations for the input variables.
let sample inputs be a function that returns a particular input from the input space inputs by sampling the set inputs uniformly at random.
the function sample inputs can be used to find a new input in place of the call to the smt solver in line of procedure iterativesynthesis .
we will call this new variant as random .
samplingwith bias the second approach we consider is based on biasing the search for inputs towards a certain part of the input space.
not all inputs in the input space are equally important.
for example a program may take an integer input i but have the same behavior for all i and have interesting behaviors only on values i .
for many applications the user knows a priori which inputs are more crucial in defining the overall program.
the idea behind the sampling with bias strategy is to search for distinguishing inputs by bias ing the search to this part of the input space.
in the bitvector benchmarks used in this paper the input space consists of all tuples of bitvectors of a certain bit width.
it is well known that for a very large class of commonly used bitvector functions the rightmost bits influence the output more than the leftmost bits.
property see chapter .
a function mapping bitvectors to bitvectors can be implemented with add subtract bitwise and bitwise or and bitwise not instructions if and only if each bit of the output depends only onconstrainedrandominput cntis a global variable initialized to kis a parameter number of rightmost bits to set 3if cnt 2k 4 sample inputs 5 set rightmost kbits of tocnt 6cnt cnt 7else t sat distinct e l vectori figure strategy for generating a new input based on sampling from the input space with an application dependent bias.
bits at and to the right of that bit in each input operand.
this suggests that we should bias the sampling so that we get more variety on the rightmost bits.
the code constrainedrandominput in figure uses a constrained random strategy for generating a new input.
it starts with an input that is sampled uniformly at random but then it sets its rightmost kbits to the rightmost kbits in the number cnt.
sincecntis incremented each time we get a new combination in each time.
specifically if k then in four calls to the function constrainedrandominput we will get all four combinations and in the rightmost digits of i. the code constrainedrandominput finds the first 2kinputs this way.
if more are needed then it goes back to using the smt solver.
the new variant of iterativesynthesis obtained by replacing the call to the smt solver in line by the code constrainedrandominput will be called constrained random .
we will compare the performance of iterativesynthesis random andconstrained random in section .
.
discussion .
choosing basecomponents it is reasonable to ask how base components are chosen in our approach and what happens when the given set of base components is either insufficient or very large.
the choice of base components is made by the user and is guided by the application domain.
this allows the user to use his her knowledge to guide the synthesis and influence success.
it is not unreasonable to expect users to provide th is information.
in several application domains there is a nat ural choice for the set of base components.
for example a natural set of base components for synthesizing bitvector a lgorithms will contain components that perform bitwise and or not xor negation increment and decrement operations .
in our experiments on synthesizing bitvector programs sec tion we started with such a set of base components referred to as the standard library .
if the synthesis procedure found that this set of components was insufficient the standard library was augmented with a set of new components suggested by the user and the synthesis procedure was re run with this extended library .
nevertheless choosing a reasonable set of base components is crucial for the feasibility of our synthesis approa ch.
the search space of candidate programs grows exponentially with the number of base components.
the strategy of starting with a small set of base components and then incrementally adding components can partly avoid the need to dealwith very large set of base components.
however it can be successful only if the synthesis engine not only synthesize s correct programs quickly but also reports infeasibility o f the synthesis problem quickly.
in our experiments we show that our technique can detect infeasibility efficiently.
choosing base components for deobfuscation.
when using our program synthesis approach for performing program deobfuscation the base components are picked from the assignment and conditional statements in the obfuscate d code.
for example consider the obfuscated program in figure .
although it is difficult to understand the obfuscated program it is easier to guess that the set of important base components will include if then else components and equal ity comparators.
similarly for the other deobfuscation ex amples reported in section the base components used for synthesis contain only operators such as left shift an d bitwise xor that appear explicitly in the obfuscated code see figure .
.
connections to learning our oracle guided synthesis framework has close connections to certain fundamental results in computational lear ning theory.
we explore these connections in this section.
our oracle based model is similar to the query based learning model proposed by angluin but with some important distinctions.
in angluin s model a learner interacts with an oracle through the use of membership andequivalence queries in order to learn a target concept .
in our setting thetarget concept is the program we seek to synthesize.
a membership query is similar to the query we make to an i o oracle except that the former returns a binary answer whereas the i o oracle returns an output value.
an equivalence query is similar to a query to the validation oracle except that in angluin s model if the candidate concept is not equivalent to the target concept the oracle returns a counterexample as evidence for this non equivalence.
in our context since the validation oracle is called only at th e end when we are left with a semantically unique program consistent with the set of examples such a counterexample is not needed.
moreover angluin s model treats both kinds of queries as equally expensive.
we make a distinction between the cheaper queries to the i o oracle and the more expensive queries to the validation oracle which allows us to optimize our implementation.
finally our algorithm itera tes by finding distinguishing inputs which is not an operation supported by angluin s model.
two other results from learning theory also shed light on why our oracle based approach is effective in practice.
first note that our focus on loop free programs that compute functions of finite precision bit vector inputs indic ates a connection to the work on learning boolean circuits.
in particular the classic result on learning constant depth boo lean ac0 circuits from a few test inputs provides a partial explanation for the effectiveness of this strategy.
the resu lt relies on a theorem stating that ac0circuits can be approximated well by low degree polynomials which in turn are known to be identifiable by their behavior on few inputs.
the second relevant result relates to the notion of teaching dimension introduced by goldman and kearns .
informally the teaching dimension of a concept class is the minimum number of examples a teacher oracle must reveal to uniquely identify anytarget concept from that class.
as our experiments show we need very few examples to synthesize our target programs in practice indicating that th eseprograms form a concept class with a low teaching dimension.
moreover our algorithm fits closely with a result from the goldman kearns paper showing that the generation of anoptimal teaching sequence of examples is equivalent to a minimum set cover problem.
in the set cover problem for a given target concept the universe of elements is the set of all incorrect concepts programs and each set si corresponding to example xi contains concepts that are differentiated from the target concept by this example xi.
we can see that our procedure iterativesynthesis computes such a distinguishing example in each iteration and terminates when it has computed a set cover that distinguishes the target concept from all other candidate concepts the universe .
given this close connection it does seem that the classes of functions corresponding to the bit manipulatin g and deobfuscation examples we consider have small teaching dimension and also procedure iterativesynthesis is effective at generating a sequence of examples close to the optimal teaching sequence.
these connections to learning theory are very intriguing.
we leave a formal exploration of these links to future work.
.
experimental results we present experimental evaluation of our technique and compare different approaches namely iterativesynthesis random andconstrained random discussed in section .
setupandbenchmarks.
we have implemented iterativesynthesis in a tool called brahma .
it uses yices .
.
as the underlying smt solver.
we ran our experiments on 8x intel r xeon r cpu .86ghz with 4gb of ram.
brahma was able to synthesize the desired circuit for each of the benchmark examples.
semi biased brahma implements constrained randomwith the parameter k .
thus it differs only in first steps from brahma .
as mentioned in section this is specially targetted towards synthesis of bitvector progra ms. we selected a set of benchmark examples to evaluate our technique.
benchmarks p1 p22 are bit manipulatio n programs from the book hacker s delight commonly referred to as the bible of bit twiddling hacks .
benchmarks were used as examples to illustrate the use of our technique for deobfuscation.
these benchmarks reflect obfuscation strategies from literature on obfuscation techniques p23 and internet worms conficker p24 and mydoom p25 .
some of these examples are presented in figure and figure .
.
bit manipulating programs recall from section .
that the bitvector benchmarks were run using a standard library of base components and if necessary an extended library .
in table we report the runtime when using the standard library col. and when using the user augmented extended library col. in case the standard library was not sufficient.
note that our tool quickly terminates when the given library is insufficient.
for bitvector benchmarks the user plays the role of the i o oracle as well as the validation oracle.
if the user guarantees that the provided set of base components is sufficient to encode the desired solution then we do not require the validation oracle.
otherwise it is theoretically impossi ble to know whether or not the generated solution is the correct one without a validation oracle.
however in practice our algorithm detects insufficiency of the base componentsbench random inputs semibiased brahma names runtime iter runtime runtime iter standard lib extended lib p1 .
.
.
p2 .
.
.
p3 .
.
.
p4 .
.
.
p5 .
.
.
p6 .
.
.
p7 .
.
.
p8 .
.
.
p9 .
.
.
p10 .
.
.
p11 .
.
.
p12 .
.
.
p13 .
.
.
p14 .
.
.
p15 .
.
.
p16 .
.
.
p17 .
.
.
p18 .
.
.
p19 .
.
.
p20 .
.
.
p21 .
.
.
p22 timeout na .
.
table random input generation and semi biased brahma on bitvector examples.
na denotes not applicable.
denotes that the extended library was same as standard library.
runtimes in sec.
bench brahma random semibiased brahma names runtime iter runtime iter runtime iter sec sec sec p23 .
.
.
p24 .
.
.
p25 .
timeout na .
table deobfuscation examples by discovering inconsistency and not by a query to the validation oracle.
this suggests that in the absence of any validation oracle we can consider the semantically unique candidate program returned by our algorithm to be the correct program for all practical purposes.
we now compare the three approaches on bit vector benchmarks using two metrics the total runtime and the number of iterations.
we present the ratio of runtimes of random input generation col of table and semi biased brahma col of table in figure a .
semi biased brahma is .
times to times faster than random technique.
for p22 the random technique did not finish in hour while semi biased brahma was able to synthesize it in seconds.
also the number of iterations required to synthesize a program is also reduced significantly as shown in table .
brahma and semi biased brahma is compared in figure b .
while the number of iterations is more for semi biased brahma it is faster than the brahma on larger benchmarks.
it reduces the runtime for p18 from .
seconds to .
seconds p21 from .
seconds to .
seconds and p22 from .
seconds to .
seconds.
this validates the optimization proposed in section .
.
deobfuscationp1 x turn off rightmost bit.
1o1 x res x o1 p2 x test whether an unsigned integer is of the form 2n 1o1 x res x o1 p3 x isolate the rightmost bit 1o1 x res x o1 p4 x form a mask that identifies the rightmost bit and trailing 0s 1o1 x res x o1 p5 x right propagate rightmost 1bit 1o1 x res x o1 p6 x turn on the rightmost bit 1o1 x res x o1 p7 x isolate the rightmost bit 1o1 x 2o2 x res o1 o2 p8 x form a mask that identifies the trailing s 1o1 x 2o2 x res o1 o2 p9 x absolute value function 1o1 x 2o2 x o1 res o2 o1 p10 x y test if nlz x nlz y where nlz is number of leading zeroes 1o1 x y 2o2 x y res o2 uo1 p11 x y test if nlz x nlz y 1o1 y 2o2 x o1 res o2 uy p12 x y test if nlz x nlz y where nlz is number of leading zeroes 1o1 y 2o2 x o1 res o2 uy p13 x sign function 1o1 x 2o2 x 3o3 o2 res o1 o3 p14 x k round upxto a multiple of k th power of 1o1 k 2o2 o1 3o3 x o2 res o3 o1 p15 x y floor of average of two integers without overflowing 1o1 x y 2o2 x y 3o3 o res o1 o3 p16 x y compute max of two integers 1o1 x y 2o2 x uy 3o3 o1 o2 res o3 y p17 x y compute min of two integers 1o1 x y 2o2 x uy 3o3 o1 o2 res o3 y p18 x y ceil of average of two integers without overflowing 1o1 x y 2o2 x y 3o3 o2 res o1 o3 p19 x turn off the rightmost contiguous string of bits 1o1 x 2o2 x o1 3o3 o2 res o3 x p20 x determine if an integer is a power of or not 1o1 x 2o2 o1 x 3o3 bvredor x 4o4 bvredor o2 5o5 !
o4 res o5 o4 p21 x next higher unsigned number with same number of bits 1o1 x 2o2 x o1 3o3 x o2 4o4 x o2 5o5 o4 6o6 o5 o2 res o6 o3 p22 x round up to the next highest power of 1o1 x 2o2 o1 3o3 o1 o2 4o4 o3 5o5 o3 o4 6o6 o5 7o7 o5 o6 8o8 o7 9o9 o7 o8 10o10 o9 11o11 o9 o10 res o10 p23 interchange the source and destination addresses.
1interchangeobs ipaddress src ipadress dest src src dest 3if src src dest src src dest 5if src src dest dest src dest if dest src dest src dest src return else src src dest dest src dest return else src src dest dest src dest src src dest return 1interchange ipaddress src ipadress dest dest src dest src src dest dest src dest 6return p24 multiply by 1int multiply45obs int y a b z c 3while 4if a if b y z y a a b b c c if c break else z z y a a b b c c if c break 11else if b z y a a else z y a a b b 15return y 1multiply45 int y 3z y 4y z y 5z y 6y z y 7return y figure bit vector p1 p22 benchmarks and deobfuscatio n benchmarks p23 p24 7ratio of runtime ratio of iteration counts bitvector benchmarksruntime iter count a ratio of runtime for random input generation to semibiased brahma .
.
.
.
.5ratio of runtime ratio of iteration counts bitvector benchmarksruntime iter count b ration of runtime for brahma to semibiasedbrahma figure runtime comparison of brahma semibiased brahma and random input generation the i o oracle involves simply evaluating the obfuscated program on the given input.
the validation oracle can be a program equivalence checking tool or the user.
an additional challenge that this domain offers is the presence of arbitrary string constants.
our synthesis framewor k can be easily extended to discovering such constants.
for this purpose we introduce a generic base component fcthat simply outputs some arbitrary constant c. the component fctakes no input and returns one output oand its functional specification is written as o c. the only change to the framework is that since cis allowed to be arbitrary we existentially quantify over cin the functional constraint funcdescribed in section .
.
for the three examples that we used in experiments observe that brahma gives the best performance.
the key observation from the experiments is that random input generation does not work well for examples such as p25 where randomly generating integers has a rare chance of in 232to pick an input which produces any of the first possible outputs.
brahma takes exactly iterations to query the i o oracle with inputs that generate all the possible outputs.
the experimental results indicate that adding a distinguishing input is better than adding a random input to e because it guarantees that atleast one candidate program is definitely removed from the search space.
thus it guarantees progress.
moreover it possibly also removes a set of other similar designs from the search space.
.
related work there is a vast body of work on automated program synthesis.
in this section we describe some of the different approaches used for program synthesis.
component based synthesis synthesis of straight line code fragments constructed fr om a given set of components has received significant attention.
from type signatures jungloid mining tool synthesizes code fragments over a given set of api methods annotated with their type signatures given a simple query that describes the desired code using input and output types .
from functional specifications uses smt solving technology to synthesize a straight line sequence of in structions from functional description of the desired code sequence.
dipacs uses an ai planner to implement a programmer defined abstract algorithm using a sequence of library calls.
the behavior of the library procedures and th e abstract algorithm is specified using high level abstractions e.g.
predicates sorted andpermutation .
it uses interaction with the programmer to prune undesirable compositions.
from unoptimal code sequences superoptimizers generate an optimal code sequence for a given straight line sequence of instructions.
one approach is to enumerate sequences of increasing length or cost testing each for equal ity with the given sequence .
another approach is to constrain the search space to a set of equality preservingtransformations expressed by the system designer and then select the one with the lowest cost.
superoptimization is useful in optimizing performance critical inner loops.
recent work has used superoptimization to automaticall y generate general purpose peephole optimizers by optimizi ng a small set of instructions in the code.
program synthesis in deductive program synthesis a program is synthesized by constructively proving a theorem which states that forall inputs in a given set there exists an output suc h that a given functional specification predicate holds.
dedu ctive program synthesis assumes that a full functional speci fication is given.
moreover it requires advanced deduction technology that is hard to automate.
in inductive program synthesis recursive programs are generated from input output examples in two steps.
in the first step a set of i o examples are written as one large conditional expression.
in the second step this initial program is generalized into a recursive progra m by searching for syntactic regularities in the initial prog ram.
in contrast we do not require a good set of i o examples be given a priori.
moreover we do not explicitly generalize generalization happens implicitly from synthesizing a function using only a given set of components.
shapiro s algorithmic debugging system performs synthesis by repeatedly using the oracle to identify errors in the current incorrect program and then fixing those errors.
we do not fix incorrect programs.
we use the incorrect program to identify a distinguishing input and then re synthesize a new program that works on the new inputoutput pair as well.
in programming by demonstration the user demonstrates how to perform a task and the system learns an appropriate representation of the task procedure.
unlike our method these approaches do not make active oracle queries but rely on the demonstrations the user chooses.
making active queries is important for efficiency and terminating quickly so that user is not overwhelmed with queries .
in programming by sketching implementations are synthesized from sketches partially specified programs w ith holes.
the sketch system uses sat solving within a counterexample guided loop that constantly interacts wit h a verifier to check candidate implementations against a complete specification where the verifier provides counterexa mples until a correct solution has been found.
in contrast we do not use counterexamples for synthesis.
further we require a validation oracle only when the specification can not be realized using the provided components.
this verifier is not required to return a counter example.
in practice we never require a query to the verifier and our technique correctly identifies infeasible scenarios without calling the validation oracle.
.
conclusion we have presented a novel approach to program synthesis based on oracle guided learning from examples and smt solvers.
applications to synthesis of bit vector programs and deobfuscation have been demonstrated.
experiments indicate that our approach can be efficient and effective for discovering unintuitive code and for program understandin g.