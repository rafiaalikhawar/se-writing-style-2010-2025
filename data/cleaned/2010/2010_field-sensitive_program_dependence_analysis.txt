see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation field sensitive program dependence analysis conf erence paper no vember .
.
sour ce dblp citations 13reads author s including shay litv ak tel aviv univ ersity publica tions citations see profile rastislav bodik univ ersity of w ashingt on publica tions citations see profile noam rine tzky tel aviv univ ersity publica tions citations see profile mooly sagiv tel aviv univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y mooly sagiv on may .
the user has r equest ed enhanc ement of the do wnlo aded file.field sensitiveprogram dependence analysis shay litvak tel avivuniversity panayainc.
shay.litvak cs.tau.ac.ilnurit dor panayainc.
nurit panayainc.comrastislav bodik universityofcalifornia berkeley bodik cs.berkeley.edu noam rinetzky queenmary universityof london maon dcs.qmul.ac.ukmooly sagiv tel avivuniversity msagiv tau.ac.il abstract statement sttransitively depends on statement stseedif the execution ofstseedmay affect the execution of st. computing transitive programdependencesisafundamentaloperationinmanyauto matic softwareanalysistools.
existingtoolsfinditchallenging tocompute transitive dependences for programs manipulating large ag gregate structure variables and their limitations adversely affe ct analysis of certain important classes of software systems e.g.
lar ge scale enterprise resource planning erp systems.
thispaperpresentsanefficientconservativeinterprocedu ralstatic analysis algorithm for computing field sensitivetransiti ve program dependences inthe presence of large aggregate structure va riables.
our key insight is that program dependences coming from oper ationsonwholesubstructurescanbeprecisely i.e.
field s ensitively represented atthe granularityofsubstructures insteadof individual fields.
technically weadapttheintervaldomaintoconcise lyrecord dependences between multiplepairsoffieldsofaggregatestructure variables byexploiting the fields spatial arrangement.
weprovethatouralgorithmisaspreciseasanyalgorithmwhich worksatthegranularityofindividualfields themost prec iseknown approach for this problem.
our empirical study in which we a nalyzed industrial erpprograms with over lines of code in average shows significant improvements inboththerunning times andmemoryconsumptionoverexistingapproaches thebasel ineis anefficientfield insensitive whole structure thatincursa62 false errorrate.
an atomization basedalgorithm whichdisassembleevery aggregate structure variable into the collection of its individual fields can remove all these false errors at the cost of doubli ng the average analysis time from to minutes.
in contrast ou r new precise algorithm removes all false errors by increasing th e time only to minutes.
in terms of memory consumption our algorithm increases the footprint by less than compared to overhead of the atomizingalgorithm.
categoriesandsubjectdescriptors d. .
software programverification general terms verification keywords adas aggregate structure variables erp fieldsensitivity transitive program dependences permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
fse november santa fe new mexico usa.
copyright acm ... .
.
.
introduction astatement sthasanimmediateprogramdependence onastatementstseedif the content of a memory location assigned by stseed affects either the value computed by stor whether stis executed at all.
a statement sthas atransitive program dependence on a statement stseedifstandstseedare in the transitive closure of the immediateprogramdependencerelation.
computingtransit iveprogram dependences is a fundamental operation in many softwar e understanding and manipulation tools.
these tools provide valuable mechanized support for the practicing software engine er.
for example transitiveprogram dependences are usedintools f or program maintenance debugging testing sem antic differencing slicing reuse and mergin g .
the problem of computing transitive program dependences ha s been extensively studied.
most of the advances in the efficie ncy and precision of the analysis come from improving the analys is contextsensitivity i.e.
itstreatmentofprocedurecalls see e.g.
and object field sensitivity i.e.
its treatment of dynamically dispatched methods in object oriented programs see e.g.
.
incontrast theproblemofimprovingtheanalysis field sensitivity i.e.
its treatment of large aggregate structure variables1has not received much attention.
this is rather unfortunate becaus e as we have found in our extensive empirical study imprecise or co stly handlingoffieldsinaggregatestructurevariablesmayhave adverse effect on the quality of the analysis results and its applic ability to certain classes of important software systems e.g.
lar ge scale enterprise resource planning erp systems.
therearetwoknownapproaches forcomputing programdependences for programs manipulating large aggregate structur e variables.
the whole structure ws approach treats the whole structure as a single variable of a primitive type.
int uitively it handles a read statement from a field fof a structure variable v as if it may read from any of the fields of v and a write statement toafieldfofvasifitmaywritetoanyfieldof v. theatomization atom approach reduces the field sensitive dependence problemintoadependenceproblemforprogramswithoutaggr egate structures by disassembling aggregate structures to their primitive components.
unfortunately in our experimental study in w hich we analyzed industrial erpprograms with over lines of code inaverage we found the wsapproach to be efficient but imprecise and the atomapproach tobe precise but inefficient.
see sections 2and .
in this paper we present adas an interprocedural static analysis algorithm for computing field sensitive transitive pr ogram dependences in the presence of large aggregate structure vari ables.
adasstands for aggregate dependence via arrangement seg1byalargeaggregatestructurevariable wemeanarecordvariable whichcontains dozens or even hundreds of fields.ments.
in our experiments we found that adashas comparable costtothe wsapproach.
in weprovethat adasprovidesthe same precisionas the atomapproach.
ourkeyinsightisthatprogramdependencescomingfromoper ationsonwholesubstructurescanbeprecisely i.e.
field s ensitively represented atthe granularityofsubstructures insteadof individual fields.
the key reason for the efficiency of adasis the use of an interval like abstract domainwhichallows toaccuratelyr ecorddependences between multiple pairs of adjacent fields in a co ncise manner.
adasworksintwostages.
inthefirststage itcomputesa rangelabeledprogramdependence graph .
aprogramdependence graph pdg is a graph whose nodes are the program statements and its edges represent immediate program dependences.
in existin g dependence analyses aprogram dependence representinga dataflow fromst1tost2 meansthatthevalueofthevariabledefinedinstatementst1 denotedby def st1 maybeusedinstatement st2.
the labels usedby adasallow torefine this information by recording on every edge the fields of variable def st1 whichget defined in st1and may be used in st2.
in the second stage adasutilizes the range labels toperform an efficient and precise computat ion of transitive program dependences over the range labeled pdg.
example .
.
fig.
a shows a program which is comprised onlyofasequenceofassignments.2theanalysisgoalistocompute the transitive dependences on the variable defined in a speci fied seed statement which in this example is variable seeddefined in statement l1.
in this example adasaccurately infers that field b.gmay only depend onfieldseed .fandthatfield b.fmay only depend onfield seed .g.
fig.
b shows the range labeled pdgof the program.
we denotetheedgeemanatingfrom e.g.
node l1 representingstatement l1 seed exp and entering node l2 representing statement l2 a seed byl1 l2.
the range label of edge l1 l2 is hatwideseed which indicates that the whole value of variable seedis defined in statement l1andgets used in statement l2.
we refer to assignment statements inwhichwhole aggregate structures are assigned as big l value operations.
for example statements l1and l2are bigl value operations.
the range label of the edge l2 l3is hatwidera.f whichindicates that only thef field ofais used instatement l3.
note that a.fis apart of variable awhose entire value gets defined instatement l2.
therange labeloftheedge l3 l5is hatwidei whichindicatesthatthe entire value ofvariable iisdefined instatement l3andgets usedin statement l5.
inthis example iisan integer variable ingeneral i may be anaggregate structure variable withdozens of fields.
adasuses the range labels to accurately and efficiently computetransitiveprogramdependences.
forexample thedepe ndence an bracketle t hatwideseed hatwideseed an bracketri htatl2is generated by the distinguished seed statement.
its propagation over the edge l2 l3transforms it into an bracketle t hatwidera.f hatwiderseed.f an bracketri ht indicating that the field a.f which is used in l3 may only depend on field seed .f.
the latter dependence when propagated over edge l3 l5 gets transformed into dependence an bracketle t hatwidei hatwiderseed.f an bracketri ht indicatingthatthe value ofvariable iatl5depends on seed.fwhich allows adasto infer that b.gmay only depended on seed.f.
weexperimentallyevaluatedthe adasalgorithmbycomparing its precision and cost with those of the known algorithms in t he 2we discuss the treatment of control flow statements multip le assignments tothe same variable destructive updates and pr ocedure invocations inthe followingsections.context of an important software engineering application helping erpengineers understand the impact of a change in the system s configuration database.3we analyzed a variety of industrial erp programs withover a line of code inaverage.
our expe riments show that in practice adasprovides the same precision as the most precise known algorithm for this problem with ave rage improvement of the running time by and of the memory consumption by .
these improvements enabled us to effective ly analyzeprogramsthatcouldnothavebeenanalyzeusingthek nown approaches.
seesection8.
.
mainresults.
themaincontributionsofthispapercanbesummarizedas follows wepresent adas anovelalgorithmforcomputingprogram dependences inthe presence of large structure variables.
weprovethat adasisasprecise asanyalgorithm basedon the atomizationapproach in .
we implemented adasinsidepanayaia an industrial impact analysis tool and successfully applied it to re allifeerpprograms of over a millionlines of code.
ourextensiveexperimentalevaluation doneinthecontext of an important engineering application shows that in practice adascompares favorablywithexisting approaches.
we note that while adasis evaluated in the context of erp systems thealgorithm itselfisof generic nature andis ofv alue for analyzing any program which uses aggregate structure varia bles.
see section9 .
outline.therestofthepaperisorganizedasfollows.
section2describes related work.
section describes standard notions pertainingtoreachingdefinitionanalysisandprogramdependenceg raphs.
section states the field sensitive dependence analysis re search problem.
section5describesournovelrange basedreachin gdefinition analysis.
sections and describe respectively the intraprocedural and interprocedural aspects of adas.
section describe our experimental evaluation and section9concludes.
wenote thatsections4 7arewrittenatamoreformallevelth an the other sections and can be skipped on first read.
also due to spacereasons proofsandseveraltechnicaldetailshavebe enomitted from the paper andappear in .
.
related work techniquesforhandlingaggregatestructureshavebeensug gested in the context of program dependence analysis see e.g.
as well as in the context of pointer analysis see e.g.
.
traditionally these techniques have mainly focu sed on analyzingpointer basedmanipulationofaggregatestruct uresinrecursivedatastructureand orbyrecursiveprocedures.
for example an efficient analysis which computes data flow dependences in the presence of heap pointers and recursive data structure is pr esented 3erpsystems are dominant in the world of business applications.
theyaretypicallycomprisedofhundredsorthousandsofpro grams whereeachprogrammaycontainoveramillionlinesofcode.
o neof thekeyreasonsforthesuccessof erpsystemsistheirmodulardesign everybusinesscanaddandcustomizepre manufacture dcode modules to meet its particular needs by what amounts to loa ding configuration attributes into in memory large aggregate st ructure variables.
these variables have an immense effect on the way that thesystemoperates.
foradditionaldiscussionon erpsystems see section8.
.struct t1 int f int g t1a b t1d seed exp inti j l1 seed exp l2 a seed l3 i a.f l4 j a.g l5 b.g i l6 b.f j l7 d b d23 d22 d21 d20 d16 d17 d18 d19 l1 seed exp hatwideseed d15 d15 d23 d22 d21 d20 d16 d17 d18 d19 l2 a seed hatwidesta.f d15 d15 hatwidesta.g d119 d119 an bracketle t hatwideseed hatwideseed an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l3 i a.f hatwidei d39 d39 an bracketle t hatwidera.f hatwiderseed.f an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l4 j a.g hatwidej d119 d119 an bracketle t hatwidera.g hatwiderseed.g an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l5 b.g i hatwiderb.g d39 d39 an bracketle t hatwidei hatwiderseed.f an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l6 b.f j hatwidestb.f d15 d15 an bracketle t hatwidej hatwiderseed.g an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l7 d b an bracketle t hatwiderb.f hatwiderseed.g an bracketri ht an bracketle t hatwiderb.g hatwiderseed.f an bracketri ht int a f a g int b f b g int d f d g int seed f seed g int exp f exp g int i j l1.
seed f exp f l1.
seed g exp g l2.
a f seed f l2.
a g seed g l3 i a f l4 j a g l5 b g i l6 b f j l7.
d f b f l7.
d g b g d23 d22 d21 d20 d16 d17 d18 d19 l1.
seed f exp f d42 d42 d23 d22 d21 d20 d16 d17 d18 d19 l1.
seed g exp g d116 d116 d23 d22 d21 d20 d16 d17 d18 d19 l2.
a f seed f d43 d43 d23 d22 d21 d20 d16 d17 d18 d19 l2.
a g seed g d115 d115 d23 d22 d21 d20 d16 d17 d18 d19 l3 i a f d41 d41 d23 d22 d21 d20 d16 d17 d18 d19 l4 j a g d117 d117 d23 d22 d21 d20 d16 d17 d18 d19 l5 b g i d41 d41 d23 d22 d21 d20 d16 d17 d18 d19 l6 b f j d15 d15 d23 d22 d21 d20 d16 d17 d18 d19 l7.
d f b f d23 d22 d21 d20 d16 d17 d18 d19 l7.
d g b g a b c d figure a a program manipulating fields b its range la beled pdg annotated with the dependences computed by the adas algorithm at every statement c theatomized version of th e program and d thepdg of theatomized program in .
efficient analysis algorithms for handling procedu res especially recursive ones are presented in works using the system dependence graph .
the twoknown approaches forhandling large aggregate str ucture variables in the area of program dependence analysis ar e the whole structure ws approach and the atomization atom approach whichhavebeendescribedinsection1.
thetwoapproachesrepresentdifferenttradeoffsbetweene fficiency and precision.
the first one is efficient but not field sensitiv e. the second one has opposite properties.
example .
.
recallthat adassuccessfullyinfersthatat l7in fig.1field b.gmay only depend onfieldseed .fandthatfield b.f may only depend onfield seed .g.
incontrast anyalgorithmbasedonthewholestructureappr oach would fail to infer such accurate information.
specifically such an algorithm can manage to compute that at l7variable bmay depend on seed.
however the field dependence is not known.
thus the results of a ws based algorithm would indicate a false may dependence of e.g.
b.gonseed.g.
theatomizationapproachcomputes informationatthesamea ccuracy levelas adas.itdoes soby transformingthe original programintotheone showninfig.
c andthenperformingstand ard dependenceanalysisonthe pdgofthetransformedprogram shown in fig.
d .
note that in particular every big l value ope ration see example .
inwhich kprimitivefields are assigned istransformed into kindividual fields assignment operations.
asshowninexample .
bothapproaches havedrawbacks the whole structure approach can yield superfluous dependences when manipulating structure fields while atomization approach may be too expensive on programs with large structures due to the l arge increase inthe totalnumber of variables andstatements .
in our case study different approaches for computing progr am dependence are evaluated by integrating different analyse s in an industrial impact analysis tool.
we applied the tool to larg e scale erpprograms.
theseprogramsmakeextensiveuseoflargeaggre gate structure variables.
we found that for the programs th at we analyzed using the known approaches isimpractical.
we note that suggests an interesting optimization for t he atomization approach.
the main idea is to use a flow insensit ive analysis that determines which fields need to be atomized.
in our experimental evaluation we have tested the applicability of this suggestion in the context of erpsystems.
our evaluation of this suggestion describedinsection8.
showsthatthisoptim izationis not effective for large scale erpprograms.
.
preliminaries in this section we describe the standard notions of reachin g definitions program dependence graphs and system depende nce graphs.
reaching definition is an iterative analysis over the contro l flow graph cfg of the program that tracks the possible last definition point for each variable that may arise at execution of a progr am label.
the analysis starts withan empty set of reaching defin itions andtrackstheeffectofstatementsonthesetofreachingdefi nitions.
essentially theeffectofastatement stonasetofreachingdefinition is to remove some reaching definitions that are no longer true and togenerate new ones see e.g.
.
a statement stusesresp.definesanaccess path if the latter denotesanl valuewhichisreadresp.
writtenby st. thisinformation is extractedfrom the result of the reaching definitionanaly sis.
a basic representation of data flow dependency is def use chains .
a def use edge between statement st1andst2represents that during execution of st1some access path is assigned whichmay be partially used inthe execution of st2.
theprogram dependence graph pdg represents the data and control dependences ofa single procedure .
the nodes ofthe graph are the statements.
there are two types of edges data a nd control.
data dependence edges are the def use edges comput ed from a reaching definition analysis.
control dependence edg es are computed by post domination on the control flow graph.
fig.
contains an example of a pdg ignore for now the labels on the edges in which control edges are pictured as dotted edges.
w eassume without lose of generality that all control stateme nts are represented as a guarded statements p?st wherest is executed only when pis evaluated to true.
a control dependency between st1and thenecessarily guarded command st2represents that st1 is acondition over a variable cwhichisthe guardof st2.
consider the guardedcommand statementin l10ofthe example.
inthepdg this statementissplitintotwonodes one forthe predicate p node l10.
and one for the guarded statement itself i q nodel10.
.
theoutgoingedgeof l10.1inthepdgisacontroldependenceedge.
asystemdependencegraph sdg representstheimmediateprogram dependence of a program containing procedures.
the sdg of a program is comprised the pdgs of its procedures.
the pdgs are connected together by call edges which represent proce dure calls and by parameter in and parameter out edges which r epresentparameterpassingandreturnvalues .
the sdgrepresentation is oftenused ininter procedural dependence analysis .
.
problem definition thegoalofthisworkistofindinapreciseandefficientmanner the field sensitive transitive dependences in the presence of aggregate structures with big l value operations.
recall that big l value operations are assignments towhole sub structures.
traditionally givenacontrolflowgraphofaprogram anode nis flowdependent onanode mifthereexistsapathinthecontrolflow inwhichthe value assigned in misdirectlyusedat n. similarly n istransitively dependent onmif there exists a path in the control flow graph inwhichthe value assigned in misindirectlyused at n ofcoursethisisanoverapproximationsincenotallcfgpat hsare feasible .
weextend thetraditional definitionto fieldsensitive flow dependentas follows an access path say x.f used at node nisfield sensitive flow dependent on an access path s.gassigned at node m ifthereexistsapathinthecontrolflowinwhichthevalue ass igned inmtos.gisdirectlyusedasthevalueof x.fatn.
thus thetraditionalflow dependentrelationisbetweenstatementswhile thefield sensitive flow dependent relation is between pairs of access path and statement.
thereareseveralfactorsthatcomplicatethisdefinitionin reallife programming languages pointers and dynamic allocations e.g.
big l values and procedures e.g.
.
we define field sensitive transitive dependence as a transitive dependence which handles precisely aggregate structures and big l values w ithout pointers .
noticethatbigl valuesmaketheproblemmoreco mplex becauseflowdependencesbetweenstatementsarenottransit ive i.e.
it may be that mis directly flow dependent on nandnis directly flowdependenton pandyetmisnottransitivelyflowdependenton p. for example statement l8in fig.
is flow dependent on l7 the use ofd.g1isflow dependent onthe definitionof d andl7is flow dependenton l6 theuseof c inparticularof c.g2 isflowdependent ofthedefinitionof c.g2 yettheirtransitiveclosureyieldsaspurious dependence of d.g1inl8onthe definition of tinl5.
.
range based representations in this section we describe our range based reaching defini tion analysis.
we say that a rangeof a variable is a contiguous part of the memory allocated to the variable.
a range denoted by v represents the memory area of vthat starts with the i th byte and ends with including the j th byte.
a single range of an alloca ted aggregatecanbeusedtorepresentallfieldsthatareallocat edwithin this range.
for ease of presentation we use the notion hatwidevto denote thewhole rangeofavariable vand hatwiderv.ftodenotetherange aligned withtheffieldofv.
arangeneedsnottobealignedwiththefieldsof an aggregate structure.
for example consider the variabl esdof typet1definedinfig.2andassumeeachfieldis4byteslong.
th e rangesd representsthefield f1ofsd.
weassumethefactthat an aggregate structure contains an ordered set of fields and e very fieldhasastartandendoffset thustherange sd representsthe fieldsf1 f2.
we define a meet operation between ranges which provides the maximal range that isinbothranges as follows v v braceleftbigg v x y x y y x y x where denotesthatthereisnooverlappingbetweenthetworanges.
forexample hatwidersd.f1 hatwidersd.f2 .
asweshallsee thisoperationis usedinfilteringspuriousdependence.
notethatthemeetope ration is definedfor ranges of the same variable.
giventhenotionofranges wefurthersimplifytheprograms a nd assume that statements are over ranges assignments are inthe form v u expressions evaluation computation assignments are in t he formv exp u1 ... un guarded statements p?st and gotostatements.
wedenoteby vthesetofvariablesintheprogramandby label the set of statements.
.
range based dependency a dependence d an bracketle tv seed l vd an bracketri htimplies that the partial value of vis transitively dependent on the partial value ofseedwhich was assigned at line l. the dependence is a value dependence ifvdistrueanda computationaldependence otherwise.
value dependence means that the value assigned to the range seed is read from range v .
note that if the variable vandseedare aggregate of the same type and the ranges are the same i.e.
x xandy y and the range spans more than one field f1 ...fnthen it implies that v.fiis value dependent on seed.fi.
notethatifaggregatevariableshavehundredsoffieldsand ifmostdependencies arecontiguous ashappens whenbigl v alue operations areused thenthisrepresentationismuchmoree fficient thana naive representation based onindividual fields.
a computational dependence comes either from a control dependence indicating that the value of seedwas transitively used as a control predicate for the transitively use of the valu e ofv or from cases where the value of seedwas transitively used at a computational expression which vis dependent on.
in contrast to value dependences computational dependences do notimply that ifseed includes fields f1 ...fnandv includes fields g1 ...gmthen every field v.giis dependent on every field v.fjfor j ...n. .
rangelabeled pdg we adjust the pdg to record fined grained reaching definition .
usingarangebasedreachingdefinitionanalysis labelsare addedto def useedgesthatrepresenttherangethatisactuallyinus e. thisenables handling ofdestructive updates i.e.
partialkilla ssignments accurately.
for example in fig.
the two edges from l2tol4are marked withtherange offield a.f1anda.f3because ofstatement l3that killsa.f2.
rangebasedreachingdefinition.
weenhancethestandardreaching definitions to track reaching definitions of ranges.
the d omain for the analysis is range 2labelwhere range v int int.
the join operator is a set union andthemaintransferfunctionispresentedintable1andexp lained below.
thegoalistotrackaggregatevariablesasawholestr ucture and split into ranges only when needed.
handling assignment s tostructt1 intf1 intf2 t2f3 structt2 intg1 intg2 t1exp sd a b t2c d i j k q intkill e t boolean p l1 sd exp l2 a sd l3 a.f2 kill l4 b a l5 t b.f1 l6 c.g2 t l7 d c l8 e d.g1 l9 p d.g2 empty l10 p?
i q l11 t i.g1 l12 j.g2 t l13 k j d23 d22 d21 d20 d16 d17 d18 d19 l1 sd exp hatwidersd d15 d15 d23 d22 d21 d20 d16 d17 d18 d19 l2 a sd hatwidea.f1 d117 d117 hatwidea.f3 d41 d41 an bracketle t hatwidesd hatwidesd true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l3 a.f2 kill hatwidea.f2 d15 d15 d23 d22 d21 d20 d16 d17 d18 d19l4 b a hatwideb.f1 d15 d15 an bracketle t hatwidea.f1 hatwidersd.f1 true an bracketri ht an bracketle t hatwidea.f3 hatwidersd.f3 true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l5 t b.f1 hatwidet d15 d15 an bracketle t hatwideb.f1 hatwidersd.f1 true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l6 c.g2 t hatwidec.g2 d15 d15 an bracketle t hatwidet hatwidersd.f1 true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19l7 d c hatwided.g1 d15 d15 hatwided.g2 d118 d118 an bracketle t hatwidec.g2 hatwidersd.f1 true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l8 e d.g1 d23 d22 d21 d20 d16 d17 d18 d19 l9 p d.g2 empty hatwidep d15 d15 an bracketle t hatwided.g2 hatwidersd.f1 true an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19l10.
p?
d115 d115 an bracketle t hatwidep hatwidersd.f1 false an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l10.
i q hatwidei.g1 d15 d15 an bracketle t hatwideq hatwidersd.f1 false an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l11 t i.g1 hatwidet d15 d15 an bracketle t hatwidei.g1 hatwidersd.f1 false an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l12 j.g2 t hatwidej.g2 d15 d15 an bracketle t hatwidet hatwidersd.f1 false an bracketri ht d23 d22 d21 d20 d16 d17 d18 d19 l13 k j an bracketle t hatwidej.g2 hatwidersd.f1 false an bracketri ht figure adasalgorithm run example on pdg.
the state next to each statemen t is a result of processing the incoming edges.
guardedcommands weresplitinorder toaccommodate control dependenceedges.
a whole variable vis rather straightforward.
reaching definitions on any range of vare killed and a new reaching definition for v is created.
for example the processing of statement l2creates the reaching definition a mapsto l2 .
handling assignments to fields requires some finesse as the de finition of v.fpartially kills a prior definition to v. assignments to a whole variable define the whole structure and thus do not create a partial kill .
in the example statement l2defines the whole structure aand the statement in l3defines only a.f2 partially killing the previous definition to a. however the previous reaching definition for ranges of the aggregate variable that were not killed are still valid and a new reaching definition o nly to the range that was reassigned is generated.
to accommodate this case previous reaching definition of ranges that o verlaps with the assigned range are removed.
instead up to thre e new ranges are generated as defined in table .
in our example the processing ofstatement l3yields thefollowingreaching defini tion a mapsto l2 a mapsto l3 and a mapsto l2 .
constructingthe pdg.
the reaching definition analysis computes a set of possible reaching definition points for ranges at eac h statement.
giventhisinformation therange labeledpdgiscons tructed.
foreachstatement l2andforeachrangeinthereachingdefinition v mapsto l1 that is partially used at the statement an edge froml1tol2isconstructed.
thelabelisthemeetbetweentherange in the reaching definition and the range used in the statement assume the used range in statement l2isv and the reaching definitionisforrange v thenthelabelis v v .
if the meet operation is then no edge is added as statement l2does not use the reaching definition of v .
control edges are added totherange labeled pdgasinthetraditionalpdg without l abels.statement transfer function a l v ... mapsto t t ne ationslash v t v v v v mapsto l v mapsto l a b v mapsto l v v ne ationslash a x v mapsto l a b v mapsto l v v ne ationslash y b b l v ... mapsto t t ne ationslash v v mapsto l table a the transfer function of the range reaching defin ition analysis where is the current state.
b for clarity a simplifiedversion for awhole variable assignment ispresen tedalthoughitis handledas anyrange assignment.
.
intraproceduralanalysis thepdgcontainsimmediatedependences andatransitivefunction is needed to compute transitive flow dependences.
howev er unlike the atomization approach or the whole structure appr oach where the transitive relation is simple for the interval b ased analysis we need to handle cases where the reaching definition is o n a big l value.
consider the example of fig.
when computing t he transitive flow dependences from statement l1and from statement l2tol4 the additional reaching definition of a.f2is taken into account.
clearly the transitivity of these two reaching defin ition is validfora.f1butinvalidfor a.f2.
as weshallsee whiletracking the transitive dependence we keep track of the current rang e that isofinterest.
inaddition thetransitivecomputationnee ds toavoid superfluous dependence.
for example consider the dependen ces betweenl6tol7andl7tol8.
theanalysisneedstoinferthatthereis nodependencebetween l6andl8.
thisisfurthercomplicatedwhen nested fields aretaken intoaccount.
our approach.
theadasalgorithm is a chaotic iteration algorithm over therange labeled pdg.thedomain isthe setof all sets of dependences angbracketleftrange range lables bool angbracketright whererange v int intis the set of all ranges.
a tuple an bracketle tv s l vd an bracketri htcorresponds to a dependence as defined in section .
it implies that range of variable vis transitively dependent on the values assigned to range of theseedvariable satlinel.
furthermore thedependence isavalue dependenceif vdistrueandacomputationaldependenceotherwise.
a dependence on v computed in a state for a statement l implies that the statement l uses a range of the variable v say v .
however the dependent range can be a subrange of the used range i.e.
xu x y yu.
in the rest of the paper we assume withoutloseofgenerality thatthealgorithmtrac ksasingle seedvariable assignedatasingleseedstatement andomitth e label member of the tuple.
the join operator is the set union operator.
the algorithm starts with a seed statement and a dependency on the seed rang e an bracketle tsd sd true an bracketri htand computes the transitive dependency of the seed.
the analysis computes for each statement st a set of field sensitive dependencies on the used ranges of st. the propagation of dependencies takes into account the source and ta rget statements and the type and label of the edge.
table formali zes the transfer functions.
a data flow edge between st1andst2is handled intwosteps step1and 2table2 as follows step computes the dependence on the defined range lefthand side of statement st1.
at this step assignments that are copy statements are treated differently than computa tional statements as the first preserve the data flow and the second does not.
conditional statements do not change thedependence.
at this step we take into account cases where the dependence is on a subpart of the used range and adjust the dependence tothe subpart of the definedrange.
step2 filters and adjusts the computed dependence from the firststepaccording tothe edge bytakingintoaccount the label on the edge a dependence an bracketle tv seed vd an bracketri htis filtered if there is no overlap between the dependent range andthelabel ontheedge.
ifitisnotfiltered thenthedependent range is refined according to the label.
in addition if the dependence processed isa data flow one vdistrue the dependence range of the seedis refinedas well.
controledgesdonothavealabelandthereforeneverfilterde pendences.
because control edges always come from a condition e xpression the analysis yields a computational dependences for each used range in the target statement to reflect that the depende ncy is not a data flow one.
the example in fig.
shows the computed dependencies on the variablesdassigned at statement l1.
we now further explain the key issues inthe analysis.
handlingdataedgesondatadependences.
thefirststepofhandlingdata edges isgenerating the dependence onthedefined r ange ofthesourcestatement.
forexample thefirststepinthepro cessing ofdependence an bracketle t hatwidesd hatwidesd true an bracketri htontheedgelabeled hatwidea.f1forml2tol4 treatsstatement l2asanassignment a sd andgeneratesthesamedependenceonthevariable a an bracketle t hatwidea hatwidesd true an bracketri ht.
the second step refines the dependence according to the label .
in this case the label v isa and the dependent range v isa .
because the dependence is a data flow one vd true and the meet between a anda is not then the processing is according to the second case in step i n table .
the computation of the dependent range is evaluated as a a a .
the seed range is also refined according to sd sd hatwidersd.f1.
thus the second stepyields the dependence an bracketle t hatwidea.f1 hatwidersd.f1 true an bracketri ht.
in cases where the defined range is a subrange of a variable th e first step performs an adjustment of the dependent range.
for example consider the processing of dependence an bracketle t hatwidet hatwidersd.f1 true an bracketri hton the edge from l6tol7.
the statement in l6is treated as an assignmentc t and the processed dependence in explicit range format is an bracketle tt sd true an bracketri ht.
according tothe first case in step in table the used range u ist the defined range v isc and the dependent range t is t .
thegenerateddependence is an bracketle tc sd true an bracketri htwhich is represented as an bracketle t hatwidec.g2 hatwidersd.f1 true an bracketri ht.
handling partial kill.
consider transition l2tol4which includes theprocessingoftwoedgesdue tothedestructive update in l3.
for each outgoing edge from l2new dependences are computed for l4 as described above in the processing of data edges.
the resul t istransfer functions case newdependence data edgestep1st1inthe form v u an bracketle tv seed vd an bracketri ht st1inthe form v exp u1 ... un an bracketle tv seed false an bracketri ht step2v v v v ne ationslash vd true an bracketle tv v seed true an bracketri htwhere x braceleftbigg xs x xl xs xl x x x l y braceleftbigg ys y yl ys y yl y yl v v ne ationslash vd false an bracketle tv v seed vd an bracketri ht control edge an bracketle tui seed false an bracketri ht i .. n table transfer functions of the adasalgorithm for a dependence d an bracketle tt seed vd an bracketri htfor an edge between st1andst2.
for dataflowedge weassumethattheedge islabeled v thatv isthedefinedrangeof statement st1 andthat v is the used range in statement st2.
note that step processes the intermediate dependence c omputed by the previous step and specificallythehandleddependencyinon v .
notethatinthefirstcase ofstep1 xu x y yualways hold.
notethatinthis case itholdsthat yu xu yd xdandthus yd yu y xd x xu y x .
alsonotethatinthesecondcaseofstep2 if v v v thenx xs x xandy xs y x .
forcontrolflowedges weassumethatasetofranges u1 ... un are usedinstatement st2.
joinedtoasinglesetofdependences.
duetothelabelsonthe edges thatrepresent theexactusedrange ofareachingdefinition thefact thata.f2is partial killed is accommodates into the results of the analysis without specific handling.
filteringunusedintervals.
the processing of the edge from l4to l5on the dependence an bracketle t hatwidea.f3 hatwidersd.f3 true an bracketri htleads to a dead end as the dependent range after the first step is hatwideb.f3and the use label is hatwideb.f1.
clearly these two ranges are disjoint hatwideb.f3 hatwideb.f1 and thus the second step filters out this dependence according t o the firstcase instep2intable .
handling big l value assignments.
the first step of processing theedgefrom l6tol7yieldsadependencyon hatwidec.g2.
thisdataenables us to filter out the spurious dependency when processing the e dge from the big l value assignment at l7tol8 despite the obvious immediate dependency between l7andl8.
handlingcomputational assignments.
the assignment to pinl9 is of a computational form.
in this case according to the sec ond caseinstep1 thewholedefinedrangeiscomputational depen dent on the seed i.e.
the generated dependence is with vd false.
additional propagation of this dependence are all computat ional ones.
handlingnonvaluedependences.
processingoftheedgelabeled hatwidei.g1betweenl10.2andl11is ona computational dependence.
step 1yieldsadependence onthewholevariable i. however according to the third case in step since the dependence is computati onal only thedependent range isrefinedaccording tothelabel yi elding a dependency on hatwidei.g1.
.
interproceduralanalysis adassummarizesproceduresasadependencerelationbetween the values of the formal arguments at the entry to the procedu re formals in and the value of the returnarguments at the procedure exit formalsout .
globalvariablesaretreatedasadditionalformalargumentsandreturnarguments.
thustherelationbetweenf ormals inand formals out computed for every procedure alsoaccount s for the procedure s effect on global variables.
informally the interprocedural dependence analysis can b e described as a two phase process the first phase summarizes eve ry procedure by computing a transitive dependence relation be tween a procedure s formals in and formals out.
the second phase computes the field sensitive dependences across procedures usi ng procedure s summaries to account for the effect of procedure ca lls.
recursiveproceduresarehandledbyrepeatingthetwosteps untila fixedpoint is reached.
technically ourimplementationisbasedonexistingsumma ryalgorithm .
thefirststepcomputesintra proceduraldepe ndences between formal intoformal out inthe form d an bracketle t fin st1 vd an bracketri ht wherest1defines the variable fin.
given a dependence at a returnstatement a dependencestatement whichareusedtorepresent procedures summaries ds d is constructed as follows ds d braceleftbigg fout fin ifvd true fout exp fin ifvd false thesecondstepisaniterativeprocessinwhichdependences tatements of callees are used at call sites to compute the depende nce statementsofthecaller.
thisisprocesseduntilnomoredep endence statements are computed.
we note that a similar modification can be applied on a more efficientsummary algorithm thus improvingthe runnin g time of the inter procedural field sensitive dependences analysis.
we consider such achange as part offuture work.
.
experimental evaluation this section presents a case study in which we evaluated adas in the context of an important software engineering applica tion customization change impact analysis for configuration ma nagement oferpsystems.
our empirical study was performed by integrating adasinpanayaia an industrial strength analysis tool for computing the impact of customization changes for erp systems made by sap a leading erpsoftware vendor and written in abap a proprietary language developed by sapsince the 1970s .
we begin by providing a short background rega rding analyzing erpsystems and then we describe our evaluation methodology and present our experimental evaluation of adas.
we note that while adasis evaluated in the context of erp systems the algorithm itselfis ofgeneric nature and isofv alue for analyzing anyprogram whichuseslargeaggregate structure s. see section9 .
.
analyzing erp systems anerpsystemintegratesinformationtechnologywithcorebusiness processes andisintended tomanage allthe information needs and business procedures of an often geographically scatte red organization.
see e.g.
.
an erpsystemistypicallycomprised of hundreds or thousands of programs.
each program represen ts a business process e.g.
human resources warehouse manage ment project management financials client relation managemen t etc.
and maycontain over a millionlinesof code.
erpsystemshavebecomedominantintoday sworldofbusiness applications.
one of the key reasons for the popularity of er p systems in the world of business is their modular design eve ry businesscanaddandcustomizemodulestomeetitsparticula rneeds.
ontheflipside theflexibilityoferpsystemsmakestheirana lysis a very challenging problem as we discuss below.
technically thecustomizationofanerpsystemisdonebyst oringconfiguration tables at the system s database and reading the configurationattributesatruntimeintoin memoryaggrega tesstructures whichmaybeofsignificantsize.
itisnotunusualtha tasingle structurecontainshundredsoffields .
theaggregatestruc turesstoring the configuration attributes have an immense effect on th e way that thesystem operates.
inpractice whenever aprofessio nal erp engineerwantstomodifythesystembehavior sheupdatesap roper configuration attribute inthe system s database.
a common programming practice in erpsystems is to fetch attributes pertaining to a whole structure from the databas e. these attributes can affect the execution of multiple programs.
i t is the task of the analysis todetermine which of the fields are neede d for thecurrentlyanalyzedprogram.
thus anefficientandpreci seway forhandlinglargeaggregatestructurevariablesisrequir edtoobtain a useful customization changes impact analysis.
due to the large code base of sap and the sharing of libraries between programs we follow a modular approach.
first each compilation unit is analyzed separately without prior kno wledge aboutdifferentinvocationofthecompilationunitandwith outtaking into account the code of external libraries invocations.
ne xt each programisanalyzedbyinter proceduralanalysesofthecom pilation units that are part of this program.
see for more elaborat ion on the implementation of panayaia .
.
evaluationmethodology theexperimentspresentedinthissectionareonaselectedb enchmarkof12programswhichvaryinsize complexity andassoc iated sapcomponents.
timeis measured inminutes.
experiments performed on a computer grid comprised of five intel servers.
eac h server has two dual intel xeon processors and 16gb memory running windows xp operating system bit with java .
.
in our experiments we study the differences in the quality of the results and the cost of the analysis of three transitive depe ndencesprogram kloc atom ws adas pairs pairs fp pairs fp sapmf02b sapf110v sapmv10a sapma01b sapmm07r sdbilldl saplamdp sapmv60a sapmv50a saplaist sapmf02d sapmm06b average table the number of customization table column pairs thatimpactthebenchmarkprogramandfp theamountoffalse positives.
the number of lines of code locs is in thousands .
negative percentages are due to implementation issues of th e panayaia tool whichareunrelatedto adas.
seesection8.
.
algorithms .
atom an algorithm based on the atomization approach .
ws analgorithmbasedonthewholestructureapproach and .adas.
note that all three algorithms compute the transitive inter proceduraldependencesoverthesystemdependencegraph sdg usingproceduralsummarydependences.
wefocusontwocompa rison criteria the accuracy of the dependences in terms of nu mber of false positive spurious dependences and the scalabil ity of the analysis approach in terms of time and memory.
the results of the atomization approach atom served as the most precise resu lts and wecompared the other twoalgorithms results toit.
.
experimental results table compares the accuracy of the dependences for the thre e algorithms.
foreachprogramthetablecontainsthenumbero fcustomization table column pairsthathaveanimpactonthep rogram accordingtoeachalgorithm.
column2liststhesizeofthepr ogram inthousands of lines ofcode.
column3contains the atomalgorithm results which also serves as a reference for the other t wo algorithms.
columns contains the ws algorithm results a nd the percentage of the false positives of the results compere d to the base results.
the results of the adasalgorithm are specified in columns .
forthewsalgorithm thepercentageofthefalsepositivesisrelativelyhigh anaverageof62 andapeakof500 foraspecifi c program.
for the adasalgorithm there is low false positive percentage ofonly1 onaverage.
theoretically adashasthesame precision as the wsalgorithm.
practically there is a difference in the precision because the implementation of the panayaia tool usessomeheuristicsthroughtheanalysisthatconsideramo ngother things thesize oftheprogram whichisquite differentbetw eenthe original program and the atomizedprogram.
facingthehighnumberof erpprogramsthatneedtobeanalyzed and the significant size of the programs the ability to scale the algorithms has beena key element inthe success of the tool.
table lists a comparison of the three algorithms according to theexecution timeof theanalysisforeachprogram.
asbefor e the 4in some cases the atomized program has times more statement s thenthe original program.program atom ws adas time time imp.
time imp.
sapmf02b .
.
.
sapf110v .
.
.
sapmv10a .
.
.
sapma01b .
.
.
sapmm07r .
.
.
sdbilldl .
.
.
saplamdp .
.
.
sapmv60a .
.
.
sapmv50a .
.
.
saplaist .
.
.
sapmf02d .
.
.
sapmm06b .
.
average .
.
.
table4 elapsedtimeinminutesandtheperformanceimprove ment imp.
.
negative percentages are due to implementatio n issuesofthe panayaia tool whichareunrelatedto adas.
see section8.
.
atom algorithm results serve as the base for the ws and adas algorithms.
we canseethat the wsalgorithm has alarge decrease of the execution time of on average with a peak of on a specific program.
interestingly adasis not far behind with a decrease of on average with a peak of .
this is without taking intoconsideration thetime savedfor theanalysis do ne prior to the actual computation of the transitive dependences bu ilding the cfg constant propagation etc .
although the wsalgorithm performs fewer actions on each step than the adasalgorithm as itdoesnotneedtocalculateandcomparefieldsensitiveprop erties due to its over approximated nature it performs more steps t han theadasalgorithm.
overall the improvements of both adas andwsalgorithmsinexecutiontimeisquitehigh aroundthe50 .
whereasthe wsalgorithmincludesahighportionoffalse positives theadasalgorithmachievesthisperformanceboostwithout hurting the accuracy of the dependences computation.
table lists the memory usage of the three algorithms for eac h benchmark program.
as expected the less precise ws algorith m columns3 hasa35 lowermemoryconsumptionthanthebas e result of the atomalgorithm column .
columns contains the results of the adasalgorithm.
we can see that the adas algorithm was able to decrease the memory consumption by on average.
adassuccessfully analyzed the largest program with amemoryusage of5.7gbwhilethe atomalgorithmhasfailedto analyze the program withinthe available heapsize 15gb .
.
evaluating a more efficient atomization we also studied if a more efficient atomization algorithm in t he style of which have shown great improvement for cobol p rograms canreducetheperformancepenaltyoftheatomalgori thm in our case of erp programs.
the main idea of the optimization suggestedin istoperformtheatomizationonlyforthos estructure fields that actually used refered in the program explic itly and not according tothetype information.
although inworst ca se this approach may result in full atomization in some cases the at omization can involve only a small portion of the structure fiel ds.
in ordertodoso aflow insensitivealgorithmisusedtogroups tructure fields to equivalence classes.
two structure fields are in the same equivalence classifthereisadirectorindirectassignmen tbetweenprog atom ws adas mem memimp.memimp.
sapmf02b sapf110v sapmv10a sapma01b sapmm07r sdbilldl saplamdp sapmv60a sapmv50a saplaist sapmf02d sapmm06b average table the average memory usage in mb and the performance improvement.
negative percentages are due to implementation issues of the panayaia tool which are unrelated to adas.
see section8.
.
them.
these fields are considered from the same type for type inference andaredisassembled foratomization ifatleast oneofthe fields isexplicitlyused.
forerpprograms wedeterminethatduetothealgorithm sflowinsensitive nature and the vast use of large structure varia bles the resulting equivalence classes are large and the number of un used structurefieldsisquitelow whichinduce atomizationofla rgeportion of the structure fields i.e the optimization unable to i mprove performance table contains the total number of structur e fields column and the number of unused structure fields column and its ratio column for each program in our benchmark.
we canseethatonaverageapproximately20 ofthefieldsareunu sed i.e.
the atomization needs to include most of the structure fi eld over80 .
therefore weconcludethat inthecontextofou rcase study this approach does not provide a good optimization to the full atomizationapproach.
.
conclusionsandfurtherwork inthispaper wepresent adas astaticanalysisalgorithmwhich conservatively computes transitive field sensitive progr am dependences.
the algorithm provides a specialized efficient and p recise handlingofprograms withlargeaggregatestructure variab les e.g.
large scale erpprograms by performing an interprocedural analysis over a novel form of representing reaching definitions u sing ranges.
we provide a detailed comparison between adasand the two known approaches for this problem the whole structure ws approach andthe atomization atom approach.
weshow that theoretically ouralgorithmismoreprecisethanthe wsapproach and aspreciseasthe atomalgorithm themost preciseknownsolution for this problem .
practically ourempiricalresultsshowthat adashascomparable performanceintimeandmemoryofthe lessprecise wsalgorithm whileprovidingthesamequalityofresultsasthe atomalgorithm.
indeed using adaswesuccessfullyanalyzedlarge erpprograms thatwecouldnotanalyzewiththe atomalgorithmusingthe rather vast computational resources that we have.
in a way we can s ay thatadasenjoys the benefitsof bothknownapproaches anddoes not suffers from their weaknesses.program fields unused fields of unused sapmf02b sapf110v sapmv10a sapma01b sapmm07r sdbilldl saplamdp sapmv60a sapmv50a saplaist sapmf02d sapmm06b average table results of a study on the number and percentage of unusedstructurefields.
adashelps solving an important software engineering problem automatically inferring the impact of customization changes onerpsystems.
it shows that it is possible to overcome a major challenge forprogram analysistools providingascalable andpreciseenoughanalysisforindustriallarge scalesystems.
w eattribute thesuccessof adastothejudiciouschoiceoftheabstractdomain which it employs.
a choice which was guided by the characteri stic of the class of programs of interest and the opportunitie s for an efficient implementation.
in this work we concentrate on analyzing programs that mani pulate large aggregate structure variables and provided an efficient and precise solution for the problem of computing field sens itive program dependences for this class of programs.
further wor kcan explore the possibilities that lie in combining our approac h with dependence analyses that specialized in other programming features.
specifically pointer manipulation of recursive dat a structure a quite precise computation of immediate dependences for programs manipulatingpointersandrecursivedatastructu reispresented in .
unfortunately their approach may compute f alse transitive dependences when facing big l value assignment s assignment operations that define the value of whole structure s .
we hope that combining our techniques with theirs will allow to accuratelycomputetransitiveprogramdependencesforpointer programs which use bigl value assignments.
another area that canbe addressed isthe computation of depe ndences betweenarrayelements.
wecanthinkofanarrayasala rge structure variables where indices are used to name subcompo nents instead of fields.
the challenging aspect of this extension i s that array copy operations are not as easily detectable from the syntax oftheprogram insteadofusingbigl valuesoperationstop erform acopythecontentsaggregatestructurelocations ascommo nlydone instructure manipulatingprograms array copyoperatio nsareusually implemented using a loop.
thus the analysis would need to track the index which we believe can be done by integrating t echniques developed for array manipulating programs .
.