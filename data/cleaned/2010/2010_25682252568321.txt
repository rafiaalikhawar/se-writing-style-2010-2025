making web applications more energy efficient for oled smartphones ding li angelica huyen tran william g. j. halfond department of computer science university of southern california los angeles california usa dingli tranac halfond usc.edu abstract a smartphone s display is one of its most energy consuming components.
modern smartphones use oled displays that consume more energy when displaying light colors as opposed to dark colors.
this is problematic as many popular mobile web applications use large light colored backgrounds.
to address this problem we developed an approach for automatically rewriting web applications so that they generate more energy e cient web pages.
our approach is based on program analysis of the structure of the web application implementation.
in the evaluation of our approach we show that it can achieve a reduction in display power consumption.
a user study indicates that the transformed web pages are acceptable to users with over choosing to use the transformed pages for normal usage.
categories and subject descriptors d. .
optimization general terms performance keywords energy optimization web applications .
introduction smartphones provide end users with a range of sensors that can be combined with applications and data via the internet.
this makes the capabilities of smartphones almost boundless and very popular with end users.
however one of the primary limitations of smartphones is that they depend on battery power.
smartphones are energy constrained devices and the use of these capabilities is very expensive.
in particular the energy to drive a smartphone s display is one of the dominant energy consuming components in a smartphone .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.oled screens are increasingly popular in di erent smartphones such as the samsung galaxy sony xperia and lg optimus series.
these screens are more energy e cient than previous generation displays but also have very di erent energy consumption patterns.
in particular darker colors such as black require less energy to display than lighter colors such as white.
unfortunately many popular and widely used web applications use light colored backgrounds.
this means that for many web application there is a signi cant opportunity to improve the battery life of smartphones by improving the color usage of a web application s pages.
researchers and engineers have long recognized the need to reduce a smartphone s display energy.
a well known and widely used smartphone technique is to dim the display to conserve energy .
for example when the smartphone is idle.
this technique is useful but there is room for additional improvement by exploiting the oled screen s unique energy color relationships.
one simple approach that has been suggested is to invert colors switching light colors to dark and vice versa .
the primary problem with this approach is that it distorts the color relationships of the user interface because color di erence is not an invertible relationship.
another approach is to create an alternate color scheme for mobile web applications.
chameleon proposes a browser extension that retrieves and applies a more energy e cient color scheme when displaying a web application .
the drawback of this approach is that it requires a customized browser additional servers on the network to handle the color scheme and the color scheme itself must be manually generated.
given the state of the art a technique that can automatically transform a web application to make its web pages more energy e cient is desirable.
however there are several signi cant challenges to providing such a solution.
the rst of these is to identify colors generated by a web applications.
most modern web applications combine dynamically generated pages and cascading style sheets in a way that makes it complicated to determine which colors will be used in which parts of a web page.
second it is important to model the color relationships in the web page.
here it is necessary to know what kind of visual relationships the colors have with each other i.e.
whether they are contained or adjacent.
third given this information it is challenging to nd a new color scheme that maintains as much as possible the color di erences and aesthetics of the original web page while also being more energy e cient.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in this paper we propose a new technique for automatically transforming the color scheme of a mobile web application.
the approach rewrites the server side code and templates of a web application so that the resulting web application generates pages that are more energy e cient when displayed on a smartphone.
the rewritten web application can then be made available to oled smartphone users via automatic redirection or a user clickable link.
our approach employs program analysis to model the possible pages that can be generated by the web application.
using this information it models the potential visual relationships among the colors of the pages elements and de nes a set of constraints for the new color scheme.
our approach then de nes a minimization problem whose solution represents a new color scheme in which the color di erences are similar to those in the original web application.
finally we de ne an e cient simulated annealing based algorithm to solve the minimization problem and produce a new color scheme that is both energy e cient and visually appealing.
we have implemented our approach in a prototype tool nyx and performed an extensive empirical evaluation on a set of seven web applications.
the results of our evaluation show that our approach is successful at automatically rewriting web applications to generate more energy e cient web pages that will be acceptable to end users.
in particular our approach achieved an average reduction in the display s power consumption.
via a user study we found that users rated the attractiveness and readability of the transformed pages as lower but still close to the original.
importantly over of users indicated that the transformed version would be acceptable for general use given the energy savings and over said it would be acceptable for use if the battery power was critically low.
overall we consider these results to be a strong indication that our approach can provide e cient and visually acceptable transformations for mobile web applications.
the other parts of this paper are organized as follows in section we use a simple example to illustrate the basic problem and provide background knowledge.
section provides an overview of the main process of the approach.
we introduce how to analyze relationships in the html output of web applications in section and how to identify color relationships and transform colors in section .
we discuss the rewriting of the web app in section .
our empirical evaluation for the approach is presented in section .
section describes related work.
finally the conclusion and future work are discussed in section .
.
motiv ating example in this section we introduce a motivating example to illustrate the challenges our approach must address.
our simple example is shown in program and its output is shown in program .
for explanatory purposes we inline the css properties used by the code in program .
as mentioned in section we have three main challenges to address to automatically transform the colors of a web application.
the rst challenge is to extract color information from the implementation of a web application.
the color information includes two types of information the colors generated and the structural relationship they have with other colors.
for example in program we need to know that the body line tag has white as its background color and the td tag has red as its background color and the1public void print html 2f print body bgcolor white style color black println table tr 5inta 6if a f println td hi td 8g 9elsef println td style background color red color yellow ha td 11g 12for inti i i f println td style background color green color blue usc td 14g println tr table println body 17g program sample code of web app body bgcolor white style color black table tr td style background color red color yellow ha td td style background color green color blue usc td td style background color green color blue usc td tr table body program output of program red color area is surrounded by the white color area.
this information is obtained by analyzing the code and identifying the strings that de ne the page s html structure and colors.
in general this requires us to model the output of a web application and then build more detailed models of the relationships among its html elements.
we discuss how to extract color and structural information in section .
the second challenge is to model the relationship between colors that have a structural relationship.
in general a transformation must maintain this relationship to improve the readability and aesthetics of a new color scheme.
for modeling this relationship we use color distance which is a function that accepts two colors and returns a numeric value to indicate the degree of di erence between the two colors .
colors have a larger color distance if they are more di erent.
this modeling is complicated by the fact that there are generally multiple colors used in a web page.
for example in program we have six colors white black green yellow red and blue.
all of these colors have di erent relationships white surrounds red and green green and red are next to each other etc.. furthermore not all color relationships in a web application are equally important.
for example in program the relationship between white and black the background color and text color in line is more important than the di erence between black and yellow text color in line and line .
we address this modeling problem in section .
and section .
.
the third challenge is that given a model for the relationships between colors we must nd the best color scheme that saves display energy and at the same time maintains the attractiveness and readability of web application.
from prior research studies we know that the energy consumption of oled screens is related to the rgb value of each528pixel .
energy consumption of a pixel ranges from black the least energy consuming color to white the most energy consuming color.
therefore we would want to change the background color of the body tag in program to black to save energy.
however to maintain readability we also need to change the background colors for table cells line and and the text color line and .
otherwise the content of the web may become unreadable and the appearance of the web application may be degraded.
a brute force method to nd a new color scheme that satis es these constraints is ine cient because of the large color space as there are 2563colors in total to choose among.
we address this problem in section .
.
.
overview of approach the goal of our approach is to reduce the energy consumption of the html pages displayed by a mobile web application.
to do this we automatically rewrite an application so that its generated html pages use more energy e cient color schemes and layouts.
our approach can be described as having three phases.
an overview of these phases is shown in figure .
the rst phase is html output analysis section .
in this phase the approach builds a model the html output graph hog of the html pages that can be generated by the application.
then using the hog the approach builds the html adjacency relationship graph harg which captures the visual relationships such as adjacency or containment between pairs of html elements.
the second phase color transformation section builds a color con ict graph ccg that describes the relationships between the colors of html elements that have a visual relationship.
using the ccg the approach generates the color transformation scheme cts a new energy e cient color scheme for the application.
this is done for an application by calculating a new color scheme that maintains the color distances represented in the ccg but whose primary colors will consume less energy during display.
the third and nal phase is output modi cation section .
the result of this phase is that the approach rewrites the application so that the generated html pages use the colors contained in the cts.
.
html output analysis in the rst phase the approach builds models of the application that describe the structural relationships among the html elements of the application s web pages.
we call this model the html adjacency relationship graph harg and it shows which html elements can be adjacent to each other or contained by one another.
to generate the harg the approach rst builds another model the html output graph hog which describes the html pages that can be generated by the application.
we explain the two models in more detail below.
.
the html output graph the html output graph hog represents the potential html output of a web application and is based on an abstraction proposed by m ller and schwarz .
intuitively the hog is a projection of the web application s control ow graph cfg where all of the nodes are instructions that generate html output.
an hog is represented as a tuplehv e v vfi.vis the node set where v2vifthe node is in the application s cfg and prints to the application s output stream.
in the java enterprise edition jee framework an example of such nodes would be invocations to jspwriter.println .e v vis the edge set where an edge vi vj 2eif there is a path from vitovjin the cfg of the web application with no other node vk2v along that path.
vo2vandvf2vare respectively the entry and exit nodes of the hog.
the approach builds an hog for each method of the web application by analyzing the method s cfg.
the hog for the entire application can be obtained by treating each node in the hog that represents an invocation as a transition to the entry node of the target method s hog.
to identify the html strings produced by each output generating node v2vwe also de ne a string analysis s that maps each vto a nite state automaton fsa .
our approach assumes that strings de ned external to the application such as user input will not in uence the color or the structure of the html tags.
for the string analysis we used a technique proposed by yu and colleagues .
we selected this method because it de nes mechanisms for handling common string related operations that appear in web applications but are di cult to analyze in traditional string analyses.
in particular it handles strings generated within loops via concatenation and string replacement by de ning awiden operation that abstracts repeating portions of the loop so that the fsa representing a string variable within a loop can converge on a safe approximation.
the hog is suitable for modeling the pages produced by dynamic web applications that directly generate html using mechanisms such as jsp servlets or struts.
however many modern web applications also contain html template les that are then lled in by application logic to generate the nal html content.
this is very common in web application frameworks that implement the modelview controller mvc pattern such as apache velocity and webmacro.
for these types of applications the approach builds the hog directly from the template les.
to do this the approach opens all macros in the template les and identi es the entire html frame.
then the approach de nes each line in the html frame as a node in the hog and de nes edges based on the order of the lines in the template le.
the process for construction of a hog for template based applications can vary based on the framework but in general the process requires a mixture of the string analysis based approach and the template parsing discussed here.
.
the html adjacency relationship graph the html adjacency relationship graph harg models the visual relationship between pairs of html elements in the hog.
the type of information present in the harg is similar to the document object model dom in that it shows parent child and sibling relationships.
however since the harg is built from the hog it also contains relationships that could be derived from loop generated html elements.
the harg is de ned as a tuple hv eiwhere each v2vis a node in the graph that corresponds to an html element that can be generated by the application.
e v vis the edge set where vi vj 2emeans that vi is a parent html element of vj.
to illustrate the harg for program is shown in figure .529figure the architecture of nyx figure example harg for program .
to build the harg our approach parses the hog to aggregate the individual characters in each node s fsa into html tags.
the traversal begins by traversing all of the edges in the fsa associated with the root node of the hog and then following all of the outgoing edges of the root node and repeating this process until all nodes in the hog have been traversed.
during the traversal the approach maintains a parse state that allows it to determine if it is currently parsing an html tag attributes or text.
when the parsing discovers an html tag it creates a corresponding node in the harg if it is an opening tag or a self closing tag.
there is an edge vi vj in the harg if and only if all of the following four conditions hold viis an opening html tag there is a path p in the hog from vitovj the closing tag of viis not in p and along path p if there is a node vkthat meets conditions vkis equals to vi.
basically these conditions enforce that vjwill be a child of vi contained within vi s opening and closing tags and that viis the most immediate predecessor that satis es these condition.
loops in the fsa will generate in nite strings.
when the parsing encounters a loop in the fsa the approach simulates its unraveling ntimes.
this unraveling may be unsafe because it is possible that the n traversal introduces new strings that are not included in the previous n unravelings.
however we have found that for the purpose of identifying the color attributes assigned to each tag n has a reasonably small bound.
in the analysis we employ the following heuristic nis assigned the maximum of either the integer value or one more than the largest iteration of repeating substrings in the css le.
for example in the string nyxnyxnyx nyx is a repeating substring.
we use the value since this is the maximum iteration of repeating substrings of a hexadecimal string that can be de ned as the value of color in an html attribute.
case in point a color is de ned by a six digit hexadecimal number e.g.
and each iteration of a loop could provide one character of this string.
since our goal is to capture potential color information this gives the approach a reasonable upper bound on the loop unraveling.
in practice we found that was always su cient and there was no incompleteness in the harg due to unraveling the loop in this way.more broadly the techniques for obtaining the hog can lead to an over approximation of an application s possible html pages.
in turn this can lead to the identi cation of spurious visual relationships that correspond to infeasible paths.
this does not cause a problem for the approach as this merely introduces additional color relationship constraints that must be accounted for while generating the color transformation scheme in section .
.
.
color transformation in the second phase the approach calculates the new energy e cient color scheme for the application the color transformation scheme cts .
there are two requirements for the cts it must use energy e cient colors as the basis for the new color scheme and maintain the color relationships between neighboring html elements.
the rst requirement serves the general goal of the approach and the second ensures that the color transformed pages are readable and ideally as visually appealing as the original pages.
to address the rst requirement the cts should replace large light colored background areas with dark colors preferably black as mentioned in section .
to address the second requirement the approach must transform the other colors of the html elements so that their color relationship with the new dark colored background is similar to their color relationship with the previous light colored background.
our approach produces a cts that meets both requirements.
to do this our approach rst builds a color conict graph ccg which describes the color relationships between pairs of html elements that have a visual relationship.
to begin our approach changes the background color of the root node of the ccg to black.
generally the root node of the ccg corresponds to the body tag but can di er for certain layouts.
then the approach calculates a new recoloring of the ccg so that the color distances between adjacent nodes in the recolored graph are the same as color distances in the original graph.
this mapping of old colors to the transformed colors is the output of the second phase.
our approach operates on three di erent types of ccg the background color con ict graph bccg which models the relationship between the background colors of neighboring html elements the text color con ict graph tccg which models the relationship between text colors and their corresponding background html element colors and the image color con ict graph iccg which models the relationship between an image and its enclosing html tag.
in the remainder of this section we rst give a formal description of the ccg and its three variants then introduce how we derive them from the harg and nally discuss the calculations that generate the cts.
.
the definition of color conflict graph the ccg and its three subtypes the bccg tccg and iccg show the color relationships between the html elements of a page generated by the application.
formally the530ccg is represented as a weighted complete undirected graph hv v wi.
the set vrepresents the graph s nodes where each node represents a color in the html page.
v02vis the root node of the graph which is the color that will be transformed to black.
typically v0is the background color of the body tag but users can specify a di erent root node for unusual html layouts.
wis a weighting function w v v!i.
since the ccg is a complete graph there is an integer edge weight de ned for every pair of tuples in v. the weighting function is used to give priority to certain types of visual relationships.
the bccg tccg and iccg vary in the weights attached to certain de nitions.
figure example bccg for program .
the bccg models the relationship among all background colors in the web page.
there are three types of relationships modeled in the bccg parent and children nodes sibling nodes and all other nodes.
the weights for these edges are assigned as the constants a b c respectively where a b c .
we rank the parent child relationship as the most important.
the reason for this is that a parent element s color generally surrounds their children node in the rendering of the html page which means that the color distance for these elements must be maintained to visually distinguish between the elements.
we rank the sibling relationship as next important because generally siblings are rendered close to each other on a page and therefore their color di erence is more important to maintain than that among the remaining elements.
finally we attach a weight to cbecause maintaining an element s color di erence relationship with the other elements on the page helps to preserve the overall aesthetics of the original color scheme but is not as important as the other two relationships.
an example bccg with edge weights for program is shown in figure .
in our example white is the background color of the body tag at line .
the table and tr tags at line inherit this color.
red and green are the background colors for the td tags at line and which are children of the tr tag at line .
thus the weight between white and red or white and green is a while the weight is bbetween red and green.
the tccg models the relationship between text colors and the background color of the enclosing html element.
therefore only edges that represent a link between these two types of colors are given a non zero weight awith the remaining edges being assigned a weight of .
the iccg models the relationship between colors in an image and the background color of the html element that surrounds the image.
therefore only edges in the iccg that connect an image s colors to the background color of its enclosing html elements are given a non zero weight of awith the remaining edges being assigned a weight of .
in some cases it is not desirable to transform every image in the web application.
for example it may be preferable to not alter a photo in a news article since the original appearance relates to the integrity of the story.
developers can specify a list orpattern of image le names that should not be transformed.
when the approach nds an image tag including one of the excluded image tags it does not construct an iccg or cts for the image.
.
building the ccg the ccg is built using the information contained in the harg.
the general intuition of this transformation is that the approach identi es color de nitions in the harg and propagates the de nitions along the graph to elements that may inherit the color.
the propagated information is then used to identify colors that have a relationship with each other and construct the ccg.
the rst step is to identify the color de nitions cds generated by each node in the harg.
a cd is generated when an html element contains an attribute that de nes either the text background color of the element or the html element is an image tag.
for example background colors of some elements can de ned by the bgcolor attribute and the color of text or links can be de ned by the text orlink attribute.
for pages that use css the approach identi es the set of cds that an html element generates based on its id class name or type which can be determined using a standard css parser.
an image tag generates a cd for every color used in the image.
the second step is to propagate all of the background cds to the other nodes in the harg.
this is done to determine which background colors will be adjacent to each other and which image and text colors will appear over a particular background color.
the approach propagates the color information using standard iterative data ow analysis .
the genset of a node is comprised of the cds generated at that node.
the kill set kills all cds that ow in to the node if the node generates a cd.
for example for a node viin the harg the approach propagates all of its background cds to a child vjifvjdoes not generate any background cds.
standard equations are used for the inand outsets.
note that cds originating from images and text are ignored during the propagation.
the nal step is to derive the ccg from the colors propagated over the edges of the harg.
nodes are created slightly di erently for each ccg variant.
in the bccg there are nodes for each unique background cd generated in the harg.
nodes in the tccg include those in the bccg plus nodes for the cds originating from text colors and the iccg includes the nodes in bccg plus nodes for the cds originating from image colors.
since the ccg is a complete graph there is an edge de ned between each pair of its nodes.
the edges of the ccg are assigned weights based on the di erent types of visual relationships discussed in section .
.
in general the weighting is done by iterating over each node vin the harg and identifying v s set of corresponding nodes in the ccg nc.
for each edge in the setf n n i jn2nc ni2ngwhere nis the ccg node set the appropriate weight is assigned based on the relationship it represents and the variant of the ccg.
the construction of the ccg does not take into account the e ects of embedded javascript.
this would result in an incomplete model of the color relationships if javascript was used at runtime to modify the colors of a web page.
to determine if this would impact our approach we conducted a small scale study on the use of javascript to modify colors in a web page at runtime.
in this study we examined the top53150 web sites as ranked by net to determine how javascript a ected the colors of a website.
in all we found that javascript was not used to modify the colors.
we believe that this result generalizes beyond the top websites and indicates that accounting for javascript in the construction of the ccg is not necessary.
.
generating the cts to generate the cts the approach analyzes each variant of the ccg and computes a recoloring that is more energy e cient but maintains as closely as possible the color differences between nodes in the graphs.
in this section we explain the analysis of the bccg in detail and then brie y describe the analogous process for the iccg and tccg.
to transform the background colors the approach converts the color of the root node of the ccg to black and then transforms the other background colors to maintain their color distances.
to state this more formally let s fc0 c1 c2 c3 c kgbe the set of colors of each node in the ccg where c0is the background color of the root node vo and each ci i is the color for the remaining knodes.
the approach creates a new color scheme s0in which c0 black and then nds color mappings for c0 c0 c0 kthat minimize the overall di erence in the color di erences of sands0.
the function to be minimized is h kx i 0kx j 0wijjdist ci cj dist c0 i c0 j j where wijis the weight of the edge between colors iandj in the bccg.
basically this minimization function is closer to zero the more closely each of the color di erence distances ins0match the color di erence distances in s. our approach maps this minimization problem to the energy minimization problem1 emp which is a well known pixel recoloring problem in the computer vision eld .
the emp minimizes the cost of a set of pixels and their labels.
given a set of pixels p fp0 p1 p kg and a set of labels l fl0 l1 l ng and a cost function cost p l f where fis a mapping from ltop the emp nds a transformation fthat minimizes the cost function cost .
in our mapping all nodes in the ccg the whole color space and the hfunction are the pixel set label set and cost function respectively.
our problem is then to nd a mapping from the whole color space to all nodes in the ccg that maps the root node to black and minimizes the hfunction.
this minimization problem is np hard but an approximation can be solved for in a reasonable time using a simulated annealing algorithm saa .
for our approach a close to optimal solution for s0satis es our two requirements for the cts and as we show in section allows the approach to compute the cts in a reasonable amount of time.
an saa is a technique for nding a good approximate solution in a very large search space and works by probabilistically exploring states until a good enough solution is found or the computation budget is fully consumed .
saas are a well known technique utilized in search based software engineering and are considered a good t for problems where identifying an approximate solution in a large search space is su cient .
our approach s adapted 1here the term energy refers to general costsaa is shown in algorithm .
the input of algorithm is the original color scheme s and the ccg.
the output is the transformed color scheme s0 with the background color of the root node transformed to black.
the saa begins with an initial color scheme current line which is generated by a greedy algorithm greedyinit .
the purpose of greedyinit is to identify a reasonable starting point for the saa.
the basic approach of greedyinit is to rst ip the color of the root node which is c0ins to black.
the algorithm then traverses over each of the remaining nodes in the ccg in order of decreasing edge weight.
for each node greedyinit assigns a color that minimizes the cost function hfor all nodes that have been visited.
our search based algorithm needs a time budget t in case the algorithm does not converge on the optimal solution.
a counter t that represents the allocated time or computational budget is initialized with an integer at line .
the saa iterates until t reaches lines .
in each iteration the approach identi es a possible new color scheme next .
this is done by calling random successor which generates a new color scheme by modifying each color in the current scheme except for c0 by a random amount line .
if the new color scheme minimizes the cost function h more than the current one then the new scheme next replaces the current scheme lines .
if the new scheme is not an improvement then the current scheme may still be changed with some small probability line to prevent the algorithm from getting stuck at a local optimum.
the probability function is based on the size of the counter t and the most recent di erence of h. finally after the counter expires the current best solution is returned.
this represents thes0for the ccg.
algorithm simulated annealing algorithm input s ccg output s0 current greedyinit s ccg best current initilize t while t 0do decrease t next random successor current ifh current h best then best current end if ifh next h current then current next else current next with p eh current h next t end if end while s0 best the approach for computing the cts for the tccg and iccg is very similar to the process described above.
a key di erence is that the background color transformations identi ed in s0are substituted into the corresponding colors in the tccg and iccg.
these transformed colors are treated as xed and the remaining colors color of the text and colors within an image are transformed using the above process.
because a signi cant subset of the colors are xed the cost function hcan be optimized further.
for space reasons we omit the description of this optimization.
the cts for the532tccg is a transformation for all of the text elements where each new text color maintains the color di erence with the transformed background color of its enclosing html element.
the cts for the iccg is a recoloring of each image so that each color in the image maintains its color distance with the transformed background color of its enclosing html element.
note that every color in an image is transformed with respect to maintaining the color relationship with the enclosing html element not the other colors in the image.
in cases where the image contains color gradients or shadows this generally results in a less attractive transformation.
in fact our evaluation showed that the attractiveness of applications with more transformed images was generally rated lower than the original.
in future work we plan to investigate more advanced image processing techniques that could improve the aesthetics of recolored images.
.
output modification in the third phase the approach rewrites the web application so that it generates web pages based on the cts.
for our approach we have two di erent mechanisms for realizing the modi er.
for css les and html templates our approach simply uses regular expressions to replace all color strings with their corresponding colors.
in practice we have found that more sophisticated approaches such as using css parsers to identify style properties to modify is unncessary.
for colors that are de ned by dynamically generated html the approach inserts instrumentation to perform the rewrite at runtime.
the instrumentation replaces the apis that print html to clients e.g.
jspwriter.println with calls to customized printing functions.
these printing functions scan the output as its generated and replace printed colors with their corresponding colors in the cts.
.
ev aluation we performed an empirical evaluation of three aspects of our approach time cost energy savings and user acceptance of the appearance of the transformed web pages.
we implemented our approach in a prototype tool nyx and used it to address four research questions rq1 how much time does nyx take to generate the cts?
rq2 how much energy is saved by the transformed web pages?
rq3 what is the runtime overhead introduced into the modi ed web applications by nyx?
rq4 to what degree do users accept the appearance of the transformed web pages?
.
subject applications we use seven open source java based web applications to evaluate our approach including applications that have been used in related work to ensure a broad representation of implementation styles.
these applications are implemented using di erent web application frameworks include colors de ned by html and css and employ a varying amount of javascript in their user interfaces.
details of each of these apps are shown in table table .
for each subject the column labeled framework shows the underlying web framework for which the application was implemented.
frameworks included in our study are jsp a very popular web application framework for java based web application servlet which describes applications that directly use the java enterprise edition jee framework with no intermediate framework struts a very widely used library and framework for web applications and velocity and turbine two popular template based frameworks for developing web applications.
the column labeled sloc shows the number of source lines of code in java for each web application.
for applications that are written in jsp we converted the jsp code into java using the tomcat jasper compiler and counted the resulting sloc.
our subject applications also represent varying levels of css and javascript usage.
javalibrary portal and bookstore de ne their styles in html directly while classroom roller scarab and jforum use css to de ne their style.
classroom portal and bookstore do not make heavy use of javascript while javalibrary roller scarab and jforum do.
three of the applications roller scarab and jforum use the model view controller mvc architectural style.
all applications except bookstore and portal are publically available from their project web pages.
bookstore and portal have been widely used in related work and are available via the sql injection application testbed .
.
implementation we implemented our approach in a prototype tool nyx.
to generate the output graph we leverage soot to build the underlying call graphs control ow graphs and the jasmin representation for java classes.
for representing the fsas of each string in the output graph and html content graph we use the brics automaton library .
as mentioned earlier to build the required string analyses we implemented the concatenation replacement and widening operations from yu and colleagues method and combined them with the brics automaton library.
we also built an automaton parser for the brics library to get the tag name css id class name and color information of html tags.
we used the sac css parser to identify colors from css les.
for the output modi cation phase we used bcel to modify java classes and perl script to modify colors in the css les.
our implementation handles html and css but it is straightforward to extend our tool to support html and css .
.
rq1 time cost to address the rst research question we ran nyx on all of the subject applications and measured the execution time.
the results are shown in table .
we separated the runtime into four di erent parts.
the rst is the time spent loading all of the java classes parsing templates and building call graphs.
this time is shown under the column labeled load.
the second is the time spent building the output graph html content graph and ccg.
this time is shown in the column labeled analyze.
the third is the time spent in calculating the cts which is shown under the column labeled transform.
finally the rewriting time is shown in the column rewrite.
all results were run on a dell xps desktop running linux mint with an intel core i5 3ghz processor and 8gb memory.
each timing result reported was the average runtime of executions.
as the results show overall it takes less than three minutes to analyze and transform each subject application.
most of the time cost is incurred in either the load or transform533table subject application information application information time cost s energy saving name framework sloc load analyze transform rewrite loading energy display power bookstore jsp .
.
.
.
.
.
portal jsp .
.
.
.
.
.
javalibrary jsp servlet .
.
.
.
.
.
classroom jsp .
.
.
.
.
.
roller jsp struts .
.
.
.
.
scarab velocity turbine .
.
.
.
.
.
jforum velocity .
.
.
.
.
time periods.
for the apps with a high loading time most of this time was spent by soot in building the call graphs of the application.
roller jforum and scarab have very small load times because we can build the output graph directly by parsing the templates les instead of analyzing java classes.
roller jforum and scarab also have a very small analysis cost since the string analysis for templates is much simpler than for java classes.
the length of the transform time was highly dependent on the structure of the web pages generated in the application.
for more complex pages with many colors it took longer to generate a new color scheme.
.
rq2 energy saving to evaluate the energy savings of our approach we deployed the original and transformed subject web applications on a tomcat web server.
we then accessed both versions of the web application using a samsung galaxy ii smartphone and measured the energy power consumption of the phone using the monsoon power meter .
there are two distinct energy power phases when a mobile phone visits a web application.
the rst phase is loading and rendering in which the browser loads the contents of the web page and renders them on the screen.
the second phase is display in which the mobile phone has nished loading and just displays the web page contents on the screen.
a key distinction is that the potential time for display is unbounded it ends when the user closes the browser or moves to another page.
in contrast the time for the loading is bounded.
therefore for fairness we measure the energy consumed during the loading and rendering phase and the power draw during the display phase.
this is more fair than simply measuring the energy of both phases since it is possible to in ate energy savings by allowing the display phase to continue for an extended period of time.
recall that energy power time.
to di erentiate these phases we leveraged the energy and power measurements provided by the monsoon power meter.
key to this was understanding what happens on a smartphone during these di erent phases.
in the loading and rendering phase multiple components in the smartphone such as cpu memory wifi 4g network and the screen are busy.
the loading phase has a limited time span it starts at the point that the browser sends the request to the server and ends when the browser nishes rendering the contents of the web page to the screen.
in contrast during the display phase all components except the screen of the smartphone are in the idle state.
therefore we can gure out the start and end times of the loading and rendering phase by observing the power state of the mobile phone in the power meter.
the start point of the loading and rendering phase is the point when the phone switches to the high power state and the end point is when the phoneswitches back to the low power state.
the start point of the display phase is the end point of the loading and rendering phase.
for both phases we took measurements of the original and transformed web application times and reported the average percentage decrease in the columns of table labeled loading and display.
on average there was a decrease in energy consumption during the loading and rendering phase and less power consumed during the display phase for the transformed web applications.
overall these are strong results and show that our approach can result in signi cant energy savings for smartphone users.
of interest to us was the fact that energy decreased during the loading and rendering phase.
this was puzzling since the transformation did not change the size of the pages in any meaningful way.
in our investigation we learned that in order to speed the display of the web pages the smartphone begins to display parts of the screen such as background color as soon as possible.
therefore there was energy consumed by the screen even during the loading and rendering phase.
this di erence became more signi cant during the display phase when only the screen was actively drawing energy.
also we investigated the lower savings incurred by the roller app.
we found that roller only covers about of the screen.
because of this we can only change colors for of the screen used by the web application to save energy.
the other is left as white which is the default color of the web browsers.
this suggests that an easy to achieve optimization would be to change the default background color of mobile browsers to black.
bookstore portal javalibrary classroom roller scarab jforumexecution time s. original transformed figure overhead .
rq3 runtime overhead the modi er introduces additional operations into the web application namely rewriting the color attribute of html strings.
therefore we are interested in measuring the runtime incurred via this operation.
for the experi 534ment the server was a core i7 .8ghz desktop with 8gb of ram running linux kernel .
and tomcat .
the smartphone was a samsung galaxy ii running android .
and connected to the server via wireless.
to calculate the overhead we compared the average time of the loading and rendering phase.
we used the time for this phase as it represents the time that users need to wait before they can see the contents of the web application.
we measured this time on the server and client side over ten executions of the experiment for rq2.
the results of this experiment are shown in figure .
the results show that on average the transformed versions take .
more time than the original.
however as can be seen in the gure sometimes the transformed application is faster.
even for applications where we only transformed css les we saw similar di erences.
we investigated this further by checking the results across di erent executions.
our results indicated that average loading time for all versions was about seconds and even the same version of an application would routinely vary by up to .
seconds with a standard deviation of about .
.
from this data we concluded that variations in the wireless signal were likely dominating any variation introduced by our modi cation overhead.
to eliminate interference from the wireless we also measured execution time just on the server side.
on average the server side increase was 34ms which represented about a increase.
however the actual distribution was bi modal with an average of a increase for apps whose code was modi ed as opposed to almost for those with only template changes.
this result is fairly intuitive as any modi cation to a template based web application did not require much additional runtime overhead and in cases where runtime transformations were required there were relatively few of these operations.
figure comparison in questionnaires .
rq4 user acceptance to address the fourth research question we conducted an end user survey in which users were asked to compare and rate the appearance of the original and transformed web applications.
the survey group was m.s.
and ph.d. students at the university of southern california who were enrolled in the third author s graduate level testing and analysis class.
the students were asked to complete an anonymous online survey on their own time and no incentives weretable subject application information attractiveness readability name ori trans ori trans preference bookstore .
.
.
.
portal .
.
.
.
javalibrary .
.
.
.
classroom .
.
.
.
roller .
.
.
.
scarab .
.
.
.
jforum .
.
.
.
bookstore portal classroom javalibrary scarab roller jforumgeneral use battery low battery critical never figure the acceptance rate of transformed web application provided to the students to complete the survey.
no background on the research project was given to the students and no connection of the work to the third author was suggested.
the survey presented users with a series of before after screenshots of the seven subject applications.
an example for the bookstore application is shown in figure .
for each image the survey group was asked to rate the attractiveness and readability of each version on a scale of to with being the highest.
the users were then asked which version they would prefer to use.
finally the last question asked if the black background version could save them x energy at what battery level would they choose to use it.
for each app x was replaced by the energy savings of the display phase.
the available responses were always regardless of battery level most of the time only when the battery level is low only when the battery level is critical and never.
the wording of the questions and forms are available via the project web page .
we received responses to the survey.
the results are shown in table and figure .
in table the columns attractiveness and readability report the related scores of both the original version and transformed version.
the subcolumns ori and trans represent the original and transformed version receptively.
the column preference reports the percentage of users who prefer the transformed web application over the original one.
the in figure we report when users would choose to use the transformed web application.
for space reasons we merged the option always regardless of battery level and most of the time into general use.
the bars show the di erent time points.
the y axis is the percentage of users who would switch to the transformed version at each time point.
for attractiveness the original app received an average score of .
and the transformed app a score of .
an average decrease of about .
this indicates that generally the users thought the color scheme of the original apps were more visually appealing than the transformed version but only by a relatively small di erence.
in fact for one535app javalibrary users found the transformed version to be more attractive.
for readability the original apps received an average score of .
and the transformed apps a score of .
an average decrease of about .
in general as we examined the per app results in more detail we noticed that applications whose screenshots contained a higher amount of transformed images bookstore portal and jforum received signi cantly lower scores.
we hypothesize that our rather crude transformation of image colors which neglects shadows and gradients impacted this score signi cantly.
transformed images in general were not as clear or readable as their original versions.
in future work we plan to explore improved image processing techniques for transforming image colors.
for user preference it was clear that users preferred the original version based on visual appearance and usability along.
on average over of the users preferred the original application.
however when asked to consider the energy savings there was a dramatic shift in user preference.
on average of the users chose to use the transformed version for general usage if it could save them x of energy during display.
overall more than of users chose to switch to the transformed version before the battery became critically low.
overall we consider the results for user acceptance to be positive.
although users rated the attractiveness and readability lower of the transformed apps when made aware of the energy savings they overwhelmingly preferred to use the transformed application.
.
related work the closest work to nyx is mian and colleagues work chameleon .
their approach modi es the source code of browsers to change the colors of web pages in the rendering bu er.
it rst manually builds color transformation schemes for each of the top twenty web sites such as google and saves them in a cloud server.
when the browser sends request to one of these web sites it queries the cloud server and downloads the pre installed transformed color schemes.
then it renders the transformed web application with the downloaded transformation scheme.
nyx is di erent from chameleon in two aspects.
first nyx builds the color transformation scheme automatically for web applications.
thus our approach is more easily applied to a broad range of web applications.
second our approach modi es the web application directly on the server side.
thus it does not introduce the client side cost of obtaining the transformation or applying it in the browser.
other approaches to save energy for oled screens have also been proposed.
kamijoh and colleagues work is one of the rst to optimize energy for oled screens.
it optimizes the energy consumption of oled screen for the ibm wristwatch by reducing the number of pixels that are bright.
however this work only considers two colors the black background color and the di erent foreground color.
as such this approach is not applicable for color displays.
choi and colleagues method reduces the energy consumption of lcd screens by reducing the screen refresh rate color depth and luminance.
however this approach relies on changing the hardware circuitry of lcd screens.
lyer and colleagues also proposed a method for changing colors on oled screens to save energy.
this method saves energy by darkening the areas that are not focused onby users.
the drawback of this approach is that the contents in the darkened area are not readable.
compared with this approach nyx can better maintain the readability of the entire page.
energy consumption of mobile devices can also be optimized in other ways.
one category of approaches for saving mobile energy is detecting the misuse of sensors .
our approach edtso saves the energy consumption of test suites with energy directed test suites minimization.
zhong and colleagues optimized the communication energy of mobile phones by redesigning the communication protocol.
rodoplu and colleagues proposed a deployment algorithm to minimize the energy consumption of ad hoc networks.
chen and colleagues proposed a method to save energy consumption for java based mobile applications by o oading workload to a server.
another related group of work is energy modeling and measuring.
mian and colleagues model the energy consumption of oled screens.
they discovered that the energy consumption of oled is linear to the rgb value.
our previous works model and measure the energy consumption of mobile devices on a source line level.
tiwari and colleagues model the cpu energy on instruction level.
eprof models energy with a state machine.
some other approaches model energy consumption on a system call level.
all the approaches mentioned above do not optimize the energy consumption for mobile applications they only model or estimate energy consumption.
besides energy saving transformation techniques for web applications are also used to optimize the user experience for mobile devices.
jones and colleagues improve the readability and attractiveness of web applications on mobile devices by manually redesigning the layout of web applications.
bila and colleagues design a system that enables end users to adjust the layout of web applications manually.
chen and colleagues improve the readability of web applications on mobile devices by partitioning web pages into segments.
minimap improves the readability by enlarging the contents of the web application.
.
conclusion and future work this paper presents a new technique nyx to make web applications more energy e cient for oled based mobile devices.
the basic idea of nyx is to replace the large light colored background areas of web applications with dark colors preferably black to reduce the energy consumed by oled screens.
during the transformation of an application s web page colors nyx also tries to maintain the aesthetics of the original web application.
an evaluation for nyx on seven open source web applications shows that it can reduce energy consumption by an average of with only a minor reduction in users rating of the pages attractiveness and readability.
our user study also shows that of users will accept the transformed web application generated by nyx if the battery power is critically low.
.