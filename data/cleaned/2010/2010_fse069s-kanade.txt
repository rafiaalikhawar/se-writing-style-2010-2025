representation dependence testing using program inversion aditya kanade indian institute ofscience kanade csa.iisc.ernet.inrajeev alur universityof pennsylvania alur cis.upenn.edusriram rajamani g.ramalingam microsoftresearchindia sriram grama microsoft.com abstract the definition of a data structure may permit many different concrete representations of the same logical content.
a client program that accepts such a data structure as input is said to have a representation dependence if its behavior differs for logically equivalent input values.
in this paper we present a methodology and tool for automated testing of clients of a data structure for representation dependenc e. in the proposed methodology the developer expresses the logical equivalence by writing a normalization program f that maps each concrete representation to a canonical one.
our solution relies on automatically synthesizing the oneto many inverse function of f given an input value x we can generate multiple test inputs logically equivalent to xby executing the inverse with the canonical value f x as input repeatedly.
we present an inversion algorithm for restrict ed classes of normalization programs including programs mapping arrays to arrays in a typical iterative manner.
we present a prototype implementation of the algorithm and demonstrate how our methodology reveals bugs due to representation dependence in open source software such as open office and picasa using the widely used image format tiff.
tiffis a challenging case study for our approach.
categories andsubject descriptors d. .
software program verification d. .
testing and debugging f. .
specifying and verifying and reasoning about programs general terms experimentation reliability verification keywords data structures program inversion testing permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
fse november santa fe new mexico usa.
copyright acm ... .
.
.
introduction in this paper we address data representation dependence a class of bugs that is a common source of incompatibility between programs.
we describe a new testing technique that we call representation fuzzing to identify such bugs.
data representation dependence.
consider a program the producer that produces some data that is consumed by another program the client .
when the client program works correctly with one version of the producer but fails to do so with a latter version of the producer we have a version compatibility problem.
data definition is often a key to interoperability between programs.
by data definition we mean a definition of the structure of data interchanged between programs and its semantics i.e.
the data value a particular data instance represents .
such a definition essentially acts as the contr act between a producer and client of data.
such definitions often permit different representations of the same data value.
a new version of a producer program may exploit the flexibility in the data definition contract to produce output that looks structurally different from the output of an earlier version of the producer yet semantical ly represents the same value.
a correct client is expected to work with the output of both versions of the producer.
unfortunately an implementation of a client may make assumptions about the data definition based on the observed output of a particular version of the producer program rathe r than use an independently specified data definition.
as a result it may fail to work correctly when the implementation of the producer evolves.
we refer to such a client as having a data representation dependence .
using examples of clients using windows data structures and clients using the widely used image format tiff we argue that such dependence is indeed an indicator of bugs in practice.
representation fuzzing.
in this paper we propose an effective novel technique for testing a client program cfor representation dependence bugs.
given a test case concret e input x we first automatically produce other test cases zthat are logically equivalent to x. we then test the programcwith these different but equivalent inputs.
if the program exhibits different behaviors for different but equi valent inputs we have a representation dependence bug.
dif fering behaviors could take the form of successful completi on in one case and a failure e.g.
null pointer dereference in the other or different inequivalent outputs in the two cases.
this technique which we call representation fuzzing works by essentially finding alternative representations of a test casewithout altering its semantics .
in our methodology thedeveloper of the data definition specifies the equivalence relation on data representations by providing a normalizationprogram the semantics function fthat maps representations to the values they denote.
in particular f x can be viewed as the canonical representation of x. finding alternative representations of xessentially requires identifying other representations zsuch thatf z f x .
program inversion.
representation fuzzing is essentially a constraint solving problem given fandxwe want to determine zsuch thatf z f x .
our approach is to decompose this problem into two parts.
first given f we automatically synthesize a program f that represents the inverse off.
the inverse will typically be a one to many function realized via non determinism.
for every yand for everyzthatf returns onyas its input f z ymust hold.
this is the correctness criterion for the inversion problem .
second given x we repeatedly apply f tof x to produce differentzthat are logically equivalent to x. this staged approach lets us do expensive symbolic constraint solving once offline during the program inversion phase when possible.
however some of the constraint solving may be hard if we treat y f x symbolically as an unknown but may be easier if the value of yis known.
in such cases we embed these constraints in the synthesized inverse program so that they are solved dynamically when f is applied to a given value of y .
the key technical challenge we address in the paper is that of synthesizing the inverse function.
in the simple cas e of straight line code computing outputs y1 ym from inputs x1 xn we generate the inversion code by symbolically solving a collection of equations for x1 xn .
in the general case conditionals loops and arrays complica te inversion.
one of the essential ideas we exploit for inversi on in the general case is to synthesize an inverse program that has a control flow structure isomorphic to the original program using local inversion via symbolic equation solving to invert loop free code fragments.
tiff case study.
tiffis a widely used image format that permits multiple representations of the same image and is known to raise compatibility issues among programs.
for instance a tiffimage consists of an orientation flag which determines whether the scanlines of the image bitmap are stored from left to right or right to left and top to bot tom or bottom to top.
thus there are multiple equivalent representations of a tiffimage.
we use tiffas a case study for representation dependence testing.
figure summarizes our methodology for testing a client programcfor representation dependence with tiffimages as an example.
the normalization program fconverts a tiff representation to a canonical bitmap representation.
our algorithm automatically synthesizes f the inverse of f. we then take a tifffiletiff1 and compute a bitmap bm f tiff1 .
applying f tobmproduces an alternative tiffrepresentation tiff2 of the same image as the bitmap bm.
we runcon both tiff1 and tiff2 and report any difference in the behavior or output of cas a data representation dependence.
the non determinism in f e.g.
the choice of orientation means that different runs of f can produce different outputs.
thus repeating the above procedure multiple times increases the effectiveness of testin g even when we use the same input tiff1.
the normalization program ffortiffconsists of several programming constructs like conditionals nested loops u n programf invertprogramf bitmap tiff1 clientc invert inverse offtiff2 clientcequiv?bug okayno yes figure automated testing for representation dependence of clients of tiff images bounded arrays and indirection in array indexing and is a challenging case study for inversion.
we cover strip based tiffimages with flexibility in the choice of orientation rows per strip and physical layout of strips.
we test five populartiffclients namely open office kview gimp faststone and picasa with the following conclusions even if the number of rows per strip is varied all clients process the image correctly for all test cases.
if orientation is varied then open office and gimp display images incorrectly with no warning to the user.
if logically adjacent strips are reordered physically in conjunction with change in orientation then picasa displays images incorrectly with no warning to the user.
.
proposed methodology we now formulate the problem concretely with an example of representation dependence and by specifying syntax and semantics of normalization programs and their inverses .
in a programming language like c the concrete representation of data can be given as a struct declaration.
as an example consider the following simplified version of datatyp e ddsurfacedesc in the windows directdraw api typedef struct ddsurfacedesc dword height width pitch lpvoid surface ddsurfacedesc a datadof type ddsurfacedesc contains two dimensional pixel datad.surface.
we assume that a pixel is stored as a single byte.
the number of rows and columns of the pixel data are given by d.height and d.width.
the field d.pitch gives the number of bytes between a pixel and the pixel immediately below it.
a program can append slack bytes to each row of the pixel data for internal use.
the value of d.pitch d.width is intended to indicate how many slack bytes are used by a program.
in practice slack bytes may not be used by a producer program p. consider the following client program cwhich uses data d of type ddsurfacedesc as input and reads the c th column ofd.surface into an array col. fori tod.height do col d.surface end3 it works correctly on data generated by p. however if p is changed independently to use slack bytes then it reads the pixels incorrectly.
in other words cmakes a stronger assumption on the datatype pitch width than the specification allows pitch width and it fails if pitch width.
a bracketle tprogram a bracketri ht a bracketle tstmt a bracketri ht a bracketle tstmt a bracketri ht a bracketle tsmpl stmt a bracketri ht a bracketle tcond stmt a bracketri ht a bracketle tloop stmt a bracketri ht a bracketle tsmpl stmt a bracketri ht a bracketle toutvar a bracketri ht a bracketle texp a bracketri ht assume a bracketle tpred a bracketri ht a bracketle tcond stmt a bracketri ht if a bracketle tpred a bracketri ht then a bracketle tstmt a bracketri ht else a bracketle tstmt a bracketri ht end a bracketle tloop stmt a bracketri ht fori to n do a bracketle tbody a bracketri htend a bracketle tbody a bracketri ht a bracketle tsmpl stmt a bracketri ht a bracketle tloop stmt a bracketri ht a bracketle tinvar a bracketri ht x x1 ... x2 ... m n a bracketle toutvar a bracketri ht y y1 ... y2 ... a bracketle tindvar a bracketri ht i j k a bracketle tind exp a bracketri ht a bracketle texp a bracketri ht a bracketle tscalar invar a bracketri ht a bracketle texp a bracketri ht x a bracketle t ind exp a bracketri ht a bracketle tind exp a bracketri ht figure the syntax of normalization programs this example of representation dependence is motivated by a real bug involving a client of ddsurfacedesc described in thewindows application compatibility bug database cf.
.
in order to detect representation dependence of clients of a datatypet we need a formal specification of the equivalence relation overt.
if a client program cproduces different behaviors or outputs on data dandd of typetsuch that d d then the client has representation dependence ont.
forddsurfacedesc d d iff d.width d .width d.height d .height and d.surface d .surface for alli jsuch that i d.width and j d.height.
given a data d the goal of representation fuzzing is to automatically generate d such thatd dand test a client with bothd andd.
writing logical specifications like this may be impractical for the developers.
further analyzing complex logical specifications seems difficult.
instead we propose that the developer writes a normalization program fto capture the canonical representation of a datatype t. this is a reasonably straight forward task.
we define d d ifff d f d .
we then show how to use program analysis to synthesize an inverse f and obtain d by applying f to the canonical representation f d .
normalizationprograms.
consider a datatype nform with the fields height width and a two dimensional array data as the canonical representation of ddsurfacedesc .
the normalization program is given below.
input d output n n.height d.height n.width d.width fori tod.height do forj tod.width do n.data d.surface end5 end6 figure gives the syntax of normalization programs.
the input and output variables are indicated by letters xandy respectively and for simplicity are considered to be integ er valued.
program expressions a bracketle texp a bracketri htand predicates a bracketle tpred a bracketri ht are affine.
loop counters and bounds are named i j k and m netc.
a loop counter is initialized to and incremented by in each iteration until the upper bound is reached.
the loops are required to be perfectly nested that is all assig nment and assume statements are part of the innermost loop body which can only be straight line code.
an array index expression can be an affine expression.
to handle the tiff case study we address two special cases of non linear indexexpressions a scalar input variable to be a coefficient of an affine expression and a single level of indirection through another array.
the index expressions of an input array can differ only in constant terms.
the rhs of an assignment to an index variable local variable icontains only iand constants.
we assume that an output variable yis assigned exactly once in the program and is not used before it is defined.
this also applies to every output array location y .
this assumption is met in the tiffcase study.
though similar to some constraints we check algorithmically for inver sion presently we verify this assumption manually.
some o f the syntactic extensions are not mentioned for brevity e.g.
boolean connectives are allowed in predicates.
while the program semantics are as usual we assume invertibility of assignment statements an assignment state menty eisinvertible with respect to every variable x appearing in eif the equality relation y ecan be rewritten to a logically equivalent relation x e .
since we assume that an output variable yis assigned exactly once and is not used before it is assigned ydoes not appear in e. the variables ofe can only be from v e y x wherev e is the set of input variables appearing in e. inverse programs.
an inverse of the normalization program of ddsurfacedesc is given below.
input n output d ensure d.pitch d.pitch n.width d.height n.height d.width n.width fori tod.height do forj tod.width do d.surface n.data end6 end7 the inverse program non deterministically assigns a value tod.pitch such that d.pitch n.width.
the values of height and width fields of dandnare same.
the control flow of the loop in the inverse program is same as that of the normalization program.
it however copies n.data tod.surface.
the conditiond.pitch n.width d.width line ensures that every element of d.surface is assigned at most once within the loop.
thus if an output dof the inverse program on n is given as the input to the normalization program we get back the same canonical representation n. suppose the inverse chooses d.pitch d.width .
since d.pitch d.width there are slack bytes but they are not required to be initialized by the inverse.
alternatively we can think of the slack bytes being assigned random values.
if a client program uses them in a computation that affects its output then it has representation dependence on ddsurfacedesc .
in addition to the statements in figure an inverse program may consist of the following kinds of statements a bracketle tensr stmt a bracketri ht ensure a bracketle toutvar a bracketri ht a bracketle tensr pred a bracketri ht a bracketle trand assgn a bracketri ht x where ensure is a call to a constraint solver which solves the constraints that are postponed to the run time.
it finds a satisfying assignment to the list of output variables of t he inverse program for a given predicate.
the run time values of the input variables of the inverse program are substituted in the predicates.
we discuss the syntax of a bracketle tensr pred a bracketri ht later on.
the assignment x assigns an arbitrary value to x. it is used when xis unconstrained in the inverse program.algorithm inversion of programs routine invert f input a program fin the language of figure output a program f that is semantic inverse of f u x d p x mapsto x x letadenote u d p a f invertsequence a f f emitpremaining a f return emitensure f a program f is asound inverse of a program fif for everyyand for every zthatf returns onyas its input f z yholds.
an inverse program may also consist of assume statements.
the presence of non deterministic choices by e nsure and random assignments may invalidate assumptions during run time.
a program f isfailure free if no assume statement fails during any of its executions.
while our inversion algorithm always synthesizes a failure free sound inverse it computes under approximations of the inverse fun ction offand hence is an incomplete synthesis procedure.
.
programinversion automatically synthesizing program inverses is a challeng ing task.
in this section we present an algorithm which works by inverting program statements locally that is without modifying the control flow of the input program except for some reordering of statements.
while allowing arbitrar y statement and control flow changes may seem more powerful we demonstrate that our algorithm is simple yet effective in inverting a large class of normalization programs includi ng iterative programs with arrays.
.
loop freeprogramswithscalarvariables we first illustrate various observations and techniques tha t we use in inversion of loop free programs with scalar variables using examples.
consider the following program.
y1 x1 y2 x1 x2 2x1 y1 x2 y2 x1 input program inverse program example to synthesize an inverse of the input program we need to compute the input variables x1andx2in terms of the output variablesy1andy2.
the first statement gives an equality relationy1 x1.
we treat the output variables as symbolic constants.
thus x1is uniquely defined by y1and we classifyx1asdetermined .
the statement is locally inverted to x1 y1bringing the determined variable on the lhs.
this statement is logically equivalent to the original statemen t and is the first statement of the inverse program.
the rhs of the second statement in the input program involves variablesx1andx2.
however x1is already determined in the prefix of the program.
therefore x2is uniquely defined in terms ofy2 an output variable and x1 a pre determined variable and is also classified as determined .
the statement is inverted locally as shown above.
if there are multiple variables on the rhs of an assignment statement that are not determined then one of them can be defined in terms of the others.
consider the following variation of example with statements reordered.algorithm inversion of statement sequences routine invertsequence a f input a u d p and a statement sequence f output updated tuple aand inverse f off f whilef e atio slash do s car f switchsdo casey e a s invertassign a s caseassume p a s invertassume a s case if p thens1elses2end a s invertconditional a s case fori 1tondobodyend a s invertloop a s end11 f append f s f cdr f end14 return a f y2 x1 x2 y1 x1 skip 3skip x2 y2 y1 x1 y2 x2 example at the first statement of the input program both x1 andx2are not determined .
say we define x1in terms of y2andx2.
however as x2is not determined x1is also not determined .
we instead classify it as a partially determined variable and generate a skip statement in the inverse program.
we then eliminate the occurrences of x1in the suffix of the input program until x2isdetermined or we encounter program exit.
we discuss the latter case in the sequel.
in the second statement we substitute y2 x2forx1.
the resulting statement is inverted locally since x2isdetermined in terms of y1andy2.
all the input variables namely x2 in the expression y2 x2to whichx1is bound are now determined .
hence we emit x1 y2 x2in the inverse program.
if an input variable xis not known to be a function of other variables at a statement of the input program then the variable is classified as undetermined at the statement.
letxbe the set of input variables of the input program.
at every statement the inversion algorithm computes a partition u d p ofxwhereu d andpare respectively undetermined determined andpartially determined variables.
the analysis also computes a binding function x exp that maps the input variables to program expressions denoted byexp.
if a variable xispartially determined then x is a program expression which evaluates to the same value asx.
otherwise xis bound to a special expression .
algorithm inverts program statements locally by computing the partition and the binding function.
statementsequences.
the function invertsequence algorithm inverts a given sequence fof program statements.
the inversion is achieved through a single forward pass over f. each statement type is treated separately.
the tuple ais also refined by the statement specific inversion algorithms.
assignment statements.
given an assignment statement s y e the function invertassign algorithm substitutes all occurrences of the partially determined variables in eby their binding expressions line .
let q u v e wherev e denotes the set of variables occurring in e. ifalgorithm inversion of assignment statements routine invertassign a s lets y e foreachx pdoe subst e x x switchu v e do case s assume y e case x s x localinvert s x a s markdemitd a x s append s s otherwise9 s x select u v e e localinvert s x u u x p p x end13 end14 return a s q then all variables in eare already determined and assigned in the inverse of the prefix of the program ending at the current statement.
nevertheless their values shoul d conform with the equality y e. this constraint is embedded in the inverse program as an assume statement.
if only one variable of e sayx isundetermined thensis inverted to x e .
given an assignment statement y e and a variable xappearing in e localinvert returns an expressione such thatx e is logically equivalent to y e. localinvert works by algebraic rewriting of an assignment such asy a x btox y b aassuming that every operator such as and has an inverse such as and .
the variable xis removed from uand added to dby the function markdemitd algorithm .
given a set w u of variables markdemitd marks them as determined .
if all variables occurring in the binding expression x of a partially determined variablexare now determined thenxis alsodetermined line .
the function markdemitd emits the assignment statement x x .
this process is repeated until no partially determined variable can be marked asdetermined .
the bindings carried by discharged as assignment statements by markdemitd cause statement reordering as discussed example .
if more than one undetermined variables occur in ethen one of them say x is marked as partially determined and bound to the expression localinvert s x lines .
assumestatements.
given an assume statement assume p the function invertassume algorithm substitutes all occurrences of partially determined variables in pby their binding expressions.
all variables in u v p are marked as determined .
as explained later we ensure that these variables take values that conform to pat the current statement.
some variable bindings may be discharged by markdemitd .
finally the statement assume p is generated.
conditional statements.
given a conditional statement s if p thenf1elsef2end the function invertconditional algorithm processes psimilar to the predicate of an assume statement and inverts the branches f1andf2individually.
letai ui di pi i i .
ifp1 p2and 1 2thenjoin a1 a2 u1 u2 d1 d2 p1 1 .
a variablex d d1 u1 d2is marked as determined by the join operation but is undetermined inf1.
to force the determined status a random assignment x is appendedalgorithm transitively mark partially determined variables as determined and emit assignment stmts.
routine markdemitd a w s u u w d d w repeat2 b p foreachx pdo ifv x dthen s append s x x p p x d d x end8 untilb p return a s to the inverse of f1 line .
similarly for f2.
this ensures that the future uses of xcan be resolved to be determined unconditionally enabling local inversion.
the condition al statement for the inverse is then formed by composing the inverses of the branches.
if p1 e atio slash p2or 1 e atio slash 2then one of the branches is eliminated1 lines .
in the following program the variables x2andx3aredetermined in the if branch and the else branch respectively.
skip ifx1 0theny1 x2 elsey1 x3 end y2 x3 x4 y3 x2 5ensure x1 x2 x1 x2 ifx1 0thenx2 y1 x3 elsex3 y1 x2 end x4 y2 x3 assume y3 x2 example we insert random assignments x3 andx2 in the if branch and the else branch respectively to force bot h x2andx3to be determined along both the branches.
we discuss the predicate x1 x2 later.
program exit.
oncefis processed completely the functionemitpremaining appends random assignments to the undetermined variables used in the binding expressions to f .
for eachx p x x is then emitted.
ensuringfailure freeexecution.
the inversion algorithm may generate random assignments to variables while processing conditional statements algorithm lines .
f urther new assume statements may be added to the inverse program if all variables on the rhs of an assignment statement are already determined algorithm line .
consider example again.
if x2gets assigned a value e atio slash y3in the else branch then the assume statement in the inverse program fails.
to avoid such failures the function emitensure algorithm line performs the following operations it computes the weakest precondition wpof assume statements emits an ensure statement at the program entry to satisfy the precondition and removes random assignments that may violate assume statements.
given the antecedant hoare triple of a wprule in the inverse program f emitensure generates the consequent triple to obtain a transformed version of the inverse program.
1it is possible to combine inequal sets of partially determined variables e.g.
by unifying their binding expressions but for simplicity we restrict it to the present form.algorithm inversion of assume statements routine invertassume a s lets assume p foreachx pdop subst p x x a s markdemitd a u v p return a append s s x e subst x e x e e e atio slash assume p p assume p x x x e atio slash v x skip x v s if p thenf1thenf2end p wp f1 p wp f2 s f ensure wp true f f the rule involving x and a postcondition where x v eliminates the random assignment to xas it may violate the postcondition .
instead xis assigned a value that satisfies by the ensure statement at the program entry.
the assignment x2 in example is eliminated by this.
the last rule emits the ensure statement.
the predicate x1 x2 in example is generated using these rules x1 x2 x1 y3 y1 x1 y3 x2 .
the ensure statement is a call to a constraint solver to find satisfying assignments to x1andx2subject to the predicate x1 x2 where the run time values of y1andy3are substituted.
we discuss the constraint solver in section .
correctness.
each statement of the input program is converted to a logically equivalent statement in synthesis of a n inverse while maintaining the control flow of the inverse pro gram.
given values of the output variables y an input variablexis assigned exactly once in the inverse program.
this guarantees that the value of xconforms with all its prior relations with y. a subsequent statement sof the input program involving xis also mapped to a logically equivalent statements in the inverse program.
it can be either an assignment to another variable x or an assume statement.
further the constraint to the ensure statement guarante es that no assume statement fails during run time.
the inverse however many not be complete in a sense that given yit may not produce all x s such that y f x .
this is because of handling of conditionals when partially determined variables along the two branches do not match and limitations of the constraint solver used in ensure statements.
.
iterative programswitharrays we now extend the inversion algorithm to iterative programs with arrays.
we use the following adaptation of example to illustrate the basic ideas behind loop inversion.
fori to do y1 x1 y2 x1 x2 end4fori to do x1 y1 x2 y2 x1 end4 example algorithm performs inversion of a loop s. it copies the loop structure l of the loop sto the inverse program lines but inverts the statements within the loop bodyalgorithm inversion of conditional statements routine invertconditional a s lets if p thenf1elsef2end foreachx pdop subst p x x a s markdemitd a u v p a1 f invertsequence a f1 a2 f invertsequence a f2 ifp1 p2 1 2then a join a1 a2 foreachx d d1dof append f x foreachx d d2dof append f x s append s if p thenf 1elsef 2end a s markdemitd a s append s s else13 a select a1 a2 ifa a1then s append s if p thenf 1elseassume false end elses append s if p then assume false elsef 2end end18 return a s locally as we did for loop free programs line .
we now describe the extensions required to do this.
in the sequel the term reference denotes either a scalar variable such as i or an indexed array variable such as x1 .
consider an assignment statement y x1 x2 .
a reference such as x1 orx2 is atop level reference .
these are given by the function toplevelrefs .
we can rewrite the assignment statement to express any top level referenc e as a function of other top level