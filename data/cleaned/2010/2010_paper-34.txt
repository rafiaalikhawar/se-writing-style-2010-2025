differential assertion checking shuvendu k. lahiri microsoft research redmond wa usakenneth l. mcmillan microsoft research redmond wa usarahul sharma stanford university ca usa chris hawblitzel microsoft research redmond wa usa abstract previous version of a program can be a powerful enabler for program analysis by de ning new relative speci cations and making the results of current program analysis more relevant.
in this paper we describe the approach of di erential assertion checking dac for comparing di erent versions of a program with respect to a set of assertions.
dac provides a natural way to write relative speci cations over two programs.
we introduce a novel modular approach to dac by reducing it to safety checking of a composed program which can be accomplished by standard program veri ers.
in particular we leverage automatic invariant generation to synthesize relative speci cations for pairs of loops and procedures.
we provide a preliminary evaluation of a prototype implementation within the symdiff tool along two directions a soundly verifying bug xes in the presence of loops and b providing a knob for suppressing alarms when checking a new version of a program.
categories and subject descriptors d. .
software program veri cation assertion checkers formal methods general terms veri cation reliability keywords di erential analysis veri cation regressions .
introduction there are several factors limiting the adoption of static analysis tools in the hands of developers.
for static assertion checking these include the need to de ne an assertion or speci cation to check to provide environment specications and to provide auxiliary invariants for loops and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.procedures.
although many auxiliary invariants can be synthesized automatically by invariant generation methods the undecidable nature or the high practical complexity of assertion checking precludes complete automation for a general class of user supplied assertions.
it has often been proposed that utilizing previous versions of an evolving program can signi cantly reduce the cost of program analysis .
such approaches run in two primary directions.
first in the presence of program refactoring two versions can be checked for semantic equivalence to ensure the correctness of the transformation .
second veri cation can be performed incrementally for example by carrying over invariants that are una ected by the syntactic changes .
although these techniques are useful in their own right they are applicable in very limited contexts.
first most software changes including some called refactoring induce some behavioral change.
equivalence checking is too strong for such cases.
moreover incremental veri cation can only be performed when the previous version does not have any false warnings unfortunately this is too strong a requirement for the usage of static analysis tools.
such false warnings have to be either removed by manually specifying additional invariants or the tool has to resort to ad hoc heuristics to suppress a class of warnings.
the former seriously undermines the productivity gained from the use of static analysis whereas the latter leads to brittle tools that may suppress true bugs.
in this paper we propose another direction for exploiting previous versions of a program as an implicit speci cation which appears to open up an interesting space for trading o soundness for cost required to apply an assertion checker.
our observation is simple we can often prove relative correctness between two similar programs with respect to a set of assertions statically with signi cantly lower cost than ensuring absolute correctness.
given a program pwith a set of assertions a one traditionally asks whether there is an environment for pin which one of the assertions in afails.
one can instead ask a relative version of this question given two versions pandp0 containing a set of assertions a does there exist an environment in which ppasses butp0fails?
we formalize this idea as the problem of di erential assertion checking dac checking two versions of a program with respect to a set of assertions.
although this provides a weaker guarantee of correctness of p0 it closely corresponds to an interestingclass of bugs regressions that are often most relevant to a developer and have a good chance of getting xed.
moreover we argue that dac has several desirable traits when checking absolute correctness is rife with false alarms .
dac allows for writing natural relative speci cations without a lot of modeling additional ghost variables to express the properties.
.
dac can be used to show that bug xes do not cause additional regressions for a set of assertions.
.
exploiting the structural similarity of programs pand p0allows simple intermediate relative speci cations to answer the relative questions.
an idea similar to dac was earlier proposed in the context of ltering false alarms for concurrent programs we discuss subtle di erences in section .
at a high level one can see this work as applying the idea towards evolving programs and extending the idea to deal with unbounded loops and recursion was restricted to bounded programs .
.
motivating example void stringcopy.
wchar t dst wchar t src int size f wchar t dtmp dst stmp src int i for i stmp i size i dtmp stmp dtmp gvoid stringcopy.
wchar t dst wchar t src int size f wchar t dtmp dst stmp src int i for i i size stmp i dtmp stmp dtmp g figure motivating example in c two versions of stringcopy figure .
consider the two versions of the procedure stringcopy described in figure .
the version stringcopy.
is a procedure for copying the contents of a char bu er srcinto dst described in an earlier work .
let us rst ignore stringcopy.
which is a buggy version of stringcopy.
.
in this paper we adopt the convention that procedures on the left side of the gures corrspond to buggy versions and those on the right correspond to correct versions.
let us illustrate the complexities of verifying the memory safety of stringcopy.
in isolation.
.
to specify memory safety one needs to de ne the bounds of a bu er for c programs unlike java or c .
this can be accomplished by adding a ghost variable bound that maps each allocated pointer such as dst to a non negative integer.
one possible way to specify the memory safety is to precede any dereference ewith the assertion assert bound e .
.
one needs a precondition that the bounds of dstand srchave some relationship with size and the two bu ers are disjoint.
.
finally one needs to write a loop invariant to record that dtmp always points inside the bu er pointed by dst among other things.
even for such a simple procedure specifying and verifying the memory safety can be quite complex if the user is left to de ne the assertions environment conditions and intermediate invariants.
now we de ne relative memory safety of stringcopy.
with respect to stringcopy.
.
first observe that the difference in the two versions lies in the loop exit condition where the conjunction is applied in reverse order this gives di erent behaviors due to the short circuit semantics of .
we want to check that stringcopy.
accesses only the memory locations which stringcopy.
accesses for any input.
we can de ne and check relative memory safety in a generic fashion as follows .
de ne an uninterpreted predicate valid that maps each pointer to a boolean value.
each dereference eis preceded by assert valid e .
.
let ok.i be a global boolean variable for stringcopy.i procedure that is true if no assertion has failed.
we replace assert by code that sets ok.i to false if is false.
we say stringcopy.
is correct relative to stringcopy.
if when both start in the same state parameters and the heap and both terminate if the former terminates in a state where ok. istrue then the latter also terminates in a state satisfying ok. .
.
assuming the two loops are automatically extracted as tail recursive procedures x9 loop.
and loop.
respectively we show how to construct a composed procedure for the two loops and attach a simple relative speci cation on the composed procedure.
pre stmp.
stmp.
dtmp.
dtmp.
mem char.
mem char.
i .
i. size .
size.
ok. ok. post ok. ok. dtmp.
dtmp.
proc ms loop.
loop.
dst .
... dst .
... here prerefers to a precondition and post refers to a postcondition and mem char.i refers to a global array that models the state of the heap.
moreover we show how such a speci cation can be inferred using the techniques in this paper.
note that we did not require any precondition about the inputs to the program nor any correlation about the bounds nor any relationship with null terminated bu ers.
this checking succeeds and we have proven that stringcopy.
has a memory footprint no larger than stringcopy.
.
on the other hand if one were to check the relative correctness of stringcopy.
with respect to stringcopy.
under the relative memory safety speci cation one would get a counterexample where size equals and pointer srcdoes not satisfy valid .
this counter example captures the seeded bug an address that stringcopy.
dereferences but stringcopy.
does not.x2vars r2relations u2functions e2expr xjcju e e jold e 2formula truejfalsejerelopej j jr e e j s2stmt skipjassert jassume jx ej havoc xjs sjx callf e e c2cfstmt l jgotol1 l njreturn f2body cjs fjf f p2proc intf xf int rfffbodyg figure a simple programming language.
the set ofgoto statements do not form any cycles in the control ow graph.
.
overview in the rest of the paper using the background developed inx2 we formalize the notion of di erential assertion checking dac x3 and illustrate its use for de ning relative speci cations x3.
.
we provide an algorithm for checking dac modularly by transforming the relative correctness problem into verifying assertions over a single composed program x4 .
this allows us to leverage standard o the shelf program veri ers and invariant generation tools to check the relative correctness problem.
we demonstrate a simple scheme based on houdini that su ces for a class of programs x5.
.
we have created a prototype implementation of our method inside symdiff a semantic di erencing tool.
we evaluate the tool along two di erent directions.
first we use dac to soundly verify that the version after a bug x is relatively correct with respect to the buggy version x6.
.
second we show that dac can provide a systematic knob for suppressing alarms when analyzing a new version of a program x6.
.
together the experiments indicate the potential of dac to be a generic framework to exploit previous versions of a program.
.
background figure describes a simple programming language a subset of the boogie programming language with recursive procedures and an assertion language.
we assume that loops are already desugared into recursive functions of this language we describe a method in x9 .
the language supports variables vars and various operations on them.
expressions expr can be variables constants or the result of applying a possibly interpreted function uto a list of expressions.
the expression old e refers to the value of eat the entry to a procedure.
formula represents boolean valued expressions and can be the result of interpreted or uninterpreted relational operations on expr boolean operations f g or possibly quanti ed expressions 8u int .
note that the programming language is fairly expressive and can be used to model arrays.
an array can be modeled in this language by introducing two special functions sel2functions and upd2functions sel e1 e2 selects the value of a map value e1at indexe2 and upd e1 e2 e3 returns a new map value by updating a map value e1at locatione2with valuee3.
a state of a program at a given program location is a valuation of the variables in scope procedure parameters locals and global variables and a program counter pcthat indicates the next statement to be executed.
a program consists of a set of basic blocks where each basic block consists of a statement s2stmt terminated with a control ow statement cfstmt goto orreturn statement .
a goto statement gotol1 l nnon deterministically sets the pc to any one of the nlabels.
we restrict the use of goto statements to not form any cycles in the control ow graph.
the statement skipdenotes a no op.
the statement assert is used to statically check that the formula holds assert has no e ect on the dynamic state.
the statement assume behaves as a skipwhen the formula evaluates to truein the current state else the execution of the program is blocked .
the assignment statement is standard havoc x scrambles the value of a variable xto an arbitrary value and s tdenotes the sequential composition of two statements sand t. conditional statements are modeled by using the goto statement and assume statements.
procedure calls are denoted using the callstatement and can have a side e ect by modifying one of the global variables.
let be the set of all states for a program.
for any procedurep2proc we assume a transition relation tp that characterizes the input output relation of the procedurep.
in other words two states 2tpif there is an execution of the procedure pstarting at and ending in .
the transition relations can be de ned inductively on the structure of the program and is fairly standard for our simple language .
there are a host of tools for modeling most high level languages such as c c java in this language such havoc for c .
we note that such translations use arrays to model the heap e.g.
an array per eld in java where the arrays are indexed by objects or pointers.
we defer further discussion of the translations to these earlier works.
.
dac in this section we formalize our approach of di erential assertion checking dac .
the basic concept of dac appears in a previous work in the context of ltering false alarms in veri cation of concurrent programs using sequential executions .
however it was described in a simpler setting of bounded programs loops were unrolled and recursive procedures were inlined a bounded number of times.
before proceeding we establish a few notations that we follow in the paper unless explicitly stated otherwise.
first we assume that any assertion assert is replaced by the assignment ok ok to a global okvariable.
second given that we are considering two versions p1andp2of a program we su x the names of procedures globals including ok and parameters with the version number.
third we label a state asfailing ifokvariable is false in .
finally we assume a one one not necessarily onto mapping between the globals procedures and their parameters between the two versions we often equate states from two versions when we really mean that the two states assign the same value to the mapped variables of the two states.
de nition .
di erential assertion checking given two procedures p1andp2 p2has a di erential error with respect top1 denoted as dac p2 p1 if there exists an input state such that there exists a state 1such that 2tp1 and 1is non failing and there exists a state 2such that 2tp2and 2is failing.we de ne a procedure p2to be relatively correct with respect top1ifdac p2 p1 does not hold.
the above de nition di ers from the de nition of di erential error di err p2 p1 in a subtle way.
the difference lies in whether we insist the input to be non failing forevery execution in p1 indi err p2 p1 as opposed to be failing on some execution in p1 indac p2 p1 .
we provide a simple example that distinguishes the two views in figure .
proc p1 f havoc x if x assert false gproc p2 f assert false g figure example di erentiating di err and dac for this example dac p2 p1 holds as there is a state empty from which p1succeeds when the internal variable xis assigned false and p2fails.
however di err p2 p1 does not hold because there is no input state from which all executions are non failing for p1.
it is easy to observe that if di err p2 p1 holds then dac p2 p1 holds but not otherwise.
the de nition of di err was motivated by comparing concurrent interleaved executions with their sequential counterparts.
we adopt the slightly modi ed de nition for dac to several reasons.
first the check for dac p2 p1 can be encoded very naturally using single program veri ers assume i1 i2 g1 g2 call p1 i1 call p2 i2 assert ok. ok. where we use iand gto denote parameters and globals.
on the other hand the di err check is more complicated because checking it is undecidable even for bounded programs.
this added complexity is not needed for comparing similar versions of a program we have found that internal non deterministic choices are less common.
whenever non determinism is present say reading chars using scanf the choices can be aligned on the two sides to return the same arbitrary sequence of choices in the two programs see .
in such a modeling the non deterministic choices become reads from an input array thereby converting internal non determinism to input non determinism.
.
relative specifications recall that writing meaningful speci cations often require access to a host of ghost state that is not present explicitly as part of the program state x1.
.
in addition to checking existing assertions in the two versions di erentially dac also facilitates writing relative speci cations using the same syntax of single program assertions.
instead of de ning the bu er overrun checks on the two programs and checking them di erentially it often helps to pose questions such as are there inputs for which p2accesses bu er regions that are not accessed by p1?
such speci cations can be written by introducing an uninterpreted predicate valid and adding an assertion before accessing any pointer p assert valid p .
such a speci cation will be useless for checking a single program every pointer dereference might be agged as a warning but will naturally provide a relative speci cation.moreover such a speci cation can be strengthened using semantics of the particular property that is desired.
for example when checking for non null pointer dereferences one can constrain the predicate by adding an axiom axiom 8x int x6 valid p similarly while checking for bu er over ows one can add an axiom axiom 8x int y int x y valid y valid x this will allow the dac to not show a warning when the programp2accesses an index that is smaller than an index accessed by p1.
this is specially useful when the entire history of indices accessed by p1is not stored especially while a modular proof of dac x4 that only records an abstraction of the history of accesses on the two programs .
finally one can even capture properties such as equivalence of two procedures modulo termination .
for a procedure p2p letobe the set of out parameters and gbe the set of globals modi ed by p. if we assert valideq o g for an uninterpreted predicate valideq on the post state of pand then perform dac on two versions p1andp2 then the relative speci cation is correct if and only if the two programs are equivalent.
.
modular dac in the previous section we de ned the problem of di erential assertion checking dac p2 p1 for a pair of procedures p1andp2.
in this section we provide a mechanism to check fordac p2 p1 or rather verify that p2is relatively correct with respect to p1 in a procedure modular manner.
in other words we will verify the relative correctness without inlining the callees inside a procedure but rather using some speci cations.
we provide a program transformation technique that compiles the relative correctness check of two programs p1andp2into a single composed program which can be analyzed by an o the shelf program veri er.
in particular the transformation allows us to leverage existing invariant inference mechanisms for single programs for inferring relative speci cations.
the transformation is not speci c to the problem of di erential assertion checking and is applicable whenever there is a need to compare two programs.
.
composed program proc f1 x1 r1 modi es g1 f s1 l1 w1 call h1 e1 t1 gproc f2 x2 r2 modi es g2 f s2 l2 w2 call h2 e2 t2 g given two programs p1andp2each containing a set of procedures and a one one mapping between procedures let us consider two particular mapped procedures f12p1and f22p2.
we have speci ed the modi ed set of globals for each procedure using modifies keyword.
for ease of exposition we have assumed that the read set of a procedure is a superset of the set of modi ed variables.proc ms f1f2 x1 x2 returns r1 r2 modi es g1 g2 f initialize call witness variables bl1 b l2 ... false false ... l1 il1 gi l1 e1 g1 store inputs call w1 h1 e1 bl1 true set call witness ol1 go l1 w1 g1 store outputs l2 il2 gi l2 e2 g2 store inputs call w2 h2 e2 bl2 true set call witness ol2 go l2 w2 g2 store outputs one block for each pair of call sites for a pair of mapped procedures .... if bl1 b l2 f for l1 l2 pair store the globals stg1 st g2 g1 g2 g1 g2 gi l1 gi l2 call k1 k2 ms h1h2 i l1 i l2 assume k1 o l1 g1 go l1 assume k2 o l2 g2 go l2 restore globals g1 g2 st g1 st g2 g ... return g figure composed procedure for f1and f2.
figure describes a composed procedure ms f1 f2 that is constructed for each pair of mapped procedures.
first note that the signature parameters modi es sets of the procedure is a disjoint union of the signatures of the individual procedures.
the body of ms f1 f2 consists of sequential composition of the bodies of f1and f2 in addition to some extra instrumentation.
since loops are already extracted as tail recursive procedures the body of any procedure contains no loops.
the instrumentations consist of two parts.
the rst part consists of storing the input and the output state at each call site.
the second part consists of constraining the outputs of pairs of call sites from di erent programs to be the result of executing the corresponding composed procedure over the input states at the two call sites.
this allows us to infer facts about pairs of procedure calls and to apply them in context.
we describe each of the steps in detail with respect to a pair of call sites from f1and f2respectively.
at a given call site say for label l1 we store the arguments and theinput value of global variables into local variables i l1 and gi l1 respectively.
since f1only modi es globals from g1 it su ces to store this subset of globals.
similarly we record the returned value and the globals after return into local variables o l1 and go l1 respectively.
each call site also has a local boolean witness variable b l1 that is initialized tofalse and set to true after the call has returned.
the gure shows the transformation of the two particular call sites other call sites in the remainder of the procedures are similarly instrumented indicated by the double brackets in .
after the instrumentation of the bodies of the two procedures we add a conditional block for each pair of mapped call sites.
the blocks are guarded by the boolean witness variables for the call sites these blocks are executed only when the corresponding call sites were encountered in an execution and both returned.
each block rst stores the values of the globals into local st gi variables.
next it calls the composed procedure ms h1 h2 this time for the pair of callees with the calling contexts restored from the gi li variables passing stored arguments i li as inputs to the composed procedure.
the return values returns and globals are constrained to be the recorded values from after the two calls using the assume statements.
finally the globals are restored from the st gi variables erasing the e ect of the call.
we use the notation 2to denote a composed state consisting of a state from the two programs with disjoint signatures.
theorem .for two programs p1andp2and two procedurep12p1andp22p2 2tp1and 2tp2 if and only if 2tmsp1p2.
proof.
we only sketch the main ideas here.
the rst part ofmsp1p2has the e ect of executing p1andp2in parallel recording the pre and post states of the procedure calls in ghost variables.
the second part always has a terminating execution and has no e ect.
that is by induction on recursion depth we can assume the theorem for the call to msh1h2.
this guarantees a behavior for which the subsequent assume statements are true.
moreover the program s global state is restored.
thus the net e ect of msp1p2is simply to execute p1andp2.
theorem illustrates that the transformation performed is not just limited to performing di erential assertion checking but provides a general method to exploit similarity between procedures in program proving.
the main power of the transformation comes from providing the additional composed procedures over which one can write speci cations towards the proof of a nal speci cation like dac .
an invariant inference engine now has the extra exibility to infer invariants about the composed procedures in addition to the procedures in p1andp2.
consider two versions of foo figure where the second version accesses fewer indices in the array a. let us assume that the loops are extracted into procedures loop.
and loop.
respectively omitted for brevity .
our approach will generate the following composed method ms loop.1 loop.
.
the relative speci cation using the keyword post says that if the values of iandokare equal at the start of a loop execution then loop.
fails less often than loop.
.
this is an inductive speci cation and also su cient to prove the dac property for the outer procedures foo.
and foo.
.var a .
int const max int proc foo.
f var i int t int i while i max f assert valid i t a. i i g gvar a .
int const max int proc foo.
f var i int t int i while i max f assert valid i t a. i i g g figure running example.
post i .
i. old ok. old ok. ok. ok. proc ms loop.
loop.
i. t .
i .
t .
returns i .
t .
i .
t .
modi es ok. ok. the example also illustrates one other important aspect.
the speci cations of composed procedures typically have a simple relative form but are not entirely trivial to obtain.
if we had included the equality t. t. alongside i. i.2our speci cation would have been too weak since tis not initialized on entry to the loops.
mutual speci cations are often mostly independent of the speci c invariants of procedures a great advantage but may not always be the trivial equality over allthe state variables in scope.
.
relative and absolute specifications on the other hand let us consider the complexity of the speci cations without the composed procedure.
to prove the dac property on the two versions of foo one will need to provide the following precondition for foo.
pre forall j j j max valid j informally this provides the weakest precondition of foo.
to ensure that the procedure does not fail.
in addition we will need a loop invariant on loop.
procedure pre i. i. max although this is another way to prove the dac property it demonstrates that one may require program speci c possibly quanti ed invariants since it talks about max that may become arbitrarily complex to specify and more di cult to infer.
on the other hand the relative speci cation used for proving the dac property using the composed procedure can be fairly easy to guess as it may depend little on details of the actual procedures.
.
inferring relative contracts since the composed procedures have the same syntax as the underlying procedures in piprograms we can use any invariant inference technique that can be used to generate invariants for piprograms.
in particular we can use ideas based on abstract interpretation predicate abstraction techniques and interpolants .
however any invariant synthesis technique is necessarily incomplete and might either be limited by the underlying domain or may divergetrying to nd the inductive invariant.
therefore it is wise to inject some domain knowledge while looking for invariants for proving di erential properties like dac .
in general there are two forms of contracts for a composed procedure such as msf1f2in figure .
the precondition of such a procedure would be a predicate over the parameters and globals i1 i2 g1 g2 and the postcondition would be predicate over the input and output parameters and globals i1 i2 old g1 old g2 r1 r2 g1 g2 we assume that the read sets are also included in giglobals.
further many natural two state postconditions have the form i1 i2 old g1 old g2 r1 r2 g1 g2 .
finally each of and usually relate mapped variables whenever such a mapping can be easily obtained by matching names or types from the two programs using relations such as equality inequality and boolean implications.
.
conjunctive relative specifications we describe a simple scheme for synthesizing a subset of the speci cations described above namely conjunctive relative speci cations.
for each composed procedure we automatically generate a set of candidate preconditions and candidate postconditions and use the houdini algorithm to infer a subset of these that are inductive for the program and prove the speci cation.
houdini performs a greatest x point computation starting with the set of all candidate contracts as live preconditions and postconditions and kills a candidate when it cannot be proved modularly assuming the other live candidates.
the process is repeated until either no candidate can be removed or the desired speci cation can no longer be proved.
in the former case a su cient inductive invariant has been synthesized for the speci cation the latter case indicates either the property does not hold or the set of candidates is insu cient.
for boogie programs one can use an e cient implementation of houdini algorithm using the contractinfer switch in boogie .
now we describe the set of candidates that are automatically generated for each composed procedure such as msf1f2in figure .
for simplicity we also assume that each program pihas a single entry procedure say p0 i that is not called from within piand all procedures in pihave a body.
for each fi i2 f1 2g let us denote iias inparameters mias the refset of globals rias the outparameters and gias the mod set of globals.
for each procedure other than the entry procedure we rst de ne the setsviasii mi for preconditions and ri gi for postconditions .
for any pair of mapped variables v12v1and v22v2 we add the following expressions as either preconditions or postconditions i fv1 v2 v2 v1gfor booleans ii fv1 v2 v2 v1gfor integers and iii fv1 v2gotherwise.
given these candidates houdini algorithm generates the strongest inductive conjunctive invariant if any over these candidates that can prove the dac speci cation.
.
ev aluation in this section we describe an implementation and evaluation of dac inside symdiff .symdiff is an infrastructure for leveraging program veri cation techniques for comparing programs.
the tool is agnostic to source languages c java c x86 as it operates on the boogie intermediate veri cation language.
it currently has a front end for c programs using the havoc tool that we use for our experiments.
internally symdiff leverages the e cient ver i cation condition generation in boogie along with the z3 theorem prover to verify loop free and call free fragments.
the implementation of dac consists of around lines of c code and mainly performs the following program transformations i introduces an okvariable and rewrites the assertions present in a program ii generates the composed procedures figure iii adds the dac speci cation for the entry procedures and iv generates the candidate contracts for the composed procedures x5.
.
in addition for each procedure p it adds a postcondition ok old ok this captures the semantics that the okvariable can only transition from truetofalse.
in the next two subsections we describe our experience with applying dac towards two directions.
first we evaluate the inference of relative speci cations for verifying bug xes for a set of small c examples with unbounded loops x6.
.
next we evaluate the e ectiveness of dac as a mechanism for ltering alarms for evolving programs compared to checking assertions on a single program x6.
.
.
verifying bug fixes table describes the result of performing dac on a set of c examples except iter which is a hand written boogie example .
each example contains between one and three procedures with at least one loop.
the rst two examples are already described in this paper iter in section and strcpy in figure .
the rest of the examples are drawn from the verisec suite containing snippets of open source programs which contained bu er over ow vulnerabilities as well as the corresponding patched versions.
.
for each of these benchmarks we add an assertion assert valid p before any dereference to a pointer expression p. this includes array accesses where a is treated as a n i for an array whose base type occupies nbytes.
performing dac checks that the corrected version is dereferencing only the memory locations which the buggy version does and the bug x has not inadvertently increased the memory footprint.
table bug x veri cation results.
glbs denotes globals in the boogie translation of each program cands denotes candidate preconditions or postconditions infrd denotes the subset of cands that were inferred by houdini .
example glbs cands infrd iter strcpy apache madwifi madwifi sendmail sendmail the examples in the verisec suite range from around to lines of c code see figure for the sendmail example .
table indicates that the number of global variables is non trivial in each example except iter which is a manually encoded boogie program .
these globals generated by havoc model various aspects of c semantics including maps for each pointer types and elds allocation status of pointers and deterministic sequence of values returned by functions such as nondet int figure .
findingthe right relative speci cations can be extremely time consuming given the sizes of product programs.
therefore the inference is quite invaluable in discovering the relative invariants needed to prove the dac property even for these small c examples.
only one example apache required an additional absolute speci cation not generated by our tool it speci es that a loop index variable never decreases.
for the rest of the benchmarks we were able to automatically infer contracts which were su cient to prove that the memory footprint of the correct version was no larger than the footprint of the buggy version.
the pair of procedures for sendmail in figure illustrates a couple of challenges for di erential reasoning.
first note that the x resets the counter fbto under some condition.
therefore the values of fbon the two programs will get out of sync after fbreaches maxline since the buggy program will continue to increment fb.
hence the precondition of the composed procedure for the loops only satis es the speci cation fb fb 1as opposed to fb fb .
second if valid is completely unconstrained one may not be able to prove the dac property modularly without using quanti ers in the invariants to record the history of accesses in the rst loop.
instead we constrain valid by the axiom 8x y x y valid y valid x x3.
allowing the simple relative speci cations to prove the dac property.
intmain void f ... fb while c1 nondet int !
eof f bad fbuf c1 fb g force out partial last line if fb f bad fbuf eos g return gintmain void f ... fb while c1 nondet int !
eof f ok fbuf c1 fb if fb maxline fb g force out partial last line if fb f ok fbuf eos g return g figure example of modular bug x veri cation sendmail .
the bad and ok denote buggy and xed bu er accesses respectively.
hence we have demonstrated that dac can be used for veri cation of bug xes.
starting from buggy and correct versions of programs from a standard bu er over ow benchmark dac automatically infers relative contracts and proves that the bug x does not introduce dereferences of new locations hence eliminating the possibility of a regression.
.
filtering warnings in this section we evaluate the trade o s of di erential reasoning as a mechanism for ltering warnings from a program veri er for evolving programs.
when a single program is analyzed for some speci cation say memory safety by a veri er for some programs invariably there is a ood ofwarnings.
many such warnings are false alarms due to the limitations of static checking.
a developer in such a situation will need some knobs which can lead him to warnings of interest.
in evolving software projects a user is often less concerned with warnings that were present in the earlier releases.
in this section we perform two case studies for exploring such knobs with benchmarks from software artifact infrastructure repository and windows device drivers1.
for this section we check the dac property with respect to the absence of null dereference errors.
each dereference of a pointer pis preceded with an assertion about valid p .
unlike the previous section we however do not solely focus on changes that correspond to bug xes for this class of assertions.
for the purpose of this section we have done several restrictions and simpli cations.
first the loops present in any procedure are unrolled two times.
this is done to separate the bene ts of dac from the precision gain obtained by using an invariant inference engine.
second we only consider one candidate postcondition for the composed procedure where the mapped procedures are semantically equal.
this is the default summary considered by symdiff for performing equivalence checking.
in other words the summary of the composed procedure msp1p2is limited to either the procedure equivalence or the trivial summary true.
we instantiate the framework with ve con gurations i single each procedure in p2 without taking p1into account a ected by the change is checked modularly without any preconditions and callee postconditions.
this is the default behavior of the static analysis performed by havoc .
ii sound when analyzing p1andp2di erentially we use the candidate summaries described above for the callees.
iii unsound we assume that callees do not modify the okvariables.
this amounts to unsoundly assuming that callees do not fail even when called from di erent states in p2 compared to p1.
iv shallow we unsoundly assume that callees are equivalent including the e ect on the okvariables.
v nonmodular we check dac non modularly by inlining callees and do not use any speci cations.
we have designed the di erent options to compare modular dac represented closest by sound with a non di erential reasoning single b non modular dac nonmodular c e ect of increasing unsoundness unsound andshallow which in turn restricts the adversarial environments a static analysis can consider while analyzing a procedure on a large class of examples.
note that the degree of unsoundness increases in going from sound tounsound toshallow .
these modular analyses try to nd a single input for an internal procedure for which p1does not fail but p2does.
on the other hand nonmodular performs an analysis assuming equal inputs only for the entry procedures only and not for the internal procedures hence it is incomparable with the other options.
as expected our experiments demonstrate that sound unsound shallow in terms of versions that have warnings.
we have also observed that the runtime of nonmodular is often times more expensive compared to the modular approaches.
table describes the results on the siemens andspace suite of c benchmarks available from the software artifact infrastructure repository .
each program in this suite 1microsoft windows driver kit wdk available at several versions the column versions that correspond to injecting various bugs encountered during the development of these benchmarks.
however these bugs are usually functional bugs changing some conditional or mutating an arithmetic operation that often do not manifest in null dereference errors.
as can be seen from the table the number of warnings versions out of a total of versions in procedures arising while checking null dereference absolutely single can be quite high even when focusing on the procedures impacted by the change.
in comparison number of warnings progressively decreases with the use of sound unsound and shallow options.
the nonmodular represents the true set of dac errors however inlining does not scale to large programs such as space .
out of these warnings we have con rmed that warnings in schedule are true null dereference bugs caused by the change.
we also notice that unsound and shallow options are very similar in nature except that more procedures can fail in unsound e.g.
schedule2 .
figure from schedule2 shows an example where performing di erential reasoning allowed suppressing a warning generated by single .
on analyzing just a single procedure every dereference of jobis agged as a warning since the input value of jobcan be null.
dac is able to show relative correctness the second program does not dereference a null pointer if the rst one does not.
int getprocess prio ratio job int prio oat ratio struct process job f ... if ratio .0jj ratio .
return badratio ... job next if job f ... return true g else return false gint getprocess prio ratio job int prio oat ratio struct process job f ... if ratio .0jj ratio .
return badratio ... job next if job f ... return true g else return false g figure di erence between single and sound onschedule2 .
the line in italics shows the change.
for the same example the di erence in unsound andshallowcan be seen by looking at the caller upgrade prio of get process that is syntactically unchanged either version in figure .
unsound ags a warning because it expects get process to return di erent values in p1andp2for the jobvariable after its call to get process since the two versions of get process are not equal whereas shallow does not.
finally figure shows an example where a false warning was caused due to a missing speci cation of a callee again from schedule2 whenever get process returns a positive value in the status variable the variable jobis initialized to a non null value.
hence even with strong unsound assumptions made by shallow for the callees modular dac can still cause false warnings due to missing summaries.table nameis the name of the benchmark version is the number of di erent versions analyzed.
locis lines of code and procs is the number of procedures in each program.
the numbers x y mean that xversions and yprocedures show warnings.
mo is a out of memory exception.
name single sound unsound shallow nonmodular versions loc procs printtokens printtokens2 replace schedule schedule2 totinfo space mo total table nameis the name of the benchmark diffis the number of procedures syntactically modi ed between vista and win7 symdiff is the number of procedures for which the summary is truefor the composed procedure.
locis lines of code and procs is the number of procedures in win7 driver.
name diff symdiff single sound unsound shallow nonmodular loc procs firefly moufilter pciide sfloppy diskperf event cancel total intupgrade prio prio ratio int prio oat ratio f int status struct process job if prio 1jj prio maxloprio return badprio if status getprocess prio ratio job return status job!priority prio ... gintupgrade prio prio ratio int prio oat ratio f int status struct process job if status getprocess prio ratio job return status job!priority prio ... g figure imprecision in shallow table shows the result of comparing two versions of sample device drivers in the windows device driver kit winddk .
the drivers for windows vista were considered asp1and the drivers for windows were considered as p2.
the rst column shows the name of the driver.
the second column shows the number of procedures which were syntactically modi ed in going from vista winddk to win7 winddk for the same driver.
the third column shows the number of functions which symdiff failed to prove equivalent.
again the results are expected the number of alarms are more for absolute correctness single than rel ative correctness.
the sound strategy raises more alarms than the unsound and shallow strategies.
as mentioned earlier the examples sfloppy and event illustrate that the set of warnings from sound does not always overapproximate nonmodular .
for cancel the option sound shows a warning whereas single does not this happens due to the fact when mapped callees in the programs are called with di erent inputs sound allows for the callee in the old program to pass and the callee in the new program to fail.
the experiments illustrate the feasibility of modular dac towards providing a set of systematic knobs to narrow down the set of warnings resulting due to the program modi cation.
.
related work the idea of relative speci cations is certainly not new it goes back at least to checking simulation between two designs usually at di erent levels of abstraction using renement mappings .
in contrast dac speci cations are not necessarily re nement checks the assertions present in a given program can be used to induce the relative speci cation.
we use the reference program both to infer the unknown environment speci cation and also to help construct a modular proof.
a concept similar to dac has been explored in the context of ltering alarms for assertion checking of concurrent programs however this method applies only to bounded programs see x3 for details .
relative relaxed progress and memory safety have been formalized in the context of approximate program transformations however little automation exists in checking them.the most popular form of relative speci cations for programs is equivalence checking.
such speci cations come up most naturally while checking for compiler optimizations using translation validation and program refactoring however such speci cations are often too strong for most program changes during the course of evolution.
although dse provides di erential summaries for loop free and recursion free procedures for arbitrary program changes it does not provide a decision problem that dac provides.
in our experience with symdiff separating intended changes from unintended ones is the hardest problem when displaying di erences to a user dac provides an intuitive speci cation whose violations are expected to be interesting for a user.
moreover the dac speci cations need not be very program speci c and can talk about relative speci cations such as using the valid predicate for checking memory safety di erentially that are fairly abstract and thus applicable to most programs.
product programs have been studied in the context of translation validation and checking information ow properties these methods have been uni ed and generalized by recent works of barthe et al.
.
similarly severals works on translation validation infer simulation relations between synchronization points in two procedures to prove equivalence after intraprocedural transformations.
however these approaches only deal with intraprocedural transformations and do not account for interprocedural transformations.
the construction of the composed program x4 allows for specifying and inferring intermediate relative speci cations for pairs of possibly non equivalent procedures.
finally unlike previous approaches we provide a mechanism to leverage any o the shelf program veri er and invariant inference engine to check these relative speci cations.
the idea of comparing two programs with respect to assertions present has been suggested in previous works but they do not provide a mechanism to specify or generate intermediate relative speci cations especially for loops and recursion.
mutual summaries provide a mechanism for writing relative speci cations by using quanti ed axioms to constrain the summaries of a pair of procedures.
these mutual summaries can be seen as postconditions on the composed procedures.
however the approach cannot leverage o the shelf invariant inference engines to discover the intermediate relative speci cations.
on the other hand provides a modular checking for relative termination that is currently not handled by our dac formulation.
in the context of verifying safety of bug xes gu et al.
investigate thecompleteness of a bug x with distance bounded weakest precondition but cannot provide any soundness guarantees in the presence of unbounded loops and recursion.
.
conclusion in this work we have described dac as a mechanism for trading o cost for guarantees obtained while verifying evolving programs.
we have reduced checking dac to the analysis of a single program that can utilize standard program veri cation and invariant inference tools.
we have provided an implementation of a simple scheme for automating the inference and applied it towards verifying bug xes and ltering alarms in real programs.
we are currently integrating other tools based on interpolants to generate relative speci cations when the current scheme does not su ce.
.
supplementary information in this section we describe how loops are transformed into tail recursive procedures.2although extracting loops as tail recursive procedures is fairly standard our approach di ers from previous approaches by avoiding the introduction of non determinism in modeling the extracted procedure.
this is important when comparing two programs internal non determinism makes program comparison di cult .
our approch requires that the control ow graph isreducible i.e.
there is only one entry point for a loop.
this assumption is true for almost any program generated from high level languages such as c and java.
we illustrate our approach informally using the example below where we use goto statements to model various control ow constructs present in high level languages l0 s1 goto l0 continue s2 goto l1 break jmp return s3 goto l0 loopback l1 s4 the loop is replaced by the following code fragment where we use to denote transforming any loops recursively inside a statement s. l0 i call l0 loop i assume false goto l0 goto l1 break jmp return assume false goto l0 l1 here irepresents the non global variables in scope.
in addition to the call to the tail recursive procedure l0 loop the interesting aspect is the duplication of the last iteration of the loop body after the recursive call.
the purpose of this is to handle goto statements that jump out of the loop such as goto l1 .
the body of the tail recursive procedure transforms jumps to the loop head as tail recursive calls.
the main change to make the extracted procedure deterministic is to replace the jumps outside the loop by a statement that restores the state of the return and globals to the initial state.
proc l0 loop i i f i i i call l0 loop i tail recursive call return i i g old g return restore state i call l0 loop i tail recursive call return g 2the exact boogie options to be speci ed are printinstrumented extractloops deterministicextractloops .
.