see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation golden implementation driven software debugging conf erence paper no vember .
.
sour ce dblp citations 33reads author s including ansuman baner jee indian st atistic al instit ute publica tions citations see profile abhik r oychoudhur y national univ ersity of sing apor e publica tions citations see profile zhenk ai liang national univ ersity of sing apor e publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y abhik r oychoudhur y on may .
the user has r equest ed enhanc ement of the do wnlo aded file.golden implementation driven software debugging ansuman banerjee abhik roychoudhury johannes a. harlie zhenkai liang national university of singapore banerjee abhik johannes liangzk comp.nus.edu.sg abstract the presence of a functionally correct golden implementation has a significant advantage in the software development life cycle.
such a golden implementation is exploited for software development in several domains including embedded software a low resourceconsuming version of the golden implementation.
the golden implementation gives the functionality that the program is supposed to implement and is used as a guide during the software development process.
in this paper we investigate the possibility of using the golden implementation as a reference model in software debugging.
we perform a substantial case study involving the busybox embedded linux utilities while treating the gnu core utilities as the golden or reference implementation.
our debugging method consists of dynamic slicing with respect to the observable error in both the implementations the golden implementation as well as the buggy software .
during dynamic slicing we also perform a stepby step weakest precondition computation of the observable error with respect to the statements in the dynamic slice.
the formulae computed as weakest pre condition in the two implementations are then compared to accurately locate the root cause of a given observable error.
experimental results obtained from busybox suggest that our method performs well in practice and is able to pinpoint all the bugs recently published in that could be reproduced on busybox version .
.
.
the bug report produced by our approach is concise and pinpoints the program locations inside the busybox source that contribute to the difference in behavior.
categories and subject descriptors d. .
testing and debugging debugging aids symbolic execution d. .
processors debuggers general terms experimentation reliability keywords embedded linux software evolution symbolic execution permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.
.
introduction software debugging can be an extremely time consuming activity.
it seeks to answer the following question given a program p and a test input twhich fails in p how to explain the failure of tin p?
debugging usually returns a bug report a fragment of pthat is highlighted to the programmer.
we observe that debugging of a given test input in a buggy program can be aided by the presence of a golden implementation.
this golden implementation captures how the buggy program is supposed to behave.
the presence of such golden implementations are common in many domains such as for embedded software where the embedded software is derived as a low resource consuming equivalent of a golden implementation or for web servers where both the buggy and the golden implementations implement the http protocol .
it should be noted that the golden implementation often employs different data structures as compared to the program being debugged.
to exploit the golden implementation in software debugging the debugging method should be based on semantic analysis.
evolving programs where the code of a program evolves from one version to another1 can be viewed as a special case of golden implementation where the older version of an evolving program can be treated as a golden implementation.
for evolving programs the older version or golden implementation is quite similar in terms of code to the buggy implementation.
in this paper we study how the golden implementation can be effectively exploited for software debugging.
our method involves simultaneously performing dynamic slicing and symbolic execution in both the programs the golden implementation as well as the buggy implementation.
the slicing is performed with respect to the observable error which is set as the slicing criteria.
moreover given the specification of the observable error we perform a step by step weakest pre condition calculation along the dynamic slice.
the resultant weakest pre conditions accumulated in the two programs are then compared to find new missing constraints accumulated in the buggy implementation.
the lines of code contributing to these constraints form our bug report.
we employ our methods on busybox the de facto standard for embedded linux devices.
it provides many of the standard linux utilities but has a smaller code size size of the executable than the gnu core utilities net tools and procps.
we choose two versions of busybox namely version .
.
and the latest version .
.
and employ our methods to find the root causes of errors that have previously been reported in very recent literature .
in 1here we consider software evolution where the new program version may have additional functionality but the requirements for the functionality which are common across the versions are not changed.
in other words the code for the common functionality may have evolved but not the requirements.particular reports a test generation method which is used to find problematic test inputs i.e.failing test cases for the busybox tool suite.
in this paper we seek to find an accurate bug report explaining the failure of these test cases.
it should be noted that all of these errors are realfaults done by programmers rather than being deliberately seeded faults.
at this point let us step back and study whether any existing debugging method can pinpoint the errors in busybox.
this will also inspire and drive us to develop a new debugging method.
will delta debugging work.
note that the golden implementation in this case the coreutils net tools and procps and the buggy implementation busybox are supposed to be functionally equivalent.
a natural question that arises is as follows can we simply treat coreutils and busybox as two program versions?
unfortunately the answer is no!
due to the demands of low resource consumption and less code size busybox often employs completely different algorithms and data structures to perform the same tasks as in coreutils.
for example the implementation of the trutility is quite different in terms of source level implementation.
moreover busybox implements wrapper functions over many of the system function implementations e.g.
getopt that correspond to a lightweight variant of the original utilities.
as a result we cannot use debugging methods such as delta debugging which enumerates and analyzes the changes across program versions the code is greatly changed in going from coreutils to busybox!
will darwin work.
in a recent work we have developed the darwin approach which can simultaneously analyze the behavior of a test input in two programs that are supposed to be semantically equivalent.
thus the method can be applied to two versions of a program or two completely different implementations possibly with different algorithms and data structures of the same specification.
however while employing the darwin method for explaining the busybox bugs we came across a technical issue.
the darwin method is most suited for explaining errors that are exposed by a difference in control flow errors in branch statements or errors due to missing code containing branches.
in the busybox toolkit the failing test inputs often followed equivalent paths that is for coreutils and busybox the path conditions of the failing test input which is computed by symbolic execution on the two are found to be logically equivalent.
this necessitated looking beyond the darwin method.
a new debugging method.
our proposed method works as follows.
given the failing test input t the golden implementation pand the buggy implementation p0 we first characterize the observable error in terms of an output variable getting an unexpected value at the end of the program.
if the observable error is a program crash we cast it as a variable getting an unexpected value at the crash site.
in either case debugging now boils down to answering a query of the form why is variable out 0at the last visit of line number lwherelis the site of output or a site of program crash .
we answer such a question as follows.
.
we perform backwards dynamic slicing on the execution trace oftin programs pandp0.
the slicing criteria is l out taken from the query we are seeking to answer.
.
while traversing the execution trace during dynamic slicing we also compute the weakest precondition wp of the formula out .
note that the weakest pre condition is only computed for the statements that are in the dynamic slice.
it terminates when the slicing terminates.
having performed the two steps given in the preceding we compute two formulae and 0as the weakest pre condition wp in programspandp0.
since we have computed wp on a single exe cution trace these formulae are conjunctions of the form mand n we find a constraint jwhich is not logically implied by or symmetrically a constraint iwhich is not logically implied by .
once such a constraint j or i is found we locate the lines in the program p0 orp which contributed to j or i thereby constructing our bug report.
contributions.
concretely the contributions of this paper are as follows.
we study the problem of debugging software with respect to its golden implementation.
our new debugging method combines dynamic slicing with weakest pre condition computation.
symbolic execution along the dynamic slice is performed in both golden and buggy implementations to compute the weakest pre condition with respect to the observable error.
this gives us a logical explanation of why the error appears in the buggy implementation.
our debugging method can also be used to root cause code errors resulting from software evolution where a test case passes in an old stable program and fails in a new buggy program.
to stress our method we perform a very substantial case study involving the busybox embedded linux utilities root causing bugs in busybox utilities as compared to gnu core utilities.
our experimental results suggest that our method performs well in practice and is able to pinpoint all the bugs published in that could be reproduced on busybox version .
.
and also on the latest version of busybox.
.
overview in this section we first present an overview of our approach via an illustrative example.
the arp address resolution protocol utility is used as an example to demonstrate the working of our methodology.
.
a motivating example program p golden implementation include stdio.h const char get hwtype const char name return name int main int argc char argv const char hw null const char ap null int hw set switch argv case a case p ap argv break case h case t hw get hwtype argv hw set break default break if hw set argv !
h hw get hwtype dflt hw printf s s n ap hw figure simplified fragment of arp in coreutils net tools we create a simplified version of the actual arp implementation in busybox and its corresponding variant in coreutils net tools for the purpose of illustration of our philosophy.
consider the program fragment pin figure .
we can consider this as the goldenimplementation.
the variant of the busybox arp implementation implementing the same functionality is given as the program p0in figure .
program p0is the buggy program version.
program p buggy implementation include stdio.h const char get hwtype const char name return name int main int argc char argv const char hw null const char ap null int hw set if argv a argv p ap argv if hw set argv !
h hw get hwtype argv printf s s n ap hw figure simplified fragment of arp utility in busybox consider an execution of the two programs as cuarp a inet andbbarp a inet where bbarp and cuarp are respectively the names of the executables resulting out of p and p .
figure shows a source level view of the execution traces of the two programs.
evidently the output of cuarp is as expected inetdflt hw while the output of bbarp is inet null sinceargv is null which is undesirable.
as an objective of investigating the incorrect value of hardware type we set out to find the root cause as to why the variablehwis set to a null value at the end of the program execution.
.
will other methods work?
we now show the working of existing debugging methods.
trace comparison.
in our example the two programs are quite different from the implementation perspective the only resemblance being the structure of the get hwtype function.
hence an attempt to establish a mapping of the execution traces of the two programs may be quite an arduous task.
consider the traces shown in figure .
the only similarities they share are in lines and the rest of the traces are different and exhibit different execution flow.
any difference metric we choose to compare the traces statements executed set sequence of branches executed and so on will report a large difference between the traces and will be unsuccessful in pinpointing the root cause.
darwin.
we now employ the darwin method on the example program.
for the sake of completeness we briefly describe the basic darwin methodology here.
given the programs p and p darwin will proceed as follows .
run program pfor test input a inet and calculate the resultant path condition f a formula representing set of inputs that exercise the same path as that of a inet in programp.
in our example the path condition fis as follows argv a jj argv p hw set argv h .
.
run program p0for test input a inet and calculate the resultant path condition f0 a formula representing set of inputs which exercise the same path as that of a inet in programp0.
in our example the path condition f0is as follows 9c o n s t char hw null const char ap null 9c o n s t char hw null const char ap null i n th w s e t if argv a argv p ap argv if hw set i n th w s e t switch argv case a case p ap argv argv !
h hw get hwtype argv const char get hwtype const char name return name break if hw set printf s s n ap hw argv !
h hw get hwtype dflt hw const char get hwtype const char name return name printf s s n ap hw trace from program p shown in figure trace from program p shown in figure f g gfigure execution traces of the programs from figure and argv a jj argv p hw set argv h .
.
here we find that fandf0are equivalent that is f f0.
thus no solutions can be found for f f0orf0 f. the darwin method fails to create a bug report!
the darwin method requires the path conditions of the test inputtbeing debugged to be different in the two implementations.
in other words the effect of the bug should appear via a difference in control flow.
as a result assignment errors can only be handled by making the effect of a wrong assignment observable usually through explicit instrumentation of predicates into the code which was not done in this case.
.
our method at work we now explain the working of our debugging method.
we perform backward dynamic slicing and simultaneous weakest precondition computation on the execution traces produced by p and p .
we chose the slicing criteria by analyzing the observable error or the crash location.
the resulting slice includes all the statements in the program that influence the slicing criteria through data or control dependencies on the entire execution trace.
the backward dynamic slice computation is inter procedural and attempts to compute the transitive closure of the data and control dependencies encountered in the path from the slicing point in our case the bug location to the start of the execution trace.
the weakest pre condition computed is simply a conjunction of constraints on the input variables that contribute to the satisfaction of the post condition attributed to the slicing criteria at the slicing point .
a comparison of the slices more specifically the weakest pre conditions reveals the difference in transformation induced in the two program executions.
this helps us pinpoint the root cause of the error.
our core method works as follows.
.
we run the program pfor test input a inet and record the execution trace at the binary level .
the execution trace at the source level is shown in fig .
.
we run the program p0for test input a inet and record the execution trace at the binary level .
.
we identify hwas the slicing variable and the observable error involves hwbeing output as null in program p0.
.
we perform backwards dynamic slicing on the execution trace inp.
the slicing criteria is hw since 26is the line wherehwis printed.
while computing the dynamic slice we compute the weakest pre condition henceforth called wp for the post condition hw6 null .
recall that theobservable error was in hwbeingnull in the buggy programp0.
the execution of the same test input in the correct programpproduces the non null value dflt hw for hw.
hence we compute the weakest pre condition of the formulahw6 null along the dynamic slice.
the dynamic slice consists of the statements at the source level .
the wp computed 1for the postcondition hw6 null is as follows argv h get hwtype dflt hw null .
.
we perform backwards dynamic slicing on the execution trace 0in the buggy program p0.
the slicing criteria is hw since 17is the line where hwis printed.
while computing the backward slice we also compute the weakest pre condition for the post condition hw null .
this is because the observable error lies in hwbeingnull in the buggy programp0.
the slice consists of the statements at the source level .
the wp computed 2for the post condition hw null is as follows get hwtype argv null argv h argv a jj argv p .
.
we compare 1and 2to deduce the difference in program executions.
it is worth noting that since the wp is computed on a trace the resulting wp is a conjunction of constraints.
we proceed as follows.
we check if there is any unexplained constraint in 2that is not implied by .
this is a straightforward implication check for each conjunct iin where k we check if i. if ifor some i we produce it as an unexplained wp constraint.
in our example the constraint argv a argv p in the wp is unexplained and this was contributed by the incorrect functional check in line number .
this helps us identify functionality errors.
in fact this revealed the bug in the busybox arp utility and also of the published busybox bugs we discuss in this paper.
similarly we look for an unexplained constraint in 1that which is not implied by .
in fact for the printf andlsbugs in busybox such unexplained constraints in 1pointed to code missing errors some necessary program fragment that is present in coreutils but is missing from busybox.
it is worth noting that both the above steps are performed at the binary level and we map them back to the source using compiler level information about symbol table .
thus the bug report returned by our method is at the source code level.
.
detailed methodology in this section we elaborate on the different steps of our method.
.
slice computation in this phase we need to execute the test input tunder examination in both the programs.
we first concretely execute tand record the trace for both the programs.
this is followed by identifying the slicing criteria and computing the backward slice with respect to the slicing criteria.
identifying the slicing criteria.
given two programs one of which is the golden implementation let us call it phenceforth and the other a lightweight implementation we call it p0henceforth we intend to characterize the difference in behavior betweenthe executions of pandp0on the test input t. to this effect our first step is to set up a slicing criteria that can be used in both the programs.
since both the programs are expected to implement the same specification it is not difficult to establish a mapping of the output signatures of the two programs obtained by executing them.
the difference in output between the two programs leads us to the slicing criteria the output variable vwhose value differs in the two programs and the slicing point the line number where variable v is output .
our choice of the slicing criteria is found by analyzing the program p0and analyzing the manifestation of the wrong behavior.
the wrong behavior may simply be an incorrect unexpected value of a program variable at a location lof the program or de referencing of null pointers at some location l or overwriting of critical data such as return addresses.
in all these cases the slicing criteria is set on the value of a variable outgetting an unexpected value at line number l the last visit of line number l if it is visited many times .
in our example given in section .
the slicing criteria on the program pin figure is set as h26 hwi andh17 hwifor program p0in figure .
backward dynamic slicing.
the backward dynamic slicing step takes in the following a a trace obtained by executing a programpon test input t and b a slicing criteria of the form hl outi.
the output of the method is a fragment of andp that is likely to be responsible for the observed error.
the dynamic slice routine computes a chain of dynamic data and control dependencies.
formally given a slicing criteria hl oution a trace obtained by executing the program pon a test input t a dynamic slice contains all statement instances or statements that have affected the value of variable outreferenced at lin the trace.
the dynamic slicing algorithm is standard.
we provide below a brief discussion of this algorithm.
during the trace traversal that starts from the statement in the slicing criterion a dynamic slicing algorithm maintains the following quantities a the dynamic slice b a set of variables whose dynamic data dependencies need to be explained and c a set of statement instances whose dynamic control dependencies need to be explained.
initially we set the following last instance of lin the trace ofp and foutg.
for each statement instance stmt encountered during the backward traversal the algorithm performs the following two checks.
the algorithm terminates when we reach the beginning of the trace.
check dynamic data dependencies letvstmt def be the variable defined by stmt.
if vstmt def2 we have found the definition ofvstmt def which the slicing algorithm was looking for.
sovstmt def is removed from and variables used by stmt are inserted into .
in addition stmt is added to and .
check dynamic control dependencies if any statement instance in is dynamically control dependent on stmt all statement instances that are dynamically control dependent onstmt are removed from .
variables used by stmt are inserted into andstmt is inserted into and .
the resultant slice the set is reported as the final dynamic slice.
in our example program pin figure we find the following dependencies given in terms of line numbers shown on the execution trace in figure is data dependent on is data dependent on and and control dependent on is data dependent on is data dependent on .
therefore the dynamic slice computed by our algorithm is h3 26i.
in a similar fashion the dynamic slice with respect to the slicing criteria h17 hwi obtained for program p0in figure ish3 17i.
.
weakest pre condition wp along a slice weakest pre condition of a given post condition c along a program path can be defined as follows.
let be a sequence of instructionshi1 i niin programp whereinis our post condition point wherecshould hold true.
inductively we calculate wp in c cond n thenwp in cond n cond n 2and so on.
the weakest pre condition of calong is then the formula cond 0obtained when we reach the beginning of the trace.
the resulting formula is satisfied by all program inputs that follow the given execution trace in programpand satisfycin control location in.
we now elaborate on the weakest pre condition wp computation method that is at the core of our approach.
the wp computation proceeds along with the slice computation.
at each step of the slice computation the wp is calculated.
the wp computation finishes once the slice computation completes.
weakest pre condition wp computation along a trace usually proceeds by computing the weakest pre condition for every statement.
however in our case we are computing wp along a dynamic slice which makes the computation much more goal directed.
consider the following schematic example where inp1 andinp2 are inputs and x y are outputs.
.
... input inp1 inp2 .
if inp1 .
x f1 inp1 .
else x g1 inp1 .
if inp2 .
y f2 inp2 .
else y g2 inp2 .
... output x y suppose we now perform slicing w.r.t the criteria h8 xifor the program input inp1 inp2 since the value of xthat is observed is unexpected it was expected to be positive but it is observed to be negative.
the execution trace for inp1 inp2 is the sequence of statements h1 8iand the dynamic slice is the set f1 8g.
if we computed wp of x w.r.t.
the execution trace we get inp2 inp1 f1 inp1 whereas the wp along the dynamic slice simply gives us inp1 f1 inp1 .
since the value of inp2is irrelevant to the computation of x and hence for explaining why x 0at the end of the program the wp along the slice does not include the constraint inp2 .
wp computation rules.
to compute the weakest pre condition wp we need to first set a post condition c with respect to which the weakest pre condition is to be computed.
this is straightforward in our case and we use the slicing criteria hl outito generate the post condition.
for our example program pin figure we choose the post condition as hw6 null and for program p0 we set it ashw null .
we now discuss the technical issues in wp computation along a dynamic slice.
since only two kinds of statements namely data dependencies and control dependencies show up when we compute the wp simultaneously with the backward dynamic slice our wp computation algorithm is simple as enunciated in the following.
during the trace traversal that starts from the statement in the slicing criterion the wp computation algorithm maintains the following a the current wp qcomputed so far this is a conjunction of constraints and b an array aof structures where each element is a tuple hlp picontaining the source line number lp for each conjunctpinq.
intuitivelyacaptures a mapping of constraints to line numbers that is for every conjunct in wp it captures the source code line numbers contributing to .initially q canda hl ciwherelis the line number from the slicing criterion.
this helps us in tracing back each wp constraint to the source and is useful for the bug report construction.
for each statement instance stmt encountered during the backward slicing the algorithm updates the current wp as follows.
.data dependency assignment statement for a statement stmt of the formx e we use the following rule wp x e q q the above rule essentially substitutes efor all occurrences of variablexin the currently computed wp q.
.control dependency branch statement for a control statementstmt involving the condition r we use the rule wp r q r q the above rule essentially conjoins the branch condition with the currently maintained wp.
in both the cases we add hlstmt stmtitoawherelstmt is the line number corresponding to statement stmt .
the algorithm terminates when we reach the end of the trace and the slicing routine completes.
the resultant wp is reported.
the wps are computed for both the programs pandp0.
let us examine the application of the rules given above in computing the wp for the example program pgiven in figure .
initially the wp is set as the post condition hw6 null .
for the purpose of easy correlation we refer to the statements with respect to the execution trace shown in figure .
while computing the backward dynamic slice with the slicing criteria h26 hwi we encounter statement hw get hwtype dflt hw as a data dependency.
therefore rule above applies and we have the updated wp as get hwtype dflt hw null .
proceeding we encounter statement if hw set as a control dependency.
hence rule above applies and we have the updated wp as get hwtype dflt hw null hw set .
proceeding in this fashion we compute the wp as argv h get hwtype dflt hw null .
in a similar fashion the wp computed for the program p0with respect to the post condition hw null is argv h get hwtype argv null argv a jj argv p .
.
putting it all together having performed the wp computation on the programs pand p0 we obtain two formulae and 0as the respective weakest precondition wp in programs pandp0.
since we have computed wp on a dynamic slice of an execution trace these formulae are conjunction of constraints that is mand n our goal is now to find a constraint jwhich is not logically implied by or symmetrically a constraint iwhich is not logically implied by .
once such a constraint jis found we locate the lines in the program p0fromawhich contributed to j thereby constructing our bug report.
similarly we find a constraint iwhich is not logically implied by .
again we locate the lines in programpthat contributed to i producing our bug report.
so far we have presented the execution traces slices and bug report at the level of statements.
in our implementation however the traces slices and bug reports are computed at the level of instructions.
the instruction level bug report is reverse translated to the source code level using standard compiler level debug information.
.
implementation we implemented our approach using the bitblaze binary analysis framework as the underlying platform and using stp as the constraint solver.
in this section we describe the implementation of our approach including the system architecture and optimizations made in our implementation.
.
system architecture figure illustrates the system architecture of our implementation which consists of four components trace collection slicing and wp computation wp comparison and mapping to source code .
our implementation takes a golden implementation p the implementation to debug p0 and an input t which demonstrates the error inp0.
it outputs a bug report consisting of locations in the source code of porp0that contributes to the error.
we now describe each component in details.
.
trace collection givenp p0 and the input t the trace collection component uses the temu component of bitblaze to execute the programs using tas the input.
temu is a virtual machine based on qemu emulating a full pc platform.
temu records all instructions executed by a program and indicates the instruction operands that are derived from program inputs.
for each program temu outputs an execution trace containing all the user mode x86 instructions executed in the program.
the trace also contains information about the instruction operands that are dependent on program inputs.
next the instruction traces are converted into traces in the intermediate representation ir used by bitblaze.
an ir trace is semantically equivalent to its corresponding instruction trace.
based on the user input information recorded in the instruction trace we also convert the variables directly dependent on user inputs into symbolic variables.
finally the trace collection component identifies the x86level slicing criteria in both traces and maps them into ir level slicing criteria.
.
slicing and wp computation the slicing and wp computation component implements our solution described in section .
using two ir traces t t0 and the slicing criteria generated by the previous step it computes the slicebased wp of each trace.
this step is implemented on top of the bitblaze s vine module.
vine is the static analysis component of bitblaze that provides an infrastructure for manipulating and performing automated analysis on the ir.
recall that our dynamic slicing algorithm needs control dependency information which is not available in a trace.
in our implementation we use the eresi utility to compute the static control flow graph cfg on program binaries pandp0.
the eresi tool produces cfg for all the functions defined in the binary.
from the cfg we compute the dominator tree using lengauer tarjan algorithm .
from the dominator tree we compute the dominance frontier and then the cdg using the algorithm described in .
the cdg is then fed to our vine based slicing algorithm.
.
wp comparison the outputs of the previous components are two wps each as a conjunction of constraints mand n the goal of the wp comparison component is to find the individual constraint ithat is not logically implied by or ithat is not logically implied by .
to this end this component breaks each wp into a set of individual constraints.
for each constraint i or j we check whether it is logically implied by or .
however the wp of large programs may be inefficient or impossible for the stp solver to handle due to limits in memory or processing power.
to address this issue instead of checking ior i we do pairwise constraint comparison as follows .
iin we check if there is any corresponding constraint kin such that k i holds i n k m .
all constraints i2 0for which a corresponding constraint is not found in are reported as unexplained.
.
iin we check if there is any corresponding constraint kin 0such that k i holds i m k n .
all constraints i2 for which such a corresponding constraint is not found in 0are reported as unexplained.
this is an approximation step but worked quite well for us in revealing all the relevant bugs in busybox.
optimization in wp comparison.
for two wps that have n andmconstraints respectively our approach needs to make mn queries to stp.
this step is time consuming for wps with large numbers of constraints.
since the wps are symbolic formula over program input variables if a constraint ior jis not affected by program inputs it will always be evaluated to true i.e.
it is atautology .
to eliminate unnecessary queries before we check the implication relationship among individual constraints we first use stp to check whether ior jis a tautology and remove the tautologies from the list of constraints.
this step will cost m n additional queries but if a significant portion of the constraints are tautologies the unnecessary queries we avoid is much larger than m n. in section we will show that this optimization achieves huge reduction in the number of queries in some programs.
.
mapping to source code the unexplained constraints generated by the previous component indicate the difference in behavior between the implementation to debug and the golden implementation but they do not directly point to the source of bugs.
to associate the constraints to program locations our approach maintains the connection between constraints in a wp and its corresponding instructions in the trace.
therefore after the wp comparison component outputs a list of unexplained constraints this component can map them to the instructions and program locations that contribute to the unexplained constraints.
with the help of compiler debug symbols we further map the program locations in binaries to source code lines and output them as our final bug report.
.
ev aluation we now report our experience in using our method for locating error causes in real life case studies.
.
experience with busybox we describe our experience in debugging the busybox utilities.
klee detected bugs in busybox and of them can be reproduced using the busybox version .
.
namely arp ainet tr top d printf lu ls co install m .2we also tested the latest version of busybox version .
.
and found that of these bugs tr printf ls still persist.
as the golden implementation we used coreutils .
for the install 2we contacted the authors of klee .
the bugs they reported were on the development branch of busybox and not all of them can be reproduced on the released version of the busybox utility.observable error bug report collection comparisontrace wp source codemapping to p pt t t wp wp unexplained constraintsslicing and wp computation slicing criteriafigure architecture of our approach.
const struct hwtype get hwtype const char name const struct hwtype const hwp hwp hwtypes while hwp !
null if !strcmp hwp name name return hwp hwp return null int arp main int argc char argv .... option mask32 getopt32 argc argv a p h t i adndsv protocol protocol hw type hw type device argv optind if option mask32 arp opt a option mask32 arp opt p ap get aftype protocol if ap null bb error msg and die if option mask32 arp opt a option mask32 arp opt p hw get hwtype hw type if hw null bb error msg and die hw set .... figure source code fragment of the arp utility in busybox ls printf tr utilities net tools .
for the arp utility and procps .
.
for the top utility.
scale of busybox.
the busybox bundle functions as a single executable where the different utilities are actually passed on at the command line for separate invocation.
it is not possible to build the individual utilities separately and run them stand alone.
for example for running the arp utility we need to invoke busybox as busybox arp ainet and record the execution trace.
since we work on the binary level the buggy implementation for us is the busybox binary which has a large code base about lines of code .
locating the arpcrash bug in busybox.
thearp utility manages the kernel s network neighbor cache.
it can add or delete entries to the cache or display the cache s current content.
there is a bug in the busybox arp implementation running arp with the command line option ainet results in a segmentation fault .
however with the same command line option the net tools variant ofarp executes successfully and displays the list of neighboring computers known to the host computer through the inet address family.
we now explain our experience in localizing this bug.
figure shows a fragment of the source code of arp in busybox.
with the command line argument ainet line sets the arp opt a mask in the variable option mask32 .
because no1 int main int argc char argv int i lop what while i getopt long argc argv a h adfp nsei t vh?dnv longopts lop !
eof switch i ... case a case p ap get aftype optarg error check and exit break case h case t hw get hwtype optarg error check and exit hw set break case i ... break case v ... break case ?
case h default ... break if hw set if hw get hwtype dflt hw null error check and exit ... figure source code fragment of arp utility in net tools hortoption was given in the command line hw type was set to null.
the bug is at line instead of checking the mask of hardware type the program checks for the mask of address family arp opt a .
as a result control flows to line which passes the null hw type intoget hwtype function and causes a segmentation fault at line due to a null argument being used in the string comparison function strcmp .
to isolate the root cause of this error we set the slicing criteria as name at the crash site and the post condition as name null.
figure shows a fragment of the implementation of the arp utility of the net tools where the incorrect condition check is not present.
therefore the arp ainet invocation is successful.
to find the root cause of the bug we did an execution of both the program versions on the same input ainet and generated the wps.
after tautology elimination and wp comparison we were left with one unexplained wp constraint from busybox.
the following example is a snapshot of our intermediate result on the bug.
busybox stp unmatched constraint 8052d75 arp main 8052d78 arp main 8052d7a arp main the first number in each line excluding the first line is an id in the bitblaze intermediate representation ir followed by the corresponding instruction address and the name of the functioncontaining the bug.
here our approach found three instructions in arp main that are related to the bug.
with the help of compiler level debug symbols our approach associated all three instructions to the same line in the source code line in figure .
we illustrate the association using the output of the objdump utility which disassembled the busybox binary with symbol information root coreutils busybox .
.
networking arp.c 8052d70 a1 d0 0d mov 0x80d71d0 eax 8052d75 e0 and 0x1 eax 8052d78 c0 test al al 8052d7a 0c jne 8052d88 arp main 0x11f there were eight unexplained constraints from net tools pointing to three lines of source which is the result of additional options implemented in net tools arp and not implemented in busybox.
code missing error in busybox printf .theprintf utility prints data according to a format argument.
the busybox s printf when run as printf lu incorrectly outputs a large number.
however if we run coreutils printf with the same arguments the output is .
using our approach we produced four unexplained constraints from busybox and unexplained constraints from coreutils.
the unexplained constraints in busybox point to a single line of source but it was due to code differences in the print formatted function busybox implements this function using strchr while coreutils version is implemented by switch case statements.
we proceeded to look for unexplained constraints contributed by coreutils.
the unexplained constraints in coreutils point to three lines of code out of which two were due to the implementation difference described above.
the remaining unexplained constraint pointed to the bug which is at the address of 0x8048c29 .
using compiler level information we found that the above instruction is compiled from line of the file printf.c.
switch conversion case d case i case o case u case x case x length modifier pridmax length modifier len sizeof pridmax break case a case e case f case g case a case e case f case g length modifier l length modifier len break default length modifier start length modifier len break .... this code fragment does a check on the formatting character supplied to printf before it is used in the printf function in c standard library.
if u d i o x or x conversion specifier is found it sets the length modifier to ll through the pridmax variable defined in header file system.h and if float conversion character a e f g a e f or g is found it sets the length modifier to l. the format we specified on the command line lu was changed to llu and passed on to the print routine.
therefore the coreutils printf produces a correct output whereas the busybox s printf which passes the lu format specifier directly to the print routine producing a buggy output.results on all six busybox bugs.
our approach successfully identified the root cause of each bug in our bug report.
the findings on all the six utilities and the corresponding data produced and analyzed by our tool are summarized in table which presents comparative data obtained by us on both busybox and coreutils nettools procps.
the first column of table is marked utility this represents the utility whose observable error is being diagnosed.
each entry in the table is a tuple where the first entity is from busybox and the second from coreutils net tools procps.
trace size is the size of the trace in terms of number of instructions obtained from temu.
ir size refers to the number of statements in the intermediate representation ir obtained from vine.
ir slice refers to the size of the slice obtained in ir form.
columns and respectively present the number of wp constraints obtained by our method and the number of wp constraints remaining after the tautology elimination optimization.
column presents the number of lines of source code present in the final bug report obtained after comparing the wps produced and mapping the unexplained terms to the source.
columns and present the time and memory usage requirements of our tool.
it is worth noting a few important facts on table .
first the size of the traces and the size of the ir produced are usually comparable or orders of magnitude smaller in the busybox variant as expected since busybox is a much lightweight implementation.
secondly a significant fraction of the wps are eliminated using the tautology optimization.
for example the number of wp constraints of coreutils lsutility is reduced from to which significantly reduces the time of wp comparison.
last but not the least the bug report produced by our approach is small which is very useful for the programmer.
for each bug in busybox we have at most four lines reported as the bug report!
darwin on busybox.
we tried running the darwin setup on the busybox utilities to see if we can pinpoint any of the six bugs.
since all the six bugs we encounter here involved an incorrect assignment statement the current darwin setup could not produce a bug report without predicate instrumentation.
in all the six cases the path conditions produced by darwin from busybox and coreutils or net tools procps were equivalent.
.
experience with program versions in this section we describe our experience with an evolving program benchmark namely libpng which was used by darwin .
table summarizes the results.
each entry for libpng is a tuple where the first entity is from libpng .
.
and the second is from libpng .
.
.
thus in this case the golden implementation is a stable version of the program.
we now describe our experience with the libpng open source library a library for reading and writing png images.
we used a previous version of the library .
.
as the buggy version.
this version contains a known security vulnerability which was subsequently identified and fixed in later releases.
we used the version .
.
as the golden implementation which has fixed the vulnerif !
png ptr mode png have plte png warning png ptr missing plte before trns else if length png uint 32 png ptr num palette png warning png ptr incorrect trns chunk length png crc finish png ptr length return figure buggy code fragment from libpngutility trace size ir size slice size wp wp constraints loc in time mem.
instructions constraints after elimination bug report min sec usage mb arp .
top .
install .
ls .
printf .
tr .
table experimental results on busybox bugs programs trace size ir size slice size wp wp constraints loc in time mem.
instructions constraints after elimination bug report min sec usage mb libpng .
.
.
.
.
miniweb apache .
table experimental results on two versions of libpng and the miniweb web server ability.
the code base of both the versions are significantly large lines for libpng .
.
and for libpng .
.
.
the vulnerability is shown in figure .
if !
png ptr mode png have plte is true the length check is missed leading to a buffer overrun error.
the error is fixed by converting else if in the code fragment to an if.
after applying our approach to two libpng versions we identified unexplained constraints pointing to only lines in source from libpng .
.
and unexplained constraints pointing to only lines of source from libpng v1.
.
.
the constraints from libpng .
.
show the execution difference but do not help us identify the root cause of the specific bug.
a careful examination revealed one unexplained wp constraint the remaining showed the execution difference from libpng v1.
.
which leads to line of pngrutil.c.
this is a check of the second condition which was missing in the buggy version.
.
experience with webservers we studied the web server miniweb a simple http server implementation.
the input query whose behavior we debugged was a simple http get request for a file the specific query being get x .
ideally we would expect miniweb to report an error as xis not a valid request uri a valid request uri should start with .
however miniweb did not report any errors and returned index.html .
we then attempted to localize the root cause of this observable error.
since the latest version of miniweb also contains the error we chose another http server apache as the golden implementation.
the apache is a well known http server for unix and windows.
apache does not exhibit the bug we are investigating.
apache is a significantly complex implementation with about lines in the code base while miniweb is comparatively a much light weight variant with about lines of code.
thus in this case the golden and the buggy implementation are both implementations of the same protocol http.
the results appear in the second row of table .
the unexplained wp constraint contributing to our bug report pointed to function apr uri parse which shows that apache checks for in get queries and reports accordingly line of apr uri.c .
the miniweb server missed this check and treated the query get x similar to get .
because of this missing check the string x in the get query is thought to be an http header.
.
related work debugging with respect to a golden implementation is related to the problem of debugging evolving programs.
in evolving program debugging a buggy program version is simultaneously ana lyzed along with an older stable program version.
this analysis is done with the goal of explaining an observed error for a particular test input in the buggy program version.
one of the first efforts for evolving program debugging is .
this work identifies the changes across program versions and searches among subsets of this change set to identify which changes could be responsible for the given observable error.
in contrast we employ a semantic analysis of the test input s execution in the two program versions.
recently we proposed the darwin approach for debugging evolving programs.
darwin performs a dynamic symbolic execution along the execution of the given test input in two programs.
thus it is applicable for debugging a buggy implementation with respect to a golden implementation.
however the darwin approach depends on the path condition of the buggy input being different in the stable program and buggy program.
in other words the observable error must be reflected by a difference in path conditions in the two programs.
for the busybox case study this was often not the case.
the main issue here is that the darwin method is most suited for debugging branch errors or code missing errors where the missing code contains branches .
in contrast the method in this paper aims to pinpoint both branch and assignment errors code missing errors are handled by examining the weakest pre condition from the golden implementation.
dynamic slicing see e.g.
has long been studied as an aid for program debugging and comprehension.
a recent work also uses dynamic program dependencies to find the relevant parts of an input that are responsible for a given failed output.
our work augments dynamic slicing with symbolic execution along a path and employs the augmented method for debugging two different programs.
we perform symbolic execution along a dynamic slice by following the dynamic data and control dependencies.
works such as combine symbolic execution and dependency analysis for test suite augmentation.
in particular uses symbolic execution of programs not paths along static data and control dependencies to generate criteria for additional test cases for the purpose of test suite augmentation.
in the authors use dynamic symbolic execution i.e.
along a path to generate additional test cases which stress a program change and reflect the effect of the change in the program output.
the problem we tackle is different instead of trying to find test cases that stress a given program change we are trying to find the root cause of failure of a given test case in a changed program.
in this work we focus on debugging a given failing test case.
these are several directions of work in finding failing tests which demonstrate an observable error such as the dsd crasher approach which combines static and dynamic analysis and bug finding approaches based on software model checking e.g.
.
symbolic execution has also been used for generating problematic or failing tests.
the works on directed automated random testing dart e.g.
see combine symbolic and concrete execution to explore different paths of a program.
a recent work uses symbolic execution on gnu coreutilities as well as busybox to compute test suites with high path coverage.
all of these works are complementary to our work our method can try to find the root cause of the error in the failing test cases generated by these works.
.
limitations the wp comparison and bug localization scheme achieves reasonably good performance for real world programs as recorded by our experiments.
our approach assumes the availability of a stable golden implementation to which the buggy implementation can be compared and the bug can be isolated.
this is a reasonable assumption to make considering the fact that such stable versions are almost always available in any project as the product goes through version driven evolutions and a bug is introduced in refining a stable version to incorporate some changed needs.
another important assumption is the definition of the observable error and the error location in terms of a variable on which the error is manifested.
for our approach to work a similar variable should be present in the golden implementation but this is also usually the case when programs move between versions.
we note that there are various threats to validity to our approach.
one important factor that deserves mention is scalability.
first the wp computation approach is linearly dependent on the size of the dynamic slice.
for programs with little inherent parallelism and having long chains of control data dependencies the sizes of the dynamic slice may be substantially large.
this may lead to significantly large number of wp constraints that need to be analyzed.
this was the case for the lsandinstall experiments.
moreover our method also requires an off line computation of the static cdg.
another element of concern that deserves discussion is the issue of false positives in our bug report.
due to limits in processing power of the smt solver we resorted to an element by element comparison measure for comparing the non trivial wp constraints obtained after tautology elimination.
in some cases our approach will incorrectly report two sets of wp constraints as different though they are semantically same.
consider the example where the wp constraints obtained from the golden program are y x yand those obtained from the buggy program are x 6for integer program variables x y. a pairwise comparison approximation will incorrectly generate unexplained constraints.
however such a situation was not encountered in our experiments.
a second limitation arises due to the comparison method adopted by us.
our method generates some unexplained constraints as bug reports though they are actually due to implementation differences.
since the programs are compiled without jump tables syntactic differences like if else and switch case are automatically filtered out.
however some implementation differences still remain in our bug reports as witnessed in a couple of our experiments.
for example out of the unexplained elements in the bug report for install were due to additional case checks in the command line processing unit in coreutils.
this was due to the fact that there are two additional command line features implemented in coreutils install and the case enumerations for these features v for verbose and b for backup are placed before the check for m install m is the bug .
differences in implementation style also cropped into our bug report for printf and were not filtered out.
in this case the command line processing is implemented using strchr in coreutils where a longword is tested at a time.
the busybox variant employs thetraditional loop which tests each character at a time.
thus unexplained loc from busybox and unexplained ones from coreutils point to this implementation difference but we report these as bugs.
in summary our method can report false positives whenever there are implementation differences that enter the dynamic slice and thereby participate as wp constraints.
however we noticed that the ability to point to the bug with a few additional lines of false positives is tolerable in practice since our main goal is aid the debugging comprehension of the program versions.
.
discussion in this paper we have presented a debugging methodology and tool for root causing errors in programs with a golden program as a reference.
our toolkit takes in a given buggy implementation and the reference golden implementation and combines slicing and symbolic execution to explain the behavior of a test input which passes in the golden one while failing in the buggy program.
our experience with real life case studies including the busybox embedded linux distribution demonstrates the utility of our method for localizing real bugs.
the bug report generated by our method is concise thereby aiding the programmer to localize the root cause of a given observable error.