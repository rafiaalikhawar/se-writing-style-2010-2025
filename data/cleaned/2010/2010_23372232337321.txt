automatic parameter recommendation for practical api usage cheng zhang1 juyuan yang2 yi zhang2 jing fan2 xin zhang2 jianjun zhao2 peizhao ou2 1department of computer science and engineering 2school of software shanghai jiao tong university china cheng.zhang.stap zhao jj sjtu.edu.cn juyuanyang yizhang1990.mail j.fan hyperzh peizhao.ou gmail.com abstract programmers extensively use application programming interfaces apis to leverage existing libraries and frameworks.
however correctly and efficiently choosing and using apis from unfamiliar libraries and frameworks is still a non trivial task.
programmers often need to ruminate on api documentations that are often incomplete or inspect code examples that are often absent to learn api usage patterns.
recently various techniques have been proposed to alleviate this problem by creating api summarizations mining code examples or showing common api call sequences.
however few techniques focus on recommending api parameters.
in this paper we propose an automated technique called precise to address this problem.
differing from common code completion systems precise mines existing code bases uses an abstract usage instance representation for each api usage example and then builds a parameter usage database.
upon a request precise queries the database for abstract usage instances in similar contexts and generates parameter candidates by concretizing the instances adaptively.
the experimental results show that our technique is more general and applicable than existing code completion systems specially of the parameter recommendations are useful and of the recommendations are exactly the same as the actual parameters needed.
we have also performed a user study to show our technique is useful in practice.
keywords recommendation api argument parameter code completion i. i ntroduction application programming interfaces apis are extensively used in software development to reuse libraries and frameworks.
since there are numerous apis providing various functionalities developers are likely to encounter unfamiliar apis in their work.
unfortunately apis are generally difficult to learn due to various factors such as complexity of the application domain and inadequate api design .
as a result developers often have to make considerable effort to learn how to use apis correctly and efficiently.
to alleviate this problem a number of techniques have been proposed to facilitate the usage of apis.
among these a highly automated approach is a code completion system which promptly provides developers with programming suggestions such as which methods to call and which expressions to use as parameters.
traditional code completion systems generally propose their suggestions corresponding authors.based on type compatibility and visibility.
such suggestions may become insufficient for complex frameworks where some types have too many methods or fields to suggest.
therefore some recent work tries to improve the suggestions via mining api usage data from code bases.
most existing techniques focus on choosing the right method to call .
however as discussed in relevant studies it is a non trivial task to choose the right actual parameter s for a method call in an api usage.
table i shows the statistics of api declarations and usages in the code of eclipse .
.
tomcat .
and jboss .
.
table i statistics on method declarations and invocations param non param param non param program declaration declaration invocation invocation eclipse .
.
jboss .
tomcat .
average param and non param are abbreviations for parameterized and nonparameterized respectively.
table i shows that of the method declarations are parameterized that is the methods are passed one or more parameters when being called.
in accordance with the statistics of method declarations of the method invocations actually have parameters.
furthermore about of these actual parameters cannot be recommended by existing code completion systems because the expected parameters are too complex to recommend2.
sometimes even if an existing code completion system can provide correct recommendations it can be difficult to find the right parameter from a large number of parameter candidates.
figure shows an example of choosing an api parameter using eclipse jdt.
in the example the developer has to choose the right actual parameter i.e.
ihelpuiconstants.tag desc from over 50string variables and literals.
unfortunately the field tag desc is even not visible in figure as it is ranked too low by dictionary order.
more importantly since the code completion system does not suggest that interface ihelpuiconstants should be used the developer probably has to learn this 2we use the eclipse jdt code completion system as a typical example.
the details will be explained in section iii a978 .
c ieee icse zurich switzerland usage from code examples or documentations.
therefore it would be really helpful if the code completion system could provide more informative recommendations of api parameters and rank them in a more sophisticated way e.g.
suggest using ihelpuiconstants and put tag desc near the top of the list .
figure .
an example of parameter recommendation by eclipse jdt.
besides slowing down the development process unfamiliarity with parameter usage may even harm the correctness of programs.
bug in the bug database of eclipse3is a typical example of the bugs caused by incorrect usage of api parameters.
the bug reporter suggested that invocations to method getbestactivebindingformattedfor of interface ibindingservice should be used as the actual parameters of two method invocations.
in the end the developer took the suggestion and fixed the bug by replacing the incorrect parameters with the correct ones.
it is worth noting that existing code completion systems can provide little help in this case because such method invocations are too complex to recommend also see section iii a .
in this paper we propose precise an automated approach toparameter recommendation for ap iusage which is able to recommend the kinds of api parameters that are frequently used in practice but mostly overlooked by existing code completion systems.
during programming when the developer has already selected a method and is about to determine the actual parameter s of the method precise automatically recommends a concise list of well sorted parameter candidates.
the basic idea of precise is to extract usage instances from existing programs and adaptively recommend parameters based on these instances and the current context.
on receiving a request for recommendations precise first uses k nearest neighbor k nn queries on the usage database built from a large code base to find abstract usage instances of parameters that are commonly used in similar contexts.
then precise generates concrete recommendations based on the abstract usage instances.
precise ranks its recommendations with respect to the similarity contexts and the frequency of usage helping developers select the right parameters more easily.
two heuristic rules are used to reduce the search space of parameters making precise practical and efficient.
experimental results show that precise can recommend parameters with good accuracy under strict constraints on the number of recommendations.
specifically the expected parameters are included in the top 10recommendations in of the cases and in of the cases precise provides useful hints to help choose the right parameters.
the main contributions of this paper are precise an automatic parameter recommender which improves existing code completion systems.
to the best of our knowledge it is the first automatic technique focusing on parameter recommendation.
we have implemented precise and performed an experiment to show its effectiveness.
combined with eclipse jdt the implementation provides useful recommendations in of the cases.
we have also conducted a user study to confirm its usefulness.
the rest of this paper is organized as follows.
section ii shows an empirical study on the usage of api parameters.
section iii describes the technical details of precise.
section iv shows the evaluation results.
section v compares precise with closely related work.
section vi concludes this paper and discusses our future work.
table ii statistics on expression types of actual parameters expression type eclipse jboss tomcat average simple name .
.
.
.
method invocation .
.
.
.
qualified name .
.
.
.
field access .
.
.
.
array access .
.
.
.
cast expression .
.
.
.
string literal .
.
.
.
number literal .
.
.
.
character literal .
.
.
.
type literal .
.
.
.
boolean literal .
.
.
.
null literal .
.
.
.
total percentage .
.
.
.
ii.
api p arameter usage in practice a major challenge in parameter recommendation is that there can be too many possible parameter candidates that are type compatible with the expected parameter.
for example when we try to recommend the actual parameter for the method m int a there are an almost infinite number of parameter candidates of type int including all the integer literals accessible integer variables method calls returning integers etc.
in addition the parameter can be an arithmetic expression such as a b c which may have a very complex structure.
therefore as a fundamental strategy of precise we propose two heuristic rules to focus the approach on parameters of a limited number of structures.
the underlying assumption is that most of the parameters belong to a small number of types of structural patterns .827in order to support the assumption we have done an empirical study to see how api parameters are used in practice by looking into three subjects namely eclipse .
.
jboss .
and tomcat .
.
these are large scale programs that are widely used in real world settings.
thus the result of our study is supposed to be reasonably representative.
as shown in table ii over of the actual parameters of apis can be classified into 12types of expressions.
figure gives a brief description of the expression types and their structures.
the expression types are formally described in eclipse jdt documentation which is in line with the java language specification .
several kinds of expressions are out of the scope of the 12expression types including array creation assignment infix expression etc.
they together make up of the actual parameters in the subjects.
angbracketleftmethod invocation angbracketright angbracketleftidentifier angbracketright angbracketleftarguments angbracketright angbracketleftfield access angbracketright angbracketleftexpr angbracketright .
angbracketleftidentifier angbracketright angbracketleftqualified name angbracketright angbracketleftname angbracketright .
angbracketleftsimple name angbracketright angbracketleftarray access angbracketright angbracketleftexpr angbracketright angbracketleftcast expression angbracketright angbracketlefttype angbracketright angbracketleftexpr angbracketright angbracketleftliteral angbracketright angbracketleftstring literal angbracketright angbracketleftnumber literal angbracketright angbracketleftcharacter literal angbracketright angbracketlefttype literal angbracketright angbracketleftboolean literal angbracketright angbracketleftnull literal angbracketright angbracketleftsimple name angbracketright angbracketleftidentifier angbracketright angbracketleftexpr angbracketright angbracketleftmethod invocation angbracketright angbracketleftfield access angbracketright angbracketleftqualified name angbracketright angbracketleftarray access angbracketright angbracketleftcast expression angbracketright angbracketleftliteral angbracketright angbracketleftsimple name angbracketright angbracketleftarguments angbracketright angbracketleftexpr angbracketright angbracketleftexpr angbracketright angbracketleftname angbracketright angbracketleftqualified name angbracketright angbracketleftsimple name angbracketright figure .
grammar of expression types.
precise focuses on the first six expression types except boolean literal and null literal.
note that this grammar just shows the structures of expression types and the accurate grammar can be found in relevant documentations .
iii.
a pproach the work flow of precise consists of two phases.
in the first phase precise builds a usage database by analyzing parameter usage instances and their contexts in a code base.
in the second phase for a recommendation request precise queries the database using the context of the request as the key and retrieves a group of abstract usage patterns.
then precise concretizes and sorts the recommendations.
the overall approach is similar to that of the work on api method recommendation where static features are used to capture contexts and several algorithms including a specialized k nn algorithm are used to calculate the relevance of the recommended methods.
similarly precise also uses static features to capture contexts and uses a knn algorithm for relevance calculation.
nevertheless since precise targets the recommendation of parameters instead of methods it uses different static features which focus on the code prior to the parameters see section iii b2 .
in addition the characteristics of parameter recommendation have motivated us to design a different evaluation see section iv and propose two heuristic rules based on the empirical study in section ii.
these rules govern both phases of precise making the technique practical while still being effective.
in this section we first introduce the rules and then describe the two phases in detail.a.
heuristic rules for search space reduction rule of expression type.
the first rule is to restrict the two phases to the parameters of certain expression types namely method invocation field access qualified name array access cast expression and some types of literals.
specifically the usage database does not include any parameter whose expression type is unspecified in the rule and such a parameter is not generated as a recommendation either.
the grammar of the focal expression types is shown in figure .
while focusing precise on these expression types we leave out three of the 12types in table ii namely simple name boolean literal and null literal.
since parameters of these expression types are recommended by eclipse jdt by default precise does not take them into account.
as shown in table ii the focal expression types of precise take up about of all the actual parameters.
more importantly parameters of these expression types are generally more difficult for developers to find or compose than simple names boolean literals and null literals.
precise also does not deal with expression types that are not shown in table ii because they are infrequently used.
rule of structural complexity.
within the expression types specified in the first rule there can still be some parameters that are too complex to recommend.
for example an actual parameter can be a method invocation in the form of array .getfoo .getname .substring .
also such complex parameters are infrequently used and thus can hardly be amenable to precise which relies on existing examples.
therefore as the second rule we restrict the two phases to the parameters expressions whose structural complexity is less than or equal to .
the structural complexity of an expression exp is the number of leaf nodes in the abbreviated abstract syntax tree ofexp.
the abbreviated abstract syntax tree ofexp is derived from the abstract syntax tree of exp by removing every node and its sub tree that represents the argument list of a method invocation or the array index of an array access.
additionally literals are treated as a leaf node instead of being further decomposed syntactically.
this rule essentially confines precise to the parameters whose structures are reasonably simple.
according to our study on eclipse .
.
jboss .
and tomcat .
the structural complexity of nearly of the actual parameters is less than or equal to which means that precise can possibly recommend the right parameters in most cases.
b. building parameter usage database following the heuristic rules precise first analyzes programs in a code base to build a usage database.
conceptually the usage database stores the accumulated data about which parameters are used for an api in a specific context.
in a recommender system for methods e.g.
it is straightforward to use the method name fully qualified declaring type and argument type list to represent a method.828in contrast precise requires a certain degree of abstraction in representing the actual parameters in order to make the data useful in the subsequent phase.
abstract representation of parameters the need for abstract representation of parameters stems from the fact that in different cases some variables are named differently though they essentially represent the same entity.
in figure either bin case a or button in case b represents a reference to an instance of button .
suppose the recommender system learns from case a and tries to recommend a parameter for method setattrib in case b it will fail to find a match if its learning and recommendation are based on exact variable names.
in this example the most useful information is the structure of the expected actual parameter and the type of the base variable that is the actual parameter should be a method invocation to getattrib and the base variable is of type button .
precise abstracts the parameter usage instances before storing them into the usage database in order to retain the essential information while pruning unnecessary details e.g.
variable names .
during the abstraction precise first identifies the structures of the actual parameters and categorizes the parameters into several expression types such as literal method invocation and field access.
then for each expression that is not a literal precise resolves the type of its sub expressions that are local variables and replaces the variable names with their types.
in figure the actual parameter used in case a will be represented bybutton.getattrib as the variable button is replaced by its type button .
case a code snippet from code base 1p u b l i c c l a s s exampleclass p u b l i c void addbutton p a n e l p a n e l b u t t o n b new b u t t o n b .
s e t v i s i b l e t ru e b .
s e t a t t r i b p a n e l .
i n i t p a n e l .
addelement b use p1 t o d e n o t e b .
g e t a t t r i b h er e p a n e l .
s e t a t t r i b b .
g e t a t t r i b case b code snippet under development 1p u b l i c void methodtodevelop b u t t o n b u t t o n new b u t t o n t h i s .
s e t a t t r i b ?
figure .
example java code.
defining parameter usage contexts contextual information enables recommender systems to make recommendations adaptively.
precise uses four static features to capture the context in which each actual parameter is used.
the features are extracted from the generally available context i.e.
the code prior to the parameter because the code after the parameter has usually not yet been writtenwhen precise is triggered.
in software maintenance scenarios where developers mainly make edits to existing code we conservatively assume that the code after the parameter will probably be changed and thus unsuitable for representing the context.
we use the case a in figure to illustrate the features.
in the code snippet we suppose that the actual parameter of interest is the method invocation at line i.e.
b.getattrib and we use p1to denote it hereafter.
feature the signature of the formal parameter bound to the actual parameter.
this feature represents the most specific usage context for an actual parameter.
the signature of a formal parameter is the combination of the method signature the parameter type and the position in the parameter list.
in figure the value of feature 1ofp1is panel setattrib int .
feature the signature of the enclosing method in which the actual parameter is used.
this feature represents the contextual information on the surrounding scope of the method .
as discussed in such a feature is useful to identify the usage context in the case of overriding or implementing a method defined in a super type.
currently this feature just includes the method signature ignoring the method s declaring type.
it is a strategy to save the effort to explore type hierarchies at the cost of the accuracy of context.
in figure the value of feature 2ofp1is addbutton panel .
feature the method invocations that have happened on the variable used in the actual parameter.
for the kinds of parameters precise focuses on a variable vcan be the base variable of a method invocation e.g.
if the actual parameter is v.geta or the qualifier of a field access e.g.
if the actual parameter is v.fielda .
this feature captures the history of the variable vbefore it is used in the actual parameter.
such a history is useful to identify specific patterns of preparing a variable for the parameter usage.
we use the method signature to denote each method invocation.
thus in figure the value of feature 3ofp1is the list of methods invoked onb that is init setvisible boolean setattrib int .
we use init to represent the constructor of a class.
feature the method invocations that have happened on the base variable of the method invocation using the actual parameter.
similar to feature this feature is designed to capture the history of a variable but the variable here is not used in the actual parameter instead it is an essential part of the method invocation using the parameter.
as shown in such a feature can effectively represent the context of method usage.
therefore we use this feature to include method related context into the parameter usage context.
again we use the method signature to denote each method invocation.
in figure the value of feature 4ofp1 is the list of methods invoked on panel that is init addelement object setattrib int .
transformation and representation of parameter usage instances when building the usage database precise first scans the code base to find every parameter usage instance.
then it extracts the feature values for each parameter usage instance while abstracting the actual parameter.
each instance of parameter usage consists of both the feature values and the abstract parameter representation.
in order to support the k nn algorithm described in section iii c precise transforms each parameter usage instance into a vector before storing it into the parameter usage database.
the transformation algorithm is shown in algorithm .
algorithm usage instance transformation input a list ilist ofinstancedata for each formalparameter output a table result 1result.name feature 2foreach instancedata dofilist do d.features d.features feature foreach feature f d.features do putf.values into a set named featurev alues end 7end 8foreach instancedata dofilist do int value new int initialize value with d.features d.features feature foreach feature f d.features do foreach value v f.values do find the index ofvin set featurev alues value end end intusageindex indexusage d.getparam value useageindex addvalue intoresult 21end 22return result in the first place we believe that it is generally useless to recommend an actual parameter for a method by learning from parameter usage instances of other methods or other formal parameters of the same method.
therefore at the beginning of the transformation we create one table in the usage database for each unique formal parameter using feature 1to generate the table name.
all the actual parameters bound to a specific formal parameter will be processed and stored in the table corresponding to that formal parameter.
then within a table we compute the range for features and which is the set containing all the feature values of the usage instances in the table lines algorithm .
each element in the range corresponds to a column in the table.
when a usage instance is being transformed the value of a column is set to 1if the column s corresponding value occurs in the instance s feature values otherwise the column is set to lines algorithm .
the last column in the table is designed for storing the abstract actual parameter.
since the information of an actual parameter is generally too rich to be stored as plain text we keep a map between each actual parameter and its unique index and store the indices in the last table column lines and algorithm wherethe method indexusage indexes each actual parameter and maintains the map between actual parameters and their indices .
the example in figure shows the feature values ofp1and three other contrived instances and their encoded vectors stored in the usage database.
panel setattrib int addbutton init setvisible setattrib init addelement setattrib button.getattrib panel setattrib int editbutton isvisible setattrib refresh text setcolor int inittext init setwidth color.black text setcolor int setfont create setcolor isenabled font.getcolor transform table panel setattrib int table text setcolor int map between actual parameters and indices button getattrib method invocation integer literal color black field access font getcolor method invocation addbutton editbutton init setvisible setattrib isvisible init addelement setattrib refresh index inittext setfont create setcolor init setwidth isenabled index figure .
example usage instances and their representations in the usage database.
for brevity the parameter types of method signatures are omitted.
c. generating parameter candidates finding similar usage instances the k nn algorithm is commonly used to classify an instance based on the nearest training instances i.e.
the instances with known classes or categories .
precise uses the information of the nearest neighbors to guide its recommendation.
when being requested for a recommendation precise queries the usage database using k nn to find kusage instances whose contexts are the most similar to the context from which the request is issued.
then the type and structure information of these similar usage instances is used to generate a list of parameter recommendations.
the details of recommendation generation will be described in section iii c2.
similar to a parameter usage instance a request context is also represented by feature values.
however such a context does not include the actual parameter.
for a request for recommendation its value of feature 1is used to determine which table will be queried for the nearest parameter usage instances.
to represent the request context features 2and4 can be computed in the same way as those of the parameter usage instances in the usage database.
however since the actual parameter is yet to be recommended it is unclear which variable is used in the parameter.
thus we have to take into account all the accessible variables for computing feature .
here accessible variables include local variables formal parameters of the enclosing method and fields.
thus features 2and 4are common for all the accessible variables.
for each accessible variable v we will compute its history of method invocation feature and combine it with features 2and 4to create an individual context called variable context and vis called the context base of the variable context .
we will also generate an individual context called non variable context which only includes830features 2and 4so as to recommend literal parameters.
therefore for a given request if nvariables are accessible then there are n 1contexts for representing the request s possible contexts.
for each of the n 1contexts we find the knearest instances in the usage database.
in order to perform the k nn search we first transform the request context into a vector with respect to the table for the formal parameter.
the way of evaluating each vector element is the same as in the transformation of a parameter usage instance except that the vector of a request context does not contain a usage index.
then we define the distance between a request context and a parameter usage instance based on their vector forms definition the distance distance rc pi between a request context rc angbracketleftc prime c prime ... c prime n angbracketrightand a parameter usage instance pi angbracketleftc1 c2 ... c n index angbracketright is calculated by distance rc pi radicalbig summationtextn i ci c prime i where c prime iandciare the encoded feature values of the request context and the parameter usage instance respectively and index is the usage index.
based on the above definition we find the knearest neighbors for each of the n 1contexts.
in the k nn search we first set kto1and increment kuntil the number of concrete recommendations reaches a threshold or all the instances in the usage database are used.
currently the threshold is .
then for each context we categorize the parameter usage instances with the same parameter index into one group.
for each group we get a summary instance that consists of the abstract parameter corresponding to the usage index and the number of instances in that group called frequency .
if there are mdifferent usage indices in the nearest neighbors mmay vary between different contexts we will get msummary instances.
concretizing parameter recommendations when the summary instances have been extracted from the usage database precise has gained some knowledge about the parameter usages in similar contexts.
as described in section iii b1 such knowledge is abstract in that it is mainly about the type and structure information of the actual parameters.
precise takes a further step to generate concrete recommendations based on the summary instances.
in recommendation concretization precise takes different strategies with respect to different types of expressions for different contexts.
if the abstract parameter of a summary instance of a non variable context is a literal then precise directly uses the literal as the parameter recommendation.
otherwise if the abstract parameter of a summary instance of a variable context contains a type name that is abstracted from a variable precise checks whether the context base is type compatible with the type in the abstract parameter.
if so precise generates a parameter recommendation by replacing the type name with the context base i.e.
the accessible variable .
in this case other segments in the parameter recommendation such as method names or package names are copied verbatim from their counterparts in the abstract usage instance.
for example in case b of figure if theabstract parameter button.getattrib is a part of a summary instance of the variable context with context base button precise will generate a recommendation button.getattrib .
after recommendation generation we sort the recommendations in descending order by the frequencies of their corresponding summary instances.
then we sort the recommendations with the same frequency in dictionary order with respect to their parameter expressions.
last the sorted recommendations are presented to the user.
currently we insert the recommendations by precise into the original list of parameter recommendations by eclipse jdt and place them on the top of the list.
iv.
e valuation we have implemented precise as an eclipse plug in4.
at the front end the implementation seamlessly extends eclipse jdt to present parameter recommendations.
at the back end the implementation leverages the dom ast api provided by the eclipse jdt platform to perform source code analysis and uses weka to do the k nn search.
tables in the usage database are stored as arff files i.e.
weka s native input format and the map between indices and actual parameters is stored in xml files.
these two parts which are correlated by the usage indices play the role of the usage database in precise.
a. objective experiment performance measure.
using the implementation we have performed an objective experiment to evaluate the usefulness of precise.
for each request while precise normally generates a list of parameter candidates there is exactly one expected actual parameter which we call the target .
the target may or may not be included in the recommended parameters.
in the experiment we impose a constraint on the number of parameter candidates that is we only check the top 10candidates if there are more than 10of them.
by controlling the total number of recommended parameters we can evaluate precise s usefulness by checking how often it provides useful recommendations without being concerned about how many recommendations it generates each time.
we choose 10as the threshold because the user may have a context switch if she has to scroll down the list to check the recommendations lower than 10with default jdt configurations.
we assume that all the top 10recommendations attract equal attention from the user because they are presented in a short list that can be quickly checked.
we determine whether precise is successful for a specific request by checking whether the list of parameter recommendations includes the expected actual parameter.
thus we userecommendations made to denote the total number of times that precise tries to recommend a list of parameters 4the source code and screen shot of the implementation and experimental data are available on successful to denote the number of times that the list includes the expected parameter .
then we use the precision defined as below to represent precise s performance of parameter recommendation.
since there is exactly one target for each request recommendations made is equal to the number of targets in the experiment.
thus the precision can also be viewed as the recall.
precision successful recommendations successful recommendations made however as in the case shown in figure even if the recommendations fail to include the exact actual parameter they can still provide useful information such as which class should be used as a part of the parameter.
more specifically a recommended parameter is said to be partially correct if it correctly indicates the base variable of a method invocation the qualifier of a qualified name or the method name of a method invocation.
the partial usefulness is proposed based on the following observations in cases and as shown in figure when a remote entity is needed it is helpful to suggest the base variable or qualifier which can reduce the search space greatly.
case occurs mostly due to polymorphism where precise reveals the usage pattern of the method leaving limited uncertainty of choosing the right base variable.
in order to take into account such cases we use recommendations useful to denote the number of times that the recommendation list provides either completely or partially correct information with respect to the expected actual parameter .
then we define another precision to measure precise s performance from this viewpoint.
precision useful recommendations useful recommendations made subjects and validation strategy.
since precise is proposed to facilitate the use of framework apis it is reasonable to evaluate precise on individual frameworks.
in the experiment we focus on the swt framework and use all the projects using swt in the code base of eclipse classic .
as the subjects.
we choose the swt framework because it provides a large code base containing about 536lines of code.
moreover swt is a specialized framework for gui development.
compared with common libraries such as the jdk api swt is less familiar to developers and has more specific patterns of parameter usage.
therefore developers are more likely to benefit from an enhanced code completion system for the swt framework.
we take the strategy of fold cross validation.
more specifically the whole data set is evenly divided into subsets at random.
in each iteration of validation one subset is used as test data while the other nine subsets are used as training data for building the usage database.
ten iterations are performed so that each subset is used as test data once.
we split the parameter usage instances based on class thatis all the parameter usage instances occurring in a java class are used together in either the test set or the training set.
during the experiment each actual parameter in the test set of an api method defined in swt is used to test precise.
when being used as a test instance the actual parameter is hidden and a request is issued to precise.
all the test instances must be of the expression types that precise focuses on.
the recommendations for the request are checked against the actual parameter to see whether they are successful or useful.
table iii results of the objective experiment no.
param req success useful ps pu avg.
5as we use fold cross validation there are rows of data.
in the columns param means the number of actual parameters in the test set req means the number of recommendation requests success and useful represent the number of times when the recommendations contain the expected actual parameter and useful information respectively psand pustand for precision successful andprecision useful respectively.
figure .
rank distributions of recommendations.
results.
table iii shows the experimental results.
the averageprecision successful andprecision useful are53 and respectively.
it means that precise can often provide useful recommendations and sometimes the right parameter is included in the list of recommendations.
it is worth noting that the kinds of parameters recommended by precise are not recommended by the original eclipse jdt and they are generally more complex and difficult to find or compose.
therefore the results can be viewed as promising.832since the experiment focuses on the top 10recommendations it is interesting to study the effectiveness of precise s ranking strategy.
as shown in figure about of the successful recommendations are placed at the top 1of the list and in the top .
by comparison only of the partially correct recommendations are ranked top and in the top .
we have analyzed the result data and found that a large number of low ranked partially correct recommendations are generated for some common methods the limitation of precise on common methods will be discussed later .
an indication of figure is that there might be large room for improvement in precision useful by designing better ranking strategies.
figure .
precision values of eclipse jdt with and without precise.
.
because the recommendations actually presented to the user also include the recommendations by eclipse jdt from the perspective of users we are more interested in how much improvement precise has made to the eclipse jdt code completion system.
the eclipse jdt code completion system generates its parameter recommendations mainly based on type based rules.
the recommendations include limited simple types of expressions.
by default the eclipse jdt code completion system is activated every time a parameterized method is selected by the user.
whenever the expression type of the expected parameter is in the scope of the jdt code completion system it will certainly be included in the list of recommendations although there may be more than 10parameters recommended .
however due to its limitation on expression types the jdt code completion system will certainly fail if the expected parameter is complex.
as shown in figure the precision successful is .
as the combination of jdt and precise the enhanced code completion system has an average precision successful of64 .
moreover its average precision useful is67 indicating that it can often provide useful recommendations.
we have compared precise with four of its variants named f1 freq f1 f2 freq f1 f3 freq and f1 f4 freq .
inf1 freq usage instances are selected from corresponding database tables using feature and then sorted by frequency.
in contrast to precise f1 freq does not use k nn search.
we choose such a variant for comparison because it represents a typical frequency based solution and is more reasonable than some naive frequency based approaches e.g.
recommendation based on the frequency of typecompatible actual parameters used for any api method .
in f1 f2 freq we augment f1 freq with k nn search only based on feature .
f1 f3 freq and f1 f4 freq are similarly designed with different features.
in essence precise can be named f1 f2 f3 f4 freq using this convention.
figure .
precision values of several variants of precise.
as shown in figure precise has the highest psand almost the highest pu.
although the difference between precise and f1 freq seems insignificant we find that features and 4can indeed capture the context information to make precise outperform f1 freq in several cases.
it indicates that it is necessary to include extra features besides feature in order to enable adaptive recommendation while the current features probably still need improvement.
to our surprise the results show that adding a single feature especially feature or does not improve or even harms the performance.
by analyzing the data we find that an individual feature is often unable to accurately capture useful context information but it may make the instance vectors high dimensional e.g.
for feature there can be a number of calls on the variable used in the actual parameter .
as a result the distances computed using such vectors may fail to capture the contextual similarity correctly.
since precise has the best performance the result indicates the necessity of combining the features and the need for improving each of them.
we also find that the difference in performance between precise and the four variants is not so significant because there are often fewer than 10recommendations for a request.
in this case precise and the other four approaches succeed or fail together.
the root cause of such cases is the scarcity of abstract usage instances in the usage database.833although we use large training sets we need more programs using swt to get more conclusive results.
a concern on the usability of precise is its runtime because its second phase has user interactions.
to study the responsiveness of precise we have measured the runtime of the second phase on a desktop with a .40ghz dual core cpu and 4gb memory and also that of the first phase on a server with a .33ghz quad core cpu and 16gb memory.
as expected most of the runtime 793seconds on average is taken by the first phase.
by comparison the second phase takes little runtime 76milliseconds on average which is presumably negligible.
therefore we believe that precise can be seamlessly integrated into the eclipse jdt code completion system using pre built usage databases.
in the user study we have further investigated this issue.
limitations.
an important assumption of precise is that it can learn usage patterns from the code base.
however some apis e.g.
get object injava.util.map are widely used in numerous contexts.
these apis are so common that their actual parameters are too diverse for precise to learn any usage pattern.
although swt is a specialized framework there are still several common methods in it.
a typical example is the method settext string defined in classes button label etc.
the method is used to set the text on a widget.
it is imaginable that various strings will be used as the actual parameter of settext .
as a result precise has extremely bad performance for this method often recommending a large number of string literals and variables without success.
in the experiment settext takes up of the requests for recommendations and theprecision successful andprecision useful of precise for settext are21 and24 respectively.
as a learning based approach precise has little chance of recommending the right parameters if there are few usage instances with similar contexts in the training data.
this limitation is actually a major reason for precise s failures observed in some iterations of the fold cross validation.
in the experiment the expected actual parameter is sometimes a method or a field that is used very locally e.g.
a private field is only used in its declaring class .
meanwhile we split the parameter usage instances based on class.
when the usages of such a method or field are concentrated in a small number of classes in the test set they are out of reach of precise.
to overcome the limitation in recommending for unseen usage patterns we will try to improve precise with generative techniques e.g.
.
b. user study we have invited eight participants to use the precise plugin to finish two small programming tasks.
the participants are students with more than three years of experience of java and at least two years of experience of eclipse on average.
thus they are familiar with the eclipse jdt code completion system.
the two programming tasks are adapted from theexamples of the swt framework.
one task is to implement a simple panel with various fields and texts while the other is to implement a simple browser.
we deleted several statements from the original examples leaving skeletons of the programs.
in this way the participants can concentrate on finishing the programs using apis from swt without making design level efforts such as creating new interfaces or classes.
after completing the tasks each participant was asked to fill in a questionnaire which consists of five questions.
for each question a participant first chose a score from strong agreement weak agreement neutral weak disagreement and strong disagreement and then gave a detailed explanation of the choice.
the questions and the summary of the answers are described as below.
q1 did precise propose the right parameters?
average .
median this question is designed to confirm that the users can recognize the successful recommendations.
the resulting scores and the explanations show that the participants are able to identify the right parameters in most cases.
this is partly due to the short list of recommendations provided by precise i.e.
up to extra items besides those recommended by jdt .
the scores also indicate that the participants have perceived the effectiveness of precise in accordance with the precision successful that is it is useful although not perfect.
q2 when you could not find the right parameter in the recommendations did you feel precise still gave useful hints?
average .
median this question investigates whether the partially correct information can indeed be useful.
we almost get the same positive answers as in q1.
a participant said some of the parameters are dot outcome and i really feel it s convenient .
while confirming the partial usefulness the answer indicates that precise probably focuses on the right expression types.
q3 did precise correctly rank the parameters?
average .
median this question checks the ranking strategy of precise.
the scores show that the participants do not think precise has ranked the recommendations well.
we have investigated the explanations and found that some participants just did not pay attention to the ranking because they focused on finding the right parameter in the list.
the purpose of the ranking is to put the most relevant recommendations at the top of the list.
however users usually wonder why such a sophisticated ranking instead of dictionary order is used especially when they fail to find the right parameters and try to use the partial information.
q4 did precise speed up your development compared to the default eclipse code completion?
average .
median this question attempts to investigate whether the improvement by precise can be noticeable in the whole eclipse system.
the answers are generally positive indicating that precise is promising to be useful in practice.
however the answers are far from conclusive because various factors may affect the final results.
by checking834one participant s program we found that she mostly failed to find the right methods to call.
as a result precise was not activated as expected.
we believe that the integration of novel code completion techniques e.g.
api recommendation and precise could improve the existing system more significantly than individual techniques.
q5 is precise well integrated into eclipse?
average .
median this question investigates whether the runtime overhead of precise is acceptable in practice.
among the seven participants who gave answers three of them chose the score of .
four participants expressed the feeling that precise worked as a natural part of eclipse jdt.
the answers have confirmed that precise does not cause perceivable slowdown when proposing recommendations.
in summary the user study has confirmed the usefulness of precise shown by the objective experiment.
however it has also revealed an inadequacy of precise its ranking strategy lacks explanations and better integration with other techniques is needed.
c. threats to validity a threat to the evaluation result is that the usefulness of precise may not be accurately measured by the precisions.
we have performed the user study to alleviate this problem.
however since the sample is small the result still needs further validation.
one threat to the generalization of the result is that the evaluation was performed on a specialized framework.
as discussed in section iv a common apis can have adverse effects on precise s performance.
further studies on the applicability of precise to diverse frameworks may be necessary.
due to the limitation of resources the programming tasks used in the user study are relatively small and simple.
it is unclear whether the same result can be obtained on real world programming tasks which are larger and more difficult.
we are working on a stable version of the precise plug in and hope to integrate it into the eclipse code recommenders .
with a number of real users we may be able to obtain more conclusive results.
v. r elated work api recommendation.
bruch et al.
propose intelligent code completion systems iccs which learns from existing programs to recommend api methods.
iccs searches the code bases for api calls under the similar context and generates proposals using a customized k nn algorithm.
similarly precise uses data mining techniques to make recommendations.
however while iccs exclusively recommends method calls precise aims to predict actual parameters for method calls.
therefore precise can be seen as an extension to iccs.
robbes and lanza use program history to improve code completion systems.
they model the program history as a sequence of changes and propose a series of code completion algorithms mainly based on the method level and class level changes.
their workprovides code completion for classes and methods and thus is different from ours.
hou and pletcher enhance the code completion system by introducing new features such as grouping sorting and filtering.
these features enable the completion system to reduce the number of api candidates and rank them in more sophisticated ways making it easier for programmers to find the right apis.
their approach essentially tries to highlight the most relevant apis when there are too many of them to choose.
in contrast precise can still be helpful when programmers have to type in actual parameters instead of choosing them .
moreover precise recommends api parameters not apis.
other techniques have also been proposed to facilitate the use of apis.
different from precise they do not focus on parameter recommendation and code completion.
code search.
code search engines enable developers to learn the usage of unfamiliar apis by providing code examples.
bajracharya et al.
create sas which applies a grouping and indexing algorithm to search the repository and shows relevant code snippets.
besides the text search used by sas structural information of program source code is also used in code search engines such as sniff .
sniff is more relevant to precise in that it makes use of type information to refine its result set.
other approaches e.g.
also leverage search engines to facilitate the reuse of frameworks.
although search based approaches effectively help api learning they still require developers to pick from the list of search results the right methods or parameters to be placed in their particular contexts.
in contrast in precise this task is performed automatically.
in precise recommendations are proposed in place by the code completion system possibly saving some effort of extracting pieces of information from examples and mapping them to the right places.
moreover precise focuses on structural api parameters instead of general code examples.
vi.
c onclusion and future work we have proposed precise to automatically recommend actual parameters for apis.
by extracting usage instances from existing programs precise provides useful parameter recommendations with satisfactory precisions showing its ability to improve the state of the art code completion systems.
in our future work we are planning to study how to use program evolution information to improve precise.
moreover we will try generative techniques to recommend parameter usages that are unseen in the code base.
acknowledgment we are grateful to the anonymous reviewers for their suggestions to improve the paper and to sai zhang for his insightful discussions.
this work was supported in part by national natural science foundation of china nsfc grants and .835references apache tomcat.
eclipse code recommenders.
eclipse jdt api specification eclipse documentation.
eclipse project.
jboss application server.
swt the standard widget toolkit.
the java language specification third edition.
sushil bajracharya joel ossher and cristina lopes.
sourcerer an internet scale software repository.
in proceedings of the icse workshop on search driven development users infrastructure tools and evaluation suite pages washington dc usa .
ieee computer society.
marcel bruch martin monperrus and mira mezini.
learning from examples to improve code completion systems.
in proceedings of the the 7th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering esec fse pages new york ny usa .
acm.
shaunak chatterjee sudeep juvekar and koushik sen. sniff a search engine for java using free form queries.
in proceedings of the 12th international conference on fundamental approaches to software engineering held as part of the joint european conferences on theory and practice of software etaps fase pages berlin heidelberg .
springer verlag.
barth l my dagenais and martin p. robillard.
recommending adaptive changes for framework evolution.
in proceedings of the 30th international conference on software engineering icse pages new york ny usa .
acm.
sumit gulwani.
dimensions in program synthesis.
in proceedings of the 12th international acm sigplan symposium on principles and practice of declarative programming ppdp pages new york ny usa .
acm.
mark hall eibe frank geoffrey holmes bernhard pfahringer peter reutemann and ian h. witten.
the weka data mining software an update.
sigkdd explor.
newsl.
november .
daqing hou and david m. pletcher.
towards a better code completion system by api grouping filtering and popularitybased ranking.
in proceedings of the 2nd international workshop on recommendation systems for software engineering rsse pages new york ny usa .
acm.
david kawrykow and martin p. robillard.
improving api usage through automatic detection of redundant code.
in proceedings of the ieee acm international conference on automated software engineering ase pages washington dc usa .
ieee computer society.
david mandelin lin xu rastislav bod k and doug kimelman.
jungloid mining helping to navigate the api jungle.
inproceedings of the acm sigplan conference on programming language design and implementation pldi pages new york ny usa .
acm.
hoan anh nguyen tung thanh nguyen gary wilson jr. anh tuan nguyen miryung kim and tien n. nguyen.
a graph based approach to api usage adaptation.
in proceedings of the acm international conference on object oriented programming systems languages and applications oopsla pages new york ny usa .
acm.
michael pradel and thomas r. gross.
detecting anomalies in the order of equally typed method arguments.
in proceedings of the 20th international symposium on software testing and analysis issta pages .
romain robbes and michele lanza.
improving code completion with program history.
automated software eng.
june .
martin p. robillard.
what makes apis hard to learn?
answers from developers.
ieee softw.
november .
jeffrey stylos brad a. myers and zizhuang yang.
jadeite improving api documentation using usage information.
in proceedings of the 27th international conference extended abstracts on human factors in computing systems chi ea pages new york ny usa .
acm.
suresh thummalapenta and tao xie.
parseweb a programmer assistant for reusing open source code on the web.
in proceedings of the twenty second ieee acm international conference on automated software engineering ase pages new york ny usa .
acm.
ian h. witten and eibe frank.
data mining practical machine learning tools and techniques second edition .
morgan kaufmann .