a dynamic analysis to support object sharing code refactorings girish maskeri rama infosys limited girish rama infosys.comraghavan komondoor indian institute of science bangalore raghavan csa.iisc.ernet.in abstract creation of large numbers of co existing long lived isomorphic objects increases the memory footprint of applications signi cantly.
in this paper we propose a dynamic analysis based approach that detects allocation sites that create large numbers of long lived isomorphic objects estimates quantitatively the memory savings to be obtained by sharing isomorphic objects created at these sites and also checks whether certain necessary conditions for safely employing object sharing hold.
we have implemented our approach as a tool and have conducted experiments on several real life java benchmarks.
the results from our experiments indicate that in real benchmarks a signi cant amount of heap memory ranging up to in some benchmarks can be saved by employing object sharing.
we have also validated the precision of estimates from our tool by comparing these with actual savings obtained upon introducing object sharing at selected sites in the real benchmarks.
categories and subject descriptors d. .
distribution maintenance and enhancement d. .
processors keywords memory optimization object caching .
introduction the advent of large system memories has not vetted the appetite for memory optimization tools for software.
for instance various researchers have noted that software commonly consumes unexpectedly high amounts of memory frequently due to programming idioms that are used to make software more reliable maintainable and understandable.
in the case of modern object oriented systems currently pursuing part time phd in indian institute of science bangalore.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
.public commonfont getfontprops f .
.
.
commonfont commonfont new commonfont fontfamily f o n t s e l e c t i o n s t r a t e g y fontstretch fontstyle fontvariant fontweight fontsize fontsizeadjust return commonfont g listing creation of isomorphic objects this problem is partly due creation of large numbers of coexisting isomorphic objects.
intuitively two objects are isomorphic if they are of the same type have identical values in corresponding primitive elds and are such that corresponding reference elds themselves point to isomorphic objects.
in other words the portions of memory rooted at the two objects are isomorphic shape wise as well as values wise.
.
motivation to illustrate this problem consider the example code in listing adapted from the real program apache fop.
this code has been substantially simpli ed for ease of presentation.
the getfontprops method in the code is used to create a commonfont object to encode display properties for each fo formatting objects node in the input fo document.
each commonfont object which we simply call font object from here on occupies bytes in memory.
for large documents the number of such font objects created is very large.
however in practice because the elds of the commonfont class can take on only a small number of distinct values e.g.
arial ortimesroman forfontfamily and 10pt or 12pt for fontsize many of the font objects created are isomorphic to each other.
for instance with a page real input document that we supplied as input although the program created font objects i.e.
.
of these objects belonged to only four distinct equivalence classes by isomorphism.
furthermore all font objects are long lived i.e.
are live nearly until the end of execution of the program .
a signi cant reduction in heap usage can therefore be achieved if the code is refactored to de duplicate orshare common font objects whenever possible instead of always creating distinct but possibly isomorphic objects.
such a refactoring which employs a cache to keep track of objects created so far and to share them is shown in listing .
we have elided the equals and hashcode methods of the commonfont class from the listing which ensure that a cache p r i v a t e map commonfont commonfont map new weakhashmap commonfont commonfont public commonfont getfontprops f .
.
.
commonfont commonfont new commonfont fontfamily f o n t s e l e c t i o n s t r a t e g y fontstretch fontstyle fontvariant fontweight fontsize fontsizeadjust i f map .
get commonfont !
n u l l commonfont map .
get commonfont return cached isomorphic object e l s e map .
put commonfont commonfont i n s e r t new object into cache return commonfont g listing caching isomorphic objects lookup using a newly created object as key is guaranteed to return either null or an object that is isomorphic with the new object.
note that whenever a cached object is found the newly created object implicitly becomes garbage and will be collected by the gc thus not occupying space in memory that it otherwise would.
also a weakhashmap rather than a normal hash map is appropriate because any key value pair gets automatically deleted from a weak hash map when there are no