supporting automated software re engineering using re aspects mohamed almorsy john grundy and amani s. ibrahim centre for computing engineering software systems swinburne university of technology melbourne australia swin.edu.au abstract system maintenance including omitting an existing system feature e.g.
buggy or vulnerable code or modifying existing features e.g.
replacing them is still very challenging.
to address this problem we introduce the re aspect re engineering aspect inspired from traditional aop .
a re aspect captures system modification details including signatures of entities to be updated actions to apply including remove modify replace or inject new code and code to apply .
re aspect s locate entities to update entities that will be impacted by the given update and finally propagate changes on the system source code .
we have applied our re aspects technique to the security re engineering problem and evaluated it on a set of open source .net application s to demonstrate its usefulness .
categories and subject descriptors d. .
restructuring reverse engineering and reengineerin g general terms algorithms design languages keywords system reengineering software evolution change impact analys is re aspects .
introduction software systems are usually exposed to extensive change and evolution after deployment.
these maintenance activities represent up to of the total system cost and effort .
this usually requires capturing new features modi fications locating system entities that must be modified locating system entities that are impacted by this modification and should be modified and propagating the required modification to the whole system.
existing system maintenance approaches are mostly limited to change impact analysis where we identify entities that will be impacted by a given system modification to a specific system entity .
these efforts assume that entities to modify are known and just look for entities impacted by this modification.
moreover they focus on changes on class and method level rather than a block ofcode.
they assume a set of predefine d system modifications .
the problem of c apturing and locating specific system entities to change has been addressed by other system reengineering efforts concept location design patterns and code evolution .
however t hese efforts are limited in their expressiveness formality and identification precision as most of them targeted to help program understanding rather than supporting actual program modification.
propagating change modification s on the target system has often been realized using aop techniques to support software maintenance re engineering and refacto ring .
we introduce the concept of re engineering aspects or re aspects for short as a novel integrated and systematic solution to the system re engineering and maintenance problem.
a re aspect capture s signature of system entities that need to be modified to effect a given change request actions required add new code remove existing code modify code or replace code and code to apply on the located matching entities.
then we automatically analyse the system source co de locate entities that match the specified signature s conduct detailed impact analysis to identify the impacted entities and propagate the change required on source code.
re aspect signature may be class method or even code blocks .
we introduce two n ovel signature specification designators to captur e formal and flexible semantic and syntactic signature s. bool updatecustomerbalance string custid decimal nbalance if !authenitcateuser username password return false if !authorzuser username up datecustbalance return false logtrx username datetime.now updatecustomerbalance customer customer customers.getcustomerbyid custid customer.balance nbalance customers.savechanges logtrx username datetime.now updatecustbalance done if request.cookies !
true if !authenticateuser request.params request.params throw new exception invalid user doadministration if !authenticateuser request.params request.params throw new exception invalid user if !authorizeuser thread.currentprincipal new stakeframe .getmethod .name new stakeframe .getmethod .
getparameters throw new exception user is not auhorized updatecustomerbalance request.querystring nbalance figure .
possible system changes motivating examples .
re aspects once a new change request cr is received a change request management process is initiated.
this process is conducted to figure out and document the expected impacts on system entities .
first it starts with an impact analysis task.
the output of it is maintained in a change set .
each item in the change set may be removed modified replaced or new code injected .
next a deeper b a c permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
analysis is then conducted to identify the impact set which includes items that will be impacted by change s in the change set .
finally system developers propagate the specified system modification s on the system entities.
this might require modifying code developed in different programming languages and different syntactical format variable name conditions order or format .
.
re aspects motivation figure show s different code snippets from an internally developed erp application called galactic vulnerable to different security issues including a built in security functions that need to be disabled b code vulnerable to authentication bypass attack and c code vulnerable to improper authorization attack .
in this figure we also show some possible mitigations system modifications to address these vulnerabilities the code with gr ey shading i.e.
the required re engineering of the original code to address the identified security vulnerabilities found .
.
re aspect s syntax a re aspect specifies a single system modification to be applied on the target code base.
a re aspect has a signature an advice and an action .
a re aspect signature defines footprint of a target system entity that should be deleted modified replaced or into which new code is ins erted this m ay be a line of code a method or a class.
a re aspect instance is a matched system entity that matches a given re aspect signature.
each re aspect instance maintains their specific context information.
a re aspect action specifies what to do on the re aspect s instances .
an action may be applied on re aspect level i.e.
on all re aspect instances or on specific instances.
a re aspect impact set represents system entities that will be impacted by a given system modification.
re aspectdef signature othersig n sigtype action action type action cond impact aspect s sign a action d advice i impact aspect st sign type se signature expr othersig n null sign code snippet ocl expression at action type ac action condition delete modify replace inject ocl expression action cond null null re aspectdef impact aspect figure .
re aspect syntax figure shows our re aspect definition syntax .
every re aspect has a signature action advice and may have an impact re aspect .
the signature specifies the signature type and the signature expression.
this can be a collection of composite signatures.
re aspect action specif ies action type and condi tions if any.
the advice specifies code to replace or inject or the code used to modify existing code.
the impact re aspect specif ies what to do with o ther system entities impacted by this system modification .
we have four possible re engineering re aspects types adding re aspect this equates to a conventional aop code injection aspect.
code to be injected is specified in a separate advice that is weaved with the target system at a given re aspect instance.
it can add any static structure new m ethod field and lines of code to system entities .
an anti aspect has only signature and no advices .
the identified code blocks re aspect instances are removed from the target system .
a replacing re aspect is a combination of deletion and adding aspect.
it includes signature of code to be remove d and an advice to be injected .
finally a modifying re aspect is the most complicated re aspect.
it makes use of the identified re aspect instance code to allow the aspect developer to specify selective deletion reordering or addition of new nodes into the identified code instance.
for example the problem in fig .
b authentication bypass could be mitigated using a modifying re aspect advice as shown in figure .
it receives a re aspect instance an ast node as input parameter.
at weaving time we call the modifying aspect script on each identified instance.
t he returned modified ast is used to replace the original sub tree.
void authenticationbypassmitigationadvice inode aspectinstance inode node aspectinstance if node as ifelsestatemenet !
null ifelsestmt node .
condition.contains loggedin true aspectinstance ifelsestatement node .truestatement ... figure .
a sample of a modifying re aspect advice .
re aspect signature designators supporting system reengineering requires a powerful signature specification approach.
our r e aspect concept is supported with a hybrid approach that delivers flexible syntactical code signature as well as ocl semantic signature specification designators .
update namespace or class with specific name if any namespace dummynamespace class dummyclass update method modifier return type or name for specific method signatures public void dummymethod update method body in case of code block re aspect dummystatement if dummycondition figure .
code snippet re aspect template code snippet signature designator using this designator developers can specify a flexible code snippet as the aspect signature.
figure shows the template of syntacti cal code snippet as a signature .
developers use this template to write code parts they are interested in .
the flexibility comes when specifying signatures to be matched with code blocks inside methods body.
a developer can specify the code block they are interested to locate .
if the developer does not know the details of the code block they can use the dummy keyword .
this indicates that all statements in the method body will not be considered until a match between the target method statements and the next statement in the given signature is found in the method body.
the syntactical code snippet approach is similar to regular expressions in the ir expressiveness .
our code snippets have an edge in the ir matching approach.
regular expressions depend on lexical pattern matching that suffers from lexical problems such as new lines tabs brackets etc .
as our code snippe t matching is done on abstract syntax tree s this avoids such lexical problems and can even match code snippets from different programming languages.
semantic ocl based signature designator to support more formal semantic re aspect signatures we use the object constraint language ocl as a signature definition lang uage.
this is more formal familiar and extensible.
to enrich ocl with object oriented programs semantics we have developed a system description class diagram shown in figure .
this shows every entity existing in any give n object oriented system including component class instance method inputs sources if statements loops etc.
moreover it helps in validating ocl constraints and can be easily extended to capture more abstract system entities and relations such as se curity apis system models feature architecture deployment design and testing... .
figure shows examples of ocl based re aspect s signature a get all public methods whose classes implement a specific system feature b get all methods t hat call a security function .
figure .
the system class diagram used in re aspects ocl based signatures figure .
sample ocl re aspect signatures set sigast call generate signature ast set startnode codeast.currentnode checknodes recursively traverse the source code ast if code ast.currnode null then exit dummy true if sigast.currentnode.contains dummy true dummystatement true end if if codeast.currnode.type sigast.currnode.type or dummy true and codeast.curr node sigast.nextnode then begin result call comparenodes codeast.currnode sigast.currnode if result true then nodes are equal begin set codeast.currnode codeast.nextnode set sigast.currnode sigast.nextnode end if else if result false then begin set startnode startnode.nextnode set codeast.currnode startnode.nextnode set sigast.currnode sigast.root end if goto checknodes end if else begin set codeast.currnode codeast.nextnode startnode codeast.currnode goto checknodes end if figure .
syntactical code snippet matching algorithm sigclass call parseocl generatec oclsig siginstance call createinstance sigclass entity foreach entity in systemmodel do if entity.type sigclass.contexttype then begin var output siginstance.invariantname test entity matcheslist output.tolist end if figure .
semantic ocl signatures matching algorithm .
locating re aspect instances give n a re aspect signature to locate the possible re aspect instances in a target application code base we first parse the input code and build an abstract syntax tree ast representation.
this step helps avoiding spacing comments brackets and parentheses ambiguities.
moreover it helps avoid syntax details relevant to different programming languages.
given the source code ast and re aspects signatures the re aspect locator traverses the ast looking for matches using one of two matching algorithms.
the selection of matching algorithm depends on the given re aspect signature type.
if code snippet then algorithm else algorithm .
algorithm figure the aspect locator traverses the input source code ast and the given re aspect code snippet ast looking for matches.
the matching takes into consideration the node hierarchy in both the signature and the system code.
it treats the dummy constructs as do not care node s in the ast .
algorithm figure is based on compiling and validating the given ocl signature using an ocl parser against the system meta model from figure .
then we generate a visitor class from the given re aspect ocl signature.
the visitor class implements handler methods for every node type specified in the ocl signature.
if a v isited node has a handler this handler is called e.g.
a vis itor for example b figure will have handlers for method definition and invocation expression nodes.
in the invocation expression the visitor will have a condition to check if the invoked me thod is marked as a security function then add s this method to the returned list of methods.
a context method inv getimpactedmethodsformodifiedmethod self.statements contains s s.statementtype methodcall and s.methodname modifiedmethod b context method inv getimpactedmethodsforclass self.
statements contains s s.statementtype newobj and s.classtype modifiedclass figure .
samples of impact analysis ocl signatures .
change impact analysis in aop the code to be injected is encapsulated in an advice separate from the target cut point itself.
thus no impact analysis is required.
however with reengineering aspects we have more complicated scenario s where we cut different code parts that have similar signature but different structure and format are from different places may have different impact sets and may be added or modified code.
thus any given system modification requires a detailed impact analysis to identify other system entities that shoul d be updated as a part of given modification.
a context method inv publicmethods self.ispublic true and self.class.implementsfeature custmgmt b context method inv methodswithsecurityfns self.stmts contains stmt methodcall stmt.
issecurityfn true table .
results of validating re aspects to locate and propagate given signatures benchmark kloc files classes authen.
bypass improper authoriz.
security disabling c o a m c o a m c o a m galactic .
splendidcrm kooboo nopcommerce bugtracer c using code snippet o using ocl a actual instances m successfully modified for each re aspect instance we compute a change impact set based on the re aspect instance type class method property field line of code .
a given system modification will have either local impact or global impact based on re aspect instance as follows lines of code has a local impact i.e.
no other system entities will be impacted thus the change impact set is empty.
method has a global impact .
to compute the impact set we locate methods and properties that contain call statement to th e modified method .
figure a shows sample oc l expression to locate methods that contain invocation to the modified method.
class has a global impact .
the change impact set contains all methods that have identifier s of this class figure b properties of this type or have identifier of this type fields of this class type and classes that have this class as base class.
property has a global impact .
to compute the change impact set we locate all methods that have this property in an y expression statement e.g.
assignment call if condition lo op statements.
the change impact sets entities are located using pre specified ocl expressions figure configured according to re aspect instance type and name .
this avoids building dependenc y graph s usually adopted by existing approaches and time consuming .
figure .
re aspects l ocal impact analysis .
change propagation the propagation of a given system modification re aspect is straight forward.
it depends on the re aspect type action either to insert delete replace or modify code of the located re aspect instance .
all re aspect instances are updated in the code ast and then code is regenerate d with the final updates.
for entities in the change impact set of each re aspect instance identified in the previous step we apply the impact re aspect included in the re aspect definition as shown in figure .
confirming that changes caused by a re aspect didn t cause any other problem is an extremely hard problem that requires a deep understanding of the logic behind the code block.
here we f ocus on confirming that the added removed replaced or modified code does not break the data flow or the control flow of the method as shown in figure .
control flow analysis cfa is used to confirm that the modification does not lead to unreachable code case .
data flow analysis dfa confirm s that the required data for the modified block are available from previous blocks and that next blocks still have required data items cases .
.
evaluation we evaluated the capabilities of re aspects in locat ing and propagating a variety of system modifications .
table summarizes the results of using re aspects to locate matches of a given re aspects signatures using our benchmark applications with a set of three system modifications from figure and propagating given changes on the identified matches.
we use precision and recall metrics to assess our approach effectiveness .
from our experiments the precision of the co de snippet approach is while its recall is .
the precision of the ocl based approach is while the recall rate is .
the precision of the change propagation module is .
.
summary we described a novel solution the re aspect to the system maintenance problem.
a re aspect capture s details of system modifications including signatures of entities that need to be modified actions to apply on located matches possibly take away de weaved replace modify or new code inserted an d code to update these entities .
a key strength of our re aspects comes from the signature speci fication designators.
re aspect support s two signature specification approaches code snippet templates and ocl based signatures.
re aspects ease and automate the reengineering process starting with locating system entities to be modified change impact analysis and finally propagating updates on located entities.
we have validated our approach effectiveness in locating entities to be modified and propagating c hanges using a set of open source .net benchmark applications.
.