finding architectural flaws using constraints radu vanciu marwan abi antoun department of computer science wayne state university de troit michigan usa email radu mabiantoun wayne.edu abstract during architectural risk analysis ara security architects use a runtime architecture to look for secur ity vulnerabilities that are architectural flaws rather than co ding defects.
the current ara process however is mostly inform al and manual.
in this paper we propose scoria a semi automat ed approach for finding architectural flaws.
scoria uses a sound hierarchical object graph with abstract objects and dataflo w edges whereedgescanrefertonodesinthegraph.thearchit ects canaugmenttheobjectgraphwithsecurityproperties whic hcan express security information unavailable in code.
scoria a llows architectstowrite queriesonthegraphinterms ofthehiera rchy reachability and provenance of a dataflow object.
based on t he query results the architects enhance their knowledge of th e system security and write expressive constraints.
the expr essiveness is richer than previous approaches that check only for t he presenceor absence of communicationor donottrack adataflo w as an object.
to evaluate scoria we apply these constraints to several extended examples adapted from the cert standard for java to confirm that scoria can detect injected architect ural flaws.
next we write constraints to enforce an android secur ity policyandfindonearchitecturalflawinoneandroidapplicat ion.
i. i ntroduction although of security vulnerabilities are architectura l flaws such as information disclosure they receive less attention from security analyses that focus on coding defec ts such as a hard coded password .
in object oriented code a localcodingdefectcanbefoundbyanalyzingoneclassorone methodatatime.ontheotherhand architecturalflawsrequi re reasoning about non local information such as the context o f architectural components.
a security analysis focused on architectural flaws is architectural risk analysis ara also known as threat modeling .
during ara architects use a runtime architectur e which is a collection of runtime components and connectors.
the current ara process is informal and manual.
one way to automateara is to executemachine checkable constraints against the runtime architecture.
for example a constrain t checks all connectors and restricts communication of components created in a given context.
in addition constraint s may use security properties such as trustlevel that architects assign to component and connector instances .
in this paper we target architectural flaws such as informationdisclosureandtampering whichmayoccurforconnecto rs between trusted and untrusted components.
simply checking forthepresenceofcommunicationisinsufficientandmaylea d to false positives.
instead architects need to reason abou t the content of a connector.
for example a connector that passes confidential information from a trusted source to an untrust ed destination may lead to information disclosure.
on the othe r hand an untrustedconnectorthat hasa trusted destination and passes unsanitized information may lead to tampering .
in previous work we approximated a runtime architecture by using a static analysis to semi automatica lly extract from object oriented code with annotations a sound hierarchical ownership object graph oog with dataflow communication edges such that the oog approximates all possible runtime objects and communication.
a component is represented by an abstract object and the objects in its substructure.
a connector is represented by edges between abstract objects.
inthispaper weproposescoria asemi automaticapproach for finding architectural flaws during ara.
scoria uses a security graph secgraph that augments the oog with security properties queries and constraints.
the queries a llow architectsto deepentheir understandingofan abstractrun time architectureasneeded andtoassignsecuritypropertiest osets of abstract objects and edges.
the architects can then enfor ce a security policy as a set of constraints that are predicates on the sets returned by the queries.
the contributions of scoria are queries that capture the thought process of how architects reason about the communication of objects in a runtime architecture.
for security it is important to identify the objects that edges refer to.
some objects that carry protected data may be part of some other object that seems to carry only unprotected data.
in th e secgraph a dataflow edge refers to an abstract object.
this i s similar to how a manually drawn runtime architecture used in arahasmessagesratherthantypesoractionsonthedirected edges between component instances .
scoria automatical ly tracksthecontentofthedataflowthrough objecthierarchy and object reachability .
then architects can write constraints by reasoning about the source the destination and the flow in terms of abstract objects.
for example in a communication from a trusted source to an untrusted destination the datafl ow object may not be confidential but a confidentialobject coul d be reachable from it or be contained within its substructure .
architects can also reason about object provenance when differentdataflowedgesrefertothesameobject.objectpro venance uses only the structure of the secgraph.
in some cases to supplement the information from the runtime architectur e architects use security properties to supply security rel evant design intent that is not directly available in the code or in an abstract object graph that is automatically extracted.
the queries also compute the indirect communication through object hierarchy and object reachability of the sou rce .
c ieee ase palo alto usa334 anddestination.architectsmaymisssuchcommunicationth at isnotexplicitinthesecgraphandleadstoarchitecturalfla ws.
to evaluate scoria we write machine checkableconstraint s for several rules in the cert oracle secure coding standard for java focusing on architectural flaws for which automated detection was previously unavailable.
our evaluatio n confirms that scoria can detect architectural flaws in severa l extended examples.
as a second evaluation we formalize an android security policy as a constraint and detect one architectural flaw in one android application.
contributions.
our contributions are the scoria approach of machine checkable constraints on a security graph where dataflow edges refer to abstract objects.
the constraints automatically track objec t provenance and indirect communication through object hierarchy and object reachability.
an evaluation that the constraints find architecturalflaws such as information disclosure and tampering in several extended examples adapted from the cert standard for java and in one android application.
outline.section ii identifies the requirements of ara and describes the oogs using a running example.
section iii describes scoria and defines the secgraph .
section iv describes the evaluation and discusses the results.
section v describ es related work and section vi concludes.
ii.
b ackground a. running example we use echo a client server application that highlights a potential information disclosure if the communication be tween the server and the client is not encrypted.
to understand the communication the architects need to distinguis h between different objects of the same class inputstream .
echo is adapted from code fragments provided as examples in the cert standard .
echo consists of two objects client echoclient and server echoserver thatcommunicate via a message ss string received from user input.
the communicationis established via a sckt socket object whichcontainstwostreamsofdata namely in inputstream and out outputstream .
the object sckt socket does not provide encryption and should be used only if the data transmitted is not confidential or if the network is trusted.
other wise theimplementationshoulduseencryptionprotocolss uch assecuresocketslayer ssl toensurethatthechannelisno t vulnerable.
the server supports both types of communicatio n and has an object sslsckt sslsocket that encrypts data.
however to avoid the performance overhead associated with encryption client echoclient uses sckt socket to communicate to server echoserver .
to implement encryption in java developers should use the class sslsocket instead of socket as advised by the cert rule .
otherwise confidential messages may be disclosed to malicious applicationsthatinterceptmessagesfrom sckt socket .such a vulnerability is an architectural flaw not a coding defect and according to the cert standard automated detection is unavailable.b.
requirements on an ara solution during ara architects use a runtime architecture rather than a code architecture.
for object oriented code a runti me architecture shows objects as opposed to a code architectur e that shows the code structure as packages and classes .
a runtime architecture can have multiple component instance s of the same type that serve different conceptual purposes or have different security properties.
for example an obje ct in inputstream of standard inputserves a differentconceptual purpose from in inputstream of a network and the architecture shows them as two distinct components.
one limitation of the current ara process is obtaining an initial runtime architecture that is consistent with the co de.
when developers manually document an architecture they maymiss some importantcomponentsor connectorsthatexist at runtime in some program run.
since ara is a worst case analysis it requires a sound architecture that represents all componentsand connectorsthat may exist at runtime because every component or connector can introduce vulnerabilitie s. for echo if server echoserver sends messages directly to out outputstream the architecture should have such a connector even if it only occurs when an exception is thrown.
in a sound runtime architecture one component abstracts multiple runtime objects used in the same context i.e.
eac h runtime object is mapped to one component.
also a sound runtime architecture does not map one runtime object to distinct components since architects could assign differe nt property values to these architectural components and obta in misleadinganalysisresults wheninfactthese components are the same runtime entity.
legacy code has high business value and vulnerabilities in legacy code are expensive .
as a result scoria supports legacy code requiring only annotations.
in particular it does not require the program to be implemented using specific programming languages or libraries or to require automated code generation as in secureuml .
c. extracting an abstract runtime architecture scoria builds on a recent body of work that uses static analysis to extract an oog with points to edges and dataflowedges .inanoog anodeisanabstractobjectthat represents a possibly unbounded number of runtime objects.
the oog is sound such that each runtime object has exactly one abstract object as a representative.
soundness also mea ns that every runtime edge has a corresponding abstract edge between the representatives of the source and the destinati on runtime objects.
for brevity we use object to refer to an abstract object.
theoogisalsohierarchical.anobjectdoesnothavechild object directly.
instead an object contains domains wher e a domain is a named conceptual group of objects where the name conveys design intent.
notation.
an object labeled obj t indicates a reference obj of type t which we then refer to as the object obj to mean an instance of the tclass .
a dataflow communication has 335the labelobj t to reflect that the same object obj t which could be a node in the graph is flowing along the edge.
the oog supports object identity where each abstract object has a unique identifier.
in echo the architects can assign differentpropertyvaluesto wrtr outputstream from the streams parent domain of the sckt socket and to wrtr outputstream fromthe streams parentdomainofthe sslsckt sslsocket not shown although both objects are of the same outputstream class.
the architects can reason about object provenance because a dataflow edge refers to an object instead of a type.
for example thearchitectscanuseobjectidentitytofindthatsev eral dataflow edges refer to the same object such as ss string in the data domain of m main .
however only some of these dataflow edges may lead to information disclosure.
the architectscantracktheinitialsourceofa dataflowtransit ively.
the dataflow might be allowed as long as the trustlevel value of the destination is trusted .
for example a transitive communication of ss string from in inputstream to wrtr outputstream exists.
the architects can reason that the object ss is confidential because the object in represents userinput.hence a dataflowedgethatrefersto ss andhasan untrusted destination may lead to information disclosure a nd should be investigated.
sinceahierarchicalorganizationofobjectsisunavailabl ein plain java code the static analysis requires annotations t o be addedtotheprogram.anothertoolchecksthattheannotatio ns are consistent with the code and with each other and convey designintent .usingannotations anobjectcanbepushe din a domainunderneathanotherobjectthathas multiple domain s in its substructure.
therefore an oog allows the architect s to reason about the content of an abstract object that has a substructure.
for echo the destination of a dataflow is wrtr outputstream in the substructure of sckt socket .
the architects can reason that the wrtr object represents unencrypted data because socket does not provide encryption as opposed to the descendants of sslsckt sslsocket that may use encryption.
anoogtracksobjectreachabilitythroughdataflow pointsto and creation edges.
in echo the architectsuse the points to edgefrom out printwriter to wrtr outputstream toreasonthatadescendantof client echoclient hasapersistent referencetoadescendantobjectof sckt socket .iftheobject client were to pass out printwriter as a dataflowobject it would also provideaccess to a descendantof sckt socket because the descendant object wrtr is reachable from out .
the oog and the code are consistent and every node and edge of the oog has traceability information.
if the set of edges returned by a query satisfies a constraint the archite cts can trace directly to the corresponding lines of code that ma y introduce an architectural flaw.
the result of a query is thus directly actionable.
this is in contrast to a manually drawn architecture that does not have traceability to code where t he architects must spend additional effort reading the code an d investigating each potential architectural flaw they find.iii.
t he scoria approach scoriaisa semi automatedapproachin whichthe architects supported by existing tools find architecturalflaws as follo ws.
first the architects add annotations to code and typecheck them fixing any of the typechecker warnings in the process.
second the architects use a static analysis that automatic ally extracts a secgraph from the code with annotations.
third as an optional step the architects assign security propert iesto objects and edges as needed using queries on the secgraph .
fourth the architects write and executeconstraints on the sets returned by queries on the secgraph .
finally the architects trace to code from suspicious edges that constraints highli ght and inspect potential architectural flaws.
the process is in crementalsuchthatthearchitectscanbeginbyassigningprope rty values to only a few of the objects while by default the rest have the unknown value.
in the following we define several concepts informally introduced in the previous sections.
a. definitions dataflow communication means that an object a a has a reference to an object o o and passes it to an object b b or an object a a has a reference to an object b b and receives a reference to an object o o .
the objects a a and b b represent the source or destination objects and o o is a dataflow object that the dataflow communication refers to.
to emphasize that a dataflow edge refers to an object not a type we use a thin dashed edge from a dataflow edge to the object that the edge refers to .
to capture the directionali ty of the flow an object graph has import and export edges.
an importdataflowedgeexistsdueto thereturnvaluesofmethod invocations or field reads.
an export dataflow edge exists due to the arguments of method invocations or field writes.
a dataflow edge is relevant for security because it may lead to vulnerabilitiessuchasinformationdisclosureortamperi ng .
object identity means that every abstract object in an object graphisuniquelyidentified.
asaresult objectidentityenables the architects to assign a value to a security property of an objecto o and enables comparison of