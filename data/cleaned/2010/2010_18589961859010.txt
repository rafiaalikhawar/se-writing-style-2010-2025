variability modeling in the real a perspective from the operating systems domain thorsten berger university of leipzig berger informatik.uni leipzig.desteven she university of waterloo shshe gsd.uwaterloo.ca rafael lotufo university of waterloo rlotufo gsd.uwaterloo.caandrzej w asowski it university of copenhagen wasowski itu.dkkrzysztof czarnecki university of waterloo kczarnec gsd.uwaterloo.ca abstract variability models represent the common and variable features of products in a product line.
several variability modeling languages have been proposed in academia and industry however little is known about the practical use of such languages.
we study and compare the constructs semantics usage and tools of two variability modeling languages kconfig and cdl.
we provide empirical evidence for the real world use of the concepts known from variability modeling research.
since variability models provide basis for automated tools feature dependency checkers and product configurators we believe that our findings will be of interest to variability modeling language and tool designers.
categories and subject descriptors d. .
design tools and techniques d. .
metrics general terms design languages measurement keywords configuration empirical software engineering feature models product line architectures variability modeling .
introduction variability models represent the common and variable characteristics or features of products in a product line.
product line developers use them to manage the addition and evolution of features and their dependencies.
product line users derive concrete products from variability models.
a range of automated tools support these activities analyzers verify model consistency or detect dead features and permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.debug level int compress datajournalling flash file system misc.
filesystems support zlib default compression none size prioritysupport zlib zlib inflate jffs2 crc mtd debug level figure feature model interpretation of jffs2 graphical configuration tools configurators for short support intelligent choice propagation and model completion .
practical significance of variability modeling is reflected in the rise of industrial tools such as pure variants by pure systems gmbh and gears by big lever software inc. recognizing the interest the omg currently seeks proposals for a common variability language cvl standard .
although variability modeling languages have been designed both in academia and industry pure variants gears little is known on their practical use.
a recent survey lists many research contributions on feature models but no empirical studies of industrial practice of feature modeling.
our work addresses this gap.
we study and compare two variability modeling languages and their use kconfig and component description language cdl .
both were developed as part of open source operating systems oss .
kconfig is used to describe the variability of the linux kernel.
cdl is part of ecos a real time rt operating system for embedded devices.
both linux and ecos have vast configuration spaces with thousands of features which explains their need for variability management.
we compare the constructs the semantics and the usage of kconfig and cdl while using the well researched concepts of feature modeling as a reference.
feature models were originally introduced as part of the feature oriented domain analysis foda .
they gained popularity with product lines researchers and practitioners alike mostly due to the simple and intuitive notation.
feature models are tree like menus of configuration options or features with cross tree constraints among the features.
fig.
presents a sample feature model in the foda notation which illustrates the core concepts shared by many feature modeling languages.
the sample model shows the variability of the journalling flash file system one of the numerous files systems supported in both linux and ecos.
the boxes represent features.
the hierarchy represents dependencies for instance the default compression feature allows a further choice of sub features that refine it none priority or size.
filled dots mark mandatory features like debug level which must be selected if the parent is.
hollow dots represent optional features which do not have this constraint.
further several features can be related by a group constraint the sub features of default compression are connected by an arc denoting the xorgroup constraint exactly one of the three choices has to be selected.
finally textual cross tree constraints are listed to the right.
our goal is to provide quantitative and qualitative empirical evidence whether the concepts researched in feature modeling are used in real world modeling languages and product lines and if so how they are used to widen the understanding of the design space for the studied concepts.
we analyzed the two languages andthe models expressed in them the linux kernel model and the ecos model.
we have instrumented the native tools supporting the languages to build an infrastructure for collecting quantitative data about the models.
guided by the collected statistics we inspected large parts of the models to study actual usage patterns.
in order to also compare the languages directly as opposed to via models we also compared their semantics.
many semantic differences turned out to be subtle and not immediately obvious from the syntax.
with respect to the first objective our study shows that the core concepts of foda feature modeling are supported by both kconfig and cdl and are used in both the linux and the ecos models.
these include boolean optional integer and string features a hierarchy group constraints and cross tree constraints.
interestingly both languages and models use concepts that are beyond foda and have not been as widely studied as the core concepts visibility both languages allow controlling the visibility of features in the user interface ui of the configuration tool via visibility conditions .
computed defaults they both support computing default values of features using values of other features.
binding modes kconfig uses three valued logics to specify whether a feature implementation is linked statically built for dynamic linking or absent.
foda uses much more space if representing this in boolean logic.
domain specific vocabulary both languages provide specialized vocabularies for various kinds of features including architectural terms cdl such as components and interfaces or terms related to the configurator ui kconfig such as menus.
the vocabularies are specific to the two projects and likely improve the understandability of the models within the communities.
for the second objective the study reveals interesting differences in how kconfig and cdl provide the above concepts feature representation kconfig treats each feature as a variable either of boolean integer or string type cdl in addition also supports composite features that contain both a boolean component encoding feature presence and a numeric or string value.
feature hierarchy for both languages the hierarchy shown to users in a configurator largely follows the syntactic nesting in the corresponding model still both figure the ecos configtool gui languages offer some mechanisms to control the configuration hierarchy separately from syntactic nesting.
group constraints kconfig supports feature grouping constructs with group cardinalities limited to xor mutex andor.
cdl is more flexible allowing integer intervals as group cardinalities however the studied models only use xor mutex and orcardinalities.
in feature modeling and kconfig only parents can impose group constraints on their children in cdl features can impose group constraints on any other features and ecos makes use of it.
visibility and computed defaults both languages support two types of conditions on a feature conditions defining only configuration dependencies and conditions defining both such dependencies and visibility.
further visibility and computed defaults are used together to provide derived features automatically computed features not shown to the user in the ui.
derived features are used to simplify constraints or define implementation features used in the build system.
constraint language both languages support arbitrary boolean constraints.
kconfig supports also equality tests on integer and string values.
cdl adds various arithmetic and string operations and a few built in functions.
the models reveal that arithmetic operations are likely needed for embedded software as in ecos whereas string operations could be dealt with in the build system outside of the models as in linux.
we observed limitations in the configurators for kconfig and cdl see fig.
for the ui of the ecos tool .
particularly the kconfig configurator lacks reasoning procedures to support choice propagation.
to mitigate this the kconfig language includes an imperative construct for specifying choice propagation which delegates this task to model developers however both the kconfig user manual and many developer comments in the linux revision history acknowledge that using the construct is very error prone.
the ecos configurator is far more intelligent thanks to an inference engine however the engine offers incomplete reasoning and may propose configuration choices that would not be desirable for the user.
interestingly both configurators follow a reconfiguration paradigm any configuration task starts with an initial possibly default configuration.
however scalable reasoning to support conflict resolution in reconfiguration for rich languages such as kconfig and cdl remains an interesting open problem.
74kconfig and cdl are interesting and highly relevant study objects.
designed not by researchers but by developers of large industrial strength product lines they are tailored to satisfy the needs of these large projects 8m sloc for linux and .9m sloc for ecos .
the size of the models features for linux and features for ecos witnesses the scalability of the respective modeling approaches.
since both linux and ecos are open source their usage can be studied openly and researchers can independently validate and replicate such studies.
both languages support quite different systems the kernel of a general purpose os linux vs. the entire real time os for embedded applications ecos .
they were developed independently from each other and independently from the feature modeling languages with research origin.
since they share many similar concepts they can confirm the importance of the modeling constructs discussed in the literature.
although our analysis is limited to variability languages and models from the os domain we believe that other projects such as rt embedded systems that require static configuration will likely have similar requirements.
thus our findings are of interest to a growing audience of variability modeling language and tool designers especially in efforts such as the development of omg s cvl standard.
.
the systems the implementation of the kconfig language is distributed together with the linux kernel source.
kconfig has been used to specify build time dependencies of the kernel since .
the linux configurator reads the kconfig model and allows the user to select features in a graphical ui closely resembling the cdl configurator of fig.
.
it outputs a set of feature value mappings that are referenced in makefiles and in the source code as preprocessor directives .
the studied version .
.
of the linux kernel supports hardware architectures.
the code base spans directories and kconfig files.
kconfig models are distributed over multiple files organized according to the source code hierarchy.
each kconfig specification is placed alongside the related code.
an architecture specific kconfig file is used as a starting point for the specification a simple inclusion mechanism is used to include other files.
cdl was designed for the purposes of the configurable embedded operating system ecos ecos.sourceware.org .
unlike kconfig which is a standalone language cdl is embedded in tcl a dynamic and highly extensible scripting language.
cdl inherits characteristics from tcl such as syntactic nesting of blocks dynamic typing of values and a rich set of operators in constraint expressions.
cdl s configurator offers an inference engine for conflict resolution.
the studied version .
of ecos supports hardware architectures called targets and comprises almost a million lines of code.
the code base is divided into packages each one containing the source code and a set of cdl files declaring the configurability of the package.
each target defines a set of packages specific to the architecture.
so called templates aggregate packages with more cross architecture functionality.
in the configurator a user first selects a target and then one of the templates finally the user may decide to load additional packages into the configuration tree.
we scope our analysis to the x86architecture in linux and i386pc target with the alltemplate in ecos.
we extended theconfigurators to export the configuration tree together with all the information necessary for our analysis.
.
the languages to compare kconfig and cdl we reverse engineered formal semantics specification for each of them by analyzing user manuals testing the tools on examples and inspecting tool implementations.
this step allowed us to discover many subtle differences and connections.
here we summarize the key similarities and differences between the languages using the feature model in fig.
as the running example.
fig.
shows the same model in kconfig to the left and cdl to the right .
both snippets are in fact extracted from the original linux and ecos models.
they define the features of the journalling flash file system version jffs2 supported by both oss.
in fact ecos s jffs2 implementation was ported from linux.
jffs2 is one of very few of such ports but it makes an ideal example to illustrate the similarities and differences between kconfig and cdl.
to give a realistic impression of both languages we keep the examples close to the originals in particular we retain the original identifiers which differ somewhat from the names in fig.
.
the few lines introduced purely for the purpose of the example are underlined we also left out unnecessary parts of the corresponding sources.
our discussion will follow table as an outline.
the table summarizes the similarities and differences among kconfig cdl and foda based feature modeling and provides citations for concepts that go beyond the original foda notation.
features .
a feature is a label that can take one or more of the following roles .user feature a configuration option that can be set by the user in a configurator .grouping feature a label grouping a set of other related features such as a menu .implementation feature a configuration option accessed by the build system or a generator and .derived feature a configuration option automatically computed via constraints.
kconfig and cdl are domain specific languages providing specialized keywords for various kinds of features tbl.
row .
feature kinds in kconfig reflect their appearance in the configurator ui menus are pure grouping features menuconfigs are menus that can be enabled and disabled by clicking choices are like menus or menuconfigs except that they also impose grouping constraints on their children and configs are individual options.
the menuconfigmisc filesystems fig.
line k corresponds to the root in fig.
.
it contains the choice k corresponding to the parent feature of the xor group default compression and eight configs corresponding to the remaining features of fig.
all enclosed in if k andendif k .
cdl feature kinds reflect types of implementation entities they map to packages are top level containers for features mapping to ecos packages.
components are nested features grouping other features.
options are simple configuration options leaves .
several possibly exclusive features can provide equivalent functionality required elsewhere.
interfaces are abstractions allowing imposing cardinality constraints in such cases.
line c 9states that cygpkg fs jffs2 implements the interface cygint io fileio not shown .
75concept kconfig cdl feature models feature kindsgrouping menu menuconfig choice package component inte rface feature individual config option featurefeaturerepresentationcomposition single value bool.
value w opt.
data value bool .
value w opt.
attribute feature type switch bool tristate bool booldata optional data hex int string booldata data integer string none menu none mandatory hierarchyspecification syntactic and computed syntactic and reparen ting syntactic child to parent impl.
visibility configuration visibili ty configuration root synthetic synthetic explicitgroup constraintsmutex optional boolean choice interface constraint int mutex group or mandatory tristate choice interface constraint int orgroup xor mandatory boolean choice interface constraint int xorgroup interval n a interface constraint m int n group feature constraintsconfiguration select requires active if cross tree constraint value restrictions range legalvalues cross tree constraint derived features non prompt default calculated interfac e rare defaults prompt default default value rare visibility conditions prompt condition active if rare expression operators !
!
also inequality arithm.
and str.
ops.
unspecified binding modes three value logic n a rare othertextual content prompt help display description descrip tion modularization textual inclusion dynamic loading unload ing rare build symbols one to one one to many unspecified code mappings no uses kbuild m n yes n and build speci fications n a table mapping of concepts between kconfig cdl and feature mod eling feature representation .
the semantics of a feature model is a set of configurations.
a configuration specifies the presence or absence of each feature and a value for the related integer or string if the feature is present when applicable .
kconfig and cdl differ in the ways they represent configurations see tbl.
row .
in kconfig a configuration assigns a single value to each feature.
if fis the set of all features in the model and val is a set of all possible values then a particular configuration maps features to values f mapsto val and if f vthenv type of f table lists the possible feature types in three categories switch data andnone.
switch features appear as a checkbox in the configurator.
data features allow the user to input a value in a text box.
kconfig s menus have no type which corresponds to features of type nonein cdl.
the kconfig type boolhas two values yandn internally represented by and denotes feature absence while means that the feature s implementation is compiled statically into the kernel.
tristate resemblesbool except for the additionalmvalue represented internally by1 which denotes that the feature should be compiled as a dynamically loadable module.
for example jffs2 zlib k has type booland jffs2 fs k istristate .
kconfig supports two integer types int decimal andhex hexadecimal .
both types also allow an empty value which is used to encode the absence of an integer feature.
the type string is ambiguous in this respect a string feature with the empty value can be seen as a present feature with that value or an absent feature the two cases are indistinguishable.
in cdl every feature has two values an enabled state and adata value .
the enabled state is a boolean and encodes the presence or absence of the feature the data value is dynamically typed and used to store numbers and strings.thus a configuration maps features to value pairs f mapsto val and if f e d then d type of f cdl refers to the type of a feature as a flavor.
the available flavors map neatly to foda features as follows none mapsto mandatory with no attribute bool mapsto optional with no attribute data mapsto mandatory with attribute booldata mapsto optional with attribute more precisely features with the flavors noneanddatacan be made optional by specifying a configuration constraint explained later .
still an optional feature with flavor none ordatadiffers from its respective boolorbooldata counterpart the latter two are shown as user selectable checkboxes in the configurator whereas the former two have no checkboxes since their presence is controlled via visibility conditions.
figure includes features assuming numeric values cygopt fs jffs2 debug bool values cygopt jffs2 nand or strings cygopt fs jffs2 compress cmode .
hierarchy .
typical modeling languages organize features into hierarchies tbl.
row3 .
we distinguish between syntactic and configuration hierarchy.
the former is given by the syntactic nesting of features such as the nesting of configs in menus or choices in kconfig or options and components in other components and packages in cdl.
the configuration hierarchy is shown to the user in a configurator cf.
fig.
.
in the notation of fig.
the diagrammatic tree represents both the intended configuration hierarchy and the syntactic nesting.
in kconfig and cdl the configuration hierarchy can deviate from the syntactic one.
in kconfig syntactic nesting within menuconfigs and choices will be reflected in the configuration hierarchy however configs can also appear as children of other configs even though 76k 1menuconfig misc filesystems k 2bool miscellaneous filesystems k k 4ifmisc filesystems k k 6config jffs2 fs k 7tristate journalling flash file system ifmtd k 8select crc32ifmtd k k k k k 13config jffs2 fs debug k 14int jffs2 debug level quiet noisy k 15depends on jffs2 fs k 16default0 k 17range02 k help k 19debug verbosity of ... k k k 22config jffs2 fs writebuffer k 23bool k 24depends on jffs2 fs k 25default has iomem k k k 28config jffs2 compress k 29bool advanced compression options for jffs2 k 30depends on jffs2 fs k k 32config jffs2 zlib k 33bool compress w zlib... ifjffs2 compress k 34depends on jffs2 fs k 35select zlib inflate k 36defaulty k k 38choice k 39prompt default compression ifjffs2 compress k 40default jffs2 cmode priority k 41depends on jffs2 fs k 42config jffs2 cmode none k 43bool no compression k 44config jffs2 cmode priority k 45bool priority k 46config jffs2 cmode size k 47bool size experimental k 48endchoice k 49endifc 1cdl component misc filesystems c 2display miscellaneous filesystems c 3flavornone c c c 6cdl package cygpkg fs jffs2 c 7display journalling flash file system c 8requires cygpkg crc c 9implements cygint io fileio c 10parent misc filesystems c 11active if mtd c c 13cdl option cygopt fs jffs2 debug c 14display debug level c 15flavor data c 16default value c 17legal values to c 18define config jffs2 fs debug c 19description debug verbosity of.... c c c 22cdl option cygopt fs jffs2 nand c 23flavor bool c 24define config jffs2 fs writebuffer c 25calculated has iomem c c c 28cdl component cygopt fs jffs2 compress c 29display compress data c 30default value c c 32cdl option cygopt fs jffs2 compress zlib c 33display compress data using zlib c 34requires cygpkg compress zlib c 35default value c c c 38cdl option cygopt fs jffs2 compress cmode c 39display set the default compression mode c 40flavor data c 41default value priority c 42legal values none priority size c c c c c c c figure a model excerpt expressed in kconfig left and cdl righ t .
corresponding definitions are aligned.
they cannot be nested syntactically.
for example a group of consecutive configs declaring dependency on the same parent lines k is placed under this parent jffs2 fs .
in cdl the configuration hierarchy mostly follows the syntactic nesting of features unless declared otherwise.
reparenting is a mechanism to explicitly specify a parent from a different syntactic scope see line c .
it allows adjusting the developer oriented structure of the model to make it more user oriented before it is shown in the configurator.
an important property of the configuration hierarchy in foda like languages is that the presence of a child feature implies the presence of its parent for each edge from child cto parent p we have that c p .
the configuration hierarchy in cdl has this property too.
in contrast the configuration hierarchy in kconfig only enforces the childto parent implications for the visibility conditions.
so the parent of a feature that is visible in the configurator must be visible.
however if the parent is not selected a feature can still be selected automatically unlike in other known feature modeling languages.
finally both kconfig and cdl configurators show a synthetic root a fresh root node that is not explicitly specifiedin the model.
this enables working with diagrams that are forests and not trees like in foda.
group constraints .
in feature modeling group constraints restrict the number of sibling features to be selected if their parent is selected tbl.
row exactly one child for xor at least one for or and at most one for mutex .
alternatively the constraint can be given as an interval.
in kconfig a choice groups a set of features and imposes a group constraint on them.
choices are either bool or tristate with a mandatory oroptional modifier flag.
if not specified otherwise a choice is bool and mandatory thus the choice in line k 38is anxorgroup.
note that ecos developers decided to model this group differently c38 with adata flavoured option holding one of three string values encoding the three compression modes.
cdlinterfaces are a more expressive construct for restricting cardinality of a set of features.
the value of an interface counts the number of its selected implementations concrete features .
restricting this value introduces a cardinality constraint.
in contrast to foda like languages cdl does not require that all implementing features are 77siblings the feature activating the group constraint need not be a parent of the constrained features.
feature constraints .
cdl and kconfig support three types of constraints tbl.
row configuration constraints restrict the legal combinations and values of features defaults provide default values for features possibly depending on other features computed defaults they can be overridden by the user visibility conditions control the visibility of features in the configurator ui.
features whose visibility condition is false are not shown or otherwise disabled for user input.
computed defaults and visibility conditions have not been widely considered in feature modeling.
unlike configuration constraints defaults and visibility conditions have no direct impact on the configuration semantics.
however they interact with each other in complex ways that may impact configuration semantics.
we will explain this soon.
a configuration constraint is expressed using select in kconfig andrequires oractive if in cdl.
for instance the constraint support zlib zlib inflate of fig.
is expressed as aselect in line k 35and as arequires inc .
both select andrequires take a condition say p and denote the configuration constraint f p where fis the feature in which they are defined.
while pcan only be a feature identifier forselect kconfig it can be an arbitrary boolean expression forrequires cdl possibly accessing multiple features via logical arithmetic and string operators.
cdl sactive if has the same syntactic form and configuration semantics as requires except that it also enforces a visibility condition.
while the visibility of a child in both kconfig and cdl is inherited from its parent in the configuration hierarchy an explicit visibility condition allows non parent features to control the visibility too.
for example the visibility of cygpkg fs jffs2 is controlled by the parent c and another feature mtd c .
in kconfig the visibility of a feature is controlled by a prompt condition.
a prompt is a string that follows a type declaration k .
it is shown to the user when the feature is visible the condition is satisfied .
the condition is specified after the prompt here mtdin line k .
note that the select statement in line k 8is also conditioned on the same condition as the prompt.
this pattern of guarding other constraints by the prompt condition is frequent in kconfig thus the language provides a syntactic sugar for it.
the depends onstatement adds a condition to the prompt and all other constraints of a feature.
for example the prompt default and range specifications of jffs2 fs debug are only active ifjffs2 fs is selected as specified in line k .
constraint expressions in kconfig can use logical operators and equality tests overbool tristate integers and strings.
range restrictions on integer values are specified using range in kconfig andlegal values in cdl k c the latter can also be used to specify valid string values c .
default values are specified using default in kconfig k anddefault value in cdl c .
if no default value is specified kconfig assumes for boolandtristate and the empty string forstring int andhex in cdl the assumed defaults for boolean and data values is .
in kconfig visibility conditions defaults and configuration constraints interact in intricate ways.
if the visibility condition of a feature is false its default value specification becomes a configuration constraint because the feature cannot be accessed by the user to modify the default value.
we refer to such invisible features with calculated values as de rived features .jffs fs writebuffer in line k 22is derived since it has no prompt declared thus has a false visibility condition but has a default that determines its value.
notice that this feature was not shown in fig.
as foda notation does not include syntax for invisible derived features.
an example of a conditionally derived feature is jffs2 zlib with a stronger visibility condition prompt anddepends on than its default condition just depends on .
thus when the feature is not visible its value is derived using its default.
this happens even if its parent jffs2 compress is not selected.
consequently jffs2 zlib does not establish a child parent implication as in feature modeling notations.
cdl clearly separates defaults which can be overridden by the user and have no configuration semantics from derived features which cannot be changed directly by the user.
default values are specified using default value and only take effect when the feature is visible.
invisible features cannot be part of a configuration.
derived features comprise interfaces as well as other feature kinds with the calculated keyword which carry an expression that computes their values for example line c .
a feature can either use default value orcalculated but not both.
thus complex conditionally derived features do not appear in cdl.
a unique feature of kconfig is its first class support for a three valued logic.
its main operators are defined as follows eval !e eval e eval e1 e2 min eval e1 eval e2 eval e1 e2 max eval e1 eval e2 the semantics of expressions follows the logic of kleene where modcorresponds to the unknown state.
the equality test is defined only between constants i.e.
tristate int hexandstring and features state.
it evaluates to y if the values match and to n otherwise.
textual content .
both kconfig and cdl allow providing natural language descriptions for features tbl.
row a short text called prompt k anddisplay c that is displayed to the user to elicit a configuration decision and a longer description called help k anddescription c19 that explains the feature in detail.
modularization .
modularization allows division of specifications into parts.
kconfig and cdl have modularization capabilities that range from static source inclusion in kconfig to more complex mechanisms for dynamic loading of packages during configuration in cdl.
mapping to code .
all configs and menuconfigs in kconfig correspond directly to symbols controlling the build system and to the preprocessor directives of the same name.
these symbols and their values are referenced in presence conditions inside the kbuild system and control the inclusion of particular source files from the linux codebase.
although these presence conditions can be of any form they are a disjunction or conjunction of symbols in most cases.
in cdl feature names do not always correspond directly to symbols for the build and the preprocessor.
instead a more fine grained control over symbols is supported such as suppressing symbols defining additional ones or changing their formatting.
line c 18shows an example of a feature defining a build symbol config jffs2 fs debug which actually appears in the code ported from linux to ecos.
78linux ftrs ftrs ecos ftrs ftrsswitchbool type bool flavor tristate type booldata flavor1192 52dataint type .
hex type .
data flavor string type .
booldata flavor1192 .
55nonemenu .
component no type flavor none total total 1repeated as booldata is both switch and data feature type.
table representation statistics cf.
tbl.
row linux ftrs ftrs ecos ftrs ftrsgroupingmenu .
components menuconfig .
packages .
26grouping with constraintsxor .
xor .
or .
or mutex mutex .
.
table grouping statistics cf.tbl.
row .
the models let us turn from the languages to their use.
we now discuss themodels of linux and ecos expressed in kconfig and cdl respectively.
again we will use table as an outline.
features and grouping .
the linux model has features the ecos model is one fifth of this size.
table shows the breakdown of features by type.
the majority of features in the linux model are bool or tristate with only .
having integer or string types.
in contrast more than half of the features in ecos are data features this is interesting since the majority of the examples found in the literature have few or no such features .
note that we listed booldata features both as switch and data features to reflect their dual nature the percentages are given with respect to the total number of features which counts them only once.
we established the following reasons for the large percentage of data features in ecos.
first some feature kinds contain data values by default even though they are not intended to be directly set by the user interfaces carry the count of the number of implementing features selected in a configuration and packages always have the type booldata with the data part representing the package version as a string.
there are data or booldata interfaces and booldata packages in ecos.
further of dataorbooldata features represent enumerations similar to the last option in fig.
.
interestingly they accept legal values in total which is the number of additional boolfeatures that we would need to express these enumerations in kconfig as shown in fig.
.
there are also data or booldata features representing compiler flags representing linker flags and holding names of files with test code.
the remaining data or booldata features or of all features represent diverse configuration constants such as priorities buffer sizes and supported io ports.
many of these constants are specificto a rtos and would either be set dynamically or not be configurable in linux.
as many as a quarter of all ecos features are explicit grouping features as opposed to linux s .
this is unexpected given that the percentages of non leaf features in both models are comparable for linux and for ecos some components in ecos are leaves .
the reason is that linux also allows nesting of configs so configs can also take a grouping role.
whereas menus and menuconfigs create a separate menu structure requiring explicit drill down by the user config hierarchies are shown by indentation and are thus more lightweight to navigate.
less than of features in ecos and linux impose group constraints on their children.
let us see how group constraints are used in practice.
the three orgroups in linux are motivated by binding time the orconstraint in the model allows including multiple alternative features in the configured kernel as dynamically loadable modules only one of them will be loaded at runtime.
the only mutex group in ecos represents three alternative random number generators.
there are no mutex groups in linux a possible reason is the need to define a build symbol even when no group member is selected cf.
jffs cmode none in fig.
.
recall that cdl interfaces generalize group cardinality constraints.
this generality is not exploited in practice though.
we did not find a single instance of a group cardinality constraint which is a proper m n interval as opposed to intervals with lower bound being or and upper bound being or .
moreover although an interface can place a group constraint on features that are not siblings all interfaces are implemented by sibling features.
still the interface and the implementing features are usually far apart i.e.
do not have a common parent and are implemented across different packages.
in other words the group constraint is activated implied by the parent of the interface which is not the parent of the set of constrained features.
this form of a group constraint is more general than what is found in feature modeling where the parent of the group activates the group constraint.
such generalized group constraints are used to model the case where a given package defines an interface required by its implementation and multiple other packages provide alternative implementations of that interface.
in total we had such constraints in ecos.
hierarchy .
both linux and ecos have shallow configuration hierarchies with an average depth of for linux and for ecos and maximum depth of and respectively.
the number of features with a given number of children decreases sharply with the increase of the number of children the majority of features are leaves and respectively the second largest class are single child parents and followed by two child parents and .
nevertheless the maximum number of children branching is as much and respectively.
this indicates a need to develop modeling interfaces that support high variation in branching from very limited to very wide.
recall that unlike feature modeling and cdl kconfig uses hierarchy to depict a visibility relation instead of a presence condition allowing a child feature to be configured without its parent.
this possibility is indeed exploited in the linux model.
we verified with a sat solver applied to a derived boolean semantics of the linux model that features do not imply their parents like jffs2 zlib in fig.
.
we found re parented features in ecos.
most 79number of referenced featuresnumber of features020040060080010001200 20linux ecos figure feature dependencies per feature re parentings move packages in the hierarchy however options and components were re parented as well.
for example the cygbld global options component from cygpkg hal i386 pc package was promoted to the top level and in addition to its syntactic children two new options were re parented under this component.
still since relatively few features in ecos in linux violate hierarchical rules of feature modeling we observe that practitioners find hierarchical organization of dependencies natural.
constraints .
the vast majority of features surprisingly both for linux and ecos declare constraints of some sort configuration visibility or defaults .
fig.
shows histograms with dependencies per feature defined as the number of features referenced in constraints of a given feature.
in linux most features refer to other features this range is much lower in ecos with typically dependencies.
some features declare a large number of dependencies the maximum is in linux and in ecos.
table summarizes the use of visibility conditions and defaults.
both linux and ecos models use visibility conditions.
in linux of features have an explicitly specified prompt condition like jffs2 compress rather than just viadepends on and of features in ecos use active if .
further of linux features specify explicit defaults ecos makes heavy use of explicit defaults of features .
only a small part of features is computed via expressions for linux and for ecos the remaining defaults are specified as literals.
recall that linux supports conditionally derived features i.e.
features that are derived or user changeable with a default value depending on a condition of linux features belong into this category.
finally linux and ecos of features are unconditionally derived.
let us look at some examples of constraints.
linux constraints are mostly logical expressions such as a single feature or more complex expressions e.g.
smp x86 32 !
x86 voyager x86 64 linux constraints often reference integer or string features using equality tests.
in a single case an integer feature in linux uses another feature as a bound in a range constraint.
many ecos constraints are logical expressions too but arithmetic and string operations are not uncommon.
for example requires cygnum fs fat node pool size cygnum fileio nfile string concatenation denoted by .
is often used to produce lists of test or implementation source files calculated tests sprintf1 tests sprintf2 .
fileio ram ?
tests fileio other constraints check whether a particular file name is included in a list e.g.
requiresis substr libs libtarget.a .
such constraints implement code mappings.
in linux these are computed in kbuild outside of the model.
summary .
let us now summarize the main lessons learnt core foda concepts tbl.
are used in both models.
boolean features are the basic and most common type the constraint language should support arbitrary boolean constraints including mutual exclusion.
linux uses heavily the three state logics for controlling binding mode more than half features are tristate.
the languages benefit from being domain specific.
domain vocabulary increases understandability.
integer features are important for embedded systems ecos uses arithmetic operators and comparisons.
strings are mostly used for file names string operations other than equality tests seem essential if the build system lacks appropriate support.
group constraints dependent on a remote feature improve modularity in the ecos model.
since only basic cardinalities are used the interfaces appear overly general.
it suffices to include n ary xor orandmutex operators in the constraint language.
separating configuration hierarchy from syntactic hierarchy helps maintain modularity of the developer view separately from the user view.
like in feature modeling child to parent implications are enforced in cdl and in most of the linux model.
default values also computed are used a lot in practice saving the user unnecessary configuration work.
visibility control is essential in both models.
two constructs are useful a pure configuration condition like requires and a combined configuration and visibility condition likeactive if .
configuration independent of visibility leads to intricate semantics.
derived features are mostly used to perform calculations that otherwise would be hidden in the build system this way feature dependencies are specified uniformly and explicitly in one model.
.
the configurators kconfig and cdl are supported by gui based configurators that both support a configuration process known as reconfiguration the tool is initialized with a configuration loaded from a file or based on default values which is modified by the user to reach a desired state.
each of the two configurators takes a different approach to ensure that the user reaches a valid configuration.
the kconfig configurator prevents the user from modifications that violate constraints the ecos configurator allows such modifications but it detects violations and helps in resolving them.
the kconfig configurator offers little support for propagating user configuration choices.
if the dependencies of a given feature are not satisfied the tool prohibits selecting it.
the user has to find out which other features need 80concept linux ecos visibility conditions explicit defaults computed expressions literals conditionally derived n a unconditionally derived table visibility and default statistics to be reconfigured to enable the selection.
a rudimentary propagation support is offered by the select construct it enforces a selection of a single feature when the feature hosting the statement is selected.
the selection is made without respecting any constraints.
this imperative behaviour can lead to illegal configurations and requires kconfig developers to explicitly specify any transitive dependencies to maintain consistency.
for example latency top contains selects for both kallsym and kallsym all .kallsym all depends on kallsym thus the sole selection of kallsym all would be sufficient if the configurator used a propagating reasoner.
in fact the official documentation and the linux kernel commit log contain multiple warnings and complaints about the error proneness of using this construct .
still the linux model is full ofselect statements as this is the only way to obtain limited propagation in the configurator.
the cdl configurator is far more intelligent than its kconfig counterpart.
when the user modifies a configuration the tool detects all constraint violations and offers the user support to resolve them via an inference engine.
every change to the model is wrapped in a transaction and the configurator checks for any constraint violation.
if one occurs the inference engine tries to resolve the conflict by a heuristics based recursive search algorithm.
it builds a tree of transactions starting a transaction for each new subconflict that arises when testing conflict resolutions.
the engine estimates the benefit of particular sub conflict resolution by using the number of required changes and source of the values being changed e.g.
user default or inference.
if a sub resolution is beneficial it gets committed to the parent transaction.
if one overall solution is found for the top level conflict the tool lists necessary changes and requests confirmation.
otherwise the conflict requires manual resolution.
we investigated the inference engine s source code with respect to correctness andcompleteness .
the resolution is correct since the proposed resolutions are verified against the model constraints.
the resolution is incomplete as the inference rules are incomplete.
for example the engine has rules for handling cardinality constraints on interfaces of or but not for arbitrary bounds.
the recursion depth is limited to levels thus reasoning on transitive requires dependencies is incomplete.
the engine uses a greedy search evaluating resolutions to sub conflicts in separation and pruning all but the optimal one.
this may prune all successful branches.
although the inference engine is less powerful than general csp solvers it performs very well on the actual ecos model.
the support for mutex andxorgroups is particularly effective and the resolution of requires dependencies is far more maintainable than the select statement in kconfig.the main limitation of the cdl configurator is that if several resolutions exist it finds at most one and possibly not the desired one.
the following comment on the mailing list sourceware.org ml ecos discuss msg00161.html indicates that developers struggle with this problem if cygpkg mypkg op1 is active make sure that the list of tests for that package is a substring of cygdat mypkg active tests .
this works of the time.
problem is the other of the time rather than fiddling with the substrings it enables disables my subpackage!
our findings underscore the importance of building configurators based on strong reasoners.
tools employing complete reasoners do exist for package configuration involving simple use dependencies and version ranges.
for example p2 in eclipse is using a sat solver.
however scalable reasoning to support conflict resolution for rich languages such as kconfig and cdl remains an interesting open problem.
.
threats to v alidity the main threat to the external validity of our findings is that they are based on two languages and two operating systems only.
on the other hand both are large independently developed real world projects with different objectives linux is a general purpose kernel and ecos is an entire specialized rtos for embedded systems.
we believe that other related domains especially embedded rt such as automotive and avionic control software will share many characteristics with the studied systems.
further comparison to other feature modeling languages shows that both are representative of the space of feature modeling.
projects such as mozilla firefox or eclipse ide are organized as plug in architectures with dynamically loadable extensions.
such extensions are often listed on marketplace sites rather than managed centrally in a closed feature hierarchy.
variability languages for these systems extension manifests only capture use dependencies and required version ranges but no exclusions or other complex constraints.
our study does not apply to such systems.
we only look at the available artifacts the languages manuals models and mailing lists.
we have not interviewed developers and users.
we plan to perform such interviews in future work.
we only examined one architecture per os however both architectures represent large and mature portions of the systems linux s x86architecture covers of the total of features and of the total of 8m sloc the ecos s i386pc covers of the total of features and of the total of .9m sloc.
an internal threat is that our statistics are incorrect.
to reduce this risk we instrumented the native tools to gather the statistics rather than building our own parsers.
we thoroughly tested our infrastructure using synthetic test cases and cross checked overlapping statistics.
we tested our formal semantics specification against the native configurators and cross reviewed the specifications.
we used the boolean abstraction of the semantics to translate both models into boolean formulas and run a sat solver on them to find dead always inactive features.
we found dead features in linux and in ecos.
we manually confirmed that all of them are indeed dead either because they depended on features from another architecture or they were intentionally deactivated.
.
related work semantics of academic variability modeling languages were studied before .
we focus on languages originating from practice.
a survey on the use of feature models identified only five papers reporting practical experience.