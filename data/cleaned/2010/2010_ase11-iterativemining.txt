iterative mining of reso urce releasing specifications qian wu1 guangtai liang1 qianxiang wang1 tao xie2 hong mei1 1institute of software school of electronics engineering and computer science key laboratory of high con fidence software technologies peking university ministry of education peking university beijing china wuqian08 lianggt08 wqx meih sei.pku.edu.cn 2department of computer science north carolina state university raleigh nc usa xie csc.ncsu.edu abstract software systems commonly use resources such as network connections or external file handles.
once finish using the resources the software systems must release these resources by explicitly calling specific resource releasing api methods.
failing to release resources properly could result in resource leaks or even outright system failures.
existing verification techniques could analyz e software systems to detect defects related to failing to release resources.
however these techniques require resource releasing specifications for specifying which api method acquires releases certain resources and such specifications are not well documented in practice due to the large amount of manual effort required to document them.
to address this issue we propose an iterative mining approach called rrfinder to automatically mining resourcereleasing specifications for api libraries in the form of resource acquiring resource releasing api method pairs.
rrfinder first identifies resource releasing api methods for which rrfinder then identifies the corresponding resourceacquiring api methods.
to identify resource releasing api methods rrfinder performs an iterative process including three steps model based prediction call graph based propagation and class hierarchy based propagation.
from heterogeneous information e.g.
source code natural language the model based prediction employs a classification model to predict the likelihood that an api method is a resource releasing method.
the call graph based and class hierarchy based propagation propagates the likelihood information across methods.
we evaluated rrfinder on eight open source libraries and the results show that rrfinder achieved an average recall of .
with precision of .
in mining resource releasing specifications and the mined specifications are useful in detecting re source leak defects.
keywords resource releasing specification resource leak detection specification mining i. introduction software systems commonly use resources such as network connections or external file handles.
once finish using the resources the software systems must release these re sources by explicitly calling specific resource releasing api methods.
failing to release resources appropriately could cause resource leaks.
as a result the system at runtime slow ly depletes the limited supply of system resources leading to performance degradation and even system crashes .
al though programming languages such as java provide gar bage collection to free programmers from the responsibility of memory management the mechanism does not address the problem of resource management programs for a system must return the acquired resources by explicitly calling a resource releasing api method.
such tasks are error prone in practice.
for example sun s guide to persistent connections gets it wrong in code that is claimed to be exemplary.
to assist programmers in resource management automatic approaches for resource leak detection report code locations where invocations of proper resource releasing api methods are absent.
these approaches require formal resource releasing specifications for specifying which api method acquires releases certain resources.
a common type of such specifications is in the form of resourceacquiring resource releasing api method pairs denoting the programming constraint that if the program acquires resources by calling the resource acquiring method it should eventually call the corresponding resource releasing method to release the resources and perform necessary cleanup actions.
for example a typical resource releasing specifi cation is new fileinputstream fileinputstream.close .
unfortunately these formal specifications are often missing due to the large amount of time and energy that must be in vested to manually creating them.
to address these issues we propose an iterative mining approach called rrfinder to automatically mining resource releasing specifications for java api libraries.
rrfinder takes as input the source code java source or bytecode and the api documents javadoc of the library and produces a set of resource releasing specifications in the form of resource acquiring resource releasing api method pairs.
some existing approaches also mine such specifications by exploiting exceptional paths in api client programs.
however because client programs tend to include mistakes especially in resource management these approaches usually suffer from high false positive rates based on only statistical analysis of api usage information.
in addi tion api client programs may not be available or many enough e.g.
for newly developed libraries.
to mine such specifications from the source code and code documents for an api library our insight behind rrfinder is that high level resources are often wrappers of low level resources.
for example database connections high level resources are established through socket connec tions low level resources .
intuitively given a set of known low level resource releasing specifications lowra lowrr a high level specification highra highrr is found when this work is supported by the national basic research program of china under grant no.
2009cb320703 the national natural science foundation of china under grant no.
and aro grant no.
w911nf .
1javadoc documents are automatically generated from the code comments in java source code.
they are often provided along with the library distribution.
highra invokes lowra methods and highrr invokes lowrr methods.
in other words rrfinder conducts propagations based on method calling relationships starting from known basic specifications concerning low level resources.
our rrfinder approach addresses three main challenges to mine resource releasing specifications from api libraries.
first our preliminary study details of the study can be found at shows that relying on propagations alone is not sufficient to mine precise specifica tions.
for example although the method acceptfrom shown in figure invokes the lowrr method inputstream.close and performs some resource releasing actions the statements in bold acceptfrom cannot be regarded as a highrr method because its main functionality is to accept a connection from a specified host.
figure .
code snippets adapted from java.net.sockssocketimpl .
second to determine whether one api method is a resource acquiring releasing method heterogeneous informa tion should be considered together.
for example the re source manipulation actions performed by an api method may be specified clearly in its code comments therefore including comment analysis could serve as a complement for the code analysis.
third through our manual investigation although resource releasing methods exhibit certain common features such as conventions for method naming resource acquiring methods do not exhibit common features these features are described in section iv a therefore it is difficult to extract resource acquiring methods directly.
rrfinder addresses the preceding challenges and mines precise resource releasing specifications effectively.
figure gives an overview of rrfinder .
the api library under analysis first goes through two preparatory analyses section iii .
then to mine specifications rrfinder starts by identifying resource releasing api methods section iv because these methods normally exhibit certain common features.
next for these identified resource releasing api methods rrfinder searches for their corresponding resource acquiring api me thods section v which acquire the resources released in the resource releasing methods.
to identify resource releasing api methods rrfinder iteratively produces effective results by interleaving the step of model based prediction section iv a with the steps of call graph based and class hierarchy based propagations section iv b .
the model based prediction employs a clas sification model to predict whether an api method is a re source releasing method.
the model exploits heterogeneous information ranging from static structural information to dynamic behavioral information and from api library source code java source or bytecode to code comments javadoc .
the call graph based propagation explores me thod calling relationships to detect callers of known re source releasing methods.
such information is then used to update certain features of the detected caller methods driv ing the model based prediction step to identify new resource releasing methods from the caller methods.
via the call graph based propagation identification of high level re source releasing methods could benefit from identification of low level ones.
the class hierarchy based propagation identifies abstract resource releasing methods by drawing con clusions from their overriding methods.
such propagation is important in object oriented languages such as java where dynamic bindings are popularly used.
figure .
example of propagations.
figure shows an example to demonstrate the propagation steps.
rrfinder takes two steps to identify orbimpl.destroy as a resource releasing method.
first rrfinder identifies inputstream.close as a resourcereleasing method via class hierarchy based propagation.
public void acceptfrom inetsocketaddress saddr throws ioexcept ion socksbind saddr int i cmdin.read cmdin is a field variable of type inputstream socketexception ex null switch i c a s e r e q u e s t o k success do some operations... break c a s e f a i l u r e ex new socketexception socks server failure break ... ... if ex !
null cmdin.close cmdin null t h r o w e x perform some functional operations... figure .
overview of rrfinder .
next detecting orbimpl.destroy to have invoked inputstream.close via call graph based propagation rrfinder updates certain features of destroy accordingly and applies the classification model to finally predict destroy t o b e a resource releasing method.
this example reflects the ratio nale for iteratively interleaving the model based prediction with the propagations the features of each api method rely on the relationships including both calling and overriding relationships between methods and these features change dynamically with the propagations based on these relation ships in other words the feedback from the propagations drives the model based prediction to produce better mining results.
in summary our iterative mining approach has several advantages owing to interleaving the three steps.
first the propagations greatly enhance the effectiveness of the model based prediction to identify resource releasing methods.
second the model based prediction mitigates the impreci sion problem discussed in the first challenge of relying on propagations alone to identify resource releasing methods.
intuitively when a method is detected to invoke known re source releasing methods via call graph based propagation it will not be identified as a resource releasing method im mediately.
only when the heterogeneous features of the me thod satisfy the classification rules represented by the classi fication model would this method be identified as a re source releasing method.
this paper makes the following main contributions a novel approach called rrfinder to automatically mining resource releasing specifications for api li braries effectively.
the evaluation on eight open source libraries shows that rrfinder identifies resource releasing specifications with an average pre cision of .
and recall of .
.
a set of measurable features for identifying resource releasing methods.
an iterative algorithm to identify precise resourcereleasing methods interleaving the step of model based prediction with the steps of call graph based and class hierarchy based propagations.
a technique to identify resource acquiring methods for given resource releasing methods.
the rest of this paper is organized as follows.
section ii discusses related work.
section iii introduces the required preparatory analyses.
section iv and section v describe the identification of resource releasing acquiring methods re spectively.
section vi presents evaluation results.
section vii concludes.
ii.
r eleated work this section first discusses related work of our approach and then discusses relevant industrial techniques specifically the automatic resource management feature of java7.
a. specification mining our work is most related to specification mining approaches.
according to their mining data sources these ap proaches fall into three categories.
the first category of approaches mines frequent api usage patterns as specifications from api client pro grams.
in particular weimer et al.
and thummalapenta et al.
used exceptional paths to mine specifications.
because programmers usually perform clean up actions when exceptions occur a large proportion of their mined specifica tions are related to resource releasing specifications.
howev er based on only statistical analysis of the usage information these approaches usually suffer from high false positive rates.
the second category of approaches directly synthesizes tem poral specifications by analyzing api library source code.
for example whaley et al.
proposed an approach to identify illegal pairs of method invocations that would cause exceptions for java programs.
our technique of method relation analysis a preparatory analysis in section iii b is pri marily a refinement of their work.
the third category of ap proaches extracts specifications from api library comments.
in particular zhong et al.
proposed an ap proach to infer resource manipulation specifications from javadocs.
a typical resource manipulation specification pat tern involves the creation lock operation unlock and clo sure of the resources.
compared to their approach our ap proach exploits heterogeneous information and specifically focuses on specifications concerning only the creation and closure of resources.
in our evaluation .
of the specifi cations for eight open source libraries lack method comments for describing their resource acquiring releasing actions.
moreover the classification model for resource releasing methods in figure also indicates that relying on method comments alone is not sufficient to extract precise specifica tions.
b. resource usage cost analysis another category of related approaches is resource usage analysis .
these approaches collect resource usages of programs and check whether the usages are performed in a valid manner.
some approaches focus on resource leak prob lems and detect certain kinds of resource leaks .
these approaches require resource releasing specifications such as those produced by rrfinder .
other related approaches include program cost analysis .
these approaches esti mate for programs the upper bounds of resource usage that program executions will cost.
traditional approaches focus on a reduced number of resources such as execution steps time and memory.
when involving higher level application dependent resources these approaches require users to define the concerned resources and specify the relevant api me thods .
rrfinder could aid the users in this process and help reduce much of the burden.
c. automatic resource management in java7 one important feature of java7 is the mechanism of automatic resource management arm obviating the need for manual resource termination.
figure shows an example.
in java7 resources declared in the try statement will be released automatically once the execution of the try block terminates.
the only requirement is that resources must implement the java.lang.autocloseable interface.
this interface contains only one method with the signature public void close which is expected to perform resource releasing actions.
to maintain upward compatibility all resource classes that implement java.io.closeable in java development toolkit jdk versions older than java7 are also supported by this feature.
figure .
code snippet to demonstrate the arm java7 feature.
from the perspective of mining resource releasing specifications on the one hand our approach could work for all programs developed with jdk versions older than java7 on the other hand the advent of java7 brings a new application scenario for our approach.
for all off the shelf api libraries that are already developed with jdk versions older than java7 rrfinder analyzes these libraries and produces a list of possible resource releasing api methods.
these methods are the candidates that should be refactored to override the close method in the java.lang.autocloseable interface to make the resources usable with the arm feature.
in this way rrfinder has the potential to reduce the cost of the migration from older jdk versions to java7 for existing api libra ries.
iii.
p reparatory analyses before describing the key ideas of our approach we first present the preparatory analyses for each given api library.
a. purity and side effect analysis the procedure of purity and side effect analysis analyzes the side effects of each method and finds out the pure me thods that do not mutate states of libraries.
for example method isclosed in class java.net.socket is a pure method which simply checks the current state of the socket whereas method close is an impure method which changes the state of the socket into closed .
this procedure provides information for our approach to filter out unwanted method declarations and method invoca tions.
first declarations of pure methods are not candidates of resource releasing methods.
second invocations of pure methods are in fact noise when rrfinder analyzes the behavior of a method to determine whether it mainly performs resource releasing actions.
therefore in the process of in dentifying resource releasing methods rrfinder ignores all the pure methods.
b. method relation analysis the procedure of method relation analysis analyzes the relationships between each method pair a b for a given class trying to determine whether there exists a cause exp relationship the execution of method a would cause exceptions being thrown from the execution of method b when these two methods are invoked in a row.
this information is used to calculate an important feature forbiddenmtdpercent for model based prediction as described in section iv a. this procedure starts by computing under what conditions each method would throw exceptions denoted as etcondition .
next for a method b whose etcondition is computed this procedure iteratively analyzes the side effects of the other methods in the same class and produces a cause exp relationship between a b if the execution of method a would cause the satisfaction of etcondition of method b. the side effects of each method are computed in advance by our flow sensitive context sensitive interprocedural analysis.
public void close throws ioexception if in null return in.close in null checks to make sure that the stream has not been closed private void ensureopen throws ioexception if in null throw new ioexception stream closed public int read throws ioexception synchronized lock ensureopen ...... figure .
code snippets of the class java.io.bufferedreader .
figure presents an example to illustrate the process.
the assignment made in method close satisfies the etcondition of method ensureopen .
therefore a cause exp relationship is found between the method pair close ensureopen .
in addition via inter procedural analysis of the side effects for each method this procedure propagates the relationship to read which calls ensureopen .
in total we found that after the close method is invoked invocations of seven other public methods in the class would throw excep tions.
iv.
r esource releasing method identification rrfinder identifies resource releasing denoted as rr in short methods via an iterative algorithm interleaving the step of model based prediction with the steps of call graph based propagation and class hierarchy based propagation.
we first describe the core component the model based prediction step section iv a and then present the whole algo rithm section iv b .
a. resource releasing method classification model we aim to build a machine learning based classification model that automatically predicts whether an api method is an rr method.
for each api method a number of features are considered to build the model table i described in de tail below.
we chose these features by drawing from our own experiences of manually identifying rr methods from all the public methods in jdk.
because the ultimate goal of rrfinder is to assist programmers to write higher try inputstream fis new fileinputstream src outputstream fos new fileoutputstream desc byte buf new byte int i while i fis.read buf !
fos.write buf i catch exception e e.printstacktrace quality client code we consider only methods that can be accessed publicly.
natural language information we consider the natural language information in method names and comments based on the observation that rr methods tend to follow common conventions for method nam ing and comment writing.
for example these methods are often named with the words like close or dispose and their comments often include phrases such as release re sources and garbage collection .
this information provides an important hint to find rr methods.
in our evaluation we collect the list of rr related words whose full list can be found at referring to the wordnet dictionary and the list also includes their synonyms appearing in the names and comments of the rr methods in jdk.
table i. features of rr method classification model features description natural language information hasreleasewordsinnameorcomment whether the method name or the method comments contain words related to rr.
hasreleasewordsincomment whether the method comments contain words related to rr.
hasnonereleasewordsinname whether the method name contains words other than rr words.
source code information static structural information implcloseable if the method is declared in a class that implements interface java.io.closeable and the method is the public void close method this feature is true.
overridereleasem whether this method overrides a known rr method.
method behavioral information releasestmtpercent of all the statements in the method how high percentage perform rr actions.
method relationship information forbiddenmtdpercent how high perc entage of other public impure methods in the class cannot be invoked safely i.e.
without throwing exceptions after this method is invoked on the same object.
calledbyfinalize whether this method is called by finalize .
callersinclass the number of methods in the same class that call this method.
calleesinclass the number of methods in the same class that are called by this method.
static structural information rrfinder uses the static information in class hierarchies to compute two features.
the implcloseable feature denotes the conformation with java7 standards .
as de scribed in section ii b the mechanism of automatic re source management works for only classes that implement the interface java.lang.autocloseable whose corresponding interface in older jdk versions is java.io.closeable indicating that this interface is inherently designed for rr functionality.
the rationale with the feature overridereleasem is that if a method overrides an rr method there is a good chance that it still performs rr actions.
method behavioral information for each method rrfinder estimates whether its main purpose is to release resources by counting how high percen tage of the method s statements perform rr actions denoted as the feature releasestmtpercent .
when counting the statements it is important that rrfinder ignores trivial statements and focuses on critical operations.
we calculate this feature following formula .
to calculate the total number of methods statements rrfinder considers only nonprimitiveassignment statements and method invocation statements in a method because these two types of state ments could take the main responsibility for the side effects caused by the method.
other statements such as jump statements are less related to functional operations and are ignored.
two types of statements are considered to perform rr actions nullassignment representing statements that assign a null value to a variable and rr invocation representing statements that invoke known rr api methods.
in addition when counting the total number of methodinvocation statements two types of invocations are regarded as noises and excluded.
the first type is invocations of pure methods which are filtered using the results of the purity and side effect analysis section iii a .
the other type is auxiliary operations such as logging operations or data structure traversal operations which are filtered based on a predefined list.
figure .
code snippets adapted from java.util.logging.streamhandler .
to enhance rrfinder and make it adaptive the calculation of this feature would involve inter procedural tracking at certain circumstances.
inter procedural tracking works espe cially when a method a performs rr actions indirectly by calling a method b which nevertheless would not be recognized as an rr method due to factors such as being a private method.
in such cases without tracking into method b rrfinder would fail to identify the rr actions performed by method a. for example as shown in figure the rr method close calls only one method flushandclose which in fact performs rr operations but would never be identified as an rr method since it is a private method.
to deal with this situation rrfinder tracks into flushandclose and updates releasestmtpercent for close from to .
to avoid explosion rrfinder tracks into a called method only when its method name contains releasing related words and updates releasestmtpercent of the caller method only when its value can be increased.
by computing this feature rrfinder could estimate the main functionality of a method.
this strategy enables the exclusion of non rr methods that involve rr invocations .
for the method in figure the releasestmtpercent is only .
many statements are omitted in figure too low to enable the method to be identified as an rr method.
privatesynchronized void flushand close writer.flush writer.close writer null output null public synchronized void close flushandclose this feature acts as the critical bond connecting the step of model based prediction with the step of the call graph based propagation described later in section iv b .
thanks to this feature identification of higher level rr methods could benefit from the identification of lower level ones.
method relationship information rrfinder also exploits the relationships between methods in a class to identify rr methods.
rrfinder includes the feature forbiddenmtdpercent based on the following observation after the invocation of an rr method invocations of all other public methods that mutate the object s state i.e.
impure methods are usually forbidden on the same object otherwise exceptions would be thrown.
for example after the rr method close is called on an object of java.io.bufferedreader all the seven other public impure methods cannot be invoked on the same object safely i.e.
without throwing exceptions .
to compute the feature given a method a from class c rrfinder identifies public impure methods of class c that cannot be safely invoked after the execution of method a based on the results of the method relation analysis section iii b and purity analy sis section iii a .
suppose that rrfinder recognizes that m other public impure methods of class b could not be invoked afterwards and class b includes totally n other public impure methods then this feature is calculated as m n. the rationale with the feature calledbyfinalize is that in java the finalize method is automatically invoked in the process of garbage collection and this method should per form only rr actions .
for a method rrfinder also exploits the number of caller methods and callee methods of this method in the same class based on the observation that in most cases rr methods have very few interactions with the other methods in the same class.
in our evaluation we manually prepared the training set using all the public methods in jdk and adopted the decision tree classification algorithm to build the model details of the evaluation process are discussed in section vi .
after the model is built for each api method under consideration rrfinder first computes all its preceding features and then applies the model to predict whether this me thod is an rr method.
b. propagation in this section we present the iterative algorithm of rr method identification as shown in figure .
the algorithm takes as input a list of api methods under consideration and identifies the rr methods among them.
this algorithm maintains two key data structures releasems is a set of all identified rr methods and newfoundreleasems is a first in first out queue of newly detected rr methods from which propagations would be started.
in addi tion releasems also serves as a guard condition to avoid redundant propagations lines and .
the algorithm is mainly composed of three phases.
initially the algorithm iteratively computes the features for each api method and uses the pre built classification model to predict whether it is an rr method lines .
next for each newly detected rr method a call graph based propaga tion lines and a class hierarchy based propagation lines are started.
figure .
algorithm of rr method identification.
via call graph based propagation identification of higher level rr methods could benefit from identification of lower level ones.
when a new rr method is detected the value of feature releasestmtpercent for all its caller methods is increased.
therefore rrfinder performs such propagations by re computing releasestmtpercent line for each caller method and performs the prediction step again to see whether the caller method could be identified as an rr method line .
this process is more effective if a list of known rr api methods which the api library under analysis calls is provided.
for example the method abstractpooledconnadapter.close in library httpclient1 calls the method httpconnection.close in library httpcore2 both are actually rr methods due to the latter method being an rr method the value of releasestmtpercent is increased for the former method and the former method s chance of being identified as an rr method is also increased.
normally to find rr methods for any third party api libraries we provide the algorithm with the list of all the known rr methods in jdk.
via class hierarchy based propagation rrfinder identifies abstract rr methods which are important in objectoriented languages such as java where dynamic bindings are popularly used.
to make such propagation for each method our algorithm counts the number of methods that override this method denoted as childcount and also the number of rr methods among these methods denoted as releasechildcount .
our algorithm considers a method to be an rr method if its releasechildcount childcount is higher algorithm identifyresourcereleasingmethods input unkwnms a list of unknown api methods output releasems a list of resource releasing api methods begin .
releasems .
newfoundreleasems .
foreach m in unkwnms do .
label classifymethod m .
if label is resource releasing then .
add m to the end of newfoundreleasems .
add m to releasems .
while newfoundreleasems is not empty do .
remove the head method releasem of newfoundreleasems .
foreach caller methods callerm of releasem do .
recompute feature releasestmtpercent .
label classifymethod callerm .
if label is resource releasing then .
if callerm not in releasems then .
add callerm to the end of newfoundreleasems .
add callerm to releasems .
foreach overriden methods parentm of releasem do .
update the releasechildcount of parentm .
if its releasechildcount childcount inheritthresh then .
if parentm not in releasems then .
add parentm to the end of newfoundreleasems .
add parentm to releasems end httpclient rg httpcomponents client ga .
httpcore he.org httpcomponents core ga index.html.than a predefined threshold inheritthresh1.
therefore each time a new rr method is found the number of releasechildcount for each overridden method is increased and then our algorithm checks whether this update produces a new rr method lines .
the rationale with such propagation is that the common functionality of the overriding methods usually reflects the functionality of their commonly overridden methods.
v. r esource acquiring method identification both resource releasing and resource acquiring methods are needed to form specifications in the form of resourceacquiring resource releasing api method pairs.
for each identified rr method rrfinder next searches in its belonging class for the corresponding resource acquiring denoted as ra in short method which acquires the resources that are released in the rr method.
to find the corresponding ra method rrfinder starts by considering the two types of rr statements in the rr method.
for each nullassignment statement rrfinder searches in the same class for the method that makes non null assignment to the corresponding variable.
for each rr invocation statement rrfinder searches in the same class for the method that invokes the corresponding known ra method.
the definitions of these two types of rr statements are in section iv a .
figure presents an example for which the known rr specification is new datagramsocket datagramsocket.close .
rrfinder first identifies syslogwriter.close as an rr method which contains one rr invocation statement.
rrfinder then identifies the constructor to be the ra method by searching for the method that invokes the known ra method new datagramsocket .
public syslogwriter final string sysloghost ....... ds new datagramsocket ....... public void close ds.close figure .
code snippets of the class org.apache.log4j.helpers.
syslogwriter .
public threadsafeclientconnmanager httpparams params schemeregistry schreg ...... this.pool connpoolbyroute createconnectionpool params ...... protected abstractconnpool createconnectionpool final httppa rams params return new connpoolbyroute connoperator params public void shutdown pool.shutdown figure .
code snippets of org.apache.http.impl.conn.tsccm.
threadsafeclientconnmanager .
because the ra method must also be a method that could be accessed publicly a call graph based backward tracking from callees to callers is sometimes needed.
figure shows an example where the known rr specification is new connpoolbyroute connpoolbyroute.shutdown .
rrfinder first detects the method createconnectionpool which invokes the known ra method and then identifies the public constructor to be the target ra method which invokes createconnectionpool .
via backward tracking the identified ra method may not necessarily reside in the same class with the rr method the average percentage is .
for the eight libraries in our evaluation.
.
for example the identified rr method for class org.hibernate.impl.statelesssessionimpl is close and the only method in the class that acquires the corresponding re sources is the constructor but with a package accessibility i.e.
only accessible to methods or classes within the same package .
the actual target ra method is sessionfactoryimpl.openstatelesssession which is a public method invoking the constructor of statelesssessionimpl .
in addition there are cases when several ra methods are identified for one rr method.
in such situation various resources are acquired in different methods in the class and the rr method performs clean up for all the resources that may be acquired by the methods in the class.
finally if there are no nullassignment or recognized rr invocation statements in the rr method rrfinder assumes the public constructor of the class to be the ra method.
in our evaluation constructors account for .
of all the correctly identified ra methods.
a call graph based tracking may also be needed in case there are no public construc tors available.
in particular if the corresponding rr method resides in an interface a class hierarchy based propagation is also required to find the public ra method.
details of these techniques are omitted here due to the space limit.
vi.
e valuation we implemented a prototype tool for rrfinder and conducted an evaluation using it.
to build the rr method classification model we manually built the training set using non empty public methods in jdk in two weeks.
we then applied rrfinder to mine specifications for eight open source libraries detailed in table ii.
in particular column c lists the number of classes and column pm lists the number of public methods exposed by the library.
we se lected these libraries because they are known to involve substantial manipulations of resources such as external files database and network connections.
to evaluate the effec tiveness of rrfinder we prepared a golden standard for each selected library.
we invited four researchers from the institute of software at peking university to manually identi fy rr specifications for the libraries.
initially each library was examined by two researchers and then any disagree ments between the two were inspected by a third researcher.
we allocated the tasks based on the workload and also their familiarity with the subject libraries.
our evaluation was conducted on a .6ghz dual core machine.
all the manually identified specifications for the eight libraries are available at our evaluation addresses the following research questions which are organized in a top down manner.
rq1 could rrfinder mine specifications effectively?
rq2 the threshold inheritthresh was set to .
in our evaluation.
could rrfinder identify rr methods effectively?
rq3 how useful are the selected features in section iv a in predicting rr methods?
rq4 how much could rrfinder benefit from the propagations?
rq5 are the mined specifications useful in defect detection?
we do not discuss in de tail the evaluation results of rrfinder in ra method identification due to the space limit and its relatively good per formance as shown in table iii .
table ii.
subject projects and their characteristics .
library version c pm description cayenne .
.
object relational database hibernate .
.
java persistent framework httpclient .
.
http client side components httpcore .
http transport components log4j .
.
logging framework pdfbox .
.
java pdf library xalan .
.
xslt processor xerces .
.
xml parser a. rq1 effectiveness of specification extraction we applied rrfinder to extract specifications for the eight open source libraries and the results are shown in ta ble iii.
for the overall results columns time to f col umn time lists the time spent on each library in minutes column t lists the number of manually identified rr specifications columns p r f give respectively the pre cision recall and f score of rrfinder .
for the results of rr method identification columns cauto to rr column cauto lists the number of correctly identified methods by rrfinder column auto lists the number of automatically identified methods by rrfinder column man lists the number of manually classified methods columns pr and rr list the precision and recall of rr method identification.
for the results of ra method identification the last two columns columns pa and ra list respectively its precision and recall.
in particular to separate the impact of the rr method identification the calculation of the precision recall of ra method identification is confined to those ra methods whose corresponding rr methods are correctly identified by rrfinder .
from the results in table iii we have the following observations.
first rrfinder achieves relatively high precisions recalls and f scores on these libraries with an average precision of .
and recall of .
.
in particular the low precisions for libraries pdfbox and xalan are mainly caused by their corresponding low precisions of rr method identification which we explain later in section vi b. second the time used to mine specifications is acceptable.
moreover the time spent on each library is largely proportional to the size considering the number of classes and me thods of the library indicating that rrfinder is scalable.
third compared with rr method identification the ra method identification demonstrates a much better performance with an average precision of .
and recall of .
in dicating that the effectiveness of rr method identification is the critical factor in determining the overall performance of rrfinder .
finally by comparing column t with column man we found that there are more rr specifications than rr methods indicating that many rr methods an percentage of .
have more than one corresponding ra method.
b. rq2 effectiveness of rr method identification we next explain the results of rr method identification shown in columns cauto to rr in table iii.
in general rrfinder identified .
of the rr methods with the average precision .
.
the results indicate that to identify rr methods for a library rrfinder does not require the classification model to be trained using methods in the same library.
therefore users of our approach could rely on a universally built model to identify rr methods.
in particular the reason for the low precision of library pdfbox is that all the wrongly identified rr methods are manually classified by us as resource releasing utility methods.
figure shows an example method.
this method looks much like an rr method except that the releasing actions are conducted on the passed in parameters.
in contrast in this paper we focus on identifying resource releasing me thods that should be invoked when the tasks of their belong ing classes are completed and these methods perform releas ing actions for their belonging classes.
these resourcereleasing utility methods can be easily filtered by checking whether the rr invocation statements are conducted on the parameters.
similarly among the wrongly identified methods two of library xalan and one of library hibernate are all resource releasing utility methods.
the other wrongly identified method of library xalan is shown in figure .
this method is undoubtedly an rr method however as shown in the method comments this method is automatically called and should not be invoked by client programs.
figure presents two rr methods that were not identified by rrfinder .
the two methods demonstrate one challenge of rr method identification some rr methods do not perform resource releasing actions directly instead they fire certain events and send out signals and the actual resource releasing actions are accomplished via the cooperation of library overall results rr idtf.
ra idtf.
time m t p r f cauto auto man pr rr pa ra cayenne .
.
.
.
.
.
.
.
hibernate .
.
.
.
.
.
.
.
httpclient .
.
.
.
.
.
.
.
httpcore .
.
.
.
.
.
.
.
log4j .
.
.
.
.
.
.
.
pdfbox .
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
xerces .
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.9table iii.
results of resource releasing specification identification .
several different classes.
we plan to address this challenge in future work.
close the document.
public void close fdfdocument doc throws ioexception if doc !
null doc.close figure .
code snippet of class org.apache.pdfbox.importfdf .
automatically called when the html page containing the apple t is no longer on the screen.
stops execution of the applet thread.
public void stop if null !
m trustedworker m trustedworker.stop m trustedworker null m styleurlofcached null m documenturlofcached null figure .
code snippet of class org.apache.xalan.client.
xsltprocessorapplet .
figure .
code snippets with the left one from class org.apache.http.
nio.util.sharedinputbuffer and the right one from class org.apache.
cayenne.event.eventmanager .
c. rq3 rr method classification model we manually built the training set using all the non empty public methods in jdk.
we adopted the decision tree classification algorithm to build the model.
in this algorithm rules are organized as tree structures where leaves represent classification results and branches leading from the root to the leaves represent the conjunctions of the conditions of features leading to the classification results.
we chose this algorithm because the classification model can be explicitly visualized enabling us to evaluate the value of each feature and also the soundness of the training set.
we present the built decision tree model in figure .
for simplicity only branches leading to positive classifications of an rr method are shown.
five manners of the conjunctions of the feature conditions could lead to the prediction of an rr method the corresponding leaves are in bold .
for example a method is classified as an rr method when it does not override an rr method its method name contains only releasing related words and its releasestmtpercent is higher than .
.
the model in figure justifies our intentions of choosing these features and it shows the predictive power of each feature quantitatively.
intuitively the shorter the path leading from the root to the leave and the closer the feature condi tion gets to the leave the stronger the predictive power of the feature is.
therefore feature releasestmtpercent demonstrates the strongest predictive power.
in particular when calculating the features callersinclass and calleesinclass in table i we calculated both the number denoted as callers calleesinclasscount and the percentage denoted as callers calleesinclasspercent for a better prediction performance.
however the feature calleesinclasscount was dropped due to its relatively low predictive power indi cating that the rr methods may sometimes invoke other methods in the same class but normally would not be invoked by the other methods in the same class.
through our manual inspection we found that the rr methods are called only either by the finalize method in the same class or when unexpected behavior occurs during the operation in the other methods which are forced to terminate and need im mediate clean up.
in addition the feature hasreleasewordsincomment is also dropped.
although the comments for rr methods usually involve phrases such as release resource or allow garbage collection the comments are missing at certain occasions partially due to the developers assumption that they have already expressed their intention using the method names.
figure .
the decision tree classification model.
figure .
distributions of the correctly identified rr methods.
api librarycayenne hibernatehttpclienthttpcore log4j pdfbox xalan xerces total of correctly identified rr methods 020406080100120140model based prediction call graph based propagation class hierarchy based propagationpublic void shutdown if shutdown return shutdown true lock.lock try condition.signalall finally lock.unlock stops event threads.
after the eventmanager is stopped it can no t be restarted and should be dis carded.
public void shutdown stopped true for dispatchthread thread dispatchthreads thread.interrupt this model was trained with precision of .
recall of .
and fscore of .
.
overridereleasem yes hasreleasewordsinnameorcomment yes hasnonereleasewordsinname no callersinclasscount .
callersinclasspercent .
calleesinclasspercent .
yes overridereleasem no hasnonereleasewordsinname no releasestmtpercent .
implcloseable yes yes implcloseable no calledbyfinalize yes yes calledbyfinalize no forbiddenmtdpercent .
hasreleasewordsinnameorcomment yes callersinclasspercent .
callersinclasscount .
calleesinclasspercent .
yes releasestmtpercent .
yes d. rq4 benefits of propagations to discover the benefits of the propagations we investigated the distribution of the correctly identified rr methods considering the way that they are identified shown in figure .
of all the correctly identified rr methods .
are identified via call graph based propagation and .
via class hierarchy based propagation.
the results show that the propagations enable rrfinder to identify more rr methods.
e. rq5 usefulness of the mined specifications finally to evaluate the usefulness of the mined specifications we used these specifications to detect defects in open source projects.
figure shows a confirmed defect con cerning the specification sessionfactory.opensession session.close .
the left hand side code snippet shows the found defect when the method invocation synsdao.get throws exceptions the session created in newsession will be left unclosed.
the right hand side code snippet shows how the defect is fixed.
more examples of the detected de fects are not shown due to the space limit.
vii.
c onclusion we have proposed an approach rrfinder to automatically mining rr specifications for api libraries.
rrfinder first identifies rr api methods and then searches for the corresponding ra api methods.
to identify rr api methods rrfinder iteratively produces rich and precise results by interleaving the step of model based prediction with the steps of call graph based and class hierarchy based propaga tions.
evaluation results on eight open source libraries show that our approach performed effectively and the mined speci fications are useful in detecting resource leak defects.
r eferences e. torlak s. chandra.
effective interprocedural resource leak detection.
in proceedings of icse .
s. z. guyer k. s. mckinley and d. frampton.
free me a static analysis for automatic individual object reclamation.
in proceedings of pldi .
d. l. heine and m. s. lam.
a practical flow sensitive and contextsensitive c and c memory leak detector.
in proceedings of pldi .
sun s guide to persistent conne ctions proposal of automatic resource management java.net pipermail coin dev february .html.
a. salcianu and m. rinard.
purity and side effect analysis for java programs.
in proceedings of vmcai .
wordnet available at .
b. eckel.
thinking in java.
3rd edition.
prentice hall .
java7 available at .
i. h. witten e. frank and m. a. hall.
data mining practical machine learning tools and techniques.
3rd edition.
morgan kaufmann.
.
d. r. engler d. y. chen and a. chou.
bugs as deviant behavior a general approach to inferring errors in systems code.
in proceedings of sosp .
w. weimer and g. necula.
mining temporal specifications for error detection.
in proceedings of tacas .
s. thummalapenta and t. xie.
mining exception handling rules as sequence association rules.
in proceedings of icse .
j. whaley m. martin and m. lam.
automatic extraction of objectoriented component interfaces.
in proceedings of issta .
l. tan d. yuan g. krishna and y. zhou.
icomment bugs or bad comments?
.
in proceedings of sosp .
h. zhong l. zhang t. xie h. mei.
inferring resource specifications from natural language api documentation.
in proceedings of ase .
a. igarashi n. kobayashi.
resource usage analysis.
in proceedings of popl .
m. bartoletti p. degano g. ferrari and r. zunino.
local policies for resource usage analysis.
toplas .
i. bate g. bernat and p. puschner.
java virtual machine support for portable worst case executiontime analysis.
in proceedings of isorc .
r. wilhelm.
timing analysis and timing predictability.
in proceedings of fmco .
e. albert p. arenas s. genaim g. puebla d. zanardini.
resource usage analysis and its application to resource certification.
in proceedings of fosad .
j. navas m. mendez lojo and m. v. hermenegildo.
user definable resource usage bounds analysis for java bytecode.
entcs .
figure .
a confirmed defect in mesh4j.