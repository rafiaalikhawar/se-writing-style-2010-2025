effective interprocedural resource leak detection emina torlak satish chandra ibm t.j. watson research center usa etorlak satishchandra us.ibm.com abstract garbage collection relieves programmers from the burden of explicit memory management.
however explicit management is still required for nite system resources such as i o streams fonts and database connections.
failure to release unneeded system resources results in resource leaks which can lead to performance degradation and system crashes.
in this paper we present a new tool tracker that performs static analysis to nd resource leaks in java programs.
tracker is an industrial strength tool that is usable in an interactive setting it works on millions of lines of code in a matter of minutes and it has a low false positive rate.
we describe the design implementation and evaluation of tracker focusing on the features that make the tool scalable and its output actionable by the user.
categories and subject descriptors d. .
software program veri cation d. .
testing and debugging general terms algorithms reliability veri cation keywords resource leaks alias analysis inter procedural analysis .
introduction while garbage collection frees the programmer from the responsibility of memory management it does not help with the management of nite system resources such as sockets or database connections.
when a program written in a javalike language acquires an instance of a nite system resource it must release that instance by explicitly calling a dispose or close method.
letting the last handle to an unreleased resource go out of scope leaks the resource the runtime system gradually depletes the nite supply of system resources permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.1public void test file le string enc throws ioexceptionf printwriter out null tryf tryf out new printwriter new outputstreamwriter new fileoutputstream le enc 8gcatch unsupportedencodingexception ue f out new printwriter new filewriter le 10g out.append c 12gcatch ioexception e f 13g nallyf if out !
null f out.close 16g 17g 18g figure code example adapted from ant.
leading to performance degradation and system crashes.
ensuring that resources are always released however is tricky and error prone.
as an example consider the java program in fig.
.
the allocation of a fileoutputstream on line acquires a stream which is a system resource that needs to be released by callingclose on the stream handle.
the acquired stream object then passes into the constructor of outputstreamwriter which remembers it in a private eld.
the outputstream writer object in turn passes into the constructor of print writer .
in the nally block the programmer calls close on the printwriter object.
this close method calls close on the nested outputstreamwriter object which in turn calls close on the nested fileoutputstream object.
by using nally it would appear that the program closes the stream even in the event of an exception.
however a potential resource leak lurks in this code.
the constructor of outputstreamwriter might throw an exception notice that the programmer anticipates the possibility that an unsupportedencodingexception may occur.
if it does the assignment to the variable outon line will not execute and consequently the stream allocated on line is never closed.
resource management bugs are common in java code for a number of reasons.
first a programmer might omit a call to close due to confusion over the role of the garbage collector.
second even a careful programmer can easily fail to release all resources along all possible exceptional paths as illustrated in fig.
.
finally a programmer needs to understandall relevant api contracts.
in the example above the programmer correctly reasoned that closing the printwriter instance closes the nested resources through cascading close calls.
but cascading close is not universal across all apis and a programmer could easily make incorrect assumptions.
contributions.
in this paper we describe the design implementation and evaluation of a static analysis tool called tracker for resource leak detection in java programs.
our contribution is in overcoming the engineering challenges to building a useful scalable leak detection tool.
by useful we mean that the reports produced by the tool must be actionable by a user as opposed to merely comprehensive.
by scalable we mean that the tool must be able to handle realworld java applications consisting of tens of thousands of classes.
some of the challenges that we address are common to all static analysis tools and include the following scalable inter procedural analysis.
inter procedural reasoning about aliases is crucial to building a useful resource leak detection tool.
given the program in fig.
for example the tool needs to reason that the instance of fileoutputstream released in outputstreamwriter sclose method is in fact the same instance that was attached to the outputstreamwriter object when the latter was constructed.
the need for such reasoning can make it di cult to handle applications with tens of thousands of classes as programs of this size are not amenable to precise whole program alias analysis.
tracker side steps the general alias analysis problem by tracking pertinent aliasing information using access paths in the context of an e cient inter procedural dataow analysis .
we observe empirically that surprisingly sparse tracked aliasing information can accord high precision.
false positives.
false positives are inevitable in any tool that guarantees soundness.
however if a bug nding tool produces too many false positives the average user will simply ignore its results.
building a bug nding tool as opposed to a veri cation tool whose goal is to determine whether or not the code is free from a certain class of errors opens up the possibility and creates an expectation of prioritizing reports that are likelier than others to be true positives.
tracker o ers such prioritization by keeping a record of whether a bug was witnessed along some path or whether it was assumed due to the limitations of the analysis.
we show empirically that bugs arising from analysis limitations are much more likely to be false positives.
we also tackle issues that are speci c to the problem of resource management nested resources.
it is not enough to track just system resources because the corrective action that a user needs to take may be to call a close method on an object that nests a resource instance.
suppose that in the above example the constructor of outputstreamwriter could not throw an exception but instead the programmer forgot to call out.close .
even though the leaked system resource would still be the fileoutputstream a user may justi ably expect a tool to report that the printwriter referenced by outshould be closed rather than the nameless instance of fileoutputstream .tracker o ers reports that make proper remedial action more apparent.
exceptional ows.
as shown in the example in fig.
as well as by others previously programmers often makemistakes in using try catch nally blocks.
a resource leakage tool therefore needs to pay special attention to bugs lurking there.
reporting leaks due to all possible runtime errors would overwhelm the user with uninteresting results but we must deal with those exceptions that the programmer expects to occur.
for instance a programmer would typically ignore a leak report based on an outofmemoryerror because most programs are not expected to deal with such abnormal conditions.
instead we present a belief based heuristic that suppresses reports due to exceptional ow unless the analysis nds plausible evidence to justify the report.
summary of results.
we evaluated tracker on a suite of large open source applications ranging in size from to classes.
all benchmarks were analyzed in a matter of minutes with our tool identifying resource leaks at an actionable true positive rate of to percent.
the engineering techniques that we describe here are crucial for actionability of the output produced by tracker our exception ltering mechanism for example reduces the false positive rate by roughly .
in comparison to findbugs tracker found times more true positives.
our tool has been used internally by ibm developers who applied it on real code and xed most of the leaks it reported.
a version oftracker ships in rational software analyzer version .
as a part of its java static analysis suite.
outline.
the remainder of this paper is organized as follows.
section presents the core resource tracking algorithm oftracker .
section presents enhancements germane to producing useful reports for such a tool.
section presents selected implementation details especially how we construct the call graph.
section presents a detailed empirical evaluation.
section reviews related work and section concludes the paper.
.
core algorithm for resource tracking in this section we rst give a quick overview of how the basic analysis works as applied to fig.
.
subsequently we give formal details of the core intra procedural and interprocedural resource tracking algorithms.
.
overview the analysis takes as input a controlow graph cfg and a speci cation of procedures that acquire and release system resources.
figure shows the relevant parts of the cfg for fig.
along with the cfgs of some of the called methods.
we introduced temporary variables t1and t2 when constructing the cfg a .
the example s speci cation declares that the constructor for fileoutputstream allocates a resource and the corresponding close releases it.
the goal of the analysis is to establish that the allocation of a resource on line is followed by its release on all possible execution paths to exit when this property does not hold there is a potential leak.
tracker symbolically tracks each resource through paths in the cfg until either a it is released or b it becomes unreachable without being released and thus leaks.
consider the program path starting with the resource allocation on line .
the next two lines require inter procedural tracking due to constructor calls.
the constructor on line stores its argu a cfg of testout nullt1 new fileoutputstream file t2 new outputstreamwriter t1 enc out new printwriter t2 catch unsupportedencodingexceptionout ...out.append out !
nullout.close exitentry2 ... 141598oomoomoomuee ioe c cfg of printwriter.
init w this.b wexitentry b cfg of outputstreamwriter.
init os this.a osexitentry e cfg of outputstreamwriter.close this.a.close exitentry d cfg of printwriter.close this.b.close exitentryfigure controlow graph of the procedure shown in fig.
.
numbers to the left are line numbers.
dashed edges represent exceptional ow labeled by the type of exception they carry e.g.
oom outofmemoryerror .
dotted edges represent inter procedural control transfers.
ment into an instance eld a. our analysis concludes that after line both expressions t2.aand t1point to the tracked resource.
the constructor on line stores its argument into an instance eld b. our analysis likewise concludes that after line the expression out.b.a also refers to the tracked resource.
the call out.close on line transitively calls close on expressions out.b and out.b.a notice that thisin cfgs d and e would be bound appropriately the last one releasing the tracked resource as it is equal to t1.
at this point the resource referred to by the expressions t1 t2.a and out.b.a is released and is therefore no longer tracked.
to be e ective the algorithm needs to be able to prove that this.ain cfg e is equal to t1assigned in cfg a .
this requires precise inter procedural must alias reasoning.
tracker performs e cient must alias reasoning using selective equality predicates without relying on whole program alias analysis as was done in prior work e.g.
on typestate analysis and resource leakage analysis.
1in modern oo languages construction of a call graph itself is a whole program analysis we describe our computation of call graph brie y in sec.
.consider now the exceptional path exit.
on line the expression outrefers to the object allocated on line and it is not equal tot1 the resource allocated on line .
at the exit of the procedure the expression t1still points to the unreleased resource from line and no other expressions may point to that resource.
since t1goes out of scope at the procedure exit we conclude that the resource allocated on line is unreachable unreleased and leaks.
what about the path exit where the branch on line is not taken?
if the analysis can prove that the false outcome is not possible the path is infeasible otherwise the analysis must report a leak.
tracker avoids this false positive.
what about the path exit in which anoutofmemoryerror occurs on line ?
the resource can leak along that path.
however at the user s discretion tracker can suppress problems along exceptional ows associated with fatal exceptions.
.
intra procedural analysis we describe our analysis on a controlow graph containing the following kinds of abstract statements entry exit p acquire r release r q branch c l p new t p q.f intraproceduralresourceanalysis cfg speci cation type fact ssavariable resourcetype state var d statement!2fact 3fors2statement do d s 5fors2statement do ifsisp acquire r a initialstate p 88t2succ s d t d t fhp r aig 9while changes in ddo s pick from statement 11hp r ai pick from d s case sisrelease r q if ismustalias p q a 148t2succ s d t d t fhp r aig case sisbranch c l ifisconsistent c a u truesucc s d u d u fhp r aig ifisconsistent c a u falsesucc s d u d u fhp r aig case sisexit ifisunreachable a p report pas leaking other a0 258t2succ s d t d t fhp r a0ig figure intra procedural leak algorithm.
p.f q p q and invoke .
for clarity we assume that we have rewritten method calls that allocate and release resources abstractly as acquire and release statements.
for example p new fileoutputstream le is represented as p acquire fileoutputstream invoke p. init le the statement p.close is represented as release fileoutputstream p invoke p.close we assume that each local variable has a single static assignment ssa .
the abstract statement p q is included to describe the treatment of nodes introduced in ssa conversion as well as to model transmission of values from actuals to formals in a procedure call.
the branch statement has a conditional expression cand a jump target l. generic data flow analysis.
figure shows a generic resource tracking analysis.
the algorithm performs iterative dataow over a powerset lattice of facts of the kind fact as de ned on line .
a fact is a tuple that consists of anssavariable which is an ssa value number a resourcetype which is the kind of the tracked resource and a state which represents a nite amount of auxiliary information used to resolve queries the algorithm will make.
a concrete description of state will be given shortly but for now assume that it contains predicates over local variables.
the algorithm makes use of the following auxiliary functions .
initialstate p ssavariable creates an element of state based on the given ssa variable.
.
ismustalias p ssavariable q ssavariable a state evaluates to true if given the information in a p equalsq.
if this check fails the analysis cannot assume that the variable on which release is called strongly closes a resource referred by p. a conservative answer to this query is false.
.
isconsistent condition expression a state is true ifcondition which is a conditional expression expression does not contradict the information in a. this function is used to prune infeasible paths.
a conservative answer to this query is true.
.
isunreachable a state p ssavariable returns true if the resource referenced by pmay no longer be accessible by any live name as per information in a. at the exit of a procedure local variables are assumed to become dead unless otherwise preserved in a. a conservative answer to this query is true.
lines seed the analysis with initial facts that correspond to resource allocation.
the algorithm then propagates these facts through program statements creating new facts along the way.
lines show the e ects of pointer statements such as p.f q on state we describe these e ects shortly.
the algorithm converges because no fact is deleted from the mapd and because each component of fact is nite.
defining state.
tracker implements state as a set of must access paths to a tracked resource .
a mustaccess path is an expression comprised of a variable followed by a possibly empty sequence of eld names such that the value of the expression refers to the resource.
for example out.b.a is a must access path.
figure shows how a set of must access paths named inis transformed by individual program statements.
as is customary in ow analysis gen refers to the new must access paths added to the set and killrefers to the must access paths removed from the set.
we remind the reader that state here represented by set of must access paths is only one component of the data ow domain fact.
in the table of transformations alias p checks ifpmay be an alias of expression based on an inexpensive type match.
because state is nite each time the transformation of must access paths set is computed we must limit the size of the resulting set using a function lter.
it is necessary to do so for two reasons a in the presence of loops or recursion it is possible for access paths to grow inde nitely and b even loop free code might in ate the sets to needlessly large sizes compromising e ciency.
the function lter a state empties the set if either any access path in it is longer than a preset limit depth or the number of access paths in it has exceeded a preset limit breadth .
we did not nd it useful to trim the set to size instead of emptying it.
given this implementation of state the auxiliary functions mentioned above are de ned as follows.
initialstate p produces a singleton set fpg.
ismustalias p q a checks ifq is in the must access path set a. isconsistent condition a can be resolved for only certain kinds of queries.
if acontainsv where is a possibly empty list of elds then we know that vcannot be null.
therefore a condition is of the formv null orv6 null can be decided exactly.
if a contains both vandw then we can infer v w. finally isunreachable a p is true ifais empty.
example .
consider the code fragment shown below.
we show the facts accumulated by our analysis after each statement to the right.statement out lter in kill gen p q.f gen fp jq f 2ing kill startswith p in p.f q gen fp f jq 2ing kill startswith p f in aliasmatches p f in p new t kill startswith p in p acquire r kill startswith p in p q gen fp jq 2ing kill startswith p f in startswith p in fp jp 2ing aliasmatches p f in f fj f2in alias p g figure flow functions for access path sets.
is a possible empty sequence of eld names.
p acquire r hp r fpgi q.f p hp r fp q fgi r q.f hp r fr p q fgi branch r null l1 t none f hp r fr p q fgi release r none l1 none at the branch statement isconsistent check tells us that only the fall through successor is feasible r being a mustalias to a resource cannot be a null pointer.
at the release statement the call to ismustalias p r fr p q fg succeeds.
consequently no fact makes it to l1.
had we used an imprecise and conservative isconsistent we would have obtained the fact hp r fr p q fgiafter l1.
local variables would then be dropped from the state giving the facthp r fgiat the exit.
this fact would satisfy the query isunreachable fg p resulting in a false positive.
if we had ltered the state on line for a breadth limit of we would have conservatively decided that the release onrmay not release the resource acquired on line that is ismustalias r p fg would be false.
again this would have resulted in a false positive.
example .
consider the leaky code fragment shown below.
it allocates a resource in a loop but frees only the last allocated instance.
the branch after l1 has a nondetermnistic condition for which the analysis must answer isconsistent true for both outcomes.
p1 null l1 hp3 r fp3gi hp3 r fp2gi p2 p1 p3 hp3 r fp2 p3gi hp3 r fgi branch l2 p3 acquire rhp3 r fp3gi hp3 r fp2gi branch true l1 l2 hp3 r fp2 p3gi hp3 r fgi release p hp3 r fgi this fragment also illustrates the treatment of nodes.
consider the path taken through the loop two times and then exiting to l2.
the initialization generates hp3 r fp3gi after the acquire .
the generated fact ows to l1 where the generateshp3 r fp2 p3gi using the e ect of p2 p3.
this in turn ows out to l2 where it is removed by release .
next time in the loop body the acquire statement kills the occurrence of p3infp2 p3g generating the fact hp3 r fp2gi.
going around the back edge again this last fact is trans formed by the statement tohp3 r fgi.
when the transformed fact ows out to l2 it cannot be removed by release .
the test isunreachable fg p3 passes and we report a leak.
alternative definitions of state.
it is worth reiterating the role of state it keeps track of interesting information related to a speci c resource allocation.
we have presented a speci c embodiment of state .
one may decide to implement the analysis described here using a richer state at additional run time cost for example it could track even more predicates to enable more precision in call resolution or in branching.
we have not found a compelling need to enrich state .
going in the other direction since there are conservative ways of answering the queries we make on state it is also possible to have a trivial embodiment of it at the expense of precision.
a third alternative is to decouple the state from a speci c fact and answer the auxiliary predicates based on globally computed information.
for example one might compute a precise ow and context sensitive points to analysis to answer the queries.
we decided against this approach since it has proven di cult to scale such analyses to the sizes of applications we wish to handle.
.
inter procedural analysis the algorithm presented in figure generalizes easily to the inter procedural case.
as is fairly standard we assume there is an inter procedural calledge from a call statement to each of the possible callees a static call graph can indicate multiple possible callees and there is a return edge from the exit of a callee to each of the call statements that could have invoked it.
for an example see fig.
where we show call and return edges using dotted lines.
a call edge is accompanied by the assignment of formal parameters to values of the corresponding actuals and likewise a return edge is accompanied by the assignment of the return value if any to the left hand side if any of the call statement.
we implement inter procedural analysis over this structure using the ifds framework .
relevant callees.
our algorithm implements the following performance optimization when it encounters a call statement.
for a facthp r aithat reaches the call instruction it determines whether the callee method is relevant .
a method is relevant to a fact if it or any of its transitive callees contains a statement that may alter the fact s state .
the algorithm uses an inexpensive and conservative side e ect computation to determine relevance.
if a callee is relevant to a fact the fact is propagated into the callee.
here formal parameters of the callee are assigned corresponding values from the actuals using the transformation for a copy statement p q .
if the callee is not relevant the fact is propagated only to the successors of the call statement bypassing the call.
this optimization is fruitful because in practice a lot of methods are auxiliary in nature and it is wasteful to drag facts along the cfgs of those methods.
any exceptions that can be thrown inside the bypassed callees and that are not caught locally are re ected in our ir as exceptional ow edges emanating from the call instruction in the caller s cfg.
thus soundness is not sacri ced when bypassing callees.
namespace management.
because ssa variables as used in sec.
.
are only unique within a single procedure weneed to protect caller value numbers from getting mixed up with callee value numbers.
details of this are routine and are omitted.
.
soundness given a sound call graph tracker is sound in that it does not miss true positives.
we note however that computing a sound call graph for partial programs or in the presence of re ection is non trivial.
we describe our beste ort call graph construction brie y in sec.
.
we also note that we are analyzing open programs e.g.
a library without client code.
in such programs a resource occasionally escapes to the unknown caller either as a return value or as a eld of some longer lived object.
we do not call such situations leaks assuming optimisitically that the missing client would release the escaped resources.
we could easily implement a pessimistic version of the algorithm but we nd the optimisitic assumption more useful.
our claim to soundness is modulo this assumption.
.
computing actionable reports this work focuses on producing error reports that are actionable rather than merely comprehensive.
we discuss three ways in which we enhance actionability.
first we prioritize reports based on the structure of access paths sets so that likely true positives are ranked higher.
second we cluster reports that arise from leakage of the same underlying resource.
third we suppress reports that arise from exception ows that are deemed unlikely or uninteresting to the programmer.
.
prioritization as discussed in sec.
.
our analysis works by tracking sets of must access paths to unreleased resources and reporting a leak if a tracked set becomes empty.
an access path set may become empty in one of two ways every handle in the set is rooted at a local variable that is going out of scope or the size of the set or the length of one the handles is about to exceed a preset limit.
in the rst case the generated leak report is based on a leakage witness a path through the program s supergraph along which the given resource is not released.
these are called witnessed reports .
in the second case the analysis is unable to nd a witness with the given limits on fact size so the resulting leak report is called an assumed report .
witnessed and assumed reports obtained by progressively relaxing the limits on the size of tracked facts have two key properties which our implementation exploits to generate low cost high quality results.
first for a given limit don the length of tracked paths and a limit bon the size of tracked sets witnessed reports whd biare signi cantly more likely to be true positives than the assumed reports ahd bi sec.
.
.
we therefore prioritize tracker s output so that the reports inwhd biare ranked higher than those in ahd bi.
second for a pair of limitshd biandhd0 b0i whered d0andb b0 whd bi w hd0 b0iandahd bi whd bi ahd0 b0i whd0 b0i.
that is the analysis generates more witnessed reports and rules out more false positives when tracking richer facts which is a straightforward consequence of our de nition of a leak.
an empirical corollary to this is that the quality of the reports plateaus quickly so that whd bicaptures the majority of true positives for a small dandb.
as a result the default con guration for our tool is d andb which1public integer getfirst file in throws ioexceptionf fileinputstream s new fileinputstream in integer ret null tryf intval s.read ret new integer val 7gcatch ioexception e fg s.close return ret 10g figure ignoring fatal exceptions yields nearly as high a proportion of witnessed and hence highly ranked true positives as would a slower con guration that uses larger limits.
.
exception flow many resource leaks found in real programs occur along exceptional paths.
the program in fig.
for example may leak the le output stream if the constructor of the stream writer throws an unsupportedencodingexception .
but not all exceptional paths are interesting or likely to be exercised and a leakage analysis that processes all exceptional edges would generate a large number of reports with little practical value sec.
.
.
to illustrate consider the program in fig.
.
the program is for all practical purposes free of leaks.
it closes the allocated le input stream along all normal paths and any ioexception that may be thrown by the call to read is caught and ignored.
nonetheless an analysis that processes allexceptional edges would generate a leak report for this program because s.close would not be executed if the allocation of the integer object on line failed due to an outofmemoryerror .
such a report is not very useful however.
most programs are not expected to recover from an outofmemoryerror and once the program fails all system resources are automatically released.
our analysis processes exceptional edges selectively.
in particular we only process the edges associated with relevant exception types.
the de nition of what is relevant is customizable but is guided by a belief based heuristic that considers an exception irrelevant unless there is evidence to the contrary.
in our implementation relevant exception types for a method minclude all types esuch that mexplicitly throws an instance of evia a throw statement mexplicitly catches an instance of ein a catch block or eappears in the throws clause ofm s signature.
the set of relevant exception types for a program is simply the union of the relevant exception types for each of the methods in its call graph.
.
nested resources it is commonplace in java to have classes that encapsulate or wrap a resource in one of their elds.
in printwriter and outputstreamwriter both of which we used in fig.
the contract says that the output stream passed as an argument to the constructor is closed when close is called on the encapsulating instance.
the following code snippet is therefore free of leaks even though fos.close is not called directly fileoutputstream fos new fileoutputstream le outputstreamwriter osw new outputstreamwriter fos ... osw.close unlike leaks of system resources wrapper leaks are often benign.
if a wrapper is encapsulating a memory resource such as as a bytearrayoutputstream then a failure to close the wrapper is uninteresting as it will be handled by the garbage collector.
the same is true if a wrapper encapsulates a system resource that is released independently as shown below fileoutputstream fos new fileoutputstream le outputstreamwriter osw new outputstreamwriter fos enc ... fos.close but not all wrapper leaks are uninteresting.
if a wrapped system resource is leaking and the handle to the resource is inaccessible as in fig.
then only way to actually x the underlying leak is by releasing the wrapper.
we therefore report leaks on wrappers which encapsulate leaking system resources.
since these reports are not independent we clusterthem so that all wrapper leaks pertaining to the same underlying resource are in the same cluster.
for example the leaks on the fileoutputstream outputstreamwriter and printwriter resources in fig.
form a single report cluster.
we cluster reports by post processing the output of the standard inter procedural algorithm.
initially wrapper types seed the analysis just like real resources.
once the analysis terminates potentially leaking instances are organized into a forest of directed acyclic graphs.
the roots of these graphs represent real resources and edges lead from wrapped to wrapper instances.
an edge is created between instances p andqifq fis a must alias of p andfis a eld that holds a wrapped object.
the determination of which elds hold nested resources is a matter or speci cation.
each disconnected portion of this forerst is presented as a cluster.
.
implementation we implemented the techniques presented here in a tool called tracker which is based on the wala program analysis framework.
tracker analysis is performed in three stages.
first the tool computes the call graph of the program to be analyzed.
because many of the standard call graph construction algorithms e.g.
cfa neither scale to large applications nor work well for partial programs we base our call graphs directly on the program s class hierarchy using type information to determine targets of virtual dispatches.
for e ciency the computed call graph includes only a necessary subset of the program s methods.
in particular a given method mis included only if it contains a resource allocation instruction or it transitively calls a method that contains such an instruction.
each included method must also be reachable from a public entry point i.e.
a public method of a public class .
after it has constructed the call graph tracker performs the core resource tracking analysis sec.
which generates a set of witnessed and assumed leak reports sec.
.
.
the nal stage of the analysis involves clustering and ltering sec.
.
of these reports for improved actionability.
.
empirical evaluation to evaluate tracker we conducted a series of experiments on the ve open source programs listed in table .
these include a build tool ant .
an image manipulation toolkit batik .
a reporting system for web applications birt .
a peer to peer bit torrent client frostwire .
and a web server tomcat .
.
the table shows the size of each benchmark given as the number of classes and methods.
also shown are the number of resource allocation sites in each program and the size of its call graph.
the latter is measured by the number of included methods the number of classes containing those methods and the time taken to compute the graph.
we conducted four experiments on the candidate programs.
the rst three experiments were designed to evaluate the e ectiveness of our ranking heuristic exceptionltering mechanism and clustering techniques.
the fourth compares tracker tofindbugs .
unless stated otherwise tracker was con gured to lter exceptions cluster all reports lter non actionable wrapper reports and to track at most access path of length or less per resource.
tracking facts larger than h10 10idid not change the output of the tool for any of the subject programs.
we refer to this con guration of the tool as the baseline con guration or base .
report counts shown in the tables and graphs refer to the number of report clusters unless otherwise speci ed.
the same set of resource acquire release speci cations was used for each experiment the stream resources in the java.io package and the database resources in the java.sql package.
all experiments were performed on .
ghz intel core duo machine with gb of memory.
program size resourcescall graph sizeclassesmethodssystemwrapperclassesmethodssecant .
99018batik .
36524birt .
802304frostwire .
85664tomcat .
table benchmark statistics.
.
report prioritization and actionability goals and methods.
to assess the e ectiveness of our ranking heuristic we con gured the base tracker with ve di erent limits on the size of tracked facts and used it to compute ve corresponding sets of reports for each benchmark.
the ve limits include the base limit h10 10iand four stricter limits h1 3i h3 3i h3 5i andh5 5i.
we manually classi ed the base report sets into true positives tp and false positives fp .
this classi cation was then used to automatically classify the remaining report sets taking advantage of the fact that tracker s output is sound so it always includes all true positives and monotonic so it includes fewer false positives as limits on fact size are increased .
results.
the results are presented in fig.
.
we show one chart per benchmark each with one bar per report set.
the height of a bar indicates the total number of reports in the given report set.
the height of the shaded regions within a bar indicates the number of witnessed true posi tives black assumed true positives white pattern on black background witnessed false positives white and assumed false positives black pattern on white background .
for example theh3 5ireport set for ant includes a total of reports which consist of true positives witnessed and assumed and false positives witnessed and assumed .
the graph on the bottom right shows the time in seconds taken to compute each report set after the call graph has been constructed.
discussion.
the data shown in fig.
reveals three key trends.
first due to the soundness and monotonicity of tracker the total number of true positives for each benchmark remains constant and the number of false positives decreases monotonically as limits on fact size are relaxed.
in practice this means that the user of the tool can easily control the trade o between resource consumption and report quality.
second for most limits on fact size true positives comprise a much higher proportion of witnessed reports than of assumed reports jwhd bi tpj whd bi jahd bi tpj ahd bi.
in other words witnessed reports which are ranked as high priority by tracker have a higher probability of being true positives than the lower ranked assumed reports.
third the number of witnessed true positives obtained with the default limit ofh3 5ion fact size captures the majority of the witnessed true positives obtained with more generous limits.
the tool s default con guration therefore o ers a good trade o between performance and quality for a wide range of applications.
.
exception flow filtering goals and methods.
to evaluate the e ect of exception ltering on report quality we applied two con gurations of tracker to all ve benchmarks the baseline con guration that lters exceptional edges as described in sec.
.
and a variant con guration that processes all edges indiscriminately.
reports generated by the variant but not the baseline were manually classi ed into true and false positives.
results.
table summarizes our ndings.
for each benchmark we show the total number of new true and false positives as well as the fraction of the new results with respect to the baseline output.
for example applying the variant con guration of tracker toant yielded new reports only two of which were true positives.
this comprises four percent of the true positives found by the baseline con guration.
discussion.
overall we found that exception ltering signi cantly improves the quality of tracker s results.
disabling the lter introduced a large percentage of false positives and only a negligible fraction of true positives in all but one benchmark where it had no e ect.
most of the additional false positives were due to low likelihood exceptional edges within try catch nally blocks.
the additional true positives were all due to exceptions that our lter deems irrelevant but that we thought likely to occur in practice.
.
report clustering and wrappers goals and methods.
to measure the e ects of report clustering and of distinguishing between system resources and wrappers we compared the output of our baseline conguration to that of the all real con guration.
the latter unlike base treats wrappers as real system resources.
the comparison of the two con gurations involved simply counting the number of report clusters and the number of !
!
!
!
!
tomcat .
!
!
!
!
!
frostwire .
!
!
!
!
!
birt .
!
!
!
!
!
batik .
!
!
!
!
!
ant .
w tpa tpw fpa fp015304560 !
!
!
!
!
analysis time sec vs. fact size antbatikbirtfrostwiretomcatfigure performance and quality of reports for a sampling of fact sizes.
individual reports in each result set.
we did not classify the leaks reported by all real but not by base since we consider all reports on wrappers that do not transitively wrap a real resource to be non actionable.
results.
figure presents the results.
the chart shows the number of clusters and the number of individual reports both base andall real for each benchmark.
for example base generated a total of individual reports for ant which were grouped in clusters.
the all real con guration on the other hand produced individual reports and clusters.
discussion.
comparing the output of base andallreal we nd that on average all real generates twice as many reports and clusters as base .
none of the additional reports are in our view actionable.
we therefore believe that a practical resource leakage analysis must distinguish between system resources and wrappers.
for both base and all real clustering decreases the number of distinct leaks that the user needs to examine by to percent.
in our experience clustering was particularly helpful for triaging complex inter procedural leaks that involve a single system resource and several di erent wrappers.tpfptp base tpfp base fpant .
.
.45batik .
.
.00birt .
.
.50frostwire .
.
.56tomcat .
.
.58table e ects of exception ow ltering.
ant .7batik .6birt .5frostwire .17tomcat .0base clustersbase reportsall real clustersall real reports figure e ects of report clustering on the output of the base and all real con gurations of the analysis.
.
comparison with related techniques goals methods and results.
to evaluate tracker against an existing widely used tool we applied findbugs to our ve subject programs classi ed the output into true and false positives and then compared the resulting classi ed reports to those of tracker base .
the results are presented in table .
for each benchmark and each class of leaks we show the number of reports that were found by both tools as well as the reports found by only one of the tools.
for example in ant tracker found true positives not found by findbugs while all true positives reported byfindbugs were also reported by tracker .
discussion.
overall tracker found signi cantly more true positives than findbugs .
we believe this is because findbugs relies on heuristics to report only the most compelling defects that it could reason about intra procedurally.
findbugs reported fewer false positives but the great majority of tracker s false positives were the low ranked assumed reports.
the few true positives that were detected byfindbugs but not by our tool were all due to engineering choices rather than fundamental limitations.
for example thefrostwire true positives missed by tracker are located in classes that were not analyzed because of the way we determine the scope of a program s class hierarchy.
.
related work our work has targeted problems relating to leaks of system resources such as sockets and le descriptors.
much related work targets memory leaks either with explicit memory management e.g.
malloc free or garbage collection.
whether considering memory leaks or system resource leaks a static analysis must reason about a liveness property for true positivesfalse positivesfbtrbothfbtrbothant .704684290batik .6126111852birt .5897538166frostwire .173615190tomcat .0263114120table comparison of tracker and ndbugs.
objects in certain states in the presence of potentially complex aliasing.
much previous work has considered type systems for regionbased memory management e.g.
whereby a type system prevents memory leaks and enables an implementation of e cient storage reclamation.
alternatively approaches based on escape analysis e.g.
typically employ sophisticated modular alias analysis to identify potential sources of leaks.
other relevant tools with analysis for object liveness and memory leaks include free me clouseau and uno .
qualitatively bug nding for system resource leaks has a di erent avor from addressing general memory leaks.
first system resource management usually involves a small subset of a large program whereas nearly every operation in an object oriented language involves dynamically allocated memory.
second in a bug nding tool it is reasonable to suppress ndings to avoid false positives whereas many applications in system memory management need conservative analysis.
.
analysis tools weimer and necula studied system resource leak problems in java programs due to incorrect exception handling.
this work presents a simple path sensitive intraprocedural static analysis to nd resource leak bugs.
weimer and necula s analysis is unsound nevertheless they report that the analysis still nds hundreds of problems with open source java programs.
in contrast to our work weimer and necula s analysis does not consider aliasing inter procedural paths or nested resources.
static analysis of resource leaks relies on analysis of a dynamic location liveness property as de ned by shaham et al.
.
shaham et al.
presented a conservative static analysis based on canonical abstraction to verify safety of synthesized free operations for dynamically allocated objects.
a similar analysis could be used to insert dispose operations to prevent resource leaks.
charem and rugina describe a similar approach with a less expensive analysis.
the closer performs a modular ow sensitive analysis to determine live system resources at each program point.
in contrast to these approaches tracker neither proposes nor checks safety of remediation at particular program points and it relies on signi cantly less expensive alias abstractions.
our analysis tracks a heap abstraction based on k limited access paths using ow sensitive context sensitive interprocedural analysis.
access path alias analysis has been used in many previous works including .
tools based dynamic instrumentation can detect resource leaks by checking that the appropriate disposal methods are called when an object is reclaimed.
the qvm takes thisapproach engineering a virtual machine where the garbage collector cooperates to allow dynamic instrumentation to detect object reclamation events.
on the other hand approaches based on bytecode instrumentation or aspects e.g.
better suit safety properties than these liveness properties without cooperation from the garbage collector to detect object death.
.
languages and type systems java s nalizers provide a language construct designed to help the programmer free resources.
section of reviews problems with destructors and nalizers in practice.
java s nalizers are particularly problematic for dealing with nite resources since the garbage collector provides no guarantees for timely nalizer execution.
many languages provide constructs to associate a resource with a lexical scope and ensure that the resource is closed when the scope nishes.
for example c provides a using statement to guarantee timely disposal of resources at the end of a lexical scope .
in our experience many of the resource leaks tracker found in java code could be eliminated if a similar lexical construct were available.
however these solutions do not apply to code that caches resource pointers in a heap untied to a convenient lexical scope.
weimer and necula propose a language construct for java called compensation stacks .
a compensation stack associates each logical resource allocation with a scope and guarantees that a clean up action a closure executes when the program exits the scope.
the scope can be tied to a lexical boundary such as a method or manipulated as a rstclass object to support more general control structures.
the vault programming language provides a type system which can rule out certain types of resource leaks.
the vault type system allows the programmer to specify function postconditions that ensure functions cannot allocate and leak resources.
.
conclusion and future work we presented a static analysis tool that reports resource leakage defects in java applications.
there are many engineering challenges in building such a tool including the generic problems of scalability and precision as well as the speci c problems of dealing with exceptions and wrappers.
our contribution is in overcoming these challenges using a blend of existing and new techniques.
an empirical evaluation of the tool showed its overall e ectiveness as well as the importance of the techniques we discussed in the paper.
several directions for future work have presented themselves.
one is the problem of discovering speci cations automatically especially with regards to identifying which pairs of types are related by a wrapper wrappee relationship.
another promising direction is to extend the leak detection algorithm to automatically suggest code refactorings.
acknowledgement.
we are indebted to stephen fink for providing valuable comments on the paper as well as for helping us with the findbugs experiments.
.