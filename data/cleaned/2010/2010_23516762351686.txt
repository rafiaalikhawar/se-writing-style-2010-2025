diagnosys automati c generation of a debugging interface t o the linux kernel tegawend f.bissyand laurentr veill re universityofbordeaux france bissyande reveillere labri.frjulial.lawall gillesmuller inria lip6 regal fran ce julia.lawall gilles.mul ler lip6.fr abstract thelinuxkerneldoes notexportastable we ll definedkernel interface complica ting the development of kernel level services suchasdevice driversandfilesystems .
whilethere does exist a set of fun ctions that are export ed to external modules this set of fu nctions frequently cha nges and the functions have implici t ill documented prec onditions.
no specificdebuggingsup portisprovided.
wepresentdiagnosys anapproachtoautom aticallyconstructingadebugging interfaceforthelinux kernel.
first a designated kernel m aintainer uses diagnos ys to identify constraintsontheuse oftheexportedfunctio ns.
basedon thisinformation devel opersofkernelservices canthenuse diagnosys to generate a debugging interface specialized to theircode.
whenaser viceincludingthisinte rfaceistested itrecordsinformationa boutpotentialproblem s. thisinformation is preserved fo llowing a kernel crash or hang.
our experiments show tha t the generated debug ging interface providesusefulloginfo rmationandincursalo wperformance penalty.
categoriesandsubject descriptors d. .
testinganddebugg ing debugging aids d. .
reliability generalterms design experimentati on reliability keywords diagnosys debugging wrappers linux devi cedrivers .
introduction debugging is difficult.
and debugging an ope rating systemkernel levelservice suchasadevicedrive r filesystem or network protocol i s even more difficult.
when a crash occurs theservicedev eloperispresentedwit habacktrace permission to make digi tal or hard copies of all or part of this work for personal or classroom us e is granted without fee provided that copies are not made or distributed fo r profit or commercial ad vantage and that copies bearthisnoticeandthe fu llcitationonthefirstpag e. tocopyotherwise to republish topostonserve rsortoredistributetolist s requirespriorspecific permission and or a fee.
ase september essen germany copyright acm ... .
.containing the location of the instruction that caused the crash and the pending return pointers on the stack.
this information may be u nreliable or incomplet e. even when the backtrace informa tion is present and co rrect it does notcapturecontextin formationsuchasthe valuesoflocal variablesandtheeffect ofrecentdecisionsthat areoftenessentialtoidentifythe problem.
indeed kern elservicecode containsmanyexecuti onpaths takingcondi tionsfromthe operatingenvironment intoaccount andisdi fficulttotest deterministically.
supp ortisneededforprovi dingmoreinformation at the time of the crash without introducing a substantial performanc e penalty or imposing an additional burdenonthedevelop er.
aslinuxisbecomingm oreandmorewidelyus ed inplatforms ranging from em bedded systems to sup ercomputers there is an increasing interest from third par ty developers havinglittleexpertise inlinuxinternals ind evelopingnew linuxkernelservices.
suchservicesmustinte gratewiththe linux kernel via the v arious kernel level api s. developing code at this level is a challenging task.
inde ed the linux kerneldevelopmentpro cessisbasedontheass umptionthat thesourcecodeofallk ernel levelservicesisav ailablewithin the publicly available kernel source tree an d thus kernel apisare forefficiency onlyasrobustasreq uiredbytheir internalclientservices .
furthermore kernel developerscan freelyadjustthekerne lapis aslongasthey arewillingto updatealloftheaffecte dservicecode.
theker nelimplementationisthus bydesig n maximallyefficient andevolvable enablingittorapidly meetnewperformance requirements address security issues and accommodate ne w functionalities.
but these assump tions complicate the ta sk of the developers of new servic es who require more s afety and help indebugging.
advance sinbug findingtools specializedtestingtechniq ues andcodeg enerationfrom specifications have easedbutnotyetfully solvedthese difficulties.
currentap proachesputsubstanti aldemandson thedeveloper bothto learnhowtousetheap proachandto effectivelyintegrateit intohisdevelopmentp rocess.
we concretize the diffi culty confronting a li nux service developerininteractin gwiththelinuxkerne lasthenotion of asafety hole.
we define a safety h ole as a fragment of code that introduces t he potential for a fau lt to occur in theinteractionbetween akernel levelservicean dtherestof the kernel.
for examp le code in the definiti on of a kernel apifunctionthatdere ferencesaparameterw ithouttesting its value represents a safety hole because a service could invoke the function w ithnullas the corresponding argument.
likewise code in the definition of a k ernel internalpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
api function that ret urnsnullas the result represen ts a safetyhole becausea callingservicecouldd ereferencethis resultwithoutchecking itsvalue.
toaddresstheproblem ofsafetyholesinlinux kernelinternalapifunctions w eproposeanapproach nameddiagnosys thatautomaticallyge neratesadebuggingint erfaceto thelinuxkerneltailore dforaparticularkerne l levelservice under development ba sed on a prior static a nalysis of the linuxkernelsourcecod e. thisdebugginginter faceamounts toawrapperontheke rnelexportedfunctions thatlogsinformation about poten tially dangerous uses of these functions.
localizingthein terfaceinthisway at theboundary oftheinteractionbetw eentheserviceandthe oskernel ensuresthatthefeedback providedbytheinterfa ceisinterms ofthecodethatthed eveloperhaswritten a ndisthusexpected to be familiar with.
because the int erface is only visibletotheservice i thasnoimpactonth eperformance ofcodewithinthekern el evencodethatuses functionsthat contain safety holes.
w hen the service execut es the interfacegenerateslogmess ageswheneverservicec odeinvokesa kernelapifunctionco ntainingasafetyholei napotentially risky way.
such a deb ugging interface requir es no manual interventionfromthes ervicedeveloperuntilt hereisacrash orhang andisthuswe ll suitedtointensivese rvicedevelopment whenthedevelo perismodifyingtheco defrequently and bugs are likewise frequent.
because the debugging interfaceisautomatically generated itcanbere generatedfor each new version of th e linux kernel as the properties of thekernelapischange .
diagnosysiscomposed oftwotools shana s afetyhole analyzer whichstati callyanalyzesthekern elsourcecode to identify safety hole s in the definitions of the kernel exportedfunctions and digen debuggingint erfacegenerator whichusesthein formationabouttheid entifiedsafety holestoconstructade bugginginterfacetailo redtoagiven service.
diagnosysalso includesaruntimesyst em provided as a kernel patch.
sh ana is run by a linux kernel maintaineronceforeachli nuxversion totakein toaccountthe current definitions of the linux kernel inter nal api functions.
digen is run b y a service developer as part of the service compilation pr ocess.
during the exe cution of the resulting service the d ebugging interface use s the runtime system to log informa tion in a crash resilien t buffer about any unsafe uses of fun ctions containing safet y holes.
on a kernelcrashorhang th eservicedevelopercan subsequently consultthebuffertoo btaintheloggedinform ation.
themaincontribution softhispaperareasf ollows weidentifytheinterf aceofkernelexported functions asasweetspotatwhic hitispossibletointer posethe generation of debuggi ng information in a way that improvesdebuggability butdoesnotintroduce anexcessiveruntimeoverhe ad.
weidentifysafetyhol esasasignificantprob leminthe interface between a se rvice and the kernel.
indeed ofthe703linux2.6co mmitsforwhichthech angelog refersexplicitlytoafun ctionexportedinlinux .
.
corrected faults that are related to on e of our identifiedsafetyholes.
weproposeanapproa chtoallowaservicedev eloperto seamlesslygenerate in tegrate andexploitak erneldebugginginterfacespeci alizedtotheserviceco de.
thisapproach has a low le arning curve and in p articular doesnotrequireanypa rticularlinuxkernelex pertise.
using fault injection experiments on lin ux kernel services we demonstra te the improvement in debuggability provided by o ur approach.
we find that in ofthecasesinwh ichacrashoccurs the logcontains information relev ant to the origin of th e defect and in of these c ases a message releva nt to the crashisthelastpiece ofloggedinformation.
wealso findthatin93 ofthe casesinwhichacrash orhang occurs theloginforma tionreducesthenumbe roffiles thathavetobeconsult edtofindthecauseof thebug.
weshowthatthegen erateddebugginginterf aceincurs onlyaminimalruntime overheadonserviceexe cution allowingittobeused upthroughearlydeplo yment.
the rest of this paper is organized as follows .
section illustrates problems in kernel development th at have been related to safety holes and gives an overview of kinds of safety holes that we ta ke into account.
sectio n discusses thechallengesinkerne ldebugging focusingo ncrashesand hangs derived from sa fety holes.
section presents diagnosys includingthepr ocessofcollectinginfor mationabout theoccurrencesofsafe tyholesandtheassoci atedpreconditions and the process of generating a debugg ing interface.
section evaluates ou r approach.
finally s ection discussesrelatedwork an dsection7concludes.
.
safetyholes to understand the cha llenges posed by safet y holes we firstconsidersometyp icalexamplesinlinux kernelinternal api functions and the problems that these ex amples have caused as reflected by linux patches.
then we present amethodologyforiden tifyingkindsofsafety holes anduse thismethodologytoen umeratethekindsofsa fetyholesconsidered in the rest of the paper.
finally we consider how tostaticallyidentifyp reconditionsontheses afetyholes to limitthegenerationof logmessagesinthedeb ugginginterfacetocasesthatmay actuallycauseacrash orhang.
.
examplesofsafety holes becausethelinuxkern eldoesnotdefineapre ciseinternal api we focus on the set of functions that a re made available to dynamically lo adable kernel modules using either export symbolorexport symbol gpl.
dynamically loadablekernelmodulespr ovideaconvenientmea nstodevelop newservices astheya llowtheservicetobelo adedintoand removed from a runni ng kernel for the testi ng of new service versions.
we refe r to kernel functions t hat are made availabletosuchmodu lesaskernel exported functio ns.
fig.
1a shows an exce rpt of the definition o f the kernel exported functionskb put which dereferences it s first argumentwithoutfirstc heckingitsvalue.
man ykernelfunctionsarewritteninthis way assumingthatalla rgumentsare valid.
thiscoderepres entsasafetyhole beca usethedereferenceisinvalidifthec orrespondingargument isnull.such afaultoccurredinlinu x2.
.18inthefiledrivers net forcedepth.c.
inthefunctionnv loopback test skb putiscalled withitsskbargumentbeingtheres ultofcallingdev alloc skb which can benull.
the fix as impleme nted by the patch shown in fig.
1b is to avoid callingskb putin this case.skb putremainsunchanged.611unsigned char skb put structsk buff skb unsigned intlen unsigned char tmp skb tailpointer skb skb linear assert skb skb tail len ... a excerpt of the defin ition ofskb put 1commit 46798c897e 235e71e1e9c46a5e6e9 adfffd8b85d tx skb dev allocskb pktlen if !tx skb ...gotoout pkt data skb put txskb pktlen b excerpt of the bug fix patch figure bug fix of the usage ofskb put fig.
2a shows an exce rpt of the definition o f the kernel exported functionopen bdev exclusive which returns a valueconstructedusing thekernelfunctionerr ptrwhenan errorisdetected.
dere ferencingsuchavalue willcrashthe kernel.
thus thisretu rnstatementalsorepre sentsasafety hole.
inlinux2.
.
i nthefilefs btrfs volumes.c thefunctionbtrfs init new devi cecalledopen bdev exclusive and compared the res ult tonullbefore dereferencing the value.
thistest howe ver doesnotpreventa kernelcrash because anerr ptrvalue is different fromnull.
fig.
2b showsapatchfixingth efault.
1structblock device open bdevexclusive constchar path fmode t mode void holder ... 5returnerr ptr error a excerpt of the defin ition ofopen bdev exclusive 1commit 7f59203abe af18bf3497b308891f9 5a4489810ad bdev open bdevexclusive ... if !bdev return eio if is err bdev returnptr err bdev b excerpt of the bug fix patch figure bug fix of error handling code in the previous cases the safety hole is appa rent in the definitionofakernelex portedfunction.
asafe tyhole however may also be inte rprocedural making th e danger that it poses more difficult to spot.
for example as shown in fig.
a b the kernel exported functionkmap defined in arch x86 mm highmem .c passesitsargumentto thefunctionpage zonevia the macropagehighmem which in turn forwardsthepointer a gainwithoutensuring itsvalidity to thefunctionpage to nid.
thisfunctionthend ereferences it unchecked.
thissaf etyholeresultedinafa ult whichwas fixedbythepatchshow ninfig.3c.
1void kmap structpage page might sleep 3if !pagehighmem pag e ... a excerpt ofkmap1staticinlineintpage tonid structpage page 3return page flags ... nodes mask b excerpt ofpage to nid 1commit 649f1ee6c7 05aab644035a7998d7b 574193a598a page read mapping page ... if is err page ...gotoout pptr kmap page c excerpt of the bug fix patch figure bug fix of a use ofkmap2.
taxonomyofsafet yholes asillustratedinsectio n2.
somefragments ofcodeexecutedbykernelexport edfunctions whilethe mselvesbeing correct canprovokeke rnelcrashesorhangsw henthefunctionisusedincorrectly.
wedistinguishbetweenentrysafety holes inwhichthecra shorhangisprovoked withintheexecution of the kernel e xported function due to an invalid argument provided by the service andexitsafety holes in whichthecrashorhan gisprovokedwithinth esubsequent execution of the servic e due to a possible eff ect of the kernel exported function that the service has n ot taken into account.
asafirstsourceofkin dsofsafetyholes wec onsiderthe faultkindsidentifiedb ychouet al.intheir2001studyo f linuxcode .
afault isnotinitselfasafety hole because thefaultycodecanbe completelycontainedw ithinasingle functiondefinition.
lik ewise asafetyholeis notinitselfa fault asillustratedby theaboveexamples.
n onetheless we observethatmanyfaul tkindsinvolvemultipl edisjointcode fragments.
whensom eofthesefragmentsa representina kernelexportedfunctio nandtheremainderm aybepresent inaserviceimplementa tion wesaythattheke rnelexported functioncontainsasafe tyhole.
forexample anullpointer dereferencefaulttypica llyinvolvesaninitializa tionofavariabletonullfollowedbyaderefere nceofthisvariable.
r eturningnullfrom a kernel exporte d function can cause i t tobedereferencedins ervicecode andreceiv ingnullasan argument in a kernel e xported function can l ead to anull pointerdereferencein thekernelexportedfun ctioncode.
theseobservationssug gestamethodologyfor translating faultkindsintokinds ofsafetyholes.
when thesuffixofa sequence of code fragm ents associated with a fault kind is foundinakernelexpor tedfunctionanddepen dsinsomeway onthecallingcontext e.g.
viaargumentsofthat function then that suffix repres ents an entry safety h ole.
likewise whenaprefixofsucha sequenceisfoundinak ernelexported functionandhassome impactonthefunction sresult then thatprefixrepresentsa nexitsafetyhole.
table1summarizesth efaultkindsidentified bychouet al.
as well as the entry and exit safety hole ki nds that we havederivedfromthes efaultkindsaccording totheabove methodology.
forexam ple giventheabovean alysisofthe structureofanullfaul t thecorrespondingen trysafetyhole isadereferenceofanun checkedpointerparame ter whilethe correspondingexitsafe tyholeisareturnofanullvalue.
.
safetyholeprecon ditions from a collection of s afety holes our goal is to create adebugginginterface thatinformstheservic edeveloperof possiblydangeroususe sofkernelexportedfu nctionswithin his code.
nevertheless merely invoking a ke rnel exported functionthatcontains anentryorexitsafety holedoesnot necessarily cause a fau lt. instead some pro perties of the argument or return va lues such as the prese nce of anull value must typically b e satisfied.
thus we require informationnotjustabout safetyholes butalsoa boutthepreconditionsthatmustb esatisfiedtoensureth atnofaultcan occur .
wefurtherm oredistinguishbetween safetyholes that arecertain if violation of the pr econdition is guaranteed to result in a cra sh or hang within the execution of thekernelexportedfu nction orpossible ifviolationofthe preconditionmaycaus eacrashorhangonat leastonepos 62table categoriza tion of common fau lts in linux .
ef refers to theexported function.
category actions to avoid faults safety hole safety hole descript ion analysis type blocktoavoiddeadlock do notcallblockingfunct ionsentryefcallsablo ckingfunction functio nreferencinggfp kernel interproc edural withinterruptsdisable doraspinlockheldexitefre turnsafterdisablingin terruptsorwhileholdi ngalock intra inter procedural nullcheckpotentiallynul l errptrpointersentryefd ereferencesanargumen twithoutcheckingits validity interprocedu ral returnedfromroutines exit efreturnsanull e rrptrpointer interpro cedural vardonotallocatelarges tackvariables 1k entryef allocatesanarraywho sesizedependonapa rameter intraprocedu ral onthefixed sizekerne lstack exit efreturnsalargevalu e interprocedural inulldonotmakeinconsist entassumptionsaboutentryefd ereferencesanargumen twithoutcheckingits validity interprocedu ral whetherapointerisn ull errptrexit efreturnsanull e rrptrpointer interpro cedural rangealwayscheckboundso farrayindicesentr yefuse sanuncheckedparame tertocomputeanarra yindex intraprocedu ral andloopboundsderiv edfromuserdataexit efreturnsavalueobt ainedfromuserlevel interprocedural lock released acquiredlocks donot double acquirelocksentry efacquiresalockder ivedfromaparameter interprocedural exit efreturnswithoutrel easinganacquiredlock interprocedural intr restored isabledinterruptsentry efcallsablockingfun ction interprocedural exit efreturnswithinterr uptsdisabled intrapr ocedural free donotus efreedmemoryentry efdereferencesapoin ter typedparameterva lue none exit effreesmemoryderiv edfromaparameter interprocedural float donotus efloatingpointinthe kernel these fault kinds depen ds on local properties a nd are thereforenone realdonotleakmemoryb yupdatingpointers not relevant to the inte rface between a servicenone withpotentiallynull reallocreturnvalues and the kernel exported functions param donotde referenceuserpointersentry efdereferencesapoin ter typedparameter none exitef returnsapointer typed valueobtainedfromus erlevel interprocedu ral sizeallocateenoughmemo rytoholdtheentr yef allocatesmemoryofa sizedependingonapa rameter intraprocedu ral typeforwhichyouare allocatinge xit efreturnsaninteger value none sible execution path.
all exit safety holes a repossible as theusagecontextofth efunctionresultisunk nown.
.
kerneldebugg ing each of the examples presented in section could crash thekernel.
whenthis occurs thekernelgene ratesanoops report consisting of t he reason for the cras h the values ofsomeregistersanda backtrace listingthef unctioncalls pendingonthestack.
usingthisinformation indebugging raisestwoissues th ereliabilityoftheprov idedinformation and2 therelevan ceoftheprovidedinfor mationtothe actualfault.
debuggin gkernelhangsraisesfu rtherissues.
reliabilityofkerneloops reports.
linuxkernelbacktrace s suffer from the proble m ofstale pointers i.e.
addresses within functions that have actually already returned.
to illustrate this problem we consider a crash occurring in the functionbtrfs init new devi cepreviously shown in fig.
.
thecrashoccur redbecausethekernele xportedfunctionopen bdev exclusivereturnsanerr ptrvalueincase ofanerror whilebtrfs init new devi ceexpectsthatthe valuewillbenull.thiscausedasubsequ entinvalidpointer dereference.
to replay the crash w e installed a version o f thebtrfs module from just befo re the application of t he patch.
to causeopen bdev exclusivetofailwefirstcreatean dmount abtrfsvolume and then atte mpt to add to this vol ume a newdevicethatisnoty etcreated.
thisoperat ionishandled bythebtrfs ioctl add devioctlwhichcallsbtrfs init new devicewiththedevicepatha sanargument.
thispa th valueisthenpassedtoopen bdev exclusivewhichfailsto locatethedeviceandre turnsanerr ptrvalue.
fig.4shows an extract of the resul ting oops report.
line shows that thecrashisduetoan attempttoaccessanin validmemory address.
line shows that the faulty operat ion occurred in the functionbtrfs init new devi cea priori during a calltobtrfs ioctl add dev line8 .
sourcefilesa ndline numberscanbeobtain edbyapplyingthestan darddebugger gdbtothecompiledmodu leandtothecompiled kernel.
bug unable to handle ke rnel paging request at ffff ffee ip btrfs initnewdevice 0xcf 0x5c5 pdpt 00000000007ee001 pde 00000000007ff067 oops ... eip is at btrfs initnewdevice 0xcf 0x5c5 ... process btrfs vol pid ... call trace ?btrfs ioctladddev 0x33 0x74 ?memdup user 0x38 0x70 ... figure oops re port following abtrfs err ptr pointer dereference crash.
this backtrace contain s possibly stale pointe rs as indicatedbythe?symbolonlines8and .
whilebtrfs ioctl add devreally does callbtrfs init new devi ce this is not the case ofmemdup user.
since it cannot be k nown a priori whether a funct ion annotated with?is really stale theservicedeveloperh astofindandstudyth edefinitionsof allofthefunctionsatt hetopofthebacktrace untilfinding the reason for the cra sh including the defin itions of functionsthatmaybecom pletelyunrelatedtoth eproblem.
a goal of the kernel deb ugger kdb 1which was merged int o the mainline in linux .
.
was to improv e the quality of backtraces.
nevert heless backtrace quali ty remains an issue.
relevance of kernel oops reports.
a kernel oops backtrace contains only th e instruction causing the crash and thesequenceoffunctio ncallsconsideredtobe onthestack.
the actual reason for a crash however may occur in previouslyexecutedcode thatisnotrepresented .
forthefault shown in fig.
the o ops report mentions a dereference of the variablebdevin the functionbtrfs init new devi ce but the real source of the problem is at the initialization ofbdev totheresultofcallin gopen bdev exclusive.
this rnel.org l 12963figure the steps in using diagnosys call has returned and thus no longer appears on the stack.
suchsituationsmaked ebuggingmoredifficult asthedevelopermustthoroughlyc onsultkernelandservi cesourcecode tolocalizeimportanti nitializationcodesites .
kernel hangs.
bydefault thelinux kernelgivesnofeedbackinthecaseofak ernelhang.
itcan how ever beconfigured to panic when it detects no progress over a certain period of time.
when the hang is due to an infinite loop thebacktraceresulting fromthepaniccanocc uranywhere within this loop the p oint of the panic may thus have no relationtotheactuals ourceoftheproblem.
.
diagnosys thegoalofdiagnosys istoimprovethequali tyoftheinformation available wh en a crash or hang oc curs and this crash or hang results from a safety hole in a kernel exportedfunction.
theu seofdiagnosysinvolve sthreephases identificati onofsafetyholesinke rnelexported functionsandinference oftheassociatedpreco nditions usingthestaticanalysis toolshana automa ticgeneration ofadebugginginterfac eusingdigenbasedo ntheinferred preconditions and3 t estingservicecodewit hthesupport of the debugging inter face.
the first phase is carried out only once by a kernel maintainer for each n ew version of the mainline linux ke rnel 3and the remaining ph ases are carriedoutbyeachser vicedeveloperwhowo uldliketouse diagnosys.
.
identifyingsafety holesandpreconditions shanafirstsearchesth ekernelcodeforoccurr encesofthe kindsofsafetyholeslis tedintable1 andthen computesthe preconditionsthatare requiredtoholdtoens urethatthese safetyholesdonotcau seakernelcrashorhan g. theanalysisfocusesonunsafeop erationsthatoccurinc odethatisin orisreachablefroman exportedfunction.
for eachsuchoccurrence abackwarda nalysisamountingtoa simpleversion ofhoarelogic pro ducestheweakestprec onditiontobe satisfiedonentrytoth efunction forentrysa fetyholes and onexitfromthefunctio n forexitsafetyholes suchthatthe safetyholewillnotcau seacrash.
shanaisim plementedusingthecoccinelleprog ramanalysistool w hichanalyzes all of the code regard less of the code s targ eted hardware platform makingitpo ssibletofindallsafety holesinasinglerun.
theresultof shanaisalistmappi ngeachkernel 3each linux distribut ion may add some sp ecific patches to the linux kernel.
these are u nlikely to affect the kernel api.
further more a service that should u ltimately be integrat ed into the mainline kernel must be developed a gainst the api supp orted by that kernel .exportedfunctioniden tifiedascontainingsafe tyholestothe associatedprecondition s. the analysis starts fr om the definition of a n exported function recognized a s one declared usingexport symbol orexport symbol gpl.table1indicatesfor eachcategory of safety hole whether intraprocedural interp rocedural or noanalysisisused.
in searchscenariosthato nlyrequireintraprocedural analysis the analyzer scans the definition of the exported function to identify code fragm ents that represent safety holes.
fo r example in searchin g for intr exit safetyholes shanaon lylooksforinterruptdi sablingoperationsinthekernelexpo rtedfunctionitself bec auseinterrupt stateflagsshouldnotb epassedfromonefunct iontoanother .
in the case of int erprocedural analysis shana starts from the definition of an exported function a nd iteratively analyzesallcalledfunc tions.4forexample insearch ingfor null entry safety holes shana searches thro ugh both the kernelexportedfunctio nitselfandallcalledf unctionsthat receiveaparameterof thekernelexportedfun ctionasanargumenttofinduncheck eddereferences.
shan afurthermore includesuncheckedder eferencesofvaluesthat somehowdependonthevalueofa nuncheckedparameter .
.
generatingandin tegratingadebugging interface basedontheresultsof shana digengenerat esadebugginginterfaceasacolle ctionofwrapperfunct ionsthataugment the definitions o f kernel exported func tions with the necessary checks and calls to logging primit ives to detect and record violations of safety hole precond itions.
ideally thekernelmaintainerw horunsshanawoulda lsogeneratea singledebugginginterf acefortheentirekerne lthatcouldbe used by all service dev elopers.
unfortunately many kernel sourcefilestargetspeci fichardwareplatforms andthushave mutually incompatible header file dependenci es making it impossibletocompilea singledebugginginterf acewrapping allofthekernelexport edfunctionsatonce.
a ccordingly we shift the interface gene ration process into the hands of the servicedeveloper who generatesaninterface specifictohis service.
because the f unctions invoked by a single service can necessarily be com piled together this ap proach avoids allcompilationdifficul ties whileproducinga debugginginterfacethatissufficient foranindividualservic e sneeds.
we nowdescribethegener ationofthedebugging interfaceand howitisintegratedint oaserviceunderdevel opment.
generating a debugging interface.
for each kernel exported function that i s used in the service and for which shanaidentifiedatlea stonesafetyhole dig engeneratesa wrapperfunction.
the generalstructureofsuc hawrapperis showninfigure6.
bas edontheargumentval ues thewrapperfirstcheckseache ntrysafety holeprecon dition line4 andthen iftheprecon ditionisnotsatisfied l ogsamessage indicating the violatio n. this message inclu des the safety hole category which s pecifies the kind of sa fety hole and whether the violation iscertainorpossible line as defined in section .
.
the wrapper then cal ls the original function.
if the origin al function has a retu rn value this valueisstoredinaloc alvariable ret andthenthepreconditionsonanyexit safetyholesarechecked basedonthis 4theanalysisstopsatf unctionpointers.641staticinline rtype debug kernel function ... rtype ret check precon ditions for entry saf ety holes 4if an entry safety hole precondition is violated diagnosys log ef id sh cat info e.g.
arg number invocation of the intended kernel function 7ret call to kernel functio n check precon ditions for exit safe ty holes 9if an exit safety hole precondition is violated diagnosys log ef id sh cat info e.g.
err ret type forward the return value 12return ret define kernel function debug kernel function figure6 wrappers tructureforanon v oidfunction information lines9 .
finally thereturnv alue ifany of theoriginalfunctionis returnedastheresult line12 .
integrating a debugging interface into a service.
the generated debugging i nterface is implemente d as a header filetobeincludedint heservicecode.
once compiledwith theinterfaceincluded theserviceusesthewra pperfunctions insteadofthecorrespo ndingkernelexported functions.
diagnosysprovidesan automatedscript dmake thatmanages the generation of a debugging interface.
this script compilestheorigin alservicecode ide ntifiesthekernel exported functions referenced by the resu lting object files generatesani nterfacededicatedtot hesefunctions and recompilesthe servicewiththeinterfa ceincluded.
.
runningservicec odewithdiagnosys tobeabletouseadia gnosys generateddebu gginginterface theservicedevelo permustuseaversion ofthelinux kernelprovidingsuppo rtforthediagnosysru ntimesystem.
thissupportisexpres sedasakernelpatch whichwehave implementedforlinux .
.
thatextendsth ekernelwith acrashresilientlogging system.
thepatchadd itionallyconfiguresthekerneltose ndallcrashesandhan gs linuxsoft and hard lockups to the kernel panic funct ion which the patch extends to rebo ot into a specialcrash kernelif diagnosys is activated o r to continue with a normal panic otherwise.
finally the diagnosysruntimesyst emincludesa toolthatcanberunfr omuserspacetoinstal lacopyofthe diagnosyskernelasac rashkernel initializeth ereservedlog buffer andactivatean ddeactivatelogging.
once the diagnosys lo gging system has been activated theservicedeveloperm aytesthiscodeasusua l. duringserviceexecution ifawra pperfunctiondetectsa safetyholefor which the precondition is violated the wrapp er logs informationaboutthesafet yholeinareservedar eaofmemory annotatedwithatime stampandincludingth ememoryaddressofthecallsite.
t hereservedareaofme moryismanaged through a ring b uffer that retains infor mation about onlythemostrecentv iolations.
on a kernel crash or hang the diagnosys r untime system uses a kexec bas ed mechanism to reboot into a new instance of the d iagnosys enabled kerne l. the kexecbasedmechanismperfo rmstherebootwithou treinitializing anyhardware includin gthememory thusens uringthatthe accumulateddiagnosy slogisstillavailable.
t heservicedevelopermaythenacces sthelogmessagesthro ughapseudo character device.
the messages are made av ailable in the orderinwhichtheyw eregenerated.
whena crashoccurs table diagnosys prototype code size diagnosyscomponent tool c odesize loc language kernelcodeanalyzer shana smpl ocaml wrappergeneratordmake digen s h ocaml loggingsystemuser space sh an sic kernel space ansiccodepatch the diagnosys runtime system also inserts the kernel stack traceintothediagnos yslogbeforerebooting .
.
implementation table gives the code sizes of the various pa rts of our prototype diagnosys im plementation.
the im plementation includes the shana a nalysis of linux kerne l digen and dmakefor generating and c ompiling wrappers for a given service andthepatch fortheruntimesystem .
.
evaluation in designing diagnosy s we have chosen to f ocus on the interfacebetweenthes ervicecodeandtheke rnel.
wefirst assessthenumberofs afetyholesinthisinte rfaceandtheir pastimpactonkernel robustness asevidence dbycommits tothelinuxkernel.
w ethenassessthediffic ultyofdebuggingkernelfaultsderiv edfromsafetyholes b ystudyingthe feedbackmadeavailab letotheservicedevelo peronacrash or hang without diag nosys namely the ker nel backtrace.
then we assess the co verage of diagnosys w ith respect to thepossiblecrashesan dhangsthataretrigge redbymisuse oftheinterfacebetween theservicecodeandth ekernel and showthatthediagnos yslogmessagesallowt heservicedevelopertofindthecaus eofacrashorhangmor erapidlythan whenrelyingonakern elbacktracealone.
fin ally weshow thatdiagnosysincursa sufficientlylowruntime overheadto beembeddedinaservi ce uptotheearlydepl oymentphase.
our experiments use c ode from linux .
.
which was releasedindecember2 .
thisversionisus edinthecurrent long term supp ort version of ubuntur .
in redhatenterpriselin ux6 inoraclelinux etc.
ourperformance experiments are carried out on a d ell .
ghz intelr coretm2 duo with .
gb of ram.
unless otherwiseindicated theos isrunningalinux2.
.
32kernelthat hasbeenmodifiedtos upportthediagnosys logginginfrastructure.
1mbisreser vedforthecrash resili entlogbuffer.
.
prevalenceandim pactofsafetyholes diagnosysisonlybenefi cialifshanaidentifies safetyholes infunctionsthatareu sedbyawiderangeof driversandif thesefunctionsarelike lytobeusedinaninc orrectway.
in this section we assess the number of safety h oles collected byshanaandthenstu dytheimpactthesesaf etyholeshave hadontherobustness ofthelinuxkernelitse lf.
in linux .
.
sha na reports safe ty holes in 505exportedfunctio ns.
table3summarize sforeachkind ofsafetyholethenumb eroffunctionsthatsh anaidentifies ascontainingatleast oneoccurrenceofthat kindofsafety hole.
inthelargestca tegory inull null abo ut94 ofthe reportedfunctionsperf ormunsafedereference sdirectly and forwardtheparam etervaluetootherfun ctionsthatunsafelyusethemwithno priorcheck.
around1 performunsafe dereferences on va riables whose validity are indirectly correlated to that of pointer parameters.
d efects due to65safetyholesinthelatte rtwocategoriesaremo redifficultfor theservicedevelopert oidentify.
table prevalence of safety holes in li nux .
.
safetyholenumberofexportedfu nctionscollectedinthe entrysub category exitsub category block inull null var lock intr lockintr free size range static analysis is neces sarily approximate as it does not havecompleteaccesst orun timevalues.
th ismayleadto falsepositives inwhich asafetyholeisreporte dthatinfact cannotleadtoacrash.
suchfalsepositivescan increasethe logging time and clutt er the log with irrelev ant messages.
nevertheless havingst udiedthecompleteset ofresultsfor linux .
.
we have found only false p ositives out ofthe22 940reported safetyholes.
405ofth esearedueto thepresenceofmultiple configuration specific definitionsof somefunctions.
shan aannotatessafetyhole sderivedfrom calls to such functions with the file in which the relevant function instance is de fined so that the serv ice developer canremovethosethat arenotrelevanttohis configuration.
of the call sit es across the entire ke rnel source codewhereexportedfu nctionsareused halfi nvokeafunctioncontaininganiden tifiedsafetyhole.
this suggeststhat the kernel exported fu nctions containing saf ety holes are likelytobeusefulton ewservices.
toassessthepastimpa ctoftheidentifiedsafet yholesover the course of the deve lopment of linux we have searched through the c ommits to linux .
5from .
.
to2.
.
.
toidentify thosewhosechangelog mentionsthe nameofatleastoneker nelfunctionexportedin linux2.
.
ignoringchangelogsin whichthefunctionnam eisusedasa commonword e.g.
sort panic etc.
.
linuxcommitsby convention make only a single logical change thus making theanalysisprecise.6703ofthesecommitsc ontainbugsdescribed in kernel chang elogs7that are related to the usage ofexportedfunctions.
267ofthem i.e.
arerelatedto thecategoriesofsafety holesthatweconsider inthispaper.
.
kerneldebugging withdiagnosys as discussed in sectio n kernel debugging is made difficultbyunreliablebac ktracesandbytheque stionablerelevance of the informa tion in crash reports.
to assess the qualitativebenefitsof diagnosys wehavere playedacrash andahangreportedin kernelcommitlogs.
replayingakernelcrash.
asanexampleofkerne lcrash we again consider thebtrfsexample of fig.
.
study of the corresponding cras h report in fig.
sho wed that the sourceoftheproblem wasnotreadilyavailab leinthebacktrace.
we have therefo re replayed the same e xecution scenario when using diag nosys.
a typical diag nosys log line contains the timestam p of the log the sourc e file and line number where the uns afe call was performed the name of the exported function the category of the sa fety hole and 5git git.kernel.org p ub scm linux kernel git torvalds linux.g it.
6documentation sub mittingpatches in th e linux kernel sourc e tree rg rg pub linux kernel v2.
possibly the name of a relevant argument or a n unsafe return value.
in the ca se of the replay of th ebtrfscrash fig.
.
shows the la st line added to the diagnosys log before the crash whi ch is the line that th e developer is likely to consult first.
this line shows that the function open bdev exclusiveactivatedaninullexit safetyholeby returninganerr ptr.italsoreportst heruntimetimestamp and the call site where the safety hole was violated.
combiningthisinform ationwiththeinforma tionaboutthe crash site in the oops report and the service source code shows that the proble m is the inadequate e rror handling codeafteropen bdev exclusive.
var diagnosys tests my btrfs volumes.c open bdevexclusive inull exited err ptr figure7 diagnosys loglineintheexecu tionofbtrfs replaying a kernel hang .kernel hangs are noto riously hardtodebug8asthepanic whichocc urslongaftertheactualfault canproduce abacktracethatishar dtocorrelate tothesourceofthepro blem.
diagnosysrecord sinformation aboutpreviouspotenti allydangerousoperatio ns.
just before the release of linux .
.
thenouveau drm nvidiar graphics card driver c ontained a hang resul ting from the use of the ke rnel exported functionttm bo wait.
thisfunctionexhibits alockentrysafetyho leandalock exitsafetyhole asitfir stunlocksandthenrel ocksalockreceivedviaitsfirstargu ment.
thenouveau drmdrivercalled thisfunctionwithouth oldingthislock hangin gthekernel.
in fig.
8a the last lin e of the diagnosys log shows that ttm bo waithasbeencalledwithou ttheexpectedlockheld .
correlating this inform ation with the source code suggests takingthelockbefore thecallandreleasingi tafterthecall asshowninthelinux patchinfig.8b.
var diagnosys tests nouveau nouveau gem.c ttm bowait lock acquire possible bo lock a diagnosys log line in the execution ofnouveau drm.
1commit f0fbe3eb5f 65fe5948219f4ceac68 f8a665b1fc6 spin lock nvbo bo.lock ret ttm bowait nvbo bo false false no wait spin unlock nvbo bo.lock b bug fix related to t he usage ofttm bo wait.
figure fault invo lving a lock safety hole in nouveau drm .
quantifyingthede buggingbenefit tobeuseful diagnosy smustcoverahighpe rcentageof the misuses of kernel exported functions.
w e first evaluatethisbyartificiallyc reatingandactivating misusesofexportedfunctionsinker nelservicesandmeasu ringhowmany aretrappedbydiagno sys.
additionally diag nosysmustbe able to produce log m essages that ease the d ebugging process.
we evaluate the debugging effort by m easuring the numberoffilesandfun ctionsthathavetobes tudiedtoidentifythecauseofacras h withandwithoutd iagnosys.
our experiments involve a number of commonly used kinds of services networkingco de usbdrivers multim ediadrivers and file systems.
serv ices of these kinds ma ke up over a rnal.com article 966third of the linux .
.
source code.
we h ave selected a rangeofservicesthatr unonourtesthardwa re .
table tested lin ux .
.
services category servic e module descriptionused functions with safety holes networkinge1000e ethernetadapter iwlagn intel wifinextgenagn btusb bl uetoothgenericdriver usb driversusb storage mass storagedevicedriver ftdisio usbt oserialconverter multimediauvcvideo webcamdevicedriver device driverssnd intel8x0 alsadriver file systemsisofs iso9660filesystem nfs networkfilesystem fuse fi lesysteminuserspace coverageofdiagnosys.
todeterminethecover ageofdiagnosys wefirstmutat eexistingservicessoas toartificially createbugs.
then wei njectfaultsatrun time topotentially causethemutationto triggeracrash.
sincethelargestperce ntageofouridentified safetyholes are related tonullanderr ptrdereferences we focus on thesesafetyholes.
one prominentsourceofsu chvaluesisas theresultofacalltoa functionthathasfailed inperforming somesortofallocation .
robustkernelcodec hecksforthese values and aborts the ongoing computation.
nevertheless omission of these tests is common.
for exam ple in linux .
.
evenforthesta ndardkernelmemorya llocationfunctionskmalloc kzalloc andkcalloc over of the calls thatmayfaildonotte sttheresultbeforeder eferencingthe returnedvalueorpassi ngittoanotherfuncti on.
based on these observ ations our experimen ts focus on missingnullanderr ptrtests in the service c ode.
our mutations remove such tests from the service code one by one andusethefailslabfeatureofthelinuxf aultinjectioninfrastructure withintheinitializatio nofthetested value to inject failures into the execution of any call to a basicmemoryallocatio nfunctionthatthisin itializationinvolves.
becausethein itializationcaninvoke basicmemory allocationfunctionsmu ltipletime asinglemu tationexperimentmayinvolvemul tipleinjectedfaults.
one possible result is that there is no obser vable effect.
this occurs when the called function does n ot involve a memoryallocation wh enthefailureofmemo ryallocations doesnotleadtoanullorerr ptrresult orwhenthesaf ety holeispossibleandisnotencountere dintheactualexecution.
anotherpossibili tyisthatthereisacr ash butthere isnorelevantinformat ioninthediagnosyslo g. inthiscase eithertheloginformat ionhasbeenoverwritte n shanahas notdetectedthesafety hole orthecalltoake rnelexported function occurs in a h eader file that for tech nical reasons hastobeincludedbefo rethediagnosyswrapp erdefinitions.
athirdpossibilityist hatthereisacrashan dtheinformationislogged represen tingasuccessfordiag nosys.
we have evaluated the coverage of diagnosys on the serviceslistedintable .
removingthenullanderr ptr tests one by one leads to mutated servic es.
for each mutated service we h ave exercised the vari ous execution paths of the affected module in order to ex ecute the mutated code.
the result s are shown in table .
of the mutations resulted in a kernel crash.
after r eboot in ofthecrashes thelog containedinformation relevanttothe crashoriginandin86 ofthecrashes alogwa spresentand itwasadditionallyint helastposition.
foron eservice thelatteronlyholdsfor66 ofthecrashes butth isamountsto onlyonemissinglog a sthisservicehasfewm utationsites.
table results of the mutation exper iments categorykernel module of mutations of crashes with coverage nologlogis notlastlogis last networkinge1000e iwlagn .
btusb .
usb driversusb storage ftdisio multimediasnd intel8x0 .
device driversuvcvideo .
file systemsisofs .
nfs .
fuse .
ease of the debugging p rocess.
provided with an oop s reportcontainingaba cktraceanddebugging toolsthatcan translate stack entries into file names and lin e numbers a developertypicallysta rtsfromthepointofth ecrash visitingallfilesandcallerf unctionsuntiltheorigi nofthecrash is localized.
when the crash occurs deep in t he execution thenumberoffunction sandfilestovisitcan becomelarge.
we have considered of the mutations p erformed in ourcoverageteststhat leadtocrashes fromb tusb nfs and isofs.
we also conside r mutations in nfs code that add statements for arbitra rily acquiring and rele asing locks in servicesinordertopro vokekernelhangs focu singonlocks thatarepassedbetwee nfunctionsastheycan triggersafety holesincorekernelcod e. we have compared the oops reports with the correspondingdiagnosyslog s. in92 ofthesecras hes thediagnosyslogcontainsinfor mationontheoriginof thefault.
for thosecases debugging withtheoopsreporta lonerequired consulting1to14func tions includingonaver ageonepossiblystalepointer inup to4differentfilesdistr ibutedacross kernel and service cod e. in of the cases for which the diagnosys log contain s relevant information we find that usingdiagnosysreduce sbyatleast50 then umberoffiles andfunctionstoconsu lt. in19 ofthecases forwhichthe diagnosys log contains relevant information t he crash occurredinthesamefile asthemutation butt hediagnosys log made it possible to more readily pinpoint the fault by providinglinenumbers thatareclosertothem utationsite.
.
overhead introducingwrapperso nkernel exportedfunc tionsincurs aperformanceoverhea donserviceexecution.
toassessthe impactofthisoverhead weexecutevariousrea l worldkernel serviceswithandwith outadebugginginterfa ce.
networkdriverperf ormance.ourfirsttestinvolves a gigabitethernetdevic ethatrequiresbothlo wlatencyand high throughput to gu arantee high performa nce.
we evaluate the impact of a d ebugging interface by exercising the e1000elinuxdevicedri verusingthetcp stream udp streamandudp rrtestsfromthenetp erfbenchmark.
fortheseexperiments thenetperfutilitywas configuredto reportresultsaccurate to5 with99 confid ence.
table6 summarizestheperform anceforthee1000edri verwhenrun withoutandwithade bugginginterface.
the debugginginterfaceonlyreducesth ethroughputby0.
to6.
.
org67table performan ce of thee1000edriver test without diagnosys with diagnosys o verhead tcp streamthroughput .91mb s .32mb s .
udp streamthroughput .00mb s .73mb s .
udp rrthroughput .69tx s .81tx s .
file system perform ance.our second test inv olves thenfsfilesystem w hoseimplementationu sesaround200 exportedfunctionsexh ibitingsafetyholes.
th eexperiment consistsofsequentialb lockreadandwriteph asesaccessing records of a given size based on patterns gen erated by the iozone file system ben chmark.108g of data are accesse d. forthisexperiment th eclientandserverrun onthesame machine connected us ing a loopback interfa ce.
read and writeoperationsarepe rformedinthedirecti omodewith varyingrecordsizes.
w ithadebugginginterfa ceintegrated intothenfsfilesystem wehavere cordedaround16milli on callstotheinterfacew rapperfunctionswhen usingarecord size of kb.
as sh own in table the o verhead varies between3 and11 dependingontherecor dsize.
table performan ce of the nfs file sy stem record blockwithout diagnosys with diagnosysoverhead accessrate k sec accessrate k sec size kb read w rite read write read wr ite .
.
.
.
.
.
.
relatedwork in the last decade stu dies have shown that kernel level services inparticulard evicedrivers arerespo nsibleforthe majority of os crashe s. ganapathiet al.have found that ofallwindowsxp crashesareduetodevic edrivers .
tenyearsago chouetal.foundthatthefaultra teinlinux drivers is times hi gher than that of othe r parts of the kernel .
palixet al.haveshownthatwhile thiserrorrate is decreasing linux dr ivers still contain man y defects .
theyhavealsofound thatfilesystemshave recentlyhada highfaultrate indeed evenhigherthanthat ofdrivers.
system robustness testing .fault injection has be en appliedtothelinuxkern eltoevaluatetheimpa ctofvarious fault classes .
ou r work identifies the s afety holes in kernelinterfacesthate xplaintheirobservatio ns.
marinescu and candea focus on the returns of erro r codes from userspacelibraryfunct ions.
theseareanalogo ustoournull exitsafetyholes.
their approach however isn otapplicable toothertypesofsafety holes.
static bug finding.
modelchecking theore mproving and programanalysishave beenusedtoanalyzeo scodetofind thousands of bugs .
neverthele ss these tools taketimetorunandt heresultsrequiretime andexpertise to interpret.
thus th ese tools are not well suited to the frequent modifications and tests that are typ ical of initial codedevelopment.
nu merousapproacheshav eproposedto statically infer so calle dprotocols describing expected sequences of function ca lls .
the se approaches havefocusedonsequen cesoffunctioncallstha tareexpected toappearwithinasin glefunction ratherth anthespecific interactionbetweenas erviceandtherestoft hekernel.
rg someofourkindsofs afetyholescouldbeel iminatedby the use of advanced t ype systems.
for exa mple bugrara andaikenproposean analysistodifferentiat ebetweensafe and unsafe userspace p ointers in kernel code .
they focus however ontheen tirekernel andthusm ayinformthe servicedeveloperabou tfaultsincodeothert hanhisown.
logging.
runtime logs are frequ ently insufficient for fa ilure diagnosis especiall y in case of unexpecte d crashes .
logenhancer enricheslogmessa geswithextrainforma tion butdoesnotcrea tenewmessages.
diag nosyscreates newlogmessagesalon gthekernel servicebo undary where theycanbemosthelpf ultoservicedeveloper s. robust interfaces.
lxfi isolates kern el modules and includestheconceptofapiintegrity whichallowsdevelopers to define the usage contract of kernel inte rfaces by annotating the source co de.
lxfi however ai ms at limiting thesecuritythreatpos edbytheprivilegesgra ntedtokernel modules while diagno sys focuses on various categories of commonfaultsencoun teredinkernelcode.
healers automatically generates a robust int erface to a user levellibrarywitho utaccesstothesource code .
it relies on fault injectio n to identify the set o f assumptions thatalibraryfunction makesaboutitsargum ents.
healers canobtaininformation aboutruntimevalues suchasarray bounds thatmaybed ifficulttodetectusing staticanalysis.
however healersdoes notaddresssafetyhole kindssuchas lock that require calli ng context information .
supporting lock would require te sting the state of all a vailable locks whichwouldbeexpens iveandarelikelyunkn own.
programming with contra cts.asoftwarecontractrepresentstheagreementbe tweenthedeveloperof acomponent anditsuseronthecom ponent sfunctionalbeh avior .
contractsincl udepre andpost cond itions aswell asinvariants.
asafety holeisessentiallythed ualofacontract inthatacontract describespropertiestha tthecontext shouldhave whileasa fetyholedescribespro pertiesthatit shouldnothave.
contractinferenceisan alogoustotheexecutio nofshana.
arnoutandmeyerinfe rcontractsbasedonex ceptionsfound in .net code .
dai kon infers invariants d ynamically by runningtheprogramw ithmultipleinputsand generalizing theobservations .
d iagnosystargetssituati onsthatlead tounhandledexception s eitherinthekernel ortheservice code.
linux kernel ex ecution is highly depe ndent on the particulararchitecture anddevicesinvolved a ndthusaservicedeveloperwouldh avetoactivelyusedai koninhisown environment.
shana allows the collection o f safety holes tobecentralized.
fina lly onlyoneoftheinv ariantsinthe daikoninvariantlist 11nonzero maycorrespo ndtooneof our safety hole kinds namely inull.
daikon does nothandlecommonsafetyhole kindssuchasfree ork ernel specific safetyholekindssuch asparam foruser poi nterbugs.
theextendedstaticc heckerforjava esc j ava reliesonprogrammeran notationstocheckmet hodcontracts.
annotationassistantss uchashoudini aut omatetheinferenceofannotations.
houdinisupportsvario usexceptions involvingarguments s uchasnullpointerexc eptionandindexoutofboundsexcep tion but does not pro vide tests for thevalidityofallocate dmemory.
it.edu pag daikon d ocumentation sec.
.
.
conclusion defects in kernel level services can cause the demise of theentiresystem often leavingdeveloperswith outanyclue as to what went wron g. debugging such pr oblems is particularlychallengingea rlyinservicedevelopm ent whenthe codechangesfrequentl yandthedeveloperis notnecessarily aware of the usage pr econditions of kernel i nterfaces.
we havedesigneddiagnos ys atoolthatdetects safetyholesin linuxkernelexportedf unctionsandsupports thegeneration ofadebugginginterfac e tailoredforaparticu larservice accordingtothisinforma tion.
atruntimediagn osysprovides a crash resilient loggin g system for recording information aboutriskyusesofker nelfunctionscontainin gsafetyholes.
using fault injection t ests on linux kern el level services wehaveshownt hatourinterfacealerts thedeveloper tothecriticaldefectsi nhiscode.
usingadri verforagigabit ethernet device an d a nfs file system w e have shown thattheperformancei mpactofourapproach iswithinthe limitsofwhatisaccep tablewhentestingak ernel levelservice in the initial stag es of development and can even be useduptothephaseo finitialdeployment.
.
acknowledgm ents thisworkwassupport edinpartbytheanr grantabl.
source code and resu lts from this work ca n be found at i.fr projects diagno sys.
.