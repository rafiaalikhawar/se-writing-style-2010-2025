racez a lightweight and non invasive race detection tool for production applications tianwei sheng1neil vachharajani2stephane eranian2robert hundt2wenguang chen1 weimin zheng1 1tsinghua university beijing china 2google inc. amphitheatre parkway mountain view ca tianwei.sheng gmail.com neil purestorage.com eranian rhundt google.com cwg zwm dcs tsinghua.edu.cn abstract concurrency bugs particularly data races are notoriously difficult to debug and are a significant source of unreliability in multithreaded applications.
many tools to catch data races rely on program instrumentation to obtain memory instruction traces.
unfortunately this instrumentation introduces significant runtime overhead is extremely invasive or has a limited domain of applicability making these tools unsuitable for many production systems.
consequently these tools are typically used during application testing where many data races go undetected.
this paper proposes r acez a novel race detection mechanism which uses a sampled memory trace collected by the hardware performance monitoring unit rather than invasive instrumentation.
the approach introduces only a modest overhead making it usable in production environments.
we validate r acez using two open source server applications and the parsec benchmarks.
our experiments show that r acez catches a set of known bugs with reasonable probability while introducing only .
runtime slow down on average.
categories and subject descriptors d. .
testing and debugging general terms reliability design performance keywords data races performance monitoring unit sampling probability analysis .
introduction .
motivation the dominance of multi core processors has made concurrent programming essential to achieve peak performance from modern systems.
unfortunately parallel programming is considerably more difficult than its sequential counterpart.
in addition to all the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.bugs common to sequential code one must also contend with concurrency bugs such as data races atomicity violations deadlock and livelock.
among concurrency bugs data races are often serious and extremely difficult to debug.
for example a race condition was partially responsible for the black out in the northeastern part of the united states described as the worst outage in north american history .
a data race occurs when multiple threads concurrently access the same location without proper synchronization and at least one of the accesses is a write.
data races are difficult to diagnose for two primary reasons.
first they often manifest only under certain potentially very rare thread interleavings.
this makes data race bugs difficult to reproduce.
second the actual data race typically only corrupts data.
user visible effects such as program crashes or corrupted output may occur much later which makes it difficult to isolate where in the code the race actually occurred.
because data races are serious bugs that are notoriously difficult to find the literature is replete with approaches to automatically detect data races.
these approaches can broadly be classified into two categories static race detection and dynamic race detection.
while static analyses have made great strides currently mainstream practical race detection tools use the dynamic approach .
these tools monitor a program at runtime and check to see if any data race has or could have occurred.
to enable this checking synchronization operations and memory accesses in the program are instrumented and the race detection tool analyzes the streams of synchronizations and accesses.
although these dynamic tools can detect many data races they typically suffer from significant instrumentation overhead.
for example the intel thread checker reported an average 200x slow down and a new valgrind based tool threadsanitizer which is widely used at google has a 40x slow down.
even recent proposals such as fasttrack still incur an average .5x slow down.
the significant overhead of these tools makes them unusable in production environments.
instead developers test for concurrency bugs during their pre deployment testing or to triage bugs after they have been observed in the field.
in addition to using tools explicitly designed to find the root cause of data races developers also use program testing methods designed to increase the probability that bugs are triggered .
however some concurrency bugs still escape testing and remain in the production code.
predeployment testing does not catch all data races for three primary reasons .
lack of representative testing input.
in order to expose all bugs during testing developers must construct representative testing input to cover all the code in the program.
this has been proven to be very challenging.
.
incomplete modeling of the runtime environment.
the testing environment is often very different from the real pro permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
401duction environment e.g.
operating system kernel version thread library version .
this poses a serious challenge for concurrency bugs since differences in environment can affect the likelihood of various thread interleavings.
.
insufficient testing time.
data races often manifest infrequently.
even with approaches to boost the probability of occurrence data races will often not manifest during testing and will occur only infrequently in production leading to mysterious program crashes or data corruption.
sampling has emerged as a promising technique to overcome these challenges.
sampling can dramatically lower overhead and therefore allows the race detection tool to be run in production.
recent work has shown that monitoring only a small fraction of the memory accesses from a program is sufficient for capturing many race conditions.
this approach can lower overhead as low as .
unfortunately even this overhead is still too high for many production systems.
additionally the approaches are invasive or have limited applicability.
for example to sample memory accesses literace clones every function one of which is instrumented leading to a 2x increase in code size.
at the entrance to each function checks are inserted to decide whether to execute the instrumented or uninstrumented versions.
this code growth can have significant performance ramifications due to instruction cache instruction tlb and branch prediction affects.
another recent sampling approach pacer avoids the code growth by relying on a jit compiler to insert instrumentation.
unfortunately while jit compilation works well for managed languages such as java it is inapplicable to unmanaged e.g.
c c code.
further users may be hesitant to deploy literace or pacer protected code due to the invasive instrumentation that could create pathological performance issues observed only in production lead to unforeseen program crashes or obscure the root cause of other bugs observed in the field.
.
our contribution in this paper we propose a dynamic data race detection method that samples memory accesses using the hardware performance monitoring unit pmu rather than relying on instrumentation of memory instructions.
our approach is based on the observation that memory accesses occur much more frequently than synchronization operations.
consequently instrumenting memory accesses is far more invasive and results in much higher overhead than instrumenting only synchronization primitives.
fortunately modern hardware pmus can sample memory accesses with very low overhead.
unfortunately using the pmu for race detection is not a panacea.
the pmu was originally designed for performance monitoring.
consequently the following artifacts in its behavior must be overcome to enable race detection .precise pmu signal delivery traditional race detection tools instrument both the synchronization and memory operations in user level code.
as shown in figure when using the pmu to sample memory accesses the synchronization data comes from user level instrumentation while the memory access data comes from hardware through the kernel to userlevel code via a signal.
in the figure if the memory operation w1 is sampled by the pmu we would like the signal to be delivered to thread before the unlock edge in the figure .
this guarantees the tool knows the correct lock context in which the memory was accessed.
however the signal may be delivered at the points indicated by edges and due to various os and pmu issues.
.distributed and biased samples from the pmu all sampling approaches will only collect data for part of a program s execution.
as shown in figure a previous sampling approaches to race detection such as literace and pacer collect data from a contiguous sequence of instructions on each sample.
however as shown in figure b the pmu collects data for only one instruction in each sample.
this means that races must be detected by synthesizing information from temporally distant instructions in the program.
additionally due to bias in pmu sampling certain instructions even memory instructions may never be sampled .
figure challenges in precise signal delivery from the pmu.
edge 1is the desired signal delivery however in practice edges 2and3are possible.
figure different sampling mechanisms.
to address the first challenge we propose both a combination of kernel enhancements and hardware and software solutions to guarantee that the sample of memory operations can be correlated back to the trace of synchronization operations.
we address the second challenge using several strategies.
first by computing a program slice originating at each sampled instruction we extend each instruction sample into effectively many.
not only does this allow us to reduce our sampling rate it also provides coverage to instructions that may not be sampled due to pmu artifacts.
second we rely on the lockset race detection algorithm which does not depend on bursts of memory operation data for race detection.
finally we observe that if the tool s overhead is sufficiently low it can be run in production.
consequently in the context of data center applications we need not catch race conditions with very high probability.
since each application is running on many machines over very long periods of time even a small probability of catching the race on one particular invocation of the application is acceptable since it is sufficient to catch the race on any one of the many machines running the application.
we refer to our implementation of these techniques as r acez .
we evaluate r acez with two open source server applications and one standalone parallel benchmarks suite.
for the two server applications given a set of known data races bugs using a modest 402serverapplicationself monitoring threadinglibrary instrumentationsampling information collectionloggingracezruntime library systemcallinterface oskernel pmusupportkernelmodule pmu hardwarecpuracezofflineanalysis figure overview of r acez architecture sampling rate r acez can successfully catch all of them with reasonable probability.
at the same sampling rate r acez only incurs a .
slow down on average.
the main contributions of this paper include .
r acez a lockset based race detection tool which uses the pmu rather than instrumentation to sample program memory accesses.
besides very low overhead with sampling the most important merit of r acez is that it is non invasive and requires minimum modification to the original applications.
to the best of our knowledge this is the first tool that uses existing pmu hardware to do race detection.
.
we develop several techniques to overcome the fundamental problems when using the pmu race detection.
.
we provide a theoretical analysis and detailed experimental evaluation to prove the effectiveness and efficiency of racez the rest of part of this paper is organized as follows.
section gives the system overview of r acez .
section describes the design and implementation of r acez .
we give a simple mathematical analysis for the probability of catching data races and introduce our main optimization techniques in section .
our experimental results are reported in section .
we discuss our limitations in section and briefly describe the related work in section .
finally we conclude in section .
.
system overview all data race detection tools require traces containing synchronization operations and memory