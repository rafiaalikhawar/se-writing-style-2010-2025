fine grained and accurate source code differencing jean r my falleri univ.
bordeaux labri umr f talence france falleri labri.frflor al morandat univ.
bordeaux labri umr f talence france fmoranda labri.frxavier blanc univ.
bordeaux labri umr f talence france xblanc labri.fr matias martinez inria and university of lille france matias.martinez inria.frmartin monperrus inria and university of lille france martin.monperrus inria.fr abstract at the heart of software evolution is a sequence of edit actions called an edit script made to a source code le.
since software systems are stored version by version the edit script has to be computed from these versions which is known as a complex task.
existing approaches usually compute edit scripts at the text granularity with only add line and delete line actions.
however inferring syntactic changes from such an edit script is hard.
since moving code is a frequent action performed when editing code it should also be taken into account.
in this paper we tackle these issues by introducing an algorithm computing edit scripts at the abstract syntax tree granularity including move actions.
our objective is to compute edit scripts that are short and close to the original developer intent.
our algorithm is implemented in a freely available and extensible tool that has been intensively validated.
categories and subject descriptors d. .
software engineering coding tools and techniques general terms algorithms experimentation keywords software evolution program comprehension tree di erencing ast.
.
introduction the rst law of software evolution states that almost all software systems have to evolve to be satisfactory .
since this law was formulated many studies have been performed to better understand how software systems evolve and forms what is called the software evolution research eld .
there is global software evolution e.g.
evolution of requirements of execution environments ... and local software evolution evolution of source code les .
in this paper we focus on the latter that is on understanding how source code les evolve.
in particular we focus on edit scripts that are sequences of edit actions made to a source code le.
usually since software is stored in version control systems edit scripts permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
computed between two versions of a same le.
the goal of an edit script is to accurately re ect the actual change that has been performed on a le.
edit scripts are used by developers on a daily basis.
for example the unix di tool takes as input two versions of a source code le and performs the myers algorithm at the text line granularity and returns an edit script indicating which lines have been added or deleted.
however the limitations of di are twofold.
first it only computes additions and deletions and does not consider other kinds of edit actions such as update and move.
second it works at a granularity the text line that is both coarse grain and not aligned with the source code structure the abstract syntax tree.
to overcome this main limitation there are algorithms that can work at the abstract syntax tree ast level .
the main advantage in using the ast granularity is that the edit script directly refers to the structure of the code.
for instance if an edit action is the addition of a new function node it clearly means that a new function has been added in the code.
despite several key contributions e.g.
the problem of computing ast edit scripts is still open with two main challenges handling move actions and scaling to ne grained asts with thousands of nodes1.
this is where this paper makes a contribution.
to design our novel algorithm we take the viewpoint of the developer she is never interested in the theoretical shortest edit script.
she is rather interested in having an edit script that re ects well the actual changes that happened.
thus our objective is not to nd the shortest sequence of actions between two versions but a sequence that re ects well the developer intent.
consequently we devise an algorithm based on heuristics that contain pragmatic rules on what a good edit script is and as importantly that is e cient and scales to large asts.
this algorithm has been implemented within a freely available and extensible tool2.
to sum up our contributions are a novel e cient ast di erencing algorithm that takes into account move actions and its implementation 1the best known algorithm with add delete and update actions has a o n3 time complexity with nbeing the number of nodes of the ast .
computing the minimum edit script that can include move node actions is known to be np hard 2github.com jrfaller gumtree an automated evaluation of the implementation performances on real data a manual evaluation of the results of the algorithm through the manual assessment of di erencing scenarios a large scale automated evaluation of di erencing scenarios showing that the results of our algorithm are more accurate than the related work even on negrained asts.
the rest of this paper is structured as follows section presents what is ast di erencing.
section describes our new ast di erencing algorithm.
section presents our tool that implement this new algorithm and its performances.
section presents an empirical evaluation of our tool.
section presents the related work.
finally section concludes and presents the future work.
.
ast differencing prior to presenting ast di erencing we brie y introduce the main concepts de ning the ast structure.
we consider that an ast is a labeled ordered rooted tree where nodes may have a string value.
labels of nodes correspond to the name of their production rule in the grammar i.e.
they encode the structure.
values of the nodes correspond to the actual tokens in the code.
more formally let tbe an ast.
tis a set of nodes.
a treethas one node that is root denoted by root t .
each nodet2thas a parent p2t .
the only node that has for parent is the root.
the parent of a node is denoted byparent t .
each node t2thas a sequence of children children t .
each node has a label in a alphabet l2 label t l .
each node has a string value v2string that is possibly empty value t v .
as an example we consider a simple java source code and its corresponding ast see the bottom left of figure .
the ast of this java source code contains nodes that correspond to the structure of the java programming language.
each node of the ast has therefore a label which maps to structural elements of the source code such as methoddeclaration ornumberliteral and a value that corresponds to the actual tokens in the code such as numberliteral associated to .
some values do not encode information and are therefore discarded for instance methoddeclaration has no interesting token associated to it and thus no value.
asts can have di erent granularities a node can encode a whole instruction or ner grain expressions.
we believe than ne grained asts are best for the developers.
for instance thereturn foo!
statement can be encoded with a single node of type statement and value return foo!
or with two nodes like in our example see node b .
if this statement is changed to return foo!
i only the ne grained representation enables to see that the infixexpression and simplename i nodes are added.
ast di erencing is based upon the concept of ast edit actions.
it aims at computing a sequence of edit actions that transform an ast into another.
this sequence is called an edit script.
regarding our de nition of an ast we consider the following edit actions updatevalue t v n replaces the old value of tby the new valuevn add t t p i l v adds a new node tin the ast.
if tpis not null and iis speci ed then tis theithchild oftp.
otherwisetis the new root node and has the previous root node as its only child.
finally lis the label of t andvis the value of t. delete t removes a leaf node of the ast.
move t t p i moves a node tand make it the ithchild oftp.
note that all children of tare moved as well therefore this actions moves a whole subtree.
as there are many possible edit scripts that perform the same transformation the edit script quality depends on its length the shorter the transformation the better the quality.
note that nding the shortest transformation is np hard when themove action is taken into consideration.
we then consider in this paper that the ast di erencing problem inputs two asts and aims at identifying a short edit script of edit actions including move that transforms a rst ast named t1 into a second one name t2 .
the existing algorithms that perform such an ast di erencing use heuristics to return a short edit script .
moreover they usually follow a two steps process.
first they establish mappings pairs of nodes between the similar nodes of the two asts.
there are two constraints for these mappings a given node can only belong to one mapping and mappings involve two nodes with identical labels.
second based on these mappings they deduce the edit script that must be performed on the rst ast to obtain the second one.
the rst step is the most crucial one because quadratic optimal algorithms exist for the second step .
in the next section we will present a new algorithm to compute mappings between two asts.
.
the gumtree algorithm as explained in the previous section ast di erencing algorithms work in two steps establishing mappings then deducing an edit script.
since an optimal and quadratic algorithm has already been developed for the second step we only explain in this section how we look for the mappings between two asts.
the output of this algorithm can be then used by the algorithm of chawathe et al.
to compute the actual edit script.
our algorithm to compute the mappings between two asts is composed of two successive phases .a greedy top down algorithm to nd isomorphic subtrees of decreasing height.
mappings are established between the nodes of these isomorphic subtrees.
they are called anchors mappings .
.a bottom up algorithm where two nodes match called acontainer mapping if their descendants children of the nodes and their children and so on include a large number of common anchors.
when two nodes matches we nally apply an optimal algorithm to search for additional mappings called recovery mappings among their descendants.
this algorithm is inspired by the way developers manually look at changes between to les.
first they search for the biggest unmodi ed pieces of code.
then they deduce which container of code can be mapped together.
finally they look at precise di erences in what is leftover in each container.
to better illustrate our algorithm we introduce the example shown in figure .
314compilationunit typedeclaration modifier public simplename t est methoddeclaration modifier private simpletype string simplename foo singlevariabledeclaration block simplename string primitivetype int simplename i ifstatement infixexpression returnstatement simplename i numberliteral stringliteral bar infixexpression returnstatement simplename i prefixexpression numberliteral 1stringliteral foo!compilationunit typedeclaration modifier public simplename t est methoddeclaration modifier public simpletype string simplename foo singlevariabledeclaration block simplename string primitivetype int simplename i ifstatement infixexpression returnstatement simplename i numberliteral stringliteral foo!ifstatement test.java sourcetest.java destination public class test public string foo int i if i return foo!
public class test private string foo int i if i return bar else if i return foo!
a bcfigure two sample java les with their corresponding asts and mappings.
nodes with a label only are denoted label nodes with a label and a value are denoted label value .
mappings from the top down phase are depicted with long dotted lines descendants of these nodes are also mapped but it is omitted to enhance readability .
mappings from the bottom up phase are depicted using short dotted lines container mappings or alternate dotted lines recovery mappings .
unmatched nodes are greyed.
.
top down phase the rst step of gumtree is a top down greedy search of the greatest isomorphic subtrees between t1andt2.
before explaining how we proceed we introduce the notion of height in a tree.
the height of a node t2tis de ned as for a leaf node t height t and for an internal nodet height t max fheight c jc2children t g .
the algorithm uses an auxiliary data structure called heightindexed priority list .
this list contains a sequence of nodes ordered by decreasing height.
the following functions are associated with this data structure.
push t l inserts the nodetin the listl.peekmax l returns the greatest height of the list.
pop l returns and removes from lthe set of all nodes oflhaving a height equals to peekmax l .open t l inserts all the children of tintol.
we also de ne the dice function that measure the ratio of common descendants between two nodes given a set of mappings mas dice t1 t2 m jft 12s t j t1 t2 2mg js t1 j js t2 j withs ti being the set of the descendants of node ti.
the dice coe cient ranges in the real interval a value of indicates that the set of descendants of t1is the same as the set of descendants oft2.
the algorithm of the top down phase of gumtree is shown in algorithm .
in this algorithm we map the common subtrees of t1and t2with the greatest height possible.
the principle is to start with the roots since they have the greatest heights and to check if they are isomorphic.
if they are not their children are then tested.
a node is matched as soon as an isomorphic node is found in the other tree.
when a given node can bematched to several nodes all the potential mappings are kept in a dedicated candidate mappings list.
this list is processed after all nodes that are uniquely matched have been processed those nodes being directly placed into the mappings set.
the algorithm considers only nodes with a height greater than minheight.
to process the candidate mappings we use the dicefunction on the parents of each candidate mapping.
the values of this function are used to sort the candidate mappings list mappings with greater values being rst.
then until the candidate mappings list is empty we remove the rst element add it in the mappings set and we remove from the candidate mappings list the mappings involving a node of this mapping.
on the sample trees of figure with a minheight algorithm nds the mappings shown with dashed lines.
.
bottom up phase algorithm shows the bottom up phase where the mappings produced during the top down phase are taken as input.
first we look for container mappings that are established when two nodes have a signi cant number of matching descendants.
for each container mapping found we look for recovery mappings that are searched among the still unmatched descendants of the mapping s nodes.
to nd the container mappings the nodes of t1are processed in postorder.
for each unmatched non leaf node of t1 we extract a list of candidate nodes from t2.
a nodec2t2is a candidate fort1iflabel t1 label c cis unmatched and t1 andchave some matching descendants.
we then select the candidatet22t2with the greatest dice t1 t2 m value.
if 315algorithm the algorithm of the top down phase.
data a source tree t1and a destination tree t2 a minimum height minheight two empty height indexed priority listsl1andl2 an empty listaof candidate mappings and an empty set of mappings m result the set of mappings m 1push root t1 l1 2push root t2 l2 3while min peekmax l peekmax l minheight do ifpeekmax l peekmax l then ifpeekmax l peekmax l then foreach t2pop l doopen t l else foreach t2pop l doopen t l else h1 pop l h2 pop l foreach t1 t2 2h1 h2do ifisomorphic t t2 then if9tx2t2jisomorphic t tx tx6 t2 or9tx2t1jisomorphic t x t2 tx6 t1 then add a t1 t2 else add all pairs of isomorphic nodes of s t1 ands t2 tom foreach t12h1j t1 tx 62a m doopen t l1 foreach t22h2j tx t2 62a m doopen t l2 19sort t t2 2ausing dice parent t parent t m 20while size a 0do t1 t2 remove a add all pairs of isomorphic nodes of s t1 ands t2 tom 23a anf t1 tx 2ag 24a anf tx t2 2ag dice t1 t2 m mindice t1andt2are matched together.
to search for additional mappings between the descendants oft1andt2 we rst remove their matched descendants and if both resulting subtrees have a size smaller than maxsize we apply an algorithm denoted optthat nds a shortest edit script without move actions.
in our implementation we use the rted algorithm .
the mappings induced from this edit script are added in mif they involve nodes with identical labels.
on the sample trees of figure with mindice algorithm nds the container mappings shown using shortdotted lines.
from these container mappings with maxsize several recovery mappings are found shown with alternatedotted lines.
finally the edit script generated from these mappings is as follows nodes a bandcare shown in figure nodestiare new nodes add t a returnstatement add t t1 stringlitteral bar add t a ifstatement add t t3 infixexpression add t t4 simplename i add t6 t4 prefixexpression add t7 t6 numberliterral move b t updatevalue c private we recommend the following values for the three thresholds of our algorithm.
we recommend minheight to avoid single identi ers to match everywhere.
maxsize is used in the recovery part of algorithm that can trigger a cubic algorithm.
to avoid long computation times we recommend to usemaxsize .
finally under of common nodes two container nodes are probably di erent.
therefore we recommend using mindice .
complexity analysis our algorithm has a worst case complexity of o n2 where n max jt1j jt2j .
indeed algorithm performs in the worst case a cartesian product of nodes with identical heights.
since the isomorphism test we use is in o thanks to hashcodes proposed in the whole algorithm is o n2 .
moreover with real asts this worst case is very unlikely to happen.
algorithm also performs a cartesian product of unmatched nodes in the worst case.
this operations is alsoo n2 because all sub operations are bounded even the cubic algorithm optwhich is only applied on trees smaller than a xed size.
finally the algorithm that computes the edit script from the mappings described in also has a o n2 worst case complexity.
.
tool the algorithm described in the previous section has been implemented in a freely available and extensible tool.
ast di erencing requires parsers that produce the ast representation to support a given programming language.
this is clearly a constraint since new languages do not work out of the box.
another interesting challenge faced by such a tool is that it is used by di erent actors with di erent expectations such as a developer that wants a neat graphical display of the edit script to quickly understand it or a researcher that wants the results in a structured format that can be processed automatically.
in this section we present our ast di erencing tool that allows to integrate new programming languages di erencing algorithms and ways of providing results.
.
architecture our tool uses a pipe and lter architecture shown in figure .
two input les are transformed into two asts by a parser.
since parser is an abstract module several concrete algorithm the algorithm of the bottom up phase.
data two trees t1andt2 a setmof mappings resulting from the top down phase a threshold mindice and a maximum tree size maxsize result the set of mappings m. 1foreach t12t1jt1is not matched t1has matched children in post order do t2 candidate t m ift26 nulland dice t t2 m mindice then 4m m t1 t2 ifmax js t j js t2 j maxsize then 6r opt t t2 foreach ta tb 2rdo ifta tbnot already mapped and label ta label tb then m m ta tb 316outputcompilationunit typedeclaration modifier public simplename test methoddeclaration modifier public simpletype string simplename foo simplename string compilationunit typedeclaration modifier public simplename test methoddeclaration modifier public simpletype string simplename foo simplename stringfile1.java file2.javaparser mappingscompilationunit typedeclaration modifier public simplename test methoddeclaration modifier public simpletype string simplename foo simplename string compilationunit typedeclaration modifier public simplename test methoddeclaration modifier public simpletype string simplename foo simplename stringactionsinsert move delete update insert delete ...figure our pipe and lter architecture.
abstract modules are greyed.
implementations can be furnished such as java or c .
these two asts are then given to an abstract mappings module that computes as output a set of mappings.
since this module is also abstract several concrete algorithms such as gumtree orchangedistiller can be provided.
finally this set of mappings is given to an actions module that computes the actual edit script.
the input les asts mappings and edit script are nally given to an abstract output module.
since this module is abstract several outputs can be provided e.g.
xml json ... .
note that all the data structures are given to the output module it can therefore operate on any of them for instance it can produce the xml of an ast or of an edit script .
using this architecture we have been able to integrate the java using the eclipse jdt parser javascript using the mozilla rhino parser r using the fastr parser and c using the coccinelle parser programming languages.
we have also integrated the gumtree changedistiller xydi and rted algorithms.
finally we can produce the following outputs a graphviz representation of an ast a xml representation of an ast a web based view of an edit script shown in figure and a xml representation of an edit script.
.
runtime performances in this section we want to assess the runtime performances of our tool on real data.
as explained in the previous section our tool applies the di erencing algorithm on asts parsed from two versions of a source code le.
we have figure the web based di view of our tool.integrated several parsers into our tools.
we use the java andjavascript parsers in this section.
to gather representative data to assess our tool we selected arbitrarily two mature popular and medium to large sized projects.
for the java language we use jenkins a continuous integration server and for javascript we use jquery a dom manipulation library .
we arbitrarily selected a complete release of each project and extracted each le modi cation performed in the commits corresponding to this release.
in jenkins we use the release !
where we extracted modi cations.
in jquery we use the revision !
where we extracted modi cations.
each modi cation consists in a pair of les previous version and next version .
they have been extracted thanks to the harmony platform .
in this performance study we want to assess two important aspects running time and memory consumption.
we use a macbook pro retina with a .7ghz intel core i7 with gb of ram.
to have reference measures we use three other tools in addition to our tool.
the complete list of tools we use is a classical text di tool that computes an edit script with add and delete actions on text lines.
as explained in section this tool is very fast and therefore represents the lower bound for a code di erencing algorithm.
in our experiment we use the google implementation3.
the parser included in gumtree which only parse the two les involved in the modi cation without applying ast di erencing algorithms.
as parsing the les is mandatory to perform ast di erencing it represents the lower bound for an ast di erencing algorithm.
in our experiment we use eclipse jdt parser to parse java les and mozilla rhino parser to parse javascript les.
the gumtree algorithm including parsing with the following thresholds minheight mindice andmaxheight .
the rted algorithm including parsing that computes an edit script on an ast with add update and delete actions.
as explained in section rted has a cubic worst case complexity n3 .
therefore it represents an upper bound for ast di erencing.
in our experiment we use the implementation provided by pawlik et al.
in our framework.
we only compare gumtree to text di and rted because we have re implemented the other algorithms included in our tool by following the description of the articles but with no particular care for optimization.
therefore reporting memory consumption or running times for these algorithms would not be fair.
for the memory consumption we ensure that the tools can run using 4gb of ram a common amount of memory in modern computers.
to that extent we use a java virtual machine bound to 4gb of memory.
we run each tool on each modi cation and count the number of modi cations leading to an out of memory error.
in this experiment the only tool that underwent out of memory errors is rted with errors 3code.google.com p google diff match patch around of the modi cations .
even though this number is not so high it still shows that the complexity of rted lead to a very expensive memory consumption in some cases.
for the running time we perform two experiments.
in the rst experiment we investigate if the tools are capable of computing an edit script of a modi cation in less than seconds.
after seconds we believe that the tools will not be used interactively by developers.
to that extent we run each tool on each modi cation and count the number of cases where the execution lasted more than seconds.
in this experiment only rted underwent such cases times around of the cases with no out of memory error .
therefore on our data rted is not capable of computing an edit script for around of the cases which is a large number of cases.
it clearly shows that the complexity of this algorithm is not suitable to real data.
in the second experiment we compare the running times of the tools.
to compute the running times we compute the edit scripts ten times for each modi cation and we retain the median of these values.
to avoid noise in the measures we ensure that the java virtual machine is hot by running each algorithm a hundred times on a random modi cation i.e.
that no more dynamic loading is involved and that the jit compiler has compiled and installed the code corresponding to hot spots.
we also pre load all les involved in the modi cations to avoid io latencies.
to be able to compare the tools on the same dataset we discarded all the modi cations that led to a out of memory error or an execution timeout execution lasting more than seconds for at least one tool.
to present the values we use the running time of text di as a reference value since it is the faster existing tool.
therefore for each modi cation we divide the running time of parsing gumtree and rted tools by the running time of the text di tool.
this ratio represent the number of times that the tool is slower than performing a text di erencing.
we then present the boxplots of the distributions of these resulting ratios.
figure shows the results of the second experiment.
the rst interesting conclusion is that just parsing the les is signi cantly longer than performing a text di erencing the median of parsing time ratios is .
additionally we see that computing an edit script with gumtree is only slightly slower than just parsing the les median at for jenkins and for jquery .
the di erence between jenkins and jquery medians indicates that javascript asts are likely to contain more nodes than java asts.
finally we see that rted is signi cantly slower than just parsing the les median at for jenkins and for jquery .
the di erence between the two medians is also observed for the rted tool.
as a conclusion we clearly see that text di tool is by far the fastest.
however performing ast di erencing with gumtree induces only a small overhead over parsing the les.
it means that our algorithm is fast and can therefore be applied on real data.
the mean running times of gumtree are milliseconds on jenkins and milliseconds on jquery.
our experiments also con rm that using rted on real data induces a huge overhead compared to text di .
.
evaluation we now present the empirical evaluation of gumtree.
our goal is to answer the following research questions rq1 does gumtree produce tree di erences that are correct and better parsing gumtree rtedfigure distribution of the running time ratios of the tools.
for each tool the left boxplot shows the ratios for jenkins and right one for jquery.
the running time ratio is the running time of the tool divided by the running time of text di .
it represents the number of times it is slower than text di .
than unix di .
?
rq2 does gumtree maximize the number of mappings and minimize the edit script size compared to the existing algorithms .
?
rq3 does gumtree detect move operations better than changedistiller .
?
we discuss the threats to the validity of our results in .
.
.
manual evaluation first we consider the viewpoint of the developer.
for her what matters is that the computed edit script is good to understand the essence of a commit.
in this perspective we have developed an experiment that has two main goals .
to evaluate the correctness of gumtree and .
to compare gumtree against text line based di erencing.
.
.
overview the experiment consists in the manual evaluation of le di erences i.e.
on the manual assessment of a le pair di erence the di erence between the version before and the version after the commit .
these le di erences are computed using two techniques gumtree and a state of the art text di erencing tool5.
we will refer to the text di erencing tool as di and to gumtree as gt.
for each le pair of a dataset the outputs from both approaches are given to a human evaluator.
he she compares both outputs and then answers to the following questions is the gumtree output correct?
and which technique yield the most understandable di erencing information gumtree ordi ?.
for example the revision .
of the class arecord of the dnsjava project6introduces a new parameter int index in the method called rrtowire .
the di output is a source code hunk pair the left hunk is composed of the line cor5mergely.com 6sf.net projects dnsjava 318responding of the previous method signature the entire line from the revision .
.
the right hunk corresponds to the updated method signature from revision .
.
the gumtree output states that there are one new parameter type and one new parameter name.
in this case the evaluator may decide that gumtree more precisely localizes and describes the change introduced by the revision .
compared to unix di .
.
.
experiment setup a commit is composed of a set of modi ed les.
after a commit each modi ed le is said to have a new revision .
in our experiment each le pair corresponds to consecutive le revisions.
we used strati ed sampling to randomly select revisions from the software history of open source projects from .
we only consider revisions with few source code changes those revisions for which the changedistiller di erencing algorithm states that there is only one single source code change .
we pick items le pairs per project if simple revisions are found otherwise less .
in total the dataset contains transactions.
then we create an evaluation item for each pair of les of the evaluation dataset.
an evaluation item contains the gumtree output between the revision pair of the transaction the di output between the same pair and the commit message associated with the transaction.
the di output shows two les i.e.
called left and right and highlights the changes made per line.
in particular it highlights the lines deleted from the left le the lines added from right le.
note that we have con gured di to discard whitespaces.
the gumtree output shown in figure highlights the added deleted updated and moved ast nodes.
the commit message describes the intention of the change it sometimes help to meaningfully assess the relevance of both di erencing algorithms.
the evaluation items were independently evaluated by three authors of this paper called the raters .
all raters evaluated all the edit scripts of le pairs at the ast and line level i.e.
outputs .
this makes a total of ratings.
the rater has to answer to the following questions question does gumtree do a good job?
the possible answers are .gumtree does a good job it helps to understand the change.
.gumtree does a bad job.
.
neutral.
question isgumtree better than di ?
the possible answers are .gumtree is better.
.di is better.
.gumtree is equivalent to di .
optionally the rater could write a comment to explain his decision.
those comments are used to identify buggy or corner cases where gumtree could be improved.full majority 1gt does good job gt does not good job neutral 2gt better di better equivalent table agreements of the manual inspection of the transactions by three raters for question top and question bottom .
.
.
experiment result table top presents the number of agreements for the rst question.
let us consider question the three raters fully agreed for .
le pairs to say that gumtree does a good job in explaining the change.
if we consider the majority at least agree it has been assessed that gumtree has a good output for le pairs .
.
table bottom presents the number of agreements for the second question.
in evaluation items there was a full agreement to say that gumtree better highlights the changes between two les.
in items the raters fully agreed the gumtree s output is as good as the one of di to explain the change.
this shows that intuitively gumtree is a tool that has added value compared to di .
beyond those raw numbers let us now measure the statistical level of agreement.
.
.
statistics let us assume that pimeasures the degree of agreement for a single item in our case in f1 3g.
the overall agreement p is the average over piwhere ini2f1 144g.
the coe cient kappa measures the con dence in the agreement level by removing the chance factor7 .
for question we have p .
using the scale introduced by this value means there is an almost perfect agreement.
the degree of agreement in our study is .
a value distant from the critical value that is .
the null hypothesis is rejected the observed agreement was not due to chance.
.
for question we have p .
using the mentioned scale this value means there is a substantial overall agreement between the rates.
the degree of agreement in our study is .
far higher that the critical value.
the null hypothesis is rejected the observed agreement was not due to chance.
.
.
conclusion the manual rating of revisions by independent raters shows that gumtree can be used to compare two java les in order to understand the essence of the change and its output is sometimes more understandable than the one from di .
there is a statistically signi cant level of agreement between raters for both results.
7some degree of agreement is expected when the ratings are purely random .
.
automatic evaluation we are now con dent that gumtree is good from the viewpoint of a human developer.
we now assess whether gumtree maximizes the number of mappings and minimizes the edit script.
compared to the previous manual evaluation this evaluation is fully automatic.
consequently it can be performed on a large scale.
.
.
goal and measures the goal of this experiment is to measure the performance of tree di erencing algorithms with respect to .
the number of mappings .
the edit script size we compare gumtree against the two major di erencing algorithms as of today changedistiller and rted .
other algorithms exist but they have less impact compared to those two in terms of publication visibility or citations .
for a description of changedistiller and rted please refer to section .
as explained in section changedistiller uses a simpli ed asts where the leaf nodes are code statements.
therefore we compute the metrics for both simpli ed asts as described in and raw asts generated by the eclipse jdt parser.
in the remainder of the section these granularities are called respectively cdg changedistiller granularity and jdtg eclipse jdt granularity .
our motivation is to compare gumtree and changedistiller algorithms even on cdg asts it would have been unfair to claim anything on asts that would be di erent from those for which changedistiller is designed and optimized.
since the goal of gumtree is to work on ne grained asts we evaluate the performance metrics on this granularity as well.
finally for the sake of comparison we also evaluate rted on ne grain ast since that is the granularity gumtree is designed for.
.
.
procedure the experiment consists in comparing source code le pairs using several ast di erencing algorithms.
we take a sample of revision pairs from java open source projects of the cvs vintage dataset .
for revision pairs we create tree representations before and after the commit and for both kinds of asts we consider .
then we run the competing tree di erencing algorithms for each pair of asts.
finally we measure the execution time we count the mapped nodes and we save the edit scripts.
for sake of performance we discard the revision pairs of large source code le i.e.
whose tree representations have more than nodes mainly because the changedistiller algorithm is too slow for large asts .
in total this results in evaluation cases.
replication information for gumtree we use the following thresholds minheight mindice and maxsize .
for changedistiller we use a label similarity threshold of .
for unmatched nodes we use two similarity thresholds for inner nodes with more than children and for the rest.
.
.
experiment result the results are presented in table .
the upper part of the table presents the performance comparison of changedistiller and gumtree at cdg granularity while the middle part cdggt better cd better equiv.
mappings .
.
.
es size .
.
.
jdtggt better cd better equiv.
mappings .
.
.
es size .
.
.
gt better rted better equiv.
mappings .
.
.
es size .
.
.
table number of cases where gumtree is better resp.
worse and equivalent than changedistiller top middle and rted bottom for metrics number of mappings and edit script size es size at the cdg granularity top and jdtg granularity middle bottom .
shows them at the jdtg granularity ner grain more ast nodes .
finally the lower part compares gumtree and rted di erencing algorithms at the jdtg granularity.
each cell of these tables presents the number of cases where an approach is better than the other for a given ast granularity and measure.
we now analyze the experimental results by metric.
mappings.
as explained in section nding the mappings is the most important step in an ast di erencing algorithm.
finding more mappings increases the odds of deducing a short edit script.
considering the cdg granularity in .
cases gumtree matches more nodes than changedistiller .
then in cases .
both approaches nd the same number of mappings.
at the jdtg granularity ner grain in .
cases gumtree matches more nodes than changedistiller .
in cases .
the number of mappings is the same.
at both granularities gumtree matches more nodes than changedistiller .
when comparing gt against rted in most of the cases .
the same number of mappings is found.
however gumtree nds more mappings which is twice many better than the opposite .
vs .
.
edit script size.
once the mappings are found an edit script is computed.
the length of the edit script is a proxy to the cognitive load for a developer to understand the essence of a commit.
hence the goal is to minimize the size of edit scripts.
considering the cdg granularity the size of edit scripts of gt and changedistiller are the same in cases .
.
in .
cases the edit script from changedistiller is longer than the one of gumtree i.e.
gumtree is generally better .
for the jdtg granularity it is the same changedistilleroften produces bigger scripts in .
cases versus cases .
where it performs better than gumtree .
the comparison between gt and rted shows in most of the cases .
the edit script size is the same and in .
of the cases gt produces shorter edit script than rted .
according to our dataset gumtree systematically produces shorter edit scripts which is better to understand the meaning of a commit.
.
analysis of move actions both gumtree and changedistiller are able detect move node actions.
this section presents an analysis of move actions found by the gumtree and changedistiller matching algorithms.
the goal of this experiment is to check how these algorithms detect move actions.
the evaluation metric can not be an absolute number of move detected operations.
the reason is twofold.
on the one hand one wants to maximize the number of moves instead of having additions and deletions .
on the other hand one wants to minimize the number of spurious detected move actions that have nothing to do with the conceptual change.
consequently we need a more subtle evaluation scenario.
we propose to compare the number of moves by stratifying over the results of both algorithms.
for instance if changedistiller is able to completely explain a commit with only move actions gumtree should also nd an edit script that is uniquely composed of moves.
in this case one can reasonable think that the edit script with the smallest number of moves is the best.
so we compare the results for a number of di erent sub cases.
.
.
procedure we analyze move actions from the di erencing of java le pairs of the dataset introduced in section .
.
we focus on move actions from edit scripts produced by changedistiller cd and gumtree gt .
in this experiment we do not consider rted because this algorithm does not identify move actions.
we select those java le pairs for which the edit script from changedistiller orgumtree is only composed of move actions.
from the initial dataset of le pairs this results in elements.
then to compare the edit scripts we classify each pair of edit script changedistiller versus gumtree in the following categories.
.changedistiller and gumtree produce only moves.
both have the same number of actions i.e.
they are equivalent top left .
.changedistiller and gumtree produce only moves but in di erent numbers top left .
a gumtree with more moves.
b changedistiller with more moves.
.changedistiller produce only move actions and gumtree other actions which can include moves top right .
.gumtree produce only move actions and changedistiller other actions bottom left .
the analysis of the number of items in each category enables us to settle the question of the e ectiveness of the detection of move actions.
.
.
experiment result the results are presented in table .
there are comparisons for which both matching algorithms produce only move actions out of these cases correspond to the case where both algorithms exactly produce the same edit script same number of moves .
then there are instances where changedistiller has more move actions case b .
it remains one case where gumtree produce more moves case a .
thisgt only move op gt other op cd only move op cd other op table comparison of the number of move operations from gumtree and changedistiller for le pairs to be compared.
shows that gumtree edit scripts are more concise to describe move actions than the ones of changedistiller .
moreover there are di erencing scenarios where gumtree produces only move actions while changedistiller produces other kinds of actions case .
in these cases changedistiller has other actions e.g.
one node addition and one node deletion in addition to a move.
this means that gumtree ismore precise to represent changes involving move actions.
to sum up according to our dataset gumtree is better than changedistiller at detecting move actions it is both more concise and more precise.
.
threats to validity we now discuss the threats to the validity of our evaluation set up.
we rst discuss those that are speci c to a research question and then the generic ones.
for the manual analysis the main threat to validity is that the raters are also authors of this paper.
to reassure the reader the evaluation dataset is made publicly available8.
for the comparative analysis of the number of mappings and move operations between di erent tools the main threat is a potential bug in our implementation.
in particular we have re implemented changedistiller because the original implementation needs an eclipse stack.
our new implementation may not re ect all speci c implementation decisions of the original implementation or even introduce new bugs.
for sake of future analysis and replication our implementation of the competitors is in the same repository as gumtree.
we also note that we have experimented with the original changedistiller in several experiments for instance and have con dence that our implementation re ects the original one.
our experiments only consider edit scripts of java les.
this is a threat to the external validity.
despite unlikely our algorithm is independent of any java speci city we can not conclude on whether gumtree performs so well on other programming languages.
finally the three thresholds of gumtree have been xed to the following values minheight maxsize and mindice .
these values have been chosen according to our expertise.
however other values could perform di erently.
more experiments are needed to evaluate their impact on the runtime e ciency and the algorithm results.
.
related work in this section we present the related work on code di erencing from text to graph granularity.
text differencing.
computing di erences between two versions of a source le is most commonly performed at the text line granularity .
within this granularity the edit actions are insertion 321deletion or update of a text line.
the more advanced algorithms are even capable of detecting moved lines .
the algorithms using this granularity are usually very fast and completely language independent compared to our approach which requires a parser that slows down the whole process.
the main issue with these algorithms is that they cannot compute ne grained di erences.
indeed in many languages such as javascript or even java a text line can contain many programming constructs.
additionally the output of these algorithms is very di cult to process automatically since it composed of source code lines that might not be parsed since they might be incomplete.
it is therefore di cult to extract automatically the syntactic modi cations using these approaches.
tree and ast differencing.
the tree di erencing problem has been largely investigated when considering only the add node delete node and update node actions .
for this problem many optimal algorithms have are described in the literature.
the fastest algorithms of this family run in o n3 which can result in signi cantly long edit script computation time for large source code les.
the other issue faced by these algorithms is their inability to uncover moved nodes which is a frequent action in source code les.
it results in unnecessarily big edit scripts which are hard to understand.
when considering move node actions the problem of nding the shortest edit script between two trees becomes nphard.
however several algorithms from the document engineering or software engineering research elds that use practical heuristics exists in the literature.
one of the most famous is the algorithm of chawathe et al.
that computes edit scripts containing move actions on trees representing latex les.
unfortunately this algorithm has constraints acyclic labels and leaf nodes containing a lot of text that do not apply to ne grained asts of general purpose programming languages.
several algorithms have also been designed speci cally for xml documents .
unlike the algorithm of chawathe et al.
they do not have any particular constraint.
however these algorithms put a particular emphasis on the edit script computation time because they are mostly used for automatic on they compression.
regarding our objective the most important thing is to compute an edit script that re ects well the developer intent computation time is only secondary.
gumtree is inspired from the algorithm of cobena et al.
because we apply a very similar rst phase.
the major di erence is that they are not interested in having ne grained di erences since the di erencing is computed only for compression purpose.
our algorithm is much more accurate since it also performs a second phase that increase the number of mappings found and therefore produces shortest edit scripts at the expense of the running time.
the most famous algorithm that works on asts is changedistiller .
it is largely inspired by the one of chawathe et al.
but tuned to work better on asts.
however this algorithm is still based on the assumption that leaf nodes contain a signi cant amount of text.
therefore the authors use simplied asts where the leafs are in fact code statements rather than raw asts.
therefore changedistiller will not compute ne grained edit scripts on languages that can have a lot of elements in statements such as javascript .
the di ts algorithm is able to work on raw asts.
the automaticexperiment performed in the orginal article shows that it produces e ciently short edit scripts.
however the results of this algorithm have not been validated by humans.
the vdi algorithm generates edit scripts from verilog hdl les.
it is slightly similar to the rst phase of gumtree but it uses also the lexical similarity of the code.
however the generated edit scripts are speci c to the vhdl language.
finally the jsync algorithm is also able to compute edit scripts that include move actions.
however it relies on a classical text di erencing algorithm applied on the unparsed asts as rst step.
it therefore limits its ability to nd moved nodes.
additionally it is focused on producing information on clones rather than edit scripts.
graph differencing and origin analysis.
there are several algorithms that go beyond the ast structure and compute edit scripts on graphs representing the source code .
although these algorithms can uncover semantic di erences they are signi cantly harder to use in practice.
mainly because they require much more semantic information on the source code such as program dependency graphs class models meta models or controlow graphs which is very hard if not impossible to obtain in many languages such as javascript or c or when considering only program fragments e.g.
plug ins .
finally there are also many algorithms that perform the socalled origin analysis e.g.
.
these algorithms output the matching program elements between two versions.
they usually use lexical as well as structural similarities between the elements.
however they only consider a few kind of program elements usually class functions and attributes and do not output edit scripts.
.
conclusion and future work in this article we present a novel algorithm that computes ne grained edit scripts on asts including move node actions.
our algorithm is implemented in a freely available and extensible tool.
we have evaluated the running time and memory consumption of our tool and shown that it is reasonable on real data and can be used on a daily basis.
we also have performed an empirical evaluation of the results of our tool.
this evaluation shows that the results of our algorithm are good and often more comprehensible than the result of a classical text di .
as future work we plan to extend our tool to extract modi cations that are performed across les .
we also plan to introduce new algorithms that can automatically process an edit script of gumtree to produce higher order edit scripts for instance to identify refactorings .
finally as the bottleneck of this approch is the parsing we consider moving to more fuzzy parsers in order to accept not well formed le and reduce the parsing time.
.