searching for better configurations a rigorous approach to clone evaluation tiantian wang harbin institute of technology harbin chinamark harman yue jia and jens krinke crest university college london london uk abstract clone detection nds application in many software engineering activities such as comprehension and refactoring.
however the confounding con guration choice problem poses a widely acknowledged threat to the validity of previous empirical analyses.
we introduce desktop and parallelised cloud deployed versions of a search based solution that nds suitable con gurations for empirical studies.
we evaluate our approach on widely used clone detection tools applied to the bellon suite of subject systems.
our evaluation reports the results of .
million total executions of a clone tool the largest study yet reported.
our approach nds signi cantly better con gurations p .
than those currently used providing evidence that our approach can ameliorate the confounding con guration choice problem.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms algorithms experimentation measurement keywords clone detection genetic algorithm sbse .
introduction software contains clones.
several studies have provided evidence for widespread presence of clones and there has been much interest and previous work on software engineering applications and implications such as software evolution refactoring and bug detection .
many tools and techniques for detecting clones have been studied .
they use a variety of approaches based on raw text lexical tokens syntax trees metrics or graph based structures sometimes combined .
the wide variety of approaches has led to many comparative studies permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.of detection techniques .
it was widely believed that cloned code is a code smell and many empirical studies of clone properties have investigated di erences between cloned and non cloned code.
unfortunately all these previous studies su er from an effect we term the confounding con guration choice problem .
that is the validity of results on the properties of clones are threatened by the confounding e ect of the con guration choice how do we know that di erences observed are related to the properties of clones rather than the properties of con guration choices?
similarly di erences observed in comparative studies may merely be a manifestation of the con guration choice adopted in the study for example by using di erent con gurations for the minimal clone size.
we studied the confounding con guration choice problem by surveying the clone detection literature and report the results in this paper as a motivation for our work.
our survey revealed that of software clone papers from the clone literature repository include an empirical experiment of which explicitly comment on problems arising from the e ects of the confounding con guration choice problem.
we suspect that others may be a ected but have not commented explicitly on it in their work.
in order to ameliorate the confounding con guration choice problem we introduce a search based approach to nd the con gurations for clone detection techniques that yield maximal agreement.
this is the rst time that search based software engineering sbse has been used as a way to augment the robustness of an empirical study of software engineering.
recent work on sbse has considered other forms of parameter tuning for data mining and traceability .
whereas these two recent contributions seek to help the tools end users we seek to aid empirical software engineering researchers evaluation of the approaches the tools implement.
our goal is to provide an additional approach to experimental rigour.
we believe that this search for suitable parameter con gurations will nd other applications in empirical software engineering.
we implemented our approach as a desktop application evaclone.
we also implemented a cloud based parallelised version called cloudevaclone.
we used cloudevaclone to conduct the large scale empirical study needed to evaluate our approach the largest hitherto reported in the literature.
the paper makes the following four primary contributions justi cation and motivation a detailed review of the literature that exposes the concern repeatedly expressed by previous experimenters regarding the threats arising from the confounding con guration choice problem.
c acm .
this is the authors version of the work.
it is posted here by permission of acm for your personal use.
not for redistribution.
the de nitive version has been published in the proceedings esec fse in saint petersburg russia.
and cloudevaclone desktop and cloud based implementations of our search based solution to the confounding con guration choice problem on which we report and which we make available to the research community.
empirical evaluation an empirical study the results of which show that default con gurations perform poorly as a choice of con guration for clone experiments.
our approach produces signi cantly better con gurations thereby reducing the confounding con guration choice problem.
optimised con gurations the con gurations found in the empirical evaluation can be used for future agreementbased clone evaluations without running evaclone.
actionable findings failure to consider confounding congurations compromises the scienti c ndings of empirical studies of clone detection.
future studies of clones can use cloud evaclone to nd appropriate con gurations.
the rest of the paper is organised as follows section presents a focussed review of empirical clone studies demonstrating the importance of the confounding con guration problem and the need to cater for confounding e ects in clone tool agreement studies .
section introduces the evaclone tool and its cloud virtualised sister cloudevaclone.
section describes the experimental methodology we adopt for our empirical study of cloudevaclone applied to the clone detection agreement problem.
section presents and discusses the empirical study and section concludes.
.
background and motiv ation the motivation for our work is that there is a problem at the very heart of the way in which clone evaluation has taken place in the literature the con gurations adopted are often arbitrary or unspeci ed yet con guration choices have a signi cant impact on the behaviour of the tools compared.
the scienti c justi cation for our claim rests on two kinds of evidence a detailed review of the literature and the presentation of empirical evidence that con guration choices can lead to signi cantly di erent results.
in this section we summarise the results of the literature review.
the remainder of the paper is concerned with the evidence that the con gurations have a signi cant impact on behaviour and the introduction of our approach to overcome the di culties that this imposes on any attempt at rigorous empirical evaluation.
we reviewed the papers on clone analysis management and detection available at the time of writing in the widelyused clone literature repository .
among these papers we found that papers have no empirical study of clone detection behaviour so our analysis focused on the remaining papers all of which include an empirical study concerning at least one code clone detection tool.
among these papers report that the experimenters are aware that tool con guration parameter selection and threshold settings may have a ected the results reported in the paper.
in particular among the papers that contain a speci c section discussing threats to validity of these papers consider this a problem that needs to be taken into account.
this provides evidence that the research community recognises the problem that we address in this paper.
it is widely believed that the results of any clone experiment will not only depend on the choice of tools studied systems or analysed language but will also depend on the con guration of the tools used leading many authors to attempt to cater for variations and reporting results for multiple clone detection tools.table categories of multiple clone tool studies category cases papers totalagreement disagreementuse the other tools to evaluate the given clone detection tool31 .
.
compare how results are di erent from detection tools10 .
select the best tool for the analysis task2 .
othercasesuse the union of the clone detection results5 .
.
only compare the execution time between di erent tools5 .
12number of publications yearonly one tool more than one tool one tool but plan to use more tools figure number of tools used in previous work as can be seen from the analysis of the literature in figure after more and more papers have paid attention to multiple clone detection tools.
in total papers have used multiple tools while a further papers used a single tool but reported that the authors planned to use multiple tools in their future work to improve result validity.
summary details concerning the papers that used multiple clone tools in their experiments are presented in table .
as the table reveals of these papers papers in total are concerned with the analysis of the agreement or disagreement among the results produced by the di erent clone detection tools studied.
for all of the papers the con guration of the tools will be of paramount importance.
table shows the choices of approach to con guration adopted by each of the papers.
there are two cases either the paper compares the authors owntool against other tools or the paper is an empirical study using a set of other tools with no own tool .
our survey revealed six distinct styles of approach to handle the confounding con guration choice problem in these studies.
table lists these six approaches in increasing order of rigorousness according to the degree to which the confounding e ect is accounted for in the experiments.
therefore those entries to the bottom right of table can be regarded as the most rigorous .table approaches to the confounding con guration choice problem in clone comparison papers other toolstotalund arb def jus var own toolsn a und arb def jus var total the entries in table have the following meanings .n a no own tool is used.
.unde ned con gurations are not reported.
.arbitrary con gurations are reported but with neither justi cation nor explanation.
.default the tools default con gurations are used.
.justi ed con gurations are reported together with some explanation as to why they have been selected.
.varied several di erent con gurations are used to attempt to cater for confounding con guration e ects.
as table reveals many authors simply use defaults while very few attempt to experimentally cater for the potential confounding e ects of parameter choice.
the clone detection community does recognise this issue.
indeed it is frequently commented upon in the literature.
for example nguyen et al.
who evaluated the performance of their tool jsync comparing it to deckard and ccfinder warn even though we ran jsync with di erent thresholds in comparing we used the default running parameters for ccfinder and deckard thus their results might not be as good as those with tuning for each system .
kim et al.
also compared their tool mecc to deckard ccfinder as well as the pdgbased detector adding the caveat we use their default options.
however careful option tuning may allow these tools to detect more type or type clones .
not all papers are concerned with the introduction of a new clone detection tool.
several empirically evaluate the e ects that clones have on software engineering activities.
however all such empirical studies are a ected in precisely the same way as the tool evaluation studies.
for example hotta et al.
investigated the e ects of clones on software evolution but were compelled to include a similar warning about the confounding e ects of con guration choices on their ndings warning the reader that in this empirical study we used default settings for all the detection tools.
if we change the settings di erent results will be shown .
the clone research community is not complacent about the confounding con guration choice problem it is merely that no approach has been found to ameliorate its e ects and thereby to provide a more rigorous approach to empirical clone studies.
this is the problem addressed by this paper.
ideally any clone related study would compare against a gold standard i.e.
an oracle that knows whether code is cloned.
however such an oracle is not available.
there have been attempts to create benchmarks but even the largescale bellon study has only created a small sample of con rmed clones.
moreover even experts can often not agree on whether something is a clone.
as a result authors of empirical studies of cloned code use clone detectors themselvesas oracles and accept their inaccuracy.
using multiple clone detectors in such studies improves on this it is very likely that something is actually cloned if all used tools agree that it is a clone and it is very likely that something is actually not cloned if all tools agree that it is not cloned.
we introduce a search based approach to determine the con gurations from the space of all con guration choices that maximises tool agreement for a set of tools on a set of systems.
such an agreement optimised con guration avoids the problem that di erent tools might disagree about whether or not a line of code is cloned simply because of the con guration parameter choices.
where tools disagree on the agreement optimised con guration the experimenter can have a stronger con dence that this is due to the e ect studied and not some coincidence of the parameter settings.
we believe that this work will put clone evaluation on a more rigorous and rm footing.
.
the ev aclone solution in this section we introduce evaclone our approach to addressing the confounding con guration choice problem and its implementation.
we then brie y describe the sister version which is parallelised for cloud deployment.
.
evaclone given a clone detection tool set ts ft1 tng a set of subject systems ss fs1 smg the clone detection tool con guration problem is to automatically search for con guration settings x fortsin the con guration search space subject to maximise f ts x ss x2 the tness function fcan be de ned according to the speci c clone analysis task.
in this paper we report on the application of evaclone using tness functions that seek to maximise tool agreement since this is important for many of the empirical studies in the literature as revealed by the review in section .
however the choice of tness function is a parameter to our approach and so evaclone provides a framework for optimising con gurations of clone detection tools.
our tool uses a genetic algorithm ga to search the con guration space guided by the chosen tness function.
figure depicts the evaclone architecture.
phase initialisation generates a randomised initial population of con gurations.
this population is seeded with defaults to give the existing default a fair chance of selection.
the computational expense of the approach resides in phase fitness evaluation since this requires that each tool is executed with each con guration from the population on each subject system.
the tness function gives a value to each con guration by evaluating the level of agreement among the tools for that speci c con guration.
this phase includes the conversion of the clone detector output into a general common format gcf any output in a proposed standard format rcf can be converted to gcf.
the genetic operations used in phase are described in section .
.
the termination condition is satis ed when no tness improvement occurs for thirty generations or when the maximum allowed budget generations in our study is exhausted.
the nal recommended con guration is the one found with the highest tness over all generations.initialisation genetic operationspopulationsubject systemsclonedetectiontoolsgcfconversionfitness analysisrcfxmltextgcfformatterminationconditionfinal recommended configurationyesnoconfigurationsettings1fitness evaluation 234figure evaclone architecture .
a parallelised cloud deployed evaclone evaclone needs to run multiple clone experiments on multiple tools over multiple subject systems to nd suitable con gurations.
depending on the subject systems size and the performance of the clone detection tools it can take from seconds to minutes to evaluate one individual in one experiment.
each experiment uses a population size of and runs up to generations.
furthermore in order to evaluate our approach we need to perform inferential statistical testing on the results required for evaluation of evaclone con gurations .
this statistical testing requires multiple experimental trials for each experiment.
in this paper we used such repeated trials for each experiment on which we report.
on a conventional desktop machine this would have taken a total time of approximately years which is clearly infeasible.
in order to cope with the computational time required we developed a parallel version of evaclone which can be deployed in the cloud thereby allowing exible control of computational time.
our approach also allows the evaclone user to trade computational cost for execution time.
we call this parallel virtualised version cloudevaclone .
using cloudevaclone s parallel computation spread over many virtualised machine instances we were able to reduce computation time for all experiments reported on in this paper from a minimum possible time of years on a single desktop to weeks in the cloud .
the virtualisation required to implement cloudevaclone also facilitates perfect facsimile replication of our results.
that is we are able to make available the entire virtualised execution image for our experiments to other researchers.
our image can be re deployed and re executed by others thereby avoiding the confounding e ects due to di erent machines operating systems and platforms that bedevil empirical replication attempts for software tool studies.
using our approach authors of future studies can thus have greater con dence that they are comparing like with like .
cloudevaclone consists of two tiers a server tier and a client tier the architecture of which is depicted in figure .
the server tier maintains a database and a task list.
the database stores the previous evaluated tness values thereby memoising previous results to avoid the cost of re computation.
the task list maintains a list of current evaluation tasks which is used to distribute the evaluation cost in parallel.
the client tier runs two kinds of instances master instances and slave instances.
each master instance runs one experiment with a parallel ga algorithm.
serverclient cloud database fitness tasklist slavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesslavesmastersmastersmastersfigure cloudevaclone architecture for each generation the algorithm rst searches the database for the tness of the current individual.
if no record is found the algorithm creates an evaluation task and sends it to the task list.
slave instances repeatedly poll the task list for unassigned tasks.
if a slave nds tasks in the list the rst task is popped from the list and the slave will evaluate the task and send the tness value back to the database in the server tier.
since we are searching the space of all possible con gurations of each tool we are also implicitly testing the clone detection tools very thoroughly in fact .
as a result of this rigorous testing it can happen that cloudevaclone nds congurations for which a tool either crashes or non terminates these tools are research prototypes and not robust industrial strength tools after all .
to avoid non termination of a clone detection tool resulting in overall non termination of the whole approach both evaclone and cloudevaclone allow the user to set a conservative threshold execution time after which execution is automatically aborted.
we performed an initial sensitisation study which suggested that when a tool runs for more than minutes on a clone detection instance it tends to run for at least several further hours without result so we set our cut o threshold at minutes.
cloudevaclone is designed to be exible the master and slaves do not interact with each other directly.
this design means that subject to the trade o between the user s time and budget master and slave instances can be added and or removed from a cloudevaclone execution at any time without the need to restart the experiment.
for the empirical study reported in this paper we deployed cloudevaclone on amazon s elastic compute cloud ec2 .
three master instances were used running three experiments at a time and two hundred slave instances were used to perform tness evaluations.
all instances were run on ubuntu .
lts systems.
the speci cations of each instance are ec2 compute units with .
gb memory and gb instance storage.
in total one or other clone detector was executed a total of .
million times.
memoisation was deployed in of cases thereby saving this proportion of the execution time.
since the clone con guration search space is approximately 1017we cannot expect higher gures for memoisation but the saving it represents is valuable since it directly corresponds to reductions in cloud computation costs.
though it is executed in the cloud cloudevaclone is merely a parallelisation of evaclone it produces the same results and has the same functional properties including memoisation .
cloudevaclone s master slave parallelisation simply allows the non functional properties of cost and execution time to be traded o against one another in a fully exible manner.table the bellon suite of eight benchmark subjects for clone detection research used in this paper subjects sets subjects full name files loc sloc description c setweltab weltab election tabulation system cook cook le construction tool snns snns simulator for neural networks psql postgresql database management system java setjavadoc netbeans javadoc javadoc package in the netbean ide ant eclipse ant ant package for the eclipse ide jdtcore eclipse jdtcore jdt core package for the eclipse ide swing j2sdk1.
.
javax swing java sdk .
.
swing components table the clone detection tools used tool approach support language type pmd s cpd .
token c c c java iclones .
token java c c ada ccfinder .
.
.
token c c java cobol conqat .
token independent simian .
.
.
text independent nicad .
parser c c java python .
empirical ev aluation the choice of tness function clone tools to be con gured and subject systems to which these tools will be applied are all parameters to our approach.
however we wish to provide a concrete evaluation.
therefore we chose a tness function detection tool set and subject system set to address the problems of rigorous empirical evaluation of clones in experiments for which clone detection agreement matters.
as shown in section such con gurations have proved to be pivotal in removing the confounding con guration problem for at least previous empirical studies.
therefore such maximally agreeing con gurations are also likely to remain important in future empirical clone evaluation work.
.
clone detectors and subject systems used for our evaluation we used six clone detectors all of which are commonly used in clone analysis work.
table presents summary information about each of these tools.
for the systems on which to apply the tools we adopted the widelyused bellon benchmark .
these choices were made to maximise the chances that the speci c con guration results reported in this paper will be a useful contribution to the community in future work on clone evaluation.
summary information about the subject systems used is presented in table with data about the systems sizes in lines of code physical source lines and number of les .
the subject systems are divided into two sets a set of subject systems written in c and a set of systems written in java.
.
configuration of the genetic algorithm clone detection researchers have a consensus that clone fragments containing fewer than lines are meaningless .
search based tools such as evaclone and cloudevaclone are well known to exploit search spaces to nd solutions that maximise tness irrespective of such domain speci c concerns unless they are factored into the search problem .
therefore we constrained the search to a range of minimum lines minline of a clone fragment from to .
for conqat simian and nicad the minimum length of clones is measured in lines so clones no smaller than minline are output by these tools.
however for pmd iclones and ccfinder the minimum length is measured in tokens.
there is no simple correspondence between tokens and lines a linemay contain few or many tokens.
to solve this compatibility problem between tools we set the range of minimum tokens mintoken to .
the lower bound of mintoken is su ciently small that it ensures that clones smaller than minline are possible.
should any clone reported by any tool contain fewer than minline lines we remove it using a post processing lter applied to all tools.
thus the minline setting is enforced over all tools.
each con guration setting is coded as an integer in the range speci ed in table which also shows the nal congurations reported by cloudevaclone which are discussed in section .
for example the chromosome for the default con guration is represented as the vector of values h50 i though this is merely one element of the con guration search space .
we wrote a decoding driver script for each clone detection tool.
the driver converts the vector of values produced by evaclone and cloudevaclone to the required format used by each of the clone detection tools.
our genetic algorithm uses the tournament selection method to create mating pools.
a single point crossover operator and a single point mutation operator is used to reproduce o springs.
the crossover rate is .
and the mutation rate is .
.
.
fitness functions the tness function is another parameter to our approach and must be carefully chosen.
for the empirical evaluation we focus on the agreement of clone detectors.
as discussed the more the clone detectors agree the more trustable are their results.
thus the goal is to nd con gurations that lead to maximal agreement of clone detectors.
given a con guration the tness function returns a value indicating the degree of agreement of the clone tools on the subject systems for the given con guration.
we distinguish between two use cases for the tness function depending upon whether it is applied to a set of systems seeking agreement on all of them with a general tness or a single subject system with an individual tness in which case the clone tools should agree only on that speci c system of interest individual task given a set of subject systems ss fs1 smg for a system sk2ss search for a better con guration xfor tool set tscontainingntools to get the maximum agreement of clone detection results on sk.
the individual tness function for the individual task is fi ts x sk pn i i agreedloc n pn i 1agreedloc general task given a set of systems ss fs1 smg automatically search a better con guration xfor tool set tsto get the maximum agreement of clone detection results on all the subjects in ss.
the general tness function for thegeneral task is based on equation and de ned as table best general and individual con gurations found by cloudevaclone for the clone detection tools tools parameter name rangecon guration settings default general individual speci c to each bellon suite c setjava setwel tabcook snns psql java docant jdt coreswing tools minimum clone size settings applicable to several tools pmd iclones ccfindermintoken conqat simian nicadminline tool technique speci c con guration settings pmdpmdignoreliterals pmdignoreidenti ers iclones minblock ccfinder tks simianignorecurlybraces ignoreidenti ers ignoreidenti ercase ignorestrings ignorestringcase ignorenumbers ignorecharacters ignorecharactercase ignoreliterals ignoresubtypenames ignoremodi ers ignorevariablenames balanceparentheses balancesquarebrackets nicadmaxline upi .
.
.
.
.
.
.
.
.
.
.
.
.
blind abstract fg ts x ss mx sk2ssfi ts x sk in these tness equations agreedloc represents the number of lines reported as cloned by exactly itools.
for example agreedloc is the number of lines reported as cloned by tools agreedloc represents the number of lines reported as cloned by only a single tool.
higher weight is given to those agreedloc values with larger i by multiplying agreedloc byi.
this ensures that the larger agreement on the clone detection results among the tools the higher the tness.
the individual tness function is based on the following observation we focus only on lines that are reported by at least one tool as cloned.
if we draw a histogram that shows for each such line how many tools report this line as cloned we want to maximise the area covered by the histogram.
the sum of all agreedloc is the number of lines reported as cloned by at least one tool.
thus the denominator is the maximal achievable area.
the numerator is the actual area covered.
the general tness function is computed from the individual tness for each system it is simply the average of the individual tness functions.
.
research questions we use a large scale empirical study of cloudevaclone to address the following research questions rq1 default agreement baseline how much agreement can be obtained using the default con guration of clone detection tools?
we ask this question to establish the validity of our approach if it turns out that the default con gurations produce good agreement then our approach would notbe needed.
we also need this result to provide a baseline against which to compare the results from our approach how much better are they than the default con gurations that would otherwise be used were there no alternative.
rq2 optimised general agreement how much agreement can our approach nd among all tools using the general tness function which seeks to nd agreement on all subject systems?
this question establishes how useful our approach is at nding new default con gurations for sets of tools and subject systems.
of course should it turn out that cloudevaclone does indeed produce signi cantly better con gurations than the currently used defaults then as a byproduct we shall also have a new default con guration for these tools.
rq3 optimised individual agreement how much agreement can our approach nd among all tools using the individual tness function which seeks to nd agreement on each individual subject system in isolation?
if we can nd even better con gurations for individual systems then this will be useful for researchers who wish to study the properties of clones arising from the systems studied themselves rather than the detection techniques.
by choosing a di erent con guration for each system a researcher can reduce the confounding e ect that a single con guration may have on di erent detection characteristics for di erent systems.
rq4 accuracy how much will recall and precision change when the optimised con gurations are used?
clearly a change in a tool s con guration will impact its recall and precision and usually there is a tradeo between them.
conguration choices are intended to allow the user to prefer recall over precision and vice versa.
it is thus important to know if the optimisation for agreement prefers recall or precision.iagreedloc weltab cook snns psql javadoc ant jdtcore swing f 1percentage of loc number of tools agreeweltab cooksnns psqljavadoc antjdtcore swing figure default con gurations achieve poor agreement on clones .
results and discussion while rq1 can be answered by simply running the tness evaluation component of evaclone on a desktop the experiments for rq2 and rq3 required cpu hours.
this would have taken approximately years of continual execution on a conventional desktop machine.
therefore we used cloudevaclone to parallelise the computation and thereby render the execution time manageable.
the signi cant computational e ort involved is due to the need to evaluate our approach thoroughly.
a future user of cloud evaclone would require only a tiny fraction of this computational e ort to nd suitable con gurations.
.
rq1 default agreement baseline to establish how much agreement can be obtained with the default con gurations as our baseline we compute the agreement and tness values for the individual subject systems as shown in the table on the left hand side of figure .
for each of the eight systems the table shows the number of lines for which exactly itools agree that the line is cloned.
in addition it shows the number of lines that at least one tool reports as cloned pagreedloc and the tness value f. for example weltab has out of lines where all six tools agree that the line is cloned and lines where only a single tool detects the line as cloned.
most of the time all six tools agree for the weltab system and so consequently the tness value fis high for weltab .
however weltab is unusual all other systems have much lower agreement and tness values between and .
in particular the number of lines where only one of the tools detected the line as cloned is very large for the other systems.
the histogram on the right of figure shows the agreement values from the table on the left as percentages of all lines reported as cloned.
the gure con rms weltab as outlier and in most cases only one or two tools agree that a line is cloned.
thus the answer to rq1 is in their default con gurations clone detection tools have a low agreement on which lines are cloned.
however it could be the case that the con gurations actually have a low impact on the results perhaps the low agreement observed is due to the fundamentally di erent clone detection techniques the tools implement.
to estimate the impact that the con gurations actually have on the agreement we compare randomly generated con gurations with the default con guration.
for both sets of c and java systems random but valid con gurations are generated as a sample of the space of all valid con gurations.
each generated con guration is applied to the six detection tools which are run on each of the eight subject systems.
c set java set weltab cook snns psql javadoc ant jdtcore swingfitness improvement ratio figure default con gurations perform poorly the tness values of the generated con gurations xare then compared with those of the default con guration xdby computing their di erence as a tness improvement ratio of xtoxd fir x f ts x s f ts xd s f ts xd s in equation sis a set of subject systems which could be a singleton set in which case it applies to a single system .
the equation can be used to asses tness improvement ratios for both the general and the individual tness functions.
figure shows the boxplots for the computed tness improvement ratios.
the two general sets c and java are to the left of the gure while the individual systems are to the right.
as we can see from the gure random con gurations almost always cause a lower agreement than the default con guration ranging up to almost lower tness values snns .
this shows that the agreement between clone detection tools is highly sensitive to their con gurations.
however a small number of random con gurations can actually improve the tness and thus increase the agreement as can be seen for cook and the set of java systems.
therefore we conclude that though default con gurations favour agreement overall compared to purely random congurations there do nevertheless exist con gurations that cause greater agreement between the results of clone detection tools than with the default con guration.
.
rq2 optimised general agreement given that the default con gurations cause low agreement and that randomly generated con gurations can increase agreement we use cloudevaclone to search for con gurations that maximise agreement.
this experiment uses the general tness function de ned in equation to seek a conguration for the c and java set that maximise agreement.
in order to support inferential statistical testing cloudevaclone is executed times.
the tness values for the c set g java set g weltab g weltab i cook g cook i snns g snns i psql g psql i javadoc g javadoc i ant g ant i jdtcore g jdtcore i swing g swing i fitness improvement ratio figure agreement improvement over defaults for general and individual con gurations con guration generated by each run and each subject system are compared with those from the default con guration.
the comparison is done based on the tness improvement ratio equation as was used to provide an answer to rq1.
figure shows the boxplots for the achieved improvements.
the improvements of the general tness for rq2 are marked with a g while the individual ones are marked with an i discussed with rq3 .
the gure shows improvements for the java up to .
and c set up to .
as well as for the individual systems.
it is interesting to note that the improvements for the java systems are larger than for the c systems.
moreover weltab proves to be an outlier again.
to further con rm that the optimised con gurations tend to have higher tness values than default con gurations wilcoxon signed rank tests were performed.
for each system tness value pairs are compared.
each pair consists of one tness value for the general con guration from each ga run and the value for the default con guration.
the null hypothesis is that the tness values for the con gurations we nd are not signi cantly di erent from that of the default con guration.
for all systems the z score was .
and the p value was .
three decimal places conforming the observation from the box plots that our approach signi cantly outperforms the default con gurations.
in fact every one of the executions of cloudevaclone produces a better con guration.
we also computed the e ect size r in the standard way.
that is for a sample size n the value of ris computed from the z score r abs zp n .
for all systems the e ect size reported by this test is large according to cohen s e ect size criteria which suggest .
to .
is a small e ect around .
is a medium while values above .
denote large .
therefore we answer rq2 as follows cloudevaclone nds con gurations that are signi cantly better than the current default con gurations and with a large e ect size.
the con gurations found by the best of the cloudevaclone runs are reported in table columns and .
it is interesting to observe the di erences in con gurations for the c and java system sets which re ects the di erences in coding styles and their impact on clone detection.
.
rq3 optimised individual agreement by answering rq2 new general con gurations for c and java systems have been established.
as we have seen there is a di erence between c and java systems maybe there are even larger di erences when cloudevaclone searches for optimised con gurations for the individual systems.
rq3 addresses this question using cloudevaclone with the indi table individual con gurations signi cantly outperform the general con gurations subjects z score p value signi cant?
re ect size weltab .
.
yes .
large cook .
.
yes .
large snns .
.
yes .
large psql .
.
yes .
large javadoc .
.
yes .
large ant .
.
yes .
medium jdtcore .
.
yes .
large swing .
.
yes .
medium vidual tness function de ned in equation and executing cloudevaclone on each system in isolation to nd optimised individual con gurations.
figure shows the tness improvements for the individual systems i side by side to the improvements previously achieved by the general con guration g .
the boxplots show that the individual optimisations not only lead to even greater agreement but also that the range of improvements is smaller than for the general optimisation.
again weltab is found to be an outlier.
to con rm that individual optimisations tend to generate higher tness values than the general con gurations wilcoxon signed rank tests are performed again.
the null hypothesis is that tness values of the general con gurations are not signi cantly di erent from the ones for individual con gurations.
table shows the results are statistically signi cant in all cases and with high e ect sizes in all cases except antand swing .
therefore we answer rq3 as follows cloudevaclone can nd even greater agreement using the individual tness function applied to each subject system in isolation.
to illustrate the improvements cloudevaclone can provide figure compares the tness values and cumulative agreedloc s for the current default and cloudevaclonereported general and individual con gurations for the largest two systems psql and swing .
in this gure the columns located above the horizontal axis legend denote the lines of code reported as cloned by at least tools i.e.
agreedloc agreedloc while the columns above the legend potential cloned lines denote the number of lines detected as cloned by at least one detection tool i.e.p6 i 1agreedloc .
as can be seen the individual tness gives the highest degree of agreement while the currently used defaults o er the worst agreement regardless of the number of tools from which we seek agreement.psql .
.
.
.
.
.
.
fitness evaluationfitness value potential cloned lines k40 k60 k80 k100 k120 k140 k agreed cloned lines of codeindividual general default swing .
.
.
.
.
.
.
fitness evaluationfitness value potential cloned lines k40 k60 k80 k100 k120 k140 k agreed cloned lines of codeindividual general defaultfigure agreement levels for the two largest systems psqland swing .
rq4 accuracy whenever a new tool is introduced the authors understandably want to investigate the performance of the new tool hoping that it will outperform some competitor or stateof the art alternative tool or technique.
in the literature this is typically achieved using a gold standard of human assessed clones.
the standard set that has emerged as a benchmark in many studies is the bellon benchmark .
using this benchmark authors measure and compare the precision and recall of detection tools.
as the tool s con gurations allow them to favour recall over precision and vice versa any comparison is only valid for one speci c conguration.
the optimisation for agreement has used the con guration space and it is important to know how this impacts precision and recall of the individual tools.
there are three accuracy criteria with which the impact of the optimised con gurations can be studied .the number of clone candidates higher agreement can be achieved by increasing the number of tools agreeing that a line is cloned or by increasing the number of tools agreeing that a line is not cloned.
for the former one can expect more clone candidates and for the later one can expect fewer clone candidates.
.recall if higher agreement is due to a larger number of clone candidates then a higher recall can be expected.
.precision if higher agreement is caused by fewer clone candidates then a higher precision can be expected.
the rst criteria can still be studied without a benchmark but the other two criteria will use bellon s benchmark which estimates precision and recall by comparing reported candidates against a small number of manually con rmed clone pairs.
bellon used two possible matchings of clone pairs to each other good and ok see for an explanation we will only use the ok matching.
figure shows the three criteria for the two largest systems psqlandswing .
due to space restrictions we only show results for two systems but we will discuss the results for all systems.
the rst observation we can make is that the optimised con gurations cause more candidates to be reported for all eight systems and all ve clone detectors neither the individual nor the general optimised con gurations have ever lead to a lower number of candidate pairs.
in out of cases the number of reported candidates more than doubled.
sometimes the number of reported candidate pairs exploded as can be seen in figure for ccfinder and nicad onpsqland for pmd on swing .
the explosion is an artefact of the bellon framework if a tool reports a large clone class i.e.
a clone with many instances then every pair of clones in that class will be reported as a candidate pair leading to a quadratic explosion.
the explosion is the reason why simian has not been included in the nal evaluation as the number of generated candidate pairs was too large to process.
with such an increase of candidate pairs one expects an increase in recall and a drop in precision.
this can generally be observed in the reported precision and recall as computed by the bellon framework.
there is one situation with a drop in recall the bellon framework reports a lower recall for iclones applied to weltab with the individual optimised con guration.
the situation is di erent for precision and there are a few cases where the precision is increased the individual optimised con guration causes a higher reported precision for pmd on cook and psql for ccfinder on snns and for nicad on javadoc andswing .
the general optimised con guration causes a higher reported precision in the same cases except for pmd on cook.
this can also be seen in figure for pmd on psqland for nicad on swing .
because the optimised con gurations increase precision and recall at the same time it may be the case that the optimisation found better con gurations for pmd ccfinder and nicad.
however this may be purely coincidental due to the limitations of the bellon benchmark.
overall one can answer rq4 with if cloudevaclone is used to maximise agreement between clone detectors recall will be favoured over precision and more candidates will be reported.
however there may be situations where a higher precision is preferable over recall.
in such situations one can simply choose a di erent tness function as the tness function is a parameter to cloud evaclone.
.
actionable results from this work we have seen that many empirical studies compare clone tools and techniques section .
however there remain important scienti c concerns expressed repeatedly in the literature that current practices are potentially awed due to the confounding con guration choice problem.
we have seen that default settings widely used in previous empirical studies o er a poor solution to the problem rq1 and that evaclone can produce signi cantly better con guration choices.
the primary actionable nding from this research is that future studies of clones can use cloud evaclone to nd appropriate con gurations for their studies.
1e 06number of candidate pairspsql default individual general 1e 06number of candidate pairsswing default individual general .
.
.
.
.
.
.7recall .
.
.
.
.
.
.
.
.9recall .
.
.
.
.
pmd iclones ccfinder conqat nicadprecision .
.
.
.
.
.
.
.
.
pmd iclones ccfinder conqat nicadprecisionfigure results from applying bellon s framework on psqland swing evaclone and cloudevaclone their source code and all of the data used and reported in this paper can be found at the papers companion website1.
we will also release cloudevaclone including our experimental environment as an amazon machine image ami which can be used to create a virtual machine within the amazon elastic compute cloud ec2 thereby facilitating replication.
authors can also use evaclone with a di erent tness function to tune con guration choices for other problems not simply those involving clone tool agreement as reported upon here .
.
limitations and threats to validity the subject systems used in this paper are all open source and not necessarily representative of all software systems.
however they do constitute a widely used benchmark set so the results reported here have actionable consequences for the clone detection community.
the clone detection tools also cannot be regarded as representative of all clone detection tools though we show that our approach performs signi cantly better than the currently used default settings for these techniques we cannot necessarily predict its e ect on other techniques.
however we have used techniques that represent several di erent widelyused approaches to clone detection including text tokenand tree based approaches .
we therefore have some cause for con dence that cloudevaclone may continue to prove useful for future as yet unimplemented tools and techniques.
note that the results are impacted by the approaches e.g.
including a pdg based approach will change the outcome.
moreover our tness function favours recall over precision and is focussed on agreement there may be situations where disagreement is more interesting.
approach to handling internal and construct validity is standard best practice for these forms of experiments we have reported results for repeated runs using nonparametric statistical testing for signi cance and have also reported results for the e ect size.
we set the alpha level chance of a type i error at .
which is widely regarded as a standard choice.
we used a sample size of which is guaranteed to be su cient to avoid type ii errors in all experiments since all the wilcoxon tests reported p .
the results reported in rq4 for recall and precision cannot be generalised due to the constraints of the bellon framework.
it would require an expert validating the candidates reported by each tool on each system for all three con gurations default individual general .
with .
million candidate pairs even checking of them is beyond being feasible.
.
conclusion we have introduced an approach to nding con gurations for clone detection techniques that can be used to place empirical studies of clone detection on a more rigorous and rm footing.
our approach ameliorates the e ects of the confounding con guration choice problem in clone studies.
we demonstrated that this problem is an important one widely recognised in the clone detection literature and for which there was hitherto no satisfactory solution.
we evaluated our approach with a large scale empirical study which revealed that it can nd signi cantly better con gurations than the defaults and with a high e ect size.
we demonstrated that the current research practice of using defaults settings in empirical studies has to be changed.
our approach can be used to tune settings in clone detection experiments for speci c subject systems.
.