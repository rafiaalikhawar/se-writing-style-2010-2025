discriminating influences among instructions in a dynamic slice vijay krishna palepu and james a. jones university of california irvine vpalepu jajones uci.edu abstract dynamic slicing is an analysis that operates on program execution models e.g.
dynamic dependence graphs to support the interpreation of program execution traces.
given an execution event of interest i.e.
the slicing criterion it solves for all instruction execution events that either a ect orare a ected by that slicing criterion and thereby reduces the search space to nd in uences within execution traces.
unfortunately the resulting dynamic slices are still often prohibitively large for many uses.
despite this reduction search space the dynamic slices are often still prohibitively large for many uses and moreover are provided without guidance of which and to what degree those in uences are exerted.
in this work we present a novel approach to quantify the relevance of each instruction execution event within a dynamic slice by its degree of relative in uence on the slicing criterion.
as such we augment the dynamic slice with dynamic relevance measures for each event in the slice which can be used to guide and prioritize inspection of the events in the slice.
we conducted an experiment that evaluates the ability of existing dynamic slicing and our approach using dynamic relevance to correctly identify sources of execution in uence and state propagation.
the results of the experiment show that inspections that were guided by traditional dynamic slicing to nd the root cause for a failure reduced the search space by on average .
.
further inspections guided with the assistance of the new dynamic relevance reduced the search space by .
.
categories and subject descriptors d. .
testing and debugging keywords program analysis dependence analysis dynamic slicing .
introduction dynamic slicing is a well known technique that is used for describing program behavior and for several software compermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
.prehension and maintenance tasks.
in use its user e.g.
a developer or another automated analysis technique expresses an interest in an execution event which is referred to as the slicing criterion.
the dynamic slicing approach then computes the set of all instruction execution events1that in uence or are in uenced by the slicing criterion.
the result of the analysis is a dynamic slice and is comprised of a undi erentiated set of either static instructions or dynamic instruction execution events that are in uential for the slicing criterion.
such dynamic slices could support development tasks such as debugging e.g.
for which the criterion may represent an observed error state at a breakpoint or change impact analysis e.g.
for which the criterion may represent points in an execution that new logic may be introduced.
despite its importance and widespread use in software engineering tools and techniques there exists a general consensus that dynamic slices are often intractable for programmer inspection and navigation due to their size and complexity.
as examples latoza and myers note that developers comprehend program behavior by navigating dependence relations within a dynamic slice that can often be prohibitively challenging and zhang et al.
found backward dynamic slices as large as of the program execution trace and forward dynamic slices as large as of the traces.
moreover such resulting dynamic slices are typically presented an unordered sets of instruction instances without any auxiliary information that may assist the developer or client analysis in their interpretation.
and although some existing work has been applied to pruning dynamic slices to further reduce their size the result is still a set of instances without information to help assess the relative in uence of each such instruction instance on the criterion.
given the fundamental di culties of size and complexity in inspecting dynamic slices to understand program behavior in this work we propose a mechanism that is able to di erentiate the degree of in uence between instructionexecution events.
as a result slicing users can perform prioritized inspections of the slice to more quickly identify most relevant events and as such further reduce the search for in uences.
we also conducted an experiment to determine the degree to which the additional relevance information can further support dynamic slice interpretation and 1aninstruction execution event is a speci c instance of an execution of an instruction within a single execution of the program.
for example an instruction may be executed many times during an execution each such instruction execution constitutes an instruction execution event.
we also refer to these as instruction instances .
search reduction.
our results found that although dynamic slicing was e ective in reducing the search for a debugging task on average reducing the cost by .
from the original execution using the additional relevance information to augment the dynamic slice substantially further reduced the search on average reducing the cost by .
or an additional cost savings of .
.
the main contributions of this work are a new measure that we are calling dynamic relevance that represents the degree to which an instruction s execution distinctively in uences the slicing criterion.
a novel augmented model of a dynamic slice that encodes a degree of in uence on the dynamic substantially further slicing criterion i.e.
our dynamic relevance measure for each instruction execution event in the dynamic slice.
these measures may provide valuable information to direct users and client analyses toward instruction execution events that strongly a ect the state at the slicing criterion.
an experimental design that evaluates the ability of dynamic slicing to narrow the search space for rootcause program state infection and further the potential additional bene t of augmenting the dynamic slicing result with dynamic relevance measures.
.
approach in this section we describe the dynamic relevance measure and the approach to generate it.
the rst three steps are shared with traditional dynamic slicing.
first we instrument a program to record an execution trace that captures all instruction execution instances along with their reads and writes to memory.
then using control dependence and data dependence analyses we compute the dynamic dependence graph for the execution trace.
next we perform a traversal of the graph while tracking memory objects and their de nitions and uses.
finally we perform an analysis to determine the degree to which each instruction instance in the dynamic slice is relevant to the slicing criterion.
motivating example.
in figure we present a simple program that simulates three temperature readings from a thermometer sensor that gives one erroneous reading.
the program reads the sensor the values records them sorts them and computes the mean temperature of the lowest of one two and three readings.
we created and use this simple example program to demonstrate the process and goals of the dynamic relevance measure to augment dynamic slicing.
although the program is simple and the program model depictions are merely representative we nevertheless implemented the example program monitored its execution to gather its execution trace computed its dynamic dependence graph and dynamic slice and calculated the dynamic relevance values for each instruction instance.
despite the need to abstract the full trace graph slice and relevance to t in this paper we provide the actual artifacts of these analyses online.
as shown in the top part of figure we start with analyzing the most basic model of program behavior i.e.
the source code of the software program.
the actual source code for this example is compose of lines of code some of which m1 void main m2 addtemperatureandsort m3 addtemperatureandsort m4 addtemperatureandsort m5 printaverageofbottomtemps m6 printaverageofbottomtemps m7 printaverageofbottomtemps m8 a1 void addtemperatureandsort int temp a2 size size a3 int i size a4 if i size a5 temps temp a6 a7 while i a8 if temps temp a9 temps temps a10 i i a11 else a12 break a13 a14 a15 temps temp a16 g1 global size g2 global int temps p1 void printaverageofbottomtemps int n p2 int sum p3 int i n p4 for i p5 sum sum temps p6 i i p7 p8 print float sum float n p9 source code g1m2a2a3a4a5a15m3p2p8p5m4m5m6execution tracedynamic dependence graphg1m2a2a3a4a5a15m3p2p8p5m4m5m6dynamic sliceg1m4a2a3a4a5a15p8m5relevance augmenteddynamic sliceg1m4a2a3a4a5a15p8m5figure models of program behavior at each step.
are condensed in the gure .
the source code is processed into an instrumented executable binary that is able to produce execution traces for the software program s execution.
the compiled bytecode les contain executable bytecode instructions.
as depicted in figure execution traces represent a long sequence of instruction execution instances represented by nodes in the gure i.e.
each distinct runtime execution of each static instruction from the program and each static instruction may be executed multiple times throughout the execution.
in our example the execution trace contained instruction execution instances.
we then analyze the execution trace to deduce dependence relations between the instruction execution instances for both control dependence and data dependence.
the result of this analysis is a dynamic dependence graph as shown in figure with directed edges between di erent instruction instances depicted as nodes.
the dynamic dependence graph contains an equal number of nodes as the execution trace for our example program this was nodes that represent instruction execution instances.
in order to nd the root cause of an anomalous output we compute the backward dynamic slice of that anomalous output.
in our example the anomalous output is represented as a higher than usual three day average and the root cause is the erroneous thermometer sensor reading.
as such we use the anomalous print instruction instance as the criteria to prune the dynamic dependence graph by performing dynamic slicing.
as highlighted in figure the dynamic slice is smaller now containing instruction instances from the original in the trace .
to further di erentiate the instruction execution events within the dynamic slice we then augment its constituent instruction execution instances with relevance measures with regard to the anomalous print instruction instance as the slicing criteria.
such relevance measures provide a nuanced view of the dynamic slice drawing attention to those instruction instances over others with high relevance to the anomalous print instruction instance potentially leading to the reading of the anomalous temperature without investigating each of the undi erentiated instruction instances 38in the dynamic slice.
figure depicts instruction execution instances with a higher relevance measures with darker nodes while those with lower relevance measure are indicated with lighter nodes.
when considering all instruction execution instances in the dynamic slice i.e.
nodes the actual root cause thermometer sensor reading is ranked at position out of all instruction execution instances.
the other highly ranked instruction execution instances are also transitive dependencies that strongly and distinctively in uence the anomalous output which may also lead to the root cause.
furthermore when searching among all thermometer readings the erroneous reading is ranked at the position and thus the dynamic relevance measure is able to help pinpoint the root cause infection.
computing dynamic relevance.
the computation of dynamic relevance between instruction instances relies on the observation that some instruction instances in uence fewer instruction instances than others.
consider the instruction instances si tjandvkfor the static instructions s tandv respectively.
the instruction instance sithat exclusively in uences the instruction instance tj is likely to be more relevant to tj than an instruction instance vkthat in uences multiple instruction instances only one of which is tj.
in other words we posit that the instance si is relevant to tj because the sole reason for the execution si ofsis to in uence the forthcoming execution tj of the instruction t. we extend this notion of relevance to instructions instances that are related by direct as well as transitive dynamic in uences as follows.
consider the instruction instances siandtj such that sitransitively in uences tj.
we say that siis highly relevant to tjifsidistinctively in uences directly or transitively those instruction instances on which tjis dependent.
the following steps elucidate the computation of the dynamic relevance of an instruction instance sifor another instruction instance tj where tjis an instruction instance of interest and together tjandsiare part of the dynamic dependence graph g. step .
we obtain the instructions that directly or transitively in uence tj.
a backward dynamic slice with tj as the slicing criterion i.e.
sbak g tj will constitute the instructions that in uence tj.
step .
we obtain all instruction instances that siin uences.
the forward dynamic slice with sias the slicing criterion i.e.
sfwd g si will constitute the instructions that siin uences.
step .
to compute the relevance of sitotj we compare the number of instruction instances in sfwd g si forward slice from si that are also present in sbak g tj backward slice from tj to the total number of instruction instances that are present in sfwd g si forward slice from si .
we denote the relevance of instruction instance sifor another instruction instance tjasdynrel si tj .
dynrel si tj jsbak g tj sfwd g si j jsfwd g si j where tjis the instruction instance of interest i.e.
the slicing criterion siis an instruction instance that has a dynamic in uence ontj i.e.
siis included in the backward dynamic slice oftj dynrel si tj is the measure of relevance of sifortj sbak g tj is the backward slice from tj sfwd g si is the forward slice from si js bak g tj sfwd g si jis the number of instruction instances common to both sbak g tj andsfwd g si and js fwd g si jis the number of instruction instances in sfwd g si if however the instruction instance si whose dynamic relevance measure is being computed is not a part of the backward dynamic slice with tjas the slicing criteria the dynamic relevance measure of siis set to .
in contrast instruction instances that do not in uence directly or transitively any other instruction instance that has no in uence on the slicing criteria would have a dynamic relevance measure of .
with regard to the slicing criteria.
in summation such a formulation of dynamic relevance as stated above penalizes the dynamic relevance measure for an instruction instance if the instruction instance were to directly or transitively in uence any instruction instance that has no forward in uence on the slicing criteria.
in effect for an instruction instance si a increasing number of instruction instances that are in uenced by siand have no in uence on the slicing criteria will decrease the dynamic relevance measure of siwith regard to the slicing criteria.
.
evaluation we evaluated the degree to which the dynamic relevance measure can assist in distinguishing relevant execution events.
as such we conducted a controlled experiment on a set of executions for which program state was infected early in an execution and the rst external manifestation of failure i.e.
the output instruction execution event that rst revealed the infection is selected as the slicing criterion.
we then compare the search reduction that is provided by traditional dynamic slicing with that a orded by our dynamicrelevance augmented dynamic slices by examining the slice in order of decreasing relevance.
.
experimental setup the subject of our experiment was the java program nanoxml locs .
the dynamic slicing and relevance technique were implemented in java and analyzed at the ne grained bytecode level.
because the goal of our experiment is to evaluate the validity of the relevance measures assigned to instructionexecution events in a dynamic slice we established the ground truth for the targeted root cause instruction execution event.
to do this we introduced a data mutation on a small input element within each large xml input to our subject program.
we then executed the program with this mutated input which then infected the program state propagated throughout the execution of the program and nally producing mutated output as a result of the program state infection and propagation.
for each we captured the execution trace and recorded the speci c instructionexecution instance in the beginning of the execution that input the speci c mutated elements.
we also monitored the output to determine the rst external symptom of the 39imposed mutation infection the outputting instructionexecution instance that was responsible for producing that symptom was de ned as our slicing criterion.
as a result we establish the evaluation ground truth for which input instruction execution events are most relevant to the symptom producing output instruction execution event.
.
experimental variables we assess e ectiveness according to the search space size of identifying the source of the program state infection in this case the input read instruction instances responsible for reading the mutated input elements.
in our experiment we control for all variables and vary only the technique i.e.
thetreatment or the independent variable to determine the search size i.e.
the dependent variable to nd the groundtruth established input instruction execution instance that originally infected the program state.
as such we compare three treatments execution trace.
this treatment serves as a baseline upon which the others can be compared.
for it we record the number of input instruction execution instances throughout each execution which constitutes the initial search space of all inputting instructions and all their individual execution instances.
traditional dynamic slice.
with this treatment we determine the extent to which dynamic slicing can reduce the search space for the input instruction execution instances according to the number of input instructionexecution events by backward slicing from the slicing criterion to all transitively reachable input instances.
dynamic relevance augmented dynamic slice.
with this treatment we determine the relative dynamic relevance values that we assigned to each input instruction execution instance and assess the degree to which we e ectively distinguish the ground truth root cause instances.
for this we assess the number of input instruction execution instances that need to be inspected in decreasing order of dynamic relevance.
.
experimental results we present the experimental results in table and figure .
table shows the data for all executions of nanoxml that were infected with mutations in their inputs.
each row in table presents the information for a single infected execution of nanoxml.
figure depicts the mean values of the data for all executions as shown in last row of table .
for example for execution there were a total of input instruction execution instances in the entire execution out of which only instances i.e.
.
were identi ed as relevant for inspection after dynamic slicing.
of these only input instruction execution instances i.e.
.
required inspection when inspecting in order of decreasing dynamic relevance.
in each of the executions using the additional relevance measure substantially reduced the search for the infection source as against the number of instruction execution instances that required inspection as a consequence of being included in the dynamic slice.
in the best case of execution8 dynamic slicing reduced the instruction execution instances for inspection to .
of the total input instances i.e.
from to .
in addition after utilizing the relevanceexecution of input instructionexecution instances in trace and instances to inspect in traditional dynamic slice and instances to inspect in augmented dynamic slice execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
execution .
.
mean .
.
.
.
.
table results for mutated executions of nanoxml measures exactly instruction execution instance required inspection i.e.
the relevance measure was able to pinpoint the input instance most relevant among all input instances that dynamic slicing determined truly a ected the slicing criterion.
even in the worst case of execution dynamic slicing reduced the search space of input instruction instances to .
of the total input instances leaving instruction instances to inspect this was further reduced to .
of the total input instances leaving instruction instances requiring inspection which is a further reduction of the search by .
from what the dynamic slice provided.
on average for all executions dynamic slicing reduced the search space for the input instruction instances to .
thus providing an average cost savings of .
.
in addition augmenting the dynamic slicing with the relevance measure reduced the search for the read instructions on average to .
of the total number of input instruction instances in the execution thus providing an average cost savings of .
.
.
discussion overall the results of our evaluation suggest that that augmenting the dynamic slice with relevance measures can substantially reduce the search for instruction execution instances and thus lead to potential cost savings.
the traditional dynamic slice was surprisingly e ective at reducing the search space in terms of the input instruction instances reduction that required inspection.
however the dynamic relevance information provides even further reduction in the search reduction to identify the mutated inputexecution instance.
it was interesting to us the number of input execution instances i.e.
between and that dynamic slicing determined to be in uencing the infection revealing output instruction instance i.e.
the slicing criterion .
to verify the correctness of our analysis we performed manual investigation to determine whether the inclusion of the input instruction instances that were reading un mutated data were 40execution trace dynamic slice augmented dynamic slicesearch space of read insn.
instances to inspect0 execution trace dynamic slice augmented dynamic slicesearch space of read insn.
instances to inspect0 100figure mean search space to locate the source of programstate infection.
n.b.
lower values are better.
correctly included in the slices.
we found that indeed these reads do in uence the control and data dependencies that propagate to the propagated and mutated output state.
we found that many of these relationships arise due to the relationships in the structured input e.g.
hierarchical xml elements attributes of elements and element types that prescribe certain attributes .
moreover we found that the most relevant among these according to our dynamic relevance measure were those that had the most direct relationships in the structural input.
finally we note threats to the validity of our evaluation results.
most notably the results of our evaluation were subject to the behavior of a single software program and thus neither con rm nor reject generalizability warranting further inquiry with additional software programs as subjects for studying program behavior.
also we evaluated using one application of dynamic slicing nding the root cause infection in the input space.
we think that the dynamic relevance measure can be helpful in distinguishing in uences in dynamic slices for many other tasks and those too should be evaluated in the future.
.
related work dynamic slicing dependence analysis.
dynamic slicing was rst proposed by korel and laski and has inspired various bodies of work ranging from e cient computation of dynamic slices to numerous applications in the eld of software engineering.
one of the earliest such contributions to dynamic slicing was made by agrawal and horgan by rst proposing and levering the dynamic dependence graph to compute dynamic slices.
a general description of slicing technology and challenges can be found in tip s survey krinke s thesis and with a more recent survey by xu et al.
.
works by bink leyet al.
further provided theoretical frameworks for distinguishing di erent types of slices.
a noteworthy amount of dynamic slicing research has focused on pruning compressing and summarizing dynamic slices or dynamic dependence graphs upon which the slicing is performed to aid comprehension e.g.
.
an underlying motivation for such works has been to eventually support e cient navigation and inspection of dynamic slices both computationally and for manual inspection by software engineers.
our work is similar to such works as it motivated by the nal goal of aiding inspection and navigation of dynamic slices for software engineers.
however in contrast our technique attempts to achieve improved navigation by deciphering the more important sections in a dynamic slice instead of pruning or summarizing it.
indeed it would be interesting to study the e ects of summarization and or pruning in conjunction with our approach.
gupta et al.
and zhang et al.
employ multiplepoints slicing to minimize the program execution search space for localizing faults in a software program.
this is similar to our approach as we employ dynamic slices from multiple points and directions to compute relevance measures.
however in contrast our approach does not minimize the dynamic slice itself instead it highlights certain relevant points in the slice based on the underlying in uences.
masri and podgurski present a forward computing approach called dynamic information ow analysis difa to track in uences within instruction instances during a program s runtime.
they use dynamic dependencies to compute in uence.
further they measure the strength of information ows modeled by program dependencies using information theory and statistical correlation between empirically observed variable values during software program executions.
our model also captures the in uence of instruction instances on each other and moreover computes a measure of relevance for such in uences.
however in contrast our approach analyzes the underlying in uences and dependencies themselves to arrive at such relevance measures instead of using empirically observed values for di erent variables in a program execution.
quanti ed dependence models.
recent works have looked at augmenting runtime information with system and program dependence graphs for weighting di erent elements i.e.
nodes and edges in such dependence models towards improved applicability for various software engineering tasks.
baah et al.
propose the probabilistic program dependence graph that composes statistical dependencies deduced from test runs to nally enable improved fault localization and comprehension.
santelices et al.
propose quantitative slicing that weights statements in a static forward slice using di erential executions to improve change impact analysis.
deng and jones propose the weighted system dependence graph that weights the edges of the system dependence graph using test execution data to better enable debugging and program comprehension.
our work is similar to such hybrid models of program behavior as we weight dependencies between di erent instruction instances to highlight certain in uences between instruction instances over others.
however in contrast to such techniques that are based on static dependence models our approach models program behavior based on dynamically observed dependencies and thus is likely to be more precise.
.
conclusion and future work in this work we presented a novel dynamic dependence and slicing model that incorporates a new measure to quantify dynamic in uence among instruction execution events within executions traces and dynamic slices.
our augmented dynamic slice model represents not only the traditional inclusion and identi cation of in uencing instruction instances but also includes the dynamic dependence relationships among them as well as a newly created measure that quanti es relationships.
our new measure which we are calling dynamic relevance represents the degree of distinctive in uence among instruction instances whether through direct or transitive dependencies.
we conducted evaluations to determine the degree to which traditional dynamic slicing and our new augmented model can reduce the search space for a set of debugging tasks.
our results show strong promise the new augmented model and lend con dence to the intuitions that gave rise to the dynamic relevance measure.
for our experimental subject and protocol search space costs were reduced to .
of all read instruction instances within an execution trace which bested the search space reduction of traditional dynamic slicing of .
.
although these results are promising future work is needed to further lend con dence in these bene ts and to explore the full range of bene ts and limitations of all such approaches.
first we will perform larger studies on more subject programs and a variety of software engineering tasks.
also we envision future client analyses that can bene t from dynamic relevance measures and we also envision user interfaces that will allow developers to explore and query dynamic slices.
.