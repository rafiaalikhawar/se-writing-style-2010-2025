sabrine state based robustness testing of operating systems domenico cotroneo domenico di leo francesco fucci roberto natella dieti department universit a degli studi di napoli federico ii via claudio napoli italy critiware s.r.l.
incipit via cinthia complesso univ.
monte s. angelo napoli italy cotroneo francesco.fucci roberto.natella unina.it domenico.dileo critiware.com abstract the assessment of operating systems robustness with respect to unexpected or anomalous events is a fundamental requirement for mission critical systems.
robustness can be tested by deliberately exposing the system to erroneous events during its execution and then analyzing the os behavior to evaluate its ability to gracefully handle these events.
since oss are complex and stateful systems robustness testing needs to account for the timing of erroneous events in order to evaluate the robust behavior of the os under different states .
this paper presents sabrine state based robustness testing of operating systems an approach for state aware robustness testing of oss.
sabrine automatically extracts state models from execution traces and generates a set of test cases that cover different os states.
we evaluate the approach on a linux based real time operating system adopted in the avionic domain.
experimental results show that sabrine can automatically identify relevant os states and find robustness vulnerabilities while keeping low the number of test cases.
index terms robustness testing fault injection operating systems linux kernel fault tolerance dependability benchmarking i. i ntroduction operating systems oss are the core of a wide range of software systems with which we interact in our everyday life ranging from embedded systems to large critical infrastructures.
os failures are a major concern as they can potentially compromise all the applications running on it and the mission of the overall system .
given that an os can execute under a large variety of scenarios facing unexpected and erroneous conditions that can arise from its working environment including the hardware applications users and other systems it is expected that the os operates robustly even in such conditions.
therefore it is of paramount importance especially in the context of missioncritical systems to assess the robustness of oss with respect to such unexpected conditions e.g.
an invalid input that is its ability to gracefully handle these anomalous events and to avoid catastrophic consequences e.g.
an os crash .
robustness testing consists in executing a software system in the presence of unexpected events e.g.
invalid or untimely inputs that are deliberately introduced injected during the test.
several approaches have been proposed but robustness testing of oss is still an open challenge.
most of robustness testing approaches rely on a formal description of the software e.g.
timed input output automata for identifying unexpected events to inject the states in which to inject and theexpected responses of the system to events but these approaches do not scale well for oss given that oss can be very large and complex up to millions of lines of code and that their source code and or expertise on their internals may not be available.
alternative proposals are instead based on black box approaches in which os robustness test cases are devised from the analysis of the input domain of os interfaces e.g.
the system call interface .
however these approaches neglect the state of the os at which an anomalous event is injected by injecting at random times or require extensive manual analysis in order to define when to perform the injection.
these limitations affect the efficiency of robustness testing since they can reduce the number of robustness vulnerabilities that are found and increase the number of experiments to perform.
in this paper we propose an approach for state aware robustness testing of oss namely sabrine state based robustness testing of operating systems .
sabrine improves the efficiency of robustness testing by performing exactly one robustness test for distinct states of the os thus avoiding superfluous experiments i.e.
experiments that inject a fault in the same os state and increasing the likelihood to find robustness vulnerabilities by covering more os states than a random approach .
sabrine does so by automatically extracting behavioral models from execution traces of the target system and by generating a distinct robustness test case for each state of the behavioral model of the system.
we evaluate the approach on a linux based real time operating system adopted in the avionic domain.
experimental results show that sabrine can automatically identify relevant os states and find robustness vulnerabilities while keeping low the number of test cases.
the paper is structured as follows.
section ii provides an overview of studies on robustness testing of oss.
section iii presents the sabrine approach.
section iv describes the case study on which we applied the proposed approach and section v reports and discusses experimental results.
section vi concludes the paper.
ii.
r elated work several studies approached the problem of robustness testing of operating systems from different points of view.
one of the earliest study has been presented in which evaluated the robustness of unix utilities in the presence of randominputs fuzzing .
two tools respectively fuzz and ptyjig were proposed to submit a random stream of data to the target through the standard input and through the terminal device.
the study found that a significant number of utility programs on three unix systems between and is vulnerable to invalid inputs causing process crashes or stalls.
a subsequent experiment found that the same utilities were still sensible to a significant part of faults found in years later.
these studies highlighted that robustness can be a serious concern even for mature widely adopted software.
even if the fuzzing approach is simple to implement and can reveal robustness problems its efficiency was questioned by some studies since it relies on many trials and good luck .
in it is pointed out that most of unstructured random tests only test the input parsing code of the program and do not stress other software functions.
riddle a tool for robustness testing of windows nt utilities extends fuzzing with erroneous inputs generated by a grammar that describes the format of inputs like a backus naur form.
these erroneous inputs random and boundary values are syntactically correct and able to test more thoroughly the target program.
in order to improve the efficiency of robustness testing subsequent studies investigated the data type based error injection approach which focuses on invalid inputs that tend to be more problematic than other to be handled.
such an approach was proposed in the ballista tool for evaluating the robustness of commercial oss with respect to their ability to handle invalid inputs from faulty user space programs to thesystem call interface .
each robustness test consists of a system call invocation with a combination of both valid and invalid parameters.
for each group of system calls and each data type these studies define a set of invalid input values e.g.
closed or read only files and null or wrong pointers to memory areas .
examples of invalid inputs using a data type based approach on three data types are provided in table i. the test outcome is determined by recording the error code returned by the system call e.g.
to identify whether the error code reflects or not the invalid input or an error code is not returned at all and by monitoring system processes using a watchdog process e.g.
a failure occurs if a process unexpectedly terminates during the experiment or it is stalled .
test outcomes are classified by severity according to the crash scale a catastrophic failure occurs when the failure affects more than one task or the os itself restart or abort failures occur when the task launched by ballista is killed by the os or stalled silent or hindering failures occur when the system call does not return an error code or returns a wrong error code.
these studies found severe robustness vulnerabilities in several commercial oss which were due mainly to illegal pointer values numeric overflows and endof file overruns .
robustness testing of oss has also been focused on device drivers since they are usually provided by third party developers and represent a major cause of os failures .
the robustness of the driver programming interface dpi of oss has been targeted in and in whichinvalid values are generated by faulty device drivers when they invoke a function of the os kernel in invalid values are introduced using a data type based approach while in the code of device drivers is mutated by artificially inserting bugs to cause a faulty behavior.
johansson et al.
and winter et al.
later compared the bit flipping fuzzing and data type based approaches with respect to their effectiveness in detecting vulnerabilities in the dpi of windows ce and the efforts required to setup and execute experiments.
they found that bit flipping is the approach most effective at finding vulnerabilities but it incurs a high execution cost due to the large number of experiments thus providing a low efficiency while the other approaches are more efficient but incur in a higher implementation cost e.g.
in the case of the datatype based approach the user has to define exceptional values for each data type .
from all these studies oss result to be more vulnerable to device drivers than to applications since developers tend to omit checks in the device driver interface to improve performance and because they trust device drivers more than applications.
other works assessed the robustness of oss with respect to hardware faults e.g.
cpu and disk faults by corrupting os memory image and with respect to synchronization faults in kernel code .
all these approaches neglect the system state or they rely on a representative workload to exercise the system and bring it to relevant states before a robustness test.
a relevant example is represented by dependability benchmarks which have been proposed for comparing the robustness of different oss.
these dependability benchmarks evaluate robustness while the target os is under different working conditions i.e.
state they define realistic scenarios in which the os is part of a database server system or mail server system and the system is exercised using a representative set of user requests.
system call inputs generated by user space applications e.g.
the dbms or the mail server processes are intercepted and replaced with invalid ones by using respectively data type based values random values and bitflips i.e.
a correct input is corrupted by inverting one bit .
the influence of os state has been investigated in recent work on testing device drivers .
in the concept ofcall blocks is introduced based on the observation that device drivers issue recurring sequences of function calls e.g.
when reading a large amount of data from a device .
therefore johansson et al.
improved the efficiency of robustness testing by focusing on call blocks i.e.
repeating subsequences of os function calls instead of injecting invalid inputs at random time.
call blocks are identified by the tester through a manual analysis before performing robustness tests.
sarbu et al.
proposed a state model for testing device drivers of microsoft windows oss using a vector of boolean variables.
each variable represents an operation supported by the device driver at a given time t thei th variable is true if the driver is performing the i th operation.
they found that the use of a state model can reduce the number of tests.
prabhakaran et al.
proposed an approach for testing journaling file systems which injects disk faults at specific states of filetable i examples of invalid input values for the three data types of th ewrite int filedes const void buffer size t nbytes system call .
file descriptor filedes memory buffer buffer size nbytes fdclosed buf small size fdopen read buf med pagesize size fdopen write buf large 512mb size page fddeleted buf xlarge 1gb size pagex16 fdnoexist buf huge 2gb size pagex16plus1 .
.
.
.
.
.
.
.
.
system transactions.
in we conducted a preliminary study on the impact of the os state on os failures and on the code coverage achieved by robustness tests at system calls.
all these studies showed that the os state has an important role in testing such complex systems however they require knowledge about os internals and a manual analysis to define state models in which to inject faults.
the objective of this paper is to overcome this limitation by automatically inferring state models to use in robustness testing.
iii.
r obustness testing approach our approach for robustness testing has been designed to perform the injection of faults in the os by taking into account the state of the os during the injection.
the state can affect how an event impacts on the os and the ability of the os to robustly handle its occurrence.
we assume that the tester has little knowledge about the inner workings of the os since oss are typically provided by a third party and it would be unfeasible to manually analyze them to understand in depth their complex behavior.
therefore we identify the states of the os through a black box approach we analyze the sequence of events produced by the os observed at its interfaces during its execution based on the idea that the history of events at os interfaces reflect the state of the os.
test cases should run at distinct sequences of events in order to cover different states of the os and to efficiently perform robustness testing i.e.
avoiding that several tests impact the same state wasting testing efforts and time .
we identify os states using behavioral model mining techniques.
these techniques have been adopted for automating several software engineering tasks including specification mining automated debugging and reverse engineering .
to the best of our knowledge this is the first work that tailors these techniques for robustness testing of oss.
the sabrine approach automates collection and analysis of os events to identify interesting sequences of events in which to inject faults.
the process consists of phases behavioral data collection before performing robustness testing the system is executed and profiled under fault free conditions.
this phase collects data about the os behavior in terms of interactions between os components at run time.
pattern identification behavioral data is preprocessed by dividing them in sequences .
each sequence is a set of interactions that occur during the execution ofan individual system call or interrupt request.
identical sequences are grouped together and represent a pattern .
pattern clustering patterns that are similar even if they are not identical are further grouped together using a clustering algorithm.
this phase is important for obtaining a compact and efficient set of robustness test cases.
state model and test suite generation for each cluster obtained from the previous phase a behavioral model is generated.
a behavioral model consists of a set of states interconnected by events.
robustness test cases are generated for each model in which faults are injected in specific states of the model.
test execution each test executes the system under the same working condition of the first phase.
during execution behavioral data is collected and analyzed at run time and a fault is injected when the os reaches a given state of the behavioral model.
we first define some basic concepts in section iii a then we discuss in detail each phase in the following sections.
a. definitions in our approach we distinguish between the different components that form an os.
a component is a subsystem of the os that is responsible for managing a resource or for providing a set of services such as memory management i o management and process scheduling.
each component provides an interface to other components that is a set of functions that are invoked to request a service.
applications can require a service to the os by performing a system call which in turn triggers one or more components that interact in order to implement the os service figure .
additionally component services can be invoked by interrupt requests coming from the hardware and by kernel tasks i.e.
processes that execute in kernel space and that can directly interact with os components.
several system calls interrupt requests and kernel tasks can be executed in parallel by alternating on the same cpu or by running concurrently on different cpus .
the applications that run on top of the os and exercise it are referred to as the workload .
we test os robustness against service failures of a component.
a service can fail for instance due to the exhaustion of a resource or due to a hardware fault in a device or a defect in an os component.
in case of a failure the function that has been invoked typically returns an error code to notify that a service cannot be provided.
a service failure may causeinteraction log behavioral data collection pattern identification and clustering behavioral modeling finite state automata cluster sequence fig.
.
overview of the sabrine approach.
opera ng system os component os component os component n os interface target os component user apps hw system calls interrupt requests kernel tasks fig.
.
system overview.
anon robust behavior such as an os crash when it is not correctly handled by the os code that invokes the service.
in such a case the os is considered vulnerable to that service failure and a robustness vulnerability has been found which may require to fix the os in order to make it robust against the service failure e.g.
by retrying the failed operation or switching to a degraded mode of service .
to test robustness we force a service failure also referred to as fault while the system is exercised with a workload that is by forcing the called function representing the service to return an error code and analyzing the system reaction to the service failure.
in particular given that the same service can be requested by several os components we focus on service invocations performed by one specific target component at a time.
for instance the target component can be represented by a new component under development such as a device driver to support new hardware or a new filesystem component.
to identify the states of the target os component we log interactions at its interfaces with other os components dashed arrows in figure .
the target component may be invoked by another component input interaction or the target component may invoke another component output interaction .
an interaction with a function that can fail e.g.
a function for resource allocation and in which a failure can be injected is referred to as injectable interaction see figure .
we both consider the case in which an injectable interaction is direct that is the injectable function is invoked by the target component and the case in which the injectable interaction is indirect in which the injectable function is invoked by another component onbehalf of the target component i.e.
the function is invoked to provide a service to the target component .
we include indirect interactions in our robustness tests since the fault may propagate to the target component and trigger its robustness vulnerabilities.
time target component component x component y input interaction output interaction an error code is returned ... injectable interaction key function invocation return from function the fault propagates fault fig.
.
interactions among os components.
b. behavioral data collection in this phase the os is executed using a workload without injecting faults.
the workload is selected by developers and testers before performing robustness testing.
in a similar way to performance benchmarks the workload reflects the context in which the os will be adopted e.g.
web applications dbmss .
.
.
and it affects the way the os is exercised during the tests e.g.
a dbms oriented workload stresses storage related services and its behavior under unexpected events.
during the workload execution we monitor component interactions figure and derive state models for the target component on the basis of its interactions with other components.
as discussed later state models are based on input output and injectable interactions that involve the target component.
component interactions are monitored through static i.e.
hard wired in the kernel source code or dynamic probes i.e.
inserted at run time located at the interfaces of components.
a probe consists of a small piece of code e.g.
a breakpoint that is inserted in a given code location and that triggers a handler routine when executed.
in turn the handler collects information and restores kernel execution.
for tracing input interactions we probe the interface of the target component storing information as described in the next section about the component that invokes the target.
for tracing output and injectable interactions we probe the interfaces of components that are invoked by the target component storing informationabout the invoked component.
probing at component interfaces represents a practical solution for most of modern commodity oss since they often provide tools that allow to insert static and or dynamic probes in kernel code and monitor its execution with a low overhead such as dtrace for oracle solaris systemtap for linux and debugview for microsoft windows .
data from probes are transferred to an external computer through a serial port which is typically adopted for debugging purposes since the serial port driver has minimal interactions with other os components thus limiting interferences on os execution due to monitoring.
when collecting behavioral data we take into account that component interactions may vary between different workload executions due to random factors for instance some interactions may appear in a different order or not appear at all depending on the timing of i o events and process scheduling.
as a consequence such random factors can affect the definition of robustness test cases since some os states can be missed during an individual workload execution.
for this reason we repeat the execution of the workload several times during this phase by so we are able to include sets of interactions even when they do not occur at every execution and to generate robustness test cases that also cover them leaving uncovered only very rare interactions.
c. pattern identification the output of the previous phase consists of an interaction log in which interactions among components appear in sequential order i.e.
ordered by their timestamp .
the log is divided into sequences where each sequence is a set of events that occur during the execution of an individual system call interrupt request or a kernel task.
two executions of the same system call represent two distinct sequences but they can produce different sets of interactions depending on the state of the system.
by dividing the log into sequences we discriminate subsets of interactions that repeat identically in this phase or are similar in the next phase in which it is likely that the target has assumed the same states.
identical sequences are grouped together forming a pattern .
to extract sequences we log the following information for each interaction between the target and other components operation id a string identifier of the operation system call interrupt request or kernel task that is being serviced at the time of the interaction.
execution id an integer that identifies a specific execution of a system call interrupt request or kernel task.
each time that an operation starts a new execution id is generated and all the interactions produced during this operation will be identified by this value.
if a system call is started while the same system call is already executing e.g.
by a different process on a different cpu the interactions of the new execution have the new execution id while the interactions generated by the other one are still denoted by the previous execution id.
trace id an integer that identifies a specific execution of the whole workload.
since the workload can beexecuted several times and more than one workload execution can appear in the same interaction log the interactions of each workload execution are denoted by a specific trace ids.
moreover each logged interaction contains the following information called function in the case of input interactions it is the name of the function of the target invoked by another component.
for output and injectable interactions it is the name of the function invoked by the target in another component.
call point the code location in which the function is invoked e.g.
the address in the executable code of the instruction that invokes the function .
!
!
...!
out pdflush ll rw block flush commit list 1f3eb !
inj pdflush kmem cache alloc flush commit list 1f3eb !
inj pdflush kmem cache alloc flush commit list 1f3eb !
in close reiserfs file release fput c018efda !
in write reiserfs write begin generic file buffered write c016b0fe !
out write grab cache page reiserfs write begin c845 !
out write block write begin reiserfs write begin c8de !
in write reiserfs write end generic file buffered write c016b151 !
out write mark buffer dirty reiserfs commit page d966 !
out write kmem cache alloc alloc jh 1fde9 !
inj write kmem cache alloc alloc jh 1fde9 !
inj pdflush generic make request flush commit list 1f3eb !
out pdflush find get block flush commit list 1f3cc !
...!
in close reiserfs file release fput c018efda !
...!trace id operation id exec.
id int.
type called function call point cont.
fig.
.
example of interaction log and pattern identification.
figure shows an extract of the interaction log from the case study that we will consider in this work.
the first sequence in the example highlighted in light gray is identified by the triple an bracketle tpdflush an bracketri ht in which there are two output interactions denoted by out and two injectable interactions denoted by inj and all of them are invocations made by the flush commit listfunction of the target component a filesystem .
this sequence is interleaved with two other ones identified by an bracketle tclose an bracketri ht white background and an bracketle twrite an bracketri ht dark gray background respectively.
this interleaving occurred since pdflush a kernel task has been suspended while executing kmem cache alloc which performs memory allocation and can preempt a task when this operation takes a long time e.g.
an i o operation is required in order to free memory .
the other two sequences are generated by the workload invoking the close andwrite system calls which in turn trigger input interactions with the target component denoted by in .
when the third sequence performs its second memory allocation a workload process is preempted in favor of pdflush which continues the first sequence.
the same sequence of interactions can repeat identically in the log with a different identifier this is the case of the sequence identified by an bracketle tclose an bracketri ht a sequence containing only one interaction which is identical to the sequence identified by an bracketle tclose an bracketri ht.
these sequences represent two instances of the same pattern number and only one instance per pattern is considered in the subsequent phases.d.
pattern clustering the execution of the os typically leads to patterns that are not identical but differ for a few interactions or there is a small variation in the order of the interactions.
in other words several patterns tend to be very similar .
small variations in the sequences are unavoidable and are due to nondeterministic factors that can affect os execution.
figure shows two similar patterns related to the write system call for the sake of readability only the called function is showed for each interaction .
the patterns p1andp2exhibit almost the same number and sequence of interactions aside from three interactions gray background which appear only in p2.
these interactions in this specific case represent the allocation of additional memory when metadata are written to the disk.
ext3 dirty inode journal start kmem cache alloc getblk journal get write access gap gap journal dirty metadata gap brelse journal stop ext3 dirty inode journal start kmem cache alloc getblk journal get write access alloc pages kmem cache alloc journal dirty metadata kmem cache alloc brelse journal stop pattern pattern fig.
.
example of similar patterns.
however generating one behavioral model for each individual pattern would lead to an excessive number of models and as discussed later to superfluous robustness test cases.
therefore before generating behavioral models we group together similar patterns thus obtaining clusters of patterns.
each cluster represents a specific mode of operation of the target component where the patterns in a given cluster only differ with respect to a few interactions.
to perform clustering we first measure the similarity among all pairs of patterns using a similarity function and then we cluster patterns that are similar with a clustering algorithm .
a similarity function is a quantitative way to express the similarity between two sequences and it is used in several applications such as the processing of biological sequences.
in our case we compare sequences of interactions in which each interaction i.e.
a pair an bracketle tcalled function call point an bracketri ht represents an element of the sequence.
two main approaches exists in the literature for evaluating similarity which respectively i only consider which elements appear in each sequence and evaluate the number of elements that appear in both sequences set based similarity functions and ii consider the ordering of elements while comparing common elements between the sequences sequence based similarity functions .
in our approach we measure the similarity between patterns with a sequence based function two sequences of interactions with different orderings may reflect different states of the system and should be regarded as dissimilar.
sequence based functions are based on alignment algorithms in which the elements of the sequences are placedside by side in order to maximize the number of matches and minimizing the number of gaps and mismatches1.
with the smith waterman algorithm we compute an alignment score for each pair of patterns pandqaccording to the following dynamic programming formulation f0 j j g f i i g fi j max fi j sim pi qj fi j g fi j g sim pi qj braceleftbigg m ifpi qj n otherwise in this set of equations piandqjare thei th andj th element of patterns pandq respectively with i and j andnandmare the lengths of patterns pandq.fis the scoring matrix where the value fi jis the score of the best alignment between the initial segment p1...iofpup topiand the initial segment q1...jofqup to qj which is calculated recursively from fi j fi j and fi j .
the constants gandnare the score penalty for gaps and mismatches while mis a score reward for matches.
common choices are g n andm g n .
the highest value of f that is fn m represents the score of the best possible alignment.
for instance the patternsp1andp2showed aligned in figure have score sw p1 p2 wmatch m wmismatch n wgap g where the ws are the number of matches mismatches and gaps respectively.
for each pair of patterns we compute the sw score and collect this score into a cell of a matrix named similarity matrix sm which expresses quantitatively the degree of similarity among all pairs of patterns.
the score of each pair is normalized using the length of the longest pattern in each pair since patterns in our context have variable length which would otherwise affect the evaluation of pattern similarity.
we group together similar patterns using a spectral clustering algorithm .
spectral clustering groups a set of elements on the basis of their similarity matrix and has recently emerged as an effective and computationally efficient clustering approach.
a spectral clustering algorithm interprets input elements as the nodes of a graph and the similarity score of each pair of elements as the weight of the connection between two nodes.
then elements are clustered into k groups by performing kcuts in the graph each group includes the nodes that are still connected after the cuts.
the idea behind spectral clustering is that cutting weak connections splits the graph into partitions of elements that are strongly connected and thus very similar each other.
the weights of cuts in the graphs are closely related to the spectrum of 1when the elements at a given position of a pair of patterns are the same we say that there is a match otherwise we say that there is a mismatch .
a gap instead consists in introducing a special symbol to fill the vacuum due to the different lengths of the two sequences.the graph that is the eigenvalues 1 ... nof the graph laplacian matrix lderived from sm .
by processing lon the basis of its eigenvectors spectral clustering obtains kcuts and in turn kclusters.
to select the number kof clusters we use the eigengap heuristic which chooses ksuch that all 1 ... keigenvalues of lare very small and k is relatively large.
intuitively if the first keigenvalues are very small then the algorithm can split the graph into kparts without separating strongly connected nodes.
e. behavioral modeling and test suite generation at this point the initial interaction log through pattern identification and clustering has been turned into clusters of sequences.
from each cluster we infer a behavioral model in the form of a finite state automata fsa .
we based our robustness test generation approach on the kbehavior mining algorithm .
this algorithm incrementally infers fsas from execution traces which in our case consist of sequences of component interactions.
the algorithm starts with an empty automata e.g.
only one state with no transitions examines the first pattern and generates an fsa whose transitions are labeled with an interaction i.e.
a pair an bracketle tcalled function callpoint an bracketri ht .
if the cluster contains more than one pattern they are subsequently provided as input to the mining algorithm one at at a time.
each time that a new pattern is provided the algorithm augments the fsa with new transitions and states in order to reflect both the new patterns and previous ones.
this process is repeated for each cluster leading to an fsa for each cluster as showed in fig.
.
a set of robustness test cases is derived from each fsa.
sabrine identifies transitions of the fsa that represent an injectable interaction i.e.
an invocation of a function in which a failure can be injected.
then sabrine automatically generates a test case for each injectable interaction present in the fsa.
more specifically given a state swith an outgoing transition tsuch that tis an injectable interaction a robustness test case is generated for the couple s t .
the test consists in forcing a failure of the function when the system reaches the state sand the injectable function is invoked.
the state srepresents the context in which the function can be invoked and can fail.
this approach allows sabrine to cover each different context in which the injectable function is invoked and to improve the efficiency of robustness tests.
figure provides an example of how robustness test cases are obtained from behavioral models.
it depicts the fsa generated from the two patterns in figure for brevity only the called function is showed at each transition in the figure .
states from to and states from to are connected by interactions that appears in both patterns while states and are connected by two different sets of transitions.
this occurs since the two patterns share most of their interactions but one of them performs contains additional memory allocations and the mining algorithm inserted new states and transitions corresponding to these interactions.
assuming to inject failures at the invocations of the kmem cache alloc memory allocation function sabrine generates robustness test cases from thefsa.
the example also points out the importance of clustering on the generation of test cases.
the first invocation of kmem cache alloc which appears in both patterns of figure is performed in the same context in both patterns.
by using only one fsa for representing both patterns the occurrences of the first kmem cache alloc invocation are collapsed into only one transition in the fsa the one between states and .
in this way we reduce the number of robustness test cases only one test is performed for each transition with an injectable interaction while still covering relevant states of the system thus improving the efficiency of robustness testing.
a similar reduction is obtained when the kmem cache alloc is performed in a loop in such cases since the same interactions are repeated several times the mining algorithm translates these interactions into a loop in the fsa and only one test case is generated for that injectable interaction.
f .
test execution robustness test cases are translated in test programs that are then executed to inject service failures in the different states of the os.
in a similar way to the behavioral data collection phase subsection iii b the test program collects interaction sequences at run time using kernel probes and keeps track of the current state of the target component.
if the test program in the current state observes the interaction specified in the fsa it transits to the new state.
if the observed interaction it is not the expected one the target program transit to the initial state.
when the system reaches the target state s the target program injects a service failure during the injectable interaction.
after the injection the os behavior evolves freely.
iv.
c ase study to illustrate the use of the sabrine approach we consider an os developed in the context of a pilot r d project in conjunction with the finmeccanica s.p.a. industrial group.
the goal of the project is to develop a reliable linux based real time operating system rtos namely fin.x rtos to adopt in software systems for avionic applications.
in particular in order to ease the certification of systems based on fin.x rtos the os needs to be accompanied by evidences e.g.
test artifacts showing the compliancy to the recommendations of the do 178b safety standard .
the original linux kernel has been enhanced in fin.x rtos by providing hard real time and scalability on multi core architectures and removing unnecessary parts.
the requirements of the standard at level d to be followed for software whose anomalous behavior would cause a minor failure condition for the aircraft have been fulfilled.
at the time of writing fin.xrtos is being tested with additional verification activities according to the requirements of level c for software that may cause a major failure condition for the aircraft which demand to test the robustness of the software against abnormal inputs and conditions.
an example of requirement from the standard is to provoke transitions that are not allowed by the software requirements .
ext3 dirty inode journal start journal dirty metadata alloc pages kmem cache alloc journal dirty metadata kmem cache alloc brelse journal stop kmem cache alloc getblk journal get write access robustness test case robustness test case robustness test case key patterns pattern pattern fig.
.
example of behavioral model.
we applied the sabrine approach to assess the robustness of a set of i o related components against service failures in the memory allocator of the kernel.
we selected memory allocation failures because most of os components depend on this service and it is a frequent cause of system failures .
kernel developers also perceive memory allocation problems as a likely cause of os failures in fact the linux kernel includes a framework for injecting service failures which encompasses memory allocation failures .
both in our implementation of sabrine and in the linux injection framework a failure is injected by forcing a memory allocation function kmem cache alloc to return a null pointer instead of a valid pointer to the newly allocated memory.
while the linux framework injects failures at a random time the sabrine approach selects the time in which to inject based on the state of the target component.
we compare both these approaches in our experiments.
it is important to note that the sabrine approach is not limited to the kmem cache alloc since several other injectors both in the literature and among practitioners also force the failure of a kernel function to test robustness.
for instance the linux kernel fault injection framework also allows to emulate disk i o errors by forcing the failure of functions for block i o management .
the relationships between i o related components in the kernel are showed in figure .
in this architecture i o system calls e.g.
write s first pass through the virtual file system which provides generic services for implementing file systems and forwards a file operation to the specific filesystem that manages the file e.g.
ext3 reiserfs .
.
.
.
the file system can issue an i o operation to the block i o layer which provides generic services such as scheduling of i o requests and caching of disk data.
in turn the block i o layer forwards requests to a device driver which manages the disk device.
all these components use the memory allocator for dynamically allocate memory such as for storing file metadata and for temporary i o buffers.
the target components are represented by thick boxes in figure and include two widely adopted file systems ext3 and reiserfs and a device driver the scsi subsystem .
we adopt the apache httpd web server to exercise the os using the httperf performance testing toolto generate web requests .
experiments were executed in a virtual machine environment and were fully automated using programs running on the host machine.
a systemtap program collects behavioral data.
fsa models are created with the kbehavior algorithm and automatically translated in test programs implemented in the systemtap language.
behavioral data and error messages from the os are collected using virtual serial port connections.
in the case of an os crash we collect information including the type of exception e.g.
illegal memory access the code location the contents of the stack and of cpu registers.
the virtual machine is automatically rebooted in case of a crash.
kernel code system call interface user apps virtual file system reiserfs ext3 ntfs ... memory allocator block i o layer scsi disk driver ide disk driver ... disk device irq interface fig.
.
overview of i o related subsystems in fin.x rtos.
v. e xperimental results this section presents the results obtained by sabrine in our case study.
table ii provides some basic facts about data collection and processing and test generation.
we collected an interaction log for each target component by running the webtable iii clusters for ext3.
cluster behavior context patterns gets and sets the file metadata statsyscall retrieves and stores in memory the file index block or updates it on the disk open unlink syscalls copies file contents from disk to a cache and modifies it write syscall copies a small amount of data from a file to a network socket sendfile syscall modifies the contents of a file already in the disk cache write syscall flushes a small amount of data from the cache to the disk pdflush kernel task flushes a large amount of data from the cache to the disk pdflush kernel task copies a large amount of data from a file to a network socket sendfile syscall updates file metadata to reflect that is has been memory mapped mmap2 syscall table ii statistics on the behavioral data collection and test cases .
ext3 reiserfs scsi interactions sequences patterns clusters test cases involving the kmem cache alloc function.
server workload times for each target.
for ext3 and reiserfs interactions were performed in the context of file related system calls such as open andwrite and of the pdflush kernel thread of the block i o layer which periodically flushed cached data to the disk.
for scsi interactions were initiated by kernel threads of the block i o layer which requested data transfers and by interrupts from the hardware.
several thousands of interactions appear in each log.
these logs were divided in sequences and identical sequences were grouped into patterns.
since we aimed at injecting service failures of thekmem cache alloc function we focused our analysis only on sequences interacting with this function.
for ext3 and reiserfs a non negligible number of patterns and clusters was generated since memory allocations were performed in many different contexts during filesystem operations.
instead even if scsi produced the highest number of sequences with kmem cache alloc it exhibited the lowest number of distinct patterns and of clusters for this target memory allocations performed always at the same code location i.e.
when allocating memory for storing a new data transfer command leading to repetitive sequences.
consequently only clusters are enough to group the patterns of scsi while ext3 and reiserfs require and clusters respectively.
we examined in depth the clusters in order to understand the mode of operation represented by each pattern and to assess whether clustered patterns are semantically similar.
table iii provides a description for the clusters of ext3 similar interpretations apply to reiserfs and scsi clusters but we do not show them due to space constraints.
column behavior provides a brief description of clusters and column context details the system calls or kernel task in which these behaviors were observed.
each cluster represents a distinct behavior of the file system.
for instance cluster gathersthe patterns representing get and set operations on file metadata e.g.
file permissions which is the case of the stat system call clusters and represent the typical behavior of read andwrite system calls.
for each cluster of each target component we derived an fsa and a set of one or more test cases for each fsa subsection iii e .
in order to evaluate the efficiency of sabrine we executed the robustness test cases generated by the approach and compared the results with the ones obtained using the standard fault injection framework included in the kernel .
in the standard injection framework allocation failures are injected randomly each time kmem cache alloc is invoked it can fail with a fixed probability p if a failure is not injected the subsequent invocation becomes the next candidate injection.
moreover the standard injector allows to inject service failures when the injectable function is invoked directly or indirectly by the target component ext3 reiserfs or scsi .
we performed random injections for each target component these experiments took a few days per target component to complete therefore injections can be considered a conservative estimate on the number of experiments that a developer would perform.
we set p which is the value suggested by kernel developers in the documentation this value avoids that too many injections take place only at the beginning of the experiment.
as for sabrine we executed the number of tests reported in the last row of table ii.
we classify the outcome of a test in kernel failure the os is crashed or its state is corrupted.
to detect state corruptions in the os we enabled several consistency checks introduced by developers in the kernel code including checks on stack overflows stuck system calls locks not released and corruptions on key kernel data structures.
this kind of failures is the most severe since they affect the whole system.
workload failure the web server crashes exits abnormally does not reply to requests or does not execute correctly the requests.
these failures are detected through the logs of the web server and of the client.
fs corruption after each test we detect disk corruptions using filesystem check utilities.
no impact neither the os nor the workload show an erroneous behavior.table iv statistics on failure distributions .
testing techniquetarget kernel failuresworkload failuresfs corruptions randomext3 .
reiserfs .
.
scsi sabrineext3 .
.
reiserfs .
.
scsi table iv provides the distribution of failures observed during the experiments.
both kernel failures and workload failures were observed instead no memory allocation failure caused filesystem corruptions since the kernel tends to crash immediately or to fail gracefully in order to avoid data corruptions.
the scsi target component was robust to memory allocation failures as it never caused failures by inspecting its source code we found that it keeps a pool of previously allocated data structures e.g.
data transfer command structure that supply memory when the kernel allocator fails in order not to lose important disk writes.
an important observation is that in the case of random testing of ext3 no workload failures occurred.
instead we noticed that when focusing error injection in particular states using sabrine workload failures were also observed for ext3 .
in these cases the web server failed since the injected error prevented the creation of a temporary file.
this kind of failures could occur only under a specific state of the os and emphasizes the influence of the os state on robustness testing.
stack kernel function frame 0kmem cache alloc 0x22 0x110 a failure occurs here 1radix tree node alloc 0x35 0xb0 2radix tree insert 0x16e 0x1d0 3add to page cache 0x65 0x1d0 4add to page cache lru 0x1b 0x40 5mpage readpages 0x70 0xe0 6ext3 readpages 0x19 0x20 affected ext3 function 7 do page cache readahead 0x176 0x210 8ondemand readahead 0xbe 0x170 9page cache async readahead 0x66 0x90 10generic file splice read 0x4a9 0x630 11do splice to 0x61 0x80 12splice direct to actor 0x8f 0x180 13do splice direct 0x3b 0x60 14do sendfile 0x187 0x240 15sys sendfile64 0x77 0xa0 16sysenter past esp 0x5f 0x91 fig.
.
call stack of a robustness vulnerability.
it is important to note that table iv does not provides an indication of the efficiency of robustness testing in terms of unique robustness vulnerabilities found as many failures are due to the same vulnerability.
by analyzing memory dumps we concluded that os crashes were caused by two robustness vulnerabilities in the kernel code.
for instance figure shows the case of a memory allocation in radix tree node alloc that causes the corruption of data structures when the allocation fails and in turn the failure of the os component calling the function.
this vulnerability emerges when the file system is retrieving data from the disk to its cache in the main memory when a memory allocation fails as in the case of cluster 3in table iii.
table v provides the percentage of random tests able to reveal each robustness vulnerability this percentage can be very low as the case of getblkin reiserfs two cases out of random tests trigger the vulnerability .
table v percentage of random injection tests that trigger each vulnerability .
vulnerability ext3 reiserfs getblk .
.
radix tree node alloc .
.
table vi probability to reproduce a robustness vulnerability in sabrine.
vulnerability ext3 reiserfs getblk .
radix tree node alloc .
in our experiments sabrine was able to detect both the two vulnerabilities with a high efficiency.
for each vulnerability sabrine generated several test cases able to detect it by injecting in states where the vulnerability could be triggered.
the sabrine approach identified the same vulnerabilities of random testing but only a relatively small set of robustness test cases was required to find them test cases in total .
moreover a vulnerability can be easily reproduced once a test case of sabrine can detect it.
by repeating times the execution of sabrine test cases almost every os crashes repeated identically table vi provides the average probability of repeating an os crash.
instead it is difficult to reproduce failures using random injections since the state of the system at the time of the injection plays an important role in triggering vulnerabilities but it is neglected in random injections.
the dramatic reduction of the number of test cases and the ability to easily reproduce os failures increase significantly the efficiency of robustness testing.
vi.
c onclusion in this paper we proposed and evaluated sabrine a stateaware robustness testing approach for oss.
sabrine can efficiently and automatically generate robustness test cases for distinct states of the os.
the approach does not require the tester to know os internals as it infers behavioral models automatically.
the overall approach was applied to a linuxbased rtos used in the avionic domain.
for this os we tested the robustness of three subsystems against memory allocation failures.
results clearly showed that the state of the os plays an important role in robustness testing and that robustness vulnerabilities can be detected with a small number of tests.