the impact of fault models on software robustness evaluations stefan winter tu darmstadt sw cs.tu darmstadt.deconstantin s rbu tu darmstadt cs cs.tu darmstadt.deneeraj suri tu darmstadt suri cs.tu darmstadt.de brendan murphy microsoft research bmurphy microsoft.com abstract following the design and in lab testing of software the evaluation of its resilience to actual operational perturbations in the eld is a key validation need.
software implemented fault injection swifi is a widely used approach for evaluating the robustness of software components.
recent research indicates that the selection of the applied fault model has considerable in uence on the results of swifi based evaluations thereby raising the question how to select appropriate fault models i.e.
that provide justi ed robustness evidence .
this paper proposes several metrics for comparatively evaluating fault models s abilities to reveal robustness vulnerabilities.
it demonstrates their application in the context of os device drivers by investigating the in uence and relative utility of four commonly used fault models i.e.
bit ips in function parameters and in binaries data type dependent parameter corruptions and parameter fuzzing .
we assess the e ciency of these models at detecting robustness vulnerabilities during the swifi evaluation of a real embedded operating system kernel and discuss application guidelines for our metrics alongside.
categories and subject descriptors c. fault tolerance general terms measurement performance reliability keywords robustness testing fault injection fault models .
introduction under a constant feature driven market pressure and due to their ever increasing complexity many software applications are often released without being su ciently tested.
even if a software component1is considered to be su ciently permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright swmf ... .
.tested for one application scenario or operational environment it may be insu ciently tested for reuse in another one.
especially commercial o the shelf cots commodity software components pose a problem in this respect.
they are subject to re use in a variety of application scenarios that may well be unforeseen by their developers.
this lack of knowledge on the intended application scenario makes it difcult for developers to estimate the su ciency of their verication and validation e orts.
in contrast the users of cots components are aware of the application scenarios in which they are planning to use them.
however their ability to su ciently test cots components is frequently also limited as they usually do not have access to the components s source code or other information available to the components s developers.
furthermore the same component may be applied in multiple di erent operational environments within the same application the same cots operating system can for instance be applied for both the client and the server in a distributed client server application.
since the operational conditions for these di erent applications of the same system di er the user of this component needs to test the component for both of them di erently.
thus failures frequently result when the operational environment of the deployed system di ers from the pre release lab con gurations used in the testing phase of the software development process.
to cope with this deployment variability aspect swifi is a popular technique for evaluating the robustness of commodity commercial software components with respect to unexpected operational conditions.
in order to assess whether a software component is su ciently robust for release it is exposed to operational perturbations in a controlled manner while its reactions are closely monitored.
the problem with such approaches is that they are well suited for demonstrating the presence of vulnerabilities but not the absence thereof.
in order to show the absence of vulnerabilities using swifi it would be necessary to expose the component under evaluation cue to every possible perturbation.
while this is theoretically possible if the component s input space is nite it is generally considered impracticable as the problem is equivalent to that of exhaustive testing .
swifi based robustness evaluations therefore require selecting a processable number of perturbations for injection.
this raises the question how to select the injected perturba1we adopt szyperski s notion of software components units of composition with contractually speci ed interfaces and explicit context dependencies only .tions to maximize the robustness evidence derivable from the experimental evaluation .
a common solution to this problem is provided by application speci c operational pro les i.e.
probability distributions for stimuli that software is being exposed to during operation.
their application to the perturbation selection problem is based on the argument that a total absence of vulnerabilities is a too strong condition since a vulnerability does not necessarily result in a robustness violation.
it does so only if the component is exposed to a perturbation which exploits this vulnerability.
this reduces the problem to proving the absence of all vulnerabilities that can be exploited during operation.
for this purpose operational pro les of the component are derived from its intended operational context including but not limited to typical classes of perturbations i.e.
classes of perturbations that are expected to be frequently encountered during operation.
however this approach has two major drawbacks.
first the robustness evidence derived from such an evaluation is only valid for the considered operational context of the evaluated component this implies that a component needs to be re evaluated for every intended context thereby impeding its reusability.
second a vulnerability whose exploitation is highly unlikely in a given application scenario but whose exploitation consequences are of disastrous impact would be ignored by operational pro les.
however critical system failures often result from highly unlikely and hence unexpected conditions that are by de nition not covered by operational pro les .
paper contributions.
considering these drawbacks we investigate an alternate approach based on the idea that the absence of vulnerabilities can be approximated by maximizing vulnerability detection and removal.
instead of selecting typical application speci c perturbation classes for robustness testing we give preference to those perturbation classes that make our evaluations most e cient in terms of detected vulnerabilities and the required e ort for their detection.
consequently this paper makes the following contributions to the current state of the art a method to compare the e ciency of di erent perturbation classes termed fault models for swifi robustness evaluations a set of fault model e ciency metrics for this purpose a pragmatic set of guidelines for the application of these metrics in swifi based robustness evaluations.
as a case study we perform swifi experimentation on an embedded operating system os kernel windows ce .
and demonstrate the e ectiveness of our approach comparing four commonly applied fault models.
the paper is organized as follows section introduces basic terminology and related work.
section introduces the metrics developed for cross model e ciency evaluations whose application is demonstrated in an experimental evaluation of our approach presented in section along with a demonstration and discussion of their utility in section .
.
background and related work .
robustness notion and system model in this paper we adopt the robustness notion from according to which robustness is the degree to which a system or component can function correctly in the presence of invalid inputs or stressful environmental conditions.
invalid inputs and stressful environmental conditions are termed perturbations .
if a perturbation causes a software component to enter an erroneous state the component possesses a vulnerability which is activated by the perturbation.
perturbations are equivalent to what is called external faults in whereas robustness vulnerabilities are termed internal faults .
the application of external fault injection is hence a sound method for robustness evaluations.
a software cue is expected to interact with other software components via explicit interfaces only.
being part of a composition components are expected to provide services that are relevant for the implementation of the composition s functionality .interfaces are sets of services and therefore constitute the means by which each component s functionality can be accessed.
figure contribution of our work in the context of swifi based robustness evaluations figure displays the considered robustness evaluation methodology.
we conduct robustness evaluations of a cue by injecting perturbations into its runtime environment during controlled executions.
perturbations are introduced into cue servers i.e.
components o ering services to the cue and on whose reliable provision of service the cue depends.
in order to trigger interactions of the cue with the cue servers cue clients use services provided by the cue i.e.
create a workload for the cue.
since we consider direct interactions across the software components any perturbation a ecting a component must be mediated by its interfaces.
we therefore consider direct fault injections into data passed to the cue via the interface under evaluation iue as well as injections into the binaries of cue server components interacting with the cue via the iue.
we do not consider injections into the cue itself since the robustness of a software component is de ned by its fault tolerance with respect to external faults.
a cue failure detector monitors the cue its clients and its servers for symptoms of prede ned cue failure modes2 of interest.
the results of injection experiments are reported to a component external to the cue s runtime environment for o ine analysis from which robustness properties of the cue are derived according to a set of robustness metrics.
for our discussion of swifi based robustness evaluations the following terms are used.
an injection run refers to 2failure modes describe how a component can possibly fail e.g.
by becoming unresponsive.table fault models for robustness evaluations in the literature framework authors fault location fault type fault latency injection trigger mafalda cue serverseutransient1stoccurrenceiuembupermanentdt albinet et al.
iue dt transient 1stoccurrence kalakech et al.
iueseutransient 1stoccurrencedt xception seutransient1stoccurrence cue server mbuintermittentnthoccurrence dtpermanenttimer iue fz x call g swfit cue servercodingpermanent 1stoccurrencemistakes medon ca neves cue servercodingpermanent 1stoccurrencemistakes johansson iueseu transient1stoccurrence nthoccurrence dt intermittent timer fz permanentx call call blockcomponent cue under evaluation interface iue under evaluation single seu event upset multiple mbu bit upset data type dt dependent corruption fz fuzzing the injection of a speci c fault the execution of the workload and the observation and logging of the injection s e ects.
an injection campaign is a collection of injection runs pertaining to a speci c fault model workload targeted cue server component and iue.
a set of injection campaigns targeting the same cue is called an evaluation of that cue possibly including multiple fault models workloads and iues thus also multiple cue server components .
the approach presented in this paper uses experimental data of injection campaigns performed for robustness evaluations to evaluate the applied fault model s e ciency.
this information can be used to introduce a feedback loop as highlighted in figure providing guidance on the selection of perturbations for subsequent campaigns in an evaluation.
the required information is de ned by a set of metrics introduced in section .
.
comparative fault model evaluations we adopt the fault model notion from where fault models3for swifi based robustness evaluations of operating systems oss were de ned by three basic attributes thefault location where to inject the fault type what to inject and the fault timing when to inject where the latter was further quali ed as injection trigger and fault latency .
table lists a number of existing swifi frameworks that have been applied for software robustness evaluations similar to those we consider in this paper along with their reported fault model support.
fault models are usually discussed only implicitly in the literature and some swifi frameworks provide mechanisms for exibly extending the set of supported fault models e.g.
by user de ned injection triggers or fault types.
thus table is likely incomplete but already indicates potentially large numbers of applicable fault models o ered to evaluators e.g.
more than possible attribute combinations for xception .
the spectrum of fault types in the related literature are 3also termed as error models in the referenced paperssingle bit ips single event upset seu multiple simultaneous bit ips multiple bit upset mbu data type dependent corruptions of data elds or parameters dt and substitution by random bit pattern fuzzing fz .
the fault latency addresses the duration of an injection in terms of repeated fault activation.
transient faults are activated exactly once intermittent faults are activated a nite number of times and permanent faults are activated every time.
injection triggers determine when a fault is injected respectively when it can be activated for the rst time.
it can be injected the rst time its injection location is referenced after n