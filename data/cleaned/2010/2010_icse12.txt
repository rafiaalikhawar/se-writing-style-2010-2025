a history based matchingapproachtoidentificationof fram eworkevolution sichen meng1 xiaoyin wang1 lu zhang1 hong mei1 1key laboratory of high confidence software technologies mi nistry of education 2school of electronics engineering and computer science pe king university beijing china mengsc11 wangxy06 zhanglu meih sei.pku.edu.cn abstract in practice it is common that a framework and its client programs evolve simultaneously.
thus develope rs of client programs may need to migrate their programs to the new release of the framework when the framework evolves.
as framework developers can hardly always guarantee backward compatibility during the evolution of a framework migrati on of its client program is often time consuming and error pro ne.
to facilitate this migration researchers have proposed tw o categories of approaches to identification of framework evolut ion operation based approachesand matching based approaches.to overcome the main limitations of the two categories of approaches we propose a novel approach named hima which is based on matching each pair of consecutive revisions record ed in the evolution history of the framework and aggregating revision level rules to obtain framework evolution rules .
we implemented our himaapproach as an eclipse plug in targeting at frameworks written in java using svn as the versioncontrol system.
we further performed an experimental study onhimatogether with a state of art approach named aura using six tasks based on three subject java frameworks.
our experimental results demonstrate that himaachieves higher precision and higher recall than aurain most circumstances and is never inferior to aurain terms of precision and recall in any circumstances although himais computationally more costly than aura.
keywords framework evolution software migration mining version history natural language processing i. introduction nowadays many developers choose to use software frameworks to reduce the cost and or improve the quality of application development.
just as other software product s software frameworks also need evolution to obtain new featuresand orimprovequality.as a result when a softwar e framework evolves developers of client programs of the framework may need to migrate their client programs to the new release of the framework to take advantage of the new release.
ideally developersof a frameworkshould guarant ee that the new release be backwardly compatible with each release before the new release so that developers of any client program using an old release of the framework are able to immediately migrate to the new release without further modifying the client program.
however researcher s e.g.
chow and notkin steyaert et al.
balaban et al.
and dig and johnson have identified the pervasive existence of backward incompatibility between a new release and an old release in frameworks.
wu et al.
presented an example of backward incompatibility ina widely used framework i.e.
between jhotdraw .
and .
.thus migrationfromanoldreleaseofaframeworktoa newreleasemayimplyextramodificationsoftheclientcode.
these modifications may typically be tedious and require a lot of effort .
to alleviate the backward incompatibilit y problem it is necessary to identify the evolution rules between the two releases of the framework.
in particular researchers e.g.
wu et al.
have demonstrated the necessity of automatically identifying four ty pes of evolution rules one to one i.e.
one method in the old release replaced by anothermethod in the new release oneto many i.e.
onemethodintheoldreleasereplacedbymore than one method in the new release many to one more than one method in the old release replaced by one method in the new release and simply deleted i.e.
methods in the old release not appearing and having no replacements in the new release .
in fact identification of framework evolution has become a research focus in recent years.
roughly speaking there are mainly two categories of approaches to identification of framework evolution.
first researchers e.g.
henkel and diwan have proposed operation based approaches which use integrated development environments ides to record change operations related to framework evolution and replay the recorded operations to identify framework evolution.
thes e approaches typically are able to achieve both high recall and highprecision1 but the requirementofusing specialized idesmakestheminapplicableformostexistingframeworks.
second researchers e.g.
wu et al.
have proposed matching based approaches which compute evolution rules via matching the source code of the two releases.
due to the independence of ides matching based approaches are applicable for more existing frameworks.
but matchingbased approaches can hardly always achieve high precision without compromising recall due to the inability to sufficientlyuse finerinformationduringframeworkevolution.a s a sub category of matching based approaches there are also approaches e.g.
sch afer et al.
that analyze adaptat ions inonlyinstantiationcodetoinferframework evolutionru les.
1recall refers to the ratio of correctly identified rules to al l genuine rules and precision refers to the ratio of correctly identified rul es to all identified rules.the use of instantiation code2may help improve precision but the reliance on only instantiation code makes these approaches difficult to obtain rules related to application programming interfaces apis not used in instantiation code.
in this paper we propose a hi story based ma tching approach named hima to identification of framework evolution.
the basic idea of himais to identify change rules related to framework evolution via matching each pair of consecutive revisions of the framework stored in its versio ncontrol system e.g.
svn3 and aggregate the revisionlevel rules to obtain the evolution rules between the two releases.
to achieve wide applicability himarelies on only information stored in common software development infrastructure.
to achieve both high precision and high recall himaanalyzes all revisions between the two releases during the evolution history of the framework.
moreover as our empirical investigation has identified that comments associated with revisions often contain information about framework evolution we also utilize these comments in himato further improve precision and recall.
to evaluate our himaapproach we conducted an experimental study of himatogether with a recently proposed matching based approach i.e.
aura using six tasks based on three subject java frameworks.
our experimental results demonstrate that himaachieves higher precision and higher recall than aurain most circumstances and is never inferior to aurain any circumstances although the computational cost of himais higher than that of aura.
this paper makes the following main contributions anovelapproach whichovercomesmainlimitationsof both categories of existing approaches to identification of framework evolution.
a technique based on natural language processing to identify change rules from comments associated with framework revisions.
an experimental comparison of our approach with auratodemonstratetheeffectivenessofourapproach.
the remaining of this paper is organized as follows.
section ii reviews existing research related to ours.
section i ii presents our approach.
section iv reports an experimental study of our approach.
section v discusses further issues.
section vi concludes with pointers to future work.
ii.
relatedwork a. identification of framework evolution for the ease of presentation we classify existing approaches to identification of framework evolution into two categories operation based approaches and matching based approaches.
2researchers typically refer to the code invoking framework apis as instantiation code when investigating framework evoluti on identification.
3subversion.apache.org accessed in march operation based approaches the basic idea of operation based approaches is to record change operations performedonthe frameworkin anide andreplaythe operationsto identifyframeworkevolution.henkel anddiwan proposed catchup!
which uses a specialized ide to record refactoring operations performed on apis of the framework and replay these operations to update client code.
moreover dig et al.
proposed a refactoring aware software configuration management tool named molhadoref which also utilizes recordingand replaying of change operations to merge versions.
although molhadoref does not explicitly target at identification of framework evolution it can be adapted for this purpose.
as api refactoring operations can accurately characterize how the framework evolves operation based approaches are typically very accurate.
that is to say both recall and precision of operation based approaches can be very high.
however recording and maintaining api refactoring operationsalong the evolution historyof the frameworkmay be a burden for framework developers.
thus although some widely used ides e.g.
jbuilder already provide the capability of recording change operations many existing frameworks are developed with ides not providing or switching off the capability of recordingchange operatio ns.
as a result operation based approaches are not widely applicable for existing frameworks.
to overcome limitations of existing operation based approaches our approach is based on revisions instead of operations in the evolution history of the framework.
due to the wide adoption of version control systems e.g.
svn in practice there may typically exist a large number of revisions between two releases of a framework.
of course information in revisions is still less fine than information in operations.
but the availability of revisions is much higher than that of operations.
moreover as developers often provide a summary of change in the form of plain texts associated with a revision our approach also uses thi s information to further improve accuracy.
matching based approaches the basic idea of matching based approaches is to compare the source code of the two releases and figure out evolution rules from the differences between the two releases using some heuristics .
in particular researchers have investigated the followin g typesof heuristics heuristicsbased on call dependency heuristics based on text similarity heuris tics based on structure similarity and heuristics based on metrics .
some approaches even use more than one type of heuristics.
godfrey and zou proposed to use origin analysis which relies on heuristics based on text similarity call dependency and metrics to infer evolution rules.
as godfrey and zou s approach is semi automatic s. kim et al.
further proposedtoautomatetheirapproach.wei gerberanddiehl proposed to use metrics based on syntactical differences to infer candidate refactorings from changes between file versions and use clone analysis to rank the candidate refactorings.
xing and stroulia proposed diff catchup which matches two models written in the unified modeling language uml using heuristics based on text similarity andstructuresimilarity.m.kimetal.
summarizedsome patterns for name changes during framework evolution and used these patterns to infer rules of framework evolution.
the most advanced matching based approach is aura which involves multiple rounds of iteration using heuristi cs based on call dependency and text similarity.
according to wu et al.
the auraapproach is able to overcome several limitations of previous approaches and vastly improve recall.
however auratypically concedes some decrease in precisionand in some special cases the decrease in precisio n may be significant.
it should be noted that some of the preceding heuristics canbeextendedtoinstantiationcodetoexplorehowinstant iation code of the framework adapts to framework evolution.
sch afer et al.
proposed to infer rules of framework evolutionfromthe changesin client code for migratingfrom onereleasetoanother.dagenaisandrobillard propose d semdiff which infers rules of framework evolution via analyzing how the framework changes itself in response to its evolution.
due to the abundance of adaptation examples for framework evolution using instantiation code can improve precision due to the capability to corroborate between adap tationexamples.moreover semdiffconsidersadaptationsin the evolution history between the two releases.
the use of adaptationinformationinafinergranularityfurtherimpro ves its accuracy.
however rules inferred from instantiation c ode do not include those related to apis not used in instantiatio n code.
that is to say using only instantiation code may even decrease recall.
note that frameworks typically contain co ld spots whichareapisseldomusedininstantiationcode .
as matching based approaches do not rely on recorded operations applicability of matching based approaches i s typically higher than operation based approaches.
howeve r matching based approaches can hardly always be very accurate due to the inability to sufficiently use finer evolutio n information.
in fact matching based approaches typicall y need to balance between precision and recall.
in general th e auraapproach makes a good trade off between precision and recall but some complex changes inside method bodies may mislead aura .
to overcome limitations of existing matching based approaches our approach uses finer information recorded in revisions together with their comments recorded in the evolution history of the framework.
because of the abundance of information our approach is able to use strict criteria to identify enough rules and corroborate among the information to discard incorrect rules.
note that althoug hwei gerber and diehl s approach4 also utilizes file versions in version control systems their approach aims t o infer possible refactorings from one transaction committe d to a framework but not to further aggregate refactorings inferred from multiple transactions to obtain evolution ru les between two releases of the framework.
furthermore their approachdoesnot utilizecommentsassociated with version s and requires human intervention to check the ranked list.
b. natural language processing for software engineering sawyer et al.
proposed revere which combines part of speech pos tagging and semantic tagging to synthesize requirements from documents.
fantechi et al.
proposed to analyze use case descriptions in natura l languagesusing natural languageparsing .
kof pro posed to use pos taggingto analyzerequirementdocuments to obtain missing objects and actions.
shepherd et al.
proposed to locate and understand action oriented concern s in programs using a combination of several natural languageprocessing nlp techniques.tan et al.
proposed icomment which combines nlp and other techniques to extract explicit program rules and detects inconsistencie s between comments and source code.
on top of icomment tan et al.
proposed acomment which combines nlp with call graph analysis to infer specifications for interruptions and detects interruption related bugs.
zhong et al.
proposed doc2spec which combines named entity recognition ner and class hierarchy analysis to inf er implicit specifications from object oriented api document s. abebe and tonella proposed to use natural language parsing to extract concepts from source code.
to our knowledge our approach which uses specialized nlp techniques with natural language parsing to infer change rules from revision comments is the first approach that applies nlp for framework evolution identification.
iii.
ourapproach a. basic idea the basic idea of our approach is to identify change rules between each pair of consecutive revisions and aggregate these change rules to obtain the evolution rules between the two releases.
note that a mainstream version control system such as svn typically records every revision subversion of the entire software system under development.
intuitively these revisions provide more information of changesmade in the evolution history of the framework.for example struts .
and struts .
.
correspond to revision s and in its corresponding svn repository with revisions containing code changes in between.
furthermore according to our empirical evidence framework developersoftensummarizethe main changesbetween a revision and its predecessor revision in the comment for 4wei gerber and diehl s approach actually targets at refact oring identification which is slightly different from framework evolut ion identification.
pleaserefer tosch afer etal.
forfurther discussion on themaindifference between the two problems.checkingin the successor revision.when identifyingchang e rules between two revisions we use the comment associated with the successor revision as our initial clues.
b. matching two consecutive revisions we use the following two main steps to identify change rules between two revisions.
first we analyze the comment of the successor revision to identify some raw change rules and validate the raw change rules against the source code to obtain a set of initial change rules.
second we expand the set of identified initial change rules to obtain change rules for other changes between the two revisions.
unlike aura to reduce computational cost we do not use iteration.
identifyinginitialchangerules we usethefollowing five sub steps to identify initial change rules.
first we split the entire comment into sentences.
in natural language processing delimiter punctuation marks e.g.
?
!
and .
serve as separations of sentences.
we also rely on these delimiters but we need to handle the following two special cases.
the first case is the dot mark serving as a connector of a class and its member e.g.
circle.tostring .to deal with this case we use a dot together with a following space instead of mere a dot as a delimiter.
the second case is the hard new line symbol.
as developers may directly use a hard new line symbol to start a new sentence we also count hard new line symbols as delimiters.
second wefilter outirrelevantsentencesasfollows.here we are primarily interested in words and phrases meaning either addition deletion or replacement which are refer red to aschange identifiers in this paper.
in fact we maintain three synonym lists which we put on our project website to keep them always consistent with our implementation each representing a change type which could be addition deletion orreplacement .furthermore we arealso interested in sentences containing entity names i.e.
class names or method names .
in particular we deem the following cases as entitynames a wordafterthe word class orthe word method a pair of empty parenthesis or a pair of parenthesis inside which the text matches the syntax of method signatures a word immediately following a dot e.g.
resizeincircle.resize and a word composed of several words throughunderlinesor capitalization of the f ollowing words e.g.
contenttransferencodingfield .
thus we keep only those sentences that contain at least one change identifier and at least one entity name.
note that the criteria for entity names considered here may not be very accurate.
the aim of using these criteria is to filter out irrelevant sentences and we further validate entity names in the final sub step.
third for each remaining sentence after the filtering in the second sub step if all the change identifiers are of the samechangetype denotedas t we extractonerawchange rule of change type tconsisting of all the entity names in the sentence.
for example if a sentence contains threeentity names denoted as name1 name2andname3 and thechange type isaddition we denote the change rule as addition name1 name2 name3 .
fourth if such a sentence contains change identifiers of more than one change type we extract more than one change rule for this sentence.
to achieve this goal we use a natural language parser to identify the verbs in the sentence and all the words associated with each verb.
if such a verb is a change identifier we extract a rule for the verb considering only entity names associated with the verb in a way similar to the third sub step.
for example from sentence we added method a and changed method b to b1 our comment analysis is able to identify two raw rules addition a and replacement b b1 .
according to our experience there are only a few sentences containing change identifiers of two or more change types.
thus the heavy weight natural language parsing would not be of too much a burden.
finally we validate and refine the raw change rules identified in the third and the fourth sub steps against the source code of the two revisions.
in particular we use the following strategies for our validation and refinement.
if the raw rule type is addition for each entity name denoted as n in this rule we check whether nexists in the successor revision and does not exist in the predecessor revision.
if so we keep nin the rule and otherwise we remove nfrom the rule.
if nis a method name we deem nas annewly added method.
if nis a class name we deem all methods in class nasnewlyaddedmethods.
if the raw rule type is deletion for each entity name denoted as n in this rule we check whether nexists in the predecessor revision and does not exist in the successor revision.
if so we keep nin the rule and otherwise we remove nfrom the rule.
if nis a method name we deem nas asimply deleted method.
if nis a class name we deem all methods in class nassimplydeletedmethods.
iftherawruletypeis replacement foreachentityname denoted as n in this rule we check whether nexists in the predecessor revision or exists in the successor revision.
here we demand that all the entity names in this rule are class names or all the entity names are method names otherwise we ignore this raw rule due to uncertainty of whether it is class replacement or method replacement.
we also ignore all entity names not appearing in either the predecessor revision or the successor revision.
among the remaining entity names we deem entity names appearing only in the successor revision as target entities and we deem the other entity names as source entities.
according to dig et al.
and sch afer et al.
developers may keep both the source entity and the target entity in the successor revision for backward compatibility.predecessor revision successor revision mimeboundaryinput stream.parenteof mimeboundaryinput stream.consume streamcursor.adv ancetoboundary streamcursor.
isended streamcursor.adv ancetoboundary streamcursor.
isended mimeboundaryinput stream.eof figure .
example for caller analysis similarly we transform class replacement to method replacement a one to one rule for each pair of exactly matched methods and one replacement rule for all the remaining methods.
thus depending on the number of the source methods and the number of the target methods each resulting change rule can be of one of the following types one to one many to one one tomany or even many to many .
expanding initial set of change rules to expand the initial set of change rules identified in the first main step similar to existing matching based approaches we also rel y on call dependency analysis.
however as the differences between two consecutive revisions are typically very small we are able to use strict criteria without thresholds for our expansion.
first we analyze the source code of the two revisions to obtain the set of source methods i.e.
methods in the predecessor revision but not in the successor revision and the set of target methods i.e.
methods in the successor revisionbut notinthe predecessorrevision .we also remov e methods already appearing in the initial set of change rules from the two sets.
we denote the resulting set of source methods as msand the resulting set of target methods as mt.
second based on ms mtand change rules identified in the first main step we use caller analysis to expand changerulesasfollows.the intuitionis that methodsalway s invoked in the same contexts may have correspondence.
given method sin the predecessor revision and method tin the successor revision we call tmatchessthroughone toonerelationships denoted as m s t if and only if the signature of tis exactly the same as that of sor there is aone to one rule identified in the first main step between sandt.
for a set of methods in the predecessor revision denotedas s anda set ofmethodsin thesuccessor revision denoted as t we extend the definition of m s t to definem s t as formula .
m s t true s s t t m s t t t s s m s t false otherwise.
predecessor revision successor revision vfsbrowser.handle message vfsbrowser.pro pertieschanged browserview.up datefileview editplugin.upda tepopupmenu vfsbrowser.m aybereload directory vfsbrowser.pro pertieschanged browserview.up datefileview editplugin.upda tepopupmenu vfsbrowser.handle propertieschanged vfsbrowser.han dlebufferupdate vfsbrowser.hand lepluginupdate vfsbrowser.han dlevfsupdate vfsbrowser.m aybereload directory figure .
example for callee analysis thus given a method denoted as ms inmsand a method denoted as mt inmt let us denote the set of callers of msin the predecessor revision as caller ms and the set of callers of mtin the successor revision ascaller mt .
we deem that there is a replacement relationship between mtandms if and only if m caller ms caller mt .
note that we rely on only identified one to one relationshipsbetween methodsto guarantee precision.
due to our definition of m it is likely for us to identify a subset denoted as m s ofmsand a subset denoted as m t ofmtsuch that there is a replacement relationship between each method in m tand each method inm s. that is to say one expanded change rule may be either aone to one rule amany to one rule aone to many rule or even a many to many rule dependingon the number of methods in m sand the number of methods in m t. figure depicts an example from mime4j for expansion with caller analysis .
in the figure methods advancetoboundary andisended appear in both the predecessor revision and successor revision.
we need to identify the relationships between methods parenteof andconsume appearing in only the predecessor revision and method eof appearing in only the successor revision.
as both parenteof andeof are called by only isended we identify a one to one rule parenteof replaced by eof .
we identify no rule for consume in this sub step.
third based on ms mtand change rules identified in the first main step we also use callee analysis to expand change rules.
the intuition is that methods sharing very similar calling structures in implementation may have corr espondence.similarto our calleranalysis ourcalleeanalysis is also based on existing one to one relationships.
however we also need to further consider unaligned matching of callees in callee analysis .
given a subset denoted as m s ofmsand a subset denoted as m t ofmt we deem that there is a replacement rule between m sandm tif and only ifm uniontext ms m scallee ms uniontext mt m tcallee mt wherecallee m denotes the set of callees of method m. to ensure the atomicity of the identified replacement rule we also demand that there is no replacement rule identified in this sub step between any subset other than m sitself and any subset other than m titself.
figure depicts an example from jedit for expansion withcallee analysis .
in this figure the following four methodsappearinboththepredecessorrevisionandthesuccesso r revision propertieschanged updatefileview updatepopupmenu and maybereloaddirectory .
in the predecessor revision all the four methods are called byhandlemessage but in the successor revision each of the four method is called by only one method.
using the preceding callee analysis we are able to identify the splitting of the method for handling all messages into four methods each handling a specific type of messages.
fourth among the remaining methods in msandmt we further use some mapping conditions which are actually inspired by wei gerber and diehl s conditions for local refactorings to identify one to one replacement between methods that have no calling relationships with other methods.
let us use n m r m andp m to denote the name the return type and the parameters of m respectively.
if there exist m1 msandm2 mt such that m1andm2are in the same class and satisfy one of the following conditions n m1 ne ationslash n m2 r m1 r m2 p m1 p m2 n m1 n m2 r m1 ne ationslash r m2 p m1 p m2 or n m1 n m2 r m1 r m2 p m1 ne ationslash p m2 we deem that there is a one to one rule in the form of m1 replaced by m2.
finally if there are still methods in msassociated with no change rules we deem them as simply deleted .
similarly if there are still methods in mtassociated with no change rules we deem them as newly added .
it should be noted that if a simply deleted methodmin class xactually overrides another method m defined in a super class of x we adjust the rule for deleting mto a replacement rule i.e.
mreplaced by m because the semantics of deleting min object orientation is to direct calls of mtom .
c. aggregating change rules supposing that we have nrevisions denoted as r1 r2 ...rn wherer1andrnare two releases of the framework and we have identified a set of change rules between each pair of consecutiverevisions we aggregatethes e change rules as follows.
we aggregate rules for changing fromr1tor2with rules for changing from r2andr3to obtain rules for changing from r1tor3.
we continue this aggregation process until we get rules for changing from r1torn.
for the ease of presentation we focus on how we aggregate change rules between r1andr2with change rules between r2andr3below.
first we deem either a rule for a newly added method or a rule for a simply deleted rule as a rule for method replacement.
that is to say a change rule is in the formof a set of methods denoted s in the predecessor revision replaced by a set of methods denotedas t in the successor revision.
if sis empty the rule is a rule for newly added methods.in such a case we break the rule into several rules each of which is about one newly added method.
if tis empty the rule is a rule for simply deleted methods.
in such a case we also break the rule into several rules each of whichisaboutone simply deleted method.thus anychange ruleris in the form of source r replaced by target r .
let us denote the set of rules for changing r1tor2as rs1 a1 a2 ...ak and the set of rules for changing r2 tor3asrs2 b1 b2 ...bm .
second we deem both change rules in rs1 2not related to any change rules in rs2 3and change rules in rs2 not related to any change rules in rs1 2as rules for changing from r1tor3.
change rule ainrs1 2and change rule binrs2 3are related to each other denoted asrelate a b if and only if target a source b ne ationslash .
third among the remaining related change rules in rs1 2andrs2 we rewrite these change rules as follows.
for such a rule denoted as a inrs1 we calculate the set of rules that are transitively related toa.
two rules denoted as xandy inrs1 rs2 3are transitively related to each other denoted astranrelate x y if and only if relate x y or c1 c2 ...cp rs1 rs2 c1 x cp y relate ci ci i p .
supposing that the set of rules that are transitively related to ais rs rs wherers rs1 2andrs rs2 we have the following rule for changing from r1tor3 uniontext c rs 2source c uniontext c rs 3source c uniontext c rs 2target c replaced by uniontext c rs 3target c uniontext c rs 2target c uniontext c rs 3source c .
we continue to rewrite the remaining rules until we have rewritten all the change rules in rs1 rs2 .
supposing that we have the rule of a replaced by b1 and b2 for changing from revision r1to revision r2and the rule of b2 and b3 replaced by c for changing from revisionr2to revision r3 the preceding rule rewriting enables us to identify the rule of a and b3 replaced by b1 and c for changing from revision r1to revision r3.
fourth we further resolve conflicts between change rules.
in particular we consider the following two cases of conflicts.
the first case is a conflict between a rule for a simplydeletedmethod and a rule for a newly added method.
this conflict occurs when a method already deleted in r2is added back in r3.
for such a case we drop both rules.
the second case is a conflict between a rule for a simply deleted method and a rule for method replacement.
this conflict occurs when a method is replaced by another method in r2 but still kept for backward compatibility and the obsolete method is deleted in r3.
for such a case we drop the rule for thesimply deleted method.
finally after we have obtained the change rules betweentable i basic information of the subjects framework release sizepackages classes methods kloc .
jedit .
.
.
struts .
.
.
.
.
mime4j .
.
r1andrn we validate the rules against the source code ofr1andrnin the same way as the validation of rules in section iii b1.
note that as rules between some revisions may not be fully accurate we need to check the resulting rules to get rid of invalid rules.
d. implementation we implemented our himaapproach as an eclipse plugin for java frameworks that use svn as the version control system.
as mentioned previously himarelies on svn to locate each revision of the framework.
our implementation further utilizes features of svn and java to avoid unnecessary code analysis.
first svn enables us to focus on only the changed files when matching two revisions.
second as classes in java programs correspond to files our implementation directly derives information for addition or deletion of classes when encounteringaddedor deleted files .
furthermore we implemented our comment analysis on top of an open source tool for nlp named opennlp5.
iv.
experimental study to evaluate our himaapproach we conducted an experimental study on hima.
in our experimental study we investigated the following two research questions.
rq1 how effective is our himaapproach in comparison with existing approaches?
rq2 how do the four main techniques in our hima approach contribute to the overall effectiveness?
the first research question is concerned with whether himais competitivewith existingapproachesto frameworkevolution identification.
the second research question is concerned with how the main techniques in himaimpact the effectiveness of hima.
a. experimental design as there exist quite a few approaches to frameworkevolution identification we compared our himaapproach withaura6in our experimental study when investigating the effectiveness of hima.
there are mainly two reasons for us to choose aurafor comparison.
first aurais a state of art approach to framework evolution identificat ion andauraprovides several advanced features that previous 5opennlp.sourceforge.net projects.html accessed in mar ch access ed in march 2012table ii overall effectiveness framework hima aura task ide.cor.
pre.
ide.cor.pre.
jedit task1 .
.
jedit task2 .
.
struts task1 .
.
struts task2 .
.
mime4j task1 .
.
mime4j task2 .
.
approaches do not provide please refer to our discussion in sectionv .
second wu et al.
haveempiricallycompared aurawith several existing approaches i.e.
m. kim et al.
s approach sch afer et al.
s approach and the semdiff approach and demonstrated the competitiveness and even superiorness of aura.
inourexperimentalstudy we usedthreeopen sourcejava frameworks as subjects struts7 jedit8 and mime4j9.
struts is a framework for developing java web applications jedit is a text editor with apis for users to develop plug ins and mime4j is a framework for developingapplications that analyze email messages.
the reasons for choosing these three java frameworks are as follows.
first all the three subjects are frameworks of medium sizes and thus it is feasible for us to manually inspect whether each identified rule is correct.
second some of the subjects e.g.
jedit an d struts have been used in previous studies e.g.
m. kim et al.
sch afer et al.
and wu et al.
and thus it is helpful to compare our experimental results with theirs.
for each subject we applied himaandaurafor two tasksinvolvingthreereleases.
that is to say foreach subj ect the first task is based on the first two releases and the second task is based on the last two releases.
thus we are able to check whether the experimented approaches performed consistently on each subject.
for example based on jedit we formed the following two tasks for framework evolution identification from release .
to release .
and from release .
to release .
.
note that to avoid basing our experiments in a scenario in favor of our approach we did not use the task based on the first and the third releases for each subject.
table i depicts the basic information of the three releases of each subject.
for each subject and each task either himaoraura identified a set of evolution rules.
as auraidentifies only four types of rules i.e.
simply deleted one to one one tomany andmany to one we considered rules of only these four types in our experimental study.
we adopted a way similar to wu et al.
to determine the correctness of identified rules.
that is to say for each set of identified evolution rules we manually inspected whether each rule in the set is correct with the help of framework documentation.
in particular the first and the second authors of this paper 7struts.apache.org accessed in march accessed in march 9james.apache.org mime4j accessed in march 2012table iii overall effectiveness for different types of rules framework simply deleted one to one one to many many to one task hima aura hima aura hima aura hima aura ide.cor.pre.ide.cor.pre.ide.cor.pre.ide.cor.pre.ide.cor.pre.ide.cor.pre.ide.cor.pre.ide.cor.pre.
jedit t1 .
.
.
.
.
.
.
.
jedit t2 .
.
.
.
.
.
.
.
struts t1 .
.
.
.
00struts t2 .
.
.
.
00mime4j t1 .
.
.
.
.
mime4j t2 .
.
.
.
.
00table iv detailed comparison of identified rules framework hima aura onlyhima onlyaura task ide.
cor.ide.cor.ide.cor.
jedit task1 jedit task2 struts task1 struts task2 mime4j task1 mime4j task2 togetherwithanothertwostudents notauthorsofthispape r participated in the manual inspection and we ensured that each identified rule was inspected by at least two inspectors .
in case of conflicts all the related inspectors discussed fa ce to face to resolve the conflicts.
in our manual inspection we payed special attention to the rules identified by only hima andtherulesidentifiedbyonly aura becausehumanerrors made on determining the correctness of such rules would affecthimaandauradifferently.
we put the detailed information of the identified rules on our project website10.
as ourhimaapproach contains several techniques to investigate how the main techniques in himacontribute to itsoveralleffectiveness wefurtherexperimentallycomp ared five combinations of the main techniques in hima.
that is to say besides himaitself we also experimented with another four combinations each turning off one technical component.similar to the experimentalcomparisonbetween himaandaura we manually inspected the correctness of each identified rule and put the detailed information on our project website.
we also recorded the execution time for either hima oraurato perform each task on each subject.
all the execution time is based on executing himaandauraon windows with an intel core i5 .53ghz cpu and 6gb memory.
we used the execution time of himaandaura as an indicator for their performance.
b. results and analysis rq1 overall effectiveness table ii depicts the overall effectiveness of himaandaura.
in this table columns depict the number of rules identified by hima the numberofcorrectrulesidentifiedby hima andtheprecision ofhimain percentagepointsfor each subject and each task.
similar to columns columns depict these numbers foraura.fromtableii wehavethefollowingobservation.
10sourceforge.net projects himafor each subject and each task himaconsistently achieves higher precision than auraand ashimais able to always identify more correct evolution rules himaalso consistently achieves higher recall than aura although auraalso achieves competitive results.
for example for the first task on mime4j himaidentifies more correct rules and achieves ten percentage points higher in precisio n thanaura.
note that as we do not know the exact number of correct evolution rules in total for each of the six tasks we are not able to calculate the exact recall values for hima andaura.
we further compare the overall effectiveness of hima andaurain terms of each rule type in table iii.
similar to table ii columns headed by ide.
depict the numbers of identified rules columns headed by cor.
depict the numbers of correctly identified rules and columns headed by pre.
depictthe valuesof precision in percentagepoints.
from table iii we have the following observations.
first thetrendofoveralleffectivenessof himaandaura in terms of each rule type is similar to the trend of overall effectiveness for all types.
that is to say himaachieves both precision and recall no less than aurafor all circumstances.
this observation demonstrates hima s consistent superiorness over aurafor each rule type.
furthermore himanever achieves poor precision for any circumstances while there are some circumstances for aurato perform unsatisfactorily e.g.
the second task for aurato identify one to one rules for struts and the first task for aurato identify rules of simply deleted methods for mime4j .
it should be noted that there are correct rules i.e.
in the second task for jedit and in the first task for struts that himaandauraidentified as different types.
the reason is thathimadeems the deletion of an overridden method in a class as redirecting calls to a method in a superclass.
second neither himanorauraidentifies many rules for one to many ormany to one replacement.
we suspect the reason to be that frameworksare not commonto evolvewith one to many ormany to one replacement.
however identifing rules for one to many andmany to one replacement may still be important because migration tasks concerned withapisinvolvedin one to many andmany to one replacement may be more difficult than other migration tasks.
typically there are some rules that can be identified by both himaandaura.
to analyze the relationshipstable v contributions of the main techniques to the overall effectiv eness framework without comment without caller without callee without mapping hima all task ide.cor.
pre.
ide.cor.
pre.
ide.cor.pre.
ide.cor.
pre.
ide.cor.
pre.
jedit task1 .
.
.
.
.
jedit task2 .
.
.
.
.
struts task1 .
.
.
.
.
struts task2 .
.
.
.
.
mime4j task1 .
.
.
.
.
mime4j task2 .
.
.
.
.
between rules identified by himaand rules identified by aura we further provide a detailed comparison of rules identified by himaandaurain table iv.
in this table for each subject and each task columns depict the number of rules identified by both himaandaura and the numberof correct rulesamongthem columns4 depict the information for rules identified by only himabut notaura and rules identified by only aurabut nothima.
here we deem the correct rules that himaandauraclassified into different types as correctly identified by both himaand aura.
from table iv we have the following observations.
first the majority of correct rules can actually be identified by both himaandaura.
this observation thus confirms the effectiveness of both approaches.
second very few correct rules are identified by aurabut not by hima while there are quite some correct rules identified by hima but not by aura.
this observation indicates that although himaandauracan complement each other in practice himashould be preferred if only one approach can be used.
rq2 contributions of the four main techniques to compare the five combinations of the four main techniques in ourhimaapproach each column in table v depicts the results of one combination.
for example without comment denotes himawithout using comment analysis and hima all denotes himaitself.
from table v we have the following observation concerning the contributio ns of the main techniques in our himaapproach.
himawithout using either comment analysis callee analysis caller analysis ormapping conditions would typically identify fewer evolutionrules that can be correctlyidenti fied byhimausing all the techniques in some circumstances.
this observation indicates that all of the techniquesin hima are useful.
furthermore as turning off any of the four techniques in himamay not always result in significant decrease in the number of correctly identified evolution rules the effects of the four techniques may somehow overlap with each other for a specific framework.
it should be noted that the need for using all the four techniques in himaactually lies in the way for himato use them.
as himauses all the four techniques to match each pair of consecutive revisions slight loss in accuracy indu ced in matching some pair of revisions may affect the overall effectiveness.thus it is preferableforusto employmulti ple techniques to identify as many correct rules as possible for each pair of revisions.
supposing that we have one rule fortable vi execution time in minutes framework task task rev.
hima aura rev.
hima aura jedit .
.
.
.
struts .
.
.
.
mime4j .
.
.
.
changing revision r1to revision r2in the form of method a replaced by method b and one rule for changingrevision r2to revision r3in the form of method b replaced by method c failure to identify either of the two rules would result in failure to identify the rule method a replaced by method c for changing revision r1to revision r3.
c. performance table vi lists the execution time of himaandaurafor thesixtasks.columnsheadedby rev.
depictthenumbers of pairs of revisions used by hima.
from this table we can observe that the execution time of himais always much longer than that of aura.
in particular himais typically times more costly than auracomputationally.
we suspect the reason to be that himaneeds to analyze too much more revisions than aura.
for example for the first task on jedit himaanalyzed pairs of revisions butauraanalyzed only one pair of revisions.
as the aim of framework evolution identification is to facilitate the migration of client code and one framework may have a large number of clients the extra computational cost ofhimawould not be a big burden for its application.
furthermore as the execution time of himamay be more sensitive to the number of revisions himamay not be significantly less scalable than aurain response to the increaseof the frameworksize.
of course moreexperiments on large frameworks are necessary to further investigate hima s scalability.
d. threats to validity construct validity threats to construct validity are concerned with whether the measurement in the study reflects real world situations.
the main threat to construct validity in our study is the way of validating identified rule s. asweadoptedamanualprocesstocheckwhethereachidentified rule to be correct errors made in this manual process would bias our experimental results.
to reduce this threat four human inspectors carefully determined the correctnes s oftheidentifiedrulesensuringeachruleinspectedbyatlea st two inspectors.
note that existing studies e.g.
m. kim etal.
sch afer et al.
and wu et al.
typically ado pt manual inspection of identified rules to evaluate approache s to framework evolution identification.
internal validity threats to internal validity are concerned with the uncontrolled factors that may also be responsible for the experimental results.
in our study the main threat to internal validity is the possible faults in th e implementation of our approach.
to reduce this threat we reviewed all the code before conducting the study.
external validity threats to external validity are concerned with whether the experimental results are generalizable for other situations.
in our study the main threat to external validity lies in the representativeness of our subjects.
to reduce this threat we chose three subjects including two subjects used in previous research .
however as we experimented with frameworks written in only java using only svn as the version control system our experimental results may be specific to java and svn.
further reduction of this threat may require evaluation of our approach on frameworks written in other languages using other version control systems.
note that our approac h requires the version control system to support locating ea ch framework revision.
v. discussion in this section we discuss the following issues related to ourhimaapproach the strength and weakness of using revisions and comments the ability to identify plentiful types of rules the ability to avoid thresholds and the need to assist client migration.
use ofrevisionsand comments .themainstrengthofusing revisions is that the differencesbetween two consecuti ve revisions are much smaller than the differencesbetween two releases.
thus rule identification between two consecutiv e revisions could be more accurate than rule identification between two releases.
the main strength of using comments isthattheinformationincommentsisorthogonaltoinforma tion in source code.
thus conceding nlp s inaccuracy we are ableto use sourcecodeofrevisionsto validate andrefine raw rules identified from comments.
the main weakness of using revisions and comments is that the abundance of information may incur too much computational cost to use deep code analysis.
however our empirical results indicat e that shallow analysis on abundance of information may still be superior to deep analysis on scarceness of information.
automatic identification of plentiful types of rules .
in the literature researchers e.g.
wu et al.
have demonstrated that it is necessary to automatically identif y the four types i.e.
simply deleted one to one one to many andmany to one of evolution rules.
in fact aurais the first approach that satisfies this requirement.
our hima approach is able to not only satisfy this requirement but also outperform aurafor each type of rules.
in fact hima can also identify many to many rules which auracannot identify.avoiding threshold tuning .
according to wu et al.
not using thresholds is also a key feature of approaches to framework evolution identification because the use of thresholds implies tedious tuning for different contexts.
among all the existing automatic matching based approaches aurais the only approach that does not use any threshold.
in particular auraemploys a procedure to calculate the confidence of each identified rule and keeps only rules with confidence.
unlike aura as differences between two consecutive revisions are very small himais able to naturally avoid using any threshold by just keeping rules that satisfy our strict criteria.
assisting client migration .
it should be noted that the final goal of framework evolution identification is to automate the migration of client code.
to achieve this goal it is necessary to further identify framework evolution rel ated usage patterns.
in fact zhong et al.
and nyuyen et al.
have investigated techniques that may help obtain such patterns.
vi.
conclusion and futurework in this paper we have proposed a novel approach named himato identification of framework evolution.
the distinctive feature of our himaapproach is to match each pair of consecutive revisions in the evolution history of the framework and aggregate revision level rules to form evolution rules between the two releases.
to evaluate our himaapproach we empiricallycompared himawithaura using three java frameworks as subjects.
our empirical results indicate that for both precision and recall himais superiorto aurainmostcircumstancesandisneverinferior toaurain any circumstances.
due to the use of a large number of revisions himais computationally more costly thanaura.
however the higher cost in computation would not be an inhibitive factor for the application of hima.
infuturework weplantoinvestigatethefollowingissues.
first we plan to implement himafor other languages and other version control systems and conduct further experiments to address the main threats to the validity of our experimentalstudy.
second as client code providesa sourc e of information not utilized in our approach we plan to incorporate analysis of client code into our approach to further improve the accuracy of our approach.
finally we plan to further investigate optimization of the matching between each pair of revisions so as to incorporate deeper analysis for higher accuracy.