an empirical investigation into the role of api level refactorings during software evolution miryung kim the university of texas at austin austin tx miryung ece.utexas.edudongxiang cai sunghun kim hong kong university of science and technology hong kong china caidx hunkim cse.ust.hk abstract it is widely believed that refactoring improves software quality and programmer productivity by making it easier to maintain and understand software systems.
however the role of refactorings has not been systematically investigated using fine grained evolution history.
we quantitatively and qualitatively studied api level refactorings and bug fixes in three large open source projects totaling revisions of evolution.
the study found several surprising results one there is an increase in the number of bug fixes after api level refactorings.
two the time taken to fix bugs is shorter after api level refactorings than before.
three a large number of refactoring revisions include bug fixes at the same time or are related to later bug fix revisions.
four api level refactorings occur more frequently before than after major software releases.
these results call for re thinking refactoring s true benefits.
furthermore frequent floss refactoring mistakes observed in this study call for new software engineering tools to support safe application of refactoring and behavior modifying edits together.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring general terms measurement experimentation keywords software evolution empirical study refactoring defects release cycle a part of the research was conducted while dongxiang cai was an intern at the university of texas at austin.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction refactoring is the process of changing a program s design structure without modifying its external functional behavior in order to improve program readability maintainability and extensibility .
it has been widely believed that refactoring improves software quality and developer productivity by making it easier to maintain and understand software systems and that a lack of refactorings incurs technical debt to be repaid in the future to reduce increasing system complexity .
there has been a conventional wisdom that software engineers often avoid refactorings when they are constrained by a lack of resources e.g.
right before major software releases as refactorings do not provide immediate benefit unlike new features or bug fixes.
some questioned the benefit of refactorings since refactorings often introduce a large amount of structural changes to the system creating code churns shown to be correlated with defect density .
wei gerber and diehl found that a high ratio of refactorings is sometimes followed by an increasing ratio of bug reports .
they found that bugs are introduced by incomplete or incorrectly done refactorings even though the original intent of refactoring was to improve software maintainability.
ratzinger et al.
found contradicting evidence that the number of defects decreases if the number of refactorings increases in the preceding time period.
the goal of this paper is to systematically investigate the role of refactorings during software evolution by examining the relationships between refactorings bug fixes the time to resolve bugs and release cycles using fine grained version histories.
first we applied m. kim et al.
s refactoring reconstruction technique to version histories to find revisions that underwent rename move and signature changes at or above the level of method headers .
we used this technique because the documentation about past refactorings is often unavailable in most version histories.
second we applied s. kim et al.
s bug history extraction technique to identify bug fix revisions .
to mitigate construct validity concerns we sampled a total of one hundred revisions and manually investigated their commit messages associated bug reports and corresponding code changes to measure the accuracy of the tools.
we then investigated the number of bug fixes and the time taken to fix bugs within a sliding window of k revisions before and after each refactoring revision and measured refactoring density and fix density within a sliding window of k revisions before and after each major release.
the following paragraphs summarizes our findings for eachhypothesis about api level refactorings move rename and signature changes at the method declaration level.
h1 are there more bug fixes after api level refactorings?
we found that a bug fix rate is higher after api level refactorings than the preceding period e.g.
from .
to .
when examining revisions before and after api level refactorings in eclipse jdt.
we manually investigated bug fixes that follow after refactorings and found that a fix rate increase is often caused by mistakes in applying refactorings and behavior modifying edits together.
h2 do api level refactorings improve developer productivity?
we compared the time taken to fix bugs for those that were closed within revisions before and after refactorings.
the time taken to fix those bugs decreases by about .
to .
after refactorings.
h3 do api level refactorings facilitate bug fixes?
we found that .
to .
of refactoring revisions also include bug fixes in the same revision.
furthermore of refactoring revisions were related to fix revisions that follow within revisions as opposed to of non refactoring revisions being related to later bug fixes within revisions.
this implies that in many cases either refactorings created new bugs or refactorings may have been applied to facilitate bug fixes that were hard to implement without them.
h4 are there relatively fewer api level refactorings before major releases?
there are .
more refactoring revisions within revisions before major releases than revisions after the releases.
this result is surprising because developers do not avoid refactorings even when they have a pressure to meet deadlines.
in conjunction with the fact that many revisions include both refactorings and bug fixes we speculate that refactorings were done to facilitate bug fixes that needed to be implemented before major releases.
these results call for an in depth investigation of refactoring s true benefits and the economic implications of refactoring investment.
furthermore frequent floss refactoring mistakes observed in the study call for new software engineering tools to help developers apply systematic coordinated refactorings safely.
the rest of the paper is organized as follows.
section discusses related work and section describes our data collection and analysis method.
section presents our results section describes threats to validity and section presents future directions and summarizes the implication of our results.
.
related work empirical studies on refactoring.
xing and stroulia studied eclipse s evolution history and found that of 1floss refactoring is a term coined by murphy hill et al.
to describe refactorings interleaved with behavior modifying edits .structural changes are due to refactorings and existing ides lack support for complex refactorings .
dig et al.
studied the role of refactorings in api evolution and found that of the changes that break client applications are api level refactorings .
while these studies focus on the frequency and types of refactorings our study focuses on the relationship between api level refactorings bug fixes and release cycles.
hindle et al.
found that large commits are more perfective refactorings while small commits are more corrective bug fixes .
purushothaman and perry found that nearly of changes involved only a single line of code which has less than a chance to result in error while a change of lines or more has nearly a chance of causing at least one defect.
though the focus of these studies is different from our study the results are somewhat aligned with ours large commits which tend to include refactorings have a higher chance of inducing bugs.
wei gerber and diehl found that refactorings often occur together with other types of changes and that refactorings are followed by an increasing number of bugs .
carriere et al.
s case study found that the productivity measure manifested by the average time taken to resolve tickets decreases after re architecting the system .
ratzinger et al.
developed defect prediction models based on software evolution attributes and found that refactoring related features and defects have an inverse correlation if the number of refactorings increases in the preceding time period the number of defects decreases.
our results are aligned with some of these findings yet improve upon these studies.
our study method not only relates refactorings and bug fixes based on their temporal proximity using a k revision sliding window but also considers method level location of refactorings and bug fixes to examine whether bug fixes are related to a preceding refactoring.
though the intent of refactoring is to improve software maintainability refactoring could be potentially error prone as it often requires coordinated edits across different parts of a system.
several researchers found such evidence from open source project histories m. kim et.al.
s program differencing technique identifies exceptions to systematic change patterns which often arise from the failure to complete coordinated refactorings.
g org and wei gerber detect errors caused by incomplete refactorings by relating api level refactorings to the corresponding class hierarchy .
because manual refactoring is often tedious and errorprone modern ides provide features that automate the application of refactorings .
however recent research found several limitations of tool assisted refactorings.
daniel et al.
found dozens of bugs in the refactoring tools in popular ides .
murphy hill et al.
found that many refactoring tools do a poor job of communicating errors and programmers do not leverage them as effectively as they could .
they also found that programmers frequently intersperse refactorings with other program changes floss refactorings and these are not well supported by existing refactoring tools .
this need for safe floss refactoring application is also confirmed by our study refactoring often overlap with bug fixes behavior correcting transformations.
program metamorphosis relaxes behavior preservation checks to safely support floss refactorings .
refactoring reconstruction.
a number of existing tech table study subjects eclipse jdt core jedit columba type ide text editor email client period june may sep apr jul jan revisions of api level refactorings of bug fix revisions of refactoring revisions niques address the problem of automatically inferring refactorings from two program versions.
these techniques compare code elements in terms of their name and structure similarity to identify move and rename refactorings.
m. kim s technique used in the study is broadly in the same category its median precision and recall are in the ranges to and to and the comparison with five other approaches shows that its recall is higher while its precision is comparable to others.
a survey of existing refactoring reconstruction techniques is described elsewhere .
bug history extraction and analysis.
there are two well known techniques to extract bug fix data from version control systems.
fischer et al.
search for specific keywords such as bugorfixin revision logs to identify bug fix revisions .
another well known technique is to use the links between commits and bug reports because developers often leave a corresponding bug report id when resolving a bug.
since leaving special keywords or bug ids in change logs is optional for developers fix revision data could include noise.
for example aranda and venolia et al.
manually inspected ten bug reports and interviewed developers who resolved them .
they found important information about bug fix process is often missing in software repositories.
bird et al.
studied the quality of change logs and bug reports and found that it is difficult to reliably link all commits and bug reports .
however the quality of automatically collected fix revision data depends on projects and their change log quality.
in this paper we selected projects with high quality change logs based on our experience of mining bug repository data.
.
study approach we selected eclipse jdt jedit and columba as study subjects because we studied these subjects in the past and found that they have high quality change logs .
this enabled us to extract fix revision data reliably.
identification of refactoring revisions.
we used m. kim et al.
s refactoring reconstruction technique mk to identify systematic changes to api names and signatures at or above the level of method headers .
mk takes two program versions as input first identifies seed matches based on the method header name similarity and generalizes the transformation witnessed in a seed match to a high level systematic change pattern.
mk identifies rename refactoring at the level of packages classes methods add delete parameter refactoring move refactoring at the level of packages classes methods and changes to the return type of a method.
it does not analyze the internal content of method bodies and thus is limited to api level refactorings.
the details of the algorithm and evaluation are described elsewhere .
using this technique we found and refac torings in eclipse jedit and columba respectively see table .
we considered that a revision is a refactoring revision if the revision contains at least one api level refactoring.
identification of bug fix revisions.
we identified fix revisions by mining check in comments change logs which is a widely used heuristic in mining software repository research.
we first searched for keywords such as fixed or bug and identified a reference to a bug report number such as id .
this heuristic woks well with projects which have high quality change logs such as columba eclipse and jedit.
for example columba developers usually write at least one predefined tag e.g.
and in change logs.
eclipse and jedit have strict guidelines for writing check in messages.
if a commit message contains such fix revision indicators we considered it as a fix revision.
identification of bug introducing changes.
when a revision is determined to contain bug fixes it is possible to trace backward in the revision history to determine the corresponding bug introducing change .
we first use diff to determine what changed in each fix revision.
diff returns a list of consecutive deleted or added lines called hunks .
using a built in annotation functionality of a version control system such as svn blame we track down the origin of deleted or modified source lines in each hunk which we call as bug introducing changes.
change distilling.
for each revision we used change distiller to compute syntactic program differences .
this has two benefits this distilling process filters out meaningless changes in a revision because the revision may contain changes to comments license information white spaces etc.
change distiller maps the line level location of a bug fix to its container method to allow easy comparison with an api level refactoring location e.g.
method foowas renamed to method bar.
manual inspection of automatically collected data.
since our study approach relies on automatic refactoring and fix identification techniques it is important to ensure the automatic techniques are accurate enough for our study.
to evaluate the techniques we randomly sampled revisions from eclipse jdt core s revision to .
for each sampled revision one of the authors manually investigated the revision and determined whether it is a refactoring revision and or a fix revision based on three sources checkin comment an associated bug report linked by a bug id and code modification i.e.
diffassociated with the revision.
based on this investigation we manually identified api level refactoring revisions and fix revisions out of revisions see column in table .
we then compared this set with the automated tools results.
the evaluation shows that the mk has .
precision and .
recall row mk in identifying refactoring revisions.
the bugtable accuracy comparison automated techniques vs. manual inspection source prec.
recall mk .
.
refactoring manual c .
.
revisions manual b .
.
sk .
.
fix manual c .
.
revisions manual b .
.
fix revision identification technique has .
precision and .
recall row sk in identifying bug fix revisions.
we also compared the tools results with the data set labeled using an associated check in comment alone row manualc or using a bug report alone row manual b .
though the automated techniques accuracy .
and .
is not as good as manually inspecting all three information sources including code modification their accuracy are much higher than manually inspecting check in comments or bug report description alone.
overall we conclude that our fix revision data is accurate enough to base our investigation on and our refactoring revision data has a high precision and a recall about api level refactorings.
.
results section .
investigates changes to the number of bug fixes after refactorings and section .
investigates changes to the time taken to resolve bugs after refactorings.
section .
investigates the probability of refactorings and bug fixes to appear in the same revision and the probability of a refactoring revision to be related to later bug fixes and section .
investigates fix density and refactoring density with respect to software release cycles.
!
!
!
!
!
!
!
!
!
!
!
.
?
abc 8d 8e a cf f gh .
01fghi 2345678f ih j8k13 e l60 e figure fix rate before and after refactorings varying k from to .
are there more bug fixes after api level refactorings?
to understand the relationship between refactorings and the number of bug fixes we find all fix revisions within krevisions before and after for each refactoring revision.
then we compute a fix rate fix revisions k. figure shows average fix rates of k revisions before and after refactorings by varying k from to .
horizontal dotted lines show the average bug fix rate for each subject over its entire life time we observed.
in all three subjects the fix rate increases after refactorings.
for example the fix rate of revisions before refactoring noted as revision in figure is around .
while the fix rate of revisions after refactorings is .
for eclipse jdt.
for columba the fix rate of the revision is around .
and the revision is around .
.
!
.
.
!
?
?a bc bd figure an example method evolution history we also investigated a fix rate at the method granularity.
this technique computes fix rates more accurately by considering refactorings and bug fixes per method.
for each method we reconstructed its revision level history which includes information about when method level rename and move refactorings occurred and in which revision bug fixes were applied to the method.
figure shows an example change history method m.foo was created in revision it was renamed to method m.bar in the revision and a bug fix was applied to it at revision and .
using the same sliding window method we computed the fix rate for each method by varying the window size k from to .
figure describes the results at the method granularity.
the fix rate at the method level is much lower than the one at the revision level since most fixes did not happen in the same method location of a refactoring.
its trend is almost the same as figure .
the method level fix rate increases from .
to .
in eclipse jdt from .
to .
in jedit and from to .
in columba within revisions after api level refactorings compared to the preceding period.
to show the statistical significance of these rate differences the ttest is used .
our null hypothesis is the bug fix rates before and after api level refactorings are the same at the method level.
we reject the null hypothesis and accept the alternative hypothesis if the p value is smaller than .
.
the changes in fix rates are statistically significant with a p value of .70e in eclipse jdt .
in jedit and .12e05 in columba.
both at the revision and method level we observe that the fix rate after refactoring is higher than the fix rate before refactoring.
there are several possible explanations.
refactorings may introduce bugs and developers fix those new bugs after the refactorings.
or refactorings help developers identify and fix previously introduced latent bugs.
in order to investigate the fix rate increase after refactorings both at the revision and at the method level we conducted an in depth case study of the refactoring revisions in eclipse jdt followed by at least one bug fix to the same method location within revisions after the initial refactorings.
this process found revisions in eclipse jdt out!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
!
!
!
!
!
!
!
?
a !
!
bc8d3 !
!
e79f5g2 !
hdi87h jdk4 l 14m2n371di o5di hdi87h jdk4 l hdi87h jdk4 l 14m2n371di o5di 14m2n371di o5di ?
a bc8d3 e79f5g2 figure fix rate before and after refactorings at the method level varying k from to of which we randomly selected revisions for manual investigation.
we inspected the refactoring and associated fix revisions check in comments associated bug reports and code modifications.
the following five categories emerged from the investigation results.
i. floss refactoring refactoring combined with a bug fix is incomplete thus inducing a supplementary fix later.
for example olivier thomann tried to fix the bug id at revision .
later he fixed the same bug again at revision because the original bug fix was incorrect.
ii.
in order to fix several related bugs that are very hard to fix a developer first refactors code to enable bug fixes.
for example jerome lanneluc decided to fix bug ids and which are all related to the ast functionality.
he first refactored code at revision and then bug and bug are fixed at revision .
iii.
incorrect refactorings cause a bug which induces a later fix.
for example olivier thomann renamed method unnecessarynonnlstags tounnecessarynlstags but forgot to rename the related xml tag at revision .
he later renamed the related tag at revision .
iv.
after a developer performs refactorings she discovers a new bug or a design problem which induces a later fix.
for example jerome lanneluc tried to speed up a path look up feature by hashing on container paths at revision .
as he realized a design problem in the code he reported this issue as a bug report id and fixed it at revision .
v. a bug fix happened after a refactoring in the same location but they are not related.
for example david audel fixed bug id with a refactoring at revision and then at revision philippe mulet fixed another bug id which was introduced before revision .
table shows the categorization of inspected samples and lists refactoring revision number fix revision number pairs per category.
a pair followed by means that the two revisions are completed by the same author.
in cases out of the refactorings are indeed related to bug fixes.in cases of inspected samples later bug fixes are caused by floss refactoring mistakes during a bug fix.
this implies that though developers apply refactorings to facilitate bug fixes such refactorings often cause bugs as well.
this result calls for new software engineering tools that repair refactoring mistakes and support developers in applying coordinated refactorings consistently.
table categorization of inspected sample pairs of refactoring revision fix revision .
the mark indicates that the two revisions are completed by the same author.
refactoring revision fix revision i .
ii iii .
iv .
v .
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
?
12ab cd d !ef .
012d e g 3456789d eh i1 04i 1j bkc ?
12a l9m24 n71 figure latent bug density before and after refactorings k from to furthermore to investigate whether refactorings increase the number of latent bugs we calculated the number of fileswith bug introducing changes .
this technique traces the line level locations of bug fixes to previous revisions per file to identify which revision created the buggy code that was later modified by the fix.
we then computed latent bug density the number of files with bug introducing changes out of the total number of files at that revision.
figure shows the latent bug density computed by the same sliding window method varying k from to .
for all three subjects the bug density remains stable without much change after refactorings.
this implies that while some refactorings help developers identify and fix bugs some also introduce new bugs.
there is a short term increase in the number of bug fixes after refactorings.
.
do api level refactorings reduce the time taken to fix bugs?
!
!
.
.
.
!
figure four categories of bug fixes that were introduced and resolved near the timing of a refactoring to examine whether refactorings improve developer productivity we first identified bugs that were both introduced andresolved near the timing of refactorings and estimated the time taken to fix those bugs by measuring the timing of a bug fix minus the timing of a corresponding bug introducing change.
to compare the difference in productivity before and after refactorings for each refactoring revision r we further categorized nearby bug fixes closed within into four categories based on their introduction and resolution time in relation to the timing of refactorings see figure bb bugs that were introduced before r and fixed beforer.
i.e.
open k and closed k aa bugs that were introduced after r and fixed after r. i.e.
open k and closed k ba bugs that were introduced before r and fixed after r. i.e.
open xb bugs that were introduced at least krevisions before r and fixed before r. i.e.
open 2k k and closed k .
category xb was added for comparison with category ba because the maximum bug life time in category ba is 2k while bb is only k. figure shows an average time taken to fix bugs in each category when using k .
when comparing xb with ba there is .
decrease in jdt .
decrease in jedit and .
decrease in columba in the time taken to fix bugs after refactorings.
when comparing bb and aa there is .
and .
decrease in jdt and jedit respectively but a .
increase from .
to .
in columba.
overall we observed the bug fix time decrease after refactorings.
based on the results in section .
we speculate that developers discover bugs during refactorings and quickly fix them as they are already making changes to the involved code or they quickly fix incomplete refactorings as they recognize them.
another explanation is that refactorings combined with bug fixes often incur supplementary fixes which are usually smaller and easier to implement than main bug fixes.
when it comes to fixing bugs introduced near the time of refactorings the average fix time tends to decrease after refactorings.
.
do api level refactorings facilitate bug fixes?
the results in sections .
and .
motivated us to further investigate whether refactorings were done to facilitate bug fixes.
to examine how many refactorings were done as a part of a bug fix we first measured the extent of revisions that include both refactorings and bug fixes.
in table p f is the probability of a revision to include a bug fix p r is the probability of a revision to include an api level refactoring p r f is the conditional probability of including a refactoring given a bug fix revision.
p r f is the conditional probability of including a refactoring given that it is a not a fix revision.
we used the entire population of our refactoring revision and fix revision data to measure the proportions.
in eclipse jdt we found that more than .
refactoring revisions were associated with bug fixes .
in jedit and .
in columba .
furthermore the probability to include a refactoring given a fix revision is much higher than the probability to include a refactoring given a non fix revision .
vs. .
in eclipse .
vs. .
in jedit and .
vs. .
in columba .
the probability to include a fix given a refactoring revision is .
while the probability to include a fix given a non refactoring revision .
in eclipse.
interestingly jedit and columba show the opposite trends .
vs. .
in jedit and .
vs. .
in columba.
we also conducted a similar experiment at the method level because a fix revision may include more than one delta where refactorings were applied to only a subset of the deltas.
the results at the method level are slightly different from the revision level analysis because refactoring tends to involve decentralized crosscutting changes to more than one methods making the probability of a method to include a refactoring much higher than the probability of a revision to include a refactoring.
to examine whether bug fixes resolved after refactorings indeed are related to the preceding refactorings we measured the percentage of refactoring revisions that have at least one bug fix applied to the same method level refactoring location within revisions.
as a control group we measured the percentage of nonrefactoring revisions that have at least one bug fix applied to the same change location within revisions of the change.!
!
!
.
!
?
a bc ac a db ?
b?
b e?
e ff gg hf fg eb ?
be e ci d e ?
e?
?
?
i?
b??
be?
ff gg hf fg di i a ed?
ed b c ?
?
b??
b ?
e??
e ?
ff gg hf fg ff gg hf fg figure an average time taken to fix bugs in each category table probability of fixes and refactorings at the revision level and at the method level at the revision level project revisions f r f r p f p r p r f p r f p f r p f r eclipse jdt .
.
.
.
.
.
jedit .
.
.
.
.
.
columba .
.
.
.
.
.
total .
.
.
.
.
.
at the method level project methods f r f r p f p r p r f p r f p f r p f r eclipse jdt .
.
.
.
.
.
jedit .
.
.
.
.
.
columba .
.
.
.
.
.
total .
.
.
.
.
.
in figure the left hand side is for a treatment group and the right hand side for a control group.
while .
of refactoring revisions have at least one fix revision applied to the same method locations only .
of non refactoring revisions have at least one fix revision overlap with the same change locations.
when k is the results are .
vs. .
and when k is the results are .
vs. .
.
this result implies that it is more likely for refactoring revisions to be followed by related bug fixes than non refactoring revisions to be followed by related bug fixes.
in conjunction with the manual investigation results in section .
we find that after a refactoring usually the same developer applies related bug fixes.
we speculate that it is because developers apply refactorings first to fix several hard to fix bugs on purpose or apply supplementary fixes later to correct accidental refactoring mistakes.
fixes and refactorings often appear in the same revision.
furthermore it is more likely for a refactoring revision to be followed by related bug fixes than for a non refactoring revision.
.
are there relatively fewer api level refactorings before release dates?
some practitioners believe that refactorings do not have immediate benefits and thus developers often postpone refactorings when they are constrained by time .
we compared the number of refactorings before and after major release dates to see whether feature freeze before major software releases discourages developers from introducing refactorings !
.
!
.
!
!
.
?
ab cde 3fg ?
ab cde h7256789 ?
ab cde h7256789 3fg ?
ab cde figure of refactoring revisions that have at least one fix revision in a revision window applied to the same method location to the system.
in our study we analyzed major releases in eclipse jdt and in jedit whose release dates are identified based on their websites.2we excluded columba in this analysis as it had only one release during the period.
we compute a refactoring rate and a fix rate before and after each release using the same k sliding window method in section .
.
figures and show the box plot 1st quartile median and 3rd quartile for each subject for k and .
the results show that there are more refactorings before releases than right after and there are more bug fixes before releases than after.
combined with section .
s results that refactorings and bug fixes often occur in the same revision we speculate that developers apply refactorings to implement bug fixes that must be shipped with a new software release.
and .
.
figure refactoring rate in relation to release timing !
.
.
.
.
figure fix rate in relation to release timing there are more refactorings and bug fixes prior to major version releases.
.
discussion this section discusses the limitation of our study method and the implication of our results.
refactoring reconstruction s coverage and accuracy.
as we discussed in section the refactoring revision data we used may not accurately represent the population of refactoring revisions as api level refactoring reconstruction only captures a subset of refactorings rename move and changes to api signatures at or above the level of method headers.
thus our study results may not generalizable to intra method refactorings or complex refactorings that do not involve any changes to method headers.
furthermore some may disagree with our definition of refactoring in this paper since a refactoring technically cannot overlap with a bug fix behavior correcting transformations.
nevertheless we believe that our results shed light on the relationship between api level refactorings and bug fixes during software evolution.
a recent work by prete et al.
encodes out of refactoring types in fowler s catalog as template logic rules and uses a logic query approach to infer concrete refactoring instances .
we plan to use this technique to collect refactoring revision data more accurately and comprehensively in the future.
in addition it is possible to collect refactoring revision data from different sources mining commit logs observing programmers logging refactoring tool use etc.
in our study we considered a revision is a refactoring revision if it includes at least one api level refactoring.
thus a large commit mostly feature addition with a single apilevel refactoring is still categorized as a refactoring revision according to our definition.
a further study that accounts for the size of edits as well as the number of refactorings remains as future work.
in our study due to a large number of detected refactorings we did not check with open source developers regarding whether they were performed manually or automatically using refactoring engines.
it is possible that automatically applied refactorings do not have much correlation with bug fixes.
phases and activity levels during a software life cycle.
we did not investigate other confounding factors such as activity levels task types or the phases of a software life cycle e.g.
requirements analysis design testing etc.
for example a refactoring rate increase before major releases can be interpreted by organization shifting its focus to beautifying code before releases.
figure shows the number of revisions within the same time frame during eclipse jdt s life time.
it shows that there are specific periods of very high level of activities indicating that developers may perform different types of tasks during such high activity period.
furthermore the k sliding window method in the study does not always map to the same length of absolute time as revisions during a high activity period could be equivalent to day while it could be equivalent to days during a low activity period.
a revision may not be a meaningful time unit as developers could accumulate several logical changes in a single revision.
development practices.
our study results may be strongly influenced by a few developers practices.
for example the results on refactorings and bug fixes may be symptoms of micro commits where developers commit a single logicalchange in multiple revisions just as a habit.
it is also possible that some organizations assign refactorings and bug fix tasks together to a few developers who drive a majority of refactoring and bug fix commits.
bug introducing change identification method.
when measuring the extent of latent bugs we used a bug introducing change detection method which only tracks deleted or modified code lines.
thus our method of tracking the origin of a bug is very limited especially when the bug fix involves code addition.
this issue in the study s construct validity may have affected our results on bug fix time and the extent of latent bugs.
in addition we calculated the time to fix a bug based using the difference between bug introduction and resolution time which is not always a reliable measure.
software maintainability and developer productivity.
though our study reveals interesting relationships between refactorings and bug fixes further investigation into the impact of refactoring on software maintainability and productivity is needed.
the study found that refactoring often serves the role of both facilitating bug fixes and inducing bugs.
this result calls for re thinking the true benefits of refactorings and quantitatively assessing the cost and benefit of refactoring investment.
further research on economicsbased quantitative assessment of refactorings remains as an open problem.
new software engineering tools.
empirical evidence from this study resonates with the limitations of refactoring features in modern ides reported by previous research refactorings occur as a part of other behavior enhancing or correcting transformations and manual application of coordinated systematic refactoring is often errorprone.
this result calls for new software engineering analyses such as a tool that detects refactoring mistakes and repairs them.
jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec feb apr jun aug oct dec releases of revisions week figure activity density during eclipse jdt evolution .
conclusions it is believed that refactoring improves software maintainability and a lack of refactorings incurs technical debt in the form of increased maintenance cost.
this paper presents an empirical investigation into the role of api level refactorings during software evolution.
the study found that the number of bug fixes increases after refactorings while the time taken to fix bugs decreases after refactorings.
refactorings often serve the role of both facilitating bug fixes andinducing bugs.
the study results calls for an in depth quantitative investigation into the cost benefit analysis of refactoring investment.
the results also suggest the need of new software engineering tools that detect andcorrect inconsistent program updates when developers apply refactorings.