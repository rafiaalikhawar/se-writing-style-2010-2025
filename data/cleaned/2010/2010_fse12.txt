retargeting android applications to java bytecode damien octeau department of computer science and engineering pennsylvania state university octeau cse.psu.edusomesh jha computer sciences department university of wisconsin jha cs.wisc.edupatrick mcdaniel department of computer science and engineering pennsylvania state university mcdaniel cse.psu.edu abstract the android os has emerged as the leading platform for smartphone applications.
however because android applications are compiled from java source into platform specific dalvik bytecode existing program analysis tools cannot be used to evaluate their behavior.
this paper develops and evaluates algorithms for retargeting android applications received from markets to java class files.
the resulting dare tool uses a new intermediate representation to enable fast and accurate retargeting.
dare further applies strong constraint solving to infer typing information and translates the dvm opcodes using only translation rules.
it also handles cases where the input dalvik bytecode is unverifiable.
we evaluate dare on of the top applications found in the free section of the android market and successfully retarget .
of the associated classes.
further whereas existing tools can only fully retarget about half of these applications dare can recover over of them.
in this way we open the door to users developers and markets to use the vast array of program analysis tools to ensure the correct operation of android applications.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering keywords android dalvik bytecode dalvik retargeting .
introduction android now hosts more smartphones worldwide than any other mobile platform and its market share is increasing quickly .
the corresponding markets are delivering an astonishing array of applications as of march the number of applications available from the android market alone doubled to in just eight months .
however existing markets provide little meaningful security or privacy guarantees because market providers have neither the tools nor the resources to perform detailed analysis of submitted applications .
thus users fall victim to bad applications with moderate to devastating results .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.at the time of registration android developers submit an application package containing the program bytecode resources and an xml manifest to the market.
the submitted applications are initially developed in java but compiled by the developer into dalvik bytecode .
android runs each application on the phone in its own instance of the dalvik virtual machine dvm .
the dvm has some major differences with traditional jvm.
for example the dvm is a register based architecture and has ambiguous register typing see section .
these different bytecode and program structures make it impossible to leverage existing java tools such as soot or wala for program analysis of android applications.
thus in the absence of usable analysis tools markets can do little to vet applications.
in this paper we develop and evaluate algorithms for retargetting dalvik to java bytecode.
the resulting tool is called dare dalvik retargeting .dare was motivated by our past analysis of a large corpus of applications found in the android market.
in this study we used a rudimentary retargeting tool to perform a study of security properties of android applications .
the output of that retargeting tool was input to dava a java decompiler integrated with the soot toolkit and the resulting source code analyzed using fortify sca .
we found that the ad hoc methods used for retargeting were often unreliable or failed outright.
these failures limited the visibility of the code and thus the coverage of the analysis and prevented conclusive results.
more specifically while we were often able to retarget and eventually decompile portions of the application code about half the applications had classes which were unrecoverable which made program analysis of complete applications impossible.
further the ad hoc tool was targeting decompilers and its success rate was measured in terms of decompilation success.
for dare we do not target a specific tool but instead seek to produce verifiable java bytecode which ensures that it is accepted by analysis tools.
by providing the java bytecode of android applications via dare we provide a path for users developers application market providers such as amazon to perform analysis on android applications.
the following sections detail the structure of dare .
principally we focus on solutions that address the key challenges of retargeting dalvik bytecode.
our paper makes the following contributions we introduce the tyde intermediate representation for structured semantic mapping between the vms.
all dalvik instructions are translated using only translation rules.
because sound bytecode typing is necessary for verifiability we use a strong constraint based type inference algorithm.
we introduce code transformations to fix unverifiable input bytecode.
in addition to making the code verifiable these transformations accurately mirror vm runtime behavior.
1source code and documentation for dare are available at .
we evaluate our algorithms on a sample of applications.
we successfully retarget .
of the classes.
further while previous tools were able to completely recover less than of the applications in the corpus we recover over .
retargeting is efficient taking less than minutes for the entire sample.
finally our experiments reveal that over of applications in the sample have unverifiable dalvik bytecode in at least one class.
the remainder of this paper explores the algorithms and structure of dare .
the next two sections provide background on the retargeting challenges and outline the dare retargeting process.
next we describe how dvm bytecode is translated into the tyde intermediate representation sections and and then converted to java bytecode section .
next we show the causes of unverifiability in dalvik bytecode and how to reliably retarget unverifiable bytecode section .
we then present the empirical study of dare section show related work section and conclude.
.
retargeting challenges android applications are developed in java and compiled into jvm class files.
then the various class files comprising the application are retargeted to the dvm and coalesced into a single .dex file.
thus java bytecode is an intermediate representation for dvm bytecode.
dare reverses the lossy jvm to dvm bytecode compilation to allow subsequent program analysis e.g.
.
in order to make sure that the bytecode we generate can be used by existing analysis tools we aim to generate verifiable bytecode.
since not all code that is loaded by a vm necessarily comes from a trusted compiler the verification process ensures that code can be safely executed.
the java verification process is precisely described in the jvm specification .
the dalvik verification process is mostly defined in the dalvik source code documentation we inferred part of it directly from the source code .
the jvm and dvm verifiers both check for similar static constraints i.e.
answering the question is the file well formed?
and structural constraints i.e.
relationships between instructions .
they also both implement a similar type inference algorithm which consists in symbolically executing instructions one by one to infer the influence that each instruction has on the types of the local variables java or registers dalvik .
this algorithm follows all possible execution paths and iterates as long as new type information is found for a variable or a register.
this part of the verification process ensures that the bytecode is type safe.
the differences between the jvm and dvm make the retargeting process difficult.
to aid the following discussions we give some background on the main retargeting challenges.
instruction set dalvik instructions are vastly different from java instructions.
dvm bytecode has different instructions and pseudo instructions.
dalvik instructions are two to ten bytes long and pseudo instructions have a variable length.
the dvm has substantially more instruction formats over than the jvm.
pseudo instructions are used to store extra information related to other instructions and thus are never executed .
specifically the dalvik switch instructions packed switch andsparseswitch store an offset to a pseudo instruction.
the data describing the switch statement case values and targets is stored in a pseudo instruction placed at the end of the bytecode block.
the fill array data instruction fills an array of primitive elements with values stored in a pseudo instruction.
the dvm is register based whereas the jvm is stack based.
thus the dvm uses registers to manage local variables rather than pushing them onto a stack.
for example in dalvik add int zerofloatdoublelongobjectbooleanarraysother refs32 bit64 bitbyteshortintcharfigure dalvik type lattice v1 v2 v3adds the contents of registers v2andv3and stores the result tov1.
in contrast java bytecode would first push the integer variables onto the stack with iload and iload perform the addition with iadd and store the result using istore .
it is challenging and potentially cumbersome to find a semantic mapping for all instructions.
to allow structured mapping between the vms we introduce the tyde intermediate representation ir in section .
the generation of java bytecode from tyde is shown in section .
in particular we show how to make the transition from register based bytecode to stack based bytecode.
exceptions there is a significant difference in the type inference algorithm used by the verifiers related to how they handle exceptions.
during the path sensitive type verification process the java verifier considers that any instruction in a try block may throw an exception.
in reality not all instructions in each try block are able to throw exceptions.
therefore the java verifier considers some unfeasible execution paths.
on the other hand the dalvik verifier does not consider these unfeasible paths.
occasionally an unfeasible path leads from a register assignment to a register use with an incompatible type e.g.
an int register assignment reaches a use with float type .
it is not an issue in the dvm since the spurious execution path is not considered by the verifier.
however since the java verifier follows the unfeasible path during type inference it leads to unverifiable java bytecode if nothing is done to remove it.
we explain how we deal with this issue in section .
.
bytecode type system dvm typing is very different than that of jvm bytecode.
the primary differences include primitive assignments dalvik primitive constant assignments specify only the width of the constant or bits .
thus no distinction is made between int and float or between long and double.
in contrast primitive constants in java are fully typed.
array load store instructions the dvm has common arrayspecific load and store instructions for int and float arrays aget andaput and for long and double arrays aget wide and aput wide .
here again this introduces type ambiguity.
object