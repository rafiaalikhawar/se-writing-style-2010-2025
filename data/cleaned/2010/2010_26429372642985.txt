needfeed taming change notifications by modeling code relevance rohan padhye ibm research india ropadhye in.ibm.comsenthil mani ibm research india sentmani in.ibm.comvibha singhal sinha ibm research india vibha.sinha in.ibm.com abstract most software development tools allow developers to subscribe to notifications about code checked in by their team members in order to review changes to artifacts that they are responsible for.
however past user studies have indicated that this mechanism is counter productive as developers spend a significant amount of effort sifting through such feeds looking for items that are relevant to them.
we present n eedfeed a system that models code relevance by mining a project s software repository and highlights changes that a developer may need to review.
we evaluate several techniques to model code relevance from a naive touch based approach to generic history based classifiers using temporal code metrics at file and method level granularities which are then improved by building developer specific models using text based features from commit messages.
n eedfeed reduces notification clutter by more than on average with the best strategy giving an average precision and recall of more than .
categories and subject descriptors d. .
programming environments d. .
distribution maintenance and enhancement version control keywords collaborative software development version control mining software repositories .
introduction software development is a collaborative activity.
multiple developers work on a project at the same time checking in their own code and accepting others changes.
most collaborative development environments such as rational team concert or the webbased github platform allow developers to sign up for a feed of code check in notifications in the form of emails rss feeds or pop up alerts.
these feeds help developers keep themselves aware of changes happening in the project s code base.
kim conducted a study to explore developers experiences with such permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
feeds.
she reported that developers find change notifications to be very important especially when the changes affect their own code.
also developers like to be notified about changes to artifacts which they are responsible for in order to review incoming changes for possible discrepancies.
however the study revealed that developers find the existing laundry list of notifications to be inadequate for their information needs.
the change feeds are not personalized and hence developers need to go through every item to identify changes that might be of relevance to them.
now what changes would a developer consider relevant?
fritz and murphy found through a user study that though the notion of relevance was very subjective in general developers find information about artifacts that they have worked on in the past and likely to continue updating in the future to be more relevant than information about artifacts that they have not worked on at all.
hence the likelihood of a developer modifying a source code artifact in the future is a good indicator of whether that developer would find changes involving that artifact to be relevant today.
in his phd thesis fritz attempted to answer the question which changes should i know about?
.
he modeled a developer s knowledge of various code files called the dok model based on code authorship and recency of interaction with the source code items in an ide.
in a user study involving developers he recommended the participants to review changes to bug reports associated with source code artifacts having high dok values and observed that out of the recommendations were found useful by the developers in the study.
we build upon this work in our paper by exploring additional techniques at different granularities and by empirically evaluating these techniques over a much larger data set.
we present n eedfeed a system that models code relevance to personalize a developer s change notification feed by highlighting those items that a developer may need to review by using the heuristic that developer s would find those items to be relevant which they are likely to modify in the future.
we explore various techniques to model code relevance and evaluate these models on a set of medium to large sized projects hosted on github.
we found that on average the best strategy reduces notification clutter by more than and that more than of the recommended items are relevant by our definition precision while more than of all relevant items are recommended recall .
we first implemented a naive strategy which for every changeset1 notifies all developers who have modified any of the files involved in this change set at least once in the past.
we call this thetouch based strategy which effectively subscribes users to all 1we use the terms commit andchange set interchangeably to refer to an atomic set of changes authored by a single developer which is logged in a software repository and which can be used to uniquely identify the state of the system at some point in time.
changes involving files which they have contributed to indefinitely.
as compared to a blind strategy that notifies every developer about all changes in the project the naive touch based strategy alone reduces the notification clutter by on average though the average precision is less than .
this means that many change notifications are sent to developers who never revisit any of the changed artifacts and thus could be considered irrelevant .
this is intuitive because developers often make minor edits to files which they do not regularly work with and which they may never revisit in the future.
notifications about changes to these files are not relevant to them and hence the touch based strategy is not very precise.
we then tried to improve on the touch based strategy by including temporal parameters about files modified in a change set such as the developer s code ownership relative contribution as well as recency and longevity of changes.
these parameters are extracted from the project s prior change history and hence we call this the history based strategy.
we first validate that these code metrics do in fact influence our notion of ideal relevance using statistical tests.
we then apply machine learning techniques to train three different classifiers naive bayes decision tree and rule based to predict whether or not a change set is potentially relevant for a given developer using these code metrics.
with the history based strategy precision improves to more than without severely impacting recall which is more than as well.
these models also appear to generalize across projects.
we then applied these techniques at a different granularity that of changes to individual java methods.
we analyze projects which contain a high proportion of java files.
our experiments show that we can further reduce the total volume of notifications while maintaining similar levels of precision and recall of about .
finally we augmented history based metrics with text from commit messages associated with change sets in order to model code relevance as a spam filtering problem.
this strategy required building separate models per developer and we present results for developers.
the augmented model of text history performed better than the only history based models giving an average precision of .
and average recall of .
.
to summarize this paper makes the following contributions .
a definition of ideal relevance of code changes based on source code artifact re visits.
.
an evaluation of different techniques for modeling change relevance including the touch based and history based strategies at both the file level and the method level.
.
an evaluation of developer specific text based models which leverage comments in commit messages.
the rest of this paper is organized as follows.
in section we formulate four research questions for exploring different strategies to model change relevance and also define the code metrics we use in the process.
in section we empirically evaluate our different strategies on open source projects and present our findings.
section is a discussion on the implications of our evaluation and other practical considerations in building a relevance based change notification filter.
we also discuss factors that might threaten the validity of our results in section .
section presents related work.
we then outline potential future work in section and conclude in section .
also we have publicly provided the data sets used in this paper on the web2.
theory in this section we discuss the theory behind our approach to modeling code relevance for reducing change notifications.
.
ideal relevance we design n eedfeed as a classifier which given a changeset containing a set of modified artifacts decides whether or not it may be relevant to a given developer using one or more of the strategies discussed below.
but in order to train such models and evaluate their effectiveness we need an objective measure of ideal relevance or ground truth which is the set of changes that a developer ideally would have liked to review.
developers may find others changes to be relevant for a variety of reasons but in general they would be interested in changes to artifacts which they are working on or which they use .
one approach for discovering this information is to track workitems such as tasks or bugs that a developer is working on but this is not feasible when targeting a heterogeneous landscape of projects which use different task management systems that may or may not link back to source code artifacts.
similarly we do not capture information about which source code files a developer opens or reads which can be used to develop degree of interest models as this would require an integration with every developer s ide.
the only source of data we rely on is a project s change history containing source code check ins.
hence a simple heuristic we use to determine ideal relevance is that if a developer authors some changes to an artifact then they would have found every change that occurred to this artifact by their team members since their own last modification to the artifact as relevant.
this definition excludes external changes to an artifact before a developer modifies it for the first time the intuition being that when a developer starts working on a new artifact they would read its entire contents first and only then make assumptions about its state which need to be kept up to date as their team members make changes.
ideal relevance a change set committed at time t1is considered ideally relevant to a developer difdhas modified some artifact in at times t0andt2 where t0 t1 t2.
as this definition is based on a heuristic it may result in the introduction of some bias in our subsequent experiments this is discussed in section .
.
strategies our first approach to reduce notification clutter is a naive strategy in which developers are subscribed to all changes by their team members that include modifications to artifacts that they themselves have modified at least once in the past.
we call this the touch based strategy.
our hypothesis is that this naive strategy alone will reduce the clutter significantly as compared to the default blind system that broadcasts notifications regarding all changes to every member in the team.
the first research question is thus rq1 how effective is a touch based subscription strategy in reducing change notification clutter as compared to a blind notification broadcast?
the drawback of the touch based approach is that developers are subscribed to changes involving files which they may have only made some minor edits to but which are not relevant to them.
a common scenario may be when a developer changes a method declaration in a file that they regularly work with which causes their ide to automatically refactor all invocations of that method resulting in a large change set.
the files in which only the method 666invocations are changed are not necessarily relevant to this developer in the context of their work and hence the change notification subscription is unnecessary.
another example would be if a developer who did in fact regularly work on a file changed their role and started working on a new module.
the touch based strategy will continue to notify this developer about changes to artifacts in a module which is no longer relevant to them.
hence we decided to explore other code metrics that change along with a project s evolution and which may be better indicators of change relevance.
the first metric that we considered was code ownership which is the relative amount of an artifact s current source code that is authored by a given developer.
a developer fully owns an artifact if all lines of the artifact s current code have been authored by them.
artifacts whose contents are authored by multiple developers may have multiple owners with a varying fraction of ownership.
ownership information is easily obtainable using a feature known asblame orannotate in most scm tools.
a related metric is relative contribution.
if an artifact has been modified multiple times then a developer s relative contribution is the fraction of these changes that were authored by them.
there is an interesting interplay between code ownership and contribution.
for example a minor contributor may overwrite all lines of code of a certain artifact and suddenly become a major owner.
conversely a developer may make several contributions but each time fix only a certain section of the code and hence have low ownership overall.
apart from these two code metrics we also consider the exact points in time a developer modifies a given artifact.
the principle of temporal locality suggests that developers who have recently modified a given artifact are likely to revisit it soon and hence changes to such artifacts may be relevant to them.
on the other hand those who recently changed the artifact may have just fixed a minor bug but the people who are really responsible for it may in fact be the developers who first created the artifact or those who were involved in its initial evolution even if it was a long time ago.
hence we introduce two new metrics which we call recency and longevity respectively.
hence our next research question is rq2 is there a relationship between code metrics such asownership contribution recency andlongevity and our notion of ideal relevance and if so how effective is a history based strategy in reducing the volume of change notifications?
further all these metrics can be calculated at different granularities based on what the term source code artifact refers to.
the most straightforward granularity is the file level.
the advantage is that this technique is applicable to all types of content.
but we would also like to explore if change notification clutter can reduce if code relevance is modeled at a finer granularity of changes to individual methods in source code files.
this exploration is motivated by the intuition that although multiple developers may be working on the same file they may focus their work on different sections of that file for example on different methods in a java class.
hence a change to one of the methods by one developer may not be interesting to another developer who works on a different set of methods in the same file.
the third research question is thus rq3 does the volume of change notifications reduce by using a finer granularity of changes to individual methods in a source code file?
finally we realize that the problem of reducing change notification clutter is similar to the problem of reducing spam in other information channels such as e mail.
hence we also consider the c1c2c3c4c5c6 c7c8f4f3f2f1 d1 d2 d1 d3 d1 d2 d3 d1 timecommit developer files indicates file modificationfigure an example time line of commits change sets their authors and the files changed.
option of augmenting our models with text based features using commit messages.
however unlike the history based models which may be generalizable across developers and even across projects a text based classifier needs to learn words that are relevant to a particular developer and hence a different model must be trained per developer.
our final research question is rq4 does the addition of text based features from commit messages improve the usefulness of code relevance models for reducing change notifications?
these research questions will be answered with empirical evaluations in section .
.
code metrics we now formally define the different code metrics mentioned above with the help of an example shown in figure .
the four horizontal lines represent time lines of four files named f1tof4 which are modified at various points in time through commits c1 toc8.
each commit or change set modifies the files which have a symbol in their time line.
the developer who committed the change set is mentioned in parenthesis this example contains changesets committed by three developers d1tod3.
for example c5is a change set committed by developer d1containing modifications to filesf1andf4.
note that although this example shows a simplified linear time line in general the change history of a project may be non linear due to branching and merging.
letdbe the set of developers in a team athe set of artifacts e.g.
files in the project and cthe set of commits or changesets .
we first define some primitives which are operations usually supported by version control systems such as git and hence directly obtainable changes c!2agives the set of artifacts modified in a change set.
for example changes c ff1 f2 f3g.
the corresponding git command for this primitive operation is git whatchanged commit !
author c!dgives the developer who committed a change set.
for example author c d2.
this information can be fetched in git using git log commit !
before c!2cis the set of change sets that the given commit follows.
that is it is the entire change history of the project from the start up to the given commit.
for example before c6 fc1 c2 c3 c4 c5g.
the corresponding git command for this primitive is git log commit after c!2cis the set of change sets that follow the given commit right upto the last commit which resulted in the current state of the project.
for example after c fc7 c8g.
the corresponding git command for this primitive is git log commit.. totallines c a!iis the number of source code lines that make up the given artifact at the given point in time specified by the commit .
in git a file s contents at an arbitrary point in time can be extracted using the command git show commit filename ownedlines c a d!iis the number of source code lines of an artifact at the given point in time which were authored by the given developer.
this information can be easily extracted in git on a per file level using the command git blame commit filename these primitives can be used to define some useful auxiliary relations for a given commit c artifact aand developer d pastchanges c a fc0jc02before c a2changes c0 g. for example pastchanges c f1 fc1 c3 c4 c5g.
pastchangesbyauthor c a d fc0jc02before c a2 changes c0 d author c0 g. for example pastchangesbyauthor c f1 d3 fc3g.
futurechangesbyauthor c a d fc0jc02after c a2 changes c0 d author c0 g. for example futurechangesbyauthor c f1 d1 fc8g.
mostrecent c a d is the minimum distance between cand any commit in pastchanges c a which is committed by developer d. for example mostrecent c8 f1 d1 because the most recent change to f1byd1was made at c5 which is commits ago in the change history of f1at that point.
if the given developer has not modified the given artifact at all in its history then the result is .
for example mostrecent c8 f4 d2 .
leastrecent c a d is the maximum distance between cand any commit in pastchanges c a which is committed by developer d. for example leastrecent c8 f1 d1 because the least recent change to f1byd1was made at commit c1 which is hops away in the change history of f1.
if the given developer has not modified the given artifact at all in its history then the result is .
for example leastrecent c8 f4 d2 .
definition .
relative contribution contribution c a d jpastchangesbyauthor c a d j jpastchanges c a j for example contribution c f1 d1 .
the range of relative contribution is to where implies the developer has never touched the artifact while implies that all previous modifications to the artifact were made by this developer alone.
definition .
recency recency c a d mostrecent c a d for example recency c f1 d3 .
the range of recency is to where implies that the developer has never touched the artifact while implies that the most recent modification to this artifact was committed by the this developer.
between and a high value of recency indicates that the developer was involved in one of the last few changes to the artifact.
definition .
longevity longevity c a d leastrecent c a d jpastchanges c a jfor example longevity c f1 d3 .
the range of longevity is to where implies that the developer has never touched the artifact while implies that the first ever change set involving the artifact was made by this developer.
between and a high value of longevity indicates that the developer was involved in the initial contributions to this artifact.
definition .
code ownership ownership c a d ownedlines c a d totallines c a for example if the file f1contained lines at the state just before commit c6 and of these lines were authored by developer d1 thenownership c f1 d1 .
the range of code ownership is to where implies that none of the lines of code that comprise the source code artifact at this state were authored by this developer while implies that all the lines of code were authored by this developer.
note that it is possible for a developer to have an ownership of while having non zero values for contribution recency and longevity which would occur if all the lines of code authored by the developer were overwritten by other contributors subsequently.
the four code metrics of ownership contribution recency and longevity have been defined at a per commit per developer perartifact level.
however when deciding whether or not a changeset is relevant to a given developer we need to aggregate these metrics over all artifacts that have been modified in the changeset.
to prevent missing out on important change notifications we aggregate these metrics in such a way that will cause a notification to be deemed relevant even if one of the artifacts changed were relevant to the developer.
as the numeric equivalent of the boolean or operation is the max function the aggregation is done as follows contribution c d max a2changes c contribution c a d recency c d max a2changes c recency c a d longevity c d max a2changes c longevity c a d ownership c d max a2changes c ownership c a d definition .
ideal relevance finally we define ideal relevance in formal terms relevant c d is true if and only if 9a2changes c such that both the following relations hold .pastchangesbyauthor c a d .futurechangesbyauthor c a d in the example of figure the change set c6is ideally relevant to developer d1 but not to d3.
this is because c6involves changes to three files f1 f2andf3 of which f1andf3have prior contributions by d1who also revisits them later at c8.
the developer d3has also modified both f1andf2in the past but does not revisit them.
developer d3does modify f3in the future however that would be the first experience with that file.
hence this change set does not fit our definition of ideal relevance for d3.
note that while the running example showed a simplified linear time line of a project s change history none of the above definitions assume any linear timestamp based ordering.
all operations can be performed on a non linear change history that may arise due to branching and merging which can be visualized as a directed acyclic graph dag .
668projects age source code files of of of notifications months total java commits developers blind ideal touch astrid .
atmosphere .
basex .
bigbluebutton .
carrot2 .
ceylon compiler .
cgeo .
clojure .
dotcms .
druid .
eclim .
elasticsearch .
erlide fbreaderj .
floodlight .
gephi .
h2o .
hazelcast .
hbase .
hector .
hibernate orm .
hibernate search .
jogl .
k .
libgdx .
mahout .
mondrian .
mvel .
netty .
nimbus .
nutz .
orientdb .
repose .
rhino .
rstudio .
sensei .
spout .
torquebox .
vraptor .
zxing .
table the set of open source projects analyzed.
.
data analysis in this section we describe our exploration of different techniques to model code relevance for taming change notifications.
we first describe the data set of projects that were analyzed and then describe the setup and results of different experiments that were conducted for answering our four research questions.
.
data set for our evaluation we considered medium to large size opensource projects hosted on github.
the sample set is derived from a list of top starred java projects on github which contain between and commits each.
a summary of the descriptive statistics of these projects is presented in table .
the table contains the name of the project as it appears on github theage of the project in months the total number of files in its latest state the number and fraction of files that contain java source code the total number of commits from the start of the project and the number of developers who have made at least one commit.
the projects we selected varied in different dimensions.
projects range in development history from year h2o to years mondrian .
the number of developers range from in carrot2 to developers in libgdx with an average of developers across projects.
column contains the sum of the total volume of notifications that would have been sent to the entire team using a blind strategy that notifies every team member of every change.
note that a change notification is only sent to developers other than the committer who have made at least one commit in the past.
developers who join the project late thus receive notifications 669conjunctive rule j48 naive bayes touch .
.
.
.
.
precisionrecall f .score precisionrecall f .score precisionrecall f .score precisionrecall f .scorefigure precision recall and f score of change set relevance prediction at file level.
only from that point on.
column contains the ideal volume of notifications that should have been sent by applying definition for classifying a notification as ideally relevant or not to the receiver.
the values in column will be addressed while answering our first research question.
when comparing different techniques for reducing change notification clutter we use standard measures such as precision recall and f score which are defined as follows letnibe the set of all notifications that would have ideally been relevant by definition in a project over all change sets and all developers .
let nsbe the notifications that were actually found relevant by our model.
then precision jns nij jnsj recall jns nij jnij f score precision recall precision recall .
a naive approach rq1 how effective is a touch based subscription strategy in reducing change notification clutter as compared to a blind notification broadcast?
the touch based strategy is first evaluated at a file level of subscriptions.
for each change set committed to the repository we identify the files modified as part of that change set.
we then identify the set of developers who in the past prior to this commit had modified any of these files.
a notification would be sent to all these developers except the developer who committed this changeset .
the sum of all such notifications calculated for every commit containing at least one changed file is reported in column of table .
the numbers in parenthesis is the fraction of the upper bound blind broadcast of notifications.
clearly the touch strategy alone results in a significant reduction of notification clutter with the reductions ranging from inclojure to in eclim.
however many of these notifications may still be irrelevant to the receivers.
the right most column in figure depicts the distribution of precision recall and f score for the touch strategy.
now every notification that is ideally relevant willbe sent out by the touch strategy.
this is because definition dictates that for a change to be ideally relevant to a developer a necessary condition is that pastchangesbyauthor is non empty for at least one of the changed artifacts and this iscoefficients estimate z score pr jzj ownership .
.
contribution .
.
recency .
.
longevity .
.
odds ratio ownership contribution recency longevity .
.
.
.
table results of binary logistic regression on code metrics in predicting ideal relevance.
exactly the sufficient condition for sending out notifications in the touch strategy.
hence the recall for the touch strategy will always be .
however the average precision is about indicating that even though the touch strategy reduced the overall notification clutter it still sends out change notifications to developers who never revisit any of the changed artifacts in the future.
hence a more intelligent system is needed in order to determine the right set of developers who are likely to find a change set relevant to them.
this brings us to the next research question.
.
a machine learning approach rq2 is there a relationship between code metrics such asownership contribution recency andlongevity and our notion of ideal relevance and if so how effective is a history based strategy in reducing the volume of change notifications?
to answer this research question we calculate the metrics ownership contribution recency longevity andideal relevance using definitions for each change set for each developer who would have received a touch based notification.
our aim is to be able to use the code metrics to predict whether or not a change set is ideally relevant.
we first determine the statistical significance of each of these metrics in predicting ideal relevance.
we then train three different classifiers and evaluate their effectiveness in predicting whether a developer would find a change set relevant or not.
.
.
statistical significance of code metrics in predicting ideal relevance for the projects we had a total of data points for our analysis.
the four code metrics are predictor variables while ideal relevance is the outcome variable with binary values indicating that the change set is not relevant for the developer and indicating it is relevant.
since the outcome variable is binary categorical and our predictor variables are continuous we applied binary logistic regression to evaluate the influence of the predictor variables on the outcome.
table presents the results of binary logistic regression listing the regression coefficients estimates z score and p value.
we find three predictors ownership contribution andrecency significantly influencing the outcome variable of ideal relevance with p values while longevity influences the outcome with a relatively lesser significance.
the odds ratio represents the magnitude of influence.
for example for every unit change in recency the odds of the notification being relevant increases by .
the odds ratio suggests recency andcontribution as major predictors of ideal relevance followed by ownership andlongevity.
670conjunctive rule j48 naive bayes .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
precisionrecallfigure precision and recall for three classifiers using a filelevel history based strategy.
we also performed the wald test to determine how well each predictor is significant.
this test identifies how well the model fits by including a predictor variable as opposed to a model which excludes that predictor.
we repeated the test for each predictor and for all the predictors the wald test resulted in a significant chisquare with a p value of less than .
.
.
change relevance classification problem we now evaluate different classification techniques for predicting whether a change set would be relevant to a given developer or not based on temporal code metrics of the modified artifacts.
collectively this represents the history based strategy for reducing notification clutter.
effectiveness of classification techniques we used three classification techniques available in weka for our study naive bayes a probabilistic classifier conjunctive rule a rule based classifier and j48 which is an implementation of the c4.
decision tree algorithm .
we applied the standard fold cross validation technique and figure shows the scatter plot of precision and recall for different classification techniques.
each point in the plot represents the average precision and recall value aggregated over the fold cross validation for each project.
intuitively classification techniques that place majority of the data points in the top right quadrant where precision and recall are greater than .
can be considered as performing well.
correspondingly j48performs the best by predicting change set relevance with precision and recall greater than .
for projects.
conjunctive rule performs extremely well in few cases where it predicts with a recall of and precision greater than .
but gives very low precision and recall for some other projects and is hence not consistent.
the performance of naive bayes is between the other two techniques having at least either of precision or recall greater than .
across all projects.
improvement over the touch strategy when compared to the touch strategy the two history based classifiers j48and naive bayes performed better in terms of precision and f score as shown in the first three columns of figure .
the median precision values observed for j48andnaive bayes were greater than which is a factor of two more than the precision observed for touch .
the entire range of precision values was higher than the corresponding precision values for touch indicating that j48 andnaive bayes outperform touch with respect to precision.
although history based classifiers report lower recall values when compared to the touch based strategy where recall is by definition the j48technique predicts with a recall greater than in almost all cases.
the conjunctive rule classifier is not consistent and performs as bad as touch in some projects.
as regards to the total volume of notifications while the touch stratf score precision recall .
.
.
.
.00conjunctive rule j48 naive bayes touchfigure performance of generalized project independent file level history based models.
projects of notifications blind ideal touch atmosphere .
druid .
floodlight .
hazelcast .
hector .
hibernate orm .
mahout .
mvel .
netty .
vraptor .
table subset of java projects analysed for rq3.
egy resulted in a reduction in clutter compared to the blind broadcast strategy the history strategy reduced clutter by more than using either of j48ornaive bayes.
generalization of the classification models we further evaluated if a single history based model trained using aggregate data from across projects can predict relevance for change sets in other projects individually.
we present the results in comparison with the touch strategy in figure .
the vertical bars represent the corresponding precision recall and f score for each classification technique.
it is evident that j48outperforms the touch strategy as well as other history based classification techniques by predicting relevance correctly with approximately precision recall and f score on average.
.
granularity of changes rq3 does the volume of change notifications reduce by using a finer granularity of changes to individual methods in a source code file?
we now explore the effectiveness of the above techniques at the method level and compare it to the results at the file level.
data set and naive touch strategy we chose projects from our original data set projects which had a high more than proportion of java files.
for each change set we identified the set of changed methods by comparing the differences in the abstract syntax trees of java source files before and after the change.
this was implemented using the eclipse java development toolkit.
the summary statistics for these projects is shown in table .
a comparison of table and corresponding rows of table make it evident that there is a significant reduction in the notification volume for blind as well as touch at the method level.
the blind volume is lower than that at the file level because not all changes 671conjunctive rule j48 naive bayes touch .
.
.
.
.
precisionrecall f .score precisionrecall f .score precisionrecall f .score precisionrecall f .scorefigure precision recall and f score of change set relevance prediction at method level.
f score precision recall .
.
.
.
.00conjunctive rule j48 naive bayes touch figure performance of generalized project independent method level history based models.
include modifications to java methods.
but the reduction in the notifications sent out by the touch based strategy is much more.
the difference between method level and file level effectiveness of touch can be realized by comparing the numbers in parenthesis which is the percentage of the blind notifications which were actually sent out.
the fraction is lesser in the method level because developers are only subscribed to changes to individual methods which they have touched and not just all changes to the file in which they have modified some method.
improvements with the history strategy we also calculated code metrics such as ownership contribution recency and longevity for method level changes.
note that while calculating these metrics we only considered historical changes to a given method and hence all these values will be different for each change set as compared to the file level.
we then applied the three classification techniques for the history based approach viz.
naive bayes conjunctive rule andj48.
figure is a box plot of the precision recall and f score across different classification techniques for the projects.
among the classification techniques both j48and naive bayes performed equally well at the method level granularity.j48performed well in terms of precision while naive bayes did well from a recall perspective.
in contrast conjunctive rule spanned all ranges of precision and recall proving that it was not consistent at method level granularity as well.
generalization of the classification models for the methodlevel granularity we also trained generalized project independent models using the three classifiers to see if the code metrics can predict relevancy across projects.
figure shows the results of these models.
the history based techniques seem to perform well when using a generalized method level model as well.
onl y history text history .
.
.
.
.
.
.
.
.
.
.
.
precisionrecallfigure precision and recall for developer specific models for developers.
.
text based spam filtering rq4 does the addition of text based features from commit messages improve the usefulness of code relevance models for reducing change notifications?
our final exploration was to consider the problem of reducing change notifications as a spam filtering problem and build developerspecific models of code relevance that use in addition to history based metrics text based features from commit messages that may indicate items of interest to developers.
data set and methodology since the text based strategy learns words of relevance specific to a developer this approach requires building one model per developer.
for this purpose we require enough data about a developer s prior change history with enough examples of ideally relevant and non relevant changes.
hence we curtailed our data set of the open source projects and built models for only those developers who had at least relevant and non relevant changes in their history.
only of the developers in our data set met this criteria.
to build a text based code relevance model we extracted textual comments that are associated with each change set also known as commit messages .
these messages typically include terms that refer to the module in which the change occurs or contains words describing tasks or bugs that are addressed in the change.
the commit messages were split into a bag of words using weka s stringtovector filter which also removes stop words and stems the resulting words to their root.
the resulting bag of words formed the set of input variables for the text based code relevance models.
in order to objectively understand the effect of incorporating text in our modeling of code relevance we trained two models per developer one using only history based metrics and one using both history text features.
note that the models using only history here are different from the per project or project independent models presented in section .
.
when training developer specific models we only calculate history metrics for that developer for each change set in the project that the developer is contributing to.
the evaluation of these models was done using the same ten fold cross validation technique as used previously.
results figure shows the results of our developer specific models as scatter plots of precision and recall.
as it is evident from the figure the augmented models that incorporate text perform slightly better average precision and recall of .
and .
respectively than the purely history based models average precision and recall of .
and .
respectively indicating that text from commit messages can be useful to model code relevance.
.
discussion we now discuss the implications of the above results for developing n eedfeed a relevance based change notification tool.
best classifier there is no clear winner between the various classification techniques though j48andnaive bayes seem to provide more consistent results but it is clear from the evaluation that thehistory based strategy is in general far better than the touch strategy in reducing notification clutter.
note that from an application point of view the moderately low values of recall for the history based strategies are not completely detrimental because a developer can still view change history of any artifact before modifying it.
however this is time consuming and may result in a loss of productivity which is equivalent to that of sifting through a large list of irrelevant notifications.
hence n eedfeed would need to consider a trade off between a large amount of notification clutter containing surely irrelevant changes and the off chance of missing out on potentially relevant changes.
file level vs. method level although it is clear that the volume of change notification clutter reduces significantly when using a finer granularity of individual methods not all change sets will contain changes to source code.
even projects that are exclusively written in one programming language contain certain configuration files or other documents that are collaboratively developed and for which a fine granularity may not be discernible.
generalizability from our study over the sample set of projects we found that a generalized model works as well as projectspecific models.
this is an interesting property which will allow new projects to leverage n eedfeedwithout requiring a long change history to bootstrap the relevance model.
text based filtering while the combined text history approach seems to provide better results on average than using only history metrics there is a constraint that developer specific models can only be built when there is significant amount of change history for the developer which can be used for training.
prescribed strategy overall we feel the best strategy is a hybrid one which can leverage data as it becomes available.
for new projects the project independent history based model which is generic and learned from other projects could suffice but as the project grows a project specific model can be trained using its own change history.
similarly as individual developers increase their participation developer specific models can be built for them incorporating text from commit messages.
in each case if the files modified in a change set are of a type whose source can be parsed we can apply method level history tracking.
for other types of content the model can fall back on file level granularity.
.
threats to v alidity in this section we list the most important threats and limitations of our empirical study.
construct validity we faced some minor issues while extracting the required data from git repositories for our study.
for example developers who used different names or email addresses across their commits would have been considered as distinct people and hence distinct relevance values would have been calculated for each of them.
also we did not track renaming of artifacts and hence such operations appear as a deletion of one artifact followed by the creation of another.
these issues would affect our precision and recall but we expect such occurrences to be the exception rather than the norm.
internal validity our definition of ideal relevance suffers from a horizon effect that would likely introduce biases in the preicision and recall values reported in our experiments.
this is because forcommits towards the end of the time line there is no opportunity to identify future code revisits by developers in order to classify them as ideally relevant or not.
consider a notification about a changeset that is sent to a developer dat time t1.
if we were to train or evaluate our model using historical data at some time t2 where t2 t1 and if dhas not modified any artifact in between t1and t2 then we will mark that change set as ideally not relevant to d. however it may be possible that dis in fact responsible for the artifacts changed in and that after a review of that change set dmakes some modifications in the future at some point t3 where t3 t2 .
thus our training may suffer and our evaluation may report spurious false positives and true negatives.
note that merely restricting our training and evaluation to a subset of commit history before some mid way point in time tmwill not resolve this issue as this period may still include horizons for those artifacts that were last modified only before tm.
a possible solution may involve carefully ignoring changes to a select subset of artifacts in every change set that are close to their own horizon.
we leave the detailed investigation of the horizon effect as future work.
external validity our study was conducted on a set of opensource projects hosted on github.
although the model seems to generalize over this set of projects it may or may not perform as well on different kinds of projects such as small private projects in a tightly controlled commercial setting having a team size of just a handful of developers.
such projects can hence use the touch based strategy during their initial stages and migrate to a projectspecific model as the project evolves.
.
related work there is a large amount of existing literature that has studied the problems that arise due to the overheads of collaboration in software development as the team size increases which impedes development and increases defects .
the impact of code metrics such as ownership and contribution have also been shown to be useful in studies of software quality .
a number of prior research work has tackled issues similar to the ones we address in this paper specifically that of information clutter in a developer s workspace code change notifications in particular and other methods of keeping developers updated about their teammate s activities.
we address each of these categories of related work and clarify how our work is different.
information clutter and notification spam mukherjee and garg conducted a study to measure information clutter arising from notifications about changes to work items in rational team concert.
their tool twiny uses machine learning techniques on historical data about work items mined from the software repository to predict whether a notification will prompt a response from its recipient.
similarly ibrahim et al.
developed personalized models to automatically identify discussion threads that a developer would contribute to based on their previous contribution behavior.
they built a composite model leveraging both naive bayesian and decision tree classifiers.
our work is partially inspired by these approaches but is different in scope and methodology.
we focus solely on clutter arising from source code check in notifications and hence leverage different kinds of temporal metrics as well as different granularities of changes.
relevancy in source code changes holmes and walker address the problem of modeling relevancy in code changes in their tool yoohoo.
however this tool is mainly targeted at external changes occurring in components or libraries on which a developer s own work depends on.
due to this different scope their tool looks for events such as a change in the api of imported libraries or the creation of a new repository branch possibly indicating a 673new release or change in javadoc possibly a change in expected behavior and filters out minor changes to the implementation of such external components.
our study is restricted to the problem of determining relevance of changes to artifacts in a given project which are worked on by multiple developers and hence we model code relevance differently.
change relevance has also been mentioned as a use case in fritz s phd thesis in which he presented a degree of knowledge dok model for capturing a developer s familiarity with source code artifacts.
our work differs from this thesis in two major ways.
firstly the dok model was trained with seven developers who answered a questionnaire regarding their knowledge of source code artifacts and the application of this model for estimating relevance of changes was evaluated by recommending a total of six bug reports to three developers.
our training and evaluation are completely automated and use a much larger data set of 40projects developers and data points.
secondly the variables used to model code relevance are different.
the dok model uses two components a degree of authorship doa which is based on whether a developer was the first author of a file and on the absolute number of changes delivered accepted by them and a degree of interest which is calculated by monitoring a developer s activity within an ide.
our history metrics are similar to the doa but are all continuous and normalized and we do not measure ide activity at all and hence have no though it should be easy to incorporate this variable if the data was available.
in any case fritz reported that the was not significant during the training of the dok model.
conflict detection from concurrent modifications a number of tools have been developed to prevent conflicts arising from multiple developers modifying source code artifacts simultaneously.
these tools include collabvs crystal palantir and continuous merging .
however such tools prevent conflicts that can possibly arise in the future by scanning yet uncommitted changes that are being authored in parallel by two or more developers.
also these tools are usually restricted to determining conflicts that can be automatically detected such as those that break builds or tests.
the scope of our work is different as code check in notifications potentially prevent inconsistencies that are authored by a single developer but which can be detected by another developer who manually reviews the change.
also check in notifications are fired only after the changes are fully committed to the shared repository.
our work can thus be used in conjunction with the aforementioned tools since the addressed problems are distinct.
.
future work needfeed is currently implemented as a notification filter at two granularities file level and java method level.
as discussed previously although a model based on fine granularity is better at reducing notification spam it has to fall back to the file level for content types which it cannot parse.
n eedfeed thus needs to be extended with more front ends to be effective for projects written in other languages such as c or javascript.
currently n eedfeed is only capable of classifying changesets as relevant or irrelevant to a developer in a binary fashion.
our final aim is to provide a personalized change notification feed which would contain for each item a description of why exactly the change is relevant to a given developer.
changes that are not deemed relevant may be presented in a separate unobtrusive list which can be examined on demand.
a mock up of such a personalized feed is shown in figure .
our tool can be integrated with other filters such as yoohoo which consider different types of change relevancy thus providing an integrated notification stream.
figure a mock up of a personalized change notification stream powered by n eedfeed.
we also envision other applications that can leverage the code relevance models of n eedfeed.
for example the workspace of a developer in their ide often contains a large number of files usually everything contained by the project the developer is working on.
simply locating relevant files to open can sometimes be a nontrivial task.
an alternate view of the workspace which first shows relevant artifacts and optionally allows navigation of the remaining files may be helpful in improving a developer s productivity.
also as our models capture the likelihood that a developer may modify an artifact in the future another application that is conceivable is forecasting where project managers can make estimates about the likely workloads of developers in the near future based on their recent change history.
.
conclusion software developers have consistently reported that the state ofthe art in collaborative development tools are inadequate in meeting their information needs concerning changes committed by other developers due to a lack of relevance in the notification stream.
in this paper we have described our exploration of various techniques to model code relevance towards providing a personalized change feed for every developer.
our experiments on historical data of open source projects indicate that models that incorporate data mined from a project s software repository are useful in reducing notification clutter by over on average with high levels of precision and recall over each on average .
we believe that the inclusion of personalized change notifications in collaborative development tools can be very effective in improving the productivity of software developers and hence has the potential to positively impact the success of any software project as a whole.
.