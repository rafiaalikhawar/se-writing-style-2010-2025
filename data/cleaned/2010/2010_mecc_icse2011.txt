mecc memory comparison based clone detector heejung kimy yungbum jungy sunghun kimx kwangkeun yiy yseoul national university seoul korea fhjkim dreameye kwang g ropas.snu.ac.kr xthe hong kong university of science and technology hong kong hunkim cse.ust.hk abstract in this paper we propose a new semantic clone detection technique by comparing programs abstract memory states which are computed by a semantic based static analyzer.
our experimental study using three large scale open source projects shows that our technique can detect semantic clones that existing syntactic or semantic based clone detectors miss.
our technique can help developers identify inconsistent clone changes nd refactoring candidates and understand software evolution related to semantic clones.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering f. .
semantics of programming languages program analysis general terms languages algorithms experimentation keywords clone detection abstract interpretation static analysis software maintenance .
introduction detecting code clones is useful for software development and maintenance tasks including identifying refactoring candidates nding potential bugs and understanding software evolution .
this work was supported by the engineering research center of excellence program of korea ministry of education science and technology mest national research foundation of korea nrf grant by the brain korea project school of electrical engineering and computer science seoul national university by fasoo.com and by samsung electronics.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.most clone detectors are based on textual similarity.
for example ccfinder extracts and compares textual tokens from source code to determine code clones.
deckard compares characteristic vectors extracted from abstract syntax trees asts .
although these detectors are good at detecting syntactic clones they are not e ective to detect semantic clones that are functionally similar but syntactically di erent.
a few existing approaches to detect semantic clones e.g.
those based on program dependence graphs pdgs or by observing program executions via random testing have limitations.
pdgs can be a ected by syntactic changes such as replacing statements with a semantically equivalent procedure call.
hence the pdg based clone detectors miss some semantic clones.
the clone detectability of random testing based approaches may depend on the limited test coverage covering only up to of software .
to detect semantic clones e ectively we propose a new clone detection technique we rst use a path sensitive semantic based static analyzer to estimate the memory states at each procedure s exit point then we compare the memory states to determine clones.
since the abstract memory states have a collection of the memory e ects though approximated along the execution paths within procedures our technique can e ectively detect semantic clones and our clone detection ability is independent of syntactic similarity of clone candidates.
we implemented our technique as a clone detection tool memory comparison based clone detector mecc by extending a semantic based static analyzer .
the extension is to support path sensitivity and record abstract memory states.
our experiments with three large scale open source projects python apache and postgresql section show that mecc can identify semantic clones that other existing methods miss.
the semantic clones identi ed by mecc can be used for software development and maintenance tasks such as identifying refactoring candidates detecting inconsistencies for locating potential bugs and detecting software plagiarism as discussed in section .
.
this paper makes the following contributions abstract memory based clone detection technique we show that using abstract memory states that are computed by semantic based static analysis is e ective to detect semantic clones.
semantic clone detector mecc we implemented the proposed technique as a tool mecc .
we show the e ectiveness of the proposed technique by experimentally evaluating mecc.
clone benchmark for our experimental study we manually inspect and classify code clones of three open source projects.
we make these data publicly available and it can serve as a benchmark set for other clone related research .
the rest of this paper is organized as follows we rst revisit and re ne code clone de nitions in section and then propose our approach in section .
section evaluates our approach and section discusses our limitations and applications of our technique.
section surveys related work and section concludes our paper.
.
clone types basically clones are code pairs or groups that have the same or similar functionality .
some code clones are syntactically similar but some are di erent.
based on syntactic similarity roy et al.
classify clones into four types type exact clones identical code fragments except for variations in whitespace layout and comments.
type renamed clones syntactically identical fragments except for variations in identi ers literals and variable types in addition to type s variations.
type gapped clones copied fragments with further modi cations such as changed added or deleted statements in addition to type s variations.
type semantic clones code fragments that perform similar functionality but are implemented by different syntactic variants.
these de nitions are widely used in the literature and we also use them in this paper.
the de nitions of type and type clones are straightforward.
mostly they are copies from other code that remain unchanged type or have a small variance type .
these clones can be easily detected by comparing syntactic features such as tokens in source code .
on the other hand type semantic clones are syntactically di erent.
since there is no clear consensus on type clones some researchers de ne subtypes of type clones such as statement reordering control replacement and unrelated statement insertion .
similarly we de ne subtypes of type clones as follows control replacement with semantically equivalent control structures refer to figure .
statement reordering without modifying the semantics refer to figure .
statement insertion without changing computation refer to figure .
statement modi cation with preserving memory behavior refer to figure .
like type clones there is no consensus on type clones.
stefan bellon et al.
de ne type clones as all clones that are neither type nor type .
similarly in this paper wede ne type clones as all clones that are not type type2 and type clones.
this paper proposes an abstract memory comparison based clone detector which can identify all four clones discussed in this section.
.
clone detection based on memory comparison our goal is to detect clones by comparing the functionality of code fragments regardless of their syntactic similarity.
a naive way to achieve this goal is to perform exhaustive testing on a given set of clone candidates programs .
we may determine semantic similarities of programs by generating all possible inputs for programs observing all possible executions using the inputs and comparing their execution results.
however such exhaustive testing is often infeasible since there might be in nitive many numbers of inputs and or execution paths.
for this reason we use semantic based static analysis to determine semantic similarities of given programs because static analysis soundly and nitely estimates the dynamic semantics of programs.
in our case we use a path sensitive semantic based static analyzer that symbolically estimates the memory e ects of procedures.
our overall approach is shown in figure .
we compute abstract memory states from given programs via static analysis.
then we compare the abstract memory states to determine code clones.
clone candidatememorycomparisonabstract memory statesemantic basedstatic analyzer clone candidateabstract memory state semantic basedstatic analyzerwhile y n bar if x bar else goto l figure our clone detection approach abstract memory states for each clone candidate are computed by a path sensitive semantic based static analyzer.
these abstract memory states are compared for detecting code clones we build a semantic based static analyzer on top of sparrow which can summarize each procedure after analyzing the procedure based on the abstract interpretation framework and these procedural summaries have been carefully tuned to capture all memory related behaviors in real world c programs .
however sparrow does not support path sensitive analysis.
we extend sparrow to be path sensitive like by adding guards and guarded values to the abstract domain.
the path sensitivity is crucial for semantic code clone detection.
a path insensitive analyzer loses the relation between condition expressions and corresponding statements.
for example a path insensitive analyzer considers the following two di erent if else codes as the same since it does not know which statements are belonging to which condition expressions.
this insensitivity leads to detecting false posi m 2mem addrfin !gv gv gv 2guard value g2guard value rel value guard guard guard guard v2value n addr uop value value bop value x 2addr var symbol allocsite addr field var global param local figure abstract domains the abstract semantics of procedure is estimated as abstract memory state over domain mem .
tive clones.
if a aelseb if a belsea .
collecting abstract memory states we compute abstract memory states at every program point of a given procedure by the conventional xpoint iteration over abstract semantics a la abstract interpretation .
memory state representation our abstract domains for memory states are presented in figure .
our analysis is ow and path sensitive it summarizes possible abstract memory states for each program point and all execution paths to the point.
an abstract memory state min figure is a nite mapping from abstract symbolic addresses to guarded values.
a guarded value gvin figure is a set of pairs of a guard and a symbolic value where the guard is the accumulated symbolic condition that leads to the accompanying value.
the set of all variables var consists of three disjoint sets all global variables global all parameters param and all local variables local except procedure parameters.
this partitioning enables us to de ne three equivalence classes for variables when de ning equivalent addresses in section .
.
symbols symbol are used to indicate symbolic values or symbolic addresses in global input memories of the current procedure.
allocated addresses allocsite denote all addresses allocated including arrays at each allocation site a static call program point for allocations .
field addresses addr field represent eld variables of structures.
a symbolic value can be a number n an address addr a binary value value bop value or a unary value uop value .bopanduopdenote a set of binary and unary operation symbols respectively.
a guard guard can be generated from the relations between values value rel value where reldenotes the set of comparison operators e.g.
.
some guards can also be connected by logical operators conjunction and disjunction .
the next step is estimating the semantics of the program as elements in this domain.
abstract semantics our analysis starts from the entry point of a procedure without knowing the input memory states.
the unknown input memory states are constructed by observing which locations and values are accessed by theprocedure .
abstract memory states are updated by evaluating each statement in the procedure and the updates are decided by the prede ned abstract semantics of each statement.
for example one abstract semantics of the assignment statement is de ned as follows m e1 f g x g m e2 f gi vi gi m e1 e2 m x7!f g gi vi gi m e gvdenotes that expression eevaluates to a guarded valuegvgiven the memory state m. this abstract semantics illustrates the destructive update case in which the previous guarded values of the updated address is overwritten.
the rule indicates the destructive update can happen only when the address value of e1is a single variable note that the singleton set for the value in m e1 f g x g .
as a result the value of variable xis updated by the value of e2in memorym.
the guards for the new values are the conjunctions of guard gof the address and guards giof the values.
1int foo list a int b int res if a len res bar b return res 8int bar int x int m if x m malloc x return m the abstract memory state at line afhtrue ig lenfhtrue ig bf true g fh i resh 5 0i g the procedural summary of bar x 0return alloc x 0return figure procedure barwith its procedural summary and procedure foowith its abstract memory state at the exit point line .
consider the procedure fooin figure .
the abstract memory state at the exit point line is presented on the right side.
at line variable reshas guarded value fhtrue 0igwhich means variable resalways has the value zero at the program point.
parameter ais accessed in the condition expression at line however the value of parameter ais unknown.
hence a new symbol is created to represent the value of parameter a. for the eld value of a len which is also unknown new symbol is created.
from the condition expression guards and are kept for true and false branches respectively.
inter procedural analysis the procedural summary information enables the analyzer to capture the semantics of procedure calls without analyzing the procedures again.
at line procedure baris called.
according to the procedural summary the procedure returns an allocated address when the value of parameter xis greater than otherwise it returns .
the procedural summary keeps conditions as extended from for memory behaviors of procedure.
this procedural summary is instantiated with the abstract memory state at the call site line .
at line the value of formal parameter xin procedure baris instantiated with the value of actual parameter b .
with this instantiation of the procedural summary we obtain the result memorystate of the procedure call.
now variable respoints to the result guarded value fh i h 0ig.
here guard comes from the condition on true branch at line and guards and come from the procedural summary of bar.
at line the abstract memory states on both true and false branches are joined.
variable respoints to a guarded value fh 0igin the memory state from the false branch.
the joined memory state at the return point of foo line is shown as the table in figure .
the procedural summary of procedure foois automatically generated from this abstract memory state .
handling loops the termination of the xpoint iterations is guaranteed by a widening operator .
without the widening operator xpoint iterations may diverge because the heights of the number domain nand the symbolic value domainvalue bop value are in nite.
after ve iterations delayed widening changing values go into the special value indicating an unknown value .
when we compare memory states the unknown values are considered as not equivalent.
hence our clone detection may miss some clones.
example for comparison the abstract memory states at the exit point of procedures are compared for code clone detection.
as an example procedure foo2 in figure is a semantic clone of procedure fooin figure .
if we disregard the names of variables symbols eld variables and variable types then two memories are equivalent.
note that two guards 5 and 5 are equivalent.
this equivalence is attained by function simplify presented in section .
.
1int foo2 list2 x int y int ret if x val y ret malloc y return ret the abstract memory state at line xfhtrue ig valfhtrue ig yf true g fh i reth 5 0i g figure procedure foo2 with its abstract memory state at the exit point line .
.
comparing abstract memory states given estimated abstract memory states we need to quantify their similarities.
algorithm presents the quanti cation steps.
first we calculate the similarities between guarded value pairs of all possible combinations on the given memoriesm1andm2 line to .
we compare addresses using the equivalence relationl on addresses as de ned below .
if addresses are equivalent then we calculate the similarity of two guarded values by function simgv gv1 gv2 line .
if addresses are not equivalent the similarity is zero line .
for all combinations the similarities of pairs are recorded in map s line .
then function findbestmatching s nds a subset of sthat exclusively spans the two memories such that the total similarities of matched pairs becomes the biggest line .
finally the algorithm returns the ratio of similarity to the total size of memories.
if both memories are empty the denominator becomes zero then the simi algorithm simm m1 m2 input abstract memory states m1andm2 output similarity value of m1andm2 1s fg foreach addressa12dom m1 do foreach addressa22dom m2 do if a1l a2then v simgv m1 a1 m a2 else v 6s sf a1 a2 !vg end end 9best findbestmatching s ifjdom m1 j jdom m2 j 0then return return2 best jdom m1 j jdom m2 j larity is zero line to .
equivalent addresses two addresses are equivalent with the relationl if one of the following conditions is satis ed xl y ifx y2global x y2param x y2local l 0if 02allocsite a fl a0 f0ifal a0 l iforigin l origin when two variables are compared the names and types of the variables are ignored var .
we only check if both variables are parameters global variables or non parameter local variables.
all dynamically allocated addresses are considered as equivalent regardless of their allocation sites allocsite .
for eld addresses addr field the names of eld variables are ignored and only structural equivalences are considered.
for example x vall x lenholds even if the address uses di erent eld names.
however x next lenl x lenis not true because the former one has an additional eld dereference.
all symbolic addresses are equivalent only when their origins are the same symbol .
the origin address origin is the address pointing to symbolic address .
as an example the following origin a andorigin lenhold in figure .
similarity between guarded values a guarded value gvis a set of pairs which consist of a guard and a value.
functionsimgv gv1 gv2 compares all guards and values ingv1with those ingv2 and then counts the number of matched pairs n. finally the similarity of two guarded values is computed as follows simgv gv1 gv2 n jgv 1j jgv 2j n maximum ofjmjs.t.m sand 8h g1 v1 g2 v2 i2m g1 v1 and g2 v2 appear only once s g1 v1 2gv g2 v2 2gv 2fh g1 v1 g2 v2 ijg1g g2 v1v v2g the similarity is the ratio of the number of matched pairs tothe total size of two guarded values.
we seek for the maximum number of matched pairs trying to match all possible combinationsgv1 gv .
equivalent valuesv and equivalent guardsg are de ned as the following.
equivalent values relationv establishes the equivalence on values n1v n2 ifn1 n2 v1 v2v v3 0v4ifv1v v3 v2v v4 v1v 0v2 ifv1v v2 v 0if l equivalence of numbers is determined by numerical equivalence n .
binary values are equivalent when both the pair of values and the operators are equivalent value bop value .
from our de nition ofv we may miss semantically equivalent values due to their syntactic expression di erences.
for example x and x should be regarded as equivalent but it is regarded as not equivalent because of xv and 0v x. to address this problem we canonicalize the symbolic values.
the canonicalization gives certain partial orders on both operators and values then sorts the binary values by the orders.
hence all semantically equivalent binary values have their unique representations.
equivalent guards relationg determines equivalent guards v1 v2g v3 0v4ifv1v v3 v2v v4 g1g g2 ifunify simplify g1 simplify g2 trueg true falseg false two relation guards v1 v2andv3 0v4in domain value rel value are equivalent when their value pairs are the same and their relations e.g.
are the same.
however one formula can be presented as several di erent forms.
for example formulas x x 10 x andx look di erent but are actually equivalent because x implies x .
to remedy this we use a function simplify that simpli es guards so that they do not contain any redundant sub formulas using a decision procedure .
furthermore we want to assume x andz are equivalent if xl z holds.
this process is done by uni cation algorithm unify which is widely used in type systems .
the algorithm returns true if there exists a substitution which makes two di erent structures the same while preserving relationsl andv .
best matching functionfindbestmatching s at line in algorithm nds the best matching i.e.
the matching that maximizes the sum of similarities and then returns the maximum sum of similarities.
consider this similarity table as an example.
xxxxxxxm2m1 a1 gv1 a2 gv2 a3 gv3 a4 gv4 a1 gv1 .
a2 gv2 .
a3 gv3 .
4the boxed ones represent the best matching since it maximizes the sum of similarities.
suppose our matching function nds this best matching.
the value of bestat line in algorithm is the sum of similarities of all matched pairs.
hence the similarity of these two memories is returned at line in algorithm .
we develop a lightweight greedy algorithm to heuristically try nding the best matching which runs in o n2 where nis the number of elements.
after calculating the similarities of all pairs the pair which has the maximum similarity is chosen as a matched one.
then the algorithm continues to choose another maximum pair among the remaining pairs until all addresses in either m1orm2are matched.
the order of choices for the above table is annotated over the boxes.
the algorithm is not guaranteed to nd the best matching but has the advantage of the running time.
there is a combinatorial optimization algorithm called the hungarian method which is guaranteed to nd the best matching but runs in o n3 much slower than ours.
in our experiments we found that our algorithm yields the same results as the hungarian method.
this is because similarities of pairs are usually near or .
.
judgement of clones we allow parametrization by minentry to lter small clones such as a procedure containing just one line as its body.
though the similarity function simm m1 m2 gives high values to similar memories this function does not re ect the size of memories.
so we give a penalty to small size memories.
note that the value of the similarity function ranges over .
simm m1 m2 logminentry log jdom m1 j jdom m2 j the above formula is proportional to the size of memories and inversely proportional to minentry .
log function is used to smoothen the amount of the penalty.
here parameter minentry is given by users depending on target program size.
the parameter is similar to parameter mint which determines the minimum number of tokens for clone candidates indeckard .
we evaluate similarities for all possible pairs of abstract memories.
there is a high probability that procedures with high similarity are true clones.
hence we sort all pairs according to their similarities.
we allow another parameter similarity which determines the threshold of similarities of clones to be reported.
if similarity is set to then pairs with similarity less than .
are not reported.
sometimes the similarity of two memories m1andm2 never exceeds the given similarity if there are a big di erence in the entry numbers of the two memories.
hence we can skip the comparison of two memories where min jdom m1 j jdom m2 j jdom m1 j jdom m2 j similarity this strategy signi cantly reduces the memory comparison time.
users can choose parameters minentry andsimilarity to pick thresholds to determine clones.
one could set minentry high if one wants to ignore small clones.
one could set similarity high if one wants less false positives.
.
experiments in this section we evaluate our code clone detector mecc.
we apply mecc to detect clones in large scale open source projects python apache and postgresql as shown in table .
projects kloc procedures application python interpreter apache web server postgresql database table properties of the subject projects.
we design our experiments to address the following research questions rq1 detectability how many type and type clones can be detected by mecc?
rq2 accuracy how accurately in terms of false positives and false negatives can mecc detect clones?
rq3 scalability how does mecc scale in terms of detection time and detectable program size ?
rq4 comparison how many gapped and semantic clones identi ed by mecc can be detected by previous clone detectors ccfinder deckard and a pdgbased detector ?
.
detectability we apply mecc to detect clones to evaluate the detectability.
in our experiments we set similarity andminentry .
then the detected clones by mecc are manually inspected and categorized into four clone types as discussed in section by one author who has experience with c c development in industry more than eight years.
the other two authors review and con rm the inspected clones.
type type type type python apache postgresql table the distribution of detected clone types by mecc.
the numbers of detected and classi ed clones are shown in table .
mecc can detect all four types of clones.
type semantic and some type gapped clones in table have noticeable syntactic di erences.
nevertheless mecc can detect these clones because it only compares abstract memory states.
mecc also detects type exact and type renamed clones since syntactic similarity is usually accompanied by semantic similarity.
figure shows one type clone detected by mecc.
this is a typical example of control replacement .
the if else statements in figure a are replaced by semantically equivalent statement using the ternary conditional ?
operator in figure b .
mecc detects this clone since their functionalities are the same and thus the abstract memory states are the same.
a more complex type clone detected by mecc is presented in figure .
the clone has two syntactic di erences.
pyobject pybool fromlong long ok pyobject result if ok result py true else result py false py incref result return result a static pyobject get pybool int istrue pyobject result istrue?
py true py false py incref result return result b figure type clone control replacement from python.
the statement if else is changed by using the ternary conditional ?
operator.
syntactical di erences are underlined.
one di erence is statement reordering .
two statements from line to in figure a are reordered into the statements from line to in figure b .
the second di erence comes from using intermediate variables.
the local variable sconf is introduced at line in figure a and then used as a parameter of the ap get module config function call at line .
the local variable proto is introduced at line in figure b .
the return value of the apr pstrdup function call at line in figure b is assigned to this variable.
this value is assigned to a eld address at line in figure via the local variable.
these syntactic changes make it di cult for textual based clone detectors to identify such clones .
understanding the semantics of procedure calls is one advantage of mecc.
an interesting type clone detected by mecc in figure highlights this strength.
the major syntactic di erence between the two procedures is that the assignment statement at line in figure a is substituted by the procedure memcpy call at line figure b .
most previous clone detection techniques cannot capture this semantic similarity between a procedure call and similar assignment statements.
.
accuracy the next question is how accurately mecc can detect clones.
we manually inspected the detected clones and identi ed false positives which are not real clones but are detected as clones by mecc.
total fp fp ratio python .
apache .
postgresql .
table detected clones and false positives.
total total number of detected clones fp number of false positive clones and fp ratio false positive ratio.
table presents the false positive clones and their ratio from three subjects when similarity andminentry .
static const char set access name cmd parms cmd void dummy const char arg void sconf cmd server module con g coreserver con g conf ap getmodule con g sconf core module const char err ap check cmdcontext cmd not indir loc file jnot inlimit if err !
null return err conf access name apr pstrdup cmd pool arg return null a static const char set protocol cmd parms cmd void dummy const char arg const char err ap check cmdcontext cmd not indir loc file jnot inlimit coreserver con g conf ap getmodule con g cmd server module con g core module char proto if err !
null return err proto apr pstrdup cmd pool arg apstrtolower proto conf protocol proto return null b figure type clone statement reordering from apache void appendpqexpbufferchar pqexpbuffer str char ch make more room if needed if !enlargepqexpbuffer str return ok append the data str data ch str len str data a void appendbinarypqexpbuffer pqexpbuffer str const char data sizet datalen make more room if needed if !enlargepqexpbuffer str datalen return ok append the data memcpy str data str len data datalen str len datalen str data b figure type clone preserving memory behavior from postgresqlin python the total number of found clones is the number of false positive clones is and hence the false positive ratio is around .
.
similarly the false positive ratio for apache is .
and for postgresql is around .
.
the most common case of false positive clones is data structure initialization.
in those clones a structure is allocated and then eld variables are initialized according to the structure type.
some of them can be viewed as clones but we scrupulously mark these initialization code pairs as false positives.
these false positive ratios look slightly higher than previous approaches .
however one could set similarity higher to reduce the false positive ratio.
as an example the false positive ratio is only for python when we set similarity .
in the next step we measure the ratio of false negative clones real clones but missed by mecc.
for this experiment since we need an oracle clone set we use the benchmark provided by roy et al.
.
this benchmark includes three type four type ve type and four type clones.
we apply mecc on the benchmark with similarity .
since the sizes of procedures in the benchmark are small we set minentry .
type type type type benchmark mecc table false negatives on the benchmark set .
mecc misses only one clone.
table shows that mecc has almost no false negatives.
mecc misses only one type clone which has an insertion of an ifstatement that is related to a procedure call and it changes the memory state.
however if we set similarity mecc detects this clone.
overall our experimental results in this section show that mecc can detect clones accurately with almost no false negatives and with a reasonable false positive ratio.
.
scalability in this section we measure scalability of mecc.
we already showed that mecc can detect clones in large scale open source projects accurately in section .
and section .
.
we measure the time spent to detect the clones for three subjects.
our experiments were conducted on an ubuntu bit machine with a .
ghz intel core quad cpu and gb ram.
kloc analysis comparison python 63m32s 1m54s apache 308m58s 1m36s postgresql 422m04s 6m28s table time spent for the detection process.
table shows the results.
static analysis took about minutes for python and minutes for postgresql.
since our static analysis includes preprocessing summarization instantiation of procedural summaries and xpoint iterations for collecting memory states it is computationally expensive.
however this is usually one time cost.
whensoftware changes we can incrementally recompute memory states of the changed parts including impacted parts according to the call relationship.
if the changed part in a procedure does not cause observable changes to memory behaviors of the procedure then callers of the procedure do not need to be re analyzed.
though the dependency can in the worst case expand to all the procedures such situation a procedure s change in memory e ects combined with that procedure as a hub in the call graph would not be that common.
.
comparison section .
shows that mecc can detect all four types of clones including type gapped and type semantic clones.
in this section we discuss if other clone detectors can also identify these clones.
python apache postgresql type 3mecc deckard ccfinder pdg based type 4mecc deckard ccfinder pdg based table the numbers of detected type and type clones by mecc deckard ccfinder and a pdg based detector .
for the comparison we use two publicly available syntactic clone detectors deckard a ast based detector and ccfinder a token based detector.
we also use a result set from a pdg based semantic clone detector .
fordeckard we set the options as used in mint minimum token size stride size of the sliding window and similarity .
.
for ccfinder we also use the default options minimum clone length minimum tks token set size and shaper level soft shaper .
for the pdg based detector we directly used the clone detection results provided by the authors of the detector since the tool is not publicly available at the time of this writing.
table compares type and type clone detectability of deckard ccfinder the pdg based detector.
we assume these detectors can detect all type and type clones since these clones are syntactically almost the same.
ccfinder is a scalable and fast tool which detects type1 and type clones accurately.
however ccfinder could not identify any type and type clones.
the main reason is that ccfinder extracts and compares syntactic tokens but usually type and type clones are signi cantly different in the token level.
deckard detects about of type clones.
since deckard uses the characteristic vectors of ast it can detect clones with small syntactic variations.
surprisingly deckard identi es two type clones in postgresql.
the two detected type clones are classi ed as the statement reordering subtype shown in figure .
since deckard extracts characteristic vectors of these reordered asts the vector only captures the number of elements in ast.
however deckard still misses a large portion of type and type clones.the pdg based detector identi es about of type clones.
only one type clone is identi ed in each python and postgresql.
the detected type clones are statement reordering.
since pdgs capture program semantics using data dependency and control ows the pdg based detector can detect some type clones like statement reordered ones.
however these pdg based approaches have some limitations.
first inter procedural semantics via procedure calls cannot be supported which means that semantic clones that di er in respect to procedure calls e.g.
function inlining are missed.
mecc captures memory behavior of procedure calls by procedural summaries as described in section .
second pdgs cannot be completely free from changes on syntactic structures while our technique reliably determines the semantic similarity of code because we use purely semantic information path sensitive abstract memory e ects of programs.
overall the comparison results in this section suggest that mecc an abstract memory based clone detector is e ective in detecting all four types including type and type of clones.
.
discussion we discuss potential applications and limitations of our approach.
we also identify threats to validity of our experimental results.
.
applications detecting code clones is useful for software development and maintenance tasks such as nding inconsistencies and identifying potential bugs or code smells .
we used mecc to identify potential bugs and code smells caused by inconsistencies.
figure shows one example of type clones identi ed by mecc.
this clone was not detected by other clone detectors e.g.
.
it clearly shows an inconsistency the procedure pqparameterstatus in figure b checks whether the second parameter paramname is not null but the procedure getvariable in a does not check.
this inconsistency shows an exploitable bug which manifests when null is passed as the second parameter name.
type exploitable code type bugs smells python .
.
apache .
.
postgresql .
.
total .
.
table exploitable bugs and code smells in type and type clones found by mecc.
we manually inspected all type and type clones identi ed by mecc to check if they were caused by inconsistencies and if these inconsistencies lead to potential problems.
when we identi ed problems caused by inconsistencies we classi ed them in two categories exploitable bugs andcode smells a bug is exploitable if it causes unexpected behaviors for example when a particular variable is used as procedure input as shown in figure a .
conversely a code smell occurs when an inconsistency has no demonstrated unexpected behaviors but refactorings or consistent changes with other clone pairs are highly recommended.
const char getvariable variablespace space const char name struct variable current if !space return null for current space next current current current next if strcmp current name name return current value return null a const char pqparameterstatus const pgconn conn const char paramname const pgparameterstatus pstatus if !conn !paramname return null for pstatus conn pstatus pstatus !
null pstatus pstatus next if strcmp pstatus name paramname return pstatus value return null b figure one type clone statement insertion without changing computation from postgresql.
it includes an exploitable bug due to an inconsistency.
table shows the manual inspection results1.
among type and type clones exploitable bugs and code smells were found.
about of type and type clones are either exploitable bugs or code smells.
these bugs and code smells would be missed by previous approaches e.g.
since most of these type and type clones were not detected by them as discussed in section .
.
overall table implies that mecc and its identi ed type and type clones are very useful for detecting inconsistencies exploitable bugs and code smells.
mecc can be used for plagiarism detection and common bug pattern identi cation.
syntactic plagiarism detection tools e.g.
moss and jplag cannot detect plagiarism if code is copied and intentionally changed with some syntactic obfuscations.
mecc is able to detect plagiarism as long as the semantics of the copied code remains similar regardless of its syntactic changes.
similarly mecc can help identify common bug patterns.
kim et al.
proposed bugmem which identi es common bug x patterns and locates similar bugs in other code.
however they only capture syntactic bug patterns using tokens of code.
mecc can improve their work by identifying common semantic bug patterns.
.
limitations since our current implementation compares abstract memory states at the exit points of procedures mecc detects only procedure level clones.
however it is possible to extend mecc to nd clones with a ner granularity such as basic 1more detailed data is available at kr meccblocks adapting a code fragments generation technique to prepare code clone candidates of ner granularity.
then we can calculate every abstract memory state for each candidate and compare them to identify clones.
collecting abstract memory states from programs is a computationally expensive task in both time and memory.
analyzing the semantics of programs takes longer than syntactic comparison.
however the current implementation of mecc showed that mecc scales to detect clones in postgresql which is around 1m loc.
similar abstract memory states do not always imply similar concrete behaviors which may cause false positives.
in the abstract interpretation framework one element in an abstract domain can represent several concrete elements.
procedural summaries record memory related behaviors but do not capture all concrete procedure behaviors.
this limitation is inevitable since determining semantic equivalence between two programs is generally undecidable .
.
threats to validity we identify the following threats to validity to our work projects are open source and may not be representative.
the three projects used in this paper are all open source and not representative of all software systems and hence we cannot currently generalize the results of our study across all projects.
however these projects are chosen because they are commonly used in other code clone related research.
manually inspected and classi ed clones.
one author manually inspected and classi ed clones and they are used to evaluate mecc.
since there is no consensus about type and type clones there is ambiguity in the classi ed clones.
however two other authors con rmed the classi ed clones and we made these data publicly available.
default options are used.
deckard ccfinder and the pdg based detector have various options to tune their clone detectability.
in this paper we use their default options.
however careful option tuning may allow these tools to detect more type or type clones.
.
related work most clone detection techniques are syntactic clone detectors ones leveraging line based token based or tree based approaches.
these detectors are good at identifying type and type clones but they miss most of the type and some of the type clones as discussed in section .
.
existing semantic clone detectors have limitations.
for example as we discussed in section .
pdg based detectors miss some semantic clones due to for example ignorance of inter procedural semantics.
a pdg based technique maps slices of pdgs to syntax subtrees and applies deckard to detect similar subtrees.
although slicing enables one to detect more gapped clones clones in each clone cluster still need to be syntactically similar.
jiang et al.
proposed a clone detector using random testing techniques.
they conclude two code fragments are clones when their outputs are the same just for a number of randomly generated inputs.
since random testing cannot cover all program paths or inputs usually around up to false positives are inevitable.
furthermore the inter procedural behaviors are not considered in their approach.
.
conclusions and future work we proposed an abstract memory based code clone detection technique presented its implementation mecc and discussed its applications.
since mecc compares abstract semantics as embodied in abstract memory states its clone detection ability is independent of syntactic similarity.
our empirical study shows that mecc can accurately detect all four types of code clones.
we also show that most of type4 and some of type clones identi ed by mecc cannot be detected by previous approaches .
we anticipate that mecc will allow developers to nd inconsistencies as shown in section .
identify refactoring candidates and understand software evolution related to semantic clones which would be neglected by previous approaches.
even so we still see room for improvement.
since mecc uses static analysis it requires some time to analyze the entire source code prior to our clone detection process.
our static analyzer can only collect memory states in the procedure level and thus mecc can detect only procedure level clones.
to detect ner granularity clones we plan to adapt our static analyzer to collect memory states for each basic block.
overall we expect that future clone detection approaches will exploit more deep semantics of code via static analysis program logic and or other program veri cation technologies.
mecc is one step forward in this direction.
.