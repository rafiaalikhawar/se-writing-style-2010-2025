analyzing security architectures marwan abi antoun department of computer science wayne state university mabiantoun wayne.edujeffrey m. barnes institute for software research carnegie mellon university jmbarnes cs.cmu.edu abstract we present a semi automated approach secoria for analyzing a security runtime architecture for security and fo r conformance to an object oriented implementation.
typecheckable annotations describe architectural intent with in the code enabling a static analysis to extract a hierarchic al object graph that soundly reflects all runtime objects and runtime relations between them.
in addition the annotations can describe modular code level policies.
a separat e analysis establishes traceability between the extracted o bject graph and a target architecture documented in an architecturedescription language.
finally architectural types properties and logic predicates describe global constrai nts on the target architecture which will also hold in the imple mentation.
we validate the secoria approach by analyzing a line pedagogical java implementation and a runtime architecture designed by a security expert.
categories and subject descriptors d. .
software architectures general terms design security verification .
introduction companies such as boeing and microsoft have been usingthreat modeling as a lightweight approach to reason about security to capture and reuse security expertise and to find security design flaws during development.
proponents of threat modeling have employed it in a number of industrial scale projects and report impressive results.
microsoft for example claims that threat modeling led to a reduction in security vulnerabilities and around data flow diagrams dfds were manually reviewed during the development of windows vista.
when a security expert asks a developer to build a security architecture for a system under study the developer permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.typically produces a diagram mostly from his recollection of how the system works with little tool support to extract such an architecture from the code.
then during the security review the experts study the architecture assig n to the components different architectural properties such a s trustlevel orprivacylevel and enumerate all possible communication between the more trusted and the less trusted components of the system.
they also analyze the communication between components that contain personally identifiable information and those that do not.
one potential hurdle to achieving significantly better defect reduction is that the architecture may not show all the communication that is present in the system.
as a result an architectural level analysis may be incomplete.
while any architecture based approach suffers from these problems s ecurity architectures pose special challenges.
a security architecture1is an example of a runtime architecture which shows runtime components and connectors useshierarchicaldecomposition andpartitionsasystemi nto tiers .
today the tools for extracting and analyzing con formance of runtime architectures are immature compared to tools for the code architecture .
moreover a security analysis must consider the worst and not the typical case of possible component communication.
the analysis results are valid only if the architecture reveals all objects and relations that may exist at runtime in any program run.
this requires a static analysis which can capture all possible executions.
in contrast a dynamic ana lysis which extracts an architecture or analyzes conforman ce basedononeor more programruns maymiss important objects or relations that arise only in other executions.
the contributions of this paper are the first architecture centric approach secoria2 that enables both reasoning at the level of a security runtime architecture and relating it to the code at the same time as compared to previous approaches which do one or the other.
the approach can enforce both code level and global architectural constraints.
an end to end validation of secoria using a real line java implementation of a runtime architecture designed by a security expert.
1threat modeling typically uses a data flow diagram which describes how data enters leaves and traverses the system shows data sources and destinations trust boundaries and processes that data goes through .
here a security architecture shows points to rather than data flow connectors.
2secoria stands for se curity c onformance of o bjectoriented r untime vi ews of architecture.
secoria specializes the scholia approach by abi antoun and aldrich to analyze at compile time communication integrity between arbitrary object oriented code and a hierarchical target runtime architecture .
communication integrity meansthateachcomponentintheimplementation may only communicate directly with the components to which it is connected in the architecture.
scholia requires adding typecheckable annotations to establish traceabil ity between the target architecture and the code.
ourdesign intent basedanalysis involves an iterative pro cess with two main stages the conformance stage sect.
which relates a security architecture to code and the enforcement stage sect.
which enforces architectural intent.
we evaluate the secoria approach by applying it to a real system sect.
.
finally we conclude with a discussio n sect.
and a brief survey of related work sect.
.
.
conformance stage architectural reasoning about security is best accomplished with a runtimearchitecture rather thana code archi tecture.
unfortunately extracting the runtime architect ure is difficult.
at runtime an object oriented system can be represented as an object graph nodes correspond to objects and edges correspond to relations between objects.
taking a snapshot of the heap at runtime reveals the structure at that instant in great detail but the profusion of objects makes it difficult to get a high level picture without extensive graph summarization and manipulation .
moreover such a snapshot shows only one or more executions meaning the developer may miss important objects or relations that arise only in other executions.
on the other hand a sound static analysis can extract an object graph that captures all executions.
but previous static analyses produce non hierarchical object graphs that explain runtime inter actions in detail but convey little architectural abstract ion.
a flat object graph mixes low level objects such as hashmap with architecturallyrelevantobjects suchas cryptoreceipt and a developer has no easy way to distinguish them.
even for a small program a flat object graph typically does not conveysufficientarchitecturalabstractiontobeusedforco nformance analysis.
.
ownership domain annotations a central difficulty is that architectural hierarchy is not readily observable in arbitrary code.
to achieve hierarchy in an object graph scholia requires that a developer pick a top level object as a starting point then use modular ownership annotations in the code to impose a conceptual hierarchy on objects.
the annotations specify object encapsulation logical con tainment and architectural tiers within the code construc ts which are not explicit in most programming languages.
the scholia toolsuseexistinglanguagesupportforannotations.
in addition the annotations implement a type system so a typechecking tool can validate the annotations and identif y inconsistencies between the annotations and the code.
anownership domain is a conceptual group of objects with an explicit name and explicit policies that govern how a domain can reference objects in other domains .
each object is assigned to a single domain that does not change at runtime.
a developer indicates the domain of an object by annotating each reference to that object in the program.the annotations define two kinds of object hierarchy logical containment and strict encapsulation defined below.
logical containment.
a public domain provides logical containment thus making an object conceptually part of another object.
having access to an object gives the ability to access objects inside all its public domains.
for example localkeystore has a public domain keys to holdlocalkey objects .
strict encapsulation.
a private domain provides strict encapsulation .
thus a publicmethod cannot return an alias to an object in a private domain even though the java type system allows returning an alias to a field marked private.
for example localkeystore stores the arraylist of localkey objects keys in a private domain owned .
.
object graph extraction scholia extracts an ownership object graph oog that provides architectural abstraction by ownership hier archy by showing architecturally significant objects near th e top of the hierarchy and data structures further down.
an object graph can also provide abstraction by types by collapsing objects further based on their declared types.
the visualization uses box nesting to indicate containment of objects inside domains and domains inside objects .
dashed border white filled boxes represent domains.
solid filled boxes represent objects.
solid edges re present field