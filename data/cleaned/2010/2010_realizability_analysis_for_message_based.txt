realizability analysis for message based interactions using shared state projections sylvain hall universit du qu bec chicoutimi canada shalle acm.orgtevfik bultan university of california santa barbara usa bultan cs.ucsb.edu abstract the global interaction behavior in message based systems can be specified as a finite state machine defining acceptable sequences of messages exchanged by a group of peers.
realizability analysis determines if there exist local impleme ntations for each peer such that their composition produces exactly the intended global behavior.
although there are existing sufficient conditions for realizability we show tha t these earlier results all fail for a particular class of specifications called arbitrary initiator protocols.
we present a novel algorithm for deciding realizability by computing a finite state model that keeps track of the information about the global state of a conversation protocol that each peer can deduce from the messages it sends and receives.
by searching for disagreements between each peer s deduced states we provide a sound analysis for realizability that correctly classifies realizability of arbitrary initiator protocols.
categories and subject descriptors b. .
interconnections subsystems asynchronous synchronous operation web technologies d. .
requirements specifications tools validation general terms verification keywords realizability asynchronous communication choreography .
introduction nowadays many software systems consist of multiple components that execute concurrently possibly on different machines.
new trends in computing such as serviceoriented architecture soa cloud computing multi core this work is supported by nsf grants ccf and ccf and by the fonds qu eb ecois de recherche sur la nature et les technologies fqrnt .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or c ommercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.hardware all point to more concurrency and distribution among the components of software systems in the future.
in order to complete a task components of a software system have to coordinate their executions by interacting with each other.
a fundamental question is what should be the interaction mechanism given the trend for increased level of concurrency and distribution?
one emerging paradigm is message based communication where components interact with each other by sending and receiving messages.
this is particularly the case for soa which through the use of soap and xml enable interaction among existing services to form composite value added applications.
a key factor in soa is the loose coupling between the various parties involved in an interaction.
apart from a mutuallyagreed protocol of interaction called a conversation protocol or a choreography specification in soa each peer taking part in such a global conversation is an independent and self contained unit.
to further loosen this coupling between potential partners many web services are implemented using asynchronous communication.
while in synchronous communication the sender and receiver of a message are required to block their operation for the duration of the message transfer in asynchronous communication this restriction is relaxed by treating sending and receiving as two separate events.
the recipient of a message is no longer required to synchronize with the sender and can rather buffer messages in an input queue and process them at an arbitrary later time.
interestingly the same type of message based interactions appear in other domains as well.
for example singularity is a new experimental operating system developed by microsoft research to explore new approaches to os design .
one of its main goals is to improve the dependability of software systems by rethinking some design decisions that have largely governed operating system architecture to date.
process isolation is a chief design principle of the singularity operating system.
to achieve process isolation certain constraints are enforced to ensure process independence.
among these is the rule that processes cannot share memory with each other or the kernel.
all interprocess communication in singularity therefore occurs via message passing over bidirectional conduits called channels.
channels have two end points referred to as the client and the server that communicate with each other by sending and receiving messages.
communication through singularity channels corresponds to asynchronous communication 27cs c c174 sc f c174sc f c174cs s c1740 a cs c c174 cs c c174 sc f c174sc f c174cs s c1740 b figure two simple file transfer protocols.
via fifo message queues.
moreover in singularity each channel is governed by a channel contract .
a channel contract is a state machine that specifies the allowable ordering of messages between the client and the server.
hence channel contracts are a type of conversation protocols and serve the same purpose that choreography specifications serve in soa.
asynchronous communication is appealing for simplifying the management of message exchanges in soa or when isolating processes from each other in an operating system but many natural assumptions about synchronous protocols no longer hold when message queuing is involved.
for example figure 1a shows a specification for the control channel of a simple file transfer protocol between a client c and a server s .
after asking for the start of a transfer s the sequence of possible messages depends on who initiates the remaining part of the conversation.
if c sends a cancel transfer message c first then s should replyto c s request with a transfer finished message f on the other hand no cancellation request should be issued by c once s notifies that the transfer is complete.
albeit simple this protocol p resents problems.
in the situation where s sends ffirst but its message remains in transit for some time c might believe the transfer is not finished and send c thus violating the protocol and perhaps throwing s into an undefined state.
this happens even though each peer locally complies with the protocol.
the fault in this case is not any of the peers it is rather rooted in the fact that asynchronous communication is used.
protocols that exhibit this type of behavior are called unrealizable protocols.
the question of deciding whether a given protocol is realizable or not is an open problem.
the presence of unbounded input queues makes the exhaustive search of all possible communication traces impossible.
there has been two separate branches of research to address this problem and sufficient realizability conditions have been developed indepe ndently through the analysis of the state machines characterizing the allowable conversations e.g.
or by reformulating the problem within a type system that prevents the declaration of unrealizable protocols e.g.
.
these conditions are sound and can be used to formally prove the realizability however they are not complete and can produce false positives.
in particular a fixed version of the file transfer protocol shown in figure 1b will be identified as unrealizable by both approaches although it actually isrealizable.
we show that this will be the case of any protocol containing a state with an arbitrary initiator i.e.
a state where more than one peer could send the next message and the protocol works fine for either case.
in this paper we present a novel way of deciding the realizability of a protocol in the presence of asynchronous communication.
our technique is based on the observation that in a realizable protocol a global observer can follow the con versation between the peers and at any moment determine precisely the global state of the protocol.
each individual peer based on the messages it sends and receives can only guess plausible values for that global state.
we show how to compute an annotated version of the original protocol specific to each peer called shared state projections including such guesses.
we demonstrate that at any moment in a realizable protocol there exists at least one state which all peers agree is a believable global state.
conversely this entails that in many cases unrealizable protocols have two of their peers straying until they have irreconcilable beliefs of the current global state.
since the number of protocol states is finite the number of belief states is also finite and searching for such discordant belief states can be done exhaustively.
the contributions of this paper are we provide a natural explanation of realizability based on the consistency of the observations of the different peers.
we give a new sufficient condition to ensure realizability of a conversation pro tocol that can be evaluated automatically using shared state projections.
we show that our realizability condition ca n correctly identify realizable arbitrary initiator protocols as opposed to earlier work based on conversations and session types which always produce false positives for this class of protocols.
in section we review the concepts about conversation protocols and define realizability.
in section we develop the concept of shared state channel system and show how to compute shared state projections.
we also demonstrate the soundness of our method.
in section we present a tool we developed to automatically compute belief projections and analyze its results on more than real world protocols.
we show in particular how protocols deemed unrealizable with earlier approaches can be shown realizable with our new approach.
in section we review the earlier results on realizability and show that they fail to correctly analyze arbitrary initiator protocols.
finally in section we conclude the paper and indicate further research directions.
.
modeling message based interactions in this section we first present a formal model for conversation protocols which are finite state machines that are used to specify the set of allowable message sequences.
next we discuss channel systems which is a formal model for a set of components i.e.
peers that interact with asynchronous messaging.
finally we formalize the realizability problem based on conversation protocols and channel systems.
.
conversation protocols a natural way of specifying the allowable message based interactions in a concurrent or distributed system is to use a finite state machine that serves as the agreed upon protocol among the peers that interact with each other.
such specifications can be formalized as conversation protocols definition .aconversation protocol is a quintuplet 28ab m1 c174 ab m4 c174 bc m3 c174ca m2 c174 a cab m1 c174 ab m4 c174ca m2 c174 b a c ab m1 c174 bc m3 c174ab m4 c174 c b c ca m2 c174 bc m3 c174 d c c ab m1 c174 ab m4 c174 bc m3 c174ca m2 c174a b c a b c a b c a b c a b c e a c b c b c figure a conversation protocol c a its projection for peers a b and c b d and the product of these three projections e .
c p s s l where p p0 ... is a finite set of peers s s0 ... is a finite set of states s0 sis the initial state l l0 ... is finite a set of message labels and s p l p sis a transition function.
at r i p l e t p l p is called a message and represents peer psending the message with label lto peer p .t h e t r a n sition function is such that sm p l p returns the state snaccessible from state smfor that message.
we extend the definition of over sets of states such that for a subset s s w eh a v e s p l p uniontext s s s p l p .
a sequence of messages is accepted by cas long as it corresponds to some valid path that starts from its initial state.
we do not define explicit accepting states for conversation protocols or equivalently we assume that all states are accepting .
the language accepted by c n o t e d l c is the set of message sequences that are accepted by c. a conversation protocol ccan be projected to one of its peers p noted as p c which is obtained by replacing every transition where pis neither the sender nor the receiver by an transition.
for example figure 2b shows the projection of figure 2a onto peer a. since in that protocol the transition from state to state does not involve a it becomes an invisible transition in the projection.
one might then collapse any states linked by an transition as a single compound state whose label becomes a subset of states from the original conversation.
for peer a the transition causes the collapse of states and into a single state labeled .
individual conversation protocols c0 ... cncan also be combined in a form of cartesian product noted c0 c n similar to dfa product operation.
figure shows examples of these concepts .
.
channel systems achannel system is a formal model for a set of peers that interact with asynchronous messages.
when a message is sent it is not immediately received as in synchronous communication but rather it is stored in the input queue of the receiver and can be consumed by the receiver at an arbitrary later time.
one way of producing a channel system is by composing a set of conversation protocols c0 ... cncorresponding to peer behaviors.
intuitively each peer possesses its own input message queue and its own finite state control it sends and receives messages according to its individual control state and queue contents.
channel systems formalize this type of behavior .
letpbe a set of peers lbe a set of message labels and ci p si si l i i p be a set of conversation protocols one for each peer in p. for a set of messages m p l p we let m denote the set of finite words over this alphabet of triplets these words represent the contents of each peer s input message queue.
a global state sof c is a pair angbracketleft s0 ... s p w angbracketright w h e r e si siandw p m associates each conversation protocol with a state and a message vector denoting the contents of each peer s input message queue .
a channel system is defined over these elements as follows definition .achannel system cis a quintuplet p s s0 m where s s0 s p m p is a finite set of control states s0 sis the initial control state m p l pis a finite set of messages and s m !
?
sis a finite set of transitions.
the initial global state s0of cis the pair angbracketleft s0 ... s p w angbracketright w h e r e w p for each peer p i.e.
each peer starts with an empty input message queue .
since send and receive events are now decoupled from each other the transition relation is defined over directed messages m which are tuples m m !
?
w h e r e m is a message and is either !
representing the sending of m o r ?
r e p r e s e n t i n g mbeing read from the recipient s input queue .
the relation is defined as the smallest set of triplets s m s w h e r e s s0 ... s p a n d s s0 ... s p are control states and m pm l p n i sad i r e c t e d message such that .
if angbracketleft s pm l p n !
s angbracketright then the control states change from sto s and pm l p n is appended to the tail of channel w pn all other channels do not change.
moreover sm m sm a n da l lo t h e r s si do not change.
.
similarly if angbracketleft s pm l p n ?
s angbracketright then the control states change from sto s and pm l p n is removed from the head of channel w pn all other channels do not change.
moreover sn n sn a n da l lo t h e r s si do not change.
29as an example figure shows a portion of the channel system obtained by composing the projections in figure .
each state of this channel system lists the projection state for peers a b and c followed by the contents of the queue f o re a c hp e e r i nt h ef o r m p w p where pis the peer s name and w p is the contents of its queue.
from a trace of states s0 ... skin a channel system c one can extract the corresponding sequence of directed messages m0 ... mk k .
the send trace is the subsequence obtained by keeping the directed messages misuch that i !
and removing all the other directed messages.
the set of all send traces produced by cis denoted as l c we call it the language accepted by c. .
realizability there are six possible executions in the portion of channel system in figure these executions create five distinct send traces.
let us consider the trace shown in bold which corresponds to the following sequence of events.
first peer c being in state of its projection can move to its state and send message m2to a s input queue which corresponds to the transition to the subsequent state.
next a still being in state of its projection chooses to place message m1in b s input queue and moves to state .
finally b consumes message m1 and immediately sends m3 ending in its projection state .
this execution has several issues.
first in the last state of the channel system a is in state and does not expect any more messages yet m2is waiting in its queue.
second the send trace corresponding to this execution is not part of the conversation protocol from which the channel system was derived.
as a matter of fact from the six possible send traces generated by this portion of channel system four of them are spurious message sequences not specified by the original conversation protocol.
theorem .letcbe a conversation protocol and cbe the channel system obtained from p0 c ... p p c .t h e n l c l c .
proof.
lets s0 s1 ...be a state trace of c.w e build a trace s s0 s1 ...from sas follows.
we take s0as the start state in definition .
for each i if angbracketleftsi pj l p k si angbracketright then s2i angbracketleft s0 ... s p w angbracketrightis the global state obtained from s2iby taking the transition labeled with the directed message pj l p k !
s2i angbracketlefts0 ... s p w angbracketright is the global state obtained from s2i 1by taking the transition labeled with the directed message pj l p k ?
trivially shas the same send trace as s m o r e o v e ri t sc o n struction follows definition and is therefore a trace of global states in c. the fact that the relation between cand cis an inclusion and not an equality is the source of the problem described in the file transfer protocol of figure 1a the channel system obtained from the projections of that protocol onto peers c and s produces one send trace s f c t h a ti sn o ti nt h e original specification.
a protocol is said to be realizable when we have a strict equality ab m1 c174 ac m2 c174 cb m6 c174bc m5 c174 bc m3 c174 ba m4 c174 figure deducing b s possible state from a s point of view in a conversation protocol.
definition realizability .
a conversation protocolcisrealizable if there exists conversation protocols cp0 ... cp p for each peer such that the channel system c cp0 c p p is such that l c l c .cisstrictly realizable when cpi pi c for0 i p .
.
shared state projections a simple way of ensuring realizability is to develop the channel system cand to exhaustively check that no spurious send trace is produced.
however the presence of unbounded message queues makes the problem in general intractable even for simple protocols .
other criteria must be developed to decide realizability of a conversation protocol.
we propose shared state projections ssp for this purpose.
.
an intuition for ssps an ssp is a different kind of peer projection for a conversation protocol.
rather than simply projecting the protocol over a single peer p an ssp also keeps track in parallel of the state of other peers or more precisely of what can be deduced about that state based on messages that psends and receives.
consider the simple conversation protocol shown in figure .
suppose from a s point of view that the message exchange has just started i.e.
all peers are in state .
it shall first be noted that from a s point of view transitions from state to state and from state to state are invisible transitions therefore the current state of a is actually the set .
moreover from a s point of view is not the only possible state for peer b since a cannot distinguish between states and b can reach these states with no way to know whether this transition was indeed taken.
b cannot distinguish between states where it is neither the sender nor the receiver.
hence is vacuously a possible state.
b cannot be in state since it would require a sending m1.
for a similar reason is unreachable as it relies on c s participation which in turn depends on a. finally because communications are asynchronous b can send a message to a without a having received it yet.
hence when a is in state before it reads anything from its input queue b can already be in state .
from this informal chain of deductions peer a in state knows that peer b can be in states but cannot be in states .
with a similar reasoning about c a can guess that its possible states are .
30ab m1 !
c174 ab m1 ?
c174ab m1 ?
c174 ab m1 !
c174 ab m4 !
c174 ab m4 ?
c174 bc m3 !
c174bc m3 !
c174 bc m3 ?
c174ca !m2 c174 ca m2 !
c174 ca m2 !
c174 ca m2 !
c174ca m2 ?
c174 a b c c101 c101 c101 a b c c101 c101 c101 a b c c101 c101 c101 a b c c101 c101 c101 a b c c101 c101 c101 a b c ca m2 c101 c101 c174 a b c c101 c101 ab m4 c174 a b c ca m2 c101 c101 c174 a b c ca ab mm21 c101 c174 c174 a b c ca bc mm23 c101 c174 c174 a b c c101 c101 ab m1 c174 a b c c101 c101 bc m3 c174 figure a portion of a channel system obtained from the composi tion of the peer projections in figure b d .
the initial state of a s ssp is therefore a triplet of sets of states one for each peer as follows a b c .
from that list of possible states one can then compute possible transitions leading to new combinations of possible states and so on definition .letc p s s l be a conversation protocol with p the number of peers involved in c.a shared state projection ssp derived from c f r o m p s point of view noted hatwide p c is a quintuplet p hatwides hatwides0 l hatwide w h e r e hatwides 2s p is a set of shared peer states hatwides0 hatwidesis the initial state and hatwide hatwides p l p hatwidesis a transition function.
an ssp can be seen as a hybrid like channel systems one keeps track of states for all peers but like conversation protocols queue contents are not directly taken into account.
.
conditions on ssps we now proceed to give conditions on an ssp that taken together define an algorithm for computing it.
the informal presentation of an ssp showed that guessing possible states for other peers involves computing some kind of reachability function over a set of starting states.
indeed the possible state of each peer is interdependent with the actions performed by other peers.
for example in figure 5a b cannot advance to state s3along the path s0...s3without a first sending m1to d and d then sending m2to b. in other words a indirectly controls or blocks b from reaching s3along that path.
on the contrary in figure 5b a does not constrain b from reaching s3.
this notion is formalized below.
definition blocking peer .
let s s1s2...s n be a path in c a n dl e t pbe some peer.
the peers blocked bypatsnalong n o t e d bp s is the smallest set of peers such that .p bp s .
if there exists a transition p1m p2from a pair of states si si 1in s a n d p1 bp s t h e n p2 bp s .
3a c174d m1d c174b m2b c174c m3 a 3a c174d m1d c174c m2b c174c m3 b figure different scenarios for blocked peers along a path from this definition of a blocking peer we develop a form of reachability called p p reachability .
definition p p reachability .
letp p be two peers and s s sbe two states of a conversation.
the states is p p reachable fromsif and only if there exists ap a t h s0 ... s n s0 s sn s a n ds o m e k nsuch that along s0...s k the sender is not blocked by p a n d along sk...s n pis neither the sender nor the recipient of any message.
to get b s possible states in our motivating example we computed all states that are a b reachable from state .
we indeed obtain the set .
similarly possible states for a and c have been obtained through a a and a c reachability.
thus we obtain a formal definition of an initial state in an ssp definition initial state .
the initial state hatwides0of an ssp hatwidecdeveloped from p s point of view is the p tuple 0 ... p such that iis the set of states p pi reachable froms0 the initial state of c. from this initial state of an ssp one is then interested in finding possible transitions and to compute the resulting state for each transition.
we need to introduce two auxiliary functions that will be used in this computation.
we first extend a transition function with that returns a special symbol standing for empty .
more precisely s s w h e n s is defined and s o t h e r wise.
similarly for a subset s s w eh a v e s s if s negationslash a n d s o t h e r w i s e .
31a second useful function that will be used is the post s l function which removes from s all states that precede the first occurrence of some message label lin the conversation protocol c. definition postfunction .
lets sbe a subset of states of some conversation and l lbe some message label.
the function post s l returns the smallest subset such that .
if there exists pi pj p s ssuch that s pi l p j s t h e n s post s l .
if s post s l s s and there exists pi pj p l lsuch that s pi l p j s t h e n s post s l .
finally we require one last reachability definition namely ?p reachability definition ?p reachability .
letcbe a conversation protocol and p pbe some peer.
a state s is?preachable fromsif and only if there exists a path of messages fromstos incwhere pis never the sender.
this intuitively corresponds to the fact that a peer pcan be in some state s and have messages waiting to be read in its input queue.
therefore s can be reached by simply waiting or consuming messages in the queue the state of the conversation protocol does not require pto send any new message to reach that state.
note that this does not mean that s willbe the state eventually reached by pafter reading messages in its queue it only means that s is one of the possible reachable states in that situation.
for some state s s we will note the set of all states p p reachable from sasr p p s s o rs i m p l y r p p s when the context is clear.
by extension for some set s s we define r p p s s uniontext s s r p p s s .
the function rinduces a partition of the set of states s into multiple regions the set of such regions will be noted p p p s .
similar functions can be defined with ?
p reachability.
equipped with these definitions we can define hatwide t h et r a n sition relation of an ssp.
definition transition relation .
let hatwides sp0 ... s p p and hatwides s p0 ... s p p be two states of the ssp hatwide p c f o rs o m ep e e r p p.t h e n hatwide hatwides pi lk pj hatwides if and only if for each peer p o n e of the following conditions holds .p negationslash pi p negationslash pj a n d s p sp .p pi a n d s p r p p s sp .p negationslash pi p negationslash pi p negationslash pj a n d s p r p p s post hatwidesp lk .
otherwise s p uniontext r p?p sp r to build an ssp for some focus peer p i ts u ffi c e st oc r e a t e its initial peer state and to recursively generate successo rs to each new peer state according to definition .
in each node of a shared state projection there are p subsets of the original conversation protocol state set s one for each peer.
therefore an sscs has at most p s distinct nodes and the analysis requires computing at most nsuch projections one for each peer .
therefore the procedure is guaranteed to terminate.
.
a realizability condition a first observation is that from definition hatwide is an over approximation of i.e.l p c l hatwide p c for every peerp.
the next theorem follows immediately theorem .letcbe a conversation pi c i p a n d hatwide pi c be its peer projections and shared state projections respectively.
let cbe the channel system obtained from composing the pi a n d cbe the channel system obtained from composing the hatwide pi c a l l e da shared state channel system .t h e n l c l c .
from this result we can immediately deduce that an sscs is a sound approximation of realizability for conversations any spurious message sequence produced by the asynchronous channel system making the conversation protocol unrealizable will also be a spurious message sequenc e of the sscs.
it remains to demonstrate some condition on an sscs that could in turn warn of the presence of such a spurious message sequence.
to this end we develop the notion of a conflict state.
definition conflict state .
let hatwides sp0 ... s p p be a state of hatwide p c for some peer p .
define a hatwides sp0 sp p .i fa hatwides is empty or contains the symbol then hatwidesis called a conflict state .o t h e r w i s e the states in a hatwides are called possible agreements for all peers.
for example with the conversation protocol in figure and the initial state hatwidesfor hatwide adefined previously we have a the intersection of possible states for each peer.
intuitively a conflict state des cribes a situation where after some messages have been exchanged between peers some of them disagree about the global state of this conversation in a way that cannot be settled unless one of the peers sends a message or discards a symbol in the input queue hence as it is the current state of each peer makes one of them stuck .
theorem .let sp0 ... s p p w be a global state of a shared state channel system and api a spi be the possible agreements for each of the ssps in that global state.
then unless one of the apiis a conflict state a ap0 ap p negationslash .
proof.
by induction we actually show that the intersection of the apimust include the state of cresulting from the last send action.
base case the initial state of cvacuously follows the property.
induction step suppose the property is true for any state sreachable within ksteps from the initial state.
let s pj l p k s be a transition going one step further.
two cases must be considered .
if ?
since scontains an agreement by the induction hypothesis all paths from staking ?
transitions have the same agreement this includes all paths going through s .
.
if !
let s1be the agreement in s.l e t s2 s1 pj l p k let us show that if an agreement can be reached it has to include s2.
forpj by definition .
s2is already in its set of states.
since pkcould agree on s1in s i ts u ffi c e sf o r 32pkto reach s1through receive transitions and then to consume pj l p k this is possible by definition .
.
then by construction s2is an element of skin s .
all other peers are neither the recipients nor the senders for them the transition from s1tos2is an transition and therefore s2is already in their set of states by definition .
.
hence all peers can reach an agreement on s2without sending any new message.
a consequence of theorem is that if none of the ssp contains a conflict state then neither does the channel system built from them.
conversely the presence of a conflict state might hint at a spurious message sequence.
theorem .let hatwide cbe the sscs obtained from the ssps of some conversation protocol c.l e t s s0 s1 ...be a state trace of hatwide cwhere no state is a conflict state.
then the send trace of sis a trace of c. proof.
for a global state s define aas in the previous theorem.
from s we build a sequences of states of c s a s0 a s1 .... by theorem a si is well defined and changes only through send operations.
therefore for si si two successive states if the transition results from a message p l p ?
thena si a si if the transition results from an action p l p !
then si a si p l p !
.
it follows that s s send trace is a trace of c. a realizability condition follows from all these results corollary .letcbe a conversation.
if none of the ssps hatwide p0 c ... hatwide p p c contain a conflict state then c is realizable.
proof.
let cbe the channel system obtained by composing the peer projections pi c for each peer pi.l e t hatwidecbe the sscs obtained by composing the ssps hatwide pi c for each peer.
by theorem l c l c .
by theorem l c l hatwidec .
by theorem if none of the ssps contain a conflict state then same holds for hatwidec.
finally by theorem in such a case l hatwidec l c .
it follows that l c l c l hatwidec and hence cis strictly realizable.
corollary provides a sufficient condition for a conversation protocol cto be realizable.
moreover this condition can be computed by reachability analysis.
indeed we need to compute p ssps where each has a finite size bounded by p s .
this gives an upper bound of p s on the size of the state space thereby reducing the problem to a search in a finite graph.
we shall see in a later experimental evaluation of the approach that this upper bound is seldom reached for real world protocols.
.
experimental results to test our approach we developed a tool called sspcalc which takes as input a conversation protocol and then computes ssps for some or all of the peers involved.
the1010 number of explored statestheoretical upper boundyx figure actual state space size vs. theoretical upper bound for each protocol.
tool is implemented in php and runs on a web server it u s e sag r a p h i c a li n t e r f a c et h a ta l l o w sau s e rt os p e c i f yv a r ious computation options.
sspcalc s results are also displayed graphically.
the channel system corresponding to each sscs as well as the resulting product are all represented as annotated graphs.
various statistics about the computation such as memory consumption and state space size are also given.
analysis of performance we ran sspcalc on more than different real world protocols taken from the following sources ibm conversation support channel contracts from the singularity operating system protocols from the bpel specification and the travel agency example from .
all of them were already specified graphically as conversation protocols they simply had to be translated into an equivalent textual representation that sspcalc uses as input.
we first computed the total state space that was required to be explored for each protocol.
we compared this number with the theoretical p s upper bound on the number of states.
these results are shown in figure .
as one can see the actual number of states explored in every protocol is much lower than the theoretical maximum.
the log log graph has a slope of .
which means that the expected number of reachable states is roughly in a x5relationship with the upper bound.
although sspcalc is a proof of concept prototype written as a php script we still measured the total time for the validation of each protocol in terms of its state space size and plotted the results in figure .
the log log graph has a slope of .
which indicates that processing time is roughly the square of the state space size.
the times ranged from milliseconds to one hour depending on the protocol.
very few protocols took a long time to process of them were analyzed in less than one second and in less than seconds.
they were measured on an intel machine running at .
ghz under linux centos.
false positives more importantly we compared the results returned by sspcalc with those returned by wsat a tool for analyzing conversation protocols and tune a tool for analyzing singularity channel contracts.
wsat uses the three realizability conditions defined in called synchronous compatible autonomous and lossless join d e3310410 number of explored statesvalidation time s figure total verification time with respect to state space size.
readystate io runnings1cs gettpmstatus c174 cs gettpmstatus c174readystates0 readystates1cs send c174sc ackstartsend c174 sc sendcomplete c174 sc sendcomplete c174sc tpmstatus c174 sc tpmstatus c174io runnings0io running sc tpmstatus c174 figure the original tpmcontract protocol solid lines with additional states and transitions dashed to make it realizable.
scribed in section below whereas tune uses only the autonomous condition which is sufficient for determining realizability of two party protocols like channel contracts .
both wsat and tune use sound realizability analyses and hence correctly identify the protocols that are unrealizable.
for example the haggle protocol from ibm conversation support and the tpmcontract protocol shown in figure are two unrealizable protocols that are correctly identified as such by wsat and tune.
sspcalc is also a sound realizability analysis tool so it also identifie s these two protocols as unrealizable.
in a way similar to the example of figure it is possible to fix some unrealizable protocols with additional transitions and states in such a way that it becomes realizable.
a fixed version of tpmcontract provided in is shown as dashed states and transitions in figure .
however this fixed version still violates the autonomous condition and hence fail the realizability tests used in wsat and tune.
since wsat and tune use sound but incomplete analyses this does not mean that the protocol is unrealizable.
in fact sspcalc computed all ssps for the fixed protocol and found no conflict state.
by corollary this is sufficient to conclude that the fixed version of tpmcontract is realizable a result that cannot be shown by the realizability analyses used in wsat and tune.
another example that causes the realizability conditions used in wsat and tune to generate false positives is the1agency airline askquote c174 agency airline ordertickets c174 airline agency timeout c174 airline agency timeout c174airline agency accepted c174 airline agency rejected c174agency airline ordertickets c1740 figure a portion of the fixed airline protocol from airline example mentioned in where the original protocol deadlocks because of a timeout.
since this timeout can be sent while the agency is sending an order to fix it the protocol must be modified such that both orderings of timeout and order are allowed from a global point of view.
the fixed protocol is shown in figure .
based on the realizability conditions used by wsat and tune this fixed protocol is identified as unrealizable.
however sspcalc correctly identifies the fixed protocol in figure as realizable.
even for the fixed version of the simple file transfer protocol shown in figure 1b wsat and tune generate false positives and report that it is unrealizable whereas sspcalc correctly identifies that it is realizable.
the protocols we discussed above for which the wsat and tune tools report false positives can be characterized asarbitrary initiator protocols definition .a conversation protocol cis an protocol with arbitrary initiator if there exists some state s s peers pi pj pm pnand message labels l l such that both s pi l p j and s pm l pn are defined and pi negationslash pm.
such protocols can be unrealizable since in the same state two different peers can decide to send a message without warning the other of its intent.
yet as we have shown above not every such protocol is unrealizable in fact any conversation protoc ol where some peer can interrupt a sequence of messages sent by another peer exhibits this arbitrary initiator property.
this is the case for the fixed version of the file transfer protocol shown in figure 1b.
this conversation protocol accepts both sequences s c f ands f c which is exactly what its corresponding channel system produces.
therefore it is realizable.
since the initiator of the protocol cannot be guessed by any of the peers the specification compensates by providing an appropriate behavior for both orderings.
in the case of the file transfer protocol this would simply mean that the server accepts but ignores any cancellation messages received after the transfer is finished.
.
related work and discussion the present work can be compared to earlier results on assessing the realizability of conversations with a specia l focus on their behavior on arbitrary initiator protocols.
local enforceability studied in is concerned with finding individual specifications for each communicating peer 34such that their composition produces a predefined set of interactions expressed in a web service choreography language.
however in this approach synchronous communication is used and hence the arbitrary initiator problem does not occur.
message patterns expressed with petri nets using synchronous communication are de synchronized in that is one is interested in finding a specification that produces the same pattern of messages when communications become asynchronous.
this work however already assumes that a conversation protocol is realizable and does not provide realizability conditions.
realizability conditions for conversation protocols in a set of three conditions for conversation protocols is presented which taken together are sufficient to ensure realizability .
synchronous compatible a conversation protocol cis synchronous compatible if every time a peer phas a send transition for some label lto some peer p t h e n p has a receive transition for that same label or should reach such a transition through transitions.
.
autonomous a conversation protocol cis autonomous if each peer at any moment can do only one of the following terminate send a message or receive a message.
.
lossless join if we let c p0 c p p c be the conversation protocol obtained as the cartesian product of each peer projection a conversation protocol cis lossless join if l c l c .
note that the lossless join condition operates on a product of peer projections which is still a conversation protocol and not on the channel system built from these projections.
otherwise the lossless join condition would be equivalent t o strict realizability.
algorithms for checking the above conditions on conversation protocols have been shown in .
the wsat and tune tools we mentioned above implement these algorithms.
while the above conditions allow a sound analysis of many protocols the major drawback comes from the autonomous condition.
in fact the autonomous condition is the exact negation of the definition of an arbitrary initiator protocol.
it follows that this method cannot discriminate between realizable and unrealizable classes of such protocols and immediately labels them as unrealizable.
hence as we discussed above wsat and tune generate false positives for realizable arbitrary initiator protocols as expected.
session types in session types conformance of an interaction with a predefined protocol is analyzed as a typing problem.
intuitively if t1 t2are two types then a type t3 can be built as t1.t2 where the period denotes the sequencing operator.
a global interaction mbetween peers called asession will conform to type t3if it can be divided into a sequence of two interactions m1.m2 such that m1conforms to type t1 a n d m2conforms to type t2.
similar rules can be defined for non deterministic branching conditional branching parallel execution.
the approach in session types is to first devise a global type g to an intended scenario consisting of interacting peers.
different programmers can independently develop portions of this interaction by taking the projection ofgon each of the peers.
if the individual program for each peerpcan be shown to conform to its respective projection ofg noted g p i.e.
if each program is typable then the rules of session types ensure that when the programs are executed they follow the stipulated global scenario.
one can see the immediate parallel between the rationale behind session types and the definition of strict realizability presented in section .
.
more precisely realizability of interactions can be ensured through a type discipline by checking two conditions .
a programmer first describes a scenario as a global typegand checks that it conforms to the so called linearity condition.
.
each component of the interaction is then developed independently and periodically checked to make sure it istypable against the projection of g. if linearity of gand typability of each program is enforced realizability follows.
session types can therefore provide an alternate sound analysis to the realizability conditions d escribed above.
it turns out however that the typing system for session types contains an analogue of the autonomous condition shown above.
more precisely rule if in the type discipline shown in is formulated as follows e bool p q ifethenpelseq intuitively this rule shows that for a branch of the form if ethenpelseq to conform to type bottom part of the rule then emust be of boolean type and both branches pandqmust conform to the same type .
since a type determines the sender and recipient of some communication event it follows that pandqmust have the same sender and recipient no matter what eis.
similar restrictions occur for other forms of branching in the type system.
for example the construct k l1 p1 ln pn called label branching in represents a peer offering over some communication channel k multiple choices p1 ... p nfor the continuation of a session.
the pi need not be of the same type and hence nothing prevents a peer from being alternately a sender and a receiver in some of these choices.
however for such an expression to be typable some other peer must include as its cotype the expressionk l p where the actual choice of label is communicated overk.
this is shown in figure one can see that this no longer represents an arbitrary initiator protocol since the communication of liover channel kis always unidirectional.
basically the session type discipline prevents well typed programs from including arbitrary initiator branching.
hence the realizability of such protocols cannot be established us ing the type rules of session types.
.
conclusion the shared state projections ssp presented in this paper provide a novel and sound approach to determining realizability of message based interactions.
in contrast to earl ier work ssp is based on the intuitive notion that a realizable protocol is a protocol where each peer at any moment should have a clear enough indication of the current state of other peers.
by computing for each state and from each peer s point of view the possible states for other peers in 35ab m1 c174 ba m2 c174ab l1 c174 ab m1 c174ab l2 c174 ba m2 c174 figure arbitrary initiator protocol left and label branching in session types right .
a conversation we have shown that unrealizable protocols can be soundly identified through the identification of disagreements between two peers global states.
the realizability check we developed based on ssp correctly identifies the realizability of a class of protocols called arbitraryinitiator protocols whereas earlier realizability conditio ns always produce false positives for such protocols.
an interesting feature of the ssp approach is that its output is not simply boolean.
while the shared state projections are used to derive a verdict about realizability these models in themselves can be put to other uses.
as we have shown computing the cartesian product of each sharedstate projection yields an over approximation of the original specification.
by removing conflict nodes from this product one obtains a subset of the conversation protocol which is guaranteed to be realizable at no additional cost.
conversely by adding transitions to the original conversation one can convert conflict nodes into correct nodes until no conflict remains the augmented protocol can be seen as a fixed version of the original.
therefore we believe that it would be possible to extend the ssp approach for automaticallyrepairing unrealizable protocols.
.