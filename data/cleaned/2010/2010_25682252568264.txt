hope for the best prepare for the worst multi tier control for adaptive systems nicholas d ippolitoy v ctor braberman?
jeff kramery jeff mageey daniel sykesy sebastian uchitely?
ydepartment of computing imperial college london uk ?departamento de computaci n fcen universidad de buenos aires argentina n.dippolito j.kramer j.magee d.sykes s.uchitel imperial.ac.uk vbraber dc.uba.ar abstract most approaches for adaptive systems rely on models particularly behaviour or architecture models which describe the system and the environment in which it operates.
one of the di culties in creating such models is uncertainty about the accuracy and completeness of the models.
engineers therefore make assumptions which may prove to be invalid at runtime.
in this paper we introduce a rigorous tiered framework for combining behaviour models each with different associated assumptions and risks.
these models are used to generate operational strategies through techniques such controller synthesis which are then executed concurrently at runtime.
we show that our framework can be used to adapt the functional behaviour of the system through graceful degradation when the assumptions of a higher level model are broken and through progressive enhancement when those assumptions are satis ed or restored.
categories and subject descriptors d2.
requirements speci cations general terms design reliability theory keywords adaptive systems controller synthesis planning reliability .
introduction many approaches for adaptive systems make use of various kinds of models both in the design phase and as an explicit artefact used during execution to guide decision making processes.
these models these abstractions are necessarily idealisations of the system or world that they describe created with a certain purpose in mind .
the reasoning behind such idealisation is well understood a complete permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.model would be intractable both to create and to use computationally and moreover there is a tacit understanding that the omitted detail is the very detail which is potentially incompatible with the purpose of the model.
in other words we make simplifying assumptions to ensure that the model supports the purpose we have in mind.
any model then introduces uncertainty and risk into the engineering process.
we cannot be certain that our chosen assumptions are valid and will always hold risking undesirable consequences when the assumptions are broken.
one of the aims behind research in adaptive systems is to mitigate this risk arising from design time uncertainty by making decisions with information available at runtime particularly in di cult unpredictable environments that are liable to change .
in particular certain approaches for adaptive systems use runtime representations of their operating environment and algorithmic techniques e.g.
planning and controller synthesis that can produce from environment models operational strategies for the system to achieve its goals.
such models are idealised because the algorithmic complexity of dealing with a complete model of the real world would be prohibitive in time and space and because stronger assumptions can be relied upon to support more sophisticated system goals.
the stronger the assumptions are the more enhanced functionality can be guaranteed.
conversely very little can be guaranteed in a world where everything can go wrong.
despite the important trade o s involved in xing environment assumptions existing work on adaptive systems proposes designs in which only one environment model is permitted hence xing the level of risk to be taken and the goals that can be achieved.
further the resulting system loses robustness with respect to invalid assumptions when the environment does not behave as assumed either the system fails completely or continues executing but guarantees can no longer be provided.
in this paper we address the general question of how the planning layer in adaptive systems should be designed to support multiple environment models with di erent associated risk and guaranteeable levels of functionality and how such a design can be used to provide graceful degradation and progressive functional enhancement at runtime according to the validity of the assumptions each model makes.
we propose a general multi tier modelling planning and enactment framework for adaptive systems and describe the conditions under which it guarantees graceful degradation and progressive enhancement.
the framework is general inpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
various dimensions.
first it de nes the relations that must hold between tiers without xing the speci c techniques used at each tier to automatically construct goal achievement strategies i.e.
controllers.
secondly it does not x the number of tiers required.
thirdly it supports both statesensing adaptive strategies such as in reactive plans and event sensing strategies such as in or combinations of both.
figure multi tier control problem the key requirements the framework imposes in order to guarantee graceful degradation and progressive enhancement are that see figure i higher level environment models must be simulated by lower level environment models capturing a notion of idealisation of higher level models ii higher level controllers used to achieve enhanced functionality must be simulated by controllers used at lower levels ensuring a consistent overall strategy iii the runtime infrastructure must be capable of detecting when an inconsistency between an environment model in any tier and the runtime environment occurs iv a sound automated replanning procedure for each tier that is expressive enough to deal with the system goals for its tier must be provided allowing progressive system enhancement after inconsistencies have been detected.
the framework s enactment procedure continuously monitors the environment and concurrently executes a stack of controllers giving priority to the controller of the uppermost enabled tier.
it continuously updates the current state of all environment models based on monitored actions and sensed state disabling tiers should an inconsistency be detected.
at any point to improve the provided functionality a replanning attempt may be made for the lowest disabled tier.
based on the current state of the enabled tier immediately below the state of the disabled tier is approximated and an attempt is made to build a controller that will work despite the uncertainty about the current state of the tier.
should a controller exist it is put into the controller hierarchy and the tier is enabled.
in addition to an analytical validation of our approach providing theoretical results for graceful degradation and progressive enhancement we examine feasibility by instantiating the framework with three di erent combinations of goal types and synthesis algorithms.
we show how the additional constraints on synthesis imposed by the framework can be achieved in general from multi tier safety properties and how liveness can also be incorporated.
the last instantiation also shows how very robust techniques such as reactive plans can be combined with less robust but highly expressive memory based synthesis techniques.the rest of the paper is summarised as follows.
a motivating example is discussed in section and background de nitions are given in section .
the framework is presented in section and validation is presented in section .
we then end with a discussion related work and conclusions.
.
motivating example we rst motivate our work by considering the control system for an automated warehouse that ful ls orders consisting of a number of products selected from a wide range stocked by the warehouse.
one or more mobile robots move products from the supplier area into their storage slots and ful l the orders by collecting products into a bag or parcel for delivery to the customer.
complete orders are moved to the delivery area.
suppliers are obliged to supply the warehouse with products but supply issues or demand for some products may mean that the warehouse runs out of stock.
in this case it is permissible that incomplete orders are delivered.
the warehouse is however obliged to store all products that are supplied.
within the warehouse a number of technical issues can arise.
factors such as wheel slip can impact the reliability of robot navigation so that robots may arrive in unintended locations.
in addition the product storage slots can report an erroneous stock level and can jam when depositing an item on a robot.
we wish to build a strategy c3 that guarantees the goal property g3 that the warehouse continually delivers complete orders.
this strategy would involve the robot s visiting all the appropriate storage slots for the products in an order taking an item from those slots taking the complete order to the delivery point and also moving products from the supply area at relevant times to maintain stock.
such a strategy makes various assumptions i all products are eventually in stock ii the storage slots report the correct stock levels and iii do not jam and iv the robot moves reliably to all necessary locations.
the environment usually satis es these assumptions but can win by breaking these assumptions in exhibiting technical problems or by not supplying products.
this will cause c3to fail from time to time.
however there is a weaker goal g2 which is that orders with at least one product in stock are continually delivered.
the strategy c2 for this goal makes weaker assumptions i one product is eventually in stock ii one storage slot reports the correct stock level and iii does not jam and iv the robot moves reliably to all necessary locations.
the environment can however continue to frustrate the system with continual failure of the storage slots or the robot.
there is an even weaker goal g1 that can be maintained with failing storage slots which is that supplied products are moved from the supply area to the storage slots.
the corresponding strategy c1 assumes only that the robot can move reliably between the supply area and the storage slots.
suppose that the system is initially executing strategy c3 and one of its assumptions is violated such that g3cannot be achieved.
a common solution is to monitor the environment and detect when the assumptions are violated .
but what should the system do when a violation is detected?
how can it proceed from its current state?
we would like the system to be designed in such a way that it continues from its current state with a strategy for the weaker g2 or in the worst case ensures g1is maintained until an engineer can resolve the problem.
in other words the functionality689of the system should undergo graceful degradation when environmental assumptions are violated.
in this example the assumptions of c3are likely to hold most of the time and so after a period of degraded functionality we would like the system to attempt to start providing g3again without needing to reset or stop the system completely.
we call this process progressive enhancement .
our objective in this work is to develop an approach for adaptive systems that deals with multiple tiers of goals and assumptions giving multiple tiers of functionality.
.
background we use labelled transition kripke structures to describe behaviour of the environment and the system.
transitions are labelled with names of actions some of which the system can monitor or control.
states have associated propositions which also may be monitored by the system.
definition .
.
labelled transition kripke structure alabelled transition kripke structure ltks ise s a p v s!2p s0 wheresis a nite set of states a ac amis the communicating alphabet which we assume is partitioned into controlled and monitored actions pis a set of propositions s a s is a transition relation v s!2pis a valuation function for states and s0 sis the set of initial states.
a trace of eis s0 s1 wheres0is an initial state of eand for every i we have si i si .
we denote the set of in nite traces ofebytr e .
in order to describe the enactment of controllers in later sections we introduce notation to describe possible updates of the initial state of an ltks definition .
.
ltks updates given an ltks e s a p v s witha ac am we writeeac !
for ac2acif for alls2s0there exists s ac s0 .
otherwise we write eac !.
ifam2amwe overload and write eam !if there iss2s0such that there exists s am s0 .
otherwise we write eam !.
ifea !
fora2athen we writeea !e0when anaaction is taken from all states with outgoing atransitions i.e.
e0 s a p v s0 ands0 fs0j s a s0 s2s0g .
we say that e is consistent with a set of propositions v p denoted ev !
if there is s2s0such thatv s v. we write ev !e0whene0has a reduced set of initial states with respect toebased onv i.e.e0 s a p v s0 where s0 fsjs2s0 v s vg .
definition .
.
parallel composition letm sm am pm m vm sm0 ande se ae pe e ve se0 be ltkss with am am c am mandae ae c ae m. parallel composition kis a symmetric operator such that ekmis the ltks ekm s ae pe v s wheres f se sm 2se smjv sm pe v se pmg s0 f se sm 2sjse2se0 sm2sm0g v se sm vm sm ve se and is the smallest relation that satis es the rules below where 2ae am e !e0 ekm !e0km 2aenamm !m0 ekm !ekm0 2amnae e !e0 m !m0 ekm !e0km0 2ae amwe restrict attention to states in s that are reachable from s0using transitions in .
definition .
.
simulation let be the universe of all ltkss with communicating alphabet a. giveneandfin we say that esimulatesf writtene f when e f is contained in some simulation relation r such that for all 2aand e f 2rwe havee !e0implies that there is f0such thatf !f0 8se2init e0 9sf2 init f0 v0 e se v0 f sf e0 f0 2r.
we are interested in distinguishing controlled from monitored actions and ensuring that when composing ltkss one controller never blocks the other s controlled actions.
this notion captured by interface automata is used here for ltkss.
definition .
.
legal environment given ltkss e andfde ned over communicating alphabets aeandaf that are partitioned into the sets aec aem and afc afm of controlled and monitored actions such that aec afmandafc aem we say that fis a legal environment foreif for all se sf 2ekfit holds that e se aem f sf afcand e se aec f sf afm.
control problems are typically de ned over a simpli ed form of ltks in which the set of propositions is empty.
definition .
.
labelled transition systems alabelled transition system lts is an ltks e s a p v s wherep .
we will sometimes refer to an lts as a tuplee s a s0 .
the problem of controller synthesis is to automatically produce a state machine that restricts the occurrence of actions it controls based on its observation of the actions that have occurred and the propositions it can sense from the current state of the environment so that when deployed in a given environment a given goal holds.
we do not prescribe the logic used to describe goals nor the algorithms used to solve control problems.
hence we simply assume a satisfaction relationj for ltss and the logic used to express goals.
we abuse notation referring to control problems for ltks when we are referring to the control problem resulting from removing state valuations from the ltks.
definition .
.
lts control given a speci cation for an environment in the form of an lts e2 and a goal gexpressed in some logic land a satisfaction relation j l a solution for the lts control problem e he giis a deterministic lts csuch thatcis a legal environment fore ejjcis deadlock free and ejjcj g. .
multi tier control we now de ne a general framework for adaptive systems that supports graceful degradation and progressive enhancement.
we rst explain the framework s preconditions and initialisation procedure and then explain how it is executed and nally discuss more formally its guarantees regarding graceful degradation and progressive enhancement.
a general overview of the framework is given in figure .
the overview is linked to the pseudocode in figure representing the runtime behaviour of the framework by means of the a. .
.mmarkers to aid the reader.
the pseudocode in turn uses de nitions provided in this section.690figure framework .
preconditions and initialisation the framework requires initialisation through human intervention a set of environment models and goals must be provided.
the environment models are expected to be ranked in terms of the degree of idealisation of the environment they represent.
we assume that the environment modelm0is the least idealised model of the environment and require that environment models further up the hierarchy allow strictly less behaviour.
this can be formally captured via a simulation relation mi mjfori j .
note that in order to simplify presentation we require environment models to have the same communicating alphabets partitioned identically into controlled and monitored actions.
in summary the less idealised the environment model is the more behaviour in terms of unexpected actions and nondeterminism may arise.
each tier i n has an associated goal gi to be achieved by the system assuming that the environment conforms to the environment model for that tier mi .
each tier introduces a control problem ei hmi giito be solved.
however there is an additional constraint each controller must be simulated by controllers in lower tiers ci cjfori j .
intuitively this requires that a controller at a higher tier never do something that a controller of a lower tier would not do thus ensuring that if a controller at a higher tier must be stopped because the assumptions for its tier are discovered to not hold decisions made by it up to that point have been consistent with lower tier controllers.
in other words it allows for graceful degradation falling back to lower tier controllers when needed.
the requirement that the controller hierarchy preserve simulation may make solving the set of control problemsei hmi giimore di cult.
in particular the existence of a solution for each eidoes not in general guarantee that there exists a solution for each eithat also preserves simulation between controllers.
in section we discuss how this can be achieved for a variety of controller synthesis and planning algorithms.
note that an alternative na ve requirement would be that higher level goals entail lower level goals gi gjforj i .
however this requirement is too weak as di erent tiers may chose di erent strategies to achieve lower level goals.
we assume that the environment models and goals for tiers tonare provided by engineers.
however tier is set automatically lines and to solve the control problem e0 hm0 trueiwherem0is the most general environment model an ltks where states represent all possible results of sensing the environment and all states are connected for all actions .
m0is guaranteed to simulate any m1manually provided.
the controller c0used to solvee0is the most permissive controller i.e.
one that allows any controlled action at any point in time.
c0is guaranteed to not restrict the possible solutions of e1as it will simulate any controller.
we assume a planning operation line and de nition .
that is executed bottom up through the tiers lines .
the operation attempts to build a controller that solves the control problem in a tier while being simulated by the controller for the tier immediately below.
definition .
.
planning operation the planning operation applied to tier i 0either returns null or a controllercisuch that it is a solution to the control problem ei hmi giiandci ci .
note that the initialise procedure does not require that the planning operation be successful for all tiers line .
it is possible that the system starts in a degraded mode and later and progressively enhances its behaviour as controllers for higher tiers are built.
the algorithm in figure avoids for simplicity explicit treatment of synchronisation between the enactor and planner processes.
we assume an implementation of the planner which minimises the locking time of sso as not to block the enactor s execution.
one such implementation would be thatsis only locked once a viable plan has been built and at the end of the execution of the enactor s while block.
to avoid interference the new controller is inserted only if shas not changed while the planner was computing the controller i.e.
no sensed or actuated actions .
.
framework execution we now describe how the framework is executed.
the key data structure the framework relies upon is called the framework state .
it contains the environment models m0 m n which have their initial states updated as controlled actions are actuated or changes in the runtime environment are sensed.
the structure also contains controllers c0 c n which are used to decide which controlled action to take and whose initial states are also updated.
in addition the data structure records the current functional level q of the system i.e.
the highest level for which the runtime environment is believed to conform to the environment model .
definition .
.
valid framework state we de ne the framework state as a tuple m0 m n c0 c n q where6911initialise m1...mn g1...gn m0 planner.getmodel0 c0 planner.getcontroller0 s m0 m1...mn c0 a q do q cq planner.plan s q l s.setcontroller cq q d while c6 null q n s.setfunclevel q e fork enactor fork planner planner while true q s.getfunclevel if q n mq s.getmodel q mq s.getmodel q states mq .getstatessimulatedby mq if !
states.empty mq .setinitstates states cq planner.plan s q l if cq null s.setcontroller cq q d s.setmodel q mq m s.setfunclevel q enactor while true if s.getfunclevel v runtime.sensestate i s s .
v h if s.getfunclevel am runtime.senseaction i if am6 null s s .
am h else cq s.getcontroller s.getfunclevel ac cq.pickenabledcontaction j if ac6 null runtime.actuate ac k s s .
ac h figure framework s runtime behaviour miare the environment models and ciare the controllers with i n and q n. we say that a framework state is valid with respect to goals g0 g n if for all0 i qthe following hold i ciis a solution to ei hmi gii ii mj mifor0 j i andiii cj ci for0 j i. we say that an framework state is providing functional level iifi q. succinctly the enactment of the controller stack stored in the framework state is performed by executing allcontrollers concurrently whilst prioritising the decision of higher tier controllers.
the enactor executes a loop in which the runtime environment is sensed lines and or actuated upon line and the framework state is updated accordingly lines and .
the framework state update operation s .
x wherex represents either a monitorable action or sensed runtime environment state updates each environment model and controller in the data structure and crucially decrements the functional level qappropriately to capture the highest level for which the sensed behaviour is consistent with the environment model.definition .
.
framework state update lets m0 m n c0 c n q be a valid framework state.
an update ofsforx denoteds .x wherexis an action aor a valuation vis a framework state s0such thats0 m0 m0 n c0 c0 n q0 where q0 qis the largest q0 such thatmq0x !
and where mjx !m0 jandcjx !c0 j for0 j q0 andmj m0 jandcj c0 jforq0 j n. the enactor procedure actually rst senses the runtime environment state and updates the framework state then it senses if any monitorable actions have occurred and updates the framework state.
then if no monitorable actions have occurred it picks a controlled action to actuate.
it is important to note that the controlled action is chosen based on the actions that the controller on tier qallows lines and .
thus priority is given to the highest tier controller for which the corresponding environment model is in a consistent state with the runtime environment.
thus the framework is designed to support situations in which the assumptions made in the various environment models do not hold.
definition .
.
inconsistency aninconsistency occurs when the runtime environment is not simulated by the environment model of tier iand the system is running at a functional level q i. de nition .
detects inconsistency between environment models and runtime environment when i a monitored action occurs for which no outgoing transition from the current mqstate exists i.e.
mi !
or when ii the sensed state v p of the environment is inconsistent with the propositions of the current state of the environment model i.e.
miv !
.
when an inconsistency is detected the enactor will disable the tier by lowering the functionality level to a q0 i and continue executing with a degraded service in which cq0 is used to decide which actions to take and hence only goals up togq0will be guaranteed.
note that as m0andc0are the most general environment and controller models and g0istrue it is always the case that setting q yields a valid framework state.
the proposed framework supports progressive functional enhancement by attempting to create new controllers for tiers above the current functional level q see planner in figure .
the framework does not prescribe when replanning must be attempted.
in principle this can be done at any time however in practice replanning may be associated with a clock or with heuristics related to environment modelling.
one di culty of replanning is that once a tier ihas been disabled i.e.
q i the current state of the environment modelmihas since then not been updated see de nition .
.
thus the current initial state of miis invalid.
this problem is solved by replanning bottom up.
consider the case in which the system is providing functional level i .
in order to replan the current state of the environment according to miis re established using the current state of model mi 1and the fact that mi 1is required to simulate mi.
the planner computes the largest possible initial set of states for misuch thatmi 1simulatesmi lines and .
recall that as tier can never be disabled replanning is always performed for tiers and above.692definition .
.
initial state inference letm s a p v s andnbe environment models.
we say that m0 is the result of inferring the initial states of mbased onn denotedm n ifm0 s a p v s0 is the ltks with the largest set of initial states such that n m. if the initial states for tier ican be inferred from tier i then the planner is used to solve the control problem for levelias in de nition .
line .
if successful the framework state is updated with new versions of miandci lines .
in addition the functional level of the system is incremented by one line .
definition .
.
framework state enhancement lets m0 m n c0 c n q be a valid framework state with q n .
ifm0 q mq mqandc0 q 1are the result of replanning tier q 1for a framework state m0 m0 q m n c0 c n q then state enhancement results in m0 m0 q m n c0 c0 q c n q as indicated above there is no guarantee that the functional level will be enhanced when attempting to replan.
it may be impossible to infer the initial state of the next environment model up or there may not be a solution to the resulting control problem for that tier.
should either be the case the framework state simply remains unchanged and no enhanced functionality is provided.
.
framework properties it is possible to prove that the framework correctly provides graceful degradation and progressive enhancement.
a proof is beyond the scope of this paper however it is relevant to describe the framework s properties the assumptions it relies upon and discuss their implication1.
the key result is stated informally as follows theorem .
.
graceful degradation if the initial framework state has a functional level qand the runtime environment exhibits behaviour consistent with miwithi q i.e.
2tr mi then all goals up to level iare satis ed i.e.
j gjfor all j i .
theorem .
relies mainly on the fact the update operation de nition .
preserves state validity de nition .
and particularly the functional level is set to exclude any higher level controller or environment model that cannot follow the behaviour of the runtime environment.
the key assumption required for the proof is that the framework executes fast enough so as to never block its environment.
in other words we adopt the synchronous hypothesis which is commonplace in literature for reactive systems e.g.
and is appropriate in the context of architecture level adaptation for which this framework is proposed.
progressive enhancement relies on the fact that if the framework state is valid and providing functional level i a successful replanning procedure de nition .
at tier i yields a valid framework state.
the result follows straightforwardly from the de nitions de nition .
and .
.
once replanned theorem .
is applicable from the resulting framework state.
as expected replanning provides guarantees from the point of replanning onwards and not from the start of the execution of the system.
1for the reader s convenience an appendix with more a formal exposition and proof sketch can be found in .
.
validation in this section we aim to show the applicability of our framework by showing that it can support in practice a variety of existing synthesis techniques which di er in terms of expressiveness and robustness.
we do not focus on computational complexity or scalability because beyond the fact that each new tier introduces a further control problem these are properties that emerge from the choice of expressive power of the languages used to express goals at each tier and the corresponding synthesis procedures needed to solve the resulting control problems.
we also aim to show that the additional requirements that the framework imposes chie y the simulation requirement between environment models and between controllers can be accommodated in a systematic and modular way even when the speci c synthesis techniques used were not designed to support these additional requirements.
finally we demonstrate how our framework can provide a rigorous means to endow such synthesis techniques which may not have been developed with adaptive systems in mind with graceful degradation and progressive enhancement.
we discuss three instantiations of the framework and apply them to the problem domain taken from the example in section .
firstly we apply backward propagation to synthesise controllers for three tiers of safety goals where the uppermost is a bounded liveness goal.
we assume no state sensing capabilities the environment models are ltss .
secondly we replace the technique in the uppermost tier with generalised reactivity gr to synthesise a controller for a liveness goal while retaining backward propagation for the safety goals in two lower tiers.
finally we replace the technique in the lowest tier with reactive planning retaining backward propagation and gr for the two other tiers.
reactive planning requires that we allow sensing.
figure transporting products.
the problem domain is as follows figure .
a robot moves between three locations and in certain locations the robot can pick up or put down objects products .
we do not explicitly model the passive objects that picking and putting manipulate.
the robot is capable of sensing whether pick and put actions succeed or fail but it has nocapacity for sensing its location.
we wish to build a controller for this robot that satis es various requirements.
broadly our objective is to have the robot move between locations w ande picking and putting at the appropriate moments.
in addition there are two safety requirements that are aimed at preserving the physical integrity of the robot and the environment i picking should not be performed at putting locations and vice versa and ii the robot should not pick if it is holding a product nor put if it is not holding a product.
the assumptions required to achieve these goals di er.
for example succeeding in transporting products requires reliable move pick and put operations.
avoiding picking at693put locations requires reliable inference of the robot s current whereabouts.
we de ne three tiers of models where the upper tier tier supports our transportation objective and the lower tiers support reduced functionality related to physical safety.
each instantiation is arranged in the same three tiers with some minor adjustments relating to the synthesis technique employed.
although we describe the tiers top down the framework is agnostic as regards methodology.
the designer may start with a realistic model and progressively idealise it bottom up towards satisfying a set of stronger goals or start with a strong goal and progressively weaken it topdown towards something that can be satis ed in more realistic models.
nevertheless as previously noted once the models and goals are in place synthesis happens bottom up.
in all cases we discuss the domain models and goals informally but also accompany these descriptions with finite state processes fsp expressions to describe domain models and safety goals formally and fluent linear temporal logic fltl expressions to formally describe more expressive goals.
note that the fsp and fltl are included only to illustrate the input to the synthesis tools used hence background on these languages is not included.
.
backward propagation in the rst instantiation of the framework we use backward propagation implemented in ltsa to generate controllers for three tiers of safety goals where the goal for the uppermost tier is a bounded liveness property.
the backward propagation algorithm synthesises a controller by removing paths from the domain model lts that lead to the error state.
the error state is introduced by composition of the model with observer automata encoding the safety properties.
the backward propagation technique does not necessarily ensure that individually generated controllers satisfy the simulation requirement of our framework.
thus for each tier of the hierarchy we use the controller generated for the tier below to restrict the domain model through parallel composition.
this ensures that the upper controller does not include any behaviour that is not present i.e.
is unsafe in the lower controllers.
this approach is only complete when using a synthesis technique that guarantees that the generated controllers are maximal that is they contain all strategies for achieving their goal because a non maximal controller would restrict the upper controller more than strictly necessary.
such is the case for safety properties.
.
.
tier model most idealised we start by modelling the problem domain at the most idealised level before considering more realistic models.
the good map is an idealisation of how the environment is expected to behave.
the controlled actions are move pickup andputdown while the other actions indicate how the environment can respond.
in particular moving in some direction east or west is certain to lead to the correct location w m ore .
for example moving east from location wmeans the robot will arrive in location m. in addition pickup andputdown can only succeed in certain locations.
good map arrive map map move arrive map move arrive map putdown putsuccess map pickup fail map map move arrive map move arrive map putdown putfail map pickup fail map map move arrive map move arrive map putdown putfail map pickup success map .
the model of the uncontrolled robot is reused without changes in all tiers.
we compose the map with a simple model of the robot to produce the idealised domain model.
robot move arrive robot pickup success fail robot putdown putsuccess putfail robot .
good domain robot good map .
.
.
tier goals our primary requirement in this scenario is that the robot repeatedly puts and picks.
we encode this as a bounded liveness property and nd a controller using the same mechanism as with the other safety goals.
the overall goal is encoded as boundlive which states that before the current time bound has been reached ended there must have been successful pickup andputdown actions.
the goal relies on the de nition of two uents .
for example been picking becomes true after success and false afterreset .
the count process counts controlled actions up to the speci ed bound maxtime at which point ended must happen.
fluent been picking success reset fluent been putting putsuccess reset fluent ended ended reset ltl property boundlive ended been picking been putting const maxtime count count count cont count count ended reset count count error.
we then synthesise a controller hiding the arrive actions as these are not actions the robot can monitor.
as a result the controller will have to infer the current location from the occurrence of other actions while nonetheless satisfying the goal.
we use the idealised good domain since the bounded liveness goal cannot be achieved in the non ideal domains.
the level2 controller is added to the safety goal to ensure that the level3 controller achieves the goals of and can be simulated by the lower controllers.
level3 safety count running boundlive level2 controller .
deterministic sogd3 good domain level3 safety arrive .
controller level3 controller sogd3 fluents ... controls cont ended .
the controller is then synthesised using an algorithm that performs backward propagation from the error state.
.
.
tier model the next environment model bad map is less idealised and describes the possibility that moving in a certain di 694rection does not always lead to the expected location2.
in this model due to the middle location being sunken moving out of the middle may not be successful and moving into it may lead to an acceleration that makes the robot overshoot its intended location.
later when the arrive action is hidden bad map will have a non deterministic outcome for each move .
the bad domain simulates the good domain as our framework requires.
bad map ... map move arrive map arrive map move ... bad domain robot bad map .
.
.
tier goals the non determinism of robot movements means that eventually reaching either location cannot be guaranteed and thus product transportation cannot be achieved.
however as movements predictably never make the robot go in the opposite direction locations can be su ciently approximated to avoid picking at the put location and vice versa.
fluent at arrive move reset ltl property no pick w pickup !at ltl property no put e putdown !at again we restrict the environment of this controller using the controller from the tier below in order to ensure simulation and we hide arrive actions making move actions non deterministic.
level2 safety no pick w no put e level1 controller .
deterministic sobd2 bad domain level2 safety arrive .
controller level2 controller sobd2 fluents controls cont .
.
.
tier model most realistic the least idealised environment model very bad map allows movements to lead to any location and also includes the possibility that the pickup andputdown actions fail in the locations where they are meant to succeed locations e andwrespectively .
the very bad domain simulates the bad domain .
very bad map ... map move arrive map pickup success fail map ... very bad domain robot very bad map .
.
.
tier goals the tier goal cannot be achieved under the weaker assumptions of tier as location cannot be reliably inferred.
however avoiding picking putting when holding not holding a product is still possible in this harsher environment.
fluent picked success putsuccess ltl property pickonce !
picked pickup ltl property putonce !
!picked putdown alternate pickonce putonce .
having de ned level1 safety goal we can now synthesise a controller that is safe in very bad domain .
2this can be due to wheel slip or in the case of our nao h25 humanoid robot which performs trilateration using visuallyidenti ed landmarks due to camera noise unstable motion and an obscured line of sight.
.
.
degradation enhancement the resulting hierarchy of controllers provides a control system in which the most demanding bounded liveness goal picking and putting can be achieved if the environment encountered at runtime is compliant.
if the runtime environment behaves as the bad domain orvery bad domain the system is nonetheless guaranteed to achieve its safety goals.
in other words the system makes a best e ort given the uncertainty about the runtime environment.
in order to observe how the controller stack operates degrades and enhances its functional level we simulated the composition of enactor s with various environments.
we used a model checker to generate traces that lead to enactor states in which service was degraded.
these traces when the runtime environment is the very bad domain reveal situations where the tier environment is unable to follow.
one such trace is arrive w move e arrive w count move e arrive w count pickup fail.
in this case the tier controller expects that after performing two move e actions that the robot will be in location e and sopickup must succeed.
in fact the non determinism in the very bad domain means that the robot is in location wandpickup must fail.
at this point the enactor disables the level3 controller and continues with level .
at some later stage the enactor may attempt to achieve its level goal again.
interestingly as the initial state of thegood domain is unknown and little can be inferred from the current state of bad domain the resulting controller for tier needs to be quite smart.
in fact replanned controllers for tier try to infer through a series of recovery actions what their current location is before attempting to achieve their goals as they would have having known their current location.
for example the new level controller can start by performing putdown because the success or failure of this action reveals to the controller whether it is in location eor not.
such recovery strategies are built automatically by the planner.
.
generalised reactivity in our second instantiation of the framework we take the three tiers of models as given in instantiation and we change the synthesis technique in tier from backward propagation to gr an expressive subset of linear temporal logic that includes liveness implemented in mtsa .
this technique allows us to specify liveness properties without a bound which may be useful if the bound is unknown and also may be computationally convenient if the bound is known to be high.
on the downside if there is a low bound the additional computational complexity of solving gr goals polynomial against backward propagation linear results in a signi cant overhead.
replacing the bounded liveness goal and backward propagation technique of tier with gr and the mtsa synthesis algorithm is straightforward.
as before the controller for tier is computed based on the composition of good domain and the controller for tier .
this is complete because controllers for tier and are maximal.
we discuss maximality further in section .
.
although gr limits the controllers above the tier in which it is used graceful degradation and progressive enhancement work in the same manner as with backward propagation.
if the level controller throws an exception then execution continues with the level controller.
likewise695when attempting to resume level gr is capable of generating recovery actions from a choice of starting states as happens with backward propagation.
.
reactive planning in our nal instantiation we retain tiers and from the second instantiation and change the synthesis technique in tier from backward propagation to the more robust reactive planning again implemented in ltsa.
although reactive planning uses the same core algorithm as backward propagation for safety properties it di ers in that it envisages a di erent enactment mechanism which in addition to performing controlled actions and monitoring uncontrolled actions also directly senses propositions about the environment to determine the current state.
more speci cally the enactment mechanism we adopt see figure uses sensing to verify that the valuation of sensed variables in the runtime environment not any model matches the valuation in the current inferred model states.
note that this scheme di ers from the traditional reactive plan enactment mechanism which does not retain the model at runtime and consequently is stateless.
in this instantiation we assume that the system rather than sensing the success or failure of pickup andputdown actions can sense if it is holding a product.
thus the resulting controller will be robust to unexpected events such as the accidental dropping of a product or manual intervention placing a product into the robot s hand.
in order to transform our pure lts model for tier into an ltks required to perform reactive planning we must label the states with valuations of the sensed variables.
space limitations prevent us from giving the full details here but the essential aspect is that uents in this case holding are de ned to label the ltks according to what can be sensed.
the enactment mechanism for reactive plans in contrast to backward propagation and gr can raise exceptions in two situations when an unexpected monitored action occurs and when the valuation of sensed variables does not match the valuation of the inferred current state.
when attempting to resume operation in this tier the sensed variables can be used to narrow down the set of possible starting states.
as no actions are performed blindly reactive plan enactment is robust with respect to the unexpected impact of actions on the environment.
the limitation of reactive planning is that the goals which can be achieved without remembering what the system has done are limited.
in contrast the gr technique used in tier infers the state of the world from the history of controlled and uncontrolled actions that have occurred without checking at runtime the correspondence of the inferred state with the runtime state.
such approaches are less robust as they risk taking decisions based on an incorrect assumption about what the current state of the world is.
these two techniques had not up to now been combined even in an ad hoc fashion.
our framework provides a general mechanism for combining these and other techniques and in this particular case results in a hybrid approach that addresses the limitations of both while retaining their strengths.
a critical aspect for the use of reactive planning in our framework is that the underlying ltks rather than a representation in the form of a condition action table is avail able.
this is necessary to restrict the environment of the tier above level so that the controllers meet the simulation requirement.
further e ort may be required to use reactive planning tools e.g.
that do not make this ltks available in our framework.
.
discussion the demonstration shows how our framework can combine synergistically and support the use of di erent controller synthesis and planning techniques particularly to handle graceful degradation and progressive enhancement even when these synthesis techniques were not developed speci cally to address the challenges present in engineering adaptive systems.
it also shows that the construction of the controller stack can be engineered in a modular fashion thereby avoiding an increase of complexity in the synthesis algorithms used in each tier.
the main limitation enforced by the modular bottom up planning procedure is that in order for the approach to be complete the controller for the tier below must be maximal i.e.
encodes all possible strategies for achieving its goal .
this is always possible when the lower tier has a safety property but it is not always possible for liveness goals.
this means that attempting to build a controller on top of one that achieves a liveness goal may fail due to the fact that the strategy used for liveness is inconsistent with the higher tier goal even though a di erent strategy for liveness would have allowed a controller for the higher level goal.
note however that this incompleteness does not mean that tiers cannot be stacked on top of liveness goals.
if the planner can build a controller for the next tier up graceful degradation and progressive enhancement are guaranteed.
although it is likely that in many practical applications safety properties will be expected to be achieved in the lower more robust tiers we believe that more sophisticated complete synthesis techniques will have to be speci cally tailored to allow stacking tiers on top of liveness properties.
the lack of limitations on lower tier safety properties allows exible treatment of di erent kinds of safety properties such as those related to physical integrity of human life of the system itself or other environment agents or required and nice to have properties.
.
related work our work in this paper touches on a range of related topics.
we cannot give an exhaustive list here but in the following we summarise some of the related work.
our work concerns techniques for synthesising behaviour a broad eld that draws from program synthesis e.g.
model driven development e.g planning e.g.
and supervisory control e.g.
.
our framework to be instantiated relies on the extensive work that has been developed in the areas of discrete event planning and supervisory control which has focused on augmenting the expressiveness of goals that can be automatically achieved and the complexity of building strategies for achieving them e.g.
.
we are bound by these results which have been shown to allow application of these techniques in practice e.g.
.
other planning based approaches particularly within the area of adaptive systems include plasma which employs reactive planning for architectural assembly and others that use planning for architecture .696more broadly the central feature of our framework is its ability to deal with enhancement and degradation of functionality when assumptions are broken.
this relies on some means to monitor assumptions as in the work of welsh et al.
and on appropriate recovery action.
in much work e.g.
this consists of switching to redundant alternative implementations of components or applying alternative sequences of actions as in the recent work by carzaniga et al.
.
in the context of behaviour synthesis it can involve rolling back recent actions or generating a new strategy that includes extra recovery actions .
the common theme is however that there is a single requirement to be met whereas we admit the possibility of a range of stronger and weaker requirements cf.
to deal with uncertainty an approach envisaged in the seams roadmap .
degradation and enhancement based on service quality e.g.
has been studied extensively.
notably for adaptive systems ghezzi et al.
mixes design time analysis of a behavioural model with runtime decision making that considers the probability of achieving the system requirements.
when a requirement is under threat a form of graceful degradation is allowed by omission of optional functionality while inclusion could be considered an enhancement .
this approach is in the same spirit as ours in that a mechanism for detecting divergence between the runtime environment and the environment model is in place and replanning mechanisms are used to degrade and enhance.
nonetheless the environment model is structurally xed and only rates and probabilities of transitions are monitored.
our framework could be applied in order to handle violation of functional as opposed to quantitative assumptions.
the notion of replanning as a way of dealing with uncertainty has been studied in the planning community.
for instance in replanning occurs when a plan based on a partial model or a weaker goal is deemed to be improvable through the acquisition of new information.
however the notion of multiple tiers with clear guarantees on the goals achievable at each tier based on the tier s assumptions has not been developed.
runtime monitoring of behaviour models has been studied extensively .
our approach is multi tier and is made possible by having all active controllers execute concurrently.
in contrast in the case when system requirements change is addressed by automatically identifying the states in which it is safe to switch to a new controller.
zhang and cheng verify that manually speci ed transitions between states in the old and new controllers are safe.
our approach was motivated by the desire to avoid setting xed assumptions by adopting a single domain model.
however an alternative to the hierarchy of models we have proposed here is to use feedback from executing the controller to revise the model itself .
two existing approaches our previous work which used inductive learning and that of epifani et al.
which used bayesian estimation took a probabilistic view of the environment and updated those probabilities according to observations such as detected inconsistencies .
the hierarchy of models we propose here could be seen as distinct discretisations of the underlying unknown probabilistic environment model.
this suggests there is fruitful work to be done in combining the approaches for instance by enabling the approach of epifani which cannot alter the structure of the model to switch between structurally di erent models.note that our work is orthogonal to the extensive work on continuous control and planning which also has a place in adaptive systems particularly robotic ones .
continuous control typically establishes a feedback loop where control decisions are made solely based on sensing of the environment s state and are used to achieve short term goals.
hybrid and discrete controllers are typically built on top of these techniques.
in these higher layers the controller can be seen as a feedforward control where it can anticipate the result of controlled actions and hence is able to plan in advance the necessary operations in order to achieve longer term goals e.g.
.
this is also the principle behind the three layer reference model for adaptive system where our work would be situated in the goal management layer.
in the mape k reference model our work would sit in the analyse or plan components.
.
conclusions and future work in this paper we have presented a framework for the planning and enactment layers of reactive systems.
the framework supports simultaneously multiple control problems each with its own set of environment assumptions and goals to be achieved.
these tiers allow the engineering of adaptive systems to deal with multiple levels of risk gracefully degrading services when environment assumptions are found not to hold and progressively enhancing services when possible in the hope that stronger assumptions will hold again.
we have demonstrated how the framework can be instantiated for di erent combinations of properties e.g.
safety and liveness and synthesis algorithms in particular showing that additional constraints introduced by the framework can be systematically addressed and do not introduce further computational complexity.
finally we have demonstrated how the framework can be used to combine synergistically rather di erent approaches such as reactive planning a robust memoryless control approach for safety properties based on state based sensing and gr an expressive non robust memory based approach for liveness properties .
we believe that the framework lays the foundations and opens a research agenda for exploring multi tier control frameworks for adaptive systems.
there are a number of broad avenues of future work that the approach presented in this paper puts forward.
firstly we believe the embedding of the tool chain for the di erent instantiations presented into a real sensing and actuating adaptive system is the next logical step in the evaluation of the approach.
in addition further generalisation is of particular interest.
for instance exploring weaker requirements than a total ordering of environment models e.g.
tree structures should be possible and useful in various settings.
in addition a framework to support both qualitative and quantitative assumptions is essential to integrate much of the work that has been developed for planning and enactment of adaptive systems and also to support more sophisticated adaptive degradation and enhancement.
.