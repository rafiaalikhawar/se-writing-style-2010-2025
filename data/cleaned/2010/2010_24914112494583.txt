extracting urls from javascript via program analysis qi wang1 jingyu zhou1 yuting chen1 yizhou zhang1 jianjun zhao1 1school of software shanghai jiao tong university china 2department of computer science engineering shanghai jiao tong university china 3department of computer science cornell university usa aywq sjtu.edu.cn zhou jy chenyt zhao jj cs.sjtu.edu.cn yizhou cs.cornell.edu abstract with the extensive use of client side javascript in web applications web contents are becoming more dynamic than ever before.
this poses signi cant challenges for search engines because more web urls are now embedded or hidden inside javascript code and most web crawlers are script agnostic signi cantly reducing the coverage of search engines.
we present a hybrid approach that combines static analysis with dynamic execution overcoming the weakness of a purely static or dynamic approach that either lacks accuracy or suffers from huge execution cost.
we also propose to integrate program analysis techniques such as statement coverage and program slicing to improve the performance of url mining.
categories and subject descriptors d. .m miscellaneous general terms design keywords dynamic url javascript program analysis .
introduction javascript is the predominant scripting language used in web browsers which allows programmers to create rich user interfaces and sophisticated functionality for web applications.
a recent study found that all top sites and of top sites use javascript.
unfortunately the ubiquity of javascript along with its dynamic nature is now posing signi cant challenges for web search engines because a large amount of web information including urls is now buried in client side javascript code.
major search engines e.g.
google only analyze the static parts of the html documents and have di culty in indexing scripting parts.
as a result many urls embedded permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.in javascript code are missed which may signi cantly reduce the coverage and quality of a search engine.
client side javascript poses many novel challenges for our analysis.
for example javascript programs exist in the context of an html page and operate in a browser where they interact with html elements and access the browser apis.
program execution is driven by events and accepts asynchronous inputs from the user.
javascript libraries are widely used but often involve tricky coding and are large in size.
it is important to note that javascript can generate script code or inject arbitrary html expressions into the document dynamically making its behavior hard to predict.
a straightforward approach is to employ a browser or a javascript engine to execute javascript programs in html documents instrumenting the engine to output urls encountered during execution.
however a purely dynamic approach like this does not scale well because it can incur prohibitive execution overhead.
another drawback is that only one controlow path is executed possibly missing many urls in other paths.
hence it is natural to enlist the help of static program analysis methods.
however most client side javascript programs use dynamic code generation techniques and often access html dom and browser apis.
static analysis is not able to tackle these dynamic aspects of javascript because some dynamic values can only be determined at run time.
based on these insights we propose an approach that combines static program analysis and dynamic program execution leveraging the advantages of both.
the novelty of our idea can be summarized as follows first we propose an approach that combines static program analysis and dynamic program execution to nd precise url values in client side javascript code.
second we integrate techniques such as statement coverage range analysis and program slicing to further improve the performance of our approach.
the rest of this paper is organized as follows.
section describes our approach in detail.
in section discusses some design decisions.
section discusses the related work.
finally section concludes with future work.
.
approach in detail .
basic workflow our approach combines static analysis and dynamic program execution leveraging the advantages of both.
we use static analysis techniques to reason about control ows of javascript programs and implement a special javascriptpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
figure .
the work ow of our approach.
interpreter to execute javascript code.
fig.
illustrates the work ow of our approach.
for a given web page we rst extract all the code fragments from the html document and assemble them into a complete and compilable javascript code.
then we take the assembled code as input and parse it into an abstract syntax tree ast and then construct a call graph cg using the ast.
a dom tree is also constructed for the html document.
finally we use a lightweight javascript interpreter to simulate javascript executions by traversing the ast.
during execution the interpreter performs di erent actions when visiting various ast nodes to approximate the dynamic behavior and output the urls encountered.
extracting and assembling javascript.
client side javascript code fragments exist in di erent forms and places in an html document.
for statically included javascript code we employ regular expressions to identify and extract them.
dynamically included javascript is handled by the javascript interpreter in later steps of our approach.
sequence of scripts.
a single html document may contain more than one pair of non overlapping script tags.
we assemble all javascript code fragments together and preserve their order in the original html document.
wrapping scripts de ned in html element attributes.
as discussed in javascript code can be embedded in the attribute of an html element.
in fact such a usage signi es a new entry point to the whole program and the execution scope chain that is used to resolve variables includes all dom objects on the path from the html element to the root of the document .
we wrap each piece of this kind of code into a separate function and record the path to the html element as well as the attribute the code resides in.
in this way scripts embedded in html elements can be easily recognized and receive special treatment in execution.
modeling the html dom and bom.
client side javascript uses document object model dom interfaces to manipulate and interact with the html document and uses browser object model bom interfaces to interact with the browser.
urls are often formed via the interaction of these interfaces.
however both the html dom and bom typically are not provided in javascript engines such as chrome v8 and rhino .
as a result only using a javascript engine to analyze these urls becomes impossible.
we have implemented the html dom and bom interfaces in our interpreter to model the host environments.
we de ne a separate class for each type of html dom element and implement properties and methods of each dom element.
execution.
javascript has multiple entry points and browsers execute javascript in an event driven fashion.
it is important to model the fact that load handlers are executed before other kinds of event handlers .
every event handleris an entry point of the program but our analysis cannot predict the exact invocation sequence of event handlers because it involves user interactions.
fortunately the execution order of event handlers seldom a ects the result of url mining in our experience and is not crucial for the precision of a static analysis .
as a result our analysis just randomly picks a sequence and executes it.
algorithm illustrates the execution sequence of our javascript interpreter.
given an ast and a cg the interpreter rst executes the load handlers.
then the interpreter randomly chooses an event handler and executes it.
when executing the interpreter adds dynamically generated event handlers i.e.
via calls to addeventlistener or assignments to event attributes to eh which contains unvisited event handlers.
finally to improve coverage the interpreter executes all functions in cg that have not been visited.
algorithm pseudo code of interpreter s execution.
input the ast ast the call graph cg v f visited functions eh fstatically identi ed event handlers g foreach load handler l2ehdo v isitfunction l eh eh l end for while eh6 do randomly pick a handler lfrom eh v isitfunction l eh eh l end while foreachf2cg getallfunctions nv fdo v isitfunction f end for function visitfunction func v f v f ffuncg execute func eh eh fdynamically identi ed event handlers g end function handling dynamically included code.
the eval function is a popular way to dynamically inject javascript code a study shows of the most popular websites used eval .
during the execution we capture the actual value that is passed to the eval function and then parse the value to build an ast for the dynamically included javascript code.
finally we insert the root of this syntax tree to the current point of the program ast and start traverse on this injected ast.
other eval like functions such as window.settimeout and window.setinterval are handled in the same manner.
if the dynamic code injects external javascript les during execution the interpreter will download these les parse them and add the resulting ast back.
.
further improvement to further improve coverage and performance we integrate several techniques to the execution process of our approach.628we gave a preliminary result of some of these techniques in .
statement coverage.
a problem with purely dynamic execution is that they can execute only one path of the program.
in order to improve the execution coverage we implemented a statement coverage technique .
speci cally at run time before the interpreter returns the results of executing a branch structure e.g.
if then else the interpreter is forced to execute other unvisited branches in cloned context scopes.
the code below shows an example that improving statement coverage is bene cial to mining more urls.
the recommend variable contains the url string.
assuming today is tuesday the else branch of the ifstatement is taken.
as a result recommend s value becomes string weekdayrec.asp and we nd one url.
with statement coverage another url can be found on the other branch of the ifstatement.
var recommend var today new date if today today recommend weekendspecial.asp else recommend weekdayrec.asp document.write a href recommend today a when execution reaches the ifast node the interpreter makes a clone of the current scope which records variables declared and variables de ned together with their values at that point of execution.
after executing the else branch the interpreter records the execution result and then forces to execute the then branch in the cloned scope.
when statements in both branches are visited the interpreter returns the execution result recorded to the upper ast node.
in addition to if then else other control ow structures including switch case forloop for in loop while loop do while loop and try catch finally as well as conditional expressions are handled in similar ways.
note that we do not intend to achieve high path coverage which is too expensive to use.
a relatively high statement coverage is su cient enough for our url mining task.
range analysis.
a simple range analysis can be helpful sometimes.
take the code below for an example.
because there is no de nition to hrsfrom the condition of the if statement to the use of hrs it can be inferred that the variable hrscan have integer values ranging from to at the program spot images .
therefore by applying range analysis we can nd more urls in this case.
var hrs new date .gethours if hrs hrs window.open images entry images else window.open images entry defaultindex data types of number boolean and string are also candidates for range analysis.
program slicing.
a great deal of client side javascript code is concerned with presentation details.
in nding urls in client side javascript programs it is a good idea to concentrate our e ort only on program portions where urls are bound to occur.
if we could safely determine using syntactic criteria which code is irrelevant to our analysis we could skip a large volume of it.
this would give us the scalability we will need as client side javascript programs grow in size and complexity.
based on this observation we perform slicing on javascript programs to remove url irrelevant code thus reducing the size of code to be executed.
in the context of this work a slicing criterion is a javascript statement that contains a variable whose value is a url string.
in we give a taxonomy of url relevant program points in a clientside javascript program.
according to the categorization we traverse the ast and identify seed statements for slicing.
supporting common javascript libraries.
javascript libraries are often large in size and use unusual coding tricks which make the analysis di cult and imprecise.
we deal with common javascript libraries such as jquery prototype and yui in a di erent way.
rather than analyzing and executing the code of a common javascript library we identify urlrelevant points in the library apis and de ne matching rules for them.
if a certain kind of library is identi ed the matching rules for the library will be checked when a function call or an assignment occurs.
this strategy reduces more than of the javascript code to be analyzed and saves half of the network time to download them .
take jquery as an example.
the following gives syntax of two jquery apis that indicate the occurrence of urls or dynamically injected htmls.
dom elem id .attr src url dom elem id .html html the matching rules for the above jquery apis are .attr src url .html html in the matching rule syntax urland html are keywords indicating the occurrence of a url or a piece of html code.
represents the value of the rst argument and so forth.
src de nes a constraint that the value of the rst argument must equal to the string value src .
.
design decisions we have decided to develop a lightweight javascript interpreter rather than instrumenting or modifying a javascript engine or a browser engine for several reasons.
first to support statement coverage and value range analysis we designed the value of a variable in our interpreter to be a set i.e.
a variable is allowed to have multiple distinct values at a time instead of strictly being a value.
operations on a variable are performed on each value in the variable s value set.
take the following code as an example.
var course code ...... coursecode course code location.href coursecode supposing somehow from previous analysis we determine variable course can be string value cs or se and variable code can be number value 101or201 then the value ofcoursecode is string concatenations between elements of the two sets which will yield a new value set containing of string values cs101 cs201 se101 se201 .
however such design would require substantial changes if it is applied on existing javascript or browser engines.
second implementing a javascript interpreter allows us to manipulate the control ow in the execution to implement the statement coverage mechanism as described in section .
.
third a self implemented interpreter gives us the exibility to incorporate program slicing and to support javascript libraries via matching rules section .
.629nevertheless instead of building a javascript interpreter from scratch our interpreter is implemented as a wrapper of rhino and closure compiler .
.
related work string analysis such as is a particular form of program analysis to infer string values arising at run time.
di erent with their purpose to detect potential security vulnerabilities using static approach to approximate strings our analysis needs to compute the concrete value of potential urls which relies more on dynamic execution to tackle the dynamic nature of javascript.
redirection spam detection also tries to nd urls.
in text based pattern matching is used to detect changes tolocation object.
later chellapilla et al.
summarized techniques of javascript based redirection.
thomas et al.
used redirection as a feature to detect spam urls where instrumented firefox browser is employed.
as we show in text based approach leads to many false positives and using a real browser su ers from huge execution cost.
our approach can be used as a lightweight alternative to detect javascript redirections.
several recent work focuses on crawling ajax contents where a browser engine is used to execute javascript.
our work instead focuses on nding all urls in javascript including those used in ajax communication.
our work can be extended to record ajax contents for these crawlers.
to detect drive by download attacks the wepawet tool instruments the javascript interpreter to keep track of all functions.
when the execution nishes wepawet forces the execution of functions that have not been invoked.
our approach not only executes all functions but also uses the statement coverage technique to cover all branches .
.
conclusion and future work by combining static program analysis and dynamic program execution our approach interprets only as much of the javascript code as needed to compute the urls and explores multiple execution paths simultaneously to shorten the execution time needed achieving high accuracy and improving coverage and performance.
this approach can not only be applied to web crawlers to improve their coverage but also be used for other applications such as url ltering or redirection spam detection.
there are several remaining challenges.
for example how to deal with compressed and obfuscated javascript code and how to make our method reliable across di erent versions of javascript libraries.
another challenge is how to design an e cient slicing algorithm for our purpose.
.