test generation through programming in udita milos gligoric university of illinois urbana il usa gliga illinois.edutihomir gvero ecole polytechnique f ed erale lausanne switzerland tihomir.gvero epfl.chvilas jagannath university of illinois urbana il usa vbangal2 illinois.edu sarfraz khurshid university of texas austin tx usa khurshid ece.utexas.eduviktor kuncak ecole polytechnique f ed erale lausanne switzerland viktor.kuncak epfl.chdarko marinov university of illinois urbana il usa marinov illinois.edu abstract we present an approach for describing tests using nondeterministic test generation programs .
to write such programs we introduce udita a java based language with non deterministic choice operators and an interface for ge nerating linked structures.
we also describe new algorithms that generate concrete tests by efficiently exploring the spa ce of all executions of non deterministic udita programs.
we implemented our approach and incorporated it into the official publicly available repository of java pathfind er jpf a popular tool for verifying java programs.
we evaluate our technique by generating tests for data structures refactoring engines and jpf itself.
our experiments show that test generation using udita is faster and leads to test descriptions that are easier to write than in previous frameworks.
moreover the novel execution mechanism of udita is essential for making test generation feasible.
using udita we have discovered a number of bugs in eclipse netbeans sun javac and jpf.
categories andsubject descriptors d. .
testing and debugging general terms languages verification keywords automated testing test generation test filtering test pr edicates test programs udita java pathfinder pex .
introduction testing is the most widely used method for detecting software bugs in industry and the importance of testing is growing as the consequences of software bugs become more severe.
testing tools such as junit are popular as they aupermission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
icse may cape town south africa copyright acm ... .
.tomate text execution .
however widely adopted tools offer little support for test generation .
manual test generation is time consuming and results in test suites that have poor quality and are difficult to reuse.
this is especially the case for code that requires structurally complex test inputs fo r example code that operates on programs e.g.
compilers interpreters model checkers or refactoring engines or o n complex data structures e.g.
container libraries .
recent techniques aim to reduce the burden of manual testing using systematic test generation based on specifica tions or on symbolic execution and its hybrids with concrete executions .
moder n hybrid symbolic execution techniques can handle advance d constructs of object oriented programs but practical app lication of these techniques were largely limited to testing units of code much smaller than hundred thousand lines or generating input values much simpler than representations of java programs.
the inherent requirement for not only building path conditions albeit with partial constraints but also determining their feasibility poses a key challeng e for scaling to structurally complex inputs and entire systems.
automatically handling programs of the complexity of a compiler remains challenging for current systematic approaches.
our approach is to allow testers to utilize their domain knowledge to scale these systematic approaches.
we propose a new technique to generate a large number of complex test inputs by allowing the tester to write a test generation program in udita a java based language with non deterministic choices including choices used to gene rate linked data structures.
each execution of a test generation program generates one test input.
our execution engine systematically explores all executions to generate inputs for bounded exhaustive testing that validates the code under test for all test inputs within a given bound e.g.
all trees with up to nnodes .
udita thus enables testers to avoid manual generation of individual tests.
however our approach does not attempt to fully automatically identify tests because such approaches do not provide much control to the tester to encode their intuition.
instead we provide testers with an expressive language in which they have sufficient control to define the space of desired tests.
this paper makes several contributions.
new language for describing tests we present udita a language that enhances java with two important extensions.
the first extension are non deterministic choice commands and the assume command that partially restricts these choices.
these constructs are familiar to users of model checkers such as java pathfinder jpf .
thanks to the built in non determinism writing a test generation program from which many test inputs can be generated is often as simple as writing java code that generates oneparticular test input.
the second extension is the object pool abstraction that allows the tester to control generation of linked structures with any desired sharing pattern s including trees but also dags cyclic graphs and domainspecific data structures.
due to its expressive power udita enables testers to write test generation programs using any desirable mixture of two styles filtering also previously called declarative and generating also previously called imperative whereas previous s ystems required the use of only one style.
new test generation algorithms we present efficient techniques for test generation by systematic execution of non deterministic programs.
our techniques build on systematic exploration performed by explicit state mod el checkers to obtain the effect of bounded exhaustive testing .
the efficiency of our techniques is based on a general principle of delayed choice i.e.
lazy nondeterministic evaluation .
the basic delayed choice te chnique postpones the choices for each variable until it is firs t accessed.
the more advanced copy propagation technique further postpones the choices even if the values are being copied.
like lazy evaluation our techniques guarantee tha t each non deterministic choice is executed at most once.
our techniques support primitive fields but are particularly well suited for linked structures section .
.
the techniques use a new object pool abstraction.
we postpone the choice of object identity until object s first non copy u se reducing the amount of search.
furthermore we avoid isomorphic structures which gives another source of exponential performance improvement.
finally to determine the feasibility of symbolic fresh object constraints in the current path we use a new polynomial time algorithm figures 10and11 which is in contrast to np hard constraints in traditional symbolic execution .
implementation we describe an implementation of udita and our optimizations on top of jpf a popular model checker for java which makes it easy to provide udita as a library.
our code is publicly available .
evaluation we have performed several sets of experiments to evaluate udita mostly for black box testing.
the first set of experiments on six data structures shows that our optimizations improve the time to generate test inputs up to a given bound.
thesecond set of experiments is on testing refactoring engines which are software development tools that take as input program source code and refactor transform it to change its design without changing its behavior .
modern ides such as eclipse or netbeans include refactoring engines for java.
a key challenge in testing refactoring engines is generating input programs.
figures 5and6show some example programs with multiple inheritance that revealed bugs in eclipse.
to generate such programs we need to both generate inheritance graphs and add methods in the classes and interfaces in the graphs.
our experience wit h udita s combined filtering generating style shows that compared to our prior approach astgen udita is more expressive resulting in shorter and easier to write class ig node nodes intsize static class node node supertypes boolean isclass figure a representation of inheritance graphs test generation programs with sometimes faster generation even on a slower jpf virtual machine .
through these experiments we revealed four bugs in eclipse and netbeans all four have been confirmed by developers and assigned to be fixed and even two bugs in the sun java compiler.
thethird set of experiments on testing parts of the udita implementation revealed several new bugs in jpf and one bug in our jpf extension that we subsequently corrected.
these results suggest that udita is effective in helping detect real bugs in large code bases.
thefourth set of experiments for white box testing compared udita with pex a state of the art testing tool based on symbolic execution.
our results found that object pools are a powerful abstraction for guiding explorati on orthogonal to the path bounding approaches used by tools such as pex.
in particular even a naive implementation of object pools helped pex enumerate structures and find bugs faster .
our experimental results are publicly available .
additional details are provided in a technical report .
.
example to illustrate udita we consider generation of inheritance graphs for java programs.
such generation helps in testing real world applications including compilers interpr eters model checkers and refactoring engines section .
the example illustrates how udita can describe data structures with non trivial invariants.
figure 1shows a simple representation of inheritance graphs in java.
a graph has several nodes.
each node is either a class or an interface and has zero or more supertypes that are classes or interfaces.
we do not explicitly model the java.lang.object class.
specification of inheritance graphs.
each inheritance graph needs to satisfy the following two properties dag directed acyclic graph the nodes in the graph should have no directed cycle along the