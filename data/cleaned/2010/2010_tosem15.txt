a understanding integer overflow in c c will dietz university of illinois at urbana champaign peng li and john regehr university of utah vikram adve university of illinois at urbana champaign integer overflow bugs in c and c programs are difficult to track down and may lead to fatal errors or exploitable vulnerabilities.
although a number of tools for finding these bugs exist the situation is complicated because not all overflows are bugs.
better tools need to be constructed but a thorough understanding of the issues behind these errors does not yet exist.
we developed ioc a dynamic checking tool for integer overflows and used it to conduct the first detailed empirical study of the prevalence and patterns of occurrence of integer overflows in c and c code.
our results show that intentional uses of wraparound behaviors are more common than is widely believed for example there are over distinct locations in the spec cint2000 benchmarks where overflow occurs.
although many overflows are intentional a large number of accidental overflows also occur.
orthogonal to programmers intent overflows are found in both well defined and undefined flavors.
applications executing undefined operations can be and have been broken by improvements in compiler optimizations.
looking beyond spec we found and reported undefined integer overflows in sqlite postgresql safeint gnu mpc and gmp firefox llvm python bind and openssl many of these have since been fixed.
categories and subject descriptors d. .
language constructs and features d. .
general standards d. .
testing and debugging diagnostics d. .
software program verification validation general terms experimentation languages measurement performance additional key words and phrases integer overflow integer wraparound undefined behavior .
introduction integer numerical errors in software applications can be insidious costly and exploitable.
these errors include overflows value losing conversions e.g.
a truncating cast of an int to a short in c that results in the value being changed and illegal uses of operations such as shifts e.g.
shifting a value in c by at least as many positions as its bitwidth .
we refer to all these types of errors collectively as overflow errors.
these errors can lead to serious software failures e.g.
a truncation error on a cast of a floating point value to a bit integer played a crucial role in the destruction of ariane flight in .
these errors are also a source of serious vulnerabilities such as integer overflow errors in openssh and firefox both of which allow attackers to execute arbitrary code.
in their report mitre places integer overflows in the top most dangerous software errors .
detecting integer overflows is relatively straightforward by using a modified compiler to insert runtime checks.
however reliable detection of overflow errors is surprisingly difficult because overflow behaviors are not always bugs.
the low level nature of c and c means that bit and byte level manipulation of objects is commonplace the line between mathematical and bit level operations can often be quite blurry.
wraparound behavior using unsigned integers is legal and well defined and there are code idioms that deliberately use it.
on the other hand c and c have undefined semantics for signed overflow and shift past bitwidth operations that are perfectly well defined in other languages such as java.
c c programmers are not always aware of the distinct rules for signed vs. unsigned types and may na vely use signed types in intentional wraparound operations.2if such uses were rare compiler based overflow detection would be a reasonable way to detect integer overflow errors.
if it is not rare however such an approach would be impractical and more sophisticated techniques would be needed to distinguish intentional uses from unintentional ones.
1this is an extended version of a paper that was presented at the 34thinternational conference on software engineering icse zurich switzerland june .
2in fact in the course of our work we have found that even experts writing safe integer libraries ortools to detect integer errors sometimes make mistakes due to the subtleties of c c semantics for numerical operations.
acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
although it is commonly known that c and c programs contain numerical errors and also benign deliberate use of wraparound it is unclear how common these behaviors are and in what patterns they occur.
in particular there is little data available in the literature to answer the following questions how common are numerical errors in widely used c c programs?
how common is use of intentional wraparound operations with signed types which has undefined behavior relying on the fact that today s compilers may compile these overflows into correct code?
we refer to these overflows as time bombs because they remain latent until a compiler upgrade turns them into observable errors.
how common is intentional use of well defined wraparound operations on unsigned integer types?
although there have been a number of papers on tools to detect numerical errors in c c programs no previous work we know of has explicitly addressed these questions or contains sufficient data to answer any of them.
the closest is brumley et al.
s work which presents data to motivate the goals of the tool and also to evaluate false positives invalid error reports due to intentional wraparound operations.
as discussed in section that paper only tangentially addresses the third point above.
we study all of these questions systematically.
this article expands upon our previous work making the following primary contributions first we developed integer overflow checker ioc an open source tool that detects both undefined integer behaviors as well as well defined wraparound behaviors in c c programs.3second we present the first detailed empirical study based on spec spec and a number of popular open source applications of the prevalence and patterns of occurrence of numerical overflows in c c programs.
part of this study includes a manual analysis of a large number of intentional uses of wraparound in a subset of the programs.
third we used ioc to discover previously unknown overflow errors in widely used applications and libraries including sqlite postgresql bind firefox openssl gcc llvm the safeint library the gnu mpc and gmp libraries python and php.
a number of these have been acknowledged and fixed by the maintainers see section .
in addition this article makes the following new contributions first we conducted a new largescale experiment in which we automatically tested for overflows in of the top debian packages.
we found that of these packages triggered an overflow during execution of their test suites and invoked overflows with undefined semantics.
these results provide strong new evidence that a substantial fraction of arbitrary c c software packages including many well tested ones contain serious overflow errors.
second we improved ioc by implementing and evaluating recoverability and two optimizations described in section .
.
third we integrated ioc into mainline clang a widely used production c c compiler e.g.
it is the primary system compiler c c compiler on mac os and ios .
the features of ioc are available via the fsanitize family of options e.g.
fsanitize integer and fsanitize shift .
this deployment led to improvements in diagnostics and the addition of new features such as error deduplication to meet user needs.
we describe this experience in section contributing the discussion of our end to end development of an effective bug detection tool that can now be easily used by llvm clang users.
fourth this article contains additional discussion of relevant details including hardware support for integer arithmetic section language rules governing implementation defined behavior section .
and an explanation of the usual arithmetic conversions section .
.
fifth we evaluated the performance overhead imposed by ioc under different checking policies on integer intensive cpu benchmarks as well as security sensitive server software.
these results are presented in section .
3ioc is available as part of the production version of the clang compiler for c c as of version .
.
usage information and list of available checks available at .
the original ioc as described in section is also available at .
acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a the key findings from our study of overflows are as follows.
first all four combinations of intentional and unintentional well defined and undefined integer overflows occur frequently in real codes.
for example the spec cint2000 benchmarks had over distinct occurrences of intentional wraparound behavior for a wide range of purposes.
some uses for intentional overflows are well known such as hashing cryptography random number generation and finding the largest representable value for a type.
others are less obvious e.g.
inexpensive floating point emulation negation of intmin and even ordinary multiplication and addition.
we present a detailed analysis of examples of each of the four major categories of overflow.
second overflow related issues in c c are very subtle and we find that even experts get them wrong.
for example the latest revision of firefox as of sep contained integer overflows in the library that was designed to handle untrusted integers safely in addition to overflows in its own code.
more generally we found very few mature applications that were completely free of integer numerical errors.
this implies that there is probably little hope of eliminating overflow errors in large code bases without sophisticated tool support.
however these tools cannot simply distinguish errors from benign operations by checking rules from the iso language standards.
rather tools will have to use sophisticated techniques and or rely on manual intervention e.g.
annotations to distinguish intentional from unintentional overflows.
.
hardware integer arithmetic integer overflow bugs in c and c find their roots in features and limitations of the underlying hardware platform.
on modern processors an n bit unsigned integer is represented in such a way that its value is n i 0xi2i where xiis the value of the ith bit.
the range of an n bit unsigned integer is 2n .
signed integers on all modern platforms use a two s complement representation where the value of an integer is xn 12n n i 0xi2i an advantage of two s complement is that signed and unsigned addition can be performed using the same operation.
the same is true for subtraction and multiplication.
historically this was advantageous because fewer instructions needed to be implemented.
also unlike the ones complement andsign magnitude representations two s complement has only one representation for zero.
a drawback of two s complement is that its range 2n 2n is asymmetric.
thus there is a representable value 2n that does not have a representable additive inverse a fact that programmers can and do forget.
when an n bit addition or subtraction operation on unsigned or two s complement integers overflows the result wraps around effectively subtracting 2nfrom or adding 2nto the true mathematical result.
equivalently the result can be considered to occupy n bits the lower nbits are placed into the result register and the highest order bit is placed into the processor s carry flag.
unlike addition and subtraction the result of an integer multiplication can wrap around many times.
consequently a processor typically places the result of an n bit multiplication into a location that is nbits wide such as a pair of registers.
division instructions commonly have an analogous structure where the dividend is nbits wide the divisor is nbits and the quotient and remainder are both nbits.
two s complement division unlike addition subtraction and multiplication is not performed by the same operation as unsigned division of the same width.
for example the x86 architecture has both the idiv instruction for two s complement integer division and div for unsigned integer division.
acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
table i. examples of c c integer operations and their results expression result uint max long max undefined intmax undefined shrt max shrt max ifintmax shrt max otherwise undefined char c char max c varies1 int min undefined2 char int max commonly undefined commonly intminin ansi c and c undefined in c99 and c undefined3 undefined intmin undefined in c11 otherwise undefined in practice 1the question is does cget promoted to int before being incremented?
if so the behavior is well defined.
we found disagreement between compiler vendors implementations of this construct.
2assuming that the inttype uses a two s complement representation 3assuming that the inttype is bits long processors intended for digital signal processing including dedicated dsps and also simd extensions to general purpose processors support saturating semantics for overflowing integer operations.
saturating arithmetic never wraps around but rather sticks at the maximum or minimum representable value.
in some domains saturation is a reasonable solution to the problem of integer overflow but since saturating semantics are not used by c or c we will not consider it further.
processor level left shift instructions typically place zeros into vacated bit positions.
right shift instructions come in logical and arithmetic varieties where a logical shift places zeros into vacated bit positions and an arithmetic shift fills vacated bits with the value contained in the unshifted most significant bit in order to avoid changing the sign of a two s complement integer.
finally many architectures support rotate instructions that treat the value being shifted as a circular buffer bits that fall off one end of the register are used to fill in vacated bit positions at the other end.
rotating semantics are not available to c c programs and we will not consider them further.
.
integer arithmetic in c and c there is tension in the design of c and c between the desire for portability on one hand and the desire for highly predictable and efficient execution of low level code on the other hand.
therefore in spite of c s reputation for being a simple portable assembly language its integer semantics are quite different from those provided by real assembly languages.
the same is true of c .
the most important differences include the following many integer operations are not entirely portable across platforms due to implementation defined behaviors .
c c perform pervasive implicit conversions between bitwidths and between signed and unsigned types.
a number of arithmetic operations have undefined behavior .
since the carry and overflow flags are not exposed in the language it is not straightforward for programmers to write code that detects overflow before or after it happens.
the rest of this section explores the consequences of the first three of these issues the last is discussed in section .
.
table i contains some concrete examples of the results of evaluating some c c expressions.
acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a .
.
implementation defined behaviors an implementation defined behavior in c c is one where individual implementations are given freedom to make a choice but this choice must be consistent and documented.
a few of c c s integer related implementation defined behaviors would break most non trivial c programs if they deviated from the expected values given in parentheses the number of bits in a byte eight the representation used for signed integers two s complement the result of converting an integer typed value into a narrower signed integer typed value where the value cannot be represented in the new type truncation with the potential for converting a positive number into a negative number the result of performing a bitwise operation on values with signed integer types it is as if the operands were converted to unsigned integers of the same width the bitwise operation was performed on them and the result was cast back to the signed type other behaviors do tend to vary across platforms and compilers.
these include the signedness of thechar type and the size of the short int and long types expressed as a multiple of the size of achar .
the inttype in c99 is not required to hold values in excess of .
.
.
the usual arithmetic conversions most integer operators in c c require that both operands have the same type and moreover that this type is not narrower than an int.
the collection of rules that accomplishes this is called the usual arithmetic conversions .
the full set of rules encompasses both floating point and integer values here we will discuss only the integer rules.
first both operands are promoted if an intcan represent all values of the original type the value is converted to an int otherwise it is converted to an unsigned int .
these are called the integer promotions.
all other types are unchanged by the integer promotions.
if the promoted operands have the same type the usual arithmetic conversions are finished.
if the operands have different types but either both are signed or both are unsigned the narrower operand is converted to the type of the wider one.
if the operands have different types and one is signed and the other is unsigned then the situation becomes slightly more involved.
if the unsigned operand is narrower than the signed operand and if the type of the signed operand can represent all values of the type of the unsigned operand then the unsigned operand is converted to signed.
otherwise the signed operand is converted to unsigned.
these rules can interact to produce counterintuitive results.
consider this function int compare void long a unsigned b return a b for a c c implementation that defines long to be wider than unsigned such as gcc for x8664 this function returns zero.
however for an implementation that defines long andunsigned to have the same width such as gcc for x86 this function returns one.
the issue is that on x86 the comparison is between two signed integers whereas on x86 the comparison is between two unsigned integers one of which is very large.
some compilers are capable of warning about code like this.
.
.
unsigned overflow according to the c99 standard acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
a computation involving unsigned operands can never overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.
thus the semantics for unsigned overflow in c c are precisely the same as the semantics of processor level unsigned overflow as described in section .
as shown in table i uint max must evaluate to zero in a conforming c and c implementation.
unsigned overflow tends to lead to two kinds of problems in c c programs.
first it is often the case that developers are simply not expecting values to overflow.
for example one of the infamous therac bugs occurred when an bit variable which used a nonzero value to signal an error wrapped around to zero causing a crucial checking function to be bypassed.
second since the sizes of integer types are implementation defined overflow will occur at different values on different platforms.
for example gcc evaluates 0ul to on x86 and to on x86.
.
.
signed overflow and other undefined behaviors if a signed arithmetic operation overflows for example by evaluating intmax the behavior of the c implementation is undefined .
according to the c99 standard undefined behavior is behavior upon use of a non portable or erroneous program construct or of erroneous data for which this international standard imposes no requirements.
in internet parlance when the compiler encounters it is legal for it to make demons fly out of your nose.
other operations with undefined behavior include shifting a value by at least as many bit positions as the bitwidth of the promoted type of the operand shifting by a negative number of bit positions and division by zero.
undefined behavior represents a significant departure from the semantics of processor level operations and our experience is that many developers fail to appreciate the full consequences of this.
the rest of this section examines these consequences.
.
.
.
silent breakage.
a c or c compiler may exploit undefined behavior in optimizations that silently break a program.
for example a routine refactoring of google s native client software accidentally caused to be evaluated in a security check.5the compiler at this point under no particular obligation simply turned the safety check into a nop.
four reviewers failed to notice the resulting vulnerability.
another illuminating example is the code in listing .
in this program the same computation int max int max is performed twice with two different idioms.
recent versions of gcc llvm and intel s c compiler invoked at the o2 optimization level all print a zero for the first value line and a one for the second line .
in other words each of these compilers considersintmax to be both larger than intmaxand also not larger at the same optimization level depending on incidental structural features of the code.
the point is that when programs execute undefined operations optimizing compilers may silently break them in non obvious and not necessarily consistent ways.
.
.
.
time bombs.
undefined behavior also leads to time bombs code that works under today s compilers but breaks unpredictably in the future as optimization technology improves.
the internet is rife with stories about problems caused by gcc s ever increasing power to exploit signed acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a 1int foo int x 2return x x 5int main void 6printf d n int max int max 7printf d n foo int max 8return listing source for overflow.c referred to in the text overflows.
for example in a principal postgresql developer was annoyed that his code was broken by a recent version of gcc it seems that gcc is up to some creative reinterpretation of basic c semantics again specifically you can no longer trust that traditional c semantics of integer overflow hold ... this highlights a fundamental and pervasive misunderstanding the compiler was not reinterpreting the semantics but rather was beginning to take advantage of leeway explicitly provided by the c standard.
in section .
we describe a time bomb in safeint a library that is itself intended to help developers avoid undefined integer overflows.
this operation had been compiled by gcc and other compilers into code that behaved correctly.
however a subsequent version of gcc .
exposed the error presumably because it optimizes the code more aggressively.
we discovered this error using ioc and reported it to the developers who fixed it within days .
.
.
.
illusion of predictability.
some compilers at some optimization levels have predictable behavior for some undefined operations.
for example at low optimization levels c and c compilers typically give two s complement semantics to signed overflows.
it is however very unwise to rely on this as the behavior can change when the compiler the compiler version or the compiler flags are changed.
.
.
.
informal dialects.
some compilers support stronger semantics than are mandated by the standard.
for example both gcc and clang support a fwrapv command line flag that forces signed overflow to have two s complement behavior.
in fact the postgresql developers responded to the incident above by adding fwrapv to their build flags.
they are now in effect targeting a non standard dialect of c. .
.
.
non standard standards.
some kinds of overflow have changed meaning across different versions of the standards.
for example is implementation defined in ansi c and c while being explicitly undefined by c99 and c11 assuming bit ints .
our experience is that awareness of this particular rule among c and c programmers is low.
a second kind of non standardization occurs with constructs such as intmin which is by our reading well defined in ansi c c99 c and c .
however we are not aware of a c or c compiler that reliably returns the correct result zero for this expression.
the problem is that on architectures including x86 and x86 correctly handling this case requires an explicit check in front of every operation compiler vendors are unwilling to impose this overhead on their acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
front end back end executioninstrumentation runtimeioc source checked ir executable fig.
.
architecture of ioc users.
the c standards committee has recognized the problem and c11 explicitly makes this case undefined.
.
tool design and implementation ioc depicted in fig.
has two main parts a compile time instrumentation transformation and a runtime handler.
the transformation is a compiler pass that adds inline numerical error checks it is implemented as a loc extension to clang the c c frontend to llvm .
ioc s instrumentation is designed to be semantically transparent for programs that conform to the c or c language standards except in the case where a user requests additional checking for conforming but error prone operations e.g.
wraparound with unsigned integer types.
the runtime library is linked into the compiler s output and handles overflows as they occur it is lines of c code.
this section discusses some of the key design choices made in the tool including at what point in compilation to perform the instrumentation how to perform the run time overflow checks the design of the run time library and how to efficiently recover from a detected overflow operation and continue execution.
.
.
where to put the instrumentation pass?
the ioc transformation operates on the abstract syntax tree ast late in the clang front end after parsing type checking and implicit type conversions have been performed.
this is an appropriate stage for inserting checks because full language level type information is available but the compiler has not yet started throwing away useful information as it does during the subsequent conversion into the flat llvm intermediate representation ir .
in a previous iteration of ioc we encoded the required high level information into the ir using ir metadata which is much simpler to transform than the ast and also allows the transformation to be more naturally expressed as a compiler pass.
unfortunately this proved to be unreliable and unnecessarily complicated because it requires a substantial amount of c level type information to be recorded with the ir in order to support a correct transformation.
for example the ir does not distinguish between signed and unsigned integer types since the two s complement representation is equivalent for both but this distinction is essential for correct checking of integer overflows in c code.
similarly some important operations such as signed to unsigned casts do not exist at the ir level.
also the original transformation was further complicated by the lack of a one to one mapping between ir and ast nodes.
in short it is much less error prone to do the instrumentation in the frontend where all the required information is naturally available despite the greater complexity of the representation.
.
.
overflow checks finding overflows in shift operations is straightforward operand values are bounds checked and then if the checks pass the shift is performed.
checking for overflow in arithmetic operations is trickier the problem is that a checked n bit addition or subtraction requires n bits of precision acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a and a checked n bit multiplication requires nbits of precision.
finding these extra bits can be awkward.
there are basically three ways to detect overflow for an operation on two signed integers s1ands2.
precondition test.
it is always possible to test whether an operation will wrap without actually performing the operation.
for example signed addition will wrap if and only if this expression is true s2 s1 intmax s2 s2 s1 intmin s2 in pseudocode if !precondition then call failure handler endif result s1 op s2 cpu flag postcondition test.
most processors contain hardware support for detecting overflow following execution of an arithmetic operation condition code flags are set appropriately.
in the general case it is problematic to inspect processor flags in portable code but llvm supports a number of intrinsic functions where for example an addition operation returns a structure containing both the result and an overflow flag.
the llvm backends then emit processorspecific code that accesses the proper cpu flag.
in pseudocode result flag s1 checked op s2 if flag then call failure handler endif width extension postcondition test.
if an integer datatype with wider bitwidth than the values being operated on is available overflow can be detected in a straightforward way by converting s1ands2into the wider type performing the operation and checking whether the result is in bounds with respect to the original narrower type.
in pseudocode result extend s1 op extend s2 if result min result max then call failure handler endif ioc supports both the precondition test and the cpu flag postcondition test width extension seemed unlikely to be better than these options due to the expense of emulating bit and bit operations.
initially we believed that the cpu flag postcondition checks would be far more efficient but this proved not to be the case.
rather using the flag checks has an uneven effect on performance.
we evaluated this performance question experimentally as follows.
.
.
.
performance of the overflow checks.
we studied the overall performance impact of ioc to answer two questions how do the precondition test and the cpu flag postcondition test compare in terms of the overheads they introduce?
and how much run time overhead is introduced by using ioc?
to answer these questions we compiled spec cpu in three ways a baseline compilation using clang with optimization options set for maximum expected performance.
checking for undefined integer overflows shifts and arithmetic using precondition checks.
checking for undefined integer overflows shifts and arithmetic using the cpu flag postcondition test.
we then ran the benchmarks on a .
ghz amd phenom ii processor using their ref inputs the largest input data used for reportable spec runs five times and used the median runtime.
we configured the fault handler to return immediately instead of logging overflow behaviors.
thus these measurements do not include i o effects due to logging but they do include the substantial overhead of marshaling the detailed failure information that is passed to the fault handler.
for undefined behavior checking using precondition checks slowdown relative to the baseline ranged from i.e.
from a tiny accidental speedup to a threefold increase in runacm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
time.
the mean slowdown was .
using flag based postcondition checks slowdown ranged from with a mean of .
however the improvement was not uniform out of the benchmark programs only became faster due to the ioc implementation using cpu flags.
the explanation for the uneven benefits of the cpu flag checks can be found in the interaction between the overflow checks and the compiler s optimization passes.
the precondition test generates far too many operations but they are operations that can be aggressively optimized by llvm.
on the other hand the llvm intrinsics supporting the flag based postcondition checks are recognized and optimized by relatively few optimization passes causing much of the potential performance gain due to this approach to be unrealized.
.
.
runtime library for error reporting to produce informative error messages ioc logs the source code location corresponding to each inserted check including the column number where the operator appeared.
operating on the ast instead of the llvm ir makes such logging possible and clang has outstanding error reporting.
thus users can disambiguate for example which shift operator overflowed in a line of code containing multiple shift operators.
also in service of readable error messages ioc logs the types and values of the arguments passed to the operator this is important for operators with multiple modes of failure such as shift.
for example an error we found in openssl was reported as lhash.c op reason unsigned right shift error right operand is negative or is greater than or equal to the width of the promoted left operand binary operation left uint32 right uint32 .
based on the value of an environment variable the ioc failure handler can variously send its output to stdout tostderr to the syslog daemon or it can simply discard the output.
the syslog option is useful for codes that are sensitive to changes in their stdout andstderr streams and for codes such as daemons invoked in execution environments where capturing their output would be difficult.
finally to avoid overwhelming users with repetitive error messages the fault handler uses another environment variable to specify the maximum number of times an overflow message from any particular program point will be printed.
.
.
efficient error recovery when an overflow check is triggered it is often desirable to continue program execution which we callrecovery .
when running ioc on a code base there are often multiple errors many of which may be benign and using recoverable checking to find these with a single run is useful.
unfortunately our original implementation showed substantial slowdowns in error free execution when making checks recoverable.
to evaluate these overheads we ran ioc with signed overflow and divisionby zero checks on the subset of spec cint2006 benchmarks that did not trigger these errors dynamically.
adding more check types caused this subset to be too small to be interesting.
with our initial implementation the no recovery case had an overhead of on average while recoverable checking had an average overhead of .
we used hardware performance counters accessed via intel s vtune software to investigate the causes of the slowdowns.
the first source of slowdown poor code layout which degraded performance via bad cache interaction and frontend stalls.
we resolved this issue by adding branch prediction metadata at the llvm ir level which the backend uses to guide block placement.
by hinting that the checks are unlikely to be taken the basic blocks containing calls to the runtime are not interspersed with the normal code.
this issue did not arise with no recovery checking because the code after the handler call is marked as unreachable which similarly influences block layout.
acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a using performance counters we verified that our fix resolved the layout problem.
for example in the spec benchmark .hmmer we observed that the number of instruction starved cycles cycles where the front end did not issue an instruction was reduced by and cpi decreased from to .
indeed this resulted in a significant improvement for this benchmark down from 179s to 142s from to slowdown relative to the no recovery case .
averaged across the benchmarks this optimization brought recovery overhead down to significantly less than the original .
the second problem we identified was that to enable recovery failure handling blocks for inserted checks must branch back into the program execution which hurts register allocation performance in error free paths.
in particular the compiler backend has to allocate registers with the additional constraints imposed by the parameter preparation and the registers clobbered by the runtime call.
we resolved this by changing the runtime functions to use a special cold calling convention which indicates the call clobbers as little as is possible for the architecture.
this was a difficult change because it requires making the runtime functions save restore all registers on entry exit with hand written assembly and because while llvm already supports coldcc as part of the ir it is treated the same as the normal c calling convention on all architectures.
to handle the former we used hand written assembly wrappers for the normal c functions and plan on proposing a function attribute to cause the compiler to do this automatically gcc has support for this .
for the latter we extended the llvm x86 and x86 back ends to treat coldcc calls as not clobbering any registers.
together these changes reduced average overhead to only over the no recovery case which is low enough to make checks recoverable by default.
these optimizations would benefit any similar runtime check instrumentation the first has already been adopted into mainline clang for use in other sanitization checks and there are plans to make use of the calling convention optimization once sufficient support has been added to llvm.
.
ioc deployment after the initial release of ioc our findings and user feedback encouraged us to work to make ioc more widely available by working with the llvm and clang developers to include integer overflow checks in the official clang code.
during this process we made a number of functionality efficiency and usability changes resulting in the first widely available easy to use tools to enable developers to better reason about integer overflows in the software they build and use.
as a result of these efforts integer checking support is now available in llvm clang.
the first release including our integer checking features was version .
in june .
.
.
user interface in the original version of ioc users specified what operations to check by requesting checks for violations of a particular version of the c standard.
this was found to be cumbersome and for the version of ioc deployed with clang we integrated our command line options with the fsanitize family of options providing users with a unified interface to a variety of dynamic checks.
example invocations include fsanitize integer check all suspicious integer operations and fsanitize shift check only shift operations .
.
.
improved diagnostics diagnostics were improved to read more naturally and to match the formatting style of errors given statically by the clang compiler.
here are two examples taken from clama v .
.
bytecode vm.c runtime error signed integer overflow cannot be represented in type int bytecode vm.c runtime error left shift of by places cannot be represented in type int64 t aka long these new diagnostics are designed to significantly improve the user experience by providing a natural explanation about what occurred including the operands that triggered the problem.
while the same information was available in the diagnostics printed by the original ioc it has been made acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .a w. dietz et al.
cleaner with attention given to details such as providing source level types and more specific explanations.
.
.
new features besides changing the interface we also introduced a number of features to make ioc suitable for a larger variety of use cases.
first we added the ability to continue program execution to recover after a failing check.
making checks recoverable incurs a performance penalty which we significantly reduced through the changes described in section .
.
in addition to making checks recoverable once a particular check has been triggered often users are not interested in seeing the error again.
this error deduplication was originally accomplished using a hash table but this design proved to not scale well.
to address this we now emit a byte for each check which is used to track its triggered state which scales well and only requires a minor amount of additional space in the resulting binary.
finally often integer overflows are known to be intentional or the programmer has investigated it and determined it to be acceptable.
to address these use cases while still being useful in reporting undesired integer overflows a whitelist functionality was introduced to enable users to specify certain files or functions that should not be checked.
.
.
runtime concerns inclusion in a production compiler required us to address a number of edge cases in our runtime that we previously ignored in our research prototype.
examples include avoiding dependencies on libc linking the ioc runtime automatically and transparently in a variety of build scenarios ensuring correct execution in multithreaded environments and ensuring the preservation of errno across calls into the runtime functions.
.
integer overflow study this section presents the qualitative and quantitative results of our study of overflow behaviors in c and c applications.
.
.
limitations of the study there are necessarily several limitations in this kind of empirical study.
most important because ioc is based on dynamic checking bugs not exercised by our inputs will not be found.
in this sense our results understate the prevalence of integer numerical errors as well as the prevalence of intentional uses of wraparound in these programs.
a stress testing campaign or use of a formal methods tool would be very likely to uncover additional integer bugs.
second our methodology for distinguishing intentional from unintentional uses of wraparound is manual and subjective.
the manual effort required meant that we could only study a subset of the errors we focused on the errors in the spec cint2000 benchmarks for these experiments.
for the other experiments we study a wider range of programs.
finally while some parts of our study are methodical other parts were performed in an informal fashion and hence our reporting of the results is also informal.
for example in many cases we lack links into bug reporting systems because the programs that we tested do not have bug reporting systems the bugs we found were reported by email.
in other cases we lack a definitive answer about whether a particular bug was fixed because the developers failed to confirm that they fixed the bug and the changes across versions of programs are often large enough that manually tracking the status of bugs in the code is infeasible.
.
.
a taxonomy for overflows table ii summarizes our view of the relationship between different integer overflows in c c and the correctness of software containing these behaviors.
only type overflows do not introduce numerical errors into carefully written c c software.
using ioc we have found examples of software errors of types and as well as correct uses of type .
the section numbers in the acm transactions on software engineering and methodology v ol.
v no.
n article a pub.
date january yyyy .understanding integer overflow in c c a table ii.
taxonomy of integer overflows in c and c with