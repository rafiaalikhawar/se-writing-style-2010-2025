partial evaluation of model transformations ali razavi department of electrical and computer engineering university of waterloo waterloo canada arazavi swen.uwaterloo.cakostas kontogiannis department of electrical and computer engineering national technical university of athens athens greece kkontog softlab.ntua.gr abstract model transformation is considered an important enabling factor for model driven development.
transformations can be applied not only for the generation of new models from existing ones but also for the consistent co evolution of software artifacts that pertain to various phases of software lifecycle such as requirement models design documents and source code.
furthermore it is often common in practical scenarios to apply such transformations repeatedly and frequently an activity that can take a significant amount of time and resources especially when the affected models are complex and highly interdependent.
in this paper we discuss a novel approach for deriving incremental model transformations by the partial evaluation of original model transformation programs.
partial evaluation involves pre computing parts of the transformation program based on known model dependencies and the type of the applied model change.
such pre evaluation allows for significant reduction of transformation time in large and complex model repositories.
to evaluate the approach we have implemented qvtmix a prototype partial evaluator for the query view and transformation operational mappings qvtom language.
the experiments indicate that the proposed technique can be used for significantly improving the performance of repetitive applications of model transformations.
i. i ntroduction model driven engineering mde is an emerging paradigm whose fundamental objective is to raise the level of abstraction in the software development process.
the basic premise of model driven engineering mde is that software artifacts can be represented as collections of models which adhere to standardized meta modeling formalisms such as the meta object facility mof or the eclipse modeling framework emf .
in addition to serving as a medium for documentation mde aspires to promote models to first class development artifacts.
to this end various model transformation frameworks have been proposed to facilitate bridging levels of abstraction between models and even use models to generate executable code .
to be practically relevant mde should also support modern iterative and incremental development processes a.g. agile methodologies .
when commencing the development of a system in mde style the initial models need to be transformed into multitudes of formats to realize a concrete system.
the models then being first class entities should be refined for maintenance purposes which necessitates theirre transformation.
unlike code based development simple make like programs are however not adequate for effective handling of model transformations.
this is mostly because models are modularized in a rather different way than source code with a different coupling and cohesion characteristics.
mde encourages developing models that describe a certain perspective of the underlying system and the dependencies of such models with other models in a project tend to be context dependent.
for instance when using uml to describe a system and transforming it to java code the details of what constitutes an underlying class in java can be scattered across amongst others class diagrams and sequence diagrams.
consequently a change made to the class diagram would need to be weaved with the sequence diagram to form the target java class.
in this context a common problem that arises is that in order to keep these models synchronized and consistent with each other one has to re apply all transformations in all models so that a complete re generation of all model artifacts is achieved.
plain re transformation can be intractable for large models and or complex transformations.
therefore incremental model transformations are considered to be the proper mitigation strategy for keeping the source and target of transformations synchronized .
most existing mde frameworks utilize transformations that are denoted either by a declarative style language in the form of logical relations or functional mappings for cases in which there exist clear correspondences between the elements of both sides of the transformations or by imperative style languages when mutual relationships of models are less evident.
as we review in the next section the body of research work on incremental model transformation primarily addresses the issue for the declarative model transformation languages.
however incremental transformation of imperative model transformation languages due to the familiarity of developers with this style and also the richer expressiveness they offer are just as important.
in this paper we propose an approach to increase the performance of model transformation process based on the partial evaluation of transformation programs.
partial evaluation is an established methodology in programming languages research that is based on the premise that programs can978 .
c ieee icse zurich switzerland 562be executed on a subset of input data known a priori so as to generate a residual program whose expressions are to the extent allowed by the availability of known data are statically pre evaluated.
thus the residual program when executed over the dynamic inputs does not need to compute the parts of the code that only correspond to known inputs.
performing fewer computations at runtime residual programs are expected to perform better than their original counterparts .
the basic premise of our proposed approach is that model transformations are also a kind of software programs which get as input instances of a metamodel e.g.
mof or similarly ecore .
when a transformation is applied iteratively the altered elements of the source model can be considered as dynamic data and the invariant fragments as static.
the objective is to reduce the number of computations performed when a complex transformation is invoked by pre computing and storing in a residual transformation the expressions that are not affected by a model change.
as a proof of concept we have developed a prototype of a partial evaluator for a subset of omg s imperative model transformation language qvt operational mappings .
transformations denoted in qvt and in other model transformation languages alike make extensive use of collection operations to manipulate the elements of input models and their containers in order to form the target model.
therefore our technique primarily focuses on the specialization of these types of expressions.
in this respect we have implemented a prototype partial evaluator in qvt om itself.
this design decision has two important methodological consequences.
on the one hand it adheres to the general philosophy of model driven engineering which strives to treat all major software component as models in particular the object of our partial evaluator i.e.
qvt transformation are themselves treated as models and are manipulated as such.
on the other hand this enables the concept of self application that is specializing the partial evaluator by itself.
the rest of the paper is organized as follows.
section ii discusses related work and lays the foundations for the rest of the paper.
section iii presents the outline of the partial evaluation process.
section iv presents the detail of the partial evaluation technique for the qvt om model transformation language explained through a running example transformation.
section v reports and comments on experimental results.
finally section vi concludes the paper and points to a number of future research directions.
ii.
b ackground and related work a. background partial evaluation of software programs refers to the approach whereby parts of the program are pre computed with values of known inputs so as to yield a new residual program which when executed to a set of known and unknown inputs will compute only the parts of the program that correspondto the unknown inputs.
because the residual program performs fewer computation it is expected to run faster than the original program.
more specifically let jprog kl out denote that prog is a program specified in language land produces output outfor the sequence of inputs in.
suppose that the first minputs of the program are known before the execution time and they are denoted as k1 .
.
.
k m and the rest of the inputs are unknown and are denoted as u1 .
.
.
u n .
a partial evaluator for prog is a program such aspe inputs of which are the source code of program prog in language l and its set of known inputs.
it transforms the input program to a specialization of it referred to as prog s with respect to this set of known inputs.
using the same notation we can denote jpek prog s. because some of the expressions in prog are replaced by statically pre evaluated values in prog s the latter is intuitively expected to run faster than the former.
partial evaluation is a form of program transformation as it produces another program as output.
running this program on the remaining inputs i.e.
the unknowns results in the same output thus jjpek kl out.
partial evaluation usually consists of two phases.
during the first phase binding time analysis the source code of the program is analyzed with respect to the set of known inputs and its expressions are annotated as either static ordynamic .
following this analysis in the second phase the constructs that are determined to be static are evaluated starting from the inputs and progressively replacing each static expression with its evaluated value.
dynamic expressions in contrast are substituted with symbolic expressions that are derived from the values of static expressions and other dependent dynamic expressions.
the second phase yields a program called residual program which only needs the unknown subset of the inputs of the original program to run.
there are two common strategies to carry out these two phases explicitly and separately in offline evaluators versus online evaluation by performing static analysis on the go along with specialization .
either way all the statically computable expressions of the original programs are replaced with preevaluated values in the residual program thus will not be recomputed during runtime.
b. related work an elaborate classification of various model transformation approaches is presented in .
a prominent model transformation framework is the omg s query view and transformation qvt which specifies three languages .
qvt core and qvt relations both define mappings between the two sides of transformations in a declarative fashion.
both languages are also envisioned in the standard to have built in support for incremental and bi directional transformation.
for specifying more sophisticated transformations whose mappings are not as straightforward as those expressible by the core and relations languages omg563offers the qvt operational mappings qvt om language.
this language provides a hybrid collection of imperative and declarative constructs and is designed to operate in one direction with no direct support for incremental execution of transformations.
as discussed this essentially results in redundant computation of unaffected model elements when the transformations are used iteratively.
amongst other proposed model transformation frameworks are the atlas transformation language atl and triple graph grammars tgg .
atl programs can be used to perform syntactic or semantic model transformations and run on top of a specialized virtual machine.
triple graph grammar tgg is a graphical declarative incremental and bi directional model transformation methodology based on graph transformation .
tgg is shown to be semantically aligned with qvt relations .
in the area of model synchronization one solution that relates to our work in the sense that it enhances existing transformations to achieve model synchronization is syncatl proposed by xiong et al.
in .
the authors have proposed an extension to the bytecode of the atl virtual machine whereby supporting automated backward synchronization of models linked by an atl transformation.
for the forward synchronization syncatl relies on re invoking the transformation and merging the results with the existing target.
however syncatl does not address incremental synchronization as the framework relies on re executing the transformation in its entirety for forward change propagation.
another framework with the theme of building incremental synchronization around existing transformation engines is presented in .
the tefkat transformation engine which has a declarative logical flavor is decorated with support for incrementality.
in tefkat transformation rules are specified as logical predicates which are reduced using sld resolution.
their synchronization framework avoids redundant computations in the successive transformation of the same model by preserving the intermediate sld trees.
there exists a vast body of research on partial evaluation.
an excellent introductory resource is the book authored by jones et al.
which also provides an exhaustive list of