practical and effective symbolic analysis for buffer overflow detection lian li cristina cifuentes nathan keynes sun labs oracle brisbane australia lian.li cristina.cifuentes nathan.keynes oracle.com abstract although buffer overflow detection has been studied for more than years it is still the most common source of security vulnerabilities in systems code.
different approaches using symbolic analysis have been proposed to detect this vul nerability.
however existing symbolic analysis techniques are either too complex to scale to millions of lines of code mloc or too simple to effectively handle loops and complex program structures.
in this paper we present a novel symbolic analysis algorithm for buffer overflow detection that applies simple rulesto solve relevant control and data dependencies.
our approach is path sensitive and effectively handles loops and complex program structures.
scalability is achieved by us ing a simple symbolic value representation filtering out irrelevant dependencies in symbolic value computation and computing symbolic values on demand.
evaluation of our approach shows that it is both practical and effective the analysis runs over .
mloc of theopensolaris tmoperating system networking on codebase in minutes and finds hundreds of buffer overflows with a false positive rate of less than .
categories and subject descriptors d. .
testing and debugging symbolic execution general terms reliability security .
introduction although buffer overflow detection has been studied for more than years it is still the most common source ofsecurity vulnerabilities in systems code.
in a study of bugs that lead to publicly reported vulnerabilities mitre reports that of all security vulnerabilities over the period2001 were due to buffer overflows .
different ap proaches have been proposed to detect this vulnerability permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.fse november santa fe new mexico usa.
copyright acm ... .
.including both dynamic and static techniques.
symbolic analysis is a static analysis technique that represents the values of program variables and computations with symbolic values.
recently different symbolic analysis approaches have been proposed to detect buffer overflows and promising results were reported.
however these approaches are still eithertoo complex to scale to millions of lines of code mloc or too simple to effectively handle loops and complex program structures.
complex approaches that do not scale well to mloc include .
these approaches exhaustively traverseall possible execution paths and use an external constraint solver or a theorem prover to try to solve all data and control dependencies on each path.
although they can be very precise these approaches are hard to scale to large applica tions due to the unbounded number of execution paths and the complexity of solving all dependencies on each path.
as a result they are mostly used in unit testing .
simpler approaches that trade precision for scalability include not being path sensitive and only providing very lim ited support for control dependencies only support ing very limited computation between symbolic values i.e.
limited support for data dependencies or using simple heuristics to handle loops and complex control structures .
these tradeoffs not only miss many bugs they mayalso introduce numerous false alarms.
in this paper we propose a new symbolic analysis technique for buffer overflow detection.
here buffer overflow refers to buffer bounds violation via both read and write accesses.
compared to previous approaches we apply simple rules to solve relevant data and control dependenciesiteratively.
the analysis is path sensitive and handles loops and complex program structures effectively.
scalability is achieved by using a simple symbolic value representation filtering out irrelevant dependencies in symbolic value com putation and computing symbolic values on demand.
our demand driven algorithm has been implemented in parfait a scalable bug checker built on top of llvm .as shown in section our experimental results against large systems code show that it is both practical and effective.
in summary this paper makes the following contributions we propose a new symbolic analysis technique for bufferoverflow detection.
the technique is simple yet effective.
it can be easily implemented and integrated withother analysis techniques.
we develop a new demand driven symbolic analysis algorithm to compute the symbolic value of a variableefficiently.
we evaluate our implementation using several large applications including the opensolaris tmoperating system networking on consolidation.
experimental results show that this technique is practical and effective.
it analyzes .
mloc of the opensolaris oncodebase in minutes on an intel e8600 .33ghz processor and identifies hundreds of buffer overflows with a false positive rate of less than .
the rest of the paper is organized as follows.
section reviews related work.
in section we show an example to motivate our approach.
the symbolic analysis technique is described in section and the algorithm is presented in section .
we evaluate the scalability and effectiveness ofour approach in section and section concludes the paper.
.
related work symbolic analysis was introduced in the 70s and has recently been applied in many approaches to detect buffer overflows .
in symbolic analysis the program is executed with symbolic values asinput.
during symbolic execution values of program variables are computed as symbolic expressions by manipulating program expressions involving symbolic values i.e.
solving data dependencies symbolically.
control statements such as branch instructions are executed by conceptually follow ing both branches and maintaining the control predicateinformation i.e.
control dependencies on each branch.
existing symbolic analysis techniques differ from each other in their different representations of symbolic values and howthe symbolic values are computed.
in the symbolic values are simplified as integer ranges and the authors map the range analysis problem into an integer linear programming ilp problem which is exponential.
rugina and ri nard reduce the ilp problem to a linear programming problem by using a different symbolic representation the symbolic value of a variable is abstracted as a linear functionof the set of input variables then a linear constraint solver is used to solve the linear representation for each variable.
however for large applications with millions of loc it willbe very time consuming for the linear constraint solver to solve the representations of all program variables together.
these approaches are not path sensitive in that control de pendencies are either not used at all or are discarded at instructions where different execution paths merge leading to imprecision in the buffer overflows reported i.e.
high false positive rate .
xie et al.
use linear derivations of a single symbol to represent symbolic values which are then computed by in terpreting the program.
in their approach computations be tween symbolic values are not supported and loops with nonconstant iterations are handled by simply unrolling them once and terminating them with an assumption that theloop test has failed.
this simplification in handling loops although adopted in various approaches can miss many bugs and may cause some false positives as well.
in the authors formalized symbolic analysis as a special case of abstract interpretation .
they defined a set of abstract domains to represent symbolic values at different levels ofprecision and the users can select which abstract domain touse.
the more precise the abstract domain is the more expensive the analysis will be.
their approach can scale totens of thousand loc as described in the paper.
the technique described in this work can be integrated as a different abstract domain in their frameworks.
compared to the above approaches symbolic analysis as applied in unit testing is often more precise byexhaustively traversing all possible execution paths and using an external constraint solver or theorem prover to solveall data and control dependencies on each path where control dependencies are often represented as extra constraints on each path.
given that the number of possible executionpaths is unbounded in the presence of loops and that the execution path can be very long restrictions are often introduced to limit the number of iterations to traverse a loopand the number of constraints on each execution path.
the authors in improve the scalability of the above approaches by being demand driven instead of symbolicallyexecuting the program they exhaustively traverse all possible execution paths backwards from each buffer access instruction.
during the backward traversal extra data dependencies and control dependencies are analyzed incrementallyby an external constraint solver allowing for the analysis of hundreds of thousand loc.
as in loop bounds and path restrictions are applied.
in this paper we use a different tradeoff for precision and scalability by iteratively solving relevant data dependencies and control dependencies when computing the symbolic values of a program variable.
instead of exhaustively traversingall execution paths we only consider linearly related control dependencies which can be efficiently solved.
since the values of array index variables often only depend on data andlinearly related control dependencies it is very effective in finding buffer overflows.
as a result our approach is both scalable and effective as shown in our experimental results scaling well to millions loc.
.
a motivating example we present the c code fragment in figure a to illustrate our approach.
the function tosunds strproduces a new string by adding a letter capchar in front of every capital letter in the input string.
it firstly creates a new buffer buf with size n lines and .
then in the forloop lines every letter in the input string stris processed and copied to buf where a letter capchar will be inserted in front of the processed letter if it is in uppercase.
after the forloop the null string terminator will be appended at the end of bufas shown in lines .
in the above example a buffer overflow may occur at line as highlighted in the shadow box.
the forloop exits in line if the index variable jis larger than or equal to the buffer size n. however the loop will keep executing if jis equal to n .
in that case in the next iteration of the loop the assignment to bufin line may overflow.
.
the intermediate representation figure b shows the control flow graph cfg and the single static assignment ssa representation for the program in figure a where each instruction is given a unique label and only relevant basic blocks are shown.
in ssa form all variables have a single definition and at join points where different paths in the cfg merge a phiinstruction is introduced as the new definition of a variable puts capchar in front of uppercase characters for example assuming capchar i fs t r a b c i tr e t u r n s a b c char tosunds str char str int i j n char buf ... 5n ... n is defined by external function buf malloc n sizeof char 7j 8f o r i i strlen str i if isupper str buf capchar 11buf str if j n break if j n j n buf return buf p2i0 phi i1 p3j0 phi j3 p4pred0 i0 strlen str p5if pred0 goto bb5 p6 pred1 isupper str p7if pred1 goto bb3 p8buf capchar p9 j1 j0 p10 j2 phi j1 j0 p12 j3 j2 p13 pred2 j3 n p14 if pred2 goto bb5 p15 i1 i0 p16 goto bb0 p17 j4 phi j3 j0 p18 pred3 j4 n p19 if pred3 goto bb7 p20 j5 n p23 return buf bb5 bb7bb6bb4bb3bb2bb1bb0p0n ... p1buf malloc n sizeof char p21 j6 phi j4 j5 p22 buf p11 buf str a the code snippet b the intermediate representation ir for the example code in a figure a motivating example abstracted from usr src cmd fs.d autofs ns ldap.c in opensolaris on.
if it has been defined along distinct paths.
for example in bb3in figure b where the buffer overflow is located line in figure a a phi instruction j2is introduced at p10 to represent the new definition of index variable j. as is common practice in modern compilers such as gcc and llvm only scalar variables whose addresses are never taken are represented in ssa form.
variables which may be referenced by pointers are accessed via load and store in structions.
program values include constants and variablesdefined by ssa or load instructions.
for illustration purposes we explicitly label each control predicate as a separate instruction at p4 p6 p13 and p18 in figure b .
control predicates are those conditional expressions used in instructions that alter the flow of control i.e.
the conditional branch instructions at p5 p7 p14 and p19.
all control predicates are normalized as relational expressions in the form pred op1 op2 where predis the label of the control predicate op1andop2are the left and right hand operands and is a relational operator.
.
data and control dependencies in our intermediate representation each variable is defined by a unique instruction.
for a variable v letdvbe the unique instruction where vis defined.
at different instructions the possible values of vcan be different due to control dependencies of the instruction and we use sv p to represent the symbolic value of vat instruction p.f o r buffer overflow detection at each instruction pwhere vis used as an index variable into a buffer we will try to computesv pto detect buffer overflows.
both data and control dependencies need to be considered to compute sv p. data dependencies refer to the incoming operands of the instruction by which vis defined.
control dependencies refer to those control predicates that need tobe satisfied for pto be executed.
consider our motivating example.
to detect the buffer overflow in line in figure a we need to compute thevalue of index variable j2 i.e.
s j2 p11.
the data dependencies between variables j3 j0 j1 and j2 and the control depen dency pred2 atp13need to be considered.
note that these dependencies form a cycle and need to be solved iteratively.
the control predicate pred2 j3 n must be false to allow the use of j3atp3inbb0to be executed.
as a result we havesj3 p3andsj0 p3must be less than n. then the values ofj1 j2 and j3can be iteratively computed and the buffer overflow at p11 line in figure a via index variable j2can be identified.
the example shows that both data and control dependencies need to be considered in computing the symbolic value of a variable at an instruction.
those dependencies often form a cycle and we need to iteratively compute the valuesof program variables to address cyclic dependencies.
however not all dependencies are useful in the computation.
for example pred0 atp4inbb0 pred1 atp6inbb1are not useful in computing s j2 p11.
the key therefore is to determine which dependencies need to be considered and how the value of a program variable can be computed based on those dependencies.
.
symbolic analysis based on the observations in section we have developed a new technique to compute values of program variables symbolically.
we use symbolic ranges to represent values of program variables at each instruction.
the bounds of the symbolic ranges are defined in a simple symbolic expressiondomain as explained in section .
.
the simple symbolic expression domain enables us to compute the symbolic ranges of program variables at each instruction very efficiently.
in section .
simple rules are introduced for computing the symbolic ranges of program variables according to various control and data dependen cies.
the symbolic ranges of program variables can then becompared with buffer sizes to detect buffer overflows.
.
symbolic value representation symbolic ranges are introduced to represent the values of program variables at each instruction.
the symbolic range 319for variable vat instruction p sv p is defined by its lower and upper bound denoted as sv pminandsv pmax r e s p e c tively.
both sv pminandsv pmaxare symbolic values defined in a simple symbolic expression domain as explained below.
.
.
a simple symbolic expression domain the set of symbolic expressions eincludes a set of atomic symbols and their affine functions as derivations.
the symbolic expression set ehas the following property property .every symbolic expression eineis an affine function of an atomic symbol in e. constant value is regarded as an atomic symbol from which all constant values are derived.
property 1i se n forced by how symbolic expressions are introduced into e. initially the set is .
during the analysis new atomic or derived symbolic expressions may be introduced into eto represent computations between symbolic expressions.
a new atomic symbol will be introduced if the computationresults cannot be represented as an affine function of existing atomic symbols in e. for example if we try to add two symbolic expressions e x 1a n d e2 2y w h e r e x andyare atomic symbols a new atomic symbol z x 2y will be introduced intoeif no existing atomic symbol is affine toz.
this simple strategy in performing computation between symbolic expressions is very efficient and easy to implement.
however it is also very effective in finding buffer overflows as demonstrated in our experimental results in section .
the symbolic expression set eis partially ordered by where for any two symbolic values e1ande2ine e1 e2iff their subtraction e1 e2is no larger than .
by convention latticetopand are introduced in e. e e w eh a v e eand e latticetop.t h et w oo p e r a t i o n sm e e t intersectionsqand join unionsqare defined as follows e1 intersectionsqe2 e1ife1 e2 e2ife2 e1 otherwisee1 unionsqe2 e2ife1 e2 e1ife2 e1 latticetopotherwise .
.
symbolic ranges the symbolic range of variable vat instruction p sv p is defined by its lower bound sv pmin and upper bound sv pmax.b o t h sv pminandsv pmaxare symbolic expressions defined in eand it implicitly implies that at instruction p w eh a v e sv pmin sv pmax.t h es y m bolic range sv prepresents the set of all symbolic expressions einesuch that sv pmin eande sv pmaxmay be true.
the set is if no symbolic expression in esatisfies such condition and we use to represent an empty range.
the union and intersect of two symbolic ranges can be computed as follows s1 s2 s1 s2 letbbe the size of the buffer and let vbe the index variable a buffer overflow will be reported if sb pmax sv pmax orsv pmin .
a buffer access cannot overflow if 1we assume that the accessed buffer is indexed from as for c.symbolic range algebra s1 s2 s1 s2 s1 s2 s e s1 s2 s1 s2min s1 s2max s e s1 s2 s2 s1 s2min s1 s2max otherwise s e smax smin o t h e r w i s e s1 s2 s2 s1 s2min s1 s2max otherwise figure simple integer arithmetic operations between symbolic ranges.
erepresents a symbolic expression in eand represents an integer arithmetic operation.
sv pmax sb pmin 1a n d0 sv pmin.
note that such buffer accesses are guaranteed to be within buffer bounds since the symbolic ranges are computed conservatively as described in section .
.
otherwise we consider the buffer access to beapotential buffer overflow that is our analysis cannot determine with certainty whether or not a vulnerability exists.potential buffer overflows are not reported as bugs.
.
computing symbolic ranges we support common integer arithmetic computations including and between two symbolic ranges.
the resulting range represents the set of symbolic expressions obtained by computing the operation over any two symbolic expressions selected from each input range e1 s1 e2 s2 e1 e2 s1 s2 where represents an arithmetic operation.
figure shows the simple algebraic equations.
the equations for and are self explanatory.
for the operation let us first look at the simple case of applying the multiplication operator to a symbolic range sand a symbolic expression e s e. the product could be in the range o r depending on whether eis positive or negative.
then the range of s1 s2 can be computed as shown in figure .
similar equations are derived for the operator.
note that we conservatively assume that any range divided by will result in the symbolic range which includes all symbolic expressions ine.
in the equation for s e w h e r e sis a symbolic range and eis a symbolic expression the remainder will carry the same sign as the dividend as specified in the c99 standard.
the equation for applying the modulo operationto two symbolic ranges is derived in the same way.
given the simple symbolic range algebra s v p t h es y m bolic range for variable vat instruction p is then computed according to data and control dependencies.
two steps are involved in computing sv p. firstly we compute the symbolic range of v sv according to data dependencies.
then sv pis computed by refining svwith relevant control dependencies.
we call svthedefine range ofv a n d sv pthe use range ofvatp.
note that variable vwill have different use ranges sv p1andsv p2at instructions p1andp2 i f different control dependencies are considered.
in this section we explain how to select the relevant dependencies and introduce the simple rules for computing 320symbolic ranges according to those dependencies.
the computed symbolic range is conservative in that for each vari able its symbolic ranges are always a superset of its possible values.
more precise symbolic ranges can be computed if more accurate dependency information is provided either via compiler analysis or user annotation.
.
.
data dependencies data dependencies define ranges sv v op1 op2 sop1 dv sop2 dvv phi op1 op2 sop1 dv sop2 dv v load a i ... intersectionsq... a ais constant aggregate a ... unionsq... a v input v unsolved figure the rules for computing the define range of v sv a c c o r d i n gt od a t ad e p e n d e n c i e s .
dvis the instruction where vis defined represent an arithmetic instruction.
v.type.min and v.type.max represent the minimal and maximal value that could be represented by the type of v i.e.
v.type .
the instruction v unsolved represents the set of instructions that will not be handledby our analysis.
figure outlines the rules to compute the define range of variable v sv according to data dependencies.
for variables defined by arithmetic instructions and their define ranges are computed according to the symbolic range algebra in figure .
similar rules with small exten sions can be applied to variables defined by arithmetic shift instructions.
the define range of a phi instruction is the union of the use ranges of all its operands from their corresponding incoming blocks assuming that it can hold any value from its incoming operands.
memory dependencies are solved only if the variable is loaded from a constant buffer.
its define range will be computed by checking the range of the index variable and all possible values in the buffer.
this may sound restrictive.
however it is effective in detecting vulnerabilities such as buffer overflows where index variables are often either scalars or loaded from constant arrays as indirect array accesses .
finally the define range of a variable defined by user inputincludes any value that can be represented by its type.
note that we do not try to solve the data dependencies for all variables.
instead for a variable whose define rangecannot be solved v unsolved such as library call returns or bit mask operations we introduce a unique atomic symbol into the symbolic expression set eand the define range of the variable is defined by the introduced symbol as both itslower and upper bound.
for illustration figure only shows the rules for computing data dependencies intra procedurally.
however theserules can be easily extended to inter procedural analysis by propagating the values of function actual arguments to callee functions and function return values to caller functions.
.
.
control dependencies at instruction p the use range sv pis computed by refining the define range of vaccording to relevant control dependencies such that pmay be executed given any value ofvinsv p. a control dependency will be considered incomputing sv pif it controls both the execution of instructionpand the value of v. we conservatively define that a predicate predcontrols the execution of instruction pif predstrictly dominates p i.e.
every path from the entry of the cfg to pincludes pred a n d2 pis only reachable from one successor of the conditional branch instruction that usespred.
then the outcome of predmust be true or false depending on which successor can reach p. control dependencies use ranges sv p pred op1 op2 sv c1 sop2 pred c2 op1 op2 sv op1 op2 sv op1 negationslash op28 sv svmin v svmin op1 op2 sv svmax v svmax op1 op2 sv otherwise figure the rules for computing sv paccording to direct control dependencies.
control predicates are in the form of pred op1 op2 where op1and op2are the left and right hand operands and is a relational operator.
the predicates are normalized in such a way that v c1 op1 c2and c1 .
control predicates are in the form of pred op1 op2 where is a relational operator.
a control predicate may control the value of vdirectly or indirectly depending on how its operands relate to v.op1isdirectly related tovif it is defined as an affine function of v i.e.
op1 c1 v c2 where both c1andc2are constants or if vis defined as an affine function of op1.op1isindirectly related tovifop1is loaded from a buffer with the index variable directly related tov o ri f vis loaded from a buffer with the index variable directly related to op1.
accordingly those dependencies are called direct orindirect control dependencies.
similarly to memory data dependencies indirect control dependencies can be transformed to direct control dependencies by examining the content of the buffer.
figure shows how to compute sv paccording to direct control dependencies.
all control predicates are normalized in such a way that op1is directly related to v. the define range svis intersected with a range defined by the affine function between op1andv the relational operator and the use range sop2 pred.
if multiple control predicates need to be considered in computing sv p t h e n svwill be refined multiple times according to the rules described in figure .
.
enhancements our analysis can be improved if more detailed dependency information is provided either via compiler analysis or user annotation.
here we introduce two important compiler analysis enhancements.
.
.
loop induction variable analysis loop induction variables refer to those variables whose values take on a simple progression in successive iterations of a loop.
loop induction variable analysis tries to represent such variables as functions to the loop iteration number thus dependencies between induction variables and loop iteration numbers can be considered when computing their symbolic ranges.
this analysis is important for buffer overflow detections since induction variables commonly appear 321as loop indices and in subscript computations.
in our analysis we only consider induction variables which are affinefunctions of the loop iteration number.
.
.
path sensitive analysis the analysis so far is predicate aware but it is not fully path sensitive.
we have considered the control dependencies of a variable s uses but have not considered the control dependencies of its definitions.
at a phi instruction wherevalues defined along different paths merge path sensitive analysis will check from which paths a definition will reach the phi instruction.
then the define and use ranges of a phi instruction can be more precisely computed by also consider ing the control dependencies along the paths of its incoming definitions.
we compute gated single assignment gsa form for path sensitive analysis as needed.
in gsa form the phi in struction v phi v1 v2 is extended to a binary decision tree called a tree.
the incoming definitions v1a n d v2 are leaf nodes in the tree with predicate nodes as internal nodes in the tree to guide which definition to choose.
when computing the symbolic range for a phi instruction we re cursively traverse the tree and compute the use ranges of its incoming operands according to the control dependenciesof the phi instruction as well as those control predicates inthe tree.
by only computing the gsa form on demand for relevant phi instructions the runtime overhead is minimized.
.
the demand driven algorithm algorithm compute the use range sv p procedure computeuserange v p computedefrange v sv p refinedefrange v p end procedure as explained in section the use range sv pis determined by firstly computing the define range svaccording to data dependencies then refining it with relevant control dependencies.
algorithm outlines the procedure where we first call computedefrange to compute svthen refine it inrefinedefrange .
computeuserange works in a demand driven fashion.
sv pis computed only when computeuserange is invoked with variable vand instruction pas the two input arguments.
we use a data structure to cache all define rangesthat have been computed.
at instruction p the use range s v pcan then be efficiently computed on the fly by refining the cached define range of vwith relevant control dependencies.
when computing the define range sv for all operands that define v we need to compute their use ranges at dv as shown in figure .
similarly when refining svaccording to the predicate pred op1 op2 we need to compute the use range of op2atpred sop2 pred as shown in figure .
if those dependencies form a cycle our algorithm will recognize those cyclic dependencies and will iteratively solve them.
.
iteratively solving data dependencies the data structure symtab is introduced to cache the computed define range svfor each variable v. initially it is set to .w h e n svis to be computed svand all definealgorithm compute the define range sv symtab newvalset procedure computedefrange v ifvhas an entry in symtab then return end if newvalset newvalset v symtab foreach operand opiused to compute vdo computeuserange opi dv end for compute sva c c o r d i n gt of i g u r e3 symtab sv updatedefrange v newvalset newvalset v end procedure procedure updatedefrange v forw newvalset do ifswis dependent on svthen foreach operand opito compute swdo computeuserange opi dw end for compute swaccording to figure symtab symtab sw ifsymtab has been updated then updatedefrange w end if end if end for end procedure ranges required to compute sv if not computed yet denoted as sw will be computed on demand and inserted into symtab .
note that swmay be used directly in computingsvas data dependencies or it could be used as control dependencies to refine a define range that will be used incomputing s v. there are cyclic dependencies if svis required to compute sw. letnewvalset be the set of variables whose define ranges are inserted into symtab when computing the define range svfor variable v. we have the following property property .cyclic dependencies can only exist between vand variables in newvalset .
if a define range is already cached in symtab t h e n sv is not required to compute it.
similarly if a variable has no entry in symtab aftersvhas been computed then its define range is not required to compute sv.i ne i t h e rc a s e there is no cyclic dependency in between.
in algorithm the procedure computedefrange returns if svhas already been computed lines and .
otherwise computeuserange will be recursively invoked to compute the required use ranges as data dependencies lines .
the define range svcan then be computed and cached in symtab lines and .
in line we invoke updatedefrange to iteratively solve cyclic dependencies if there are any until a fixed point is reached.
inupdatedefrange we recompute swif it is dependent on sv lines .
recall that svm a yb eu s e d directly in computing swas data dependencies or it could be used as control dependencies to refine a range that is used directly in computing sw.i fswhas been updated then updatedefrange is recursively invoked to update those symbolic ranges dependent on sw lines .
the algorithm terminates when no more updates can be made to symtab .
at this point we have reached a fixed point for svand all define ranges required to compute sv.t h e s e 322ranges will be cached in symtab and they do not need to be recomputed thereafter.
since we only update symtab if a smaller symbolic range can be computed the algorithm is guaranteed to terminate.
.
computing control dependencies algorithm refine the define range svat program point p procedure refinedefrange v p sv p symtab letpredset be the set of predicates that controls both the execution of pand value of v forevery pred op1 op2 i npredset do computeuserange op2 pred refine sv paccording to figure end for return sv p end procedure the function refinedefrange algorithm computes the use range sv pby refining the define range svaccording to control dependencies.
as stated in section a control predicate will be considered only if it controls both the execution of instruction pand the value of v line .
the use range sv pwill be computed by refining the define range svwith all predicates in predset lines .
in our implementation when refining a define range with the range defined by a control dependency a simple rule is applied if the bounds of the two symbolic ranges are not comparable.
the constant bound is selected first.
otherwise if thedefine range is unsolvable the bound of the range defined by the control dependency will be used.
when refining the range according to a predicate pred op1 op2 computeuserange will be recursively invoked to compute the use range sop2 pred line .
the define range sop2 i fn o tc a c h e d yet will be computed on demand and inserted into symtab .
ifsvis used in computing sop2 those cyclic dependencies are iteratively solved as shown in updatedefrange .
the control predicate predalways strictly dominates instruction pby definition and only those control predicates that strictly dominate pred will be used in computing sop2 pred.
as a result the algorithm is guaranteed to progress.
.
the motivating example figure shows the relevant dependencies for our motivating example in figure as well as how they are solved incomputeuserange .
in our algorithm data dependencies are cached in symtab while control dependencies are solved on the fly.
as shown in figure data dependencies are grouped into gray boxes.
each box is given a number representing the order of when they are computed.
the computation order is essentially a topological order in the reduced dependency graph including only relevant dependencies with all cyclic dependencies being reduced into a single node.
the define range of nwill be solved first since it is not dependent on any other values.
the define range of j0 j1 j2 and j3form a cycle which is control dependent on n. they will be iteratively solved together.
then the define range of j4and j5are computed one by one.
note that this order is implicitly enforced in our algorithm by recursively calling computeuserange to compute all dependencies on demand.p3j0 phi j3 p9 j1 j0 1p0n ... p10 j2 phi j1 j0 p12 j3 j2 1p13 pred2 j3 n p17 j4 phi j3 j0 p13 pred2 j3 n p20 j5 n p21 j6 phi j4 j5 p18 pred3 j4 n figure reduced dependency graph including only relevant dependencies for the motivating example in figure .
all data dependencies are highlighted in ovalboxes and control dependencies are placed in white rectangular boxes on the path from the definition of a variable to the instruction where it is used.
dashed linesdenote that the dependency is used in computing control dependencies.
solid lines denote data dependencies.
.
experimental results we implemented our algorithm for buffer overflow detection in parfait a scalable bug checker built on top of llvm.
parfait processes an application in two steps .
source c c files are parsed by the llvm frontend which generates llvm bitcode files.
the llvm linker is used to link bitcode files as any normal linker would do.
.
bitcode files are loaded into memory a few simple optimizations are applied on the code e.g.
constant propagation and our analysis is applied to the bitcode representation to find buffer overflows.
the results reported in this paper use llvm bitcode files as the starting point.
the runtime includes the time in loading bitcode files to memory performing simple optimizations as well as the time in performing our analysis.
benchmarknc loc lines of code bitcode c c total files asterisk .
.
.
292k 6k 298k 25mb openjdktm7b 406k 492k 898k .39gb openbsd .
.72m .72m 129mb opensolaris on b105 .5m 87k .6m .44gb table summary of the benchmark data.
several large open source system applications are used in our experiment as shown in table .
opensolaris on and openbsd kernel only are general purpose operating systems openjdk is an implementation of the javatmvirtual machine and asterisk is the implementation of a telephone private branch exchange pbx .
for each benchmark we list its version or build number the number of non commented lines of c c code as reported by the sloccount tool and the size of the bitcode files generatedby the llvm front end.
323we evaluate our implementation of the symbolic analysis algorithm in the following ways section .
evaluates the precision of our algorithm section .
reports the performance of the algorithm section .
reports on our attempts to compare the precision of the analysis against other bug checking tools and section .
studies the limitations of ouranalysis by reporting the percentage of buffer accesses that cannot be solved by our analysis.
.
precision we manually verified all bugs reported by our tool computing the true positive i.e.
bugs that are correctly reported and the false positive i.e.
bugs that are incorrectly reported rates.
all the true positives were reported to the maintainers of each application who further verified our re ports and in turn filed bugs into their bug tracking system.
some bugs have already been fixed while others are in the process of being fixed.
benchmarks reports tp fp asterisk .
.
.
.
openjdk b51 .
openbsd .
.
opensolaris on b105 .
total .
table precision results of our tool.
reports is the number of total reports tp is the number of correctly reported bugs and fp is the false positive rate.
table summarizes the precision of the symbolic analysis implementation.
overall our tool is able to find true bugs with a false positive rate of .
.
the false positive rate is less than or close to for all applications except openbsd where we have observed a false positive rate ofclose to .
the false positives reported in openbsd as well as in other benchmarks are due to the limitation of our implementation in handling pointer types and memorydependencies which are explained next.
these limitations are currently being addressed in our implementation.
false positives struct sockaddr un struct sockaddr safamily ts u n family safamily ts a family char sun path char sa data static int convert sockaddr struct sockaddr addr socklen t l e n struct sockaddr inaddr socklen ti n l e n ... if inlen sizeof struct sockaddr un return ... orig len inlen sizeof addr safamily for i i orig len i ... 390addr sadata ... figure false positive example from opensolaris on file usr src lib brand lx lx brand common socket.c in figure the buffer access addr sadata in line is reported as buffer overflow as highlighted in the shadow box.
the upper bound of the loop index iand orig lencan be computed as while the buffer size for addr sadatais only .
however the type sockaddr is effectively a polymorphictype.
in this case the object that addrpoints to is actually of type sockaddr unand the buffer access to addr sadata cannot overflow.
to recognize such false positives we need very precise points to information.
such information is not provided in the llvm infrastructure.
alternatively we can rely on user annotations as in .
for this exam ple a simple cast to struct sockaddr unwould be the obvious annotation and would improve the code readability.
many of the false positives in openbsd were reported due to this reason2.
struct ieee80211 rateset unsigned char rs nrates unsigned char rs rates void pgt objbss2scanres struct pgt softc sc struct wi scan res scanres uint32 tn o i s e struct ieee80211 rateset rs struct wi scan res ap ... rs sc scic.ic suprates n for i i i ... if i rs rsnrates break ap.wi srates ap.wi rate rs rsrates ... ... figure false positive example from openbsd file usr src sys arch dev ic pgt.c in figure the buffer access rs rsrates in line is falsely reported as a bug.
the range of index variable i is computed as and the buffer size of rs rsratesis .
when computing symbolic range of i t h ec o n t r o ld e pendency i rs rsnrates is not considered since the value rs rsnrates cannot be computed.
in this case rs rsnrates is at most and the reported buffer overflow will not be exposed.
similar to the example in figure precise points to information is required to be able to compute these memory dependencies.
note that although it is classified as a falsepositive it can be argued that the loop exit condition shouldbei 15instead of i .
from our experience in verifying results against the various system applications the majority of false positives were reported due to the above two cases.
usually these false positives require very precise points to information to eliminate them.
.
performance benchmarktime max max min sec variables predicates asterisk .
.
.
openjdk b51 openbsd .
opensolaris on b105 table performance results of our tool.
max variables is the number of variables in the largest cycle that is iteratively solved.
max predicates is the largest number of predicates used when computing the use range of a variable on the fly.
table summarizes the analysis times for different benchmarks on an intel e8600 .33ghz processor with 8gb of 2if we consider these type violations as true bugs the false positive rate for openbsd would be .
324ram.
for each benchmark we report its analysis time column the number of variables in the largest cycle thatis iteratively solved column and the largest number of control predicates used when computing the use range of a variable on the fly column .
the analysis time includes the time to load the bitcode files build the representationin memory perform the symbolic analysis and report the results.
for each benchmark we ran our analysis times and the user time of the slowest run is reported.
the symbolic analysis time is less than minutes for opensolaris on with .
mloc.
openjdk is the secondmost time consuming application despite the fact that it ismuch smaller than openbsd see table .
this is due to its extensive use of c templates which are expanded in the llvm bitcode files.
as a result the total size of all llvm bitcode files in openjdk is actually much larger than thatin openbsd see table .
overall the performance of the algorithm is largely due to the fact that we compute only relevant dependencies on de mand and use simple symbolic expression representations.
as shown in column and column in table the largest cycle that is iteratively solved in computedefrange includes at most variables and the largest number of control dependencies that is computed on the fly in refinedefrange is .
.
comparison with other tools since we do not have access to existing commercial tools only open source tools were considered for comparison.
of the tools available four of them llvm clang static analyzer saturn uno and splint are underactive development and therefore used in our testing.
the llvm clang static analyzer mainly reports bugs that deal with objective c errors as such it does not report any buffer overflow bugs in c code.
saturn is a system for static analysis for c programs.
its existing analysis assumes inbound array accesses as such saturn does not report bufferoverflow bugs at present.
we tried to run splint and uno over the applications in table .
in our experience splint produces a large numberof error reports and uno produces very few reports.
for asterisk alone splint generates around out of bounds errors and uno reports which look to be false positives.
we estimate that to verify all the reports against the givenapplications in table would require many months of dedicated effort even at a rate of per day.
reports tp misses fp fn splint .
.
uno .
.
parfait .
table precision results of different tools on the begbunch suite.
reports is the number of total reports tp is the number of correctly reported bugs missesis the number of bugs present in the code but not reported.
fp is the false positive rate and fn is the false negative rate.
therefore we evaluated our buffer overflow detection implementation against other bug checking tools for c c using the begbunch benchmarking suite .
the begbunch suite includes a set of bug kernels extracted from existingopen source applications and existing bug checking bench marks.
each bug kernel has been manually inspected by the authors of and the bug location is marked.
it allows us toevaluate both precision and performance of our tool as wellas checking how many bugs are missed i.e.
false negatives .
table summarizes the results of different tools on the begbunch suite.
for the total buffer overflow bug kernels in the begbunch suite our tool reported bugs all of which were correctly reported with an overall .
false negative rate.
for this dataset our tool is significantly bet ter than splint and uno.
it is able to find all true bugs that are reported by the other two tools with a much better false positive and false negative rates.
the bugs that weremissed by our tool are mostly due to our limitation in handling memory dependencies which require precise points to analysis or user annotations.
it is worthwhile noting thatsplint s false positive and false negative rates can also beimproved by adding annotations to the code to be analyzed.
.
limitations recall that in our analysis we only report a bug if sb pmax sv pmaxorsv pmin where vis the index variable and bis the size of the accessed buffer.
in addition a buffer access is guaranteed to be within buffer bounds only if sv pmax sb pmin 1a n d0 sv pmin.
otherwise the buffer access is a potential buffer overflow that cannot be solved by our analysis.
in this section we report on thepercentage of potential buffer overflows which suggests the limitations of our approach and gives us a hint about howmany buffer overflows may be missed.
benchmark potential buffer overflows asterisk .
.
.
.
openjdk b51 .
openbsd .
.
opensolaris on b105 .
table the percentage of potential buffer overflows that cannot be solved by our analysis.
table summarizes the percentage of potential buffer overflows for all applications.
for asterisk openbsd and opensolaris on close or below of all buffer accesses were potential buffer overflows that could not be solved by our analysis.
the percentage increased to just over for openjdk.
we manually looked into some of the po tential buffer overflows and found that most of them were not solved due to the same limitation of our implementation in handling pointer types and memory dependencies.this also suggests the worst behavior in openjdk where precise points to information is harder to get because of its extensive usage of c templates.
.
conclusion in this paper we presented a new symbolic analysis technique for buffer overflow detection and evaluated it using large systems applications.
we demonstrated that the simple symbolic value representation is effective for buffer over flow detection and symbolic values could be precisely computed by iteratively solving data dependencies and linearlyrelated control dependencies together.
we also showed that by being demand driven and using simple algebraic rules the symbolic values could be computed very efficiently.
our experimental results against large systems applications suggested that this technique is simple yet effective 325it was easy to implement and found hundreds of buffer overflows in large well tested codebases with a false positive rateof around .
this makes the technique feasible for implementation in existing compilers to identify vulnerabilities at the earliest stage of software development.
in addition to buffer overflows our analysis can be applied to detect other important vulnerabilities such as inte ger overflows.
it can also be applied to analyze the bounds of shared memory regions to detect potential data races.
.