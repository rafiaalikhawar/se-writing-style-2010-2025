plasma a plan based layered architecture for software model driven adaptation hossein tajalli joshua garcia george edwards and nenad medvidovic computer science department university of southern california los angeles ca usa tajalli joshuaga gedwards neno usc.edu abstract modern software intensive systems are expected to adapt often while the system is executing to changing requirements failures and new operational contexts.
this paper describes an approach todynamic system adaptation that utilizes plan based and architecturebased mechanisms.
our approach utilizes an architecture description language adl and a planning as model checking technol ogy to enable dynamic replanning.
the ability to automaticallygenerate adaptation plans based solely on adl models and an ap plication problem description simplifies the specification and use of adaptation mechanisms for system architects.
the approach uses a three layer architecture that while similar to previous work pro vides several significant improvements.
we apply our approachwithin the context of a mobile robotics case study.
categories and subject descriptors d. .
design tools and techniques d. .
software architecture general terms design management reliability keywords self software adaptation software architecture software evolu tion planning model driven software component based software .
introduction modern software systems are increasingly expected to satisfy high reliability and availability requirements.
in particular thesesystems are expected to alter and extend their functionality handle failures of software and hardware components and apply updates and bug fixes while the system is executing.
to provide these capabilities several software architecture based self adaptive and self aware systems have beenproposed in the literature.
a software architecture based approach permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.to dynamic system adaptation has several advantages.
architecturebased approaches utilize composition hierarchy and abstractionto reduce complexity and increase scalability.
furthermore a richarea of existing work on software architecture modeling and anal ysis can be exploited.
for example architecture description lan guages adls can be used to specify a system that must undergo runtime adaptation and architectural analysis techniques can be used to examine the implications of system adaptations.
previous work in self adaptive and self managing systems can be categorized across two prevalent adaptation mechanisms poli cies and plans.
policies are sets of condition action rules that spec ify how the system should be modified when a specific condition is met.
an example is the policy based approach to architectural adaptation management pbaam .
on the other hand plansare sequences of actions that achieve a high level goal.
plans areautomatically generated by finding a path from the current systemstate to a goal state in a model of the system domain.
sykes et al.
s three layer model is an example of a plan based approach.
thus far plan based approaches have been limited to precomputed plans for application adaptation and have lacked the abil ity to dynamically generate new plans when system requirementschange.
furthermore planning mechanisms have only been ap plied to core application functionality and have not been applied to application architecture adaptation.
these approaches are thus unable to dynamically compute new adaptation plans that are usedto modify application architectures in response to unforeseeable events such as new system requirements a change in the executionenvironment or an unexpected type of failure.
in this paper we introduce plasma a plan based layered architecture for software model driven adaptation .
plasma utilizes an adl and a planning as model checking technology toenable dynamic replanning in the architectural domain.
we utilizeadl models and system goals as inputs for generating plans.
inparticular our solution has the ability to generate new plans in re sponse to changing system requirements and goals and in the case of unforeseeable component failures.
the contributions of our paper are twofold.
first we show how planning techniques can be applied not only to application func tionality but to application architecture adaptation which resultsin the ability to automatically modify application architectures in order to achieve a system goal when the current architecture is inadequate.
second we show how dynamic replanning can be usedwhen the application domain or system goal changes which resultsin the ability to automatically handle unexpected circumstances.
the rest of the paper is organized as follows.
section describes our framework s architecture and plasma s use of domain models component models and planning.
section details plasma s design and implementation.
section demonstrates how we ap 4unlock lock load lock unload unlock loaded lockedloaded locked a unload 4unlocklockload lock unload unlock loaded locked5 adjust loadedmisplaced b lockedload figure a an example application domain model.
b the example extended with an additional capability.
plied plasma in a mobile robotics case study and discusses the benefits observed.
section covers the related work and section 6concludes the paper.
.
approach in this section we provide a high level summary of the plasma approach to automated self adaptation and self management forsoftware systems the details of plasma s design and implementation are then provided in section .
first we explain the two types of domain models that are utilized in plasma applicationdomain models and adaptation domain models.
second we de scribe how plasma leverages an adaptive layered architectureto achieve a high degree of autonomy and a clear separations ofconcerns.
third we discuss the role of architectural modeling in plasma.
lastly we describe how plasma applies planning techniques to realize dynamic replanning in a self adapative sys tem.
.
domain models plasma is based on the novel application of planning mechanisms to two different types of models application domain modelsandadaptation domain models .
application domain models capture the possible states of application components and actionsthat those components may perform.
each action modifies the application state in a defined way.
analogously adaptation domain models capture architectural states and actions each state in theadaptation domain model corresponds to a particular architecturalconfiguration and actions in the adaptation domain model corre spond to architectural modifications such as the addition removal and replacement of components.
while previous work has applied planning to application domains plasma is unique in its usageof adaptation domains.
both application domain models and adaptation domain models consist of the states of the domain available actions in the domain and the state transitions caused by those actions.
therefore a domain model is formally defined as a tuple f s a r in which fis a finite set of fluents which represent the state variables of the system s fis a finite set of states ais a finite set of actions andr s a mapsto sis a transition function.
figure depicts two example application domain models.
the first application domain model represents a system where an item can be loaded unloaded to from a container which in turn can belocked unlocked.
figure a is a graphical presentation of the domain model for this example in which loaded andlocked are the fluents of the domain circles represent the states and arrows rep resent the actions as well as system transitions in the model.
thelabel assigned to each state in this figure is the conjunction of thefluents which are true in that state.
for the case where a system re quirements change occurs consider the domain model depicted in figure b .
in this figure a new fluent called misplaced and a new state are added to handle the case where an item may be misplaced.
figure depicts an example adaptation domain model.
in this example domain software components can be instantiated killed added removed to from an architecture and connected disconnect ed to from another component in that architecture.
the states of this adaptation domain model are the various architectural configurations involving c1 and c2.
for example state corresponds toan architecture in which c1 and c2 exist but are not connected.
in the remainder of this section we show how these two types of domain models are utilized for software adaptations in plasma.
.
adaptive layered architecture in our approach we leverage the adaptive layered architectural style which was introduced in our previous work .
traditionally layering implies that components at a given layer invoke the services of components at the layer below.
in contrast components at a given layer in the adaptive layered style monitor man age and adapt components at the layer below.
adaptive layered systems consist of application level components and meta level components.
application level components implement functionality that achieves the application goals.
meta level components aredesigned to handle operations that deal with monitoring analysis and adaptation.
meta level components can be one of three types collectors analyzers o radmins .collectors monitor components analyzers evaluate adaptation policies or plans based on monitored data and admins actually modify components.
although the adaptive layered style allows for layering of arbitrary depth plasma employs three adaptive layers as shown infigure .
application level components reside in the bottom application layer .
the middle layer called the adaptation layer monitors manages and adapts components in the application layer.
the topmost planning layer manages the adaptation layer and the generation of plans based on user supplied goals and component speci fications.
the plans generated by the planning layer define both thetarget architecture for the application layer the adaptation plan and the actions to be carried out by the application layer the application plan .
therefore the planning layer is capable of responding to changing system requirements or operational environments by regenerating plans.
this three layered architecture enforces a clearseparation of concerns whereby each layer in the system providesa different form of adaptation capability and enables a high degreeof autonomy.
in plasma the only inputs provided by the system architect are the application problem description component spec ifications written in an adl and executable implementationsof the components.
the problem description consists of an initialstate and a goal.
the component adl models are used by the adl model parser components in the planning layer to generate application and adaptation domain model descriptions as depicted in figure .
a domain model description presents a domain modelin a standard language which is required for planning.
domainmodel descriptions along with the problem description are pro vided to the application planner andadaptation planner components depicted in the planning layer in figure .
each of these two components generates a plan for one of the two bottommost lay instantiate c1 8kill c1 add c1 remove c1 kill c2 instantiate c2 remove c2 add c2 kill c2 instantiate c2 instantiat c1 kill c1 remove c2 add c2 add c1 remove c1 disconnect c1 c2 connect c1 c2 exist c1 exist c2 exist c2 exist c1 exist c1 exist c2 archincludes c2 exist c1 exist c2 archincludes c1 exist c1 exist c2 archincludes c1 archincludes c2 exist c1 exist c2 archincludes c1 archincludes c2 connected c1 c2 figure an example adaptation domain model.
sensor sense executor compute loader control domain stateadaptation analyzer compute analyzer compute arch stateaction req application componentapplication layeradaptation layerplanning layer key event collector analyzer adminlocker control adaptation planner arch stateaction req action reqaction reqcollector sense referenceapplication planner admin control adaptation layer architectureadl model parseradl model parser adaptation problemadaptation domain descriptionapplication domain descriptionapplication problemapplication layer adl modelsadaptation layer adl models admin control collector sense adaptable entity figure the plasma adaptive layered architecture.
ers the application planner generates a plan for the application layer which specifies how to achieve the application goal whiletheadaptation planner generates a plan for the adaptation layer which specifies how to arrive at the target application architecture.
each of the two bottommost layers contain a special component that executes the plans generated by the top layer s planner compo nents.
the adaptation layer contains an adaptation analyzer that executes plans generated by the adaptation planner .the adaptation analyzer uses the plan to determine how and under what conditions components in the application layer should be added removed replaced or otherwise altered.
the application layer con tains a special component called the executor which executes plans generated by the application planner .
the executor examines the state of application components and based on their state and theplan received from the application planner invokes the functionality of application components to perform tasks.
.
architectural modeling as previously noted components in plasma must be specified in an adl and passed to the adl model parsers in the topmost layer in figure .
adl models are used to generate domain model descriptions which are required for planning.
to be able to generate domain models from adl models the adl used must carryenough information from which a tuple domain model f s a r can be extracted.
consequently component descriptions in the selected adl should include the ability to specify attributes required and provided interfaces and pre and post conditions of each interface.
this information is used by the adl model parsers to generate domain model descriptions which are passed to the appropriate planner component.
in particular the adl model parser will generate a domain model by mapping attributes to fluents f interfaces to actions aand by utilizing pre and post conditions of interfaces to determine states sand the transition function r. instead of explicitly and possibly rigidly specifying the structure of the application s architecture plasma infers thetopology of the application layer from the plan and the componentadl models.
to this end required and provided interfaces are usedto discover component dependencies and thus determine required components in the architecture.
we should point out that any adl that includes this information can be used with plasma giventhe appropriate adl model parser .
the use of adl models in plasma results in several benefits.
first whenever components are added removed or replaced new plans can be automatically generated to achieve the goals of the system.
in particular adl model changes result in domain model changes which in turn initiate replanning.
second changesto requirements represented in changes to component model de scriptions can be handled during runtime.
this particular benefit isobtained because the domain models that are generated from adlmodels serve as a requirements specification of the system.
in the next section we describe how the planners in figure use domain model descriptions to create plans for both the applicationand adaptation layers.
.
planning the behavior of the application and adaptation layers in plasma are planned in order to achieve the high level goal ofthe application layer specified by the system architect i.e.
theplasma user .
the two bottommost layers receive the plans fromthe planning layer.
the planning layer generates different kinds ofplans for the application and adaptation layers.
each of these plans is generated from its own domain model description.
the plannercomponents in the top layer accept the domain model description and a planning problem as inputs to generate a plan.
we maintain a clear separation of application and adaptation concerns by sep arating planning among the two different kinds of planners in theplanning layer.
a planning problem is the problem of arriving at a goal from an initial state.
the goal is represented by a set of conditions on the domain model fluents and corresponds to a set of goal states where those conditions are true.
the generated plan is a set of state actionrules which specify the actions to be taken from each state to reacha goal state.
the plan is sufficient to determine a path from anypossible initial state to a goal state.
the application goal is a set of conditions provided by the system architect.
the application planner first finds an application plan that specifies how to achieve the application goal from a givencurrent application state.
the application planner then derives the target architecture topology of the application layer requiredto run that plan using an algorithm specified in section .
the cur rent architectural topology and the target architecture topology of the application layer form the inital and goal states of the adaptation problem respectively.
consequentely the adaptation planner finds an adaptation plan that transforms the current architecture ofthe application layer to the desired architecture.
the application plan and adaptation plan are executed in the following way.
recall that the adaptive layered style includes metalevel components collectors analyzers and admins that respectively monitor analyze and modify components in the layerbelow see figure .
.
the collector at the planning layer determines the current architecture of the adaptation layer which is initially empty .the planning layer analyzer computes an architecture for the adaptation layer i.e.
what collectors analyzers and admins are needed .
the planning layer admin instantiates and deploys the adaptation layer components.
unlike the appli cation layer the topology of the adaptation layer is providedto the adl model parser component in the planning layer i.e.
it is not planned but is rather pre defined as shown in figure .
.
the instantiated adaptation layer architecture will include an adaptation analyzer that contains the adaptation plan and logic for executing it.
the adaptation analyzer executes the plan by instructing the adaptation layer admin to make modifications to the application layer architecture by instantiatingcomponents establishing connections etc.
adaptation layercollectors monitor the application architecture if it changes unexpectedly the adaptation analyzer can use the adaptation plan to return to the target application architecture.
.
the instantiated application layer architecture will include an executor that contains the application plan and logic for executing it and one or more sensors .sensors monitor the current state of the system i.e.
the domain fluents and pass thisinformation to the executor .
the executor uses the values of the fluents to determine the appropriate action to perform according to the application plan.
adaptation in our approach is achieved automatically through dynamic replanning and is not pre programmed by the system ar chitect.
dynamic replanning can be initiated either by the systemarchitect or by unexpected changes to the domain models e.g.
dueto component failures .
adaptation of the application layer occurs whenever the adaptation goal and or adaptation domain modelfigure the high level design of prism mw.
change.
these changes could in turn be caused by a change to the application goal and or the application domain model.
the firstcase application goal change is initiated by the system architect who may provide a new application goal to the system at any time.in the second case application domain model change a new component becomes available e.g.
a new version is introduced or a component becomes unavailable e.g.
due to a failure .
the planning and adaptation layers achieve a high degree of autonomy and flexibility and also reduce the burden on the architect.the adaptation layer maintains a high degree of autonomy by uti lizing automatically generated plans to adapt the application layer.
placing the onus of automatic adaptation onto the adaptation layer reduces the burden of design on the architect because she need notmanually specify plans for each adaptation scenario.
moreover our approach offers significant flexibility by giving the architectthe ability to specify the adaptation requirements via adl modelsof specific components in the adaptation layer.
.
design and implementation in this section we describe the detailed design and implementation of plasma.
in particular we discuss the middleware adl and adl tool support we utilized as well as the tools we leveragedfrom the planning domain.
.
adaptive layered architectures in plasma as mentioned in .
we leveraged the adaptive layered style introduced in our previous work .
as described in we extendedanarchitectural middleware platform called prism mw to support adaptive layered architectures.
prism mw is a lightweight middleware implemented in java and c .
the high level design of prism mw is given in figure .
the key building blocks ofprism mw are the architecture component andconnector classes.
anarchitecture object serves as a run time container for a topology ofcomponents andconnectors .components implement application services while connectors implement interaction oriented services.
components andconnectors communicate by exchanging events via ports .
prism mw is particularly well suited to plasma because it natively supports dynamic system adaptationby decoupling components via dynamically instantiable ports andevent based interaction.
the full description of this platform is be yond the scope of the current paper and may be found in .
the extended version of prism mw which is introduced in figure the sadel specification for the loader component.
includes three specialized meta level component types collectors analyzers and admins .
meta level components have access to the internal representation of a currently running architecture.
we callcomponents with this kind of access architecturally aware.
collectorsandanalyzers have read only access to the architecture while admins have read write access and are allowed to adapt the architecture.
moreover the extended version of prism mw defines a meta level architecture type which is used as a container for the meta level components.
each meta level component in a meta level architecture possesses a reference to the architecture that im plements the layer immediately below it.
we evolved and extended the meta components of the adaptive layered style to run application and adaptation plans in plasma.
as envisioned in analyzers evaluate the adaptation policies based on monitoring data and triggered adaptation operations whenrequired.
these policies and plans were designed and implementedby application developers and were hard coded in the analyzer .
therefore analyzers were not very flexible and did not provide a high degree of automation.
furthermore they tended to be complex which made them time consuming and error prone to generate.
in contrast the adaptation analyzer in plasma is an extended version of the one in it is capable of running automat ically generated plans.
we also modified the collector andadmin components to match the interfaces of our adaptation analyzer .
.
architectural modeling in plasma to support architectural modeling in plasma we adapted and extended c2sadel an adl introduced in .
we chose thislanguage because it meets the requirements discussed in .
.
more over it supports system analysis and evolution.
this language wasoriginally designed to support the c2 architectural style a layered and event based style.
furthermore we modified the componentbased dradel environment used to support modeling anal ysis evolution and implementation of architectures described inc2sadel.
dradel supports component evolution via subtyp ing architectural consistency and type checking and code gener ation.
we extended c2sadel and created sadel as the adl forplasma.
as discussed in .
prism mw supports the implementation of the layered component based architecture of plasma.
therefore we designed sadel to support the event based stylewhich is the basic style supported in prism mw.
compared to c2 the event based style covers a wider range of applications and pro vides a higher degree of flexibility in architectural design thoughat the cost of some analyzability as discussed in .
just like in c2sadel an architectural model in sadel has three major parts component types connector types and a topology .
the topology defines the component and connector instances and their in terconnections.
components define state variables interfaces andprovided and required operations.
each interface is mapped toan operation.
in turn each operation specifies the pre and postconditions of its invocation in terms of first order logic expressions involving state variables.
operation definitions in sadel spec ify conditional and non deterministic post conditions which arerequired for the generation of domain models.
component mod els in sadel also include version information which allows theplanning layer to distinguish between evolved updated components and adapt the architecture accordingly.
an example sadel specification of the loader component is given in figure .
loader has two interfaces load and unload .
these interfaces are mapped to actions ain the application domain model.
loader has two boolean state variables called loaded andlocked .
these variables are mapped to fluentsfin the domain model.
finally pre and post conditions are specified for the load andunload interfaces.
for example load has the pre condition not loaded and not locked and post condition loaded .
plasma provides support for modeling analysis evolution and implementation of components and architectures described in sadel by enhancing dradel and integrating it with otherplasma components.
we ported dradel s components toprism mw and adapted their interfaces to match plasma com ponents in the planning layer.
the enhanced dradel compo nents integrated into plasma support modeling and analysis in the event based as opposed to c2 style and code generation for prism mw as opposed to c2 s custom built architecture imple mentation framework .
incorporation of the extended dradelcomponents enables plasma to perform consistency and type analysis on application layer architectures further explanation ofdradel s analysis capabilities can be found in .
these components also provide additional features not supported by dradel originally.
for example plasma supports component evolutionvia subtyping and version control.
.
planning in plasma we used the model based planner mbp a planning tool for non deterministic domains to support planning in plasma.
mbp implements the planning as model checking technique introduced in .
the fundamental idea behind planning as model checking is to generate plans by checking the correctness of for mulas in a model.
to find a plan to reach a goal state in a do main mbp uses a problem description and a domain model de scription specified in npddl an extended planning domain description language.
the problem description determines what kind of plan weak strong strong cyclic etc.
is required for theapplicaion.
in the rest of this section we describe how planning occurs at the application and adaptation layers.
more specifically we describehow plasma deals with initialization of architectures topology determination and goal or adl model changes.figure an npddl domain model description for the example domain.
.
.
application planning in plasma the npddl application problem description initial state and goal is provided by the user while the npddl ap plication domain model description is created automatically from the sadel models of application components by the adl model parser recall figure .
for illustration the npddl specification of the application domain model depicted in figure a isshown in figure .
this npddl spec is derived from the sadelmodels of the loader andlocker .
for example the loaded and locked state variables of the loader in figure are mapped to the loaded andlocked predicates in figure while the load andunload interfaces are mapped to the load andunload actions.
similarly the npddl pre conditions and effects of theseactions are mapped from the pre and post conditions of the respec tive sadel interfaces.
once the npddl application domain model has been generated it is passed along with the npddl problem description to the application planner which generates the application plan if there is a path from the initial state to the goal state in the applicationdomain model.
if there is no such path plasma notifies the ar chitect so that she can modify the problem or the set of avaliablecomponents.
in our example domain assume an initial state in which no item is loaded in the container and the container is not locked loaded locked .
this state is shown as state in figure a .
also assume that the application goal is to load anobject into the container and lock it.
this goal is represented asstate loaded locked in figure a .
the application plannergenerates a plan in the form of a set of state action rules which should be followed to arrive at the goal.
in this example the plancontains the following pairs unlock load lock .
thisplan is interpreted as follows to get to state the following actionsmust occur unlock action on state load action in state andlock action in state .
although this is a simple example richer applications have much longer plans and may have multiple plans to reach a goal.
plasma reduces the burden on the architect bydetermining these plans automatically.
next to be able to run the application plan in the application layer the required components for the plan and their topology mustbe determined.
the responsibility of determining the topology of the application layer is placed upon the application planner com ponent.
the application planner determines the components which are required to complete the plan by examining the actions used in the plan.
the application planner computes all the components possible dependencies by matching their required and provided in terfaces and creates a topology according to those dependencies.as a result the architect no longer bears the burden of specifyingthe topology of the system.
in the example domain from figure a the application plannerdetermines the target application layer architecture in the following way.
as previously mentioned to get to state from state 2the following plan p1should be run unlock load lock .
the loader andlocker have the load lock andunlock interfaces that match the actions of p1 so these components are included in the architecture.
recall that the application layer always includes an executor that runs the application plan by invoking the interfaces of application components such asloader andlocker .
consequently the loader andlocker are connected to the executor .
finally the executor must know the values of domain fluents in order to determine the appropriate actions.
consequently a sensor is added to the architecture to monitor each fluent and each sensor is connected to the executor .
this target architecture produced by the application planner is passed to the adaptation planner in the form of an adaptation problem initial architecture and goal architecture .
an application plan runs in the following manner.
the sensor component tracks the domain fluents i.e.
locked andloaded in our example.
changes to these values are pushed to the executor.
the executor uses the values of the fluents to determine the appropriate action to run based on the plan.
the actions are per formed by invoking the interfaces of either the loader orlocker components.
this process is repeated until a goal state is reached.
a high degree of autonomy is maintained since the plan is run bytheexecutor without any involvement from the architect.
while the previous discussion describes plan execution in the case where the goal of the system remains the same a change to thegoal requires replanning.
application replanning followed by software adaptation occurs automatically in plasma.
in figure a the application layer goal can be changed from loaded locked to loaded locked .
this change initiates replanning which results in the following application plan unlock unload lock .
the adaptation layer updates the executor component in the application layer to run the new plan.
to reiterate the application layer and its key components are designed to ease the burden of design on the architect maintain ahigh degree of autonomy for the software system and handle non deterministic domains.
.
.
adaptation planning adaptation plans are generated by the adaptation planner in the planning layer.
adaptation plans describe how to initialize the architecture which includes the creation and connection of components.
the adaptation planner requires an npddl adaptation problem generated automatically by the application planner and an npddl adaptation domain description specified by the systemarchitect to create an adaptation plan.
adaptation plans are alsocomputed by mbp using the same algorithm used to compute application plans.
figure shows an example adaptation domain model with two components.
in our implementation we utilized meta level com ponents admin andcollector to perform the actions and monitor the fluents in the adaptation domain model.
more specifically inthe specific example depicted in figure the admin component performs the instantiate kill add remove connect and discon figure npddl domain model description for the example adaptation domain.
nect actions in the adaptation domain and the collector detects the exist archinclude and connected fluents.
the adaptation plan is executed and managed by the adaptation analyzer from figure .
the adaptation analyzer executes an adaptation plan autonomously by reading fluents from the collectorin the layer it resides in and by sending appropriate adaptation actions to be performed by the admin .
therefore adaptation planning and adaptation take place automatically and the application architects only deal with the adaptation layer requirements and design.
in situations where a new adaptation analyzer is needed e.g.
in the case of an adaptation plan change the planning layerinstantiates a new adaptation analyzer for the adaptation layer.
an adaptation plan in our running example executes in the following manner.
the application layer is initially empty and the goal state of the application plan has a loader alocker and a sensor whose interfaces are connected to the executor component.
thus the adaptation plan contains actions such as instantiate locker instantiate executor instantiate sensor connect locker executor to connect component interfaces and so on.
figure gives the instance of our layered architecture after the adaptation plan was run and the application layer was set up.
once an initial application layer architecture has been instantiated two situations may result in adaptations to the applicationlayer modifications to the component sadel models and com ponent failures during runtime which may result in changes to the npddl domain models .
plasma supports these dynamic adaptations through replanning.
the first cause of replanning is a sadel model change which occurs when system requirements evolve.
for example to handlea new requirement to perform adjustments to the container a newcomponent called adjuster is added to the system with an interface to perform the adjust action.
the sadel model is changed to reflect the addition of the adjuster component.
this sadel model change generates a new npddl application domain modeldescription which initializes replanning.
a new application planis found automatically and the application planner from figure uses the new plan to derive a new application layer architecture that contains the adjuster component.
at this point a new adaptafigure robots convoying in the case study.
tion problem is generated and passed to the adaptation planner .i n this adaptation problem the initial state is the current applicationlayer architecture and the goal is the new target architecture.
con sequently the adaptation planner creates a new adaptation plan which changes the architecture from the current topology to the new topology.
this plan contains an action to add the adjuster .
the second cause of replanning is a failure of an application component.
as an example the adjuster component may fail at run time.
in this case the executor fails to successfully run the plan and the adaptation layer detects the component failure throughitscollector .
the adjuster is removed from the adl model resulting in a change to the npddl application domain model description which in turn initiates replanning and the deployment of anew architecture that does not rely on the failed component.
how ever if a component failure makes it impossible to achieve the goal plasma reports the failure to the architect.
plasma aims to reduce the burden of design placed upon the architect by preventing the architect from having to directly deal with architectural topology and adaptation plan specification.
thearchitect does not need to anticipate all possible adaptation scenar ios or pre program adaptation plans.
plasma is independent ofthe adaptation requirements and allows the user to provide any setof meta level components for the adaptation layer.
the meta level components in the adaptation layer can be different for different adaptation domains which provides further flexibility for the sys tem s design.
for example a domain requirement can enforce dis connection of components in a particular order to ensure minimumdisturbance to the system during runtime adaptation.
plasma isable to natively include support for such a requirement.
.
case study in order to demonstrate the contributions and effectiveness of plasma we have leveraged a family of robot based systems developed in collaboration with a third party organization .
in this section we first describe how component model changes goalchanges and failures in a selected application scenario result insystem adaptations.
.
application scenario our robotic application consists of three or more robots that form a convoy and follow a leader robot.
the leader robot is providedwith a path to follow in the form of a series of spatial coordinatescalled waypoints .
each follower robot uses on board sensors to track the robot immediately ahead of it in the convoy and followadaptation layerdesktop computer planning layer application layerrobot robot executercolorfollower rolenegotiatorrobotactuatoradaptation layer application layer executercolorfollower rolenegotiatorrobotactuator figure the deployment view of the case study architecture.
figure a snippet of the generated application plan for the robot following case study.
it.
this type of autonomous convoy is a common use case for mobile robotics having applications in transportation inventorymanagement automated farming and other areas.
each robot in our case study consists of an irobot create mobile programmable robot an attached ebox embedded computer running fedora linux a camera a gps receiver an infrared ir receiver and an ir transmitter.
also the irobot platform includesa front bumper sensor that detects when the robot has run into anobstacle while the ebox includes a .
wireless lan adapter.a picture of the robots is shown in figure .
initially we provided plasma with the sadel models of the following components rolenegotiator waypointfollower camerafollower gpsfollower gpsleader irfollower irleader andobstacleavoider .
the rolenegotiator implements a distributed negotiation to assign a role leader or follower to all robots in theconvoy.
the negotiation protocol ensures that only one robot can be assigned the leader role.
assignment of a role is a precondition for using any of the following components.
only the leadermay use waypoint following and only followers may use the othertypes of following.
gpsfollower andirfollower require transmissions from a gpsleader andirleader in the followed robot respectively.
gpsleader transmits coordinates over the wireless lan while irleader emits an ir signal these components arepulled into the target architecture as required interfaces of their respective follower components.
as long as the robots are suc cessfully following waypoints or another robot they set the fluentisfollowing true.
whenever a robot gets stuck behind an obstacle behindanobstacle true and the obstacleavoider is invoked which implements an algorithm to move around an obsta cle and bring the leader back into view.
in addition to the abovecomponents seven other sensor and actuator components are spec ified in sadel.
the interfaces of these components are requiredto read sensor values steer the robot wheels etc.
we specified an npddl problem description in which the goal is isfollowing behindanobstacle .
the plasma planning layer recall figure which is deployed on to a laptop generatesan npddl application domain model application plan adaptationdomain model adaptation goal target architecture and adaptationplan.
the planning layer also automatically generates and compiles implementation code for an adaptation analyzer andexecutor.
the plasma planning layer then deploys compiled binaries of all required components application components provided bythe architect adaptation analyzer admins collectors etc.
and instantiates an identical adaptation layer on each robot.
the adaptation layer on each robot instantiates the application layer and the executor begins execution of the application plan in which the first step is role negotiation.
the deployed architecture is depicted infigure .
as long as all robots are successfully following the application remains in the goal state and the executor does nothing.
when an obstacle is encountered the application is moved out of its goal state and the executor invokes the obstacleavoider component.
furthermore basic types of adaptations are automatically handledby the executor .
for example if a robot is using camera following and the area becomes too dark the executor can use the application plan to automatically switch to gps or ir following.
similarly gps following does not work indoors while ir following does not work at large distances.
the executor automatically handles these situations according to the application plan.
a snippet of the ap plication plan is shown in figure .
this small part of the planshows instances in which the robot is assigned a leader an obstacleis avoided during waypoint following and robots start camera or ir following.
the complete plan included state actions and took 300ms to generate on a mid range computer.
the initial adaptationplan was generated in .59s and included state actions and 15components.
more powerful forms of adaptation require dynamic replanning.
consider the case where a new system requirement is introduced at run time in which the robots are required to recharge their batter ies using docking stations along the route.
if any robot has batterypower less than the convoy is required to temporarily halt while that robot leaves the convoy docks at the station charges and returns.
to satisfy this requirement we specified new sadelmodels for a batterymonitor and stationdocker .
adding these sadel models evolves the npddl application domain modeldescription.
at this point the architect can either initiate replan ning or let the current plans continue to run.
however the current goal of the system does not imply that charging should be performed so replanning does not change the application.
there fore we also specified a new application goal isfollowing behindanobstacle batteryislow and then initiated replanning.
plasma computed new plans and regenerated and re deployed the adaptation analyzer andexecutor components along with the other required application components.
extending the requirements of the application in this way increased the number ofstate actions in the application plan to and increased the gen eration time to .2s.
the adaptation plan contained differentstate actions and took .89s to generate.
different types of failures can also cause adaptation and or replanning within the application and adaptation layers depending on the type and severity of each failure.
for example if the obstacleavoider component unexpectedly terminates due to a transient software bug the current architecture of the application layerchanges and is no longer equivalent to the target architecture.
thecollector in the adaptation layer detects this and notifies the adaptation analyzer which directs the admin to perform an instantiate obstacleavoider action according to the adaptation plan.
thus this particular failure results in automatic adaptation without re planning.
however if the camera on one of the robots fails thecamerafollower cannot be reinstantiated.
in this case the npddl application domain model is regenerated without the camerafollower component resulting in new application and adaptation plans that do not utilize the camera.
the new application plan for thisscenario was generated in 400ms and included state actions the corresponding adaptation plan had state actions and wasgenerated in .74s.
.
discussion our case study demonstrates how plasma enabled applications transparently adapt to both foreseeable andunforeseeable conditions and requirements.
foreseeable conditions requiring adapta tion such as the failure of an unreliable component or the abilityto perform object following in the dark are built into applicationand adaptation plans.
consequently adaptations that handle theseconditions are automatically realized without incurring the performance penalties of replanning.
unforeseeable conditions and requirements such as an unexpected type of failure or the need torecharge are addressed through replanning directed by the systemarchitect.
replanning incurs a performance penalty but the situa tions where it is required are relatively rare and the alternative shutting down the application for an upgrade for example may be worse.
the replanning times of 6s in all cases and 1s in somecases were well within the acceptable bounds for our case study.the ability to handle unforeseeable conditions and requirements inthis manner sets plasma apart from similar approaches.
plasma is also designed to simplify the task of specifying when and how the system should adapt.
automatically generated plans in our case study ranged from to state actions.
man ually specifying policies of this size would be tedious and cumber some for the architect.
to handle the goal change in the rechargingexample of our case study for example we only needed to specifytwo additional sadel models lines total and a new npddl problem description line of change along with the implemen tations of the two new components.
moreover the system architect maintains control over the process.
the adaptations that result from new architect requirements are realized transparently but the adap tations are only performed when the architect decides it is safe andappropriate to do so.
other types of adaptations such as foresee able adaptations and failures are handled without architect inter vention.
the use of planning within plasma has a number of natural benefits which can be seen in the case study.
first a policy based approach can result in policies that conflict with each otheror collectively make it impossible for the system to achieve itsgoal.
both of these situations cannot arise in plasma s planning based approach if system constraints make the goal unachievable plasma automatically notifies the architect before any adaptations are performed.
second the adaptation plans generated inplasma preserve all software adaptation restrictions and require ments specified in the adaptation domain model.
these require ments restrict architectural adaptation based on platform or appli cation constraints.
for example the adaptation plan in our case study removes the camerafollower after disconnection from the executer in order to avoid a dangling port in the executer which can lead to communication failures.
.
related work oreizy et al.
introduced the concept of runtime software adaptation for architecture based systems in .
in their follow up work they reviewed and examined a larger number of adaptation approaches suggested in the decade hence.
in this section we restrict ourselves to architectural approaches that rely onplans or policies.
readers are encouraged to refer to formore related work.
among the policy based approaches to self adaptive systems the most closely related approaches are pbaam and aura .
aura is a task oriented as opposed to plasma s goal oriented self adaptive approach that considers qualities of service as pri mary factors to determine when to adapt a system.
besides usingmanually specified policies rather than automatically generatedplans aura does not utilize adls.
georgas et al.
intro duced the pbaam approach to self adaptive systems.
pbaam is unique in its ability to dynamically evolve policies during runtime.
however the user is still required to manually specify architecturaladaptations which places more burden on the architect as com pared to the automatically generated plans by plasma.
salehie et al.
provide a taxonomy for self adaptation and discuss opportunities for novel research in that area.
they point out that few approaches utilize ai planning techniques for selfadaptive systems.
srivastava and kambhampati discuss theuse of planning techniques for installing and running applicationsautonomously.
however their suggested use of planning for self adaptive systems does not take an architectural perspective specifically their work does not cover addition removal or replacement of components or connectors .
arshad et al.
provide aplanning based framework for failure recovery in distributed sys tems.
although plasma also aids in failure recovery arshad etal.
s technique utilizes a dependency model to determine the ex tent to which a failure may propagate through a system.
however their framework requires the architect to directly work with domain models while plasma extracts domain models from adl mod els.
furthermore dynamic addition of new components or servicesis not supported by their technique.
in a follow up approach ar shad et al.
provide a framework called planit for deploymentand reconfiguration of distributed systems using ai planning.
similar to plasma planit takes an architectural perspective by usingcomponents and connectors for deployment and reconfiguration.
however planit only handles starting stopping and connecting of components and connectors but not their addition removal and re placement.
furthermore like their previous approach planit mod els components and connectors directly in domain model descrip tions.
the most closely related approach to plasma is the approach of sykes et al.
in .
both sykes and our approaches are capable of selecting an appropriate topology for the software system sarchitecture during runtime from an adl model.
plasma andsykes approach also both use planning as model checking tech niques.
plasma differs from sykes approach in several keyways however.
first their proposed system is not capable of replanning in the case of a domain description change or system goal change.
second their approach generated plans for application specific functionality but those plans cannot handle replacement addition or removal of components.
third sykes approach uti lized pre programmed adaptation plans while our approach gener ates such plans on the fly.
fourth sykes approach and plasma differ in their utilization of domain models domain models must be specified in sykes approach while plasma generates thesemodels from adl models.
consequently the architect does notdirectly deal with domain models in plasma.
.
conclusion and future work in this paper we introduced an approach to software adaptation that utilizes modeling and planning techniques in a meta layeredarchitecture for self adaptation.
our approach simplifies the spec ification and use of adaptation mechanisms for system architectsby freeing them from having to design the application architecturetopology and plan for specific adaptations.
as a result the architect avoids the difficulty of designing plans for unforeseeable conditions such as changing requirements and runtime failures.
one of the benefits provided by mbp is planning for temporally extended goals.
these kind of goals not only specify the de sired final state of the domain but also specify the conditions whichshould hold during the execution of the plan.
in the future we will study and leverage this property to address non functional requirements and quality properties more rigorously in plasma.
inaddition we will investigate how to leverage contingent planningtechniques to reduce the frequency of replanning.
.