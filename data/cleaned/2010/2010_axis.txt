axis automatically fixing atomicity violations through solving control constraints peng liu charles zhang department of computer science and engineering the hong kong university of science and technology lpxz charlesz cse.ust.hk abstract atomicity a general correctness criterion in concurrency programs is often violated in real world applications.the violations are difficult for developers to fix making automatic bug fixing techniques attractive.
the state of the art approach aims at automating the manual fixing process butcannot provide any theoretical reasoning and guarantees.
we provide an automatic approach that applies well studied discrete control theory to guarantee deadlocks are not introduced and maximal preservation of the concurrency of the original code.
under the hood we reduce the problem of violation fixingto a constraint solving problem using the petri net model.
our evaluation on subjects shows that the slowdown incurred by our patches is only of that of the state of the art.with the deadlock free guarantee our patches incur moderate overhead around which is a worthwhile cost for safety.
i. i ntroduction for concurrent programs using shared memory atomicity is a widely used correctness criterion.
it requires an exe cution of one thread which involves one or more sharedmemory locations not be interrupted by other threads.
inthe mainstream programming practice atomicity is enforced by locks which is notoriously difficult to be programmed correctly.
although the violations of atomicity can be de tected effectively tremen dous difficulties still exist in fixing them properly by theprogrammers who can easily introduce new bugs such as deadlocks or unintentional performance penalties.
studies show that it often takes more than one month to fix a concurrency bug and nearly of the patches arestill buggy in their first release.
one of the primary reasons for this difficulty as observed by many researchers is that writing synchronization code that is both safe and performant requires the intricate non modular reasoning about the semantics ofthe program.
the desired rigorous inter procedural reasoningof these types of global properties is usually the strength of the compiler based techniques.
therefore the research of lock allocation aims at replacing themanual reasoning by automatically assigning the locking op erations based on atomicity specifications.
these approachescan in general guarantee the freedom of deadlocks but oftenresult in the unsatisfactory performance due to the general conservativeness of static analysis techniques such as the thread escape analysis the array indexanalysis the shape analysis and many others.
we believe that for a carefully engineered concurrent system the programmer who really understands its semantics is more likely to produce the high quality synchronization code that has good performance as a result of the highdegree of concurrency.
this is simply because performancecan be easily measured in concrete test runs whereas safetyis difficult to verify due to the scheduling non determinism.an effective way of curing atomicity violations is to maximally respect the programmers designs of lock placementand assist them in avoiding hazardous situations such as inconsistent operations and deadlocks.
one recent work afix is the state of the art research in this direction.
the primary goal of afix is to automate the manual bug fixing process for programmers and strengthen it with the static analysis techniques such as the path analysis the reduction of subsumed bugs and the merging ofoverlapping bugs.
however limited by the inherent nature ofmanual reasoning approaches such as afix essentially lack a unified theoretical foundation to globally reason about bug fixes together with the existing lock design.
consequently no guarantees are provided with respect to either the safety or the performance of the patched program.
our evaluationofafix on large real systems also shows that the afix sometimes incurs the degraded performance and worse frequent deadlocks.
different from afix we propose a fully automatic bug fixing technique that is systematic rigorous and providingboth safety and performance guarantees.
for the end user our technique exhibits two distinctive and highly usefulproperties.
first our technique can simultaneously reasonand fix any number of correlated atomicity violations involving an arbitrary number of variables.
second we guaranteethat the fix not only is deadlock free but also incurs the minimal interference to the degree of concurrency of the original code.
our technique achieves these properties by modeling the concurrent properties of a program as petri nets and978 .
c ieee icse zurich switzerland 299using a branch of control theory called the supervision based on place invariants sbpi as our theoretical foundation.
we use novel methods to reduce the problem offixing atomic violations to solving a set of control constraints on petri nets.
by solving the constraints with an sbpi constraint solver we compute the locking additives to theoriginal program which prohibit the illegal interleavingsof threads.
the sbpi theory guarantees that the solution satisfies the constraints i.e.
preventing the violations from happening.
it also guarantees that the solution incurs theminimal interference 1to the degree of concurrency of the program hence maximally respects the programmer s orig inal design.
we extend the earlier application ofsbpi on the deadlock avoidance and guarantee that if the original program is deadlock free our solution does notcause the patched program to deadlock.
we implemented our approach as a tool axis and evaluated it against afix the state of the art automatic approach for fixing atomicity violations using subjects includingthree large scale real world programs.
our evaluation showsthat for these large scale subjects our patched version outperforms the afix solution by to the overhead of our patched version is much smaller than only of the overhead of the afix solution.
considering the subjects are well engineered and afix is efficient such improvement is significant.
equally important our patchedprogram scales well when the thread number increases.
be sides our patched version with the deadlock free guaranteenever incurs deadlocks in our experiments while incurring amoderate average overhead.
we make a significant contribution to the automatic fixing of atomicity violations which includes the following we propose an automatic approach to fix the atomicity violations which guarantees the minimal interferenceto the concurrency degree of the program and no introduction of deadlocks.
we reduce the fixing of atomicity violations to solving the control constraints which brings multiple compu tational advantages.
we propose a new petri net modeling which combines the dynamic calling context information and the staticprogram code.
the modeling is scalable complete andprecise for the violation fixing.
the rest of the paper is organized as follows.
we first briefly describe the overview of our approach in section ii.then we present our approach in section iii.
section ivand section v state the implementation and evaluation respectively.
1the guarantee is referred to as the maximal permissiveness of concurrency degree in the control theory we may use the two terms interchange ably.
a b c d figure basic petri subnets.
a branch.
b loop.
c start and join.
d lock.
ii.
o verview we present our technique in a nutshell by giving a primer on the petri net modeling of program control flows first followed by high level steps of our technique.
petri net primer.
petri net is a compact representation of state machines that avoids the state explosionproblem.
a comprehensive overview of petri net models and their applications is given by murata and we briefly outline the petri net models of the basic controlflow constructs including branch loop fork join and lock as illustrated in figure .
petri net is a bipartite directedgraph which contains two types of nodes places circles and transitions horizontal bars connected by the arcs.each place may contain tokens black dots each of whichmarks the current position of the execution flow of a thread.each transition can be triggered independently of each other.when being triggered the transition removes the tokensfrom each of its input places and replenishes tokens to eachof its output places.
each arc is associated with a weight i.e.
a number that determines the number of tokens to removeor to replenish.
if any input place does not contain sufficienttokens the transition is not triggered.
petri net models program statements or basic blocks as places and the control flow as the transitions .
for instance in figure a the branch is modeled using a single tokenin place p 1that flows to either p2orp3through a simple transition one source and one target t1ort2.a si n figure c the start operation is represented by the split transition one source and two targets t1 removing the token in p1and simultaneously replenishing tokens to p2and p3.
locks are modeled using two tokens one representing the program flow and the other the availability of the lock as illustrated in figure d .
the merging transition twosources and one target t says both tokens need to be available to enable the triggering of the transition and thetriggering of t 1removes the tokens simulating the lock operation.
the splitting transition t2returns the token back tol simulating the unlock operation.
our technique.
we use a slightly simplified version of the well know atomicity violation from thestringbuffer class in jdk .
to highlight the essential steps of our technique.
the interleaving sequence and the3001public class stringbuffertest public static stringbuffer s1 s2 null static thread th1 new thread public void run inlined s1.append s2 synchronized s1 intlen s2.length s2 is cleared by the thread t28 s2.getchars len s1.value s1.count static thread th2 new thread public void run s2.delete s2.length ... th1 .start th2.start th1.join th2.join a b c 1public class stringbuffertest public static stringbuffer s1 s2 null static thread th1 new thread public void run inlined s1.append s2 synchronized s1 lockm.lock intlen s2.length s2.getchars len s1.value s1.count lockm.unlock static thread th2 new thread public void run lockm.lock s2.delete s2.length lockm.unlock d figure a the original code.
b the petri net model with offending places shaded.
c the augmented petri net.
d the patched code.
offending statements are indicated by the arrows in figure .
given a violation report containing the offending programstatements such as line and in our example we firstconstruct a petri net model for this program illustrated infigure b .
we next encode this petri net and the offendingplaces statements as a set of control constraints which can be mathematically solved to yield an augmented petri net asshown in figure c .
our technique guarantees that if thenew lock mand the arcs dashed lines are added the new program has the following properties .
the violation will nolonger happen correctness .
there is no deadlock between the new lock mand the existing lock l deadlock freeness .
the new lock is used only when the interleavings of thethreads trigger the specific bug maximal permissiveness .
the augmented petri net in figure c corresponds to thepatched code in figure d .
the key to achieve these salient properties is to model the absence condition of each atomicity violation as a controlconstraint and to satisfy the constraint by augmenting thepetri net with new lock places and new arcs.
for instance the absence condition of the exemplary violation is line cannot interleave between line and line which is equivalent to two control constraints .
places p 7andp3cannot simultaneously contain tokens .
places p7andp4cannot simultaneously contain tokens.
then we express these con straints in succinct linear inequalities section iii b and usethe sbpi constraint solver to compute an augmentation to the petri net to guarantee that all constraints are satisfied.
inaddition we extend the siphon analysis of wang et al.
to eliminate any possible deadlocks introduced by the aug mentation.
treating atomicity violations with a constraintsolving system has many computational advantages over existing approaches.
the solver considers all correlated bugs and produces the optimum maximal permissive solutions rather than simply relying on merging heuristics.
the solvercomputes automatically without any ad hoc treatments forloops or branches the lock placement that guarantees tobe free of bad lock practices.
in addition the mathematic form of the constraints allows further algebraic optimizationssuch as the rank reduction.
we now describe our constraintsolving approach in detail.
iii.
f ixing atomicity viola tions with control constraints in this section we first explain how the petri net models and control constraints are constructed.
we then explain howthey are solved by the sbpi constraint solver to generate patches for fixing the violations.
at last we show the generalapplicability of our approach the deadlock free guarantee and the guarantee of lock placement.
a. on demand petri net construction our technique takes as input the reports of violations including both single variable and multi variable violations.
for the ease of technical discussion we primarily discussthe single variable violations and briefly outline later in thepaper how multi variables are treated.
the quality of the bug reports greatly affects the quality of bug fixes in general.
although our technique can be applied to statically detected violations our current focusis to deal with dynamically discovered bugs with both theoffending statements and their calling contexts available.most dynamic bug detection tools can provide this information easily.
each single variable atomicity violation can be characterized by three statements s s ands where s ands are executed by the same thread ands is a remote statement.
given the calling contexts of these statements the context sensitive petri net can easily beconstructed starting from the entry point of the thread byconstructing the subnets intra procedurally and by linkingthe subnets at the call sites inter procedurally.
if the threadis created in a loop or by a recursive call we clone the petrinet starting from the thread entry point to represent twothreads.
note two threads are sufficient to express atomicityviolations .301b.
control constraints constructing the control constraints on the petri net is a key step in fixing the violations bugs.
however the con struction is not straightforward because atomicity bugs arecharacterized by their dynamic behaviors whereas control constraints express the structural information of petri nets which is static by nature.
our transformation method isbased on the following observation.
for a violation s s s to occur at runtime there must exist a statement inclusively between s ands that is executed concurrently with s .
this is an equivalent condition of the atomicity violation .
we define this observation formally as lemma .
lemma three statements s s and s form an atomicity violation s s s at runtime statement s between s s s is executed at the same time as s .
here between s s returns a set denoted as the bset short for between set of statements that may be executedbetween s ands locally by the same thread.
one way to compute it is to collect the statements on every path froms tos which can be implemented efficiently using the standard forward data flow analysis2.
mapping to the petri net lemma is reiterated as lemma .
lemma three statements s s and s form an atomicity violation s s s at runtime.
in the petri net where p p andp model the statements s s and s respectively place p between p p pis reached at the same time as p by the execution flow of two threads or in the petri net langu age two tokens are simultaneously inpandp .
to succinctly describe the tokens in the places we introduce the marking vector u where each entry u p represents the number of tokens of a place p. the bset of two places can be computed similar to the bset of two statements.
it does not include the transitions or the lock places which do not model statements .
infigure the bset of places p 3andp4is p3 p4 .
using the bset the runtime occurrence of the violation is equivalently described on the petri net as p p3 p4 u p u p7 .
the sum never exceeds because each place contains at most one token representing the executionflow of its own thread.
remember that we make clones forthe same statements under different thread contexts the counterposition of lemma also holds as shown in lemma .
lemma place p between p p u p u p the atomicity violation does not occur at runtime.
2interested readers may refer to our technique report for the implementation details.
naturally provides the solution for constructing the control constraints.
for our running example in figure the control constraints are shown in equation .
braceleftbigg u p u p7 u p4 u p7 asp3andp4are places of the same thread at any time the token representing the execution flow of the thread can atmost stay in one of them.
therefore we have an intra threadconstraint u p u p4 .
combining the constraints in equation and the intra thread constraint it is not hard to obtain an equivalent but more succinct constraint u p7 u p3 u p4 .
we formally generalize the succinct representation of the constraint in lemma .
lemma suppose between p p consists of places p p ... p .
they form an implicit intra thread constraint equation 2a as well as the control constraints with aremote place p equation 2b to equation 2e .
u p u p u p 2a u p u p 2b u p u p 2c ... 2d u p u p 2e then we have an equivalent but more succinct constraint i.e.
control constraint u p u p u p u p .
proof the proposition equation equation holds as each place contains non negative number of tokens.the proposition equation equation also holds.
suppose between p p contains kplaces then we apply the following linear transformations to get equation .
multiplyequation 2a by k we get equation .
k u p u p u p k add equation with equation 2b equation 2c ... equation 2e we get equation .
k u p u p u p u p 2k divide equation by k we get equation .
u p u p u p u p k as each place contains integer tokens we further get equation .
definition danger stripe given a violation and its succinct constraint in equation the places appearing inthe equation form a danger stripe for the violation.
with the assistance of an indicator vector lindicating each place s302presence or absence in the danger stripe with 1or0 equation can be expressed in a vector form lu .
redundant constraints.
a constraint is redundant if it is subsumed by other constraints.
taking the constraint inequation for example the constraint u p u p3 is subsumed by u p7 u p3 u p4 .a st h e sbpi solver works on independent constraints we conduct a preprocessing step to remove the redundant constraints.in particular we remove the constraint if the set of placesappearing in the constraint are covered by the set of placesin another constraint.
note that such reduction is essentiallya more natural and rigorous form of the heuristic basedredundancy removal method used by afix .
c. solving the control constraints given the constraint in the form of lu our solution is to generate an augmentation to the petri net to force it to avoid violation executions using the supervision based onplace invariants sbpi theory.
the solution augments theoriginal petri net with new places and new arcs to guaranteethat this constraint is always satisfied in the augmented net.before describing the sbpi technique we first introduce the mathematical model of both the petri net and its dynamicoperations.
definition a petri net is a bipartite directed graph denoted by a tuple angbracketleftp t a w u angbracketright.pis the set of places andtthe set of transitions.
a p t t p is the set of arcs.
w a nis a weight function which returns a natural number for each arc.
u0 p nis a function which returns the number of tokens initially hosted in a given place.
the petri net used in our technique is a special type of petri net called the pure petri net4 where tokens cannot directly flow back to the source place no self loop .
besides the weight of each of its arcs is and each place canhave at most token.
the movement of tokens in petri netis characterized by a dimensional incidence matrix d. each cell d ijis either not connected incoming or outgoing representing the direction of the transition tj with respect to the place pi.
we state the sbpi as follows.
theorem sbpi theorem if lu0 b then we can guarantee that the constraint lu bholds for any possible marking uby adding a new place m. the newly added mis characterized by its initial marking u0 mand its row vector dmin the incidence matrix d which should satisfy the following condition u0 m lu0 b and dm ld 3lis a row vector uis a column vector.
4a standard petri net result states that any petri net can be reduced to pure petri nets .the added place enforces the maximal permissiveness in the sense that it preserves as many executions as possible whileprohibiting only the violation inducing executions.
we interpret theorem intuitively as follows.
the constraint that the number of tokens in the danger stripe cannot exceed a bound balways holds if in the augmented petri net the total number of tokens initially in both the danger stripeandm newly added place is b defined by equation and the net change of the number of tokens in the danger stripeandm is always defined by equation .
based on the two equations we can easily compute the initial marking ofthe new place as b lu 0and the new arcs as well as their directions dm ld.
let us apply the sbpi technique to fix the atomicity violation in the running example of which the incidencematrix is d t 1t2t3t4t5t6t7 p1 p2 p3 p4 p5 p6 p7 p8 p9 l the initial marking is u t the places are ordered as p1 p2 ...p9 l. .
the constraint is u p3 u p4 u p7 .
in other words the indicator vector lis andb .
applying the sbpi constraint solver the transition vector of the new place m dm i s ld with the initial marking u0 masb lu0 .
the new place m and its connecting arcs as indicated by dm is shown in figure c .
as shown in figure c the new place m has two outgoing arcs to t2andt6 and two incoming arcs from t4andt7.
the behavior of place mis identical to a lock as explained in section ii.
the arc connecting place m to transition t2essentially says a lock operation should be added to the transition t2 i.e.
the control flow edge represented by t2in the cfg.
we show how to achieve this in the program code in section iv.
d. multi variable atomicity violation so far our discussion is focused on atomicity violations involving a single shared variable.
our approach can benaturally applied to fix multi variable atomicity violations or the so called atomic set aset violations .
vizari et al.
exhaustively enumerate thread interleavingpatterns as the equivalent conditions of aset violations.
forexample the pattern w xw2 yw1 yw2 xdescribes a violating interleaving where the first and the third write belong to3031 a b figure a multiple variable atomicity violation the dotted lines depict the forming interleavings of the violation.
b the deadlocks may be introduced.
a unit of work in one thread and the second and the fourth belong to the other.
as shown in figure a the interleavingis equivalent to the co occurrence of the interleavings shownin the two squares.
following the process described above we can construct two constraints u s1 u s2 u s3 andu s2 u s3 u s4 1and add both of them to the constraint solver.
our technique treats aset violations in auniform manner with the same guarantees.
comparatively it is non trivial to adapt afix to fix aset violations because the approach is designed specifically for single variable atomicity violations.
e. deadlock free guarantee our approach fixes the violations one by one to achieve the fine granularity concurrency control for each bug.
how ever due to the interplay between the overlapping bugs deadlocks may be introduced.
for example in figure b there are two bugs each involving variables xand y respectively.
the computed controllers lxandly appearing in the comments may form the cyclic lock acquisitionorders i.e.
deadlocks.
the work of wang et al.
is usedas a postprocessing step to fix deadlocks.
we extend the deadlock avoidance to guarantee that our approach does not introduce new deadlocks to the program.
in particular weonly fix those deadlocks introduced by our added locks or inthe petri net language we only handle the siphons involvingthe newly added lock places .
f .
guarantee of lock placement our approach guarantees that the lock placement is free of bad lock practices.
in this section we show the guarantee with respect to both the intra procedural and inter proceduralconstructs.
lock placement when branches or loops are present.
our approach generates only the matched lock unlock op erations.
it never generates bad lock practices such as dou ble locking double unlocking missed locking and missedunlocking.
it is well known that the careless manual 5more details and formal proof are in our technique report.
cse.ust.hk prism axis tr.pdffixing easily leads to bad lock practices such as the double locking.
surprisingly our approach avoids bad lock practices without any special treatments.
the key insight is that the sbpi theory guarantees that the places in a danger stripe together with the added supervisory place always containan invariant number of tokens in total .
in the case that the bad lock practices are present e.g.
missed unlocking theexecution along a certain path may cause inconsistencies inthe total tokens in both the danger stripe and the supervisoryplace.
the formal proof and a concrete example is shownin our technique report .
lock placement when s and s are in different functions.
remember that s s s form a violation.
when s ands are in different functions the sbpi solver may also place the lock acquisition and the lock release indifferent functions.
such a placement can cause errors if for example the method containing the lock release getsinvoked under a different calling context where no locksare acquired.
to prevent such errors we place a restrictionon the statements s ands that they must be enclosed in the same method.
in the case that they are not in the samemethod we preprocess the violations to make sure s ands are mapped to the call sites in their lowest common ancestor lca method.
g. discussion of limitations a major threat to the validity of our high performance claim is that we use the degree of concurrency as the domi nant factor for the performance measurement.
we minimizethe number of locking operations only under the condition that the maximal concurrency degree is achieved.
in fact researchers often consider the number of lockingoperations as an equally important factor of the performance.the concurrency degree may be sacrificed sometimes forreducing the number of locking operations.
our techniquehas the consequence that the locks we introduce may bein the hot loops leading to many the locking operations.we downplay the importance of locking frequency fortwo reasons.
first due to the jvm optimization the uncontended locking operations are extremely fast and theircost is negligible if no hot loops are present.
second ourempirical experience shows that atomicity violations rarelyhappen in the hot loops perhaps because the high frequencyof execution can easily expose the bugs.
nevertheless asa mitigation measure we conduct the cycle detection toinform the developers that some locks are placed in loopsor recursions.
our input violation bugs are detected by pecan which may contain benign violations that according tochew et al.
do not affect the correctness of the program 6actually this is the reason why the technique is called sbpi and the reason why the constraint can be satisfied.
even required in some cases.
since pecan does not classify benign violations fixing them may incur unnecessaryoverhead.
however we think this is related to the quality ofthe bug reports and does not undermine our contribution.
iv .
i mplementa tion we implement our approach as a tool axis9 on top of the soot framework.
axis contains four components the petri net builder the constraint constructor the constraint solver and the patcher.
the construction of petri nets is based on the depthfirst traversal of the call graph and the intra proceduralcontrol flow graphs.
we construct petri nets by substituting each node edge node structure with the place arc transition arc place structure.
for methods invoked under differentcontexts we clone the petri nets of these methods to getcontext sensitivity.
if threads are created in recursions or loops we further clone the petri subnet rooted at the run method.
the constraint construction is built on top of theforward data flow analysis in soot .
our patcher works directly on the bytecode instead of the source code.
the implementation of the patcher is full ofchallenges.
we highlight important ones as follows.
patching locks.
the instrumentator adds the locking operations i.e.
the monitorenter and monitorexit instructions to the program according to the result of the solver.
thepatched lock is created as a static variable of the class thatcontains the program entry point main method .
since this class is usually loaded first we ensure the lock variables arealways properly initialized before being used.
exception handling.
exceptions may be thrown between a pair of added locking operations which make the executionskip the monitorexit instruction.
to make sure that our patcher works in such case we add an exception handlerdirectly after the monitorexit which captures the exceptions thrown between the monitorenter and the monitorexit statements and also from our injected exception handlers.
control flow interception.
as shown in section iii c our solution is in the form of places connecting to thetransitions.
from the view of cfg we need to inject thelock orunlock operations to the control flow edges modeled by the transitions.
however the control flow edges are notexplicitly represented in the code.
given a control flow edgee from mton where we want to inject the unlocking operation naively injecting monitorexit just before the target statement nis problematic because other edges with nas the target are also affected.
we explicitly represent the controlflow edges in the code and isolate the effect of monitorexit to the control flow edges as follows.
given the edge e w e change it to m jumpto nopjumpto n. in this way the nop having a single parent and single child explicitly representsthe flow edge.
then injecting the monitorexit to just before 9we make it publicly accessible after nop but not across the jumping statement will not affect other control flow edges.
v. e v alua tion in this section we aim at answering the following research questions.
does our approach automatically fix the atomicity violations?
how does our approach affect the concurrency degree of the original program as compared to the state of theart approach?
does our approach introduce new deadlocks to the original program?
to answer these questions we implemented our approach as a tool axis and used it to fix the atomicity violations found in a set of popularly used subjects aslisted in table i. the subjects contain three large scaleprograms openjms derby and jigsaw which are respectively the open source implementation of jms specifica tion apache s database management system and w3c s web server platform.
table i shows in column two andthree the number of application methods method and the number of statements stmt .
we collect the bugs using the violation detection tool pecan .
all studies are performed on a x86 dell workstation with .0ghz quadcore intel xeon x5450 processors based on core micro architecture cores total .
the server has 16gb ram and6m l2 caches runs ubuntu .
with a linux .
.
kernel and uses sun s bit .
.
jvm.
for each program we run20 runs to collect the data.
the first question can be answered easily by measuring the effectiveness of axis .
we run the violation detection tool pecan upon the patched versions of the subjects with the same program input.
pecan detected no further violations for any of the subjects.
we report our investigation of theremaining two questions as follows.
a. the study of the bug fixing process in this section we study various important characteristics of the bug fixing process of axis itself.
in table i we first report for each subject the space and time usage of axis in terms of the number of bugs fixed bug the size of the constructed petri net size the time of fixing the violations t av and the time of fixing the deadlocks tdl .
we show the time of the call graph construction tcg as the reference.
the data show that the constructed petri nets despite being context sensitive contain a small number of nodescompared to the total number of program statements.
thelargest number of nodes in our evaluation jigsaw is around 25k which can easily fit into the memory of a desktop ma chine.
the time for fixing the violations is almost negligible 11we conduct the analysis on the soot s jimple ir.
hereafter the statement means the jimple ir.
postattributechangeevent ... if attrlistener !
null attributechangedevent evt new attributechangedevent getresource attributes newvalue fireattributechangeevent evt a postattributechangeevent l1.lock if attrlistener !
null l2.lock attributechangedevent evt new attributechangedevent getresource attributes newvalue l2.unlock fireattributechangeevent evt l1.unlock b postattributechangeevent l.lock if attrlistener !
null attributechangedevent evt new attributechangedevent getresource attributes newvalue fireattributechangeevent evt l.unlock c figure the fixing of the violations in jigsaw .
a the violation.
b the fixing of our approach.
c the fixing of afix approach.
less than second in all subjects.
the deadlock avoidance analysis also scales well with respect to the program size taking seconds in the worst case.
the two columns under the category of locks reports the number of locks introduced by axis and afix respectively.
for the three large subjects to fix the same number ofbugs afix on average generates fewer locks compared toaxis .
this is because its heuristics based merging step cannot precisely reason about the interplay between theoverlapping bugs and conservatively protects several unrelated bugs with the same lock.
this directly translates tothe coarse granularity concurrency control and the longerblocking time on the locks.
we use a real example in the subject jigsaw to further clarify this point.
figure a is a simplified code snippet from jigsaw that shows the interplay between two atomicity violations.
inthe first bug local statements line and line accessingthe variable attrlisterner are interleaved by a remote statement not shown s that also accesses this variable.
in the second bug line is the remote statement accessingthe variable attributes that interleaves with a pair of local statements not shown s prime ands prime that access the same variable.
note that the two local statements in the secondbug can be executed in parallel with the statement line inthe first bug because they modify unrelated program states.as shown in figure c afix merges the two violations as one and protects them with a common lock.
as the result line a long computation and the sequence between s prime ands prime cannot be executed concurrently.
our fix as shown in figure b generates two locks one for each bug.
line can be allowed to execute because s prime ands prime now acquire a different lock.
our approach without any fear of deadlocks makes use of nested locking to reduce the lock contention.
b. performance of the patched code in this study we assess the performance impact of the generated patches.
for each subject we compare the per formance of four versions the original version orig the version generated by afix the patched versions by our technique with axis axis da and axis with the deadlock avoidance disabled axis noda .
since the original afix tool was developed for c programs we have reimplementedits algorithm faithfully and released our implementation forfurther scrutiny .
our performance study consists of two experiments the first studies the computational throughputof patched versions compared to the original the secondstudies the scalability of the throughput with an increasingnumber of threads.
in the performance category of table i we show the performance measurements of the subjects with the number of threads fixed at eight which is the number of cores onour test platform.
the first seven subjects use few synchro nization operations and have no more than three violations tofix.
for this reason the patches generated by axis noda and afix are almost identical.
the performance of each version is therefore more or less the same with minor fluctuationsdue to the thread scheduling.
for subjects cache4j hedc and specjbb the axis da version however introduces a higher overhead of and4 .
this overhead is the cost of deadlock freeness through the use of additional locks.
the result for the three large subjects shows the superiority of axis .
for the subject openjms the patched version with no deadlock avoidance axis noda performs almost as well as the original version which contains violations.and it outperforms the afix version by .
with the deadlock free guarantee our axis da version is slower than the afix version which does not provide a deadlockfree guarantee.
for the subject jigsaw we are unable to obtain the stable throughput data for axis noda and afix 12afix java implementation.
url i the metrics of the fixing process and the performance of the patched programs.
in the performance column we use millisecond ms as the unit.
one exceptional case is specjbb where we use its own specific unit to measure the performance bops business operations per second .
higher performance corresponds to higher bops value.
programprogram properties metrics of the fixing locks performance method stmt bug size tcg sec tav ms tdl ms axis afix orig axis noda axis daaf ix mergesort .
stringbuffer .
arraylist .
linkedlist .
hashset .
t reeset .
rayt racer .
cache4j hedc specjbb openjms jigsaw .
derby .
because the patched versions easily lead to deadlock with eight threads running.
this case shows the importance ofthe deadlock avoidance in the patch.
for the subject derby theaxis noda version is faster than the afix version.
the axis da version with deadlock free guarantee incurs only higher overhead compared to the afix version.
in general the overhead incurred by the axis noda version is around of the overhead of the afix version.
in figure we show a study of the scalability of the patched code by both our technique and afix with respect to the increasing number of threads using the large scalesubjects openjms jigsaw and derby .
for the subject openjms when the thread number is larger than the axis noda version outperforms the afix version by around .
the axis da version incurs threads to threads overhead.
compared to the afix version it is threads to threads slower but it guarantees thedeadlock freeness.
for the subject jigsaw both the axisnoda and afix versions easily lead to deadlocks.
the axisda version incurs a slowdown of threads to threads .
for the subject derby the axis noda version outperforms the afix version by around when the thread number increases to .
the axis da version incurring threads to threads overhead is slightly slowerthan the afix version by on average.
as seen our technique exhibits a better performance than afix as the thread number increases.
an explanation for the observationis our approach leads to fewer contentions of the same locksand allows higher concurrency degree.
one interesting observation from figure is that when the thread number is the performance of all versions is similar.
such an observation illustrates that the added lock ing operations are often not in the hot loops and introducenegligible overhead if we do not consider blocking time as compared to the original version.
this confirms with ourassumption that the locking frequency is not a key factor that influences the performance of our subjects.
to conclude our axis noda outperforms afix approach by to in the realistic applications.
for conservativelyguaranteeing deadlock freeness our axis version often incurs a moderate average overhead.
c. safety of the generated code in this study we aim to assess if our patches introduce deadlocks in the subjects.
we could use existing deadlockdetecting techniques to quantify this property.
however wefound that simply by sampling the runs for a fixed numberof times is already sufficient to reveal interesting insights.we run each patched program times and observe whetherdeadlocks happen without any interference to the schedulingmechanism.
as shown in table ii the deadlocks can easily happen with even uncontrolled runs.
for openjms each of the version with the axis noda patch and the version with the afix patch gets deadlocks when the thread number reaches .
when the thread number reaches more deadlocks and incur in these two versions.
for jigsaw the two patched versions of jigsaw always get deadlocks at runtime when there are multiple threads.
for derby when the thread number reaches the patched versions by axis noda and afix incur deadlocks and deadlocks respectively.
comparatively we observe no deadlocks for the patchedversion by axis da .
this observation shows the deadlock is a serious problem to treat while fixing of violations.
it isworthwhile to pay a higher cost in the axis da patches to avoid them.
vi.
r ela ted work lock allocation is akin to the automatic fixing of violations.
its goal is to infer the synchronizationconstructs to guarantee the specified atomicity properties307 a b c figure a openjms.
b jigsaw.
c derby.
table ii the fixing process of axis noda and afix introduce deadlocks.
for a subject we show the deadlocks for both its axis noda version and afix version.
patched program t 2t 4t 8t openjmsaxis noda afix jigsawaxis noda afix derbyaxis noda afix and the high performance.
recent lock allocation work makes use of the shape properties to generatethe fine granularity locks so that multiple operations cansimultaneously access different parts of a data structure.
automatically inferring the atomicity property i.e.
the atomic region is orthogonal to our approach.
v echev et al.
propose an assertion directed approach to iterativelyenlarge the atomic region until the assertion is satisfied.besides trace analysis can also be used toextract the atomicity property from the correct runs.
self healing approach detects the faults or errors at runtime and generates dynamic patches so that theexecutions recover from the anomalies.
however it lacks the comprehensive off line analysis required to generatehigh quality patches.
lucia et al.
propose a specific architectural support for dynamically avoiding atomicityviolations.
deterministic execution system or deterministic language support guarantees deterministic behaviors of theprogram by construction.
they still face many challenges such as high runtime overhead or extra manual annotations.
an alternative approach checking the determinism throughthe testing complements our approach as it can be usedto filter out the benign violations.
petri net is widely applied to various software engineering tasks e.g.
analyzing the performance of softwaresystem modeling the protocol of software systems modeling the concurrency programs .
vii.
c onclusions we have presented an automatic approach to fix atomicity violations through solving the sbpi control constraints using the sbpi control theory as the theoretical foundation.
given the bug reports of dynamically detected violations ourtechnique models the offending program statements and theircalling contexts using petri nets.
the violations themselvesare transformed to a set of linear inequalities with respectto the petri net structures which we call control constraints.we then use the sbpi constraint solver to generate an augmented petri net that .
maximally respects the degreeof concurrency in the original design .
guarantees not tointroduce new deadlocks.
we implemented our techniqueas a tool axis and evaluated it against a set of popular concurrent programs.
the evaluation shows axis is both more scalable and effective when compared to the relatedwork.
a cknowledgments we first thank yin wang and terence kelly from hp labs for their patient guidance throughout this work.
we also thank the anonymous reviewers for their constructive feedback.
this research is supported by rgc grf grant622208 and and by the hkust rfid researchcenter.
r eferences a time to patch ii mozilla.
securityfix a time topatch iimozilla.html.
sarita v .
adve stephen heumann rakesh komuravelli jeffrey overbey patrick simmons hyojin sung and mohsen v akilian.
a type and effect system for deterministic parallel java.
in oopsla .
amittai aviram shu chun weng sen hu and bryan ford.
efficient system enforced deterministic parallelism.
in osdi .
david f. bacon ravi konuru chet murthy and mauricio serrano.
thin locks featherweight synchronization for java.
inpldi .
luciano baresi and sam guinea.
self supervising bpel processes.
ieee trans.
software eng.
.
reimer behrends r. e. k. stirewalt and laura k. dillon.
avoiding serialization vulnerabilities through the use of syn chronization contracts.
in austrian computer society .
lee chew and david lie.
kivati fast detection and prevention of atomicity violations.
in eurosys .
jong deok choi manish gupta mauricio serrano vugranam c. sreedhar and sam midkiff.
escape analysis for java.
in oopsla oopsla .
vittorio cortellessa antinisca di marco and paola inverardi.
model based software performance analysis .
springer .
crispin cowan heather hinton calton pu and jonathan walpole.
the cracker patch choice an analysis of post hoc security techniques1.
information systems security .
michael emmi jeffrey s. fischer ranjit jhala and rupak majumdar.
lock allocation.
in popl .
azadeh farzan and p .
madhusudan.
causal atomicity.
in ca v .
cormac flanagan and stephen n. freund.
atomizer a dynamic atomicity checker for multithreaded programs.
in popl .
g. golan gueta n. bronson a. aiken g. ramalingam m. sagiv and e. y ahav.
automatic fine grain locking using shape properties.
in oopsla .
richard l. halpert christopher j. f. pickett and clark v erbrugge.
component based lock allocation.
in pact .
jeff huang and charles zhang.
persuasive prediction of concurrency access anomalies.
in issta .
m. v .
iordache and p .
j. antsaklis.
supervision based on place invariants a survey.
discrete event dynamic systems december .
guoliang jin linhai song wei zhang shan lu and ben liblit.
automated atomicity violation fixing.
in pldi .
shan lu soyeon park eunsoo seo and y uanyuan zhou.
learning from mistakes a comprehensive study on real world concurrency bug characteristics.
in asplos .
brandon lucia joseph devietti luis ceze and karin strauss.
atom aid detecting and surviving atomicity violations.
ieee micro .
bill mccloskey feng zhou david gay and eric brewer.
autolocker synchronization inference for atomic sections.
inpopl .
t. murata.
petri nets properties analysis and applications.
proceedings of the ieee apr .
abdullah muzahid norimasa otsuki and josep torrellas.
atomtracker a comprehensive approach to atomic region inference and violation detection.
in micro .
adrian nistor darko marinov and josep torrellas.
instantcheck checking the determinism of parallel programsusing on the fly incremental hashing.
in micro .
chang seo park and koushik sen. randomized active atomicity violation detection in concurrent programs.
in fse .
soyeon park shan lu and y uanyuan zhou.
ctrigger exposing atomicity violation bugs from their hiding places.inasplos .
eric rescorla.
security holes... who cares?
in ssym proceedings of the 12th conference on usenix security symposium pages berkeley ca usa .
usenix association.
francesco sorrentino azadeh farzan and p .
madhusudan.
penelope weaving threads to expose atomicity violations.
infse .
gautam upadhyaya samuel p .
midkiff and vijay s. pai.
using data structure knowledge for efficient lock generation and strong atomicity.
in ppopp .
mandana v aziri frank tip and julian dolby.
associating synchronization constraints with data in an object orientedlanguage.
in popl .
martin v echev eran y ahav and greta y orsh.
abstractionguided synthesis of synchronization.
in popl .
willem visser klaus havelund guillaume p .
brat and seungjoon park.
model checking programs.
in ase .
yin wang terence kelly manjunath kudlur st ephane lafortune and scott a. mahlke.
gadara dynamic deadlock avoidance for multithreaded programs.
in osdi .
yin wang st ephane lafortune terence kelly manjunath kudlur and scott mahlke.
the theory of deadlock avoidancevia discrete control.
in popl .
d. weeratunge x. zhang and s. jagannathan.
accentuating the positive atomicity inference and enforcement using correct executions.
in oopsla .
charles zhang.
flexsync an aspect oriented approach to java synchronization.
in icse .
ji zhang and betty h. c. cheng.
model based development of dynamically adaptive software.
in icse .