an optimal strategy for algorithmic debugging david insa and josep silva departamento de sistemas inform aticos y computaci on universidad polit ecnica de valencia e valencia spain.
fdinsa jsilvag dsic.upv.es abstract algorithmic debugging is a technique that uses an internal data structure to represent computations and ask about their correctness.
the strategy used to explore this data structure is essential for the performance of the technique.
the most efficient strategy in practice is divide and query that until now has been considered optimal in the worst case.
in this paper we first show that the original algorithm is inaccurate and moreover in some situations it is unable to find all possible solutions thus it is incomplete.
then we present a new version of the algorithm that solves these problems.
moreover we introduce a counterexample showing that divide and query is not optimal and we propose the first optimal strategy for algorithmic debugging with respect to the number of questions asked by the debugger.
index terms algorithmic debugging divide and query i. i ntroduction algorithmic debugging is based on the answers of the programmer to a series of questions generated automatically by the algorithmic debugger.
in each question the debugger provides the programmer with the input and output of a sub computation e.g.
a function activation and the programmer states their correctness.
this information is used by the debugger to discard correct parts of the code and guide the search for the bug until a buggy portion of code is isolated.
example .
consider the following simple and buggy haskell program main mix insert e insert e x xs e x e x xs otherwise x insert e xs mix ys ys mix x xs ys insert x mix xs xs an algorithmic debugging session for this program is the following yes andnoanswers are provided by the programmer starting debugging session... mix ?
no mix ?
yes insert ?
yes bug found in rule mix x xs ys insert x mix xs xs the debugger points out the part of the code that contains the bug.
in this case mix xs xs should be mix xs ys .
note that to debug the program the programmer only has to answer questions.
it is not even necessary to see the code.
algorithmic debuggers often produce a data structure called theexecution tree et that represents a program execution.
for instance the et of the program in example .
is depicted in figure i. fig.
.
et of the program in example .
the nodes of the et contain questions and the strategy used to decide what nodes of the et should be asked is crucial for the performance of the technique .
the algorithmic debugging strategy that presents the best performance in practice is divide and query d q .
in fact from a theoretical point of view this strategy has been thought optimal in the worst case for almost years and it has been implemented in almost all current algorithmic debuggers see e.g.
.
in this paper we show that current algorithms for d q are suboptimal.
we show the problems of d q and solve them in a new improved algorithm that is proven optimal.
moreover the original strategy was only defined for ets where all the nodes have an individual weight of .
in contrast we allow our algorithms to work with different individual weights that can be integer but also decimal.
an individual weight of zero means that this node cannot contain the bug.
a positive individual weight approximates the probability of being buggy.
the higher the individual weight the higher the probability.
this generalization strongly influences the technique and allows us to assign different probabilities of being buggy to different parts of the program.
for instance a recursive function with higher order calls should be assigned a higher individual weight than a function implementing a simple base case .
the weight of the nodes can also be reassigned dynamically during the debugging session in order to take into account the oracle s answers .we show that the original algorithms are inefficient with ets where nodes can have different individual weights in the domain of the positive real numbers including zero and we redefine the technique for these generalized ets.
the rest of the paper has been organized as follows.
in section ii we recall the algorithmic debugging technique and formalize the strategy d q. then we show with counterexamples that d q is suboptimal and incomplete.
in section iii we introduce an improved version of d q. in section iv we define a new strategy for algorithmic debugging that is optimal in all cases.
the correctness of the algorithms presented is proven in section v. finally section vi concludes.
ii.
a lgorithmic debugging in this section we recall the algorithmic debugging technique and formalize the strategy d q .
we start with the definition of marked execution tree that is an et where some nodes could have been removed because they were marked as correct i.e.
answered yes some nodes could have been marked as wrong i.e.
answered no and the correctness of the other nodes is undefined.
definition .
marked execution tree amarked execution tree met is a tree t n e m wherenare the nodes e n nare the edges and m n!vis a marking total function that assigns to all the nodes in na value in the domain v fwrong unde nedg.
initially all nodes in the met are marked as unde ned .
but with every answer of the user a new met is produced.
concretely given a met t n e m and a noden2n the answer of the user to the question in nproduces a new met such that i if the answer is yes then this node and its subtree is removed from the met.
ii if the answer is no then all the nodes in the met are removed except this node and its descendants.1therefore note that the only node that can be marked as wrong is the root.
moreover the rest of nodes can only be marked as unde ned because when the answer is yes the associated subtree is deleted from the met.
therefore the size of the met is gradually reduced with the answers.
if we delete all nodes in the met then the debugger concludes that no bug has been found.
if contrarily we finish with a met composed of a single node marked as wrong this node is called the buggy node and it is pointed to as being responsible for the bug of the program.
all this process is defined in algorithm where function selectnode selects a node in the met to be asked to the user with function asknode .
therefore selectnode is the central point of this paper.
in the rest of this section we assume that selectnode implements d q. in the following we use e to refer to the reflexive and transitive closure of eande for the transitive closure.
1it is also possible to accept i don t know as an answer of the user.
in this case the debugger simply selects another node .
for simplicity we assume here that the user only answers yes or no.algorithm general algorithm for algorithmic debugging input a met t n e m output a buggy node or?if no buggy node is detected preconditions 8n2n m n unde ned initialization buggynode ?
begin do node selectnode t answer asknode node if answer no thenm node wrong buggynode node n fn2nj node!n 2e g elsen nnfn2nj node!n 2e g while 9n2n m n unde ned return buggynode end a. divide and query d q assumes that the individual weight of a node is always .
therefore given a met t n e m the weight of the subtree rooted at node n2n wn is defined recursively as its number of descendants including itself i.e.
pfwn0j n!n0 2eg .
d q tries to simulate a dichotomic search by selecting the node that better divides the met into two submets with a weight as similar as possible.
therefore given a met with n nodes d q searches for the node whose weight is closer to n .
b. limitations of d q in this section we show that d q is suboptimal when the met does not contain a wrong node i.e.
all nodes are marked as undefined .2the intuition beyond this limitation is that the objective of d q is to divide the tree by two but the real objective should be to reduce the number of questions to be asked to the programmer.
for instance consider the met in figure left where each node is labeled with its weight and the black node is marked as wrong thus d q would select the gray node.
the objective of d q is to divide the nodes into two groups of .
nevertheless the real motivation of dividing the tree should be to divide the tree into two parts that would produce the same number of remaining questions in this case .
the problem comes from the fact that d q does not take into account the marking of wrong nodes.
for instance observe the two mets in figure center where the black node is marked as wrong.
in both cases d q would behave exactly in the same way because it completely ignores the marking of the root.
nevertheless it is evident that we do not need to ask again for a node that is already marked as wrong to determine whether it is buggy.
however d q counts the 2modern debuggers allow the programmer to debug the met while it is being generated.
thus the root node of the subtree being debugged is not necessarily marked as wrong .nodes marked as wrong as part of their own weight and this is a source of inefficiency.
fig.
.
behavior of divide and query in the mets of figure center we have two mets.
in the one at the right nodes with weight and are optimal but in the one at the left only the node with weight is optimal.
in both mets d q would select either the node with weight or the node with weight both are equally close to3 .
however we show in figure right that selecting node is suboptimal and the strategy should always select node .
considering that the gray node is the first node selected by the strategy then the number at the side of a node represents the number of questions needed to find the bug if the buggy node is this node.
the number at the top of the figure represents the number of questions needed to determine that there is not a bug.
clearly as an average it is better to select first the node with weight because we would perform less questions vs. 4considering all four possible cases .
therefore d q returns a set of nodes that contains the best node but it is not able to determine which of them is the best node thus being suboptimal when it is not selected.
in addition the mets in figure show that d q is incomplete.
observe that the mets have nodes thus d q would always select the node with weight .
however the node with weight is equally optimal both need12 5questions as an average to find the bug but it will be never selected by d q because its weight is farther from the half of the tree4 .
another limitation of d q is that it was designed to work with mets where all the nodes have the same individual weight and moreover this weight is assumed to be .
if we work with mets where nodes can have different individual weights and these weights can be any value greater or equal to zero then d q is suboptimal as it is demonstrated by the met in figure .
in this met d q would select node n1because its weight is closer to21 2than any other node.
fig.
.
incompleteness of divide and query fig.
.
met with decimal individual weights however node n2is the node that better divides the tree in two parts with similar probabilities of containing the bug.
in summary d q is suboptimal when the met is free of wrong nodes d q is correct when the met contains wrong nodes and all the nodes of the met have the same weight but d q is suboptimal when the met contains wrong nodes and the nodes of the met have different individual weights.
iii.
o ptimal d q in this section we introduce a new version of d q that divides the met into two parts with the same probability of containing the bug instead of two parts with the same weight .
we introduce a new algorithm that is correct and complete even if the met contains nodes with different individual weights that can be any decimal number greater than .
for this we define the search area of a met as the set of undefined nodes.
definition .
search area lett n e m be a met.
the search area oft sea t is defined asfn2nj m n unde nedg.
while d q uses the whole t we only use sea t because answering all nodes in sea t guarantees that we can discover all buggy nodes .
moreover in the following we refer to the individual weight of a node nwithwin and we refer to the weight of a sub tree rooted at nwithwnthat is recursively defined as wn pfwn0j n!n0 2egifm n unde ned win pfwn0j n!n0 2eg otherwise note that contrarily to standard d q the definition of wnexcludes those nodes that are not in the search area i.e.
the root node when it is wrong .
note also that winallows us to assign any individual weight to the nodes.
this is a generalization of d q where it is assumed that all nodes have the same individual weight and it is always .
for the sake of clarity given a node n2sea t we distinguish between three subareas of sea t induced by n nitself whose individual weight is win descendants ofn down n whose weight is dn pfwin0jn02sea t n!n0 2e g and the rest of nodes up n whose weight is un pfwin0jn02sea t n!n0 62e g example .
consider the met in figure .
assuming that the rootnis marked as wrong and all nodes have an individual weight of then sea t contains all nodes except n un0 3fig.
.
functions up and down total weight of the gray nodes and dn0 total weight of the white nodes .
clearly for any met whose root is nand a node n0 m n0 unde ned we have that wn un0 dn0 win0 equation wn0 dn0 win0 equation intuitively given a node n what we want to divide by half is the area formed by un dn.
that is nwill not be part ofsea t after it has been answered thus the objective is to makeunequal todn.
this is another important difference with traditional d q winshould not be considered when dividing the met.
we use the notation n1 n2to express thatn1divides sea t better than n2 i.e.
jdn1 un1j jdn2 un2j .
and we use n1 n2to express that n1andn2 equally divide sea t .
if we find a node nsuch thatun dn thennproduces an optimal division and should be selected by the strategy.
in the rest of this section we present an algorithm for optimal d q i.e.
that optimally divides the met by half .
in particular given a met algorithm efficiently determines the best node to divide sea t by half in the following the optimal node .
in order to find this node the algorithm does not need to compare all nodes in the met.
it follows a path of nodes from the root to the optimal node which is closer to the root producing a minimum set of comparisons.
algorithm optimal d q selectnode in algorithm input a met t n e m whose root is n2nand8n02 n wi n0 output a node noptimal2n preconditions 9n02n m n0 unde ned begin candidate n do best candidate children fmj best!m 2eg if children then return best candidate n0j8n00withn0 n002children wn0 wn00 while wcandidate wicandidate wn candidate n0j8n00withn0 n002children wn0 win0 wn00 win00 if m best wrong then return candidate if wn wbest wcandidate wibest wicandidate then return best else return candidate endexample .
consider the met in figure where 8n2 n win andm n unde ned .
fig.
.
defining a path in a met to find the optimal node observe that algorithm traverses the met top down from the root selecting at each level the heaviest node until we find a node whose weight minus its individual weight divided by two is smaller or equal than the half of the met wn thus defining a path in the met that is colored in gray.
finally the algorithm selects n1.
one important idea of the algorithm is the identification of a path from the root to the buggy node.
in particular when we use algorithm and compare two nodes n1 n2in a met whose root is n we find five possible cases see figure to define this path case dn1 un1 dn2 un2 n1 n2are brothers case dn1 un1 dn2 un2 n1 n2are brothers case dn1 un1 dn2 un2 n1!n2 2e case dn1 un1 dn2 un2 n1!n2 2e case dn1 un1 dn2 un2 n1!n2 2e case case case case case fig.
.
determining the best node in a met five possible cases in cases and n1is better i.e.
n1 n2orn1 n2 in case 3n2is better and in cases and the best node must be determined comparing them.
observe that these results allow the algorithm to determine the path to the optimal node that is closer to the root.
for instance in example .
case is used to select a child e.g.
node n1instead of node n4.
case is used to go down and select node n1instead of node n. case is used to select node n2instead of node n3 this is done with line of the algorithm .
case is used to stop going down at noden2because it is better than all its descendants.
and it is also used to determine that nodes n3andn4are better than all their descendants.
finally case is used to select the optimal node n1instead ofn2 this is done with line of the algorithm .
note that d q could have selected node n2 that is equally close to9 2than noden1 but it is suboptimal becauseun1 anddn1 whereasun2 anddn2 .the correctness of algorithm is stated by the following theorem.
theorem .
correctness lett n e m be a met where8n2n win then the execution of algorithm withtas input always terminates producing as output a node n2sea t such that n02sea t jn0 n. algorithm always returns a single optimal node.
however a small modification can make the algorithm to return all optimal nodes thus being complete changing line to collect all candidates instead of one and updating accordingly the output lines to return a set.
moreover line should be split to distinguish between the cases returningfbestg and returning candidates fbestg .
iv.
d ivide by queries an strategy should be consider optimal with respect to the number of questions generated if and only if the average number of questions asked with any met is minimum.
note that we can compute this average by assuming that the bug can be in any node of the met and thus computing the number of questions asked for each node using algorithm .
in this section we call optimal node to the first node asked by an optimal strategy instead of the node that better divides the met by the half .
definition .
optimal strategy let be an algorithmic debugging strategy.
given a met t n e m lets nthe sequence of questions made by algorithm with strategy and considering that the only buggy node in tisn2n.
let t p ni2njs nij.
we say that is optimal if and only if for any met t t .
in this section we show that any version of d q is and will be suboptimal.
the reason is that d q tries to prune the biggest possible subtree but it ignores the structure of the met.
in practice pruning complex subtrees that are more difficult to explore is very important but this is ignored by d q. this means that our version of d q algorithm is optimal in the sense that it optimally divides the met by the half.
but it is not an optimal strategy because in total considering all questions needed to find the bug it can perform more questions than necessary.
because we compute the cost of a strategy based on the number of questions asked we need a formal definition for sequence of questions.
definition .
sequence of questions given a met t n e m and two nodes n1 n22n asequence of questions ofn1with respect to n2 sq n1 n2 is formed by all nodes asked by algorithm when the first node selected by function selectnode t isn2and the only buggy node in tisn1.
this means that the sequence of questions is completely dependent on the used strategy.
for instance using standard d q with the met in figure left and assuming that all nodes are marked as undefined sq n n sq n3 n sq n n sq n3 n3 we now show a counterexample where d q cannot find an optimal node.
fig.
.
met where d q cannot find an optimal node example .
consider the met in figure left where the number at the right of the node represents jsq n n0 jbeing nthe node itself and n0the gray node.
d q would select node n1because its weight is closer to114 .
however n2is the only optimal node and it produces less questions than n1 even though its weight is far from .
in the met at the left we start asking node n1.
if the bug is located in the subtree of node n1 because it is a deep subtree we would ask an average of log257 83questions to each node 1because we have initially asked node n1 .
if the bug were not in this subtree then after asking node n1we would explore the subtree of node n2.
if the bug is located in this subtree we must ask all nodes until we find the bug and all these nodes have to consider the question already asked to noden1 in total we ask p51 i 3i questions.
if the bug were not located in the right brach there only remain the top nodes in the left branch including the root .
there we ask an average of log27 8questions to each node 2because we already asked nodes n1andn2 .
in total we ask57 91questions and an average of1796 76questions.
if contrarily we start asking node n2 see the met at the right and the bug is located in this subtree we ask p50 i 2i questions.
if the bug is located in the other branch after asking node n2we still have nodes in depth therefore with log264 questions 1because we have initially asked noden2 we will find the bug.
in total we ask questions and an average of1772 questions.
example .
showed that d q is not an optimal strategy.
the question now is whether an optimal strategy exists is the problem decidable?
theorem .
decidability given a met finding all optimal nodes is a decidable problem.
proof we show that at least one finite method exists to find all optimal nodes.
firstly we know that the size of the met is finite because the question in the root can only be completed if the execution terminated and hence the number of subcomputations and nodes is finite .
because the tree is finite we know according to algorithm that any sequence of questions asked by the debugger no matter the strategy used is also finite because at most all nodes of the tree are asked once.
therefore the number of possiblesequences is also finite.
this guarantees that we can compute all possible sequences and select the best sequences according to the equation in definition .
.
the optimal nodes will be the first of the selected sequences.
even though the method described in the proof of theorem .
is effective it is too expensive because it needs to compute all possible sequences of questions.
in the rest of this section we present a more efficient method to compute all optimal nodes.
we now present a method to select the best sequences of questions sqn for the nodes in a met.
for the sake of clarity in the following when we talk about the sequence of questions of a node we assume that this node is wrong and that the sequence contains a set of nodes that after they have been asked they allow us to know whether the node is buggy or not.
in order to formalize the method described in the proof of theorem .
we first define the notion of valid sequence of questions.
definition .
valid sequences of questions of a node lett n e m be a met whose root is n2n.
a sequence of questions sqn fornis valid if 8ni nj2sqn i j m ni!nj 62e nnfnjj ni!nj 2e ni2sqng fng we denote with sqnthe set of valid sequences of questions ofn.
intuitively the valid sequences of questions of a root node nare all those sequences formed with non repeated nodes that a node in the sequence cannot be descendant of a previous node in the sequence and after having pruned all the subtrees whose roots are the nodes of the sequence node nhas not descendants.
the next example shows that if we label each node of a met with a valid sequence of questions then it is possible to know how many questions do we need to ask to find the buggy node.
example .
consider the next tree here nodes are labeled with their weight inside their identifier top left an optimal sequence of questions for this node top right jsq n n jwherenis the node bottom right and the sum of jsq n0 n jfor all node n0of the subtree of this node n bottom left .
there exist many valid sequences for node n1 e.g.
etc.
.
if we consider the sequence of the figure and taking intoaccount that we start asking in the root node3 then we can easily determine the number of questions needed to find the bug in any node n. we refer to this number with qn.
for instance we need questions to find the bug in node n1 .
similarly qn4 and qn7 .
observe that when we reach noden7and mark it as wrong we continue the sequence of questions of this node .
once we have computed qfor all descendants of node n we can also compute the n s number at bottom left referred to asqn by adding all qs.
in the figure we see that qn1 qn2 and trivially the leafs only need one question the node itself .
therefore to find the optimal nodes we only have to i compute qnfor all nodes in the met ii add to the met a fictitious root node iii compute all valid sequences of the root node iv compute the cost associated to each sequence with algorithm and v select the first node of the sequences with the minimum cost.
essentially algorithm is used to compute qnof a given node.
for this it compositionally computes the number of questions that should be asked to each node.
this is done by taking into account the individual weight of each node that as with algorithm can be any number greater than or equal to .
example .
consider the following tree at the left with depth where we want to compute the cost qn1associated to the sequence .
function computeq takes the first element of the sequence n3 and computes the number of questions to be done if the bug is located in its subtree.
this is qn3 .
therefore no matter where the bug is we have to ask one extra question for each node the one in the root n1 .
thus we have a total of questions.
if the bug is not located in the subtree of n3 then we should continue asking questions of the sequence having pruned this subtree.
therefore we should prune this tree and recalculate qfor the ancestors of node n3.
this is done with function adjustintermediatenodes producing the tree with a depth of in the middle of the figure above.
in this new tree qn2has been recomputed and its value is .
then we proceed with the next question in the sequence n6 .
now we have qn6 questions.
but now we have to take into account two extra questions one for n1and one 3note that this does not mean that valid sequences must necessarily start asking the root node.
given any met we can add a new fictitious parent of the root and compute the optimal sequence of questions associated to this new node.forn3 for each node in the subtree of n6 questions.
hence we have a total of questions.
if the bug is not located in the subtree of node n6we prune it producing the tree at the right of the figure and we ask the next question in the sequence n2.
if the bug is n2 then we have to ask one question n2 plus the extra questions done before n1 n3andn6 .
thus we have a total of questions.
finally if the bug is located in the root we have to ask questions the root node itself and all questions in the sequence.
thus the final value of qn1 is .
the previous example illustrates the work done by algorithm to compute q. it basically computes and sums the number of questions asked for each node.
for this it has to take into account the sequence of questions in order to decide how many questions are cumulated when a new subtree is explored.
algorithm uses function computesq t n to compute all possible valid sequences of questions associated to node n. therefore because this function returns all possible sequences for the node then the strategy is optimal.
however note that this function could be restricted to behave as other strategies of the literature.
for instance we could adapt it to work as the strategy top down if we restrict the sequences returned to those where all elements in the sequence are children of n. this is equivalent to adding the following restriction to definition .
8n02sqn n!n0 2e v. p roofs of technical results we first define a met where individual weights can be decimal numbers definition .
variable met avariable met t n e m is a met where8n2n win .
theorem .
states the correctness of algorithm .
for the proof of this theorem we define first some auxiliary lemmas.
the following lemma ensures that wn1 win1 wn 2used in the condition of the loop implies dn1 un1.
lemma .
given a variable met t n e m whose root isn2nand a node n12sea t dn1 un1if and only ifwn1 win1 wn .
proof we prove that wn1 win1 wn 2impliesdn1 un1and vice versa.
wn1 win1 wn 22wn1 win1 wn we replace wn1using equation dn1 win1 win1 wn 2dn1 win1 wn dn1 wn dn1 win1 we replace wn dn1 win1using equation dn1 un1 the following lemma ensures that given two nodes n1and n2wheredn unin both nodes and n1!n2thenn2 n1 n2 n1 case .algorithm computeqn input a met t n e m and a node n2n output qn sqn qn computeoptimalsequence t n return qn function computeoptimalsequence t n begin sqn computesq t n sqoptimal sqn2sqnj sq0 n2sqn computeq t n sq n computeq t n sq0 n qoptimal computeq t n sqoptimal return sqoptimal qoptimal end function computeq t n sq n begin questions indexnode accumnodes while fn0j n!n0 2e g6 fng node sqn indexnode indexnode questions questions qnode accumnodes wnode accumnodes accumnodes t adjustintermediatenodes t n node end while questions questions accumnodes win return questions end function adjustintermediatenodes t n n0 begin o fn002nj n0!n00 2e g n nno n0 n00j n00!n0 2e while n06 n qn0 computeoptimalsequence t n0 wn0 wn0 joj n0 n00j n00!n0 2e end while return t end lemma .
given a variable met t n e m and given two nodes n1 n22sea t with n1!n2 2e if dn2 un2thenn2 n1 n2 n1.
proof we prove thatjdn2 un2j jdn1 un1jholds.
first we know that dn1 dn2 win2 incandun1 un2 win1 incwithinc whereincrepresents the weight of the possible brothers of n2.
jdn2 un2j jdn1 un1j as we know that dn unin both nodes dn2 un2 dn1 un1 we replace dn1andun1 dn2 un2 dn2 win2 inc un2 win1 inc dn2 un2 dn2 un2 win1 win2 2inc win1 win2 2inc hence because win1 win2 inc 0thenjdn2 un2j jdn1 un1jis satisfied and thus n2 n1 n2 n1.
the following lemma ensures that given two nodes n1and n2wheredn unin both nodes and n1!n2thenn1 n2 n1 n2 case .
lemma .
given a variable met t n e m and given two nodes n1 n22sea t with n1!n2 2e if dn1 un1thenn1 n2 n1 n2.proof we prove thatjdn1 un1j jdn2 un2jholds.
first we know that dn2 dn1 win2 incandun2 un1 win1 incwithinc whereincrepresents the weight of the possible brothers of n2.
jdn1 un1j jdn2 un2j as we know that un dnin both nodes un1 dn1 un2 dn2 we replace dn2andun2 un1 dn1 un1 win1 inc dn1 win2 inc un1 dn1 un1 dn1 win1 win2 2inc win1 win2 2inc hence because win1 win2 inc 0thenjdn1 un1j jdn2 un2jis satisfied and thus n1 n2 n1 n2.
the following lemma ensures that given two brother nodes n1andn2 ifdn1 un1thendn2 un2.
lemma .
given a variable met t n e m whose root isn2n and given three nodes n12nandn2 n32 sea t with n!n1 2e n1!n2 n1!n3 2e ifdn2 un2thendn3 un3.
proof we prove it by contradiction assuming that dn3 un3whendn2 un2and they are brothers.
first we know that asn2andn3are brothers then un2 wn3andun3 wn2.
therefore if dn3 un3thendn2 un2 wn3 dn3 un3 wn2 dn2that implies dn2 dn2that is a contradiction itself.
if two nodes n1andn2are brothers and dn1 un1then n1 n2 n1 n2 case .
the following lemma proves this property.
lemma .
given a variable met t n e m whose root isn2n and given three nodes n12nandn2 n32 sea t with n!n1 2e n1!n2 n1!n3 2e ifdn2 un2thenn2 n3 n2 n3.
proof we prove thatjdn2 un2j jdn3 un3jholds.
first asn2andn3are brothers we know that wn dn2 dn3 win2 win3 thenwn dn2 dn3 win2 win3 inc withinc .
jdn2 un2j jdn3 un3j asdn2 un2by lemma .
we know that un3 dn3 dn2 un2 un3 dn3 we replace un2andun3using equation dn2 wn dn2 win2 wn dn3 win3 dn3 wn 2dn2 win2 wn 2dn3 win3 2wn 2dn2 2dn3 win2 win3 2wn 2dn2 2dn3 win2 win3 wn dn2 dn3 win2 win3 2we replace wn dn2 dn3 win2 win3 inc dn2 dn3 win2 win3 win2 win3 inc win2 win3 2win2 win3 inc hence because win2 win3 inc 0thenjdn2 un2j jdn3 un3jis satisfied and thus n2 n3 n2 n3.
the following lemma ensures that given two brother nodes n1andn2 ifwn1 wn2anddn1 un1thendn2 un2.
lemma .
given a variable met t n e m whose root isn2n and given three nodes n12nandn2 n32 sea t with n!n1 2e n1!n2 n1!n3 2e ifwn2 wn3anddn2 un2thendn3 un3.
proof we prove it by contradiction assuming that dn3 un3whenwn2 wn3anddn2 un2and they are brothers.
first we know that as n2andn3are brothers then un2 wn3andun3 wn2.
therefore if dn3 un3thendn3 un3 wn2 wn3 dn3that implies dn3 dn3that is a contradiction itself.
if two nodes n1andn2are brothers and un1 dn1 un2 dn2then ifwn1 win1 wn2 win2 2is satisfied then n1 n2 n1 n2 case .
the following lemma proves this property.
lemma .
given a variable met t n e m whose root isn2n and given three nodes n12nandn2 n32 sea t with n!n1 2e n1!n2 n1!n3 2e andun2 dn2andun3 dn3 n2 n3 n2 n3if and only ifwn2 win2 wn3 win3 .
proof first ifjdn2 un2j jdn3 un3jthenn2 n3 n2 n3.
thus it is enough to prove that wn2 win2 wn3 win3 2impliesjdn2 un2j jdn3 un3jand vice versa whenun dnin both nodes and they are brothers.
wn2 win2 wn3 win3 22wn2 win2 2wn3 win3 we replace wn2andwn3using equation dn2 win2 win2 dn3 win3 win3 2dn2 win2 2dn3 win3 we add wn wn 2dn2 win2 wn 2dn3 win3 wn 2dn2 win2 wn 2dn3 win3 we replace wnusing equation dn2 un2 win2 2dn2 win2 dn3 un3 win3 2dn3 win3 dn2 un2 dn3 un3 un2 dn2 un3 dn3 asun dnin both nodes jun2 dn2j jun3 dn3j jdn2 un2j jdn3 un3j if two nodes n1andn2are brothers and dn1 un1and n2!
n3then ifn1 n2thenn1 n3 n1 n3.
the following lemma proves this property.
lemma .
given a variable met t n e m whose root isn2n and given four nodes n12nandn2 n3 n42 sea t with n!n1 2e n1!n2 n1!n3 2e n3!n4 2e ifdn2 un2andn2 n3thenn2 n4 n2 n4.
proof this can be trivially proved having into account thatdn3 un3whendn2 un2by lemma .
and then by lemma .
we know that n3 n4 n3 n4and asn2 n3 thenn2 n4 n2 n4.
if two nodes n1andn2are brothers and dn1 un1 dn2 un2andn2!
n3then ifn1 n2thenn1 n3 n1 n3.
the following lemma proves this property.
lemma .
given a variable met t n e m whose root isn2n and given four nodes n12nandn2 n3 n42 sea t with n!n1 2e n1!n2 n1!n3 2e n3!n4 2e ifdn2 un2anddn3 un3andn2 n3 thenn2 n4 n2 n4.
proof this can be trivially proved having into account thatdn3 un3and then by lemma .
we know that n3 n4 n3 n4and asn2 n3thenn2 n4 n2 n4.
if two nodes n1andn2are brothers and n1 n2and n2!
n3thenn1 n3.
the following lemma proves this property.lemma .
given a variable met t n e m whose root isn2n and given four nodes n12nandn2 n3 n42 sea t with n!n1 2e n1!n2 n1!n3 2e n3!n4 2e ifn2 n3thenn2 n4.
proof we show that if n2 n3thendn3 un3.
we prove it by contradiction assuming that dn3 un3whenn2 n3.
first asn2andn3are brothers we know that wn dn2 dn3 win2 win3 thenwn dn2 dn3 win2 win3 inc withinc .
therefore ifjdn2 un2j jdn3 un3jthen n2 n3.
thus it is enough to prove that jdn2 un2j jdn3 un3jis not satisfied when dn3 un3andn2andn3 are brothers.
jdn2 un2j jdn3 un3j asdn3 un3by lemma .
we know that un2 dn2 un2 dn2 dn3 un3 we replace un2andun3using equation wn dn2 win2 dn2 dn3 wn dn3 win3 wn 2dn2 win2 2dn3 wn win3 2wn 2dn2 2dn3 win2 win3 wn dn2 dn3 win2 win3 2we replace wn dn2 dn3 win2 win3 inc d n2 dn3 win2 win3 win2 win3 inc win2 win3 2win2 win3 inc but this is a contradiction with win2 win3 inc .
hence dn3 un3.
now we show that if n2 n3thenn2 n4.
we prove it by contradiction assuming that n4 n2 n4 n2when n2 n3.
first we know that dn3 un3.
therefore we know thatdn4 dn3 win4 decandun4 un3 win3 dec withdec wheredecrepresents the weight of the possible brothers ofn4.
jdn3 un3j jdn2 un2j jdn4 un4j we replace dn4andun4 jdn3 un3j jdn2 un2j jdn2 un2j j dn3 win4 dec un3 win3 dec j jdn2 un2j jdn3 win4 dec un3 win3 decj jdn2 un2j jdn3 un3 win3 win4 2decj note thatdn3 un3must be positive thus dn3 un3.
but this is a contradiction with dn3 un3.
the following lemma ensures that given two nodes n1and n2wheredn1 un1anddn2 un2andn1!n2then ifwn wn1 wn2 win1 win2 2is satisfied then n1 n2 n1 n2 case .
lemma .
given a variable met t n e m and given two nodes n1 n22sea t with n1!n2 2e and dn1 un1 anddn2 un2 n1 n2 n1 n2if and only ifwn wn1 wn2 win1 win2 .
proof first ifjdn1 un1j jdn2 un2jthenn1 n2 orn1 n2.
thus it is enough to prove that wn wn1 wn2 win1 win2 2impliesjdn1 un1j jdn2 un2jand vice versa when dn1 un1anddn2 un2.wn wn1 wn2 win1 win2 2we replace wn1 wn2using equation wn dn1 win1 dn2 win2 win1 win2 wn dn1 dn2 win1 win2 22wn 2dn1 2dn2 win1 win2 2wn 2dn1 2dn2 win1 win2 wn 2dn1 win1 wn 2dn2 win2 we replace wnusing equation dn1 un1 win1 2dn1 win1 dn2 un2 win2 2dn2 win2 dn1 un1 win1 2dn1 win1 dn2 un2 win2 2dn2 win2 un1 dn1 dn2 un2 dn1 un1 un2 dn2 asdn1 un1anddn2 un2 jdn1 un1j jun2 dn2j jdn1 un1j jdn2 un2j finally we prove the correctness of algorithm .
theorem .
.
lett n e m be a variable met then the execution of algorithm with tas input always terminates producing as output a node n2sea t such that n02 sea t jn0 n. proof the finiteness of the algorithm is proved thanks to the following invariant each iteration processes one single node and the same node is never processed again.
therefore becausenis finite the loop will terminate.
the correctness can be proved showing that after any number of iterations the algorithm always finishes with an optimal node.
we prove it by induction on the number of iterations performed.
induction hypothesis afteriiterations the algorithm has a candidate node best2sea t such that8n02 sea t best!n0 62e best n0 best n0.
inductive case we prove that the iteration i of the algorithm will select a new candidate node candidate such thatcandidate best candidate best or it will terminate selecting an optimal node.
firstly when the condition in line is satisfied best and candidate are the same node say n0 .
according to the induction hypothesis this node is better or equal than any other of the nodes in the set fn002sea t j n0!n00 62e g. therefore because n0has no children then it is an optimal node and it is returned in line .
otherwise if the condition in line is not satisfied line in the algorithm ensures thatwbest wibest wn 2beingnthe root oftbecause in the iteration ithe loop did not terminate or because best is the root observe that an exception can happen when all nodes have an individual weight of .
but in this case all nodes are optimal and thus the node returned by the algorithm is optimal .
then we know that dbest ubest by lemma .
.
moreover according to lines and we know thatcandidate is the heaviest child of best .
we have two possibilities dcandidate u candidate in this case the loop does not terminate and8n02sea t candidate!n0 62e candidate n0 candidate n0.
firstly by lemma .
we know that candidate best candidate best and thus by the induction hypothesis we know that 8n02sea t best!
n0 62e candidate n0 candidate n0.
by lemma .
we know that candidate n0 candidate n0being n0a brother of candidate .
moreover by lemma .
and .
wecan ensure that candidate n0 candidate n0being n0 a descendant of a candidate s brother.
dcandidate ucandidate in this case the loop terminates line and we know by lemma .
that dn0 un0being n0any brother of candidate .
in line according to lemma .
we select the candidate such that candidate n0 candidate n0being n0a brother of candidate .
moreover by lemma .
and .
we can ensure that candidate n0 candidate n0being n0a descendant of a candidate s brother.
then equation wn wbest wcandidate wibest wicandidate is applied in line to select an optimal node.
lemma .
ensure that the node selected is an optimal node because according to lemma .
for all descendant n0ofcandidate candidate n0 candidate n0.
vi.
c onclusion during three decades divide query has been the more efficient algorithmic debugging strategy.
on the practical side all current algorithmic debuggers implement d q and experiments see also jsilva ddj experiments demonstrate that it performs on average less questions than other strategies.
on the theoretical side because d q intends a dichotomic search it has been thought optimal with respect to the number of questions performed and thus research on algorithmic debugging strategies has focused on other aspects such as reducing the complexity of questions.
in this work we show that in some situations current algorithms for d q are incomplete and inefficient because they are not able to find all optimal nodes and sometimes they return nodes that are not optimal.
we have identified the sources of inefficiency and provided examples that show both the incompleteness and incorrectness of the technique.
a relevant contribution of this work is a new algorithm for d q that optimally divides the et even in the case where all nodes of the et can have different individual weights inr f0g.
the algorithm has been proved terminating and correct.
and a slightly modified version of the algorithm has been provided that returns all optimal solutions thus being complete.
we have implemented the technique and experiments show that it is more efficient than all previous algorithms.
other important contributions are the proof that d q is not optimal in the worst case as supposed and the definition of the first optimal strategy for algorithmic debugging.
the implementation including the source code and the experiments are publicly available at jsilva ddj.