see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation mining api mapping for language migration conf erence paper in proceedings int ernational conf erence on softw are engineering may .
.
sour ce dblp citations 145reads author s including hao zhong shanghai jiao t ong univ ersity publica tions citations see profile tao xie univ ersity of illinois urb ana champ aign publica tions citations see profile lu zhang peking univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y tao xie on dec ember .
the user has r equest ed enhanc ement of the do wnlo aded file.mining api mapping for language migration hao zhong1 suresh thummalapenta4 tao xie4 lu zhang2 qing wang1 1laboratory for internet software technologies institute of software chinese academy of sciences beijing china 2key laboratory of high confidence software technologies peking university ministry of education china 3institute of software school of electronics engineering and computer science peking university china 4department of computer science north carolina state university raleigh nc usa zhonghao itechs.iscas.ac.cn sthumma txie ncsu.edu zhanglu sei.pku.edu.cn wq itechs.iscas.ac.cn abstract to address business requirements and to survive in competing markets companies or open source organizations often have to release different versions of their projects in different languages.
manually migrating projects from one language to another such as from java to c is a tedious and error prone task.
to reduce manual effort or human errors tools can be developed for automatic migration of projects from one language to another.
however these tools require the knowledge of how application programming interfaces apis of one language are mapped to apis of the other language referred to as api mapping relations.
in this paper we propose a novel approach called mam mining apimapping that mines api mapping relations from one language to another using api client code.
mam accepts a set of projects each with two versions in two languages and mines api mapping relations between those two languages based on how apis are used by the two versions.
these mined api mapping relations assist in migration of projects from one language to another.
we implemented a tool and conducted two evaluations to show the effectiveness of mam.
the results show that our tool mines unique mapping relations of apis between java and c with more than accuracy.
the results also show that mined api mapping relations help reduce .
compilation errors and .
defects during migration of projects with an existing migration tool called java2csharp.
the reduction in compilation errors and defects is due to our new mined mapping relations that are not available with the existing migration tool.
categories and subject descriptors d. .
reusable software reusable libraries general terms api mapping relation language migration .
introduction to address business requirements and to survive in competing markets companies or open source organizations often have to release different versions of their projects in different languages.
for corresponding authors permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.example many well known projects such as lucene1and wordnet2provide multiple versions in different languages.
for some open source projects although their project teams do not officially provide multiple versions external programmers often create their versions in different languages.
for example the wordnet team does not provide a c version but simpson and crowe developed a c version of wordnet.net3.
as described by jones about one third of the existing projects have multiple versions in different languages.
migrating projects from one language to another language e.g.
from java to c manually is a tedious and error prone task.
in the literature there exist approaches and tools e.g.
java2csharp4 that address the problem of language migration partially since these approaches and tools expect programmers to describe how application programming interfaces apis of one language are mapped to apis of another language.
since there are a large number of apis provided in different languages writing mappings manually for all apis is tedious and error prone.
as a result these approaches and tools support only a subset of apis for migration.
such a limitation results in many compilation errors in migrated projects and limits these approaches usage in practice see section .
for details .
in this paper we propose a novel approach called mam mining apimapping that automatically mines how apis of one language are mapped to apis of another language.
we refer to this mapping asapi mapping relations in short as relations in the rest of the paper .
mam mines relations based on api usages in client code rather than based on api implementations for three major reasons.
api libraries often do not come with source files especially for those c libraries.
relations mined based on api implementations often have lower confidence than relations mined based on api usages.
the reason is that api implementations have only one data point for analysis whereas api usages can have many data points i.e.
call sites for mining.
mapping relations of apis are often complex and cannot be mined based on the information available in the api implementations.
first mapping parameters of an api method in one language with an api method in the other language can be complex.
for example consider the following two api methods in java and c m1in java bigdecimal java.math.bigdecimal.multiply bigdecimal p1 m2in c decimal system.decimal.multiply decimal p2 decimal p2 here m1has a receiver say v1 of type bigdecimal and has one parameter p1 whereas m2has two parameters p2 1andp2 .
for these two api methods v1 1is mapped to p2 and p1 1is mapped to p2 .
second an api method of one language can be mapped to more one api method in the other language.
for example consider the following two api methods m3in java e java.util.linkedlist.removelast m4in c void system.collections.generic.linkedlist.removelast although the method names of m3andm4are the same m3in java cannot be directly mapped with m4in c .
the reason is that m3in java returns the last element removed from the list represented as e whereas m4does not return any element.
therefore m3is mapped to two api methods m4andm5 shown below in c .
the api method m5returns the last element and should be invoked before invoking m4.
m5in c e system.collections.generic.linkedlist.last to deal with the complexity of mining api mapping we construct a graph referred to as api transformation graph atg for aligned methods of the client code in both languages.
these atgs precisely capture inputs and outputs of api methods and help mine complex mapping relations of api methods.
this paper makes the following major contributions the first approach called mam that mines api mapping relations between different languages using api client code.
mam addresses an important and yet challenging problem that is not addressed by previous work on language migration.
api transformation graphs atgs proposed to capture inputs and outputs of api methods and a technique for building atgs and comparing built atgs for mining api mapping relations.
since atgs describe data dependencies among inputs and outputs of api methods mam is able to mine complex mapping relations between api methods of the two languages.
a tool implemented for mam and two evaluations on projects that include classes and methods with both java and c versions.
the results show that our tool mines unique mapping relations with more than accuracy including mapping relations of api classes with accuracy of .
and mapping relations of api methods with accuracy of .
.
the results also show that the mined relations reduce .
of compilation errors and .
defects during migration of projects from java to c using java2csharp an existing migration tool.
the rest of this paper is organized as follows.
section presents definitions.
section illustrates our approach using an example.
section presents our approach.
section presents our evaluation results.
section discusses issues of our approach.
section presents related work.
finally section concludes.
.
definitions we next present definitions of terms used in the rest of the paper.
api.
an application programming interface api is a set of classes and methods provided by frameworks or libraries.
api library.
an api library is a framework or library that provides reusable api classes and methods.
client code.
client code is application code that reuses or extends api classes and methods provided by api libraries.
the definitions of api library and client code are relative to each other.
for example lucene uses classes and methods provided by j2se5.
therefore we consider lucene as client code and j2se as an api library.
at the same time nutch6uses classes and methods by lucene.
therefore we consider nutch as client code and lucene as an api library.
in general for programmers of client code source files of api libraries may not be available.
mapping relation.
for entities e1 such as api classes and methods in a language l1and entities e2in another language l2 a mapping relation is a triple e1 e2 b where migrating between e1ande2maintains the bbehavior.
the bbehavior is specific to the type of the entities.
mapping relation of api classes.
for data entities whose type set is c1inl1and data entities whose type set is c2inl2 a mapping relation of api classes is a triple c1 c2 s where migrating between c1andc2maintains the sbehavior.
since we use mapping relations of api classes for migrating data entities such as variables parameters and constants we require that two mapped api classes have the same program behavior to store data referred to as the sbehavior.
for example the current time in java.lang.system of java is stored in system.datetime of c whereas the environment settings in java.lang.system of java is stored in system.environment of c .
therefore the java class has a one to many mapping relation with two c classes.
mapping relation of api methods.
for invoked api methods m1inl1and invoked api methods m2inl2 a mapping relation of api methods is a triple m1 m2 t where migrating between m1andm2maintains the tbehavior.
since we use mapping relations of api methods for migrating api methods that accept inputs to produce desirable outputs we require two mapped api methods have the same program behavior of inputs outputs and functionalities.
we refer to this behavior as the tbehavior.
for example section shows a one to many mapping relation between m3 of java and m4 m5 of c .
.
example we next use an example to illustrate challenges in mining api mapping relations.
figure shows a java code example and its migrated c code.
this java code example accepts a string input that represents the name of a file or directory and returns a boolean value that describes whether the file or directory exists.
to achieve this functionality the code example declares a local variable called file of type java.io.file and invokes the exists method.
the method takes the string input and file as its inputs and produces the desirable boolean value.
here we consider file a receiver as a special input for the exists method.
to migrate this code example into c a language migration tool needs to know mapping relations of api classes so that it can migrate inputs outputs and variables into c .
for example the migration tool needs to know the mapped api class in c for java.io.file to migrate the variable file to c .
in addition the migration tool needs to know the mapped api methods so that it can add code for invoking proper api methods that take migrated inputs and variables to produce desirable outputs.
for this example the migration tool adds code for invoking the exists method and the fullname method to achieve the functionality.
here we consider field accesses as special types of method invocations.
to mine these mapping relations mam uses projects such as lucene that have both java and c versions.
mam includes three major steps to mine the preceding two types of mapping relations of apis from these projects.
aligning client code.
first mam aligns classes and methods between the two versions of each project.
since two code examples with the same functionality of two languages may exhibit mapping relations of apis this step aligns classes and methods by their functionalities.
to achieve this goal mam uses a mapping algorithm based on similarities in the names of classes and methods definedjava code file file new file test boolean b file.exists migrated c code fileinfo file new fileinfo test boolean b system.io.file.exists file.fullname system.io.directory.exists file.fullname figure java code and its migrated c code indexfiles.java public class indexfiles static final file index dir new file index public static void main string args ... if index dir.exists ... ... index dir.delete indexfiles.cs class indexfiles internal static readonly system.io.fileinfo index dir new system.io.fileinfo index public static void main system.string args ... bool tmpbool if system.io.file.exists index dir.fullname tmpbool true else tmpbool system.io.directory .exists index dir.fullname ... figure two versions java and c of client code in the two versions of each project.
aligning client code based on the names of classes and methods is based on an observation on many existing projects such as rasp7 migrated from one language to another.
we observed that while migrating the rasp project from c to java programmers first renamed source files from c to java and systematically addressed the compilation errors by replacing c apis with java apis.
during this procedure the names of classes methods fields of classes or local variables in methods often remain the same or similar between the two versions.
therefore we use name similarities for aligning client code of the two versions.
for example mam aligns indexfiles.java with the indexfiles.cs shown in figure since the names of their classes and methods are similar.
mining api mapping of classes.
next mam mines mapping relations of api classes by comparing the names of data entities such as the names of fields in aligned classes variables or parameters in aligned methods.
mam uses name similarities for comparing the names of these entities.
for example mam identifies the args parameters in lines java and c figure and maps the api classes that are the types of the two parameters.
based on this parameter mam maps the api class java.lang.string of java to system.string of c .
mining api mapping of methods.
after mapping api classes between the two languages mam maps api methods.
mapping api methods is challenging since often an api method of one language can be mapped to multiple api methods of the other language.
furthermore mapping relations of api methods should also describe how parameters and returns are mapped among these api methods.
to address these challenges mam constructs a graph referred to as api transformation graph atg for each aligned method of the client code in both languages.
these atgs precisely capture inputs and outputs of api methods and help mine mapping relations of api methods.
for example mam mines a mapping relation from java.io.file.exists in java to system.io.file.
exists andsystem.io.directory.exists in c .
by a close look at the api document for these api methods we can find that the java method can check whether a file or directory exists and this functionality is fulfilled by two c api methods system.io.
for checking whether a file exists and system.io.
directory.exists for checking whether a directory exists.
section .
presents more details on how we mine these mapping relations of api methods.
.
approach mam accepts a set of projects as data sources for mining api mapping relations between two languages l1andl2.
for each project used as a data source mam requires two versions of the project one version in l1and the other version in l2 .
figure shows the overview of mam.
.
aligning client code initially mam accepts two versions of a project one version inl1and the other version in l2 and aligns classes and methods defined in the two versions.
aligned classes or methods between the two versions implement a similar functionality.
since these two versions implement a similar functionality apis used by these classes or methods could be replaceable.
to align classes and methods defined in the two versions mam uses name similarities between entities such as class names or method names defined by the two versions of the project.
in mam we have two different kinds of entity names entity names defined by the two versions of the project and entity names of third party libraries used by the two versions of the project.
the first kind often comes from the same programmer or the same team or programmers may refer to existing versions when naming entities such as classes methods and variables.
therefore name similarity of the first kind is often helpful to distinguish functionalities compared to the second kind.
mam uses the levenstein measure provided by simmetrics8to calculate name similarities.
we next describe how mam aligns client code classes i.e.
classes defined in client code .
the first step is to find candidate class pairs based on similarities of class names.
for two sets of classes candc from two versions mam returns candidate class pairs m with name similarity greater than a given threshold referred to as sim threshold .
since some projects may have more than one class with the same or similar name mmay contain more than one pair for a class in a version.
to align these classes mam uses package names of these classes to refine mand returns only one pair with the maximum similarity for each class.
for c we refer to namespace names for package names.
in each aligned class pair mam further aligns methods within the class pair.
the alignment algorithm for methods is similar to the algorithm for classes and also may return more than one candidate method pair due to overloading.
here the algorithm for methods relies on criteria such as the number of parameters and names of parameters to refine candidate method pairs.
for the example shown in section mam correctly aligns the class indexfiles and the method main in java to the class indexfiles and the method main in c respectively since their names are quite similar.
since mam returns pairs mam may sometimes fail to map some classes or methods see section for details .
.
mapping api classes in the second step mam mines mapping relations of api classes.
as mapping relations of api classes are used to migrate variables in language migration mam mines mapping relations of api classes based on how aligned client code declares variables such as fields of aligned classes and parameters and local variables of aligned methods.
for each aligned class pair c1 c2 mam analyzes each g8822 g88214 1version g31 version g321.
g3client g3code g3 alignment class g3pair g3and g3 method g3pair .
g3api g3class g3 mapping mapping g3relations g3 .apimethod mapping g3relations g3 of g3api g3methods of g3api g3classes .
g3api g3method g3 mapping figure overview of mam field pair f1 f2 and considers f1 type f type as a relation if the similarity between f1 name andf2 name is greater than sim threshold .
similarly for each aligned method pair m1 m2 mam analyzes each local variable pair v1 v2 and considers v1 type v2 type as a relation if the similarity between v1 name andv2 name is greater than sim threshold .
mam also analyzes each parameter pair p1 p2 ofm1andm2 and considers p1 type p type as a relation when the similarity between p1 name andp2 name is greater than sim threshold .
for the example shown in figure mam mines the mapping relation between java.lang.string andsystem.string based on the mapped parameters of lines and .
the mapping relation of api classes helps migrate the variable declared in line figure to the variable declared in line figure .
.
mapping api methods in the third step mam first builds a graph for each client code method and then compares the two graphs of each pair of clientcode methods for mining mapping relations of api methods.
.
.
api transformation graph we propose api transformation graphs atgs to capture api usages of client code methods.
using atgs has two main benefits for mining.
first an atg describes inputs outputs and names of api methods and helps compare api methods from various dimensions.
second an atg describes data dependencies among api methods and helps mine mapping relations of multiple api methods.
an atg of a client code method mis a directed graph g ndata nm e .ndata is a set of the fields fofm s declaring class local variables vofm parameters p1ofm parameters p2of api methods invoked by m and returns rof all invoked methods.
nm is a set of all methods both api methods and client code methods invoked by m.eis a set of directed edges.
an edge d1 d2from a datum d1 ndatato a datum d2 ndatadenotes that d2is datadependent on d1 referred to as data dependency from d1tod2.
in our representation a data dependency edge is shown as a dotted line.
in addition an edge d1 m1from a datum d1 ndata to a method m1 nmdenotes that d1is a parameter or receiver of m1.
similarly an edge m1 d1from a method m1 nmto a datum d1 ndata denotes that d1is the return of m1.
.
.
building api transformation graphs mam builds an atg for each method mdefined in the client code called a client code method.
atg includes information such as inputs and outputs for each client code method.
in particular for each client code method m mam first builds subgraphs for its local variables invoked api methods and field accesses.
mam adds additional edges to the built atg and sub graphs inside the atg and these additional edges represent data dependencies among built sub graphs.
we use two notations for representing nodes in the atg.
a rectangle represents a method labeled with the method name whereas an ellipse represents a datum such as fields local variables and parameters.
an ellipse is labeled as n t where nis the name of the variable tis its type and null t denotes return values which have no names.
we use the following rules for adding nodes and edges to the atg.
.for each f f v p1 mam adds a node to the built atg.
the reason for considering these variables such as fields in the declaring class or local variables in method mused in client code is that these variables are useful to analyze data dependencies among api methods.
section .
.
defines f v and p1.
.for each api method in the form t0t am t1p1 t npn invoked by method m mam adds a receiver node of type t a return node and parameter nodes to the built atg as shown below.
mam does not add a receiver node for static api methods.
note that t0 randpi p2.
g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each f f v iffis a non primitive variable of type t1and a field xoft1is accessed as f x mam adds nodes to the built atg as shown below.
since java often uses getters and setters whereas c often uses field accesses mam treats field accesses as special types of method invocations.
g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each statement in the form x y where x f v y f v mam adds an edge from ytox.
this edge represents thatxis data dependent on y. g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each statement in the form x am where x f v mam adds an edge from am toxto indicate that the return of am is assigned to x. this edge represents that xis data dependent on the return of am.
g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each api method am x invoked by method m mam adds an edge from xto the parameter node of am.
this edge represents that the parameter of am is data dependent onx.
g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each statement in the form m2 m1 x mam adds an edge from the return node of m1to the parameter node of m2.
this edge represents that the parameter of m2is datadependent on the return of m1.
g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each statement in the form x m mam adds an edge from xtomsince xis the receiver of m. this edge represents that the receiver of mis data dependent on x. g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t .for each statement in the form x y op z op op mam adds edges from y z and others to x since these variables are connected by binary operations and the return is assigned to x. the edge denotes the data dependency from y z and other variables to x. for simplicity mam ignores opinfo.
we discuss this issue in section .
g8822 g88214 1arg0 system.string index system.string index java.lang.string line g311 step1 step2 system.io.fileinfo.getfullname index dir system.io.fileinfo null system.string null java.io.file j i fil d l t arg0 java.lang.string receiver g3 java.io.file receiver g3 java.io.file null g3system.io.fileinfo system.io.fileinfo.fileinfo java.io.file.file index dir java.io.file java io file exists line g36 line14 line g317 system.io.fileinfo.getfullname index dir system.io.fileinfo null system.string receiver system.io.fileinfo receiver system.io.fileinfo step2 system.io.directory.exists null system.boolean system.io.file.exists a b null system.boolean null boolean java.
io.
fil e. delete null boolean java .io .file .exists line g38 line g39line g314 path system.string path system.string step3 step3 step3 step4 step4 figure built atgs and the main steps of comparing atgs g8821 g88220 1f.name f.type null t 0am p1 t ...pn t n receiver g3t x.name x.type y.name y.type z.name z.type null t am x.name x.type ... x.name x.type y.name y.type null t am x.name x.type p t am x.name x.type am 1x.name x.type p t null t am 2p t null t null t 0getx receiver t am 2p t null t am x.name x.type receiver t for each client code method m mam applies the preceding rules for each statement from the beginning to the end of m s method body.
within each statement mam applies these rules based on their nesting depth in the abstract syntax tree.
for example for the statements of the form m2 m1 x mam first applies these rules on m1and then on m2.
our construction is similar to static slicing with emphasis on api call sites.
figures 4a and 4b show partial atgs for the two main methods ofindexfiles.cs andindexfiles.java shown in figure respectively.
figure also shows corresponding line numbers of each sub graph.
mam applies rules and for lines and figure to build corresponding sub graphs in the atg.
mam applies rules and to build corresponding sub graphs for lines and figure .
for simplicity we do not show the nodes for the local variable tmpbool in the built atgs in figure .
.
.
comparing api transformation graphs the second sub step compares each pair of built atgs for mining mapping relations of api methods.
our mapped api methods should satisfy three criteria.
the mapped api methods implement the same functionality.
the mapping relation describes the relation between parameters and receivers of mapped api methods.
the mapping relation describes the relation between returns of mapped api methods.
the two mapped api methods in two different languages satisfying the preceding three criteria are replaceable in the client code.
therefore these mapped api methods assist for migrating client code from one language to another.
algorithm presents major steps of comparing atgs for mining mapping relations of api methods.
for each pair of aligned methods mandm the findvarpairs function finds mapped variables and constants as follows.
for two variables vandv f v and p1inmandm respectively findvarpairs maps v andv if the similarity metric value on their names is greater than sim threshold .
for constants in mandm findvarpairs maps those two constants if they have exactly the same value.
from mapped variables and constants our algorithm uses the following criteria to find mapping relations between the two api methodsjmandsm.
mapped inputs the first criterion is based on the inputs of jm andsm.
we map jmwithsm if there is a to mapping between arg0 system.string index system.string index java.lang.string line g311 step1 step2 system.io.fileinfo.getfullname index dir system.io.fileinfo null system.string null java.io.file j i fil d l t arg0 java.lang.string receiver g3 java.io.file receiver g3 java.io.file null g3system.io.fileinfo system.io.fileinfo.fileinfo java.io.file.file index dir java.io.file java io file exists line g36 line14 line g317 system.io.fileinfo.getfullname index dir system.io.fileinfo null system.string receiver system.io.fileinfo receiver system.io.fileinfo step2 system.io.directory.exists null system.boolean system.io.file.exists a b null system.boolean null boolean java.
io.
fil e. delete null boolean java .io .file .exists line g38 line g39line g314 path system.string path system.string step3 step3 step3 step4 step4 figure built atgs and the main steps of comparing atgs x.name x.type y.name y.type z.name z.type ... null t x.name x.type am 2p t null t for each client code method m mam applies the preceding rules for each statement from the beginning to the end of m s method body.
within each statement mam applies these rules based on their nesting depth in the abstract syntax tree.
for example for the statements of the form m2 m1 x mam first applies these rules on m1and then on m2.
our construction is similar to static slicing with emphasis on api call sites.
figures 4a and 4b show partial atgs for the two main methods of indexfiles.cs and indexfiles.java shown in figure respectively.
figure also shows corresponding line numbers of each sub graph.
mam applies rules and for lines and figure to build corresponding sub graphs in the atg.
mam applies rules and to build corresponding sub graphs for lines and figure .
for simplicity we do not show the nodes for the local variable tmpbool in the built atgs in figure .
.
.
comparing api transformation graphs the second sub step compares each pair of built atgs for mining mapping relations of api methods.
our mapped api methods should satisfy three criteria.
the mapped api methods implement the same functionality.
the mapping relation describes the relation between parameters and receivers of mapped api methods.
the mapping relation describes the relation between returns of mapped api methods.
the two mapped api methods in two different languages satisfying the preceding three criteria are replaceable in the client code.
therefore these mapped api methods assist for migrating client code from one language to another.
algorithm presents major steps of comparing atgs for mining mapping relations of api methods.
for each pair of aligned methods mand m prime the findvarpairs function finds mapped variables and constants as follows.
for two variables vand v prime f v and p1in mand m prime respectively findvarpairs maps v and v prime if the similarity metric value on their names is greater than sim threshold .
for constants in mand m prime findvarpairs maps those two constants if they have exactly the same value.
from mapped variables and constants our algorithm uses the following criteria to find mapping relations between the two api methods jm and sm .
mapped inputs the first criterion is based on the inputs of jm and sm .
we map jm with sm if there is a to mapping between algorithm atg comparison algorithm input gis the atg of a client code method m g primeis the atg of m s aligned method m prime.
output sis a set of mapping relations for api methods begin p findvarpairs m m prime for pair p in p do jm g.nextmethods p.j sm g prime.nextmethods p.s s mapping sm jm sm jm s s.addall s while s negationslash sm negationslash jm negationslash do for method jm in jm do if jm.ismapped then jm jm.nextmethod jm.delete jm jm.add jm else jm merge jm jm.nextmethod jm.delete jm jm.add jm s mapping sm jm s.addall s for method sm in sm do if sm.ismapped then sm sm.nextmethod sm.delete sm sm.add sm else sm merge sm sm.nextmethod sm.delete sm sm.add sm s mapping sm jm s.addall s end inputs of jm and sm .
here mam considers both the receiver and the parameters as the inputs of an api method.
mapped functionalities the second criterion is based on functionalities of jm and sm .
we consider that jm and sm implement the same functionality if the similarity metric value between the name of jm and the name of sm is greater than sim threshold .
mapped outputs the third criterion is based on the returns of jm and sm .
consider the returns of jm and sm as r1and r2 respectively.
we map jm with sm if the type of r1is mapped with the type of r2in mapping relations of api classes.
our algorithm first attempts to map the first api method jm in mwith the first api method sm invoked in m prime.
our algorithm uses inputs of jmandsm.
here mam considers both the receiver and the parameters as the inputs of an api method.
mapped functionalities the second criterion is based on functionalities of jmandsm.
we consider that jmandsmimplement the same functionality if the similarity metric value between the name of jmand the name of smis greater than sim threshold .
mapped outputs the third criterion is based on the returns of jmandsm.
consider the returns of jmandsmasr1andr2 respectively.
we map jmwith sm if the type of r1is mapped with the type of r2in mapping relations of api classes.
our algorithm first attempts to map the first api method jmin mwith the first api method sminvoked in m .
our algorithm uses thenextmethods function to get these jmandsmapi methods.
in each iteration this function merges an api method with its di rectly next api method to produce a merged api method.
if our algorithm successfully maps jmwithsm our algorithm moves to the next available api methods invoked in client code methods m andm .
if our algorithm is not able to map jmwithsm our algorithm merges smandjmwith their next available api methods in the corresponding atgs respectively and attempts to map merged api methods.
note that merged api methods are just synthesized intermediate representations for correlated api methods invoked in client code and are used internally by our algorithm to construct many to many mapping relations of api methods.
a merged api method cmis a sequence of api methods mcombined by inputs and outputs so the tbehavior of cmis the combination of m. in the simplest case a merged api method could include only one api method.
for l1 consider an api method m1defined in the class c1and an api method m2defined in c2with the following signatures m1signature o1c1.m1 inp1 inp1 ... inp1 k m2signature o2c2.m2 inp2 inp2 ... inp2 l our algorithm merges methods m1andm2to create a new merged api method mnewif the output o1ofm1is used either as a receiver or as a parameter for m2 i.e.
o1 c2oro1 inp2 i in client code.
the signature of the new merged api method mnewis shown below mnew signature o2mnew inp1 inp1 ... inp1 k inp2 inp2 ... inp2 l for example our algorithm merges the api methods shown in figure 4a to two merged api methods as follows.
cm1 boolean fileinfo getfullname file.exist string cm2 boolean fileinfo getfullname directory.exist string similarly our algorithm merges the api methods shown in figure 4b to two merged api methods as follows.
cm3 boolean file exist string cm4 boolean file delete string our algorithm merges these api methods so that it is able to mine many to many mapping relations of api methods as shown in figure .
after merging api methods our algorithm uses the replace function for merging an api method with its next available api method.
for two merged api methods our algorithm uses the maximum similarity of method names between jmandsmas a similarity metric value for mapping their functionalities.
with each iteration smorjmor the mapping relation represented as s in the algorithm may change.
therefore we repeat our algorithm till s sm and jmdo not change anymore.
we next explain our algorithm using the illustrative example shown in figure .
the numbers shown in rounded rectangles such asstep represent the major steps in our algorithm for mining mapping relations of api methods.
we next explain each step in detail.
step mapping parameters fields local variables and constants.
given two atgs of each method pair m m this step maps variables such as parameters fields and local variables by comparing their names and maps constants by comparing their values.
as shown in figure step maps two constants since both the constants have the same value index .
step mapping inputs of api methods.
step mines mapping relations of api methods using variable and constant mapping relations.
initially this step identifies the first api methods in the two atgs and tries to map their receiver and parameters of the two api methods.
in our current example this step maps the constructor parameter in line to the constructor parameter in line since these parameters are of the mapped types and their associated constants are mapped.
step mapping outputs of api methods.
step maps returns of api methods.
if mam is not able to map returns mam mergesproject sourcejava version c version c m c m neodatis sourceforge db4o sourceforge numerics4j sourceforge fpml sourceforge pdfclown sourceforge openfsm sourceforge binarynotes sourceforge lucene apache logging apache hibernate hibernate rasp sourceforge llrp sourceforge simmetrics sourceforge aligner sourceforge fit sourceforge total table subjects the next api method and then attempts to map returns of merged api methods.
in the example shown in figure mam merges subsequent api methods in the atg till the exists api method since the returns shown as boolean can be mapped only after the exists api method.
figure shows step along with the mapped returns.
step mapping functionalities.
after mam maps parameters and returns this step further maps functionalities of those merged api methods.
given two merged api methods with mapped parameters and returns this step uses the similarity metric value based on their method names as a criterion for mapping their functionalities.
in the preceding example this step maps the two merged api methods shown in figure 4a to the api method of java.io.file.
exists since all three merged api methods include the method named exists .
after finding out the mapped pair of api methods as shown in figure mam merges all variables and returns to corresponding parameters and receivers and produces the mapping relation of api methods from java.io.file.exists in java to system.io.
file.exists andsystem.io.directory.exists in c see section .
for how mined mapping relations help language migration .
.
evaluations we implemented a tool for mam and conducted two evaluations using our tool to show the effectiveness of our approach.
in our evaluations we address the following two research questions .how effectively can our approach mine various api mapping relations section .
?
.how much benefit can the mined api mapping relations offer in aiding language migration section .
?
table shows open source projects with both java and c versions used as subjects in our evaluations.
column project lists names of subjects.
column source lists sources of these subjects.
these subjects are collected from popular open source hosting sites such as sourgeforge9 apache10 and hibernate11.
columns java version and c version list information for versions in java and c respectively.
in these two columns sub columns c and m list the number of classes and methods respectively.
as shown in the table java versions are much larger than c versions version c version aligned c m c m c m db4o .
.
.
.
fpml .
.
.
.
pdfclown .
.
.
.
openfsm .
.
.
.
binarynotes .
.
.
.
neodatis .
.
.
.
numerics4j .
.
.
.
lucene .
.
.
.
logging .
.
.
.
hibernate .
.
.
.
average .
.
.
.
table results of aligning client code for all subjects.
we found two major factors for such a difference.
first java versions of some of the projects are more up to date.
for example the latest java version of numericas4j is .
whereas the latest c version is .
.
second for some projects migration from java to c is still in progress.
for example the website12of neodatis states that neodatis is a project in java and is being ported to c .
this observation further confirms the usefulness of our approach since our approach aids migrating projects from one language to other languages.
in total all these projects include classes and methods.
we conducted all evaluations on a pc with intel qual cpu .83ghz and .98g memory running windows xp.
more details of our evaluation results e.g.
version numbers of subjects are available at .
.
mining api mapping relations to investigate the first research question we use the first projects listed in table for mining api mapping relations.
aligning client code.
we first present the results of aligning client code.
we use the sim threshold value as .
which is set based on our initial empirical experience.
we choose a relatively low threshold since it helps our approach to take into account as much client code as possible.
table shows our evaluation results.
in column aligned subcolumns c and m list the number of aligned classes and aligned methods respectively.
for each project of columns c version and java version sub column c lists the percentage of the aligned classes among total classes of corresponding versions.
sub column m lists the percentage of the aligned methods among total methods of corresponding versions.
row average of the two sub columns lists the percentage of aligned methods classes among the total methods classes as shown in table .
we find that the results of table fall into three categories.
the first category includes db4o fpml pdfclown openfsm and binarynotes .
in this category our approach achieves relatively high percentages for both java and c versions.
for all these five projects m is relatively smaller than c because methods of those unaligned classes cannot be aligned and hence are counted as unaligned13.
the second category includes neodatis numerics4j andlucene .
in this category our approach aligns c versions well but does not align java versions so well.
we find that the migration ofneodatis andlucene from java to c is in progress and the java version of numerics4j is more up to date than its c version.
as a result some java classes or methods do not have corresponding implementations in c versions in these projects and hence are not 13another factor lies in that java versions usually have many getters and setters and these getters and setters often do not have corresponding methods in c versions.projectclass method num.
acc.
j2se num.
acc.
j2se db4o .
.
fpml .
.
pdfclown .
.
openfsm .
.
binarynotes .
.
neodatis .
.
numerics4j .
.
lucene .
.
logging .
.
hibernate .
.
total .
.
table results of mining api mapping relations aligned.
the third category includes logging andhibernate .
in this category our approach does not align classes and methods of the two projects well.
although both of the two projects seem to be migrated from existing java versions the programmers of the two projects often do not refer to names of existing java versions for naming entities.
for these two projects the percentages of aligned classes are relatively high and the percentages of aligned methods are relatively low.
we find that even if our approach aligns a wrong class pair our approach does not align methods within the wrong pair since the method names of a wrong pair are quite different.
these results suggest that we could take method names into account when aligning classes in future work.
for any of these these projects our approach does not align all classes or all methods.
we discuss these issues in section .
in summary as shown by row average our approach aligns classes and methods well on average.
the result confirms that many programmers refer to existing versions of another language to name entities of a version under development.
mining api mapping relations.
table shows the results of mined mapping relations of api classes and methods.
columns class and method list results of mining mapping relations of api classes and api methods respectively.
sub column num.
lists the numbers of mined mapping relations.
the numbers of mined api mapping relations are highly proportional to the sizes of projects shown in table except for logging andhibernate .
since classes and methods of these two projects are not well aligned our approach does not mine many api mapping relations from these two projects.
for the remaining projects our approach mines many mapping relations of api classes and api methods.
sub column acc.
lists accuracies of the first mined api mapping relations i.e.
percentages of correct mapping relations .
for api mapping relations mined from each project we manually inspect the first mined api mapping relations by alphabetical order sorted based on the names of their corresponding api classes and methods .
we next classify these relations as correct or incorrect based on inspecting api client code and api documents.
we find that our approach achieves high accuracies except for hibernate .
although our approach does not align logging quite well either the accuracies of api mapping relations mined from logging are still relatively high.
to mine api mapping relations of classes our approach requires that the names of fields in aligned classes variables or parameters in aligned methods are similar.
to mine api mapping relations of methods our approach requires that two built atgs are mapped.
these two requirements are relatively strict.
as a result if the first step does not align client code well our approach may miss some api mapping relations but does not introduce many false mapping relations.
in other words our approach is robust to mine accurate api mapping relations.
sub column j2se lists the number of mined api mapping relations between j2se apis and .net frame packageclass method p r f p r f java.io .
.
.
.
.
.
java.lang .
.
.
.
.
.
java.math .
.
.
.
.
.
java.net .
.
.
.
.
.
java.sql .
.
.
.
.
.
java.text .
.
.
.
.
.
java.util .
.
.
.
.
.
junit .
.
.
.
.
.
orw.w3c .
.
.
.
.
.
total .
.
.
.
.
.
table results of comparison with manually written relations work apis.
we next compare these api mapping relations with manually written mapping relations.
row total in table lists the total result after we merge all duplicated mapping relations.
in summary our approach mines a large number of api mapping relations.
these mined api mapping relations are accurate and associated with various libraries.
comparing with manually written api mapping relations.
some migration tools such as java2csharp include manually written api mapping relations of apis.
for example one item from the mapping files of java2csharp is as follows package java.math system class java.math.bigdecimal system decimal method multiply bigdecimal pattern decimal.multiply this item describes the mapping relation between java.math.
bigdecimal of java and system.decimal of c and also describes the mapping relation between multiply of java and multiply of c .
for the two api methods the pattern string describes the mapping relation of inputs denotes the receiver of the multiply method and denotes the first parameter of the multiply method.
based on this item java2csharp migrates the following code snippet from java to c as follows bigdecimal m new bigdecimal bigdecimal n new bigdecimal bigdecimal result m.multiply n decimal m new decimal decimal n new decimal decimal result decimal.multiply m n to compare with manually written mapping files of java2csharp we migrate our mined api mapping relations using the following strategy.
first for each java class we migrate its mapping relations of classes with the highest support values.
here the support value of a mapping relation is the frequency that the mapping relation is mined from the subjects listed in table .
second for each java method we migrate its mapping relations of methods with the highest support values into mapping files as relations of methods with pattern strings.
for to mapping relations of api methods this step is automatic since mined mapping relations describe mapping relations of corresponding methods and inputs.
for a few many tomany mapping relations of api methods this step is manual since mined mapping relations do not include adequate details.
the mapping files of java2csharp are associated with packages defined by j2se and packages defined by junit14 and we treat these mapping files as a golden standard.
we find packages overlapping between the mined mapping files and the mapping files of java2csharp.
table shows the comparison results of our mined api mapping relations within these mapping packages.
columns class and method list results of comparing api classes and mf mf ext.
mf e d e d e e d d rasp .
.
llrp .
.
simm .
aligner .
fit .
total .
.
table compilation errors and defects simm simmetrics methods respectively.
sub columns p r and f denote precision recall and f score.
precision recall and f score are defined as follows15 precision true positives true positives false positives recall true positives true positives false negatives f score precision recall p recision recall in these preceding formula true positives represent those api mapping relations that exist in both the mined api mapping relations and the golden standard false positives represent those relations that exist in the mined api mapping relations but not in the golden standard false negatives represent those mapping relations that exist in the golden standard but not in the mined api mapping relations.
row total shows the results when we compare mapping relations of all the packages listed in table .
from sub columns p of table we find that our approach achieves relatively high precisions but the precisions are lower than the accuracies shown in table .
after inspecting those differences we find new correct mapping relations of api classes from our mined mapping files.
for example these mined mapping files contain a mapping relation between org.w3c.dom.attr and system.xml.xmlattribute and the mapping files of java2csharp do not contain mapping relations for the two api classes.
if we consider these new relations as true positives the total precision would be .
.
these new mapping relations are useful and complements the existing mapping files of the java2csharp tool.
from sub columns r of table we find that our approach achieves relatively high recalls but the recalls still have space for improvements.
for example our approach does not mine the mapping relation between java.util.resourcebundle andsystem.
resources.resourcemanager as described in the mapping files of java2csharp.
although this mapping exists in hibernate our approach fails to mine the mapping relation since hibernate uses the two api classes in two classes with quite different names.
our approach also fails to mine the mapping relations between java.util.
gettime andsystem.datetime.ticks correctly since our approach cannot infer that millisecond returned by gettime of java is equal to ticks returned by ticks of c .
in summary compared with the mapping files of java2csharp our mined mapping files show reasonably high precisions and recalls.
the precisions are relatively high since our mined mapping relations are accurate and include new mapping relations that are not covered by java2csharp.
the recalls are also relatively high since our approach mines many mapping relations although we still have space for further improvements.
15we ignore those api mapping relations that do not have call sites in the projects listed in table since our approach relies on api call sites to mine mapping relations.
by adding more projects using these apis to our subjects our approach can then mine relations of these apis.
.
aiding language migration to investigate the second research question we feed the mined api mapping relations to the java2csharp tool and investigate whether these relations can improve the tool s effectiveness.
we choose this tool because this tool is a relatively mature project at ilog16 now part of ibm and supports the extension of user defined mapping relations of apis.
we use java2csharp to migrate the last five projects listed in table from java to c and table shows the results.
for each migrated c project column no mf lists results without mapping files.
column mf lists results with only the mapping files of java2csharp.
column ext.
mf lists results with mapping files that combine our mined api mapping relations with the existing mapping files of java2csharp.
sub columns e and d list the number of compilation errors and api related defects found respectively.
compilation errors provide an overview for qualities of migrated projects but some compilation errors are not related to apis.
to find out the effectiveness of reducing api related defects we manually inspect some migrated c files.
in particular for each project we first select those overlapping files between migrated files and existing c files from the c version of the five projects.
after that we manually compare the top five largest files among these overlapping files with existing c files and analyze those differences for detecting api related defects.
for example a migrated c statement of simmetrics in no mf is as follows.
totaldistance float java.lang.math.sqrt totaldistance this statement contains an api related defect since java2csharp does not migrate the sqrt method of java to its corresponding api method of c .
sub columns e and d list percentages of improvements over the results of mf .
on average mined api mapping relations help further reduce .
compilation errors and .
api related defects.
since the five projects use different libraries compilation errors and defects in migrated projects are different.
in particular simmetrics andfituse api classes of j2se that are covered by mapping files.
consequently the migrated projects of simmetrics andfithave only a few errors and defects.
the aligner project also mainly uses j2se but it uses many api classes and methods from java.awt for its gui.
the mapping files of java2csharp do not cover any classes of java.awt so the migrated project has many compilation errors.
since the existing c version of aligner does not have gui we do not compare those defective migrated gui files and we do not find any api related defects in the compared five files.
the mined files map java.awt tosystem.windows.forms and thus reduce compilation errors.
however the result is not significant since many classes of the two packages are still not mapped.
for rasp andllrp they both use various libraries besides j2se.
consequently the migrated projects have both many errors and api related defects.
in particular llrp uses log4j17and jdom18 and the mined mapping files contain mapping relations of the two libraries.
as a result the mined api mapping relations help reduce compilation errors and api related defects significantly.
rasp uses some libraries such as neethi19.
since the used subjects for mining and thus our mined api mapping relations do not cover these libraries the migrated project of rasp contains many compilation errors and api related defects.
in summary the mined api mapping relations help improve existing language migration tools such as java2csharp.
in particular the mined api mapping relations help effectively reduce compilation errors and api related defects in the migrated projects.
threats to validity the threats to external validity include the representativeness of the subjects and the used migration tool.
although we applied our approach on projects for mining api mapping relations and on additional projects for helping language migration our approach is evaluated only on these limited projects.
although java2csharp is the best migration tool within our knowledge other tools may perform better than java2csharp.
this threat could be reduced by more evaluations on more subjects and more migration tools in future work.
the threats to internal validity include human factors for determining correct mined api mapping relations and for determining api related defects in migrated projects.
to reduce these threats we inspected mined mapping relations and api related defects carefully and we referred to existing mapping relations and existing c files for determining correct api mapping relations and api related defects respectively.
the former threat could be further reduced by comparing with more existing mapping relations of apis as we did for j2se.
the latter threat could be reduced by running test cases to detect api related defects.
.
discussion and future work we next discuss issues in our approach and describe how we address these issues in our future work.
aligning client code.
table shows that our approach could not align client code in a few cases.
the primary reason is that the functionality associated with a class or a method in one language version is split among multiple classes or methods in the other language version.
to address this issue we plan to align classes and methods of client code based on their functionalities through developing or adapting dynamic approaches in future work.
mining richer api mapping.
table shows that our approach still has space to improve recalls.
although we use large projects as subjects these projects still do not provide sufficient code examples for mining mapping relations of all apis in j2se.
our previous work shows that it is feasible to use large scale repositories available on the web as subjects with the help of code search engines.
in future work we plan to leverage these code search engines to mine richer api mapping.
migrating many to many mapping relations of api methods.
a mined many to many mapping relation of api methods can have multiple outputs and complex internal data processes.
although our atgs help identify all api methods our implementation is not complete for supporting automatic migration.
for example we need to manually add an oroperator for the two outputs of the api mapping presented in section i.e.
the returns of system.io.file.exists andsystem.io.directory.exists .
in future work we plan to enhance our implementation to help automate migration with many to many mapping relations.
migrating unmapped apis.
our approach mines api mapping of methods along with the mappings of their inputs and outputs.
these mappings are useful for migrating api methods of one language to another.
sometimes our approach may not be able to map inputs and outputs of mapped api methods.
if our approach is not able to map outputs our approach currently simply ignores those outputs that are not used in the client code.
however since inputs cannot be ignored the migrated code has compilation errors.
in future work we plan to address this issue by analyzing how two versions of a project deal with a similar unmapped api problem for some other code examples.
.
related work our approach is related to previous work on two areas language migration and library migration.language migration.
to reduce manual efforts of language migration researchers proposed various approaches to automate the process.
however all these approaches focus on the syntax or structural differences between languages.
deursen et al.
proposed an approach to identify objects in legacy code.
their approach uses these objects to deal with the differences between object oriented and procedural languages.
as shown in elramly et al.
s experience report existing approaches support only a subset of apis for language migration making the task of language migration a challenging problem.
in contrast to previous approaches our approach automatically mines api mapping between languages to aid language migration addressing a significant problem not addressed by the previous approaches and complementing these approaches.
library migration.
with evolution of libraries some apis may become incompatible across library versions.
to address this problem henkel and diwan proposed an approach that captures and replays api refactoring actions to update the client code.
xing and stroulia proposed an approach that recognizes the changes of apis by comparing the differences between two versions of libraries.
balaban et al.
proposed an approach to migrate client code when mapping relations of libraries are available.
in contrast to these approaches our approach focuses on mapping relations of apis across different languages.
in addition since our approach uses atgs to mine api mapping relations our approach can also mine mapping relations between api methods with different parameters or between api methods whose functionalities are split among several api methods in the other language.
mining specifications.
some of our previous approaches focus on mining specifications.
mam mines api mapping relations across different languages for language migration whereas the previous approaches mine api properties of a single language to detect defects or to assist programming.
.
conclusion mapping relations of apis are quite useful for the migration of projects from one language to another language and it is difficult to mine these mapping relations due to various challenges.
in this paper we propose a novel approach that mines mapping relations of apis from existing projects with multiple versions in different languages.
we conducted two evaluations to show the effectiveness of our approach.
the results show that our approach mines many api mapping relations between java and c and these relations improve existing language migration tools such as java2csharp.