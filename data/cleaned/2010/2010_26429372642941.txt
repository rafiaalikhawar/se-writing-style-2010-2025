transferring an automated test generation tool to p ractice from pex to fakes and code digger nikolai tillmann microsoft research redmond wa usa nikolait microsoft.comjonathan de halleux microsoft research redmond wa usa jhalleux microsoft.comtao xie university of illinois at urbana champaign urbana il usa taoxie illinois.edu abstract producing industry impacts has been an important yet challenging task for the research community.
in this paper we report experiences on successful technology transfer of pex and its relatives tools derived from or associated with pex from microsoft research and lessons learned from more than eight years of research efforts by the pex team in collaboration with academia.
moles a tool associated with pex was shipped as fakes with visual studio since august benefiting a huge user base of visual studio around the world.
the number of download counts of pex and its lightweight version called code digger has reached tens of thousands within one or two years.
pex4fun derived from pex an educational gaming website released since june has achieved high educational impacts reflected by the number of clicks of the ask pex!
button indicating the attempts made by users to solve games in pex4fun as over .
million till july .
evolved from pex4fun the code hunt website has been used in a very large programming competition.
in this paper we discuss the technology background tool overview impacts project timeline and lessons learned from the project.
we hope that our reported experiences can inspire more high impact technology transfer research from the research community.
categories and subject descriptors d. .
coding tools and techniques object oriented programming d. .
testing and debugging symbolic execution general terms languages experimentation keywords testing symbolic execution technology transfer .
introduction producing industry impacts such as producing successful technology transfer and adoption has often been an important task permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
academic or industrial researchers when conducting research.
however it is generally challenging to transfer research results into industrial practices.
in recent years a set of promising research results around automated software engineering tools have been produced by the research community and demonstrated to be useful on various real world open source projects.
there are substantial opportunities for exploiting these research results to improve industrial practices of automated software engineering.
furthermore there are substantial demands from software practitioners to address urgent and critical issues in their industrial practices.
however demonstrating effectiveness of proposed research tools on open source code or even industrial code as often reported in the research literature does not naturally lead to successful transfer or adoption of the tools in industrial practices.
the research community has already realized gaps between academic research and industrial practices and has called for training and education of researchers and practitioners in conducting successful technology transfer and adoption.
furthermore there have been various cases of successful technology transfer on static bug finding dynamic bug finding and software analytics .
in this paper we report experiences on successful technology transfer of pex denoting the p rogram ex ploration tool and its relatives tools derived from or associated with pex from microsoft research and lessons learned from more than eight years of research efforts by the pex team in collaboration with academia.
moles a tool associated with pex was shipped as fakes with visual studio since august benefiting a huge user base of visual studio around the world.
the number of download counts of pex and its lightweight version called code digger has reached tens of thousands within one or two years.
pex4fun derived from pex an educational gaming website released since june has achieved high educational impacts reflected by the number of clicks of the ask pex!
button indicating the attempts made by users to solve games in pex4fun as over .
million till july .
evolved from pex4fun the code hunt website has been used in a very large programming competition.
the rest of the paper is organized as follows.
section presents the technology background for the pex project.
section presents the overview of pex and its relatives.
section presents the industry educational and research impacts of the pex project.
section illustrates the project timeline.
section discusses the lessons learned and section concludes.
.
technology background in this section we present the technology background underlying the pex project dynamic symbolic execution section .
which is the technology that pex has realized parameterized unit figure user interface of applying pex t esting section .
which is the technology that provides a playground and motivation for pex fitness guided path exploration section .
which is a key technology that allows pex to improve its effectiveness and efficiency.
.
dynamic symbolic execution dynamic symbolic execution dse is a variation of symbolic execution and leverages runtime information from concrete executions.
dse is often conducted in iterations to systematically increase code coverage such as block or branch coverage.
in each iteration dse executes the program under test with a test input which can be a default or randomly generated input in the first iteration or an input generated in one of the previous iterations.
during the execution of the program under test dse performs symbolic execution in parallel to collect symbolic constraints on program inputs obtained from predicates in branch statements along the execution.
the conjunction of all symbolic constraints along an executed path is called the path condition.
then dse flips a branching node in the executed path to construct a new path that shares the prefix to the node with the executed path but then deviates and takes a different branch.
dse relies on a constraint solver such as z3 to check whether such a flipped path is feasible if so compute a satisfying assignment such assignment forms a new test input whose execution will follow along the flipped path.
.
parameterized unit testing a key methodology that pex supports is parameterized unit testing which extends previous industry practice based on closed traditional unit tests i.e.
unit test methods without input parameters .
in parameterized unit testing unit test methods are generalized by allowing parameters to form parameterized unit tests.
this generalization serves two main purposes.
first parameterized unit tests are specifications of the behavior of the methods under test not only exemplary arguments to the methods under test but also ranges of such arguments.
second parameterized unit tests describe a set of traditional unit tests that can be obtained by instantiating the methods of the parameterized unit tests with given argument value sets.
an automatic test generation tool such as pex can be used to generate argument value sets for parameterized unit tests.
.
fitness guided path exploration dse or symbolic execution in general suffers from the path exploration problem there are typically a huge or infinite number of paths in the code under test for the dse engine to explore.
to tackle this exploration problem the pex team developed the fitnexsearch strategy for guiding the dse engine pex to achieve the target test coverage quickly.
the guided search provided by the fitnex strategy alleviates issues encountered by previous dse search strategies such as bounded exhaustive search or random search .
in particular the fitnex strategy assigns to already explored paths fitness values computed by program derived fitness functions.
fitness functions have been traditionally used in search based test generation .
a fitness function measures how close an explored path is in achieving the target test coverage.
afitness gain is also measured for each explored branch a higher fitness gain is given to a branch if flipping a branching node for the branch in the past helped achieve better fitness values.
then during path exploration the fitnex strategy prefers to flip a branching node whose corresponding branch has a higher fitness gain in a previously explored path with a better fitness value .
the pex team integrated the fitnex strategy with other fair choice search strategies which work well for other types of exploration problems.
such integration of the fitnex and other strategies achieves the effect of getting the best of both in practice.
.
pex and its relatives in this section we present the overview of pex section .
and its relatives i.e.
tools that are derived from or associated with pex including code digger section .
moles fakes section .
and pex4fun code hunt section .
.
.
pex based on dse pex is an automatic white box test generation tool for .net.
which has been integrated into microsoft visual studio as an add in.
starting from a method that takes parameters either a parameterized unit test or a method under test pex performs path bounded model checking by repeatedly executing the program and solving constraint systems to obtain inputs that will steer the program along different execution paths following the idea of dse.
pex uses the theorem prover and constraint solver z3 to reason about the feasibility of execution paths and to obtain ground models for constraint systems pex was one of the major reasons for initiating the z3 project .
the unit tests that pex generates can be executed by various unit test frameworks such as mstest nunit and xunit without pex.
figure shows the user interface of applying pex in visual studio.
pex can be invoked anywhere in the visual studio code editor via clicking the context menu item of run pex explorations and does not require any pre existing tests.
the results are presented as an input output table as shown in the lower right part of figure .
each row represents a set of inputs to the method under test and the observed return value or exception.
the results can be easily saved in the visual studio solution as traditional unit tests.
the generated tests can also be debugged just like any other unit tests.
.
code digger code digger the first visual studio extension from the pex team for visual studio generates test data that show different behaviors of the .net code under test.
figure shows the user interface of applying code digger in visual studio.
code digger can be invoked through clicking the context menu item generate inputs outputs table in the visual studio code editor.
the generation result is a table showing for which inputs the code under test produces which outputs as shown in the lower left part of figure .
the table helps the developers understand the behavior of the code and it may also uncover hidden faults.
under the hood code digger uses pex to systematically explore paths in the code trying to generate a test suite that achieves high code coverage.
386figure user interface of applying code digger o ut of the box code digger works on only public .net code that resides in portable class libraries.
but options are available to allow the developers to configure code digger to explore other .net projects.
by restricting the code exploration to portable class libraries code digger avoids problems with code that has dependencies on a particular platform that the pex engine does not understand portable class libraries are a neat way in .net to ensure that there are no external dependencies .
in addition when using code digger developers do not need to change their project under test e.g.
without the need of creating a new test project as needed in pex therefore code digger can be conveniently used by some developers in a project team even when some other developers in the same project team do not use code digger.
.
moles fakes in software testing especially unit testing it is often desirable to test individual units such as classes in isolation.
in other words all irrelevant environment dependencies should be mocked or simulated so that the unit tests for the code under test run quickly and give deterministic results.
ideally to address the problem developers can refactor the code under test by introducing explicit interface boundaries and allowing different interface implementations.
however in practice it is often not feasible to refactor existing legacy code under test especially the code from a third party.
to address the issue the pex team developed a new lightweight framework called moles .
the moles framework allows the test code to provide alternative implementations for non abstract methods of any .net type.
using code instrumentation the moles framework redirects calls of a method to its alternative implementation.
the moles framework has been designed to work together with pex to enable automated test generation.
pex can analyze only .net managed code.
consequently when the program execution invokes a method e.g.
a system library method not implemented in .net managed code pex cannot infer the constraints that reflect the behavior of that method and thus pex cannot generate test data to achieve high code coverage.
moles allows developers to replace any method at test time with .net code that simulates its behavior which in turn facilitates test generation with pex.
achieving high industry impacts see section .
for details moles has been shipped with visual studio since visual studio with the new name of microsoft fakes .
similar to moles fakes comes in two flavors a stub and a shim.
a stub replaces a class with a small substitute that implements the same interface.
to use stubs developers have to design their application so that each component e.g.
a class or group of classes designed and updated together and typically contained in an assembly depends only on interfaces and not on other components.
a shim modifies the compiled code of developers application at run time so that instead of making a specified method call it runs the shim code that secret implementation class secret public static int puzzle int x if x return return x puzzle x player implementation class player public static int puzzle int x return x class test public static void driver int x if secret.puzzle x !
player.puzzle x throw new exception mismatch behavior secret impl player impl secret implementation class secret public static int puzzle int x if x return return x puzzle x class test public static void driver int x public static void driver int x if secret.puzzle x !
player.puzzle x if secret.puzzle x !
player.puzzle x throw new exception mismatch behavior secret impl figure workflow of playing an example coding duel in p ex4fun or code hunt figure user interface of playing a coding duel in code hunt t he developers test provides.
shims can be used to replace calls to assemblies such as .net assemblies that the developers cannot modify.
.
pex4fun code hunt pex4fun is an interactive gaming platform for teaching and learning programming and software engineering supporting .net programming languages such as c visual basic and f .
it is a browser based teaching and learning environment with target users as teachers students and even software practitioners etc.
the core type of pex4fun games is a coding duel where the player has to solve a particular programming problem.
figure shows the workflow of playing an example coding duel in pex4fun or code hunt evolved from pex4fun with more details in the end of this section .
a coding duel created by a game creator who could be any user of pex4fun consists of two methods with the same method signature and return type1.
one of these two methods is the secret golden implementation shown in the top left part of figure which is not visible to the player.
the other is the player implementation shown in the top right part of figure which is visible to the player and can be an empty implementation or a faulty implementation of the secret implementation.
the player imple1the method signature of a coding duel must have at least one input parameter.
the return type of a coding duel must not be void.
387mentation can include optional comments to give the player some h ints in order to reduce the difficulty level of gaming.
after a player selects a coding duel game to play the player s winning goal is to modify the player implementation visible to the player to make its behavior in terms of the method inputs and results to be the same as the secret implementation not visible to the player .
apparently without any feedback or help the player has no way to guess how the secret implementation would behave.
the player can get some feedback by clicking the button ask pex or capture code in code hunt to request the following two types of feedback under what sample method input s the player implementation and the secret implementation have the same method result and under what sample method input s the player implementation and the secret implementation have different method results.
pex4fun applies pex on the synthesized test driver code for comparing the returns of the two implementations as shown in the lower left part of figure to generate such feedback as shown in the lower right part of figure and determine whether the player wins the game the player wins the game if pex cannot generate any method input to cause the player implementation and the secret implementation to have different method results.
evolved from pex4fun code hunt codehunt.com instills more fun and entertaining effects adds hint generation adds language support to java etc.
there are four steps to follow in playing games in code hunt.
in step from the suggested sequence of sectors in the game the player discovers a secret code segment by selecting a sector.
in step after the player clicks a sector the player is presented with the player s code as shown in the left part of figure .
then the player clicks the capture code button as shown in the top middle part of figure equivalent to the ask pex button in pex4fun to analyze the behavioral differences of the secret code segment and the player s code.
then code hunt displays the feedback on the behavioral differences as shown in the right part of figure .
in step based on the feedback the player then modifies the player s code to match the secret code segment s behavior.
then the player iterates through steps and until no behavioral differences of the secret code segment and the player s code can be found by code hunt.
in this case the player reaches step winning the game.
.
impacts in this section we present the impacts that the pex project has made in the industry community section .
the education community section .
and the research community section .
.
.
industry impacts inside microsoft pex was applied to a core component of the .net architecture which had already been extensively tested over five years by approximately testers within microsoft.
the component is the basis for other libraries which are used by thousands of developers and millions of end users.
pex found various issues in this core component including a serious issue.
furthermore there have been many other successful cases for applying pex on microsoft code bases.
in the broad software industry pex has had high download counts in industry and academia e.g.
during a month period of february october including downloads with the academic license and downloads with the devlabs industrial license.
the release of pex including moles has led to an active user community including members largely from the industry .
from the period of october till november the msdn forum dedicated to pex and moles included more than forum posts made by the user community.
microsoft fakes was shipped with the ultimate editions of visual studio since visual studio benefiting a huge user base of visual studio around the world.
the substantial benefits and impacts of microsoft fakes were also reflected by the visual studio user community s request to provide microsoft fakes with all visual studio editions .
the request post states include microsoft fakes with all editions of visual studio including professional edition rather than being restricted to developers with ultimate editions of visual studio.
this will allow all visual studio developers to leverage the capabilities of the fakes mocking library since mocking stubbing is a necessary part of every developer s unit testing toolbelt.
this request got votes from the visual studio user community.
since code digger was shipped to the visual studio gallery in april the number of download counts of code digger is as of july .
there have been many very positive user comments on code digger.
some quotes are below very easy to use and quickly see the potential input sanitation problems!
what an awesome tool.. help us to explore our logic by providing accurate input parameter for each logic branch.. you should try this as one of your ultimate tool it really saves a lot of our time to explore every logic branch in our apps.. great tool to generate unit tests for parameter boundary tests.
i like to see it integrated into visual studio and the testing features as far as in resharper!
what a fantastic tool.
whilst it s not bullet proof it shows amazing promise.
i ran the code digger over a number of real world methods and it immediately identified dozens of edge cases we hadn t thought of.
this is getting rolled out to my team today!
well done.
brilliant.
really brilliant.
top stuff here.
very anxious for more of the pex features that were available in vs pex moles like auto gen unit tests .
this tool is poised to become indispensable for anyone writing solid suites of unit tests.
.
educational impacts pex4fun has been gaining high popularity in the community since it was released to the public in june the number of clicks of the ask pex!
button indicating the attempts made by users to solve games in pex4fun has reached over .
million as of july .
pex4fun has provided a number of open virtual courses similar to moocs in spirit including learning materials along with games used to reinforce students learning.
in may microsoft research hosted a contest on solving coding duels at the international conference on software engineering icse .
during the main icse program conference attendees could register a nickname in pex4fun and complete as many coding duels as possible within the icse main conference period.
whoever solved the most coding duels by the end of the period won the contest.
the icse coding duel contest received pex4fun attempts duels completed and participants though likely more since some did not actually enter the official icse course to play the coding duels designed for the contest .
recently pex4fun inspired the new contest form in the icfp programming contest .
competing entirely over the internet more than participating teams of programmers from around the world were asked to complete a series of programming 388tasks using any programming languages and tools that they des ired to address an extremely challenging scenario in program synthesis.
results were assessed using microsoft research s z3 running in windows azure to compare submitted solutions to actual solutions to determine correctness in a similar way as coding duels in pex4fun.
the generic problem description was guess the implementation of a black box function implemented in a simple functional language through querying a web server for information about the input output behavior of the function.
over the contest s hours z3 received about a million requests and successfully decided all except about problem instances within an imposed time limit of seconds the overwhelming majority within a matter of a few milliseconds.
various pex4fun users posted their comments on the internet to express their enthusiasm and interest even addiction to pex4fun .
here we included some examples.
pex4fun could become a better fizzbuzz than fizzbuzz.
it really got me excited .
the part that got me most is about spreading interest in teaching cs i do think that it s really great for teaching learning!
frankly this is my favorite game.
i used to love the first person shooters and the satisfaction of blowing away a whole team of noobies playing rainbow six but this is far more fun.
teaching learning isn t this really the same in the end?
in fact for me personally it s really about leveraging curiosity be it mine or someone else s at best both!
and pexforfun all the stuff behind is a great promising platform for this you got riddles you got competition you get feedback that makes you think ahead... i m afraid i ll have to constrain myself to spend just an hour or so a day on this really exciting stuff as i m really stuffed with work pexforfun improves greatly over projecteuler w.r.t.
how proposed solutions are verified in fact what it adds is that you don t just get a nope but something more articulate something you can build on.
that s what i think is really great and exciting let s push it even further now!
evolved from pex4fun code hunt offers more fun and entertaining effects hints for players language support for java besides c .
in april code hunt was used at a very large competition called beauty of programming in the greater china region.
in three rounds students scored in the game with an average .
puzzles solved across this large number.
code hunt is being offered for more competitions as ongoing efforts.
.
research impacts the pex team has published a set of papers on pex or its relatives along with experimental extensions of pex .
work on experimental extensions of pex was mostly conducted in collaboration with the automated software engineering research group led by the third author at north carolina state university before july and then at the university of illinois at urbana champaign since july .
as of july the major publication on pex published in has got citations.
the major publication on parameterized unit testing published in has got citations.
the major publication on the fitness guided path exploration published in has got citations.
all the preceding citation counts were derived from google scholar in july .
pex itself is not open source and only some extensions of pex are open source including extensions being part of pex releases and other extensions as research exploration .
however pex has been used by other third party researchers from academia who did not have direct collaboration with the pex team on carrying out the academic research in different ways.
first some researchers e.g.
made ex tensions of pex by leveraging the apis of pex without requiring to access the pex source code .
second some researchers e.g.
compared pex as a stand alone state of the art test generation tool with their new approaches in empirical evaluations.
.
project timeline the initial idea of pex arose from the spec explorer project which produced a model based testing tool with an embedded model checker for a subset of .net.
at the core of spec explorer was xrt a self contained runtime of a subset of .net that enabled the dynamic analysis and exploration of model programs written in a subset of .net.
while it is possible to apply this engine not just on specially written model programs but also on carefully chosen real world .net code that stays in the supported .net subset it became also clear that it would be a very laborious task to extend the self contained runtime xrt to support the full or at least a very broad subset of the .net runtime.
the required work would have clearly exceeded the manpower of the research team.
it was under this consideration that the pex project was started based on the idea of instrumenting monitoring and guiding execution paths in the commercial .net runtime.
we next list the timeline of the pex project.
in pex was started by the pex team at microsoft research which initially included only the first author.
then in september the second author joined the pex team.
in march the pex team blogged about the pex tool to the public .
in may the first version of pex under a microsoft research license was released to the public.
it was integrated with visual studio professional.
in september pex integrated the fitnex search strategy in combination with other fair choice strategies the source code of fitnex was also released as open source .
in october an early version of code digger was released for supporting visual studio and visual studio .
code digger allows to start the path exploration from the code under test not from an already existing unit test or even parameterized unit test.
in october pex became one of the first three devlabs projects and available as a microsoft download for visual studio community technology preview ctp .
the new microsoft download comes under a microsoft pre release software license for pex.
this license is different from the microsoft research license agreement this license does not explicitly rule out all forms of commercial use.
note that some of devlabs projects may turn into features in microsoft s existing shipping products some may be open sourced by microsoft to the community.
in october stubs a simple framework for .net test stubs was released with pex.
in may pex included a new feature unit tests as inputs.
before using heavy weight constraint solving to explore hard toreach execution paths pex can leverage already existing unit tests that call parameterized unit tests pex scans their body to extract the parameter values and then pex uses these values to seed the exploration.
in the past pex would have seeded the exploration by simply using the default values for all parameters and nothing else.
in september moles a lightweight detour framework was released with pex.
moles is a new extension of the stubs framework it lets developers replace any .net method including static methods with their own delegate.
in december an extension of stubs to write models was released with pex.
with stubs and moles the pex team provided 389a framework to write record replay tests i.e.
mock based tests a gainst any .net type interface or not.
the extension further allows developers to write simple implementations with behavior that can be used to replace the external system during testing.
the benefit of using the extension is that the resulting test cases are much more robust to code changes since the tests specify the state of the system rather than a sequence of method calls and outcomes.
in january the stubs framework was renamed to the moles framework.
the pex team decided to make the moles the center of the framework and as a consequence renamed stubs to moles .
in march after more than a year of community feedback on devlabs pex and moles took the next step and had become visual studio power tools.
in april a facebook page on pex and moles was launched to better build its user community.
in may moles was released as a standalone tool on visual studio gallery .
in june pex integrated rex being smarter about regular expressions.
in june pex4fun was announced being a web site that brings code to life.
pex4fun on the web was a radically simplified version of the fully featured pex power tool for visual studio.
the website came with a set of code puzzles where a player s task is to simply guess what a given puzzle method does by studying the code of the puzzle method.
in july the game type of coding duels being interactive puzzles was introduced in pex4fun.
coding duels are different from those simple puzzles announced in june .
in august visual studio was released including microsoft fakes which was evolved from the moles framework.
the microsoft visual studio product team took over and owned the code base of moles fakes relieving the pex team from subsequent maintenance efforts of the code base.
in april code digger an extension for visual studio was shipped to the visual studio gallery .
after shipping the moles framework as fakes in visual studio this effort on code digger was the subsequent step of bringing the pex project to the latest and greatest development environment.
since then ongoing efforts have been taken for further technology transfer of code digger pex.
in february code hunt evolved from pex4fun was released to the public and formally announced in may .
it is a significant extension of pex4fun by instilling more fun and entertaining effects adding hint generation adding language support to java etc.
.
lessons learned in tool trans fer in this section we illustrate main lessons learned from the pex project in terms of technology transfer and adoption.
.
evolving dreams tool researchers typically would like their dreams of tool adoption to become true.
however turning dreams to be true can be a long process or even may not be possible at times and tool researchers would need to evolve their dreams by being adaptive to evolve their focus to different types of tools or variants of their initial tools.
as discussed in the project timeline section before the pex project was started the first author along with some other researchers at microsoft research worked on the spec explorer project a model based testing tool with an embedded model checker for a subset of .net.
although the spec explorer project led to substantial adoption in the microsoft s protocol documentation program the spec explorer tool did not reach wide adoption by practitioners.
during the promotion of adopting the spec explorer tool e.g.
within microsoft it was observed that systematic training of test engineers played a critical role in their adoption of model based testing methodologies or tools .
the adoption of the spec explorer tool at microsoft was driven by having more experienced test engineers to mentor less experienced ones however experienced test engineers might not be commonly available thus becoming a bottleneck in the tool adoption process.
after observing the difficulties of shaping the target tool users e.g.
via training the first author moved on to propose and focus on a more lightweight formal testing methodology parameterized unit testing which relies on specifications written in unit tests to provide test oracles and relies on an automatic whitebox test generation tool to provide test data.
at this timing the pex project was born in .
although the pex team and the third author had great passion and high hope in promoting parameterized unit testing in combination with automatic test generation provided by pex in practice such methodology seemed to get well accepted and adopted by only a relatively small subset of advanced developers.
a large portion of developers did not seem to popularly write parameterized unit tests likely due to higher abstract thinking skills required when writing specifications encoded in parameterized unit tests.
then the pex team relaxed the usage of pex to be beyond the usage scenario of requiring parameterized unit tests before running pex developers can simply run pex even when they do not write any parameterized unit tests.
such new mode of pex along with code digger was provided to attract more developers as tool users.
furthermore after observing the strong needs of tool support for mocking independent of whether pex or another automatic testgeneration tool is used the pex team further invested efforts to develop moles a lightweight detour framework.
only some time after that point in august moles was shipped as fakes with visual studio benefiting a huge user base of visual studio around the world being the first such shipped tool from the pex project .
although moles has relatively simple technologies behind the scene interestingly its timing of being shipped with visual studio was earlier than other more sophisticated tools such as pex from the pex project.
in addition pex4fun and code hunt educational websites based on pex also got high educational impacts.
however in the future pex itself may get as wide adoption as or even wider adoption than moles fakes or pex4fun code hunt.
.
dealing with chicken and egg problem in the pex project setting there are two types of tool transfer and adoption convincing the target users such as developers in microsoft product teams or developers in the broad .net user community to use pex or its relatives convincing target tool vendors such as the microsoft visual studio product team to ship parts of pex or its relatives with future releases of visual studio.
typically the second type of tool transfer and adoption would succeed only after the first type has succeeded because the target tool vendors would like to see a large enough user base of the tools before committing to ship such tools in their future product releases.
tools with public releases already typically will first be shipped at microsoft devlabs or microsoft visual studio gallery for some time before being considered for being shipped with visual studio.
390in fact in early phases of transferring a tool accomplishing the fi rst type of tool transfer and adoption is quite challenging.
the chicken and egg problem occurred when developers were faced with the decision on adopting pex in early phases.
below are example conversations that occurred in early stages of tool adoption between a developer or project manager and the pex team developer manager who is using your tool?
pex team do you want to be the first?
developer manager i love your tool but no.
developers or project managers in industry tend to be conservative and might wait and see more substantial success stories of using a tool before they commit to adopt the tool.
it is generally difficult to recruit the first early tool adopters but having success stories of these early tool adopters could help convince others to follow the adoption.
to address such challenges the pex team was persistent in tackling real world challenges finding early adopters addressing technical and non technical barriers for technology adoption in industry e.g.
providing a tool license that does not prohibit commercial use etc.
in addition the pex team adopted the strategy of incremental shipping e.g.
shipping code digger before aiming to ship the full fledge pex.
to convince target users e.g.
developers from industry to become early adopters of the pex tool the pex team selected and demonstrated how pex can be applied on complex real world classes such as the resourcereader class from the .net framework.
it is important to go beyond simple textbook classes such as simple well isolated data structures as often used in testing research papers because the target users might have a pre impression that a research tool might not work well on real world cases.
to convince the microsoft visual studio product team to ship moles as fakes in visual studio the pex team selected and demonstrated successful and important scenarios of applying moles such as assisting unit testing of sharepoint code.
among microsoft patterns practices2 the sharepoint guidance highlighted the use of moles for testing sharepoint code.
successfully addressing pain points of testing such important type of code provided strong incentives for the visual studio product team to ship fakes.
in general it is very important to demonstrate that the tool to be transferred can be applied to address one important scenario very well the more important the scenario is and the better the scenario is addressed the stronger case it is to convince the target tool vendors to ship the tool.
in addition to make a strong case it is important to provide quantitative information for reflecting the tool s importance or benefit extent to the target tool vendors.
it is a common practice of releasing a tool as an installation file via the internet and keeping track of the download counts without keeping track of which organization s members downloaded the tool or whether how the downloaded tool was used.
however based on our experiences there are three main issues with such common practice.
first a member of an organization e.g.
a developer from a company can download the tool s installation file and share the file with other members of the organization.
thus counting only one download in this case does not faithfully reflect the reality.
second those who downloaded or installed the tool do not necessarily use the tool in their work in a regular basis .
thus it is important to incorporate a mechanism of collecting tool usage information such as those in the microsoft customer experience improvement program .
2microsoft patterns practices provide popular recommendations on designing and developing custom applications using the microsoft platform.third not all tool downloads or usages are equal downloads or usages by members of important customer companies are valued more by the target tool vendors than downloads or usages by others.
thus it is important to identify the organization affiliations of those who downloaded or used the tool.
.
considering human factors in the research literature there was little discussion on human consumption of the generated tests user studies on test generation tools conducted by fraser et al.
briefly touched on such issue .
based on substantial user feedback on pex it is important to generate user friendly tests for users to digest and interact with.
as a past anecdotic example a user of code digger asked a question on string values generated by code digger previously code digger generates a lot of strings as input.
i can t find a way to create such a string via my own c code.
could any one show me a c snippet?
i meant zero terminated string.
the pex team responded in c a in a string does not mean zerotermination.
it s just yet another character in the string a very simple character where all bits are zero and you can create as pex shows the value .
as another past anecdotic example below are conversations between a developer and the pex team on desired representative values for generated test inputs by pex developer your tool generated pex team what did you expect?
developer marc.
more recently pex inheritably along with code digger has been improved with a number of techniques to take human factors into account.
for example the latest version of pex tries to use human friendly characters and integers.
pex now prefers humanreadable characters over strange unicode characters if both cover the same execution path.
similarly pex now prefers small integers that do not cause overflows over big integers that cause overflows if both cover the same execution path.
to accomplish these techniques pex modifies some outputs of z3 instead of taking z3 s outputs directly as test data.
pex includes a wrapper around z3 to give additional guidance to z3 in its constraint solving.
for example pex feeds z3 the original constraints from path exploration along with additional basic range constraints such integers being between if no solution is provided by z3 then pex falls back to the default setting without additional guidance.
in some other cases pex starts with small test data and iteratively queries z3 to see whether the provided small test data such as the array length being a small value can be the solution to the original constraints if not pex increases the value of the test data and queries z3 again.
because users need to interact with the generated tests even the naming convention of the generated tests would matter to the users.
below are conversations between a developer and the pex team on desired naming of generated tests by pex developer your tool generated a test called foo001.
i don t like it.
pex team what did you expect?
developer foo should fail when the bar is negative.
when developers write traditional test methods manually they use meaningful naming conventions for these test methods.
it is natural for developers to expect to see meaningful naming for generated test methods especially when no parameterized unit tests are written and the generated test methods are used for robustness checking as directly inspected by the developers .
in response to user feedback like the above the pex team improved the naming 391convention in various ways e.g.
when a test throws an exception throws exceptiontypename is added to the name of the generated test method.
pex incorporates a number of techniques to minimize the users inspection or investigation efforts.
pex includes techniques to produce fewer object creation messages that are not actually relevant to better engage the users to cooperate with pex to address those challenges faced by pex .
pex includes techniques to suppress warnings that are hard to understand they are still shown in the diagnostic mode or do not matter.
pex also allows users to manually suppress object creation messages that are not relevant in the users context by clicking the ignore button.
pex also provides convenient views such as the global event view the exploration tree view and the exception tree view to enable users to conveniently navigate through the path exploration results.
pex incorporates various convenient mechanisms to seek feedback from users.
for example the pex team added the thumbs up and thumbs down buttons along with a link on send feedback for asking questions in the pex forum in the pex result view.
.
performing well on best case scenarios while averagely on worst case scenarios in general a proposed technique such as a search strategy may often have its best case application scenarios and its worst case scenarios.
for example most previous approaches to dse typically use a fixed depth first backtracking search strategy where the next execution path would always share the longest possible prefix with the previous execution path.
therefore much resource may be allocated to analyze small parts of the program under test before moving on.
the worst case scenarios for such search strategy would be code including a loop with its loop bound dependent on program inputs because such search strategy would try to unfold the same loop forever.
a patch to such search strategy as often adopted by previous approaches to dse is to impose a fixed bound on the number of iterations of a loop.
but then the worst case scenarios for such search strategy would be code including branches whose coverage would require the number of iterations of a loop to be beyond the imposed fixed bound.
some other well known search strategies such as breadth first search do not get stuck in the same way as depth first search but it does not take into account the structure of the program having its own worst case scenarios.
to allow pex to be applied generally well on a variety of realworld code the pex team could not afford to adopt any of the above mentioned search strategies which typically work quite well on their best case scenarios but quite poorly on their worst case scenarios.
to address such issues before september pex preferred a fair choice between all such unexplored branches of the explored execution tree.
pex included various fair strategies which partition all branches into equivalence classes and then picked a representative of the least often chosen class.
the equivalence classes clustered branches by mapping them according to different criteria.
in september pex combined the new fitnex strategy with its above mentioned fair choice strategy.
such combination in fact enables to perform well on best case scenarios while performing averagely on worst case scenarios.
the best case scenarios for fitnex include code whose coverage is amenable to fitness functions and the worst case scenarios include code whose coverage is not amenable to fitness functions.
for fitnex s worst case scenarios the search strategy combination can make pex to perform very similarly to its fair choice strategy.although such search strategy combination does not read like a significant portion of our proposed work in the published paper on fitnex the combination design is very critical to enable the integration of fitnex to pex releases.
to our best knowledge there was no or little discussion on such desirable characteristic of performing well on best case scenarios while averagely on worst case scenarios for a proposed new technique in the research literature.
however such desirable characteristic is a precondition for a technique to be integrated into a tool aiming for adoption in practice.
.
dealing with tool users stereotypical mind set or habits tool users may have specific stereotypical mindsets.
in fact different subgroups of tool users may have different stereotypical mindsets.
for example one stereotypical mindset towards an automated test generation tool is that using such tool would be simply one mouse click and then everything would work just perfectly.
a developer with such stereotypical mindset could easily get frustrated and give up in continuing using a tool when the tool faces challenges in dealing with the real world code base that the developer intends to apply the tool on.
therefore setting realistic expectations right away is very important when introducing a tool such as pex to the target users e.g.
developers.
although it is important to illustrate the potential benefits of the tool to the target users the tool will typically have limitations and these limitations must be clearly communicated to the target users and how the target users can deal with such limitations.
in other words the target users should be informed and trained on helping the tool to deal with those faced limitations in a cooperative way as advocated in the cooperative testing methodology .
for example training the target users to know how to use moles or fakes to isolate environment dependencies is very important to enable successful application of pex on real world code bases which tend to have many environment dependencies.
note that tool users often may not realize the hidden complexity of the code under test brought by the invocation of some thirdparty api method and then blame the tool for the achieved low code coverage .
below is an example code snippet under test that a developer applied pex on and complained about achieved low code coverage of void sum int numbers string sum foreach int number in numbers sum int.parse sum number .tostring if sum throw new bugexception in fact invoking simple api methods such as int.parse and int.tostring can incur challenges for pex or any other test generation tool because the implementation code of these api methods can be complex including a huge or infinite number of paths for pex to explore.
in addition some tool users may have a stereotypical mindset on thinking or expecting that a test generation tool capable of achieving high code coverage would detect all or most kinds of faults in the code under test.
it is also important to emphasize the limited kinds of faults e.g.
crashing or uncaught exceptions that can be detected by the tool when the users do not write any specifications such as properties in production code under test or parameterized unit tests to reflect the intended behavior of the code under test.
for example it was observed that a developer complained your tool only finds null