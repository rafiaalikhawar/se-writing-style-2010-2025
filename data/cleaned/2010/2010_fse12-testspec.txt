testing mined specifications mark gabel department of computer science the university of texas at dallas mark.gabel utdallas.eduzhendong su department of computer science university of california davis su ucdavis.edu abstract specifications are necessary for nearly every software engineering task but they are often missing or incomplete.
specification mining is a line of research promising to solve this problem through automated tools that infer specifications directly from existing programs.
the standard practice is one of inductive learning mining tools make observations about software and inductively generalize them into specifications.
inductive reasoning is unsound however and existing tools commonly grapple with the problem of inferring false specifications which must be manually checked.
in this work we introduce a new technique for automatically validating mined specifications that lessens this manual burden.
our technique is not based on heuristics it rather uses a general semantic definition of a true specification.
we perform systematic targeted program transformations to test a mined specification s necessity for overall correctness.
if a violating program is correct the specification is false.
we have implemented our technique in a prototype tool that validates temporal properties of java programs and we demonstrate it to be effective through a large scale case study on the dacapo benchmarks.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering f. .
specifying and verifying and reasoning about programs keywords specification inference reverse engineering software tools .
introduction nearly all software engineering tasks require some form of a specification.
implementation debugging and testing for example all involve reconciling a software program s specified and actual this research was supported in part by nsf career grant no.
nsf cybertrust grant no.
nsf ccf grant no.
nsf tc grant no.
nsf shf grant no.
and the us air force under grant fa9550 .
the information presented here does not necessarily reflect the position or the policy of the government and no official endorsement should be inferred.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.behaviors.
documentation and source code comments are standard sources of specifications but they are often incomplete incorrect or missing entirely.
worse yet time saving software tools our research focus require formal machine readable specifications which are even rarer.
research in specification inference aims to solve this problem through tools that automatically reverse engineer specifications directly from programs.
although reasoning soundly about specifications from implementations is generally impossible the intended behavior of a stable software project can be somewhat evident.
for example if calls to the function lock.lock often precede lock.unlock it might be reasonable to suggest that this relationship is necessary andrequired.
this example illustrates the essence of how specification mining tools work they make observations about software and generalize them into specifications albeit with a degree of uncertainty.
that degree of uncertainty is a central issue in specification inference.
the fundamental cause of imprecision in specification inference is the standard problem of induction generalizing from examples is unsound.
a mining tool is easily deceived into reporting frequently observed coincidental relationships as false specifications e.g.
calls to list.add must precede list.isempty .
the possibility of these false positives forces the user of the tool to validate each inferred specification manually.
manual validation of mined specifications is an expensive and error prone process.
unfortunately it is also essential truly sound reasoning about specifications requires specifications a circular dilemma.
researchers have nonetheless tried to reduce this burden with several automated techniques for identifying and filtering likelyfalse specifications including leveraging simple usage statistics more advanced statistical models and assorted heuristics .
all of these techniques are alike in that they operate on the belief that classes of true and or false specifications are somehow alike and mechanically recognizable.
in our own continuing research we have found existing specification validation techniques to be insufficient.
the current statistics and heuristics approach does work adequately when applied to the examples frequently found in the research literature such as specifications mined from language level standard libraries.
specifications over java s iterator iterator.hasnext next and c s file descriptors open fd close fd are recognizable examples.
our research focus however has been to scale specification mining down and out to project specific and highly semantic properties those perhaps most relevant to the majority of software tasks and existing techniques have left us at a precision wall.
in short false positives dominated our early experimental results.
in this paper we present a novel and effective automated technique for validating mined specifications.
our technique is not a 1surface level statistic or heuristic it is instead based on a purely semantic definition of a true specification that is a result of a firstprinciples reexamination of the problem.
we have formulated our approach around this key observation a true specification is one that is necessary for correctness.
our technique takes the following high level approach.
we start with a program and a potentially false mined specification say that a call to method foo should always be followed by a call to bar .
we then perform a series of automated experiments each of which involves transforming the program to violate that specification in this case reordering and or removing calls to foo andbar and evaluating correctness using testing.
if we can generate a transformed program that both a violates the mined specification and b is correct then we have shown the mined specification to be unnecessary for correctness and thus false.
we call our technique deductive specification inference or dsi.
the name deductive reflects our goal of moving away from heuristics and statistics but it is of course an idealization as mentioned earlier sound deductive reasoning about specifications from programs is impossible.
that limitation is manifest here by the requirement that we precisely evaluate the correctness of a program which if possible would require complete specifications obviating the need to mine them!
we have approximated this ideal with testing and our implementation of our technique is thus like any specification miner must be imperfect.
nonetheless dsi is effective in practice as we show in a case study of several real java programs.
this paper includes the following contributions .a novel specification validation methodology dsi that avoids the use of statistics or heuristics.
.an implementation of our method for a well studied domain temporal specifications over the sequences of method calls in a java program.
.a case study demonstrating our tool s effectiveness on several open source java programs.
.a detailed discussion of the nuances and limitations of our technique including how these limitations speak to fundamental limitations of specification inference in general.
the next section section provides an overview of our approach through a set of examples.
section then presents in detail both the dsi methodology and a tool implementing dsi for the domain of temporal properties of method calls.
our experimental results and related discussions follow in section .
in section we discuss dsi in the context of related work and in section we conclude with a discussion of future work.
.
overview in this section we provide an overview of our general approach through a series of examples.
we begin with an introduction to our target domain temporal specifications and continue with a presentation of our general technique as well as our implementation.
.
temporal properties and their inference the examples in this section are drawn from the domain of temporal specifications over program elements.
here temporal refers to the span of runtime execution and program elements refers to executable code.
a temporal specification extends traditional state assertions variable xis always positive with the notion of time once xis positive ywill eventually become positive as well .
one commonly studied class of temporal properties involves ordering restrictions on function calls.
functions are building blocks of software projects and the order in which they are composed is both critical and subtle especially in imperative and object orientedsystems with side effects.
common examples include locking disciplines in which a specification might state calls to methods lock and unlock on each lock object strictly alternate at runtime and resource usage rules in which a partial specification might state one should call close on a file descriptor soon after its final use.
temporal properties are often much more domain specific and obscure than these canonical locking and resource examples and they are rarely fully documented.
researchers have recognized this problem and developed automated software tools capable of mining temporal properties directly from programs.
the predominant models are forms of inductive learning.
many tools operate similarly in two high level steps observing at runtime or statically approximating the behavior of a program and generalizing that behavior into a specification.
.
validating specifications figure lists four examples of potential temporal specifications.
they were synthesized from observations of real software projects simplified excerpts of which are listed as well.
mining tools may report specifications like these for several reasons including the observed property is satisfied or mostly so by the observed program.
this condition is often trivially true.
the tool observes the property frequently with examples occurring frequently at runtime or within the static source code.
this encodes the belief that common behavior is likely to be correct .
assorted heuristics.
for example the property listed in figure 1a involves a method named execute which may match a function name filter that identifies naming patterns that have often been important in the past.
ultimately a specification mining tool takes an inductive leap essentially lifting observations into specifications based on both observed evidence and prior beliefs.
potential specifications may not be true though which is a natural consequence of inductive learning.
when a programmer is presented with a mined specification he or she must generally validate and or debug it before it becomes useful.
approaches include code inspection.
if the specification is not followed would it lead to an obvious error?
reconciling with known requirements.
is the specification clearly in consistent with existing specifications?
consulting with experts and past software engineering data.
have the elements of this specification been involved in any prior issues?
note the lack of a complete algorithmic solution.
this is precisely what makes specification inference difficult in practice and impossible in the limit.
these validation techniques do follow a common theme though they involve using disparate sources of information to answer the following question as accurately as possible given a potential specification j isjnecessary for my program s correct execution?
our current work can be framed as a method for solving this problem systematically and automatically.
.
automated experimental validation returning to the running examples consider now the contrapositive of the validation problem does violating jmake my program incorrect?
21compilertest test ... 2test.reset set up prog variable 4test.execute prog out err a. call compilertest.reset at some point before calling compilertest.execute.
1resourceattributes attr ... other setup 3attr.setarchive true 4attr.setsymboliclink false b. resourceattributes.setarchive andsetsymboliclink must appear in sequence.
1generatoradapter gen ... set up type and constr variables 3gen.loadthis ... other gen invocations 5gen.invokeconstructor type constr c. call generatoradapter.loadthis at some point before calling generatoradapter.invokeconstructor.
1savemanager sm this other state restoration actions 3try sm.restoremarkers resource true p sm.restoresyncinfo resource true p catch exception e ignore d. savemanager.restoremarkers andrestoresyncinfo must appear in sequence.
figure four observed temporal properties and a selection of the java source code that generated them.
1compilertest test ... test.reset set up prog variable 4test.execute prog out err 5test.reset a. call compilertest.reset at some point before calling compilertest.execute.
1resourceattributes attr ... other setup attr.setarchive true 4attr.setsymboliclink false 5attr.setarchive true b. resourceattributes.setarchive andsetsymboliclink must appear in sequence.
1generatoradapter gen ... set up type and constr variables gen.loadthis ... other gen invocations 5gen.invokeconstructor type constr 6gen.loadthis c. call generatoradapter.loadthis at some point before calling generatoradapter.invokeconstructor.
1savemanager sm this other state restoration actions 3try sm.restoremarkers resource true p sm.restoresyncinfo resource true p sm.restoremarkers resource true p catch exception e ignore d. savemanager.restoremarkers andrestoresyncinfo must appear in sequence.
figure transformed programs that should now be wrong if each specification is real or necessary.
phrasing the question this way suggests an experimental solution.
figure reprises the potential properties listed in figure but the code excerpts have now been transformed.
for the domain of temporal properties we have a strong idea of what it means to violate a specification and in each case the code has been minimally and straightforwardly modified to violate each property.
if each of the potential specifications is true then each program in figure should now be wrong.
the problem now reduces to judging each experiment as correct or wrong.
if we were able to judge any as being correct despite being transformed we could say with some certainty that the associated specification is unnecessary for correct execution and thus false.
similarly if one of those programs were now incorrect we would obtain evidence but not proof that the associated specification is necessary and true.
note the lack of the word certainty in the latter case it is rife with subtlety and will be discussed in more detail throughout this paper.
judging a program correct or wrong is generally impossible of course and to do so actually begs the question of a complete specification.
however correctness checking can often be approximated through testing and analysis giving us the final component we need to automatically but approximately validate specifications.
our high level technique is as follows .start with a proposed specification jfrom a program p. for temporal function call specifications this might be of the form calls to function aalways precede calls to function b .
the normal source of proposed specification will be a specification mining tool.
.create a suite of experimental programs around pandj a sort of design space populated with programs similar to pbut violating j. we accomplish this through automatic program transformations.
continuing the earlier example this space may consist of the family of programs in which calls to aandbare reordered.
.testthese experimental programs.
if jis found to be unnecessary for correctness then jis not a specification.
we call this process deductive specification inference or dsi.
this name reflects dsi s logical and experimental nature but we emphasize again that truly sound deductive reasoning in this setting is impossible.
nonetheless on our example properties this automated process is very revealing.
the experiment in figure 2a crashes early reset does in fact set up the precondition for execute to run the specification is true.
experiment 2b passes the order in which these two fields are set is irrelevant.
experiment 2c fails but notwith an immediate crash it ultimately causes operations much later in the test suite to fail.
3generatoradapter is a helper class within a java bytecode library.
not following this temporal specification will actually result in the generation of bytecode that violates the java bytecode specification which is what ultimately causes the much later test failure.
experiment 2d passes but perhaps surprisingly so each operation contains a substantial amount of overlapping side effects.
from a class level perspective though the tests demonstrate that the observed ordering is irrelevant.
in theory one could transform this specification validation procedure into a specification inference algorithm as validation and inference are fundamentally the same problem.
for temporal specifications we could simply enumerate every possible ordering of function calls and systematically validate or invalidate each one.
however for efficiency and to better leverage advances in specification mining we bootstrap the process with an inductive specification mining tool.
this section has provided an overview of our automated validation technique and how we implement it for the domain of temporal function call properties.
the following section presents our dsi methodology and implementation in full detail including a discussion of the strengths and subtle limitations of the technique.
.
testing specifications we have implemented dsi for the domain of temporal functioncall properties of imperative and object oriented systems.
our implementation uses automated program transformations to conduct its experiments and it uses software testing to approximately evaluate correctness.
we introduced the temporal function call problem domain earlier see section .
and continue here in more depth.
.
temporal function call properties we address a common class of specification ordering restrictions on function calls within a software project.
these specifications are common and error prone as they are not enforced by the type systems within standard compilers.
when they are defined formally however advanced software tools can check them statically or at runtime preventing and eliminating errors.
the formalism we use to represent specifications is regular languages.
while the most general formalism for expressing these properties is some form of a temporal logic many important properties can be expressed as simple regular languages.
the earlier examples of locking and resource disposal are both regular lock unlock and read close respectively.
each specification is quantified over a domain of possible usage scenarios which is a general way of capturing the notion that the properties only restrict related function calls e.g.lock andunlock calls on the same lock object or read andclose calls on the same file descriptor.
our tool is implemented for programs written in the java programming language.
for simplicity we focus on temporal properties of function calls on a single object that is our domain of scenarios is the set of objects at runtime.
note that we use receiver objects solely as a convenient and reliable way of relating sets of method calls through data.
no aspect of our implementation is fundamentally restricted to object oriented systems.
remark.
a related concept is typestate the notion that individual types have a high level state that dictates when certain operations e.g.method calls are legal i.e.when they do not violate aninternal class invariant.
because we focus on single object properties it is tempting to view dsi narrowly as a form of typestate inference.
our technique certainly willvalidate typestate properties the two examples above fall into this category but it is far dynamic specification miner stripped of heuristics temporal function call dsi experimental harness experiment selection experiment execution result analysis experiment validity tests determinism check test coverage runtime monitor lazy evaluation framework delay force user defined tests assert x program transformations randomized differential tests figure implementation architecture.
more general.
by using overall system correctness as an oracle rather than obeys a preexisting local class invariant our tool can and frequently does infer interesting domain specific properties like that shown in figure 1c the class does not crash when used incorrectly no local class invariant is violated but it eventually causes a violation of a higher level system specification.
.
temporal function call dsi our temporal function call implementation of dsi takes as input .
a java program and .
a mined temporal specification over a set of function calls.
it runs a series of automated experiments returning as output .
likely true specification or .
likely false specification with supplemental details .
the high level architecture appears in figure .
execution occurs in two phases preamble andexperiment.
the first involves constructing a set of experiments that aim to test the necessity of the mined specification.
we implement this process using static program transformations that use a novel lazy evaluation framework for java programs.
the second phase is dynamic running and interpreting these experiments with respect to a correctness oracle which we approximate through testing.
remark.
testing for necessity for correctness is superficially similar to testing for control flow or data flow dependencies a heavilystudied subject.
lack of any control or data dependence is sufficient cause to invalidate a specification but it is far from necessary.
this issue is analogous to the distinction between strong andweak mutation testing .
mining a set specifications to validate for a given program is straightforward.
we make use of an existing dynamic inductive specification inference tool that has had its heuristics disabled.
.
phase i preamble our temporal properties describe ordering relationships between sets of function calls.
we testa mined specification by transforming the input program in various ways so that all relevant function calls are reordered in a specification violating way.
transforming java programs reordering function calls in real software projects is problematic.
highly local cases are simple if two function calls appear on subsequent lines their parameters tend to draw from the same variable scope simplifying the actual transformation.
in our experience though the source code of actual projects tends to form a complex and rigid scaffolding that is 41generatoradapter gen ... set up type and constr variables 3gen.loadthis other gen invocations possibly crossing procedure boundaries 6gen.invokeconstructor type constr a.original source code.
1thunk t global known location 2generatoradapter gen ... set up type and constr variables 4t delay gen.loadthis other gen invocations possibly crossing procedure boundaries 7gen.invokeconstructor type constr 8force t b.transformed source.
figure the essence of our transformation.
delaying the first invocation until the second has executed violates the mined specification.
difficult to modify and the most important and subtle properties are likely to be those that are not confined to a pair of sequential lines of code.
we solve this problem by implementing a robust lazy evaluation framework for java programs.
put simply our framework lets us capture an arbitrary java function call andits parameters in an executable function object save it and execute it later.
it brings to java the concept of promises in eager functional languages like scheme.
the entry point is analogous to the delay primitive in scheme but slightly generalized given an arbitrary sequence of straight line java bytecode our framework functionally abstracts it and creates a closure with its eagerly bound parameters thus converting it into a thunk.
this object may then be executed at any time immediately or later by an analogue of scheme s force primitive.
lazy evaluation greatly simplifies the task of reordering function calls.
our transformation occurs at the bytecode level but it maps conceptually well on to source code.
an example of the essence of our transformation appears in figure .
the higher level operation in the figure is delay the first function call until point p .
this operation is the basis of all of our transformations and the remaining questions are when andwhere to apply it.
surveying behavior our selection technique relies on proactivelycollected information about the runtime behavior of the program.
figure provides an overview of the complete dsi process the left pane depicts this preamble phase.
before selecting experiments we execute the program s test cases the same tests that will be used during the experiment phase twice once unmodified and once instrumented which collects a property related trace.
we then use this trace to generate our set of transformations.
in addition these pilot runs allow us to perform various sanity checks including is the property actually exercised in these test cases?
if not then our broken programs will certainly be judged correct causing a false invalidation.
is the property satisfied by the program?
if not the currentlypassing tests imply this is a trivially false specification is the program s behavior deterministic enough to allow experimentation?
if not our experiment selection algorithm may fail.
the third check is not as stringent as it appears we use a flexible form of execution indexing that tolerates a great amount of variation in program behavior.selecting effective experiments consider the mined specification method fooshould always be called before method bar.
there are many ways to violate this specification remove all calls of fooandbarfrom the program entirely.
randomly delete calls of foo bar throughout the program.
reorder the calls by delaying all runtime invocations of foo until the program exits.
reorder the calls by delaying each invocation of fooby the minimum amount of time necessary to cause a violation.
these actions differ in the amount of change or disturbance they cause on the target system and the fourth least intrusive option appears most sensible.
there is an analogy here to traditional scientific experimentation and the issue of control.
here we wish to answer the question is the stated relationship between fooandbar necessary for correctness?
a well designed experimental answer should vary precisely that relationship and leave unchanged all other aspects of the program s execution.
in realistic software projects full behavior isolated control will be generally impossible specifications overlap and program components communicate.
rather as the examples demonstrate it tends to be a matter of degree.
selection algorithm the preceding line of reasoning led us to anexperiment selection algorithm that strives for completeness and control.
we respect completeness by generating test programs that violate each potential binding of the property at runtime.
we maintain control by so in as minimally intrusive manner as possible.
that is each time the elements of a mined specification are used at runtime we delay the minimum number of function calls by the minimum amount of execution time necessary to violate the property.
our experiment selection algorithm is listed as algorithm .
it takes as input a mined specification and the previouslydescribed trace of the program s specification related method calls.
it returns an instruction for a minimal experiment idx len which can be interpreted as the minimally intrusive way to violate the given specification is to delay theidxthmethod call by len calls.
this algorithm ensures minimality by taking a brute force approach it simply evaluates all possible transformations.
in the worst case this algorithm runs in time quadratic in the length of the trace in practice it is much closer to linear the set of trials line is eagerly pruned lines and remains consistently small.
note that this algorithm is formulated in terms of a single usage scenario e.g.the calls surrounding a single file descriptor and it returns a single experiment.
in practice we process multiple scenarios simultaneously and generate a suite of experiments.
remark.
the simple primitive delay a call until time p is powerful for example multiple functions can be simultaneously delayed and re emitted in any order.
in theory this delay primitive is notpowerful enough to break i.e.transform to rejecting every accepting string of any arbitrary non total regular language.
fortunately in practice every valid trace of every regular specification pattern we have encountered in our work can be broken by delaying just a single event albeit by varying amounts of time.
we have performed a more thorough theoretical investigation of this problem which we have omitted for brevity.
other implementation notes one complication to our otherwise simple process is caused by the presence of explicit return values from the functions we delay if a function is not evaluated we cannot know what it will return.
we solve this problem by implementing a model of what a sensible programmer would do in this situation inspired by our principle of minimally intrusive experiments.
we 5algorithm algorithm for selecting an experiment for a given usage scenario.
returns a minimally disruptive perturbation that causes a violation of a mined specification.
input p s fm1 m2 g s s0 d f mined regular specification over methods fm1 m2 g t hcall idx method i an indexed runtime trace of method calls for one usage scenario where method2fm1 m2 g output idx len a minimal perturbation delaying the call attrace index idx by len number of calls violates pand minimizes len over all such violating transformations.
strace s0 .the state of the trace w.r.t.
specification p e fg .set of trial experiments f idx len s gif the call at idx were to be delay ed by len calls pwould be in state s. min null .minimum amount perturbation for all call idx method intdo for all trial idx len s inedo .trial sis the state of p had the call at trial idxbeen delayed trial s nextstate p trial s call method trial len trial len sforced nextstate p trial s t .sforced is the state of pif forced now ifisrejecting sforced andissink sforced then ifmin null ortrial len min lenthen min trial idx trial len end if e entrial else if min6 null andtrial len min lenthen e entrial end if .perf.
optimization track minimum and prune early end for e e call idx strace .create a new trial strace nextstate p strace call method end for for all trial idx len s inedo .tabulate remaining trials ifmin null ortrial len min lenthen min trial idx trial len end if end for return min implement a simple type analysis that allows us to replace the return value of a delayed call with the value of the nearest defined local variable of the appropriate type or the language defined default value if one is not found .
this general definition automatically captures many intuitive actions including reusing the return value from a previous call among others .
multithreaded programs caused complications as well.
avoiding any single threaded assumptions handled most issues but our early experiments revealed several fundamental challenges.
for one we may move a function call to a program point at which an important lock is no longer held.
to solve this issue our lazy analysis framework makes note of the locks held during a runtime invocation ofdelay and optionally attempts to reacquire them if necessary when the thunk is force ed .
in another case a delayed call was indirectly responsible for some event that if omitted would cause a second call to block indefinitely creating a deadlock.
in this case we instituted a global inactive timeout on our experiments if the subject program makes no forward progress after a period of time we forcibly terminate the program.the execution of these initial runs tests and experiment selection algorithms form the entirety of the preamble phase.
at its conclusion we have produced a set of transformed experimental programs that are ready to be evaluated.
.
phase ii experiment the experiment phase is conceptually simple we run each experiment in the suite of transformed programs and interpret the results.
testing as an oracle our approximation of a correctness oracle istesting.
this portion of our tool is pluggable to allow the use of user defined tests and test oracles.
in addition we also provide a default implementation based on randomized regression testing.
we first run the unmodified assumed correct program on random inputs.
we record the input output behavior on these inputs as a behavioral profile which then becomes our test oracle.
this process is similar to differential testing which uses automatically generated tests to test modified software for regressions.
analysis of results at a high level the only important output is the success or failure of each individual test failures suggest the mined specification is valid successes suggest it is false.
however exactly how a test executes and fails can be useful knowledge.
regardless of the property the precise relationship it defines or the number of functions it