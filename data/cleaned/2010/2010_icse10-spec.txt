online inference and enforcement of temporal properties mark gabel zhendong su department of computer science university of california at davis mggabel su ucdavis.edu abstract the interfaces of software components are often paired with specifications or protocols that prescribe correct and safe usage.
an important class of these specifications consists of temporal safety properties over function or method call sequences.
because violations of these properties can lead to program crashes or subtly inconsistent program state these properties are frequently the target of runtime monitoring techniques.
however the properties must be specified in advance a time consuming process.
recognizing this problem researchers have proposed various specification inference techniques but they suffer from imprecision and require a significant investment in developer time.
this work presents the first fully automatic dynamic technique for simultaneously learning andenforcing general temporal properties over method call sequences.
our technique is an online algorithm that operates over a short finite execution history.
this limited view works well in practice due to the inherent temporal locality in sequential method calls on java objects a property we validate empirically.
we have implemented our algorithm in a practical tool for java ocd that operates with a high degree of precision and finds new defects and code smells in well tested applications.
categories and subject descriptors d. .
software program verification general terms languages algorithms experimentation reliability keywords dynamic analysis temporal properties online algorithm this research was supported in part by nsf career grant no.
nsf cybertrust grant no.
nsf ccf grant no.
and the us air force under grant fa9550 .
the information presented here does not necessarily reflect the position or the policy of the government and no official endorsement should be inferred.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.
.
introduction the interfaces of software components are often paired with specifications or protocols that prescribe correct and safe usage.
if violated software systems may crash or perhaps worse be placed in an inconsistent state and behave nondeterministically.
one important type of these specifications is the class of temporal safety properties over function or method call sequences.
common examples include locking disciplines in which locking functions e.g.
lock unlock must be called in a strictly alternating fashion and resource usage in which all resource like objects e.g.files sockets must be eventually closed or disposed and cannot be used thereafter.
formalized by researchers as the typestate concept these properties capture a broad category of software defects and have inspired a diverse body of research.
many static formal verification algorithms in particular software model checkers either specifically target these specifications or use them as their primary example.
similarly dynamic tools such as runtime monitoring frameworks often operate over these temporal properties as well.
these tools and techniques have advanced significantly in recent years particularly in the areas of scalability and automation but they still must be supplied with temporal specifications to verify generally a manual and time consuming task.
this dearth of enforceable properties has led in part to the development of automated specification mining orinference techniques.
these tools observe a system s source code or its runtime behavior and produce one or more temporal specifications as a result.
most of these tools leverage potentially imprecise parameters such as the frequency of a specification s occurrence in the source code or the number of times it was satisfied in a dynamic trace.
similar to data mining in fact many specification mining tools directly use data mining algorithms these inexact parameters lead to a precision recall tradeoff a precise tool may fail to infer important properties while a more liberal tool may produce many false properties requiring a large time investment by the software developer.
in this paper we present a novel technique and a practical tool ocd for simultaneously learning and enforcing general temporal properties over function or method call sequences.
both tasks are tightly integrated and form a symbiotic relationship the verifier benefits from the abundance of inferred properties and the learning algorithm benefits from the results of continuous verification to learn and refine properties.
most importantly the software developer our intended user benefits from being removed from the center of the process he or she can use ocdas a turn key dynamic online bug finding tool that requires no input beyond the program to analyze.
ocdis a dynamic trace processor for java programs it analyzes java method calls online through load time instrumentation.
at a high level our algorithm functions by using a predefined set of specification templates two letter regular expressions that represent components of larger more general temporal properties andattempting to enforce them in a brute force manner over all possible combinations of method calls.
our experience with the javert specification miner provides evidence that the inference of these small properties can yield a surprisingly complete and general class of temporal specifications and we show in this paper that enforcing these smaller patterns is a safe approximation of enforcing the larger general properties.
our work is enabled by two key observations temporal locality from a scalability perspective this brute force approach would ordinarily be intractable in both time and space.
we solve this problem by operating over a relatively small finite window of trace events which greatly constrains the number of property instances that we learn and enforce.
though we demonstrate that theverification of properties over a finite window is a safe approximation of verification over a complete trace a finite window may greatly reduce the effectiveness of any learning algorithm we may be unable to sufficiently speculate if our view is too short sighted.
this effect is greatly mitigated sometimes even completely by the fact that method calls in java programs exhibit a high degree of temporal locality that is operations on particular objects tend to be tightly clustered in time.
we have stated this observation anecdotally in previous work we now evaluate it empirically in section and find it to be true for a diverse set of commonly used java programs.
verification of redundant properties dynamic specification miners attempt to synthesize specifications by generalizing a program s observed behavior.
unfortunately false specifications often result from the inference of true properties of the trace perhaps inferred from coincidentally common behavior caused by control flow artifacts for example that are not considered by the developer to be true specifications.
while this poses a major precision problem for specification miners it affords us an interesting opportunity.
as the goal of our technique is to locate defects not to produce human usable specifications the properties we infer are seen by a human developer only if they are violated .
rather than applying coarse grained filtering heuristics as is commonly done and likely losing many important specifications we can simply attempt to verify alllearned properties without human validation.
the vast majority of the false properties are verified and produce no output thus trading inexpensive cpu time for valuable human developer time.
we evaluated ocdon a set of commonly used java programs and found that it learns and fully verifies a large set of temporal properties with acceptable overhead.
on a subset of our evaluated programs our tool revealed previously unknown defects and code smells.
in all experiments ocdmaintained a high degree of precision.
we make the following specific contributions .the first online algorithm that simultaneously learns and enforces general temporal properties of software systems.
our algorithm is an online trace processor that operates over a short sighted finite window of trace events.
.a practical tool for java ocd which we use to demonstrate the effectiveness of our algorithm.
o cdlearns and verifies a large number of properties with acceptable overhead and high precision and it finds previously unknown defects.
.a demonstration of the generality of our work.
in particular we show that our tool can be configured to discover and enforce function precedence protocols as well as temporal association rules of function calls and field accesses .
.an empirical evaluation of the temporal locality of java method accesses in practice which we use to justify our use of a short sighted trace window as well as set its size .
pattern p ab ab a3 contents of window q timeexpiring event eold latest event enew ... os.lock map.get object map.get object map.get object map.get object ... os.lock map.get object os.unlock map.get object map.get object trace trace assignment a b lock unlock unlock lockstate sf lock unlock unlock lock get lock lock get1 err 0specs before enew specs after enewassignment a b lock unlock unlock lockstate sf lock unlock unlock lock get lock lock get2 err err 0figure execution of algorithm on two example traces.
this paper is organized as follows.
the following section section describes our general approach and algorithm while section discusses the realization of our algorithm as a practical defect detection system.
section contains an empirical evaluation of our work and sections and discuss related work and our plans for continuing this research respectively.
.
approach this section describes our basic approach.
we first describe our algorithm in its simplest form section .
.
we then expand on the basic definition with a series of generalizations sections .
.
that form the final algorithm implemented in our tool o cd.
.
basic algorithm our algorithm described in pseudocode as algorithm functions as an online trace processor that receives traced events from an instrumented application as they occur.
it is configured with a pattern template an abstract model of a specification and produces as online output anomalies specific instantiations of the templates that likely represent defects in the monitored system.
events in this basic incarnation of our algorithm an event consists only of a type t. when tracing java method calls for example t represents a method s fully qualified signature.
sections .
and .
sections discuss generalizations that consider additional information e.g.receiver objects.
two example traces appear in figure .
pattern templates apattern template is a two letter regular expression describing the general structure of specifications to infer.
we refer to its alphabet as the symbolic alphabet which for the remainder of the paper we will assume without loss of generality to be exactlyfa bg.
for this expository example we will focus on the simple alternating pattern ab which describes the family of two event specifications in which the events must strictly alternate.
a minimal finite automaton that recognizes this pattern appears in figure .
a concrete assignment fa7!t1 b7!t2gmaps the symbolic alphabet to two distinct trace event types.
in the first example trace of figure one possible concrete assignment into the alternating pattern is fa7!os lock b7!os unlockg forming the potential specification os lock os unlock .
finite window our algorithm operates over a finite window a bounded view of a trace s history.
the window is a standard fifoalgorithm online inference and enforcement algorithm.
constants p two letter pattern automaton over fa bg with statesfinit g types asgn a t b t spec asgn asgn sat int fail int st state of p state q bounded queue of t specs asgn7!spec require enew t q add q enew eold remove q for all efutinqdo if eold efut 2domain specs then specs eold efut eold efut init specs efut eold efut eold init end if end for for all spec inspecs eold specs eold do ifspec asgn a eoldthen spec st next spec st a else spec st next spec st b end if ifspec asgn anot in qandspec asgn bnot in qthen ifisfinal spec st then spec sat spec sat else spec fail spec fail ifisenforcing spec sat spec fail then r eport anomaly end if end if spec st init end if end for queue we add each new event to its head while simultaneously removing the oldest event from its tail maintaining a fixed size.
we formulate our algorithm in terms of this expiring event the queue in effect provides a short sighted view of the future .
though omitted from this presentation for brevity we populate the queue with null events on startup and drain it completely on shutdown.
our algorithm aims to a learn concrete assignments of the pattern i.e.
specifications that should be enforced and b report violations as anomalies .
though conceptually distinct our algorithm integrates the two processes such that they are indistinguishable.
the following steps describe our algorithm s execution and they serve to narrate the running example in figure and the pseudocode of algorithm .
as this is an online algorithm we describe its execution in terms of the steps we perform on a single event.
state our algorithm maintains a collection of tuples each of which contains a a concrete assignment defined earlier b a satisfied count the number times the pattern was matched over a substring of the trace c a failed count defined similarly and d a pattern automaton instance which we encode as its current state .
queue maintenance lines we add the newest event to the head of the queue and remove the oldest for processing.
in our example figure our queue is of length four and our newest and oldest events are the same for both traces map.get andos.lock respectively.lazy instantiation lines we observe the queue and identify any upcoming pairings concrete assignments of the pattern that we have not yet seen.
we then instantiate two patterns one for each symmetric assignment in their initial state.
in our example traces map.get andos.lock have not yet occurred within a span of four our window size events so they are absent from the initial specification table.
after this step two concrete assignments are added to the table.
advancing automata lines we iterate through all specifications that our currently processed event eold participates in line and advance their state machines lines .
the test at line dereferences the concrete assignment to its symbolic letter and the state updates on lines and access an external function next which is a simple accessor for the transition relation of the pattern p. to improve performance our implementation incrementally maintains a mapped index from each seen trace element on to the set of all affected specifications.
trace left of figure demonstrates this step all four specifications including the two instantiated in their initial state are advanced according to the pattern.
bookkeeping and enforcement lines line inspects the queue determining if any forthcoming event is relevant to the current specification.1if not we have reached the end of a timeclustered substring of the trace with respect to the current specification and we inspect the last state of the automaton instance.
if the automaton was left in a final state i.e.
this trace scenario matches the specification and is accepted we increment the satisfied count.
if not the we increment the failing count.
line accesses isenforcing an external function predicate that takes as input the historical statistics i.e.
the sat and fail counts and determines according to a predefined algorithm if the specification should be considered real and enforced.
one simple implementation of i senforcing might be based on a ratio isenforcing sat fail sat sat fail threshold we refer to such functions as learning strategies .
the various implementations and the values of their constants thresholds are of great importance to our system s performance we discuss them in detail in section .
finally in the event that isenforcing returns true we report the current instance as an anomaly.
in trace right of our running example both lock unlock specifications must be counted and reset as neither lock norunlock appear in the window.
this results in a failure of both specifications with the failure of the more intuitive of the two lock unlock likely being flagged as an anomaly that is isenforcing returns true forlock unlock andfalse forunlock lock.
note that in this case our algorithm is conservative it may be the case that an unlock event is forthcoming but our window is not appropriately sized to recognize it.
this may result in both unlearned properties false negatives and false anomalies false positives which highlights the importance of setting the window to an appropriate size.
.
separating event instances the most crucial omission from our basic algorithm is its lack of support for separating and tracking multiple instances of the learned specifications.
when tracing java method calls for example it is often desirable to separate trace events that are generated from different receiver objects failing to do so can hurt both precision and recall.
for example if we consider a source program in which all operations require two nested locks all traces would appear to fail due to the apparent double locking.
even if we somehow learned 1for performance our implementation maintains an incremental set view of the queue.the specification or supplied it statically we would generate false error reports.
we adapt our algorithm to accommodate differences in receiver objects or more generally any form of different instance by extending the type of events from a simple type tto a pair t id where tis as defined previously and idis an integer identifier.
the remaining changes are straightforward rather than a single state st each specification tuple now contains a map instances id int !
st state of p .
thus the single instance specification tuple becomes a specification schema that tracks multiple instances.
the predicates not inq on lines and now operate only over the relevant queue elements i.e.those whose id eold id.
matching and anomaly reporting lines occurs on the specific relevant instance.
lazy instantiation lines is extended to build specific instances and the reset operation line is replaced with a full deletion from the specification s instances map to prevent unbounded memory usage.
note that our finite window allows a rather simple solution to this problem while other runtime monitoring tools must interact with the target program s runtime e.g.java s garbage collector through weak