minthint automated synthesis of repair hints shalini kaleeswaran varun tulsian aditya kanade indian institute of science india now at walmart labs shalinik varuntulsian kanade csa.iisc.ernet.inalessandro orso georgia institute of technology usa orso cc.gatech.edu abstract being able to automatically repair programs is at the same time a very compelling vision and an extremely challenging task.
in this paper we present minthint a novel technique for program repair that is a departure from most of today s approaches.
instead of trying to fully automate program repair which is often an unachievable goal minthint performs statistical correlation analysis to identify expressions that are likely to occur in the repaired code and generates using pattern matching based synthesis repair hints from these expressions.
intuitively these hints suggest how to rectify a faulty statement and help developers find a complete actual repair.
we also present an empirical evaluation of minthint in two parts.
the first part is a user study that shows that when debugging developers productivity improved manyfold with the use of repair hints instead of traditional fault localization information alone.
the second part consists of applying minthint to several faults in unix utilities to further assess the effectiveness of the approach.
our results show that minthint performs well even in common situations where the repair space searched does not contain the exact repair and the operational specification obtained from the test cases for repair is incomplete or even imprecise which can be challenging for approaches aiming at fully automated repair.
categories and subject descriptors d. .
testing and debugging general terms debugging aids diagnostics symbolic execution keywords program repair statistical correlations synthesis of repair hints .
introduction debugging is an expensive activity that can be responsible for a significant part of the cost of software maintenance .
it is therefore not surprising that researchers and practitioners alike have invested a great deal of effort in developing techniques that can improve the efficiency and effectiveness of debugging e.g.
.
in particular in recent years there has been a growing interest in automated program repair techniques e.g.
.
although these techniques have been shown to be effective they suffer from one or more of the following permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
char esc char s int i char result if s !
escape result s else if s endstr localization rank result escape else i i localization rank if s n result newline else if s t localization rank result tab else result s localization rank return result figure function esc from program replace version which contains a faulty statement at line .
the ones shown are the line numbers of function esc in the actual code.
limitations.
first some techniques rely on the existence of a specification for the program being debugged which is rarely the case in practice.
second techniques that do not rely on specifications tend to overfit the repair to the set of existing test cases which is likely to affect the general validity of the repair.
third because they are looking for a complete repair most existing techniques must perform a search over a repair space that is large enough to include the unknown repair.
for non trivial repairs this can make the technique either ineffective if the bound on the repair space used by the tool is too small or too expensive to be used in practice if the bound on the repair space used required is too large .
to address these limitations of existing techniques in this paper we propose minthint a novel semi automated approach to program repair.
minthint is a departure from most of today s program repair techniques as it does nottry to find a complete repair which we have observed to be an unachievable goal in many if not most cases due to technical and practical reasons.
instead minthint aims togenerate repair hints that suggest how to rectify a faulty statement and help developers find a complete actual repair .
as an example consider function esc from a faulty version of program replace shown in figure .
function esc takes as input a string and an index into the string and checks whether the character at the index is a special character e.g.
a newline .
if so it returns a program specific constant that represents the special character.
the fault is at line where the branch predicate should bes endstr but an incorrect array index i is used instead.
given this faulty program and a set of test cases for the program that trigger the fault i.e.
at least one test in the set fails due to this fault minthint would produce the following hint replace s endstr bys endstrpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
developers would use this hint as guidance while modifying the original code to arrive at a repair.
in this specific example developers would simply make the suggested change and obtain the repaired version.
in the more general case as we will show in section hints are not necessarily complete repairs but rather practically useful suggestions on how to generate such repairs.
to generate hints minthint operates in four steps.
the first step identifies potentially faulty statements by leveraging an existing fault localization technique that requires only a test suite e.g.
.
the subsequent steps are performed for each of the identified statements.
the second step derives a state transformer that is a function that is defined for all program states that reach the faulty statement in the given test suite and produces the right output state for each of them.
this step leverages dynamic symbolic execution e.g.
.
the third step explores a repair space and tries to identify and rank through a statistical correlation analysis expressions in the space that are likely to occur in the repaired statement using the state transformer derived earlier.
to the best of our knowledge this paper is the first one to apply this form of statistical reasoning to programs.
the fourth step of the approach synthesizes repair hints by pattern matching the expressions computed in the previous step with those in the faulty statement.
finally after computing hints for all potentially faulty statements minthint ranks the generated hints to help developers prioritize their efforts.
minthint synthesizes five types of hints that suggest insertion replacement removal or retention of expressions and combinations of these.
as shown in table these hints are applicable to many types of common faults including incorrect spurious or missing expressions and combinations of these.
moreover minthint can handle faults in a variety of program constructs such as assignments conditionals switch statements loop headers return statements and statements with ternary expressions.
minthint s main restriction is that the fault has to involve a single statement and in the case of an assignment it must be in the righthand side expression.
however we believe that minthint can be extended to address other situations such as those where the lefthand side variable is faulty or the fault spans multiple statements.
minthint overcomes the limitations of existing techniques which we listed earlier in the following ways.
first it does not rely on a formal specification it instead derives an operational specification i.e.
a state transformer from the test cases available.
second approaches that aim at deriving complete repair typically use equality with the state transformer or an analogous entity as a criterion for selecting a candidate repair e.g.
.
the statistical correlation used in minthint is amore relaxed and robust notion than equality and can thus be more effective in identifying which expressions are likely to be part of the repaired code this allows minthint to synthesize more general repairs and to be effective in the presence of incomplete data or even imperfect data i.e.
state transformer mappings that do not arise in execution of the fault free program .
third since minthint looks for building blocks of repair rather than the complete repair itself and then combines them algorithmically to generate compound hints it can generate useful actionable hints even when exploring an incomplete repair space.
to evaluate minthint we developed a prototype tool that implements our approach for c programs and performed a user study using programs from the siemens benchmark .
the study involved 10users and consisted of a control phase and an experimental phase.
in both phases we provided each user with a single repair task along with fault localization information and a test suite.
in the experimental phase in addition we gave the users repair hints generated byminthint .
the tasks we gave to a user in the two phases were independent.
without repair hints only 6of the 10users completedtable nature of hints and targeted faults.
nature of hint targeted fault insert missing expressions replace incorrect operator constant variable etc.
remove spurious expressions retain filtering out non faulty statements compound one or more occurrences of above their task within 2h.
with repair hints all10users could complete their task within the same time limit.
moreover the tasks completed in both phases were completed over 5times faster by the users who used minthint s repair hints.
in addition we evaluated minthint on a total of 11faulty versions of unix utilities sed flex and grep .
symbolic execution timed out for one of them and hence we did not generate hints for that version.
for 7of the remaining 10faulty versions minthint generated hints that immediately led to a repair that is we did not have to manually identify any additional transformations to achieve repair.
in one more case the hints resulted in a partial repair in which all passing tests continued to pass and several previously failing tests passed.
it is worth noting that both in the user study and in the evaluation on unix utilities minthint was able to synthesize useful hints even in the many cases in which the repair space considered did not contain the repaired version of the faulty expression or the state transformer contained imperfect data.
in general a fault localization tool may incorrectly flag a statement as suspicious.
minthint can discover such cases and generate retain hints for them helping developers focus their attention on the other statements.
in our experiments minthint filtered of such cases altogether.
in summary the main contributions of this paper are the definition of minthint anovel sophisticated programrepair technique that suitably combines symbolic statistical and syntactic reasoning and overcomes some of the main limitations of existing techniques by focusing on generating repair hints rather than complete repairs.
an implementation of minthint that can perform automated synthesis of repair hints for c programs.
a user study that evaluates the usefulness of repair hints during debugging.
this is one of the few user studies performed in the area of program repair and debugging in general .
a further evaluation of minthint s effectiveness on several faulty versions of three real world programs.
.
overview figure provides a high level view of minthint .
as the figure shows minthint takes as input a faulty program and a test suite where at least one test case triggers the fault in the program and thus fails and produces a list of repair hints in four steps.
we now describe these four steps using the example we discussed in the introduction shown in figure .
step fault localization.
this is a preliminary step whose goal is to provide the hint generation algorithm with a list of possibly faulty statements to be repaired.
to compute this list minthint can leverage any existing fault localization approach.
in our current implementation we use the ochiai approach as implemented in the zoltar tool which performs spectra based fault localization.
for our example the localization tool computes the following ranked list of suspicious statements and so on.
in its subsequent steps minthint runs its hint generation algorithm on each of the first few statements in the fault localization list independently .
in the following discussion we use line 70to illustrate the remaining steps of minthint .267program program faultlocalization derivation ofstate transformers statetransformer t est suite ranking of expressions synthesis ofrepair hints rankedexpressionsrepairhints developersminthintfigure high level view of the minthint approach.
table an example state transformer and values of some expressions over the input states.
input state output state values of expressions over input state s i branch s s s s endstr endstr a false false false false n false false false false n true false false true false true false false v true false false true step derivation of state transformers.
this step infers a specification of what would be the correct computation at line .
to do so in the absence of an actual specification minthint uses the test suite provided for the program to infer an operational specification for the statement in the form of a state transformer.
informally thisstate transformer is a function that given an input state i.e.
valuation to variables at the potentially faulty statement produces an output state that would make every test in the test suite pass including the failing ones.
for passing tests state transformers can be easily computed by simply observing input and output states during the execution of the tests.
for failing tests as we discuss in detail in section .
minthint computes state transformers using dynamic symbolic execution and constraint solving .
let us illustrate this step using the statement at line .
because the statement is a conditional statement minthint uses a fresh boolean variable say branch to represent the outcome of the branch predicate.
that is the statement is transformed into an assignment branch s endstr in which the fault is on the righthand side rhs expression and the branch predicate becomes the variable branch .
table shows some entries in the state transformer of the newly created assignment statement the string array sand index expression iin the input state and the lefthand side lhs variable branch 0in the output state.
the values of all variables except branch 0remain unchanged between a pair of input output states and hence are not shown again.
the value of branch 0in the first row is obtained from a passing test by concrete execution whereas the remaining values are obtained from failing tests using symbolic execution.
these are the values that branch 0is expected to assume in the repaired version for the respective input states.
step ranking of expressions.
the goal of this step is to identify syntactic building blocks i.e.
expressions for constructing an rhs expression compliant with the computed state transformer.
to do so minthint searches the solution space called the repair space for expressions whose values over the input state oftable a partial list of expressions ranked by the likelihood of occurrence in the repaired rhs.
rank expression likelihood 1s endstr .
2s endstr .
.
.
.
7s !
endstr .
.
.
.
s endstr .
.
.
.
s endstr .
.
.
the state transformer are statistically correlated with the corresponding output values produced by the state transformer.
more precisely minthint interprets correlation coefficients which represent the numerical measure of the strength of a statistical correlation as thelikelihood of the expression to occur in the repaired rhs.
for our example minthint would compute correlations between the values of the candidate expressions and the expected value of branch 0at line70.
table gives the values over the input states for two expressions from the repair space and for the faulty rhs itself.
endstr is the null character indicating end of string.
as the table shows the values of s endstr are highly correlated with the expected values of branch but the same is not true for the other expressions.
table shows some expressions in the repair space ranked by decreasing value of likelihood.
step synthesis of repair hints.
after producing a ranked list of expressions minthint analyzes this list to synthesize an actionable list of repair hints.
minthint generates two types of hints simple and compound.
a simple hint is a single program transformation whereas a compound hint is a set of program transformations.
for our example the hints synthesized by minthint for some of the statements identified by the fault localization tool are given in table .
note that minthint may generate more than one hint for the same statement e.g.
for statement 70in table .
we now explain howminthint generates such hints.
forsimple hints minthint iteratively selects expressions from the repair space of each statement individually such that their likelihood values are above a given threshold and the statistical correlation among themselves is low.
that is they form a set of expressions such that any one expression in the set is likely to appear in the repaired rhs.
in our example minthint would select s !
endstr ands endstr .
we discuss the algorithm for selection of expressions in detail in section .
.268table repair hints synthesized by minthint .
rank statement hint score replace s endstr withs endstr replace s endstr withs endstr insert s endstr andremove s endstr retain the statement retain the statement retain the statement insert s !
endstr after selecting these expressions minthint pattern matches each of the selected expressions with the faulty rhs.
based on the edit distance between an expression and the subexpressions in the faulty rhs minthint determines the nature of the hint to be generated for the expression.
if the edit distance is less than or equal to a threshold chosen heuristically 2in our current formulation minthint suggests the replacement of the matching expression in the faulty rhs.
otherwise if the edit distance is greater than the threshold it suggests an insertion.
expression s endstr for example is at edit distance 2from the faulty rhs s expression s endstr sominthint synthesizes a replace hint for the rhs position 2in table .
the edit distance for s !
endstr conversely is greater than and minthint synthesizes an insert hint for this expression position 7in table .
if the edit distance of an expression selected through likelihood value is zero that is it already occurs as a subexpression in the faulty rhs minthint deems the rhs s subexpression as unlikely to be faulty and generates a retain hint for it.
in our example this happens for lines and positions and respectively .
in fact there is no way to repair the fault through simple modifications of these statements.
thus retain hints can help developers localize a fault by eliminating some spurious statements i.e.
false positives returned by the fault localization tool.
finally minthint generates remove hints for subexpressions of the faulty rhs that do not have retain hints or hints suggesting their replacement.
in our example as discussed above a replace hint was synthesized for s endstr and hence no remove hint is generated for it.
minthint ranks hints based on their score .
intuitively the score indicates the confidence in the applicability of the hint and is derived from the likelihood values of the expressions involved.
in the case of a replace hint the score is the maximum of the likelihood of the expression being used for replacement and one minus the likelihood of the expression being replaced.
for the replace hint at position 2in table for instance the score is max where 0is the likelihood value of the faulty rhs that is being replaced see table .
for insert and retain hints the score is the likelihood of the expression being inserted or retained e.g.
62for the insert hint at position 7in table .
for a remove hint the score is one minus the likelihood of the expression being removed.
whereas simple hints can address faults that can be repaired through a single syntactic transformation compound hints can help repair more complex faults faults that require either more than one program transformation to be repaired or more refined pattern matching.
further if the repair space contains only building blocks of the repaired rhs but not the repaired rhs itself compound hints obtained by algorithmically combining these building blocks can bring the repair hints closer to the actual repair.
minthint synthesizes compound hints by first computing sets of expressions such that within each set the likelihood values of the expressions are above a threshold and all expressions in the re algorithm algorithm minthint input programp test suitet the number of faulty statements k the bound on the size of expressions in the repair space m output ranked list of repair hints for the faulty statements 1begin 2sf localize faults p t k localize faults 3hints initialize the set of hints foreachf2sfdo derive the state transformer letfbe of the form x e 6f st trans p f t letfbe represented as an array n n enumerate expressions in repair space 8s subexps e 9v vars in scope p f e enum exps g v m generate the data 10d x x n x foreache02s synthesize hints 12hints hints mintsimplehints f d s e 13hints hints mintcompoundhints f d s e end return sort hints 16end pair space that are likely to appear in the repaired rhs together are included in the same set.
this computation uses a variant of correlation coefficients called partial correlation coefficients and a more refined pattern matching.
we defer the detailed discussion of these steps until sections .
and .
.
in our example minthint would compute two such sets s endstr and s endstr .
the selection criterion used here successfully identifies the required expression s endstr .
although in this case these sets are singletons the sets would generally contain more than one expression e.g.
see task in section .
.
after computing a set of expressions that may occur together in a repair minthint synthesizes a compound hint using the edit distance between each expression in the set and the faulty rhs.
for the first set in our example s endstr minthint generates the replace hint at position 1in table .
for the second set s endstr it generates the hint at position 3in table which has two constituent hints an insert hint for the expression in the set and a remove hint.
minthint adds the remove hint because in this compound hint there is no constituent hint which suggests retention or replacement of the faulty rhs.
the score of a compound hint is the maximum of the scores of the constituent hints.
at this point developers can manually apply the hints produced byminthint by modifying the potential faulty statement according to such hints.
for example in the case of a replace hint developers should replace a subexpression with a suggested one.
for a remove hint conversely developers should remove the subexpression in the hint.
developers would also have to suitably remove the operator s around the subexpression or guess another expression to fill the hole so as to obtain a well formed resulting expression.
finally for an insert hint developers should combine the subexpression in the hint with the existing expression by selecting an appropriate operator and a place for insertion.
.
algorithm algorithm shows the minthint algorithm.
as we discussed in the previous section the inputs to the algorithm are a program p and a test suite tsuch that the program fails on at least one of the tests int.minthint also takes a threshold kon the number of faulty statements to be considered for repair and a bound mon the size of the expressions in the repair space.269the first step of minthint line is to use the test suite to perform fault localization as indicated by the function localize faults which produces a list sfof up tokstatements ranked by their likelihood of being faulty.
all statements in sfare then processed in a loop lines .
function st trans at line computes the state transformer for a faulty statement f. setssande computed at lines and contain the subexpressions of the faulty rhs and the extra expressions that should be considered when searching for repairs.
the function dmaps expressions from the repair space and the lhs variable to their values according to the state transformer similar to the column values in table .
two separate algorithms mintsimplehints andmintcompoundhints are used for synthesizing simple and compound hints.
finally the hints across all statements are sorted by their scores line .
in the following discussion for simplicity we consider statement fto be of the form x e. in step 2in section we discussed a transformation of the conditional to the form above.
minthint can also handle cases in which the potentially faulty statement is a loop header of the form for init cond upd where initinitializes the loop counter s cond is the loop termination condition and upd is the update of the loop counter s .
in these cases the fault could be in any of these three components so minthint spawns three different tasks for init cond and upd.minthint treats an assignment with a ternary rhs expression as a conditional statement in which the fault is in the branch predicate or in one of the assignments in the branches.
minthint can handle other constructs such as switch or return statements in analogous ways.
.
from tests to likelihood of expressions the first part of the minthint algorithm is based on symbolic and statistical analysis and is performed in several phases.
we discuss each of these phases separately.
.
.
fault localization function localize faults leverages an existing fault localization technique to compute a set sfof potentially faulty statements.
any fault localization technique that requires only the program pand a test suitetcan be used here e.g.
.
analogously to existing repair approaches e.g.
minthint assumes that faults can be repaired by changing a single statement.
therefore minthint synthesizes repair hints for each statement finsfindependently.
.
.
derivation of state transformers for each potentially faulty statement f function st trans derives astate transformer fthat when substituted for f makes the program produce the correct output for each test in t.fis a function from program states to program states where a program state is a mapping from the variables in scope at the faulty statement to appropriately typed values.
more formally in algorithm fis an array of pairs of input output states f n n line .
notationally an unprimed state is an input state at f and a primed state is the corresponding output state.
functionfis defined for states that can be witnessed at f given the inputs in t. tests intthat do not execute fare ignored when computing state transformers.
for each passing test traversing f minthint runs the program and collects the input output states at f. conversely for failing tests that traverse f minthint makes the lhs variable xsymbolic uses a symbolic execution algorithm with constraint solving to obtain values of xthat makes the program produce the correct output and reruns the program concretely using the so computed values for x instead of the original values of the rhs .
the input output states at fin this concrete execution give the mapping ffor the failing test.minthint sets a timeout for symbolic execution of each failing test.
symbolic execution may fail to obtain values for xthat result in the correct output either because it times out or because of constraint unsatisfiability.
if the symbolic execution times out on every failing test off minthint discards the statement and does not generate any hints for it.
if the constraint obtained by making xsymbolic is unsatisfiable for every failing test of f minthint generates a retain the statement hint.
intuitively since the program fails irrespective off as evidenced by unsatisfiability of the contraints fmay not be the faulty statement.
in its subsequent phases minthint treats the state transformer f for a potentially faulty statement fas an operational specification for repair thus eliminating the need to have a formal specification.
.
.
ranking of expressions using the state transformer f minthint ranks expressions in the repair space of faccording to their likelihood of occurring on the rhs of the repaired version of f. the repair space can be obtained in several ways such as by enumerating expressions over variables in scope or mining expressions that occur elsewhere in the program similar to what is done in .
presently minthint uses the former approach.
more precisely function vars in scope in algorithm computes the set vof variables in scope at f. then functionenum exps enumerates the expressions of size up to m a userdefined threshold over v. letebe the set of these expressions.
minthint also includes the set of subexpressions of the rhs expressione includingeitself in the repair space.
it does so because it evaluates whether they are likely to be faulty or not independent of the fault localization results.
this set which we call s is computed by function subexps line .
the repair space is thus e s. we recall that a program state maps variables to values.
this mapping can be extended naturally to expressions.
if e e0op e00 then e jopk e0 e00 .
letd x x n x be the values of the lhs variable xover the output states defined by state transformer f line .
similarly for an expression e0in the repair space let d e0 be the values of the expressione0over the input states defined by f line .
given the data d x andd e0 minthint s goal is to find whether xande0are related with each other that is whether a change of value in one is accompanied by a change of value in the other.
becaused x contains the expected correct rather than current erroneous values of xfor the failing tests the faulty rhs and its faulty subexpressions should notbe highly related with x. therefore the expressions that are highly related with xwill be treated as building blocks for the repair.
of course just because the fault localization tool marks a statement as potentially faulty it does not mean that the statement is actually faulty.
the statistical analysis performed by minthint isdiscriminative enough so that for a spuriously marked statement i.e.
a false positive the existing rhs expressioneitself may appear as highly related to x. statistical correlation.
in statistics the problem of whether two statistical variables are related with each other is solved by statistical correlation analysis and a correlation coefficient gives a numerical measure of the strength of the correlation between two variables .
in our context a statistical variable is either the lhs variablexor an expression e0.
the absolute value of a correlation coefficient ranges over .
a correlation coefficient value close to 0indicates that the variables are statistically uncorrelated whereas values close to 1indicate strong correlation.
there are a number of coefficients that are used for identifying different types of correlations between variables e.g.
linear or monotonic correlations .
in its current form minthint uses two coefficients the spearman coefficient and the spearman partial correlation coefficient .
the former can be applied to any data domain270algorithm algorithm mintsimplehints input the faulty statement f x e a mappingdfrom expressions to data the set sof subexpressions of the faulty rhs the set eof enumerated expressions output a set of simple hints 1begin 2r s e sh l while truedo select the most likely expression 4e0 argmaxe002rlikelihood e00 r rnfe0g exit loop if likelihood below threshold iflikelihood e0 then break ensure that e is not subsumed by l ifp likelihood e0 l then 7l l fe0g synthesize a simple hint using e e00 dist minedit e0 s 9sh sh genhint e0 e00 dist end end remove hints for unlikely expressions foreache02sfor which there is no retain replace hint do 13sh sh f line f removee0 likelihood e0 g end returnsh 16end for which there is a ranking function rthat can map the values in the data domain to a totally ordered set.
the latter is a variation of the spearman coefficient to compute the strength of the correlation between a pair of variables by eliminating the effect of a controlling set i.e.
a subset of the other variables .
the complexity of computing the spearman coefficient between datasets of size nis o nlogn .
the complexity of computing the spearman partial coefficient is o n3 fornlarger thanm wheremis the size of the controlling set.
likelihood and ranking of expressions.
theminthint algorithm is based on the hypothesis that an expression e0is likely to occur on the rhs in the repaired version of fiff it is highly correlated withxon the dataset obtained from the state transformer which gives the expected correct values of xeven for the failing tests.
thelikelihood of an expression e0to occur in the repaired rhs denoted by likelihood e0 is the absolute value of the spearman coefficient between e0andxover the datasets d e0 andd x obtained at lines and .
given a set lof expressions the partial likelihood ofe0to occur in the repaired rhs along with the expressions inl denoted by p likelihood e0 l is the absolute value of the spearman partial correlation coefficient of d e0 andd x with fd e00 je002lgas the data of the controlling set l. .
from likelihood of expressions to hints in this second part we discuss how minthint utilizes the likelihood values of expressions computed in the first part of the algorithm to synthesize hints.
intuitively minthint synthesizes hints by performing syntactic pattern matching between the expressions that are likely to occur in the repaired rhs and the subexpressions of the faulty rhs using different patterns to address different types of possible faults.
formally a repair hinthfor a statement fis a triple t s comprising the line number of statement f a textual hint t and the hint s score s. the keywords in the textual hint shown in bold font have their usual english meaning.
.
.
simple hints mintsimplehints see algorithm synthesizes a set shof simple hints given a faulty statement f a datasetdobtained from f s state transformer subexpressions sof the faulty rhs and extra expressionsethat constitute repair candidates.
the algorithm alsomakes use of two thresholds and to select expressions by likelihood and check partial likelihood of a candidate expression given the already selected expressions respectively.
mintsimplehints initializes the repair space rtos e and the set of simple hints sh and the set of likely expression lto the empty set line .
it then executes the loop starting at line until the likelihood of expressions drops below the threshold line .
within this loop an expression e02rwith the highest likelihood is selected and removed from r line .
if the partial likelihood of e0withlas the controlling set is above the threshold line it is added tol.
this check ensures that e0has sufficient statistical correlation with x the lhs after taking out the effect of l i.e.
e0 is not subsumed by l .
in the example in section once s !
endstr is added tol all expressions up to s endstr ranked 23rd have partial correlation below the threshold .
at this point mintsimplehints generates a simple hint for e0.
to do so it first invokes function minedit which identifies the expressione00fromswith minimal edit distance dist frome0 line .
then the algorithm invokes function genhint which synthesizes a simple hint based on the value of dist line .
ifdist is below a given threshold but dist the algorithm generates hint replacee00bye0 .
conversely if dist is above such threshold it generates hint inserte0 .
for the former the score of the hint is set to the maximum between the likelihood of e0and the unlikelihood ofe00 i.e.
likelihood e00 .
for the latter the score is simply the likelihood of e0.
in its current formulation minthint uses a threshold of 2over the edit distance.
in our empirical evaluation it captures errors resulting from incorrect operator constant variable array index and so on.
increasing the threshold may generate spurious replace hints whereas reducing it would produce two separate hints insert and remove for e0ande00respectively.
ifdist i.e.
e0already belongs to s the algorithm generates hint retaine0 and assigns to the hint a score equal to likelihood e0 .
a special case of this is when e0is exactly the same as the rhs expression for which the algorithm generates a retain the statement hint.
finally for the expressions that appear in the faulty rhs but do not have an exact or close match with dist less than the threshold in setl the algorithm generates remove hints in the loop at line where function line returns the line number of a statement.
the score of a removee0 hint is likelihood e0 .
.
.
compound hints function mintcompoundhints called in algorithm at line computes compound hints using the same inputs as mintsimplehints .
due to space constraints we do not typeset mintcompoundhints and simply explain the key similarities and differences between algorithm and mintcompoundhints .
similar to algorithm it iteratively computes the set of likely expressions.
however it uses p likelihood e00 l in place of likelihood e00 at line and the branch predicate at line is replaced with true .
the value of partial likelihood gives the measure of the likelihood of e00to appear in the repaired rhs along with the expressions in l. consequently the expressions added to set lare all those expressions that can occur together in the repaired rhs.
in contrast the selection of an expression at line in algorithm is based on its individual likelihood.
in general mintcompoundhints can generate more than one set of likely expressions.
more specifically if multiple expressions have the highest partial correlation coefficient line in the first iteration of the loop the algorithm would partition them into three sets based on their minimum edit distance from the faulty rhs and its subexpressions equal to zero less than equal to and more than .
the algorithm initializes three sets of likely expressions by selecting one expression from each of the partitions above if not empty .
it then proceeds independently to select other expres 271table description of tasks.
program loc tasks print tokens2 replace tcas sions to add to each of them.
conversely when generating simple hints for multiple expressions with the highest correlation coefficient mintsimplehints selects one expression at random without partitioning the expressions by edit distance.
for example in section the expression s endstr is the only expression among the seven expressions with the highest likelihood that is at edit distance less than equal to .
for each expression in set l mintcompoundhints generates a hint with the pattern matching logic used at line in algorithm .
we call each of these hints a constituent hint of the compound hint.
we say that a pair of constituent hints of a compound hint conflict if they refer to either the same or overlapping subexpressions of the faulty rhs.
two subexpressions of the faulty rhs overlap if their subtrees in the ast of the faulty rhs have some common node s which can be checked by performing a simple walk over the ast.
in order to ensure that no conflicting hints are generated minthint removes a subexpression and all the expressions that overlap with it from the repair space as soon as the subexpression is added to setl.
simple hints are independent of each other and hence are permitted to conflict.
finally analogous to the loop at line in algorithm mintcompoundhints generates remove hints for the subexpressions of the faulty rhs which do not have an exact or close match in l. there could be multiple simple hints that suggest retention of different subexpressions of the rhs.
in these cases these hints are clustered into a single compound hint.
the score of a compound hint is the maximum of the scores of the constituent hints.
.
ev aluation to assess the effectiveness of our approach we implemented the minthint algorithm for c programs and performed an empirical evaluation.
our implementation leverages zoltar for fault localization klee for dynamic symbolic execution with constraint solving and matlab1for statistical analysis.
our evaluation consists of two main parts a user study that assesses whether minthint can improve developers productivity and an empirical study in which we apply minthint to several faulty versions of three unix utilities to further assess the effectiveness of the approach.
specifically we investigated the following questions rq1 usefulness of hints can minthint produce useful hints thus enabling developers to repair programs more effectively?
rq2 robustness how does minthint perform when the repair space is incomplete i.e.
does not contain the repaired version of the faulty expression and is supplied imprecise data?
rq3 performance and scalability how well does minthint scale to large programs state transformers and repair spaces?
.
user study experimental setup.
we performed fault localization on a set of programs from the siemens suite which consists of programs with multiple faulty versions.
table lists the programs and the number of faulty versions that were selected as tasks.
the tasks represent a diverse collection of faults see table .
in the user study each user was required to work on two independent tasks.
to keep each task manageable within 2h we presented to the user only the top5statements identified by zoltar as potentially faulty.
for each of chosen tasks the actual faulty statement belonged to this list.
for each program and candidate faulty statement minthint obtained the state transformers for the failing tests through symbolic execution with a timeout of 5m per test.
for one of the candidate tasks replace v18 symbolic execution of many failing tests timed out.
in comparison there were many more passing tests potentially making data from failing tests statistically insignificant.
to avoid this only half of the passing tests were used for deriving the state transformer.
of the 10users who participated in our study 8were working professionals and 2were graduate students with prior industry experience none affiliated with our research group.
of these stated that they had moderate to high expertise with c programming debugging and all 10had at least 1year of experience with c programming.
for each task the input output specifications of methods together with the meaning of variables and named constants were presented as comments in the source code.
in addition each user was provided with a test suite of 10passing tests and was given 15m to study the program before starting to repair it.
we performed the user study in two phases.
in the control phase the users were given the fault localization information and the test suite.
in the experimental phase they were also given the repair hints.
each user worked on a single task per phase and was given 2h to complete that task.
we considered a task to be complete if the repaired program passed all the tests.
the users chose the programs for the control phase by drawing lots.
we mapped each task in the control phase to a task in the experimental phase to make sure that a user would not work on the same task or on another faulty version of the same program in both phases.
rq1 usefulness of hints.
table summarizes the results of the user study.
in the control phase i.e.
without hints the users could localize the fault in 10cases but only managed to repair the programs in 6cases.
on the contrary in the experimental phase i.e.
with hints the users were able to perform localization and repair in all 10cases.
further the average time taken to repair a fault was91m in the control phase except for the 4timeouts whereas it was 29m in the experimental phase.
the average speedup obtained with the use of hints for the 6tasks that were completed in both phases was 8x.
we asked the users to rate the difficulty level of localization and repair for their tasks as easy moderate or difficult.
the ratings for the same set of tasks differed across the two phases.
notably with hints 4more tasks were rated by the users as easy.
these qualitative ratings corroborate the quantitative results presented above.
the users uniformly reported that the hints were useful and were asked to indicate the most useful hint.
in table we report for each task the rank of the most useful hint as identified by the user over the entire list of hints presented to the user for that task.
as the table shows the most useful hints were all in top 10except for one case.
the last column in table shows the number of statements for which only a retain the statement hint was generated.
these are the statements that are classified by minthint as unlikely to be faulty.
across the 10tasks and 50statements in the fault localization lists 40statements are likely to be false positives as only 10are true positives i.e.
definitely faulty .
out of these minthint filters out11statements over .
this contributes greatly to ease of localization.
as further evidence that there is no obvious way to rectify these 11statements we note that no user in the study was able to produce a repair for any of them.
for6tasks tasks and the most useful hint had the precise information required to repair the fault.
for task the faulty rhs was of the form exp1 exp2 and the compound hint suggested that both exp1 andexp2 be retained but it did not report the same for272table description of faults in the user study and of useful hints identified by the users the tasks that could not be finished in the control phase without hints are underlined.
all the tasks were completed in the experimental phase with hints .
task program version nature of fault type of the most useful hint rank of the most total hints stmts with only useful hint retain the stmt hints print tokens2 v6 incorrect array index remove replace v7 superfluous expression compound remove others print tokens2 v7 superfluous expression compound remove others replace v18 missing expression compound insert others replace v23 incorrect array index replace tcas v28 incorrect operator replace replace v8 missing expression compound retain others tcas v2 incorrect constant replace tcas v1 incorrect operator replace tcas v12 incorrect operator compound retain others table results of the user study.
control phase experimental phase without hints with hints quantitative analysis successful localization successful repair avg.
time to repair 91m 4timeouts 29m no timeouts avg.
speedup excl.
timeouts na 8x qualitative analysis ratings given by the users difficulty of localizationeasy easy moderate moderate difficult difficult difficulty of repaireasy easy moderate moderate difficult difficult table count of tasks in the user study wrt incompleteness of the repair space and noise in state transformers.
yes no incompleteness of repair space noise in state transformers obtained from tests max.
the entire rhs.
the user therefore suspected that the operator was incorrect and correctly replaced it with .
for task the hint suggested only removal of the incorrect expression so the user had to produce a substitute expression.
in task the hint did not suggest the expression to be inserted.
in fact the user mentioned that the hints helped mainly in localizing the fault.
this is possible because minthint eliminates 2other statements in this case see the last column for task in table .
in the case of task the replace hint did not suggest the required named constant to be used.
nevertheless the user observed that after substituting the new expression suggested in the hint many failing tests started passing and subsequently inferred the right constant manually.
of these tasks and were notcompleted in the control phase.
the number of total hints per task given in table depends on several factors.
first the thresholds on correlation coefficients determine how many expressions end up in the set of likely expressions and thus also affect the number of hints.
across all tasks the thresholds on correlation coefficient and partial correlation coefficient for generation of simple hints were 4and0 respectively.
for compound hints the threshold was .
second if the symbolic execution times out on all failing tests for a statement the hint generation algorithm is not run for that statement see section .
.
.
though the study involves a relatively small number of users it provides substantial evidence that repair hints are useful in obtaining repairs and also in reducing the time taken for repair.table performance and scalability chart tasks from the user study belong to all cells except cell at position .
tasks related to unix utilities section .
belong to the shaded cells.
exprs in repair space columns of the data matrix size of state transformerupto 5k upto 10k 10k upto 1k 1m 1m 1m rows of the data matrix upto 10k 1m 5m 5m 10k 1m 5m 1h rq2 robustness.
in practice it is difficult to estimate the syntactic space to search for a complete repair.
in our experiments for each statement apart from the subexpressions of the potentially faulty expression expressions of size up to over the variables in scope at the statement were added to the repair space.
the size of an expression is the number of nodes in its abstract syntax tree ast .
for expressions involving arrays an occurrence of an array expression is counted as size 1and the index expressions themselves can go up to size .
we call a repair space complete when the repaired version of the expression belongs to it.
for example in task the repaired expression exp1 exp2 was not in the repair space.
minthint derives state transformers for failing tests by symbolic execution.
in some cases the derived constraints may have multiple satisfying assignments but not all of them can be observed in the execution of the repaired version of the program.
the constraint solver may pick any one of them.
for passing tests the state transformer is obtained by concrete execution.
even though the test passes the value generated by the faulty expression may not be observed in the repaired version.
these situations make the resulting data which is used as a specification imperfect noisy and may in general invalidate the applicability of a repair.
table gives the count of tasks which had noise in the state transformers and where the repair space was incomplete.
this information is provided only for the actual faulty statement.
to estimate the amount of noise in the data we first obtain the noise free state transformer of the known repaired version independently by concrete execution over the test suite.
an entry in the state transformer obtained over the faulty version is classified as noisy if it does not belong to the noise free state transformer.
there were 7tasks with noisy data with the maximum of noise in one of them and there were 5tasks where the actual repaired expression did not belong to the repair space.
nevertheless the successful completion of the tasks in the user study indicates that useful hints could be synthesized even in these challenging cases.
the key reasons for this are the use of statistical correlation which is robust in presence of noise and the ability of minthint to synthesize compound hints from building blocks.
in particular the repair spaces were incom 273table description of faults and hints for unix utilities.
task version type of rank of total stmts with fault nature of fault useful useful hints retain stmt hint hint hint only tasks flex 1f2 f2 incorrect constant replace 2f2 f14 incorrect operator replace 3f4 f15 incorrect operator replace tasks grep 4g3 f10 incorrect operator compound 5g4 f10 incorrect operator tasks sed 6s2 f1 incorrect operator replace 7s3 f4 incorrect constant 8s3 f6 incorrect constant replace 9s5 f1 incorrect operator replace 10s6 f1 incorrect operators compound 11s6 f2 symbolic execution times out with 15m threshold plete for tasks and and as table shows in each of these cases the most useful hint was a compound hint.
rq3 performance and scalability.
the complexity of statistical correlation computation see section .
.
dominates the cost of hint generation.
it works on a two dimentional matrix where the number of rows is equal to the size of the state transformer the number of input output pairs and the number of columns is equal to the number of expressions in the repair space.
table gives the performance and scalability chart summarizing all runs of the hint generation algorithm for all tasks and faulty statements in the user study.
despite the large datasets the hint generation algorithm scales well.
zoltar took slightly over 2m on an average for fault localization.
except for a few statements klee ran to completion on all the failing tests within 5m the timeout set by us .
the timings are measured on a desktop with intel i5 cpu .
ghz and 4gb ram.
.
hint generation for unix utilities experimental setup.
we applied minthint on three commonly used unix utility programs flex grep and sed obtained from the sir repository .
these are reasonably large programs ranging from 10k to14k lines of code.
we performed fault localization on the different faulty versions using zoltar.
we selected those versions for which zoltar identified the actual faulty statement within top statements in its list.
table lists the versions and fault ids of the programs that were selected as tasks.
the top 15statements identified by zoltar as potentially faulty were considered for repair.
for each version and candidate faulty statement the state transformers were obtained for failing tests through symbolic execution with a timeout of 15m with the exception of tasks 7and8for which a timeout of 5m was sufficient.
in task symbolic execution timed out for all failing tests and hence it was not analyzed further.
forgrep we observed that the input files supplied along with the program were too large 10k lines due to which the symbolic execution would result in timeout.
consequently we isolated the failure inducing part of the input files.
for each failing test we split the input file into segments comprising 500lines each.
we then ran the test concretely with each segment as the input file and compared its result with the result of the known correct version of grep on the same segment and the same regular expression .
we identified the segment on which the two outputs differed.
in all the cases there was only one such segment.
the original failing test was replaced with the segment and corresponding desired output.
rq1 usefulness of hints.
for each of the tasks table shows the nature of the fault and the type of the most useful hint.for all tasks in flexand tasks 9insed a replace hint synthesized by minthint when applied immediatedly lead to success on both passing and failing tests.
for task 4ingrep minthint synthesized a compound hint for the faulty statement which suggested removing several expressions from the rhs and retaining a single non faulty expression.
we manually removed the suggested expressions and operators around them retaining a single well formed expression.
with this change all the tests passed successfully.
task 10insedconsists of two faults in the same statement.
a compound hint suggested removal of two subexpressions and retention of the non faulty subexpression.
applying this hint however lead to only a partial repair since minthint did not generate the expressions that should be used for replacing the faulty ones.
with this change all the previously passing tests continued to pass and several previously failing tests too started to pass.
for task the symbolic execution timed out on all failing tests for the faulty statement.
thus minthint could not produce any hints for it.
for the other statements identified by zoltar as potentially faulty minthint suggests to retain each of them as they are.
even though we did not obtain a repair for the fault in this task the retain hints help filter out the non faulty statements.
in task minthint did not produce any useful hint for the faulty statement due to excessive noise as discussed below .
interestingly minthint generated only retain the statement hints for many statements identified by zoltar effectively filtering them out as non faulty.
across the 10tasks and 150statements in the fault localization lists 140statments are likely to be false positives.
out of these 62statements are filtered out by minthint .
we studied the faulty statements which had only the retain hints but could not identify a way to change them to repair the faults.
this study gives strong evidence that minthint can be applied to large programs with not so accurate fault localization lists.
rq2 robustness.
repair spaces were constructed in a manner similar to the user study and with the same bound on expression sizes.
the repair space searched by minthint contained the repaired version of the faulty rhs in all but two cases.
the data obtained for the faulty statement from the failing tests contained noise in cases.
our approach for estimating the amount of noise is explained in section .
.
in one case task the noise was and minthint could not produce any useful hint.
note that we could not measure noise for one of the tasks task as the symbolic execution did not generate any data for the faulty statement.
rq3 performance and scalability.
in table the shaded cells denote the time taken by minthint for statistical correlation analysis and hint generation for the tasks from unix utilities.
no task took more than 5m for these steps.
in particular correlation analysis and hint generation for tasks from flexandgrep took less than10s.
fault localization finished within 1m on an average for sedtasks 2m for grep tasks and 3m for flextasks.
although symbolic execution finished within 5m for tasks it required at least 15m for the remaining tasks.
even with 15m threshold it timed out for all failing tests for the actual faulty statement in task5and for all potentially faulty statements in task .
.
limitations and threats to validity one of the main limitations of our approach is its reliance on symbolic execution for deriving state transformers which is a complex and expensive technique.
however these techniques are becoming increasingly efficient and many of their practical limitations are being addressed e.g.
.
moreover as we discuss in section we plan to investigate alternative less expensive ways to build state transformers.
further it is technically difficult to obtain only those values which can be observed in the repaired program through symbolic execution.
this makes the state transformers noisy.
due to the274statistical reasoning applied in minthint it produced useful hints even in presence of noise in many cases.
the measurement errors leading to noisy data are common in other domains as well and a large body of work called outlier detection exists to deal with them see for a survey .
we plan to investigate applications of these techniques to further improve tolerance of minthint to noise.
like every empirical evaluation ours too has potential threats to validity.
threats to internal validity for the user study include selection bias where the users working on the same task in control and experimental phases may have different expertise and testing bias where activities before the study may affect the outcome.
only two users had indicated low expertise with c programming to prevent selection bias we paired them in such a way that their tasks were interchanged in the two phases.
since the control phase was conducted before the experimental phase for all users it is likely that the users became better accustomed to the debugging task.
we mitigated this possibility by ensuring that no user worked on the same task or two faults of the same program in the two phases.
further we only made a presentation about the meaning of repair hints and did not provide any hands on tutorial.
there may be faults in our implementation that might have affected our results.
to address this threat we manually checked many of our results and did not encounter any error.
threats to external validity arise because our results may not generalize to other group of developers in the case of user study and program repair tasks.
in the user study we ensured that the users did not have any prior experience with the programs used as repair tasks.
while this ensures a level playing field it leaves out users who might have better familiarity with the programs.
the tasks in the user study were nothand picked.
we applied a well defined criterion for their selection.
the programs in siemens suite were sorted by the rank of the actual faulty statement in the respective localization lists.
within each rank the program fault names were then sorted in the lexicographic order and finally the first two tasks at each fault localization rank were selected.
similarly the tasks from the unix utilities consist of all tasks from the sir repository with only a single faulty statement such that the statement occurs within top 15statements returned by a third party fault localization tool zoltar.
a few tasks could not be included because of limitations of the symbolic execution tool.
the performance of minthint is a function of the test suite also.
it will take a much larger evaluation to ascertain how the quality of tests affects the quality of repair hints.
it is however important to note that the tasks and test suites we used were also used in numerous previous papers in the area e.g.
.
nevertheless the number of tasks considered is small so our findings may not generalize to other programs or faults.
.
related work early work by arcuri later extended by le goues and colleagues proposes the use of genetic programming to automatically generate repairs that make failing test cases pass and do not break any passing test case.
debroy and wong propose a similar approach but based on the use of mutation .
other approaches rely on the use of program specifications for repair.
pei and colleagues propose an approach for finding program repairs given program contracts .
jobstmann griesmayer and bloem use a game theoretical approach for identifying repairs that satisfy a linear temporal logic specification .
gopinath malik and khurshid s approach builds a sat formula that encodes the constraints imposed by the specification on the program behavior and if the formula is satisfiable derives a repair from the sat solution .
konighofer and bloem present a template based approach that given a faulty program and a specification performs a symbolic analysis of program inputs and template parameters togenerate a repair .
he and gupta propose a technique that computes the weakest preconditions along a failing trace and compares the computed conditions with functions pre and post conditions to find and correct faults .
logozzo and ball s approach generates verified program repairs from failed verification checks of programs that have developer supplied modular specifications .
yet other approaches leverage the existing test suite to infer specifications and generate repairs accordingly.
pachika models a program s behavior for passing and failing test cases and generates a repair based on the differences between these models of correct and incorrect behavior.
in a recent paper nguyen and colleagues propose the semfix approach which combines angelic debugging and program synthesis to automatically identify program repairs.
bugfix shares with our approach the idea of deriving bug fix suggestions rather than actual repairs.
unlike our approach bugfix generates suggestions using a machine learning approach based on knowledge acquired from previous bug repairs.
finally some approaches perform program repair in specific domains such as repairs for data structures web applications security vulnerabilities or concurrency faults .
unlike minthint most of these program repair approaches suffer from one or more of the limitations that we discussed in the introduction.
they require a specification tend to find repairs that are overfitted to a given testsuite or must perform a search over a solution space that is large enough to include the unknown repair and are therefore unlikely to be effective in the case of non trivial repairs.
.
conclusions and future work we presented minthint a novel technique for semi automated program repair.
the key novelty of our approach is that it does not generate complete repairs an elusive goal in many practical cases but rather synthesizes repair hints expressions that are likely to occur in the repaired code.
to do so given only the faulty program and a test suite minthint suitably combines symbolic statistical and syntactic reasoning.
our evaluation of minthint provides initial but strong evidence that our approach is effective and practically useful even in cases that would be particularly challenging for existing program repair techniques.
in the future we will extend our technique so that it can handle the more challenging case of faults involving multiple statements.
also in order to improve minthint s performance we plan to investigate alternative more efficient techniques for building operational specifications and outlier detection mechanisms that can further improving minthint s tolerance to noise.
another interesting direction for future work is the investigation of how repair hints could be used to further automate the program repair process.
for example we envision that hints could be used to inform program synthesis e.g.
or sketching e.g.
.
a final future work direction is the study of the explanatory power of repair hints.
we hypothesize that unlike the fixes computed by fully automated repair techniques repair hints can help developers better understand the nature of faults and corresponding repairs.
it would be interesting to conduct investigations and experiments to assess the usefulness of repair hints in this direction.
.