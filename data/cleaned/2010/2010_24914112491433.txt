enhancing symbolic execution with built in term rewriting and constrained lazy initialization pietro braione university of milano bicocca milano italy braione disco.unimib.itgiovanni denaro university of milano bicocca milano italy denaro disco.unimib.itmauro pezz university of milano bicocca and university of lugano italy switzerland pezze disco.unimib.it abstract symbolic execution su ers from problems when analyzing programs that handle complex data structures as their inputs and take decisions over non linear expressions.
for these programs symbolic execution may incur invalid inputs or unidenti ed infeasible traces and may raise large amounts of false alarms.
some symbolic executors tackle these problems by introducing executable preconditions to exclude invalid inputs and some solvers exploit rewrite rules to address non linear problems.
in this paper we discuss the core limitations of executable preconditions and address these limitations by proposing invariants speci cally designed to harmonize with the lazy initialization algorithm.
we exploit rewrite rules applied within the symbolic executor to address simpli cations of inverse relationships fostered from either program speci c calculations or the logic of the veri cation tasks.
we present a symbolic executor that integrates the two techniques and validate our approach against the veri cation of a relevant set of properties of the tactical separation assisted flight environment.
the empirical data show that the integrated approach can improve the e ectiveness of symbolic execution.
categories and subject descriptors d. .
testing and debugging general terms veri cation keywords software analysis symbolic execution we provide an artifact it pietro.braione to experience with the approach presented in this paper and replicate our results.
the artifact has been successfully evaluated by the esec fse artifact evaluation committee and found to meet expectations.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction symbolic execution is at the core of many modern approaches to software testing and veri cation .
in a nutshell symbolic execution is the process of executing programs using symbols instead of concrete values as input to generalize the computation over the input domains .
the attractiveness of symbolic execution for program analysis is its ability to yield precise though bounded representations of the program state space exploiting ow sensitiveness and reference aliasing to full extent.
symbolic execution addresses ow sensitiveness by tracking the satis ability of the path conditions i.e.
the logical assumptions over the input values that must hold for executing speci c program paths and relies on lazy initialization to systematically account for reference aliasing across the input domain .
both these approaches introduce challenging approximations into the analysis often inducing large amounts of false alarms as we further discuss below.
symbolic executors must be able to compute the satis ability of path conditions to avoid engaging into the analysis of infeasible paths.
to this end symbolic executors use constraint solvers .
with state of art solvers symbolic executors can deal e ciently with path conditions that contain linear integer arithmetics and operations with bitvectors but cannot deal well with expressions that refer to other theories.
for instance although notable research advances in constraint solvers to handle some classes of nonlinear constraints it is still very unlikely to e ciently solve constraints over polynomials of arbitrary degree or trigonometric functions.
giannakopoulou et al.
report a study of using the spf symbolic executor for the analysis of a component of tsafe the tactical separation assisted flight environment which we also use as a benchmark in this paper where spf generates path conditions that are too complex for the constraint solvers to solve .
in fact the conservative over approximation of assuming the nonsolvable path conditions as potentially satis able may drive the symbolic executors into the extensive exploration of massive sets of infeasible traces questioning the general applicability of the technique for practical programs.
to mitigate these problems some modern solvers exploit term rewriting based on equivalences between the mathematical interpretation of terms in di erent reference theories to substitute intractable terms through the formulas and possibly achieve tractable formulas eventually .
in this paper we propose to engineer term rewriting within the symbolic executor before calling the constraint solving services.
we nd this particularly bene cial to suitably identify and sim permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
plify inverse relationships that may depend on either speci c calculations in the analyzed program or the additional logic of the veri cation tasks.
while in principle a constraint solver might be able to exploit these relationships we found that this is not always the case for formulas resulting from multiple subsequent symbolic manipulations.
on the contrary by incrementally matching the relevant relationships as rewrite rules during symbolic execution we can recognize the applicable simpli cations earlier on simpler formulas.
lazy initialization consists of assigning an unknown value to the