see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation staged concu rrent program analysis conf erence paper no vember .
.
sour ce org citations 50reads author s including chao w ang univ ersity of southern calif ornia publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y chao w ang on a ugust .
the user has r equest ed enhanc ement of the do wnlo aded file.stagedconcurrent program analysis nishant sinha chao wang nec labs america princeton nj usa.
nishants chaowang nec labs.com abstract concurrent program verification is challenging because it i nvolves exploring a large number of possible thread interleavings t ogether with complex sequential reasoning.
as a result concurrent program verifiers resort to bi modal reasoning which alternat es betweenreasoning over intra thread sequential semantics and interthread concurrent semantics.
such reasoning often invol ves repeatedintra threadreasoningforexploringeachinterlea ving interthreadreasoning andleadstoinefficiency.
inthispaper w epresent a new two stage analysis which completely separates intra and inter thread reasoning.
the first stage uses sequential pro gram semantics to obtain a precise summary of each thread in terms of the global accesses made by the thread.
the second stage performs inter thread reasoning by composing these thread mo dular summaries using the notion of sequential consistency.
asse rtion violations and other concurrency errors are then checked in this compositionwiththehelpofanoff the shelfsmtsolver.
we have implemented our approach in the fusion framework for checkingconcurrentcprogramsshowsthatavoidingredundantbi modal reasoning makes the analysis more scalable.
categories subject descriptors d. .
model checking formalmethods.
general terms algorithms verification.
keywords thread modularsummarization interferenceabstraction interference skeleton staged analysis sequential consistency axiomatic composition smtsolvers.
.
introduction checking properties of shared memory based concurrent programsstaticallywithmodelcheckingisexpensivebecausei tamounts toexploringlargenumberofinterleavingsoftheconcurren tthreads.
methodsoftenamelioratethiscostbyusingpartialorderte chniques and causal orderings imposed by synchronization pri mitives e.g.
locks.
unfortunately most of the methods wh ether explicit orsymbolic resortt oredundantbi modal reasoning theanalysis alternates betweenreasoning over theintra thread and the inter thread semantics.
for example consider twoconcurrent threads t1andt2asfollows t1 x t x a t b a assert b t2 x permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
fse november santa fe new mexico usa.
copyright acm ... .
.thethreadt1containsanassertion b tocheckthisassertion variousinterleavingsof t1andt2mustbeconsidered inter thread reasoning based on when the statement x int2is executed.
oncethevalue of xisobtained x thestatements t x a t b a int1are composed via intrathreadreasoningtochecktheassertion.
bi modalreasonin gofthis form is inherently wasteful because the analysis engine is f orced to perform reasoning over similar intra thread program reg ions repeatedly.
intra thread or thread modular program summa rization is a possible solution to this problem.
however classical p rogram summarization methods designed for sequential pro grams are not applicable in a concurrent setting because of interf erences onshared locations from concurrent threads.
in this paper we present a stagedconcurrent analysis which avoids redundant bi modal reasoning.
the first stage summa rization consists of a new algorithm to summarize the individua l program threads in the presence of concurrency.
the summary is r epresented in form of an interference skeleton which is a partiallyorderedsetofallglobalreadandwriteaccessesofprogramt hreads.
the second stage performs composition symbolically by enco ding feasiblelinearizations of the above partial order using a sequential consistency sc criterion on the global accesses.
finally we check property violations by using an smt solver whi ch searches fora linearizationthat violates the property.
no te thatbecause the two stages perform either intra or inter thread r easoning we achieve a complete separation between intra and int erthread reasoning and thus avoid costly bi modal alternati on betweenthem.
the key idea behind summarization in the first stage is that of interference abstraction any read access to a shared memory location global read in the program is abstracted by a fresh s ymbolicvariable.
thesefreshvariables linearinthenumber ofreads model arbitraryinterference tothe sharedlocationvia wri tesinthe same or aconcurrent thread.
interference abstraction ine ffect enables thread local summarization while assuring us that t he interferences due to concurrent writes can be taken into account l azily and preciselyinthe subsequent composition stage.
the second stage linearizes the skeleton by linkingthe read accesses with appropriate write accesses in the skeleton.
axiomatic composition ac provides a natural way to do this as oppose d to introducing an explicit scheduler i.e.
we can use the s equential consistency sc axioms specified in first order lo gic to enforce that the linearization corresponds to a feasible co ncurrent program trace.
ac has been employed to check consistency of concurrent data structures under relaxed hardware memory m odels e.g.
.
in contrast we propose to employ ac in the ne w setting of high level static analysis of concurrent progra ms. in this setting it is sufficient to consider only the sc model of exec ution for performing high level static analysis as opposed to mo re relaxedmodels .
thecentralproblemishowtoencodescefficie ntly to obtain a scalable analysis.
to this goal we propose a meth odtopruneredundant sc constraints by analyzing the interference skeleton computed inthe firststage.
ourstagedanalysishandlesarbitraryconcurrentcprogram s e.g.
usingpthread libraries using pointers and arrays with the help of a precise memory representation .
as opposed to most co ncurrent analyses program threads need not be demarcated be forehand ouranalysishandles threadcreationanddestruction natively.
analysisofgeneralrecursiveprogramsevenwithfinitedata isknown to be undecidable.
to analyze arbitrary c programs over infin ite data types we transform the input programs to their structurally bounded versions where loops and recursive functions in the input program are unrolled to a fixed depth.
finite unrolling of this form indirectly finitizes the number of threads and also fixe s the size of heap that the bounded program mayaccess.
asa result the analysis of bounded programs becomes decidable.
wehaveimplementedourapproachinthefusionframework for verification of concurrent c programs.
preliminary eval uation showthatsummarizationandoptimizationsduringcomposit ionare essential for scalable symbolic analysis of concurrent pro grams.
the key contributions of this paper are asfollows a staged analysis algorithm for verifying concurrent programs consisting of stage a precise thread modular summarization of individual threads and stage an optimize d composition step over the summary using sequential consistency axioms followed by checking assertion violations us ingan smtsolver.
a thread modular data flow analysis based on interference abstractiontosummarizestructurally boundedconcurren tprograms inform of aninterference skeleton.
optimized composition of the interference skeleton by systematically pruning redundant sc constraints between the global accesses by staticanalysis of theskeleton.
.
redundant bi modal reasoning thread t1 thread2 t2 ... s1 a0 x a1 a0 z1 a1 a2 a1 z2 a2 ... a99 a98 z99 a99 a100 a99 s2 x a100 s3 x ... s4 x ... a assert x x consider the fragments of concurrent threads t1andt2shown above thevariables a0 a100arelocal andtherest x z1 z99 areshared our goalistochecktheassertion aatline5.t1andt2 may interleave in many possible ways an efficient analysis b ased onsay partialorderreduction willconsiderarepre sentative set of such interleavings and compute the value of xat the assertiona.
analyzingeachinterleavingamountstobi modalreasonin g whichalternates betweenintra andinter threadreasonin g. forexample consider the interleaving s3 s4 s1 s2 a the analy sis first considerst2 settingxto3and5at s3and s4successively intrathreadreasoning andthenswitchesto t1 inter threadreasoning successively computing a0 a100 z1 z99andx intra thread and finally switches back to t2to checkausing the computed value ofx.
this form of bi modal reasoning is redundant since similarintra threadreasoningisrepeatedforeachinterl eavingconsidered.
for example note that a100 a0 irrespective of the interleaving of t1andt2considered.
however to analyze another interleaving say s3 s1 s4 s2 a the values a1 a100 must berecomputed becausea0 0now as opposed to a0 in the previous interleaving.
redundant intra thread reas oning or composition takes itstollonbothexplicit a ndsymbolic analysis techniques often decreasin g theirperformance by an order of magnitude.
although summarizati on techniques are well known for sequential program analysis they cannot be directly employed here because of inter ference onsharedlocations byconcurrent threads the val ue read from a shared location in a thread may not be the same as the pre vious value writtentothe locationinthe same thread.
there exist techniques that ameliorate this problem by collapsinga set of intra thread transitions into a single one e.g.
pa th reduction .
however they can only collapse transition s insidetransactions i.e.
regions withoutanyconcurrent interference.
givenatransactionbetweenlocations l1andl2 pathreductioncollapses all the transitions between l1andl2to a single transition.
unfortunately these techniques are not effective across a rbitrary program regions or transactions.
in the above example assi gnments to shared variables z1 99represent locations where interference may occur which alternate with assignments to vari ables a0 a100.
therefore pathreduction methods cannot collapse the assignments toinfer that a100 a0 .
our method avoids this problem by using the idea of interference abstraction which in turn enables data flow based su mmarization.
first the value of shared variable xread at line 2int1 is abstracted by a fresh symbolic variable say r0.
since the assignments to variables a1 a100are not influenced by any other interferences ourdata flowpropagationsuccessfullycom putesthat a100 r0 .
further our method precisely summarizes all localcontrolanddataflowintermsofglobalaccesses e.g.
assignmenttoz1atline 3int1givesrisetoaglobalaccessevent z1with valueval z1 r0 .
similarly global accesses z2 z99are computed withtheir relativeorder z1 z2 z3... .
lal and reps present address this problem in the setting of context bounded analysis cba of programs with finite dom ain variables extended to c programs in .
in cba a concurrent program is analyzed assuming only a fixed number of conte xt switches occur between threads.
context bounding allows fi xinga set of context switch cs locations and model the interfere nce at thecslocationsonly.
thisisdone by guessing orabstracting the value of the global state at each cs location.
since no interf erence is possible between each pair of cs locations in a thread and t he number of cs locations is finite sequential summarization c an be applied between each cs location pair.
guessing the global s tates however involves unnecessary duplication of the shared state at eachcslocation.
thisisbecauseeachprogramlocationmaym odifyonlyafewsharedvariables andhenceitisextremelyine fficient toduplicate allshared variables at everylocation.
for example the method will duplicate all the global va riables z1 z99 x at all locations in thread t1and compute summaries between all pairs of locations.
this summarizati on is quadratic in the number of thread locations and the global va riables and incurs a high overhead.
further in the improved la zy algorithm thesummariescannot bereusedacross multi pleinterleavings if the global state at a cs location is different across interleavings which causes redundant bi modal reasoning .
incontrast our method avoids bi modal reasoning and the number o f the global access events as well as the fresh variables introduc ed in our summaries is linear in the number of shared variable acce sses thusenablingapracticalanalysis.
moreover itispossibl etoobtain cbaas aspecial casebyfixingthecontext bounds inour analys is.
.
overview ccfgs.
we represent concurrent programs in form of concurrent controlflowgraphs ccfgs whichcanbeviewedasanextensi on of control flow graphs cfgs for sequential programs to conc urrentprograms.
accfg v e consists of asetofnodes vand a set of edges e. each edge in eis labeled by a guard condition ganda possibly empty setof assignments of form lhs rhs .
intuitively the assignments are executed iff the guard con ditionholds.
the set of nodes vcontains two special nodes fork and join to model thread creation and termination respective ly a fork join node has a single incoming outgoing edge and multiple outgoing incoming edges.
individual program th reads are modeled as sub graphs of the ccfg.
function calls are mod eled inthe standard way withcall and return edges label ed by assignments toparameters andreturnvariables respective ly.
synchronizationconstructs e.g.
mutex conditionvaria bles etc.
aremodeledusingsharedvariables.
forexample acquiring locklk inthreadtiis modeled as anedge withguard lk andassignment lk i .
instantaneous test and set primitives are modeled by marking the corresponding sub graphs of the ccfg as atomic which are referred toas atomic regions.
the assertions inth e original program are transformed into error nodes while constructing the ccfg assertion checking reduces to checking if there ex ists a feasible interleaving of concurrent thread paths in the ccf g that terminates at the error node.
we distinguish the two kinds of join locations in the ccfg the intra thread joins occur due to path merging inside a thread while the inter thread join corresponds to the join nodes.
anexample ispresented inthe next section.
read and write accesses.
we refer to each read or write to a memory locationas a read or write access respectively.
a mem ory locationlissaidtobesharedifmorethanonethreadreadsorwrites tol.
in the following we will mainly concern with accesses to shared memory locations called global accesses .
each global accesseis represented using a symbolic tuple loc val occ where loc e andval e correspondtothememorylocationandthevalue that is read written during the access e andocc e is the necessary condition for eto occur.
a global access e1is said to interferewith another global access e2if one of them is a write and loc e1 loc e2 is satisfiable.
note that every usage of the phrase globalaccess inthispaperisimplicitlyidentifie dwiththis tuple representation loc val occ .
a motivating example.
consider the multi threaded c program based on the pthread library shown in fig.
a .
the program contains a single shared variable x. two threads are created from the main thread which read and write x. fig.
b shows the corresponding concurrent control flow graph ccfg .
in the ccfg fork and join represent thread creation and termination poi nts.
theccfgconsistsofsub graphsforthreethreads main nod es fork join err t1 nodes andt2 nodes .
forbrevity wehavemergedmultipleconsecutive forkandjo in nodes into a single node.
moreover new assignments have bee n added to ensure that each statement makes at most one global access.
fig.
b also shows the global accesses in the ccfg w1 w2 w3 w2 w3 aretheglobalwrites while r1 r2 r3 r1 r2 r3 r4are the global reads.
let us see how our stagedanalysis works onthe given ccfg.
stage .
the first stage performs a data flow analysis sec.
on the ccfg is used to compute a summary in form of a interference skeleton is s s .
theissummarizes the ccfg in terms of global accesses sand their partial order s. starting fromtheentrynodeofccfg theanalysisiterativelycomput esand propagates symbolic data consisting of a path condition and alocalstate.
duringpropagation eachglobalreadaccessisassigneda freshsymbolicvalue interferenceabstraction andtheg lobalwrite accesses are computed in terms of these symbolic values.
fig .
shows the details of the global accesses in the skeleton is.
the accessesr1 r2 r3areassignedsymbolic values r1 r2 r3.
note thateventhough r1andr2areconsecutive accessesto x theyare assigneddifferentsymbolicvalues r1andr2.
thisallowsustotake arbitraryinterference writes fromconcurrentthreadsi ntoaccount during composition.
the analysis also collects the path con ditions under which the global accesses happen e.g.
w2occurs if the conditionocc w2 r1 holds.
the analysis merges the propagated data at the joinpoints in a precise path sensitive manner to avoid potentially exponential path enumeration in the ccfg.
at the intra thread join point s cf.
sec.
e.g.
node the path conditions are disjuncted followingthestandardsequential semantics whileattheinter t hreadjoin node node join the path conditions are conjuncted to ensure simultaneous reachability of the node by all threads.
to che ck assertion violations we compute error conditions at the error nodes whichcorrespondtothecomputedpathconditionsatthenode e.g.
r4 ne ationslash at err node.
these error conditions are checked during the second stage.
the analysis also computes a partia l order s see fig.
c denoting the relative order of events.
note thatisabstracts away all the thread local control and data flow from the ccfg and only contains the global access informatio n. computing the interference skeleton is non trivial for arb itrary c programs with pointers and complex data types we present the full algorithm insec.
.
stage2.thesecondstageofouranalysisexploresthefeasibleconcurrent behaviors of the ccfg by performing inter threadco mposition.
note that in the skeleton iscomputed above the values of the global reads are unconstrained symbolic variables.
the composition step constrains these values by linkingthem to the global writes cf.
sec.
.
note that we cannot link reads with write s arbitrarily because we onlydesire feasible program behav iors during composition e.g.
the read access r2cannot be linked to w2 which follows r2in the program order.
the notion of sequential consistency sc enables us to find a suitable relation between the reads and writes systematically sc constraints enforc e that each read access rmust link with somewrite access say w such thatbothaccessthesamememorylocation thevaluewritten byw isthe value readby r andwmustbe the lastsuchwritethathappensbeforerinanexecutiontrace.
inordertocapturethefeasible executions duringcomposition weaddscconstraints betwe enthe reads and writes in is sec.
.
for example the sc constraints relatingr2 loc x val r2 occ r1 tow2 loc x val r occ r are of form copy r2 w2 r2 r r hb w2 r2 where the predicate copy r2 w2 denotes that r2is linked to w2 andhb w2 r2 denotes that w2 must happen before r2.
constraintsenforcingthatnoother writehappens between r2 andw2 and thatr2must link with some write are also added see sec.
.
in sec.
we show how to add sc constraints in an optimized way to pruneredundant constraints.
finally the error condition r4 ne ationslash ischeckedforfeasibility togetherwiththe encoding ofisand sc constraints by an smt solver .
if the constraints are satisfiable then a sequence of accesses in isis obtained e.g.
w1 r1 r1 r2 w2 r2 w2 r4 for the above example.
this sequence is then mapped to the ccfg to obtain a violation witness.
by separating the intra thread summari zation in stage with inter thread composition in stage our analys is is able toavoidredundant bi modal reasoning completely.
.
modeling c programs wefirstdescribehowtotransformanarbitraryconcurrentcp rogram to a simplified intermediate program by adopting a memor y representation which consists of a global memory map togeth er with local memory maps for each program thread.
the simplifie d program isthenstructurallybounded andrepresentedasa bounded ccfg whichisused inour analysis.
.
program transformation inordertohandlecprogram constructslikepointers array sand structuresuniformly wefixamemoryrepresentationforour analysisinamannersimilartothehavoctool .
indirectmem ory accesses are handled using a memory map mem which models the program heap by mapping a memory location address to a symbolic value.
all variables and objects whose address can be t akenint x void add global if x x x else x x int main int argc char argv pthread t t1 t2 x pthread create t1 null null add global pthread create t2 null null add global pthread join t1 pthread join t2 assert x fork joinx x tmp x x tmp x tmp 2tmp xx x tmp x x tmp 1x tmp 2tmp x errx negationslash x 3x 0w1 w2 w3w2 w3 r1 r1 r2 r3 r2 r3 r41 10w1 r1 r1 r2 r3 r2 r3 w2 w3 w2 w3 r4 c access loc val occ w1 x true r1 x r1 true r2 x r2 r1 w2 xr2 r1 r3 x r3 r2 w3 xr3 r2 r4 x r4 true d a b figure example a a multi threadedc program withtwo th reads b its concurrentcontrol flow graph ccfg andits g lobal summaryconsistingof c therelativeorderofglobalacces sesand d thevaluesoftheglobalaccesses.
thevaluesforo nlyunprimed accesses are shown primedaccess values are similar.
theme mory location for variable xisdenotedby x. are allocated on the heap.
the address of a variable vis a fixed value denoted by v. letoffs f denote the integer offset of the location of a field finside its enclosing structure.
using the above map we can transform the program statements denoted by operator t asfollows i t e f mem ii t e mem iii t e f t e offs f iv t e mem wherestride e denotes the size of array e s type.
all c program statements with indirect accesses canbe transformedusing the above rules .
shared variables.
to detect shared variable accesses in concurrent programs with pointers we use a conservative flow a nd context insensitive pointer analysis algorithm by steens gaard .
all the variables that are declared as globals in the program or belong to an steensgaard equivalence class containing at least onegloballydeclaredvariable aresaidtobe shared.
basedonthis we partition the single memory map memabove into i a shared memory map g todenote themapcontainingthesharedvariables andmaps lktodenotethelocalmemorymapforthreadwithidentifierk.
the domains of gandlkmaps are disjoint from each other contain different memory locations thus creating a valid partition.
in contrast to previous approaches which partit ion the memorymapsbasedontype orfieldsafety theabovepa rtitionismorefine grainedandthereforeimprovesthestageda nalysis by reducing the number of conflictingmemory accesses.
all program statements are rewritten in terms of the above pa rtition e.g.
a statement of form l p wherelandpare local and shared respectively is re written as l g .
as a result we can now identify allglobal accesses inthe progra m syntactically.
variables whose address is not taken in the prog ram are referredtobytheirnames asbefore.
moreover werewritet heprogram statements so that no statement may perform more than on e global read or write i.e.
no statement may contain more tha n one occurrence ofg.forexample suppose athread tcontains astatementx p where bothpandxare shared variables this isrewrittenas lp g ap g g ap wherelpandapare freshvariables local to t. .
structural bounding analyzingconcurrentprogramswithrecursionisundecidab le.
we therefore obtain decidability by structurally bounding the concurrent program by unrolling loops and recursive functions to fi nite depth.
structural bounding ensures finite number of threads and heapsize werefertotheccfgoftheboundedprogramas bounded ccfgs.ourmethodthenanalyzes thesebounded ccfgsforconcurrent reachability properties e.g.
assertion violati ons or data races .
the presented analysis is sound and complete with re spect to these bounded ccfgs.
note that although we only consider bounded ccfgs the ccfg representation is essential for mod eling real world programs since it allows specifying thread c reation and destruction andthe relative order between threads cf .
fig.
.
boththese aspects are not handled by most concurrent analys es.
.
thread modularsummarization the first stage of our analysis computes a thread modular sum marizationofthe ccfg summarization getsridofbothlocal control and data flow in each thread and represents them precisel y in terms of global accesses.
global skeleton.
the analysis summarizes the ccfg in form of a interference skeleton is s s wheresconsists of the set of global accesses in the ccfg and sdenotes a partial order on elements ofs.
recall that each access einscontains the correspondingsymboliclocation loc e valueval e andtheoccurring conditionocc e .
each access einsis global hence the loc e values correspond tomemory locations ing.
thread modularsummarizationisdoneusingaprecisedatafl ow analysisthatexplorestheccfginthestandardreversepost order of the nodes while computing the symbolic data facts at each node of the ccfgandpropagating the facts tothe successors.
symbolic data.
the data computed at a node nis a tuple of form an bracketle t l e an bracketri ht where i is the path condition formula for the set of pathsreaching n ii listhelocalmemorymapforthethreadthat nbelongs to and iii edenotes the set of global accesses which happen immediately before reach the current location.
we use programexpressions orterms torepresentboth andlprecisely during the analysis.
intuitively captures the reachability condition for the node n lcaptures the local state map from memory locations to their symbolic values at nandeis used to computethe interference skeleton iteratively.
we also refer to the above tuple as the symbolic state s and itsfields as s. s.lands.e.
symbolic summary.
given a fragment fof the ccfg e.g.
a function having unique entry and exit nodes the thread mo dular summaryoffconsistsof i ainterferenceskeleton is s s over global accesses sinf and ii a symbolic state an bracketle t l e an bracketri htat the exit node of f where landedenote the path condition local map and the reaching accesses at the exit node in terms of the input state map at the entry of f. note that in the case where the fragment f e.g.
afunction body contains noglobal accesses thefunctionsummaryreduces tothetraditionalsequential function summary of form an bracketle t l an bracketri ht which represents the function outputs in terms of its inputs.
for ease of presentation we fi rst describe the analysis assuming that all function calls are i nlined in the ccfg.
subsequently we discuss the general inter proce dural summarization algorithm.
error conditions.
recall that assertions are transformed to error nodemonitorsintheccfg.ouranalysisretainsthesenodes i nthe skeletonisandcomputes the symbolic state satthese nodes.
the corresponding path condition s. is used to check precise reachabilityof the nodes duringthe composition stage.
data flow analysis.
a well known technique for precise program exploration is symbolic execution which assumes symb olic values for program inputs and propagates the state represe nted as program expressions along all feasible program paths.
our dataflow analysis may be viewed as a form of symbolic execution for concurrent programs with two key differences.
first we av oid costly path enumeration as in symbolic execution by mergi ng symbolic data at the join locations intra and inter threa d joins see sec.
in a precise path sensitive manner.
second we av oid exploring exponential number of thread interleavings by pe rforming interference abstraction each global read access is as signed a fresh symbolic variable placeholder .
these placeholder s model arbitrary concurrent writes to the read location propagat ing these placeholdersenablessequential thread modular summar izationin the presence of concurrency.
the analysis propagates only t he local state through the ccfg the computed global accesses are not propagated butare used toconstruct the interference skele tonis.
figure2presents therulesforpropagatingdatathroughacc fg fragment tobe summarized.
theyconsist of rules for initial ization init at the entry node of the ccfg propagating data through guardededges guard assignmentswithonlylocalaccesses asgnloc assignmentswithglobalaccesses asgn glb r asgn glbw splitting data at the fork node fork and merging data at intra thread intra join and inter thread inter join joins.
the incoming data at a node nis denoted by in an bracketle t l e an bracketri ht read writeaccesses earerepresentedastuples loc e val e occ e .
the summary of the fragment fconsists of the skeleton istogetherwiththedatacomputedattheexitstateof f. letusconsider these rulesinmore detail.
assignments.
recall that ccfg assignments cf.
sec.
either performglobalaccessesviasharedmap g orlocalaccessesviathe mapl.
since no statement accesses gmore than once we consider three kinds of assignments global lhs g g rhs and local lhs rhs.
let us assume that a procedure eval e l evaluates expression ein the local memory map l this is done by employing the standard first order logic oper ators select l l andstore l l v for manipulating arrays cf.
wherelranges over memory locations and vover values stored at these locations.
to handle a local assignment lhs rhs asgnloc the analysis first obtains the location by evaluating lhsinl eval lhs l followedbyevaluating rhstoobtainthenewvalue v and finally computing the update store l l v which is propagated.
an assignment accessing the shared map containing g is handled differently since it creates a global access even t. suppose anodenwithassignment g rhshas the incomingdata in an bracketle t l e an bracketri ht .
the rule asgn glb w handles this by creating aglobal write access w l r with location l eval e l valuer eval rhs l andthe occuring condition pathcondition atn .
moreover the skeleton isis updated by adding wand partial orders between the reaching accesses in eandw.
similarly the rule asgn glb r for handling lhs g updatesis with a global read r where the value of ris a fresh symbolic variabler interference abstraction .
handling pointers.
recall that we model indirect accesses via pointersinanuniformmannerbyemployingaprecisememoryr epresentation using maps gandl cf.
sec.
.
note that by using selectandstoreoperatorsformanipulatingsymbolicdata wecan handle arbitrary indirect memory accesses to lvia pointers or arrays in an implicit manner without explicitly computing t he alias sets of these pointers.
indirect memory accesses tothe shar ed map garecapturedbythelocationexpression loc e foreachglobalaccesse the subsequent composition stage employs loc e to check for interferingaccesses.
forks and joins.
the analysis merges the data at joinlocations in the ccfg in a precise path sensitive manner.
at intra threa d joins intra join the incoming maps l1andl2are merged using an if then else operator to retain path sensitivity while the path conditions 1and 2are disjuncted.
at inter thread joins the local map for the child thread lc is discarded and the path conditions pand cconjuncted this models the fact that both the parent and the child threads must execute the join location togethe r. note that the analysis creates a new local map lcfor the child thread at the thread creation node fork which is discarded at the thread destruction node join .
by handling statements forks and joins precisely during da taflow analysis and using interference abstraction for global reads thealgorithmgetsridofalllocalcontrolanddataflowinthe ccfg they are summarized to precise relations between global rea d and writeaccesses.
togetherwithprecisecompositioninthene xtstage ouranalysisbecomessoundandcompletewithrespecttotheb ounded ccfg.
note that for the example in sec.
.
summarization wi ll be able toinfer that a100 a0 and hence repeated intrathread reasoning isavoidedduring composition.
example.
the analysis of ccfg in fig.
proceeds as follows.
first create a write access w1 x true at node .
at the fork node initialize the local maps for thread t1andt2 l1andl2 tom1andm2respectively.
consider the propagation along the thread t1 for example.
at node create access r1 x r1 true addr1toisand updateeto r1 at node update the path condition to r1 add access r2 x r2 r1 tois add r1 r2 to s updateeto r2 and update map l1tostore m1 tmp r .
at node add w2 x v r1 toiswherev select l1 tmp i.e.
v r2 and so on.
at the intra thread join node the incoming states are merged to obtain r1 r1 trueandl1 store m1 tmp ite r1 r2 r3 and e w2 w3 .
at inter thread join node join the incoming path conditions are conjuncted trivially true andemerged.
finally the error condition is obtained from the path condi tion r4 fortheerrnode.
thecompletesummaryoftheccfgis giveninfig.
c and d .
notethatwedonotpropagateanygl obal readorwritesduringccfgexploration alltheglobalacces sesare captured inis.
although the data flow analysis algorithm works on the complete ccfg the analysis is thread modular i.e.
each thread isanalyzed independently using interference abstr action.
function summaries.
the above algorithm can summarize arbitrary bounded concurrent programs assuming that functio ns are inlined.
however inliningcausesblowupoftheanalyzedpr ogram and makes it difficult to exploit the modular sequential prog ram structure.
wecanextendtheabovealgorithmtoperformasta ndard interprocedural analysis based on computing summa ries at function boundaries and reusing these summaries at the ca lling contexts.
a function summary consists of a interference ske letoninitn entry ccfg in an bracketle ttrue l an bracketri ht guardng n in an bracketle t l e an bracketri ht g eval g l i n an bracketle t g l e an bracketri ht asgn locnlhs rhs n in an bracketle t l e an bracketri ht l eval lhs l v eval rhs l i n an bracketle t store l l v e an bracketri ht asgn glb rnlhs g n in an bracketle t l e an bracketri ht is s s l eval lhs l l eval e l r l r ris fresh i n an bracketle t store l l r r an bracketri ht is s r s e r e e asgn glb wng rhs n in an bracketle t l e an bracketri ht is s s l eval e l r eval rhs l w l r i n an bracketle t l w an bracketri ht is s w s e w e e intra joinm n m n tid m tid m tid n im an bracketle t 1 l1 e1 an bracketri ht i m an bracketle t 2 l2 e2 an bracketri ht in an bracketle t 1 2 ite 1 l1 l2 e1 e2 an bracketri ht forkfork n n p n c tid p tid n in an bracketle t l e an bracketri ht ip an bracketle t l e an bracketri ht ic an bracketle t lc e an bracketri ht lcis freshinter joinjoin n p n c n tid p tid n ip an bracketle t p lp ep an bracketri ht ic an bracketle t c lc ec an bracketri ht in an bracketle t p c lp ep ec an bracketri ht figure transformation rules for thread modular summari zation of a ccfg fragment.
for a node n in an bracketle t l e an bracketri ht denotes the incomingsymbolic state at n tid n isthenumericidentifierofthethreadcontaining n iterepresentsthe if then else operator.
the summary consists of theinterferenceskeleton is s s andiexcomputedat exit node exof thefragment.
globalaccessesmadeinthefunction togetherwiththelo calsymbolic state lat the exit node of the function.
here the exit state lis computed using a fresh symbolic input state liat the function input.
incontrast to explicit summarization approach es which depend on detecting transaction boundaries our me thod can compute symbolic summaries for arbitrary program regio ns across multiple transactions.
the key problem is how to reus e precomputed summaries givena callingcontext state l the interference skeleton of the summary is duplicated and all global acc esses evaluated inthe incoming state l bysubstituting l forli.
theorem .theinterferenceskeleton is s s isaprecise thread modular summary of the finite ccfg.
moreover s respects the program order1.
.
axiomaticcomposition we now describe the second stage of our analysis which computes the inter thread composition by using sequential con sistency axioms that link the read and write accesses in the thread mo dular summaryiscorrectly.
.
linearization ofthe globalskeleton alinearization lof a interference skeleton is s s is a tuple s s where i s s ii s isatotalorder and iii for allrw1 rw2 s rw1 srw2 rw1 s rw2.
in other words a linearization of isis obtained by selecting a subset of accesses from isandimposingatotalorderamongthemsuchthat the totalorder respects the partial order in is.
a linearization lis saidtobe programpath consistent ifitsprojection ontotheccfg corresponds toa single pathfor each program threadinthe cc fg andlshould contain all the accesses in each path on which it is projected.
program path consistency allows us to obtain co ncrete ccfg program paths from a linearization that leads to an erro r. a linearization lofisissaidtobe feasibleifthereexistsaconcrete interleaved execution of the program ccfg corresponding to l. notethatafeasiblelinearizationisalwaysprogrampath c onsistent but not vice versa.
althougheachconcreteexecutioncorrespondstosomelinea rizationis of the skeleton is all linearizations may not be feasible program traces.
infeasible linearizations is occur because the reads inis may not be linked to appropriate writes.
in order to derivetheseconstraintssystematically wedefinethe copyrelation.
1allproofs are available inthe extended version of this pape r.copy relation.
letrandwbe a read and write access in a read write total ordered sequence s. we say that rcopiesw or copy r w holds if a randwinterfere i.e.
loc r loc w b the value read by ris the same as the value written by w val r val w and c there are no interfering write accesses w toloc w ins such thatw sw andw sr. the main goalofcomposition therefore istofindasuitablewrite wforeach readrso thatrcan copyw.
the notion of sequential consistency sc can be used to formally characterize this problem.
a linearizationis s s is said to be sequentially consistent if the followingaxioms hold sc.
program order let rw1andrw2be read write accesses to the same location lin the sequence s. ifrw2followsrw1inthe executionorder of program p i.e.
rw1 p rw2 thenrw1 srw2.
sc.
copy some each read to location linsmust copy somewriteinstol2.
axiomatic composition ac using the above sc axioms guarantees thefeasibilityof linearizations of is.
theorem .a program path consistent linearization is of isis feasible iffitissequentially consistent.
axiomatic composition ac has been previously used toveri fy properties of concurrent data structures executing on m odern out of order processors.
here ac was primarily used to pre cisely model various intra thread read write reorderings allo wed by the processor.
in contrast we employ ac in an entirely new setti ng i.e.
static analysis of high level programs.
here the pro blem reduces to encoding only the sc constraints between reads wri tes.
however the central challenge is to obtain an efficient enco ding that enables ascalable analysis.
.
copy constraints note that by theorem any linearization of the interferenc e skeletonismust obey the program order sc.
.
however additional constraints must be imposed on a linearization to s atisfy sc.
.
we refer to such constraints as copy constraints denoted by c. these constraints capture the copyrelation and are modeled by a set of first order logic formula quantified over read s and writes consisting of 1 c 2 cand 3 c. 2theinitialvalue oflocation lisalsorepresentedbyawriteaccess withafresh symbolic value.
1 c r.occ r w.copy r w 2 c r w.copy r w occ r occ w val r val w loc r loc w hb w r 3 c r w.copy r w w ne ationslash w .
occ w hbet w w r loc w ne ationslash loc w c 1 c 2 c 3 c. the constraints 1 ccapture the conditions sc.
sec.
i.e.
each read if it occurs must copy some write access.
the formula 2 c capturesthedata flowconstraintsonthecopy i.e.
thewri tewmust occur occ w the values locations of both randwshould be same andwmust happen before rin the linearization.
the predicatehb e1 e2 models a strictpartial order relation that denotes thataccesse1musthappenbefore e2ineverylinearization.
inother words if a linearization contains both e1ande2thene1must precedee2.
theformula 3 ccapturesthefactthatnointerferingwrite w may happen between the write wand a readrthat copies from w. the predicate hbet w w r denotes that w may happenbetweenwandr and is defined as hb w w hb r w .
detailsofencoding hbarepresentedinthenextsection.
3 cmodels that either w does not happen between wandr or does not interfere with w loc w ne ationslash loc w ifw occurs inbetween.
example.
recall the example and its isin fig.
.
a linearization l0 w1 r1 r3 r2 w2 r1 r2 w2 r4 of theisis not program path consistent since it does not project to a sing le path for threadt1.
on removing r3froml0 we obtain a linearization say l1 which is path consistent however l1is not feasible.
to see this note that because the reads r1 andr2 immediatelyfollowthewrite w2inthelinearization copyconstraints 1 c and 3 cimplythatboth copy r1 w2 andcopy r2 w2 must hold.
now since val w2 the constraints 2 cimply that val r1 r val r2 r val w2 .
this however implies that occ r2 r false which violates 2 c. hencer2 shouldnotoccurintheexecution andthereforein l1 .
onreplacing r2 w2 byr3 w3 inl1 weobtainafeasible linearization w1 r1 r2 w2 r1 r3 w3 r4 .
.
encoding thecomposition we encode the set of sequentially consistent linearization s of a interference skeleton isas a formula in quantifier free first order logic theskeleton is s s isencodedasaformula is and thecopyconstraintsas c. thesetoffeasiblelinearizationsof is is then represented as a formula is c. finally given an error location with the path condition we can check if the error location is reachable via a feasible linearization by checking the satisfiabilityof the formula usingan smtsolver.
encoding isandhb.both isand cdepend on the strict partial order relation hbbetween read write accesses.
to obtain an efficient encoding that avoids quantifiers we encode the r elation using the integer theory with the strict partial order o perator .
more precisely we assign an integer clockvariableteto each accesse.
now hb e1 e2 is simply encoded as te1 t e2.
the accesses inisare encoded in a straightforward manner for each read write access we create three variables loce valeandocce and add constraints that equate each variable to the corresp onding value.
to model arbitrary initial values for locations in th e map g lazily we add a finite set of initial symbolic writes in isas many as the number of reads in is.
finally we encode the partial order susing the must happen before predicate hb.
encoding c.the quantified constraints in sec.
.
can directly serve as input to an smt solver that supports quantifiers usi ng interpreted functions for loc valandocc.
in practice however smt solvers have difficulty in instantiating quantifiers effi ciently.therefore weinstantiatethecopyconstraintsexplicitly forallpossible read and writes in isusing the corresponding loc valand occvariables for each access.
modeling copy r w directly will introduce boolean variables of form copy r w quadratic in number of reads writes which we want to avoid.
therefore we cr eate an integer identifier variable idefor each access e and assign a unique constant to idwfor each write access w. now copy r w is encoded as idr idw which holds when the identifier to ris same as that for w. this encoding takes advantage of the fact that a readcanonly copy a single write.
still this explicit instantiation of cfor all reads writes is too eagerandmayresultinaformulathatiscubicinsizeoftheread write access set.
the next section discusses optimizations to ove rcome the bottlenecks due tothis eager encoding.
theorem .suppose we have an sequentially consistent encoding for a ccfg cand apath condition for an error locatione.
if is satisfiable then there exists a feasible interleaved executionof ctothe location e. example.
recalltheprogramanditsskeleton isinfig.
.
checkingthepathcondition r4 ne ationslash fortheerrnodetogetherwith is andcopyconstraints cleadstoasolutionwitha hbrelationthat refines s cf.
fig.
by adding pairs r1 r1 r1 r2 and w2 r2 .
the accesses r3 w3 r3 w3 do not occur i.e.
theiroccevaluates to false and they can be ignored.
as a result we obtain a linearization w1 r1 r1 r2 w2 r2 w2 r4 that witness the assertionviolation.
.
interference pruning eager instantiation of the copy constraints cfor all pairs of reads and writes in large programs proves to be a significant b urden on the smt solver during satisfiability check.
moreover in case of indirect accesses it is not clear upfront if a read rcannot interferewithawrite w i.e.
loc r loc w isunsatisfiable thus making the search more complex.
however many of these copy constraints may be redundant i.e.
copy r w holds.
for example note that the constraints corresponding to 2 cmay reduce to copy r w if the right hand side rhs of the formula is unsatisfiable for some randw.
this may happen due to a number of reasons.
for example a read rcannot copy a write wthat follows rin the program r2 w2in fig.
or a read rin a child thread cannotcopyawrite wthatoccursintheparentthreadafterthechild thread terminates.
also rcan only copy from wifrandwmay interfere i.e.
loc r loc w is satisfiable.
in other words each read may copy from only a restricted set of writes and it is wa steful to add copy constraints for the writes not in the set.
a lar ge number oftheseredundant constraints canbedetectedstati callyby analyzingtheinterferenceskeleton isandremovedtooptimizethe composition cf.
sec.
.
we now present a systematic method to prunethese copy constraints basedon the followingnotions.
mhp and kill set.
given an interference skeleton is s s let sdenote the transitive closure of s. we say that two accessese1ande2may happen in parallel i.e.
mhp e1 e2 if bothe1 se2ande2 se1do not hold.
if a write wfollows another write w in the same thread and winterferes with w i.e.
loc w loc w in all program executions then we say that w killsw .
more formally the set of writes killedbywis given by kill w w w sw loc w loc w .
note that for symbolicvalues loc w andloc w loc w loc w musthold ifwkillsw inall executions.
reaching writes.
we say that a write wmay reach a read r if i mhp r w or ii whappens before rand for allw sr w ne ationslash w w ne ationslash kill w holds.
we denote the set of writes that mayreachrby r .
wecompute r foreachread rasfollows.
first we compute the transitive closure sfor the given skeleton is.
computing i mhp r w requires checking if both r w or w r do not belong to s. in order to compute the writes that are not killed we perform a light weight gen kill analysis of the partial order graph for s cf.
fig.
.
starting from the node corresponding to the initial write the analysis compu tes and propagates the set of reaching writes to each location in the graph i.e.
for each access in is each location that generates a write w may kill the incoming writes w that belong to kill w .
note that checkingloc w loc w precisely is expensive if both loc w andloc w are symbolic values.
so we estimate the kill set conservativelybycheckingif loc w andloc w areexactlythesame.
may copyset.
inorder toprune theredundant constraints in c we define the may copy setc r for eachrby restricting r to interfering writeswthat can occur i.e.
c r w w r loc r loc w occ w .
again computing c r preciselyis expensive we syntactically check if occ w or loc r loc w is unsatisfiable.
finally we instantiate 1 c 2 cand 3 conly for pairsrandw wherew c r .
instantiating the inner quantifier in 3 cfor all possible writes w may still produce redundant constraints.
we prune such constraints by checking if a the write w cannot occur occ w or b cannot happen between wandr hbet w w r or c loc w loc w is unsatisfiable.
we check a and c syntactically.
to check b we use the isrelation computed above i.e.
w cannot happen between wandrif eitherw iswor r isw .
ourencodingcanbefurtheroptimizedtohandle atomic regionsandtoperformacontext bounded analysis seefull version of the paper .
our experiments in the next section sh ow thatpruningredundant constraints asabove leadstosignifi cantimprovement of solver run times.
.
experiments we implemented the staged analysis approach in the fusion verificationsystem forconcurrentcprogramsbasedon pthreads .
the fusionsystem combines dynamic and symbolic verificatio n techniques inorder to verifyproperties of concurrent prog rams.
in the first step of its execution fusion instruments the given concurrentprogramandthenrunstheprogram ptoobtainasliceof p. the slice is represented as a ccfg and contains the threa ds created and the original program statements that each threa d executed during the run.
the slices themselves can grow quite l arge dependingonthenumberofstatementsexecutedin pandthenumber of threads created and are suitable for preliminary eva luation of our approach.
in order to evaluate our approach our implementation focus ed on checking assertions as well as data races in the concurren t program slices obtained from benchmarks using fusion.
we first performed data flow analysis on the slices to obtain an interf erence skeleton and computed a pruned set of sequential consis tency constraints over this skeleton.
to check assertion violati ons at an error location we add the feasibility path condition for th e error location and employ the yices smt solver to check if the se t ofconstraintscanbesatisfied.
tocheckdataracesbetweent wolocations weaddconstraintsmodelingthatthe correspondin g global accesses are simultaneously reachable and again check for satisfiability using the solver.
all experiments are conducted on a pc with .4ghz intel core2quad processor with 2gb memory limit running fedora .
our evaluation consists of two parts.
first we compared our stagedanalysiswithapreviousapproachthatusesconcurre ntsinglestatic assignments cssa cf.
for encoding concurre nt programs.
cssa is an extension of single static assignments to c oncurrent programs to handle both intra thread data flow each variable must be assigned only once as well interference value s of all concurrent writes are propagated to each read .
the cssa representation retains all the local control and data flow more over a large number of fresh variables are introduced in each thre ad tomodeljoinsandinterference.
duetothepresenceofcomplex local control and data flow the approach performs repeated intra thread reasoningforeachinterleavingoftheprogramthreads.
sec ond we evaluated the efficiency of optimizations when encoding com position using sequential consistency.
more precisely our goa l was to estimate the impact of pruning redundant interferences.
we evaluated our approach using the following benchmarks ob tained from the public domain.
the first set of benchmarks con sist of the c implementation of the indexer example using pthread library parametrized by the number of threads.
in this example multiple threads read and write to a hash table with entries.
asthe number ofthreads increases beyond thenu mber ofsharedaccessesalsoincreasesrapidlyduetohashcollis ions.
we checkthepropertythatnocollisionhappensonaparticular entryof the hash table.
we evaluated the effectiveness of our approa ch for handling increasing number of threads as compared to the css a based implementation which does not perform summarization .
we experimented with ccfgs with up to threads to evaluate the scalability of our approach.
the second set of benchmarks ar e obtained from traces of a bank account program account and a s ynchronization based module synchbench .
boththese benchm arks were checked symbolically for existence of data races.
the b enchmarks are marked in the name t format where tdenotes the number of threads.
fig.
shows the comparison of various modes of our tool with without summarization and optimized composition.
the mod e old o denotes an implementation of the symbolic checks ba sed on cssa encoding .
this implementation has been optimiz ed extensively to reduce the number of redundant constraints similar to sec.
but does not use summarization.
in the next mode so we perform summarization but composition is done eagerl y by instantiatingcopyconstraints forallpairsof reads andwr ites.
this eagerinstantiationleadstoalargenumberofredundantcon straints.
finally s o denotesourapproachwithbothsummarizati onand optimized composition.
we do not present results for the mod e without summarization or optimization s o because of it s poor performance.
our experiments show that mode s o outperforms all other modes on our benchmarks.
for example as the number of thread s in theindexer example is increased successively from to both old o and s o modes scale much worse than s o mode.
themode s o withoutoptimizationsperformsveryp oorly since the eager instantiation of sequential consistency s c constraints allows each global read to link with all global writ es e.g.
intheindexer example eachreadcancopyfrom 1856writes.
the smt solver is not able to handle such a large number of copy constraintseffectivelyandtimeoutsin s o mode for25o rmore threads.
this shows that a naive encoding of sc constraints i s not useful for analyzing real life benchmarks an optimized en coding that avoids redundant constraints is needed.
similarly th e mode with optimized composition but without summarization old o timeouts for and threads.
in contrast the mode with bot h summarizationandoptimizedcomposition s o finishesan alyzingindexer inonly 104s.
for theaccount benchmark similarly for the synchbench example weagainobservethatsummarization s o leadsto faster run times as the number of threads increase from 11to21.
this supports the fact that performing repeated intra thread re asoning whenexploringlargenumberofthreadinterleavingstakesa significant toll on the overall efficiency of the solver.
we observe d that theaveragenumberofwritesthatareadmaycopy cf.
sec.
a fter optimized composition in s o mode is 3for all the benchmarks maximum varies between .
the results show that both summarization and optimized composition are indispen sable for scaling up the analysis and summarization can make veri fication tractable in cases where optimized composition is not s ufficient.
moreover note that the encoding used in context bou ndedbm n e r w old o s o s o synchbench synchbench indexer .
.
indexer .
indexer indexer indexer indexer indexer account1 account2 figure experiments comparing a cssa based algorithm without summarization with optimizations old o b with summarization no optimization s o c our method with s ummarization and optimization s o .
n e total number of nodes edges intheccfganalyzed.
r w total numberof global reads writes .
allrun timesare in seconds.
methods roughly corresponds to the s o mode wher e each global read may link with all possible shared variable w rites.
therefore theprevious encodingisimpracticalforlargep rograms.
.
related work context bounded analysis.
a number of approaches check concurrent software under a fixed context bound since the ve rification problem is both decidable and practically useful .
both symbolic and explicit approaches have been proposedforcba.arecentapproach transformsaconcurren t recursivebooleanprogram withfinitedata underacontextbo undto asequentialprogram whichisthenanalyzedusingsequenti alanalysis.
extend the method to perform context bounded ana lysis of concurrent c programs by unrollingloops and recursion fin itely to obtain decidability and employing a precise memory repre sentation for c programs.
in contrast our goal is to verify real life concurrent cprograms where both i variable domains maybe infinite and ii arbitrary context switches are allowed iii without any redundant bi modal reasoning.
to achieve the condition i we need to structurally bound the loops and recursion in our p rograms similar to .
although can be extended to achi eve ii and avoid bi modal reasoning such an extension is impr actical.
more precisely the extension will have to a duplicat e and abstract all global state variables at eachpotential context switch location and b compute summaries for each pair of intra th read locations resulting in an extremely inefficient metho d. in contrast our staged analysis abstracts interference by in troducing freshvariablesatglobalreadlocationsonly.
further bys tructurally bounding theprogram whichisunavoidableduetodecidabil ityissues wenot onlyavoidredundant bi modal reasoning but i nfact separate the intra and inter threadreasoning completely .
thread modularsummarization.
pathcompressiontechniques relyon identifying interference free transactions and are unable to summarize data facts across multiple transactions causin g redundant bi modal reasoning.
the zing model checker employs fun ction summarization in presence of interference by iden tifying transactions during path enumeration based explicit state exploration.
incontrast our method performs precise summar ization symbolically based on symbolic memory accesses as opposed to potentially infinite number of concrete valued accesses.
f urther wedonotneedtoidentifytransactionsandavoidpath enume ration by mergingsymbolic data facts at program joinlocations.
thread modular verification.
thread modular or rely guarantee techniques for software include the initial deductive meth ods followed by more recent methods that employ iterative co mpositional refinement or methods for handling h eapmanipulating programs .
iterative refinement techn iques first abstract the transition relation or the reachable states of the individual threads by over approximating the relation be tween global accesses in each thread.
if the composition of t hese abstractions is not suitably precise to prove the given prop erty the methodsrefinetheabstractionsiteratively e.g.
basedon counterexamples from the property check.
interference abstra ction alsomakesourthread modularsummariesover approximate however because our summaries contain the exact relation betw een non concurrent reads and writes we can obtain the fully pre cise system in one step by linking the reads to the writes during co mposition.
this is in contrast to the previous methods where a large number of iterations may be required before the abstraction s are made suitably precise for proving a property.
instead of per forming rely guarantee reasoning as in our focu s is on compositional minimization we use summaries tosep arate intra andinter threadanalysisandobtainacompactrepre sentation of threads before composition.
concurrentdataflowanalysis.
mostconcurrentdataflowanalyses cf.
employ a finite height data domain and perfor m redundant bi modal reasoning by repeated intra thread propa gation of new symbolic domain values while exploring all relevant i nterleavings explicitly.
in contrast our staged analysis performs summarization over infinite domains using program expressi ons terms followed by symbolic exploration of interleavings inside ansmt solver .
othersymbolicencodings.
anothersetofmethodsusesat smt solvers to check concurrent programs with an encoding that d oes notemployanexplicitscheduler .
noneoftheseappr oaches employ thread modular summarization and therefore perfor m redundant bi modal reasoning the solver must reason over con current interleavings as well as complex local transitions alt ernately.
theencodingpresentedinfse2009 isbasedontransform ing a bounded program into a concurrent single static assignm ents cssa formandisrestrictedtohandlingsimpleintegerpro grams in contrast to ours which handles arbitrary c programs and p erforms summarization.
the idea of interference abstraction is employed implicitly in the cssa representation but not explo ited to compute summaries.
verificationofconcurrentdatastructuresunderrelaxedlo w level hardware memory models employ axioms specifying the allowed load store event orderings to the hardware memory in order to precisely model the concurrent interleavings.
our me thod instead targets high level static analysis of c programs f or highlevel analysis it is sufficient to consider only sequential ly consistent sc orderingsofreadsandwrites asopposedtomorere laxed memory orderings considered in .
as a result of this restr iction ourmethodfocusesonencodingscefficientlyinsidean smt solver whichis not considered in .
.
conclusionswe presented a staged analysis for verifying concurrent c pr ograms which separates intra and inter thread reasoning an d exploits sequential summarization to solve the pervasive pro blem of redundant bi modal reasoning.
the key contribution is a thr eadmodular program summarization algorithm which abstracts a way all the local control and data flow in terms of global accesses .
the summarizedinterferenceskeletonisthenusedforinter th readanalysis by employing sequential consistency axioms over the gl obal accesses.
experimental results on benchmarks show our appr oach is more scalable than previous bi modal methods because it a voids repeated intra thread reasoning.
future work will focus on scaling our approach to larger concurrent systems the key problem i s to further minimize the set of quantifier instantiations whic h are cubic inthe size of reads and their may copy sets which causes blow up on larger benchmarks.
another approach is toavoidexplic it instantiation by using quantified sc axioms inside the solver.
our method can also be extended to perform data flow analysis on le ss precise domains thanterms e.g.
polyhedra.