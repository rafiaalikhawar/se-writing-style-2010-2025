minimal strongly unsatisfiable subsets of reactive system specifications shigeki hagihara dept.
of computer science tokyo inst.
of technology hagihara fmx.cs.
titech.ac.jpnaoki egawa r d division sony computer entertainment inc. negawa rd.scei.
sony.co.jpmasaya shimakawa dept.
of computer science tokyo inst.
of technology masaya fmx.cs.
titech.ac.jpnaoki y onezaki dept.
of computer science tokyo inst.
of technology yonezaki cs.
titech.ac.jp abstract verifying realizability in the speci cation phase is expected to reduce the development costs of safety critical reactive systems.
if a speci cation is not realizable we must correct the speci cation.
however it is not always obvious what part of a speci cation should be modi ed.
in this paper we propose a method for obtaining the location of aws.
rather than realizability we use strong satis ability due to the fact that many practical unrealizable speci cations are also strongly unsatis able.
using strong satis ability the process of analyzing realizability becomes less complex.
we de ne minimal strongly unsatis able subsets msuss to locate aws and construct a procedure to compute them.
we also show correctness properties of our method and clarify the time complexity of our method.
furthermore we implement the procedure and con rm that msuss are computable for speci cations of reactive systems at non trivial scales.
categories and subject descriptors d. .
software program veri cation formal methods f. .
logics and meanings of programs specifying and verifying and reasoning about programs speci cation techniques general terms veri cation reliability algorithms keywords reactive systems speci cations realizability strong satisability flaw location analysis ltl b uchi automata minimal unsatis able subsets .
introduction reactive systems are widespread and include systems that control elevators vending machines nuclear power plants permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
.and air traffic.
reactive systems respond to requests from the environment at an appropriate time.
when designing a system of this kind requirements are analyzed and then described as a speci cation for the system.
if the speci cation has a aw such as inappropriate case splitting the system may display unintended behavior.
indeed many fatal accidents in safety critical reactive systems have occurred due to the rise of such unexpected situations.
therefore it is important to ensure that speci cations do not possess such aws.
more precisely a reactive system speci cation must have a model that can respond to any possible set of requests at an appropriate time.
this property is called realizability and was proposed in .
flaws in speci cations can be classi ed as follows.
case speci cations are realizable but involve aws.
there are critical situations that were not considered during the design and testing phases and thus the speci cations do not de ne behavior for those situations.
the intent of a given speci cation is incorrect and does not lead to the expected outcome.
case the speci cations are not realizable.
a speci cation cannot achieve realizability because its intent is not expressed correctly.
a speci cation cannot achieve realizability due to unintended con icts between parts of the speci cation.
in this paper we consider the type of aws in case .
if a speci cation is found to possess such aws they must be located and eliminated.
if it is possible to locate the aws it should be straightforward for system designers to correct them.
here we propose a method for locating aws in a speci cation.
rather than realizability we use strong satis ability which is a necessary precondition for realizability.
many practical unrealizable speci cations are also strongly unsatis able and strong satis ability may lead to less complex analysis than realizability.
we de ne minimal strongly unsatis able subsets as an indication of the location of aws and detail a procedure to compute them.
a minimal strongly unsatis able subset represents a minimal part that is not strongly satis able in the speci cation.
in this procedure we take a speci cation and an input event sequence from an environment as inputs and then compute all of the minimal strongly unsatis able subsets by analyzing a graph representing behavior for the input event sequences on the !
automaton representing the speci cation.
we show correctness properties of our method soundness and completeness and clarify the time complexity of our method.
furthermore we report an implementation of the procedure and con rm that minimal strongly unsatis able subsets are computable for the speci cations of reactive systems at non trivial scales.
.
specifications of reactive systems and their properties .
reactive systems a reactive system responds to requests from an environment with appropriate timing.
definition reactive system .
a reactive system rs is a tuple x y r where xis a set of events caused by an environment yis a set of events caused by the system andr 2x !2yis a reaction function.
we call events caused by the environment environmental events and events caused by the system system events.
the set 2x is the set of all nite sequences of sets of environmental events.
a reaction function rrelates sequences of sets of past environmental events with the set of current system events.
.
language for reactive system specifications the timing of environmental and system events is an essential element of reactive systems.
in this paper we use linear temporal logic ltl to describe the speci cations of reactive systems.
in ltl in addition to the operators !
and?
we can use the temporal operators andu.
the notation fstates fholds at the next time whereas fug represents falways holds until gholds.
the notations frg 3f and2fare abbreviations for fu g uf and f respectively.
we treat environmental events and system events as atomic propositions.
behavior is an in nite sequence of sets of events.
j f represents that satis es f which is de ned as usual.
.
properties of reactive system specifications when developing reactive system speci cations it is important to satisfy realizability.
realizability requires that there exists a reactive system such that for any environmental events of any timing the reactive system produces system events such that the speci cation holds.
definition realizability .
a speci cation is realizable if 9rs8 a behave rs a j holds where ais an in nite sequence of sets of environmental events i.e.
a2 2x !.
behave rs a is the in nite behavior by rs for a and is de ned as follows.
if a a0a1 behave rs a a0 b0 a1 b1 where biis a set of system events caused by rs i.e.
bi r a0 a i and is the union operator of two sets.
the following property is a necessary condition for realizability .
definition strong satisfiability .
a speci cation is strongly satis able if a9 b a b j holds where bis an in nite sequence of sets of system events i.e.
b2 2y !.
if a a0a1 and b b0b1 then a b is de ned as a b a0 b0 a1 b1 .
intuitively strong satis ability is the property that if an in nite sequence of future environmental events is known then the system can determine an in nite sequence of sets of system events.
strong satis ability is a necessary condition for realizability i.e.
all realizable speci cations are strongly satis able.
however many practical strongly satis able speci cations are also realizable.
strong satis ability requires a less complex analysis compared to realizability.
checking for strong satis ability is expspace complete whereas checking realizability is 2exptime complete .
if a speci cation is not strongly satis able then there exists a counterexample that is evidence for unsatis ability of the speci cation.
definition counterexample .
let be a specication that is not strongly satis able that is satis es a8 b a b j .
then a counterexample is a which satises8 b a b j .
example .let us consider the following reactive system speci cation i 3 i 1 x1!3y 2 x2!
y 3 x3 y !
yux where x1 x2 and x3are environmental events and yis a system event.
each of 1 2 3is strongly satis able individually however is not strongly satis able because there is no response that satis es for the environmental behavior where x2continues to occur after x1occurs.
formally this is because for a fx2gfx2 x3g fx1 x2gfx x3g !
b a b j does not hold.
ais a counterexample that shows unsatis ability of .
.
minimal strongly unsatisfiable subsets in this section we de ne minimal strongly unsatis able subsets msuss and propose a procedure to compute them.
.
minimal strongly unsatisfiable subsets intuitively an msus represents a minimal part of a speci cation that is not strongly satis able.
definition strongly unsatisfiable subset msus .
let i2i ibe a strongly unsatis able speci cation and let abe a counterexample i.e.
an in nite sequence of sets of environmental events that satisfy b a b j .
if a set of indices i isatis es b a b j i2i i we say i is a strongly unsatis able subset in for a. if i is minimal we say i is a minimal strongly unsatis able subset msus in for a. example .let us consider in example .
the strongly unsatis able subsets for the counterexample a fx2gfx2 x3g fx1 x2gfx2 x3g !aref1 2gandf1 3g.
msus is f1 2g.
any other set of indices jsatis es b a b j i2j i .
this is because i2j iholds by considering bwhere ykeeps on occurring for j f1 3g and by considering bwhere y keeps on occurring for j f2 3g.
this means that the collision of subspeci cations 1and 2results in being strongly unsatis able.
.
preliminary to procedure definition b uchi automata.
our method of computing all of the msuss uses !
automata which accepts only the same set of behavior as that which satis es a speci cation.
in this paper we use b uchi automata and generalized b uchi automata of which the edges are labeled by boolean formulae as follows.
630defini tion b uchi automata .
letpbe a set of propositions i.e.
environmental or system events.
a b uchi automaton on an alphabet 2pis de ned by a q q f where qis a nite set of states q0is an initial state q b p qis a transition relation f qis a set of nal states and b p is a set of boolean formulae that consist of propositions in pand connectives .
a run of a on an !
word is an in nite sequence of states where q0and bi and j bifor some bifor all i .
if in f holds a run is said to be successful where in is a set of states that occur in nitely often in .
if there is a successful run of aon we say that aaccepts .
a set of !
words that are accepted by ais called the language accepted by a which is represented by l a .
definition generalized b uchi automata .
a generalized b uchi automaton on an alphabet 2pis dened by a q i f where q and iare dened as above for a b uchi automaton.
f ff1 f ng is a set of sets of nal states and satis es fi q. if 8i inf fi holds a run is said to be successful.
if there is a successful run of aon we say that aaccepts .
translation to b uchi automata from ltl formulae.
there are numerous ways to translate an ltl formula into a b uchi automaton that accepts exactly the same set of behaviors satisfying the formula.
formally translation methods convert an ltl formula to a b uchi automaton awhich satisfy l a f j j g. improvements to this procedure have been reported and graphical tools to construct and manipulate automata have also been reported .
we obtain a b uchi automaton for a speci cation using the methods introduced above.
product of automata.
in our procedure we compute a product of b uchi automata de ned as follows.
definition product of automata .leta1 anwith ai qi q0i i fi be b uchi automata.
the product of a1 a nis the generalized b uchi automaton i nai q q f de ned as follows.
q q1 qn q0 q01 q 0n f q1 q n b1 bn q q n j i n qi bi q i ig f ff f ng where f i f q1 q n jqi2fi 8j i qj2qj g. remark .leta ibe a b uchi automaton that satis es l a i f j j ig.
then l i na i f j j 1 ngholds.
.
procedure for computing msuss in this section we propose a method for computing all of the msuss in i n i. the procedure takes as inputs b uchi automata a1 anthat satisfy l a i f j j ig and a counterexample a i.e.
an in nite sequence of sets of environmental events that satis es b a b j and outputs the set of all of the msuss for ain .
we assume that each aiis total which means that for any state in ai any set of events there is a transition from that state based on that set of events.
any b uchi automata can be converted into total automata without changing the accepted languages.
we also assume that ais given by a1 a2!
which is a concatenation of a nite sequence a1of environmental events and an in nite iteration of a nite sequence a2of environmental events.input a q q0 f a a1 a2!
output run graph g v e v f q0 a g v e e while v v e e do v v e e for each q z 2vdo for each q b q suc h that head z j bdo v v f q tail z g e e f q z q tail z g end for end for end while return v e here head andtailare functions that return the rst element and the remaining elements respectively.
figure algorithm for constructing a run graph.
step we construct i naifrom a1 a n. the resulting automaton is a q q f step we obtain a b uchi automaton a q q f by restricting ato only environmental events where f q e b q j q b q g e b b is a substitution that substitutes or?for all of the system events in b. intuitively e b denotes the quanti ed boolean formula 9y1 9ynb ify1 y nare system events that appear in b. note that all of the labels in aare boolean formulae that consist of only environmental events.
this manipulation of automata is known as projection.
step we construct a run graph g v e from aand a a1 a2!using the algorithm shown in fig.
.
grepresents the set of runs of aon a .
each node of gis a tuple the rst element is a state in a an d the second element is a remaining part of athat has not yet been processed.
remark .l a f aj b a b j g holds by the de nition of .
a path of the rst element of gcoincides with a run of aon a. step w e compute the maximal strongly connected components sccs in g. let scbe the resulting set of sccs.
step for each sc2sc we obtain isc which is the set of indices of automata that do not include nal states isc fkj fqkj q1 q n a 2scg fk g where q1 q n a is a node included in sc.
q q n is a state in aand is represented by a tuple of states of a1 a n. step we consider the set iof sets iof indices that satisfy 8sc2sc i isc and output the set imsus i which consists of all of the minimal sets in i. .
example application we apply the procedure to the speci cation and the counterexample ashown in example .
b uchi automata a1 a2 a3for 1 2 3are obtained in advance as shown in fig.
left .
the states with the symbol are initial states and those with the double circle are nal states.
the labels with edges are transition conditions represented by boolean formulae obtained by connecting literals horizontally with and vertically with .
first in step we obtain a which is the product of a1 a2 and a3 and in step we obtain aby considering only environmental events as shown in fig.
center .
each number in tuples of states in acorresp onds to the indices of states in a1 a2 a3.
next in step 631truex2y x3y yx2truetrues0s1s2 figur e the automata of sub speci cation a1 a2 a3 the automaton a and the run graph g. we obtain the run graph g shown in fig.
right .
each path of gcoincides with a run of aon a. although each node in gis a tuple in fig.
right we show only the rst element i.e.
a state in a of the tuple and arrange nodes with the same second elements in the same row.
in step we compute the sccs and obtain sc fsc1 sc2 sc3 sc4ging shown in fig.
right .
in step we obtain the set of indices of automata that do not include nal states in the sccs.
because each nal state of a1 a2 a3iss0 if is included in the tuple of states the nal state of the corresponding automaton is included in the scc.
for instance the nal states of a2anda3are included in sc1 however the nal states of a1are not included in sc1.
we conclude that isc1 f1g.
similarly we conclude that isc2 f2g i sc3 f2 3g i sc4 f1 3g.
finally in step we compute i which satis es 8sc2sc i isc .
in this case f1 2gandf1 3gsatisfy this condition i.e.
i ff1 2g f1 3gg.
we obtain all of the minimal sets fromi.
hence in this case we obtain imsus ff1 2gg which is the same result as that given in example .
.
correctness and complexity in this section we show correctness properties of our procedure i.e.
soundness and completeness.
we also clarify the complexity of the procedure.
theorem soundness completeness .
let i n ibe a speci cation a1 a nbe b uchi automata that satisfy l a i f j j ig abe a counterexample i.e.
an in nite sequence of sets of environmental events that satisfy b a b j .
ifimsus is a set of sets of indices that is the result of applying the procedure to a1 a nand a then i2 imsus iis a msus in for a holds.
this theorem can be proved by using lemma .
we omit the proof.
lemma represents that the result of projecting i naibyica n be considered as i2iaiwhi ch was not constructed in the procedure.
lemma .proj run i nai i run i2iai ho lds where run a a is the set of runs of aon a proj run i nai a i is the set of runs obtained by projecting q1 q n into qi1 q im where i fi1 i mg and q1 q n is a tuple of states that appears in runs of i naion a. this lemma obviously holds because the following i ii iii can be proved.
for proving iii we use totality of ai.
we omit these proofs.
i run a a br un a a b ii proj run i nai a i bpr oj run i nai a b i iii proj run i nai i run i2iai .
we can clarify the time complexity of our procedure by estimating computation time for each step of our procedure.
theorem time complexity .
let i n i be a speci cation and let a a1 a2 !be a counterexample.
we can translate 1 ninto a b uchi automaton a1 an apply the procedure to a1 a nand a and compute the set of msuss in time 2o j j log j a1j j a2j log n 2o 2n .
.
applicability our method is useful for correcting strongly unsatis able reactive system speci cations as demonstrated by the following example of a control system for a door.
the initial speci cation is as follows.
.
a door has three buttons an open button a close button and an open extension button.
.
if the open button is pushed the door eventually opens.
.
while the close button is pressed the door remains shut.
.
while the door is open if the open extension button is pushed the door remains open until the close button is pushed.
the event the open or close or open extension button is pushed is an environmental event.
we use x1 x2 x3 to describe this event.
the event the door is open closed is a system event.
we use y y to describe this.
this initial speci cation is represented by x1!3y x !
y x3 y !
yux in ltl which is identical to in example .
because this speci cation is strongly unsatis able as stated in example it is necessary to identify a aw that causes strong unsatis ability and correct this speci cation.
to correct this speci cation we use msuss in the speci cation.
strong satis ability can be checked for using the method described in and if a speci cation is 632no t strongly satis able a counterexample of the form a a !
can be obtained.
in this case we suppose that the counterexample ashown in example is obtained.
the set of msuss ff1 2ggis obtained by applying the procedure to and a as stated in sect.
.
.
this states that to make anot be a counterexample it is not necessary to modify 3 in the speci cation but it is necessary to modify 1or 2 or in the speci cation .
several modi cations are possible for example in the initial speci cation may be weakened to i.e.
.
if the close button is pushed the door eventually closes.
the modi ed speci cation is represented by x1!3y x !
y x3 y !
yux .
for a there is an in nite sequence of sets of system events that satis es this modi ed speci cation.
that is following this modi cation ais no longer a counterexample.
in this case because only one msus f1 2gwas obtained by the procedure only one modi cation was required.
in general multiple msuss may be obtained.
in such cases multiple modi cations may be required to account for all of the msuss.
furthermore one counterexample does not always correspond to all of the aws that give rise to strong unsatis ability of the speci cation.
although modi cation succeeded in making ano longer a counterexample aws causing strong unsatis ability of the speci cation may remain.
in such cases we can obtain strongly satis able speci cations by iterating the following processes we determine whether strong satis ability of the speci cation exists and if not we obtain a counterexample we compute the msuss and we correct the speci cation accordingly.
.
implementation and evaluation .
implementation we implemented the procedure using python .
.
the inputs were a collection of b uchi automata representing specications and a counterexample.
we used the tools goal and ltl3ba to translate the speci cation into b uchi automata.
.
evaluation we evaluated our implementation on a machine with a core i7 processor running at .
ghz with gb of memory and which was running the ubuntu linux operating system.
we apply this implementation to a practical speci cation at a non trivial scale.
we consider the speci cation of an moor elevator system described in shown in fig.
.
the speci cation has m environmental events 2m system events and 12m temporal formulae.
the speci cation consists of a a speci cation for each oor divided into functional requirements and non functional requirements b a speci cation for a door of the lift and c a speci cation of the physical constraints.
this speci cation is not strongly satis able because if the button at a given oor is held i.e.
pushed continuously the lift will stay at that oor and will not move to other oors.
in this experiment we use the counterexample representing the behavior that both buttons at the rst and second oors are pushed continuously.
we consider the following two kinds of partitions of speci cations a. a1 am b c and b. a1f a1n amf a mn b c where a i represents the speci cation for the i th oor a if and a in represent the functional and non functional requirements respec tively for the i th oor speci cation.
we show the results in table .
the execution time includes the time to translate the subspeci cations in ltl into b uchi automata.
if the execution does not terminate within seconds we show the notation t o. after partitioning the speci cation into subspeci cations the bottommost case in table it failed to compute msuss within seconds and the run graph was not constructed.
because we used a naive transformation algorithm and naive data structures to represent the run graph the memory space for the run graph was large.
except for this case in spite of the naive implementation we obtained the intended results in a reasonable period of time.
this indicates that the aw did not appear in non functional requirements and appeared only in the functional requirements for the rst and second oors and the physical constraints.
hence our method is useful not only for locating the aws but also for classifying subspeci cations including functional non functional requirements and physical requirements.
we con rmed that the set of msuss can be computed from a practical speci cation at non trivial scale in a reasonable amount of time and found that the msus is useful for locating aws in practical speci cations.
m partition the set of msuss time a ff a1 a2 c gg .
b ff a1f a2f c gg .
a ff a1 a2 c gg .
b ff a1f a2f c gg .
a ff a1 a2 c gg .
b ff a1f a2f c gg .
a ff a1 a2 c gg .
b t o t o ta ble results for application to speci cation of moor elevator system.
.
related work methods for computing locations of aws in unrealizable speci cations has been proposed in .
although in these methods they treat realizability they restricted speci cation language to gr which is a subset of ltl.
in contrast to their works we treat strong satis ability instead of realizability however targets of our method are speci cations written in full ltl and can be expanded to !
regular languages easily.
methods for computing minimal unsatis able subsets muss from unsatis able boolean formulae are typically derived from research on satis ability solvers or sat solvers.
in procedures for computing all of the muss were proposed.
methods for deriving causes rather than the locations of aws in reactive system speci cations have been reported .
these methods derive constraints of the behavior of an environment implicitly imposed by unrealizable speci cations.
because the implicit constraints provide hints to the cause of aws in speci cations these constraints are helpful to correct the aws.
.
conclusion we have described a method for computing msuss using a counterexample of a reactive system speci cation written 633ev ents environmental events lbtn i i m request button at ith oor is pushed.
obtn open button in the lift is pushed.
cbtn close button in the lift is pushed.system events li i m the lift is located at ith oor.
ri i m the lift is requested to go to ith oor.
opn the door is open.
mov the lift can move.
to the time limit that the door can open has past.
oreq the door is requested to open.
speci cations a a speci cation for each oor af functional requirements if a request button is pushed the lift eventually go there.
i m2 lbtn i!3li riw li ri if the lift reaches the requested oor the door open.
i m2 li ri!opn liwmov an non functional requirements until request button is pushed lift is not requested to go there.
i m2 li mov!
ri wlbtn i if the lift is not requested at a oor the door will not open there.
i m2 li ri!
opn c a speci cation of the physical constraints the lift is located at some oor.
i mli i m li!
j m i j lj the lift must pass oors on the way to the destination.
m i m j m i j li rj!
i k j lk u lk lk i m j m i j lj ri!
i k j lk u lk lk a relation between the door open close and the lift movable unmovable opn !
mov w opn opn !movwopn b a speci cation for a door of the lift the time limit that the door open is set.
opn!3to if open button is pushed the door is requested to open.
obtn to!oreq when the time that door can open passed the door closes.
to!
opn if close button is pushed the door closes.
cbtn oreq!
opn if the door is requested to open and the lift is not movable the door opens.
oreq mov !opn remark in the speci cations we use the weak until operator fwg which is an abbreviation for gr g f .
figure sample speci cations of moor elevator systems in .
in ltl which is not strongly satis able.
flaws can be located and corrected by modifying the parts of the speci cation indicated by the msuss.
because our method is based on strong satis ability instead of realizability it is possible to locate aws in a speci cation efficiently.
we proved correctness of our procedure i.e.
soundness and completeness to ensure that all msuss are computed correctly.
we also showed the time complexity of our procedure.
furthermore we implemented the procedure and con rmed that the set of msuss can be computed from a speci cation at a nontrivial scale in a reasonable amount of time.
step simply translates minimal correction subsets mcss into muss.
in several efficient translation algorithms are described.
we expect that these algorithms can improve the efficiency of our method.
we believe that our method has many potential practical applications for the analysis of safety critical systems.
.