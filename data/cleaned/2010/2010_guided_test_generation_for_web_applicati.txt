guided test generation for web applications suresh thummalapenta k. vasanta lakshmi saurabh sinha nishant sinha and satish chandra ibm research india indian institute of science india ibm t.j. watson research center usa abstract we focus on functional testing of enterprise applications with the goal of exercising an application s interesting behaviors by driving it from its user interface.
the difficulty in this is focusing on the interesting behaviors among an unbounded number of behaviors.
we present a new technique for automatically generating tests that drive a web based application along interesting behaviors where the interesting behavior is specified in the form of business rules.
business rules are a general mechanism for describing business logic access control or even navigational properties of an application s gui.
our technique is black box in that it does not analyze the application s server side implementation but relies on directed crawling via the application s gui.
to handle the unbounded number of gui states the technique includes two phases.
phase creates an abstract state transition diagram using a relaxed notion of equivalence of gui states without considering rules.
next phase identifies rule relevant abstract paths and refines those paths using a stricter notion of state equivalence.
our technique can be much more effective at covering business rules than an undirected technique developed as an enhancement of an existing test generation technique.
our experiments showed that the former was able to cover of the rules compared to of the rules covered by the latter.
i. i ntroduction a. testing interesting application behaviors enterprise applications have complex logic that governs the application behavior.
the goal of functional testing of these applications is to exercise meaningful or interesting application behaviors.
the starting point for functional testing are documents that capture requirements specifications use cases business rules etc.
test designers study such documents and create test cases to cover the requirements use cases or business rules.
this activity is largely manual and is often performed in several steps to get to executable test cases e.g.
high level test cases are created initially then refined into lowlevel test cases and finally automated to create executable test cases.
being manual these activities are not only timeconsuming but also prone to human lapses.
our goal is to automate the functional testing of enterprise web applications.
the challenge in this is efficiently discovering the interesting behaviors from among a possibly infinite set of application behaviors.
for this work we assume that interesting application behaviors are specified as business rules.
a business rule is typically related to business calculations or access control policies.
for example banking applications have rules for calculating interest rates loan eligibility customer status and so on and healthcare applications have rules on actions permissible in differentr1.
once a card type is added it should be visible on the registration page where the card type option is available r2.
discount should be computed as follows if invoice amount is less than discount if invoice amount is between and discount if invoice amount is more than discount r3.
the data entered by a user on successful registration should be visible on the user page r4.
users logged in as admin should have admin functions enabled fig.
.
sample business rules for the bookstore application.
roles.
in this paper we use the business rule framework to also express properties of the ui.
figure shows sample business rules stated informally in english for an online bookstore application .
as the samples illustrate an application can have rules of different types.
for example rules r1andr3specify properties of the gui r4pertains to access control whereas r2 which describes how shipping discounts are to be computed is the specification of a business calculation.
test designers create test cases intended to cover such rules.
for example to cover r1 a tester would create a test case that navigates to the card types record page enters a non empty name of a new card type selects the insert button navigates to the registration page and verifies that the list of cards shown includes the newly added card type.
b. the problem in this paper we consider the problem of automatically generating executable test cases to cover interesting application behaviors specified as business rules .
an executable test case is a script consisting of a sequence of actions on the application graphical user interface gui along with relevant data values.
figure illustrates such a test case for thebookstore application.
this test case pertains to a web application in which the gui elements are links text boxes buttons etc.
the last action is a verification step a check that the current state is as expected which in this case looks for a certain string in a drop down list.
such scripts are meant to be used in automated regression testing and executed using a driver implemented in a testing tool such as selenium .
what does it mean for a test to cover a business rule?
technically a rule has an antecedent a consequent and optionally an invariant each of which are predicates over the gui state of the application.
formal versions of rules in figure are discussed in section ii.
for example for r1 the antecedent requires that a card name is entered and the insert button is clicked on the cardtypesrecord page the .
c circlecopyrt2013 ieee icse san francisco ca usa162test step action type name data s1 select link administration s2 enter text box user id admin s3 enter text box password admin s4 click button submit s5 select link card types s6 select link insert s7 enter text box name discover s8 select button insert s9 select link registration s10 exists combo box credit card type discover fig.
.
a test case consisting of a sequence of steps each step includes an action the target of the action specified as the type and name of the gui element and any required data.
consequent says that the card name previously entered should appear on the cardtypesgrid page.
to cover a rule a test must first drive the application to a gui state in which the antecedent of the rule is true.
then it must drive the application along a path such that the consequent can be evaluated while ensuring that the invariant if any is not violated along the way.
note that the consequent may evaluate false signaling that the application has violated the rule.
the test case shown in figure covers rule r1.
we have developed a technique for automatically generating test cases to cover business rules.
our approach takes as inputs a set of formal rules see section ii .
it outputs test cases one or more per rule for as many rules as our analysis is able to cover these test cases are of the form shown in figure .
our approach is black box as it does not analyze the implementation of the application under test.
instead it relies on driving the application via its gui e.g.
clicking hyperlinks selecting menu items entering text in text boxes and observing the gui state after each test step.
c. challenges although a web application may have a small number of distinct pages in terms of urls each page can have a large or even unbounded number of distinct gui states.
this happens because the content of a page can be generated dynamically by the server and reflects some aspect of the server state e.g.
ashoppingcart page can have unbounded number of gui states.
this also happens in ajax style pages that directly manipulate the browser state.
the enormity of the space of gui states creates a problem for test generation.
to cover a rule a test must identify a sequence of gui actions a path that first drives the application to a state in which the antecedent can be evaluated and from there to a state in which the consequent can be evaluated.
for r1 this means identifying a path to the cardtypesrecord page in a gui state in which the insert button appears on the page and then a path from there to the registration page.
directly jumping to a page such as cardtypesrecord based on its url does not work for one thing the authentication credentials need to be established and moreover there is no reason that this should lead to the page in the desired state.
therefore test generation needs to perform a search over the space of the application s gui states to find a path to take the application from its current state to the desired state it performs this search over and over again.
because there cancard types recordadministration default registration shopping cart book detailcard types grid fig.
.
url level std of the bookstore application the edge labels are omitted.
an unbounded number of gui states this approach does not yield good results because the search can easily get stuck in irrelevant parts of the state space.
the natural step in such situations is to resort to abstraction.
we create an abstract state transition diagram std using some notion of equivalence of gui states.
the nodes in an std are states equivalent states appear only once .
each labeled edge represents a gui action that leads from the source state to the target state.
our approach for creating an std is based on a standard search until no new states or labeled edges can be found.
once a state is explored in the search it is marked visited and not explored again.
for web applications some options for state equivalence in order of decreasing coarseness are all states pertaining to the same url are equivalent all states with the same clickable elements e.g.
buttons or links are equivalent and so on.
section considers these options in more detail.
as we go down the list the number of states in the std increase as does the cost of creating it.
in the limit each gui state is considered as a distinct state in which case the full std cannot be constructed in general because of an unbounded number of states.
figure shows an std based on the coarsest abstraction mentioned above.
in principle the test generator can carry out its work over an std quite easily.
a path in the std from a source state to the destination state represents the sequence of gui actions that must be performed to take the application from the source state to the destination state.
unfortunately there are two problems with search over an abstract std.
the first problem is that a path may not lead to the desired gui state.
being a path over abstract states this is quite expected.
a path might reach the correct abstract state but perhaps another path was needed to reach the desired concrete gui state.
a simple instance of this problem occurs in bookstore .r1requires cardtypesrecord page to be visited in a state in which the insert button appears as shown in figure .
the path that leads to the desired gui state screenshot must traverse the insert link from the cardtypesgrid page see screenshot the other links would go to the right page but not in the desired state screenshot .
the second and a more subtle problem is that a path in an abstract std may not correspond to an actual traversable path.
this is an artifact of how the std is constructed.
to illustrate consider figure .
when a state sis added to the std for the first time it is seen in a certain concrete gui cardtypesgrid.jsp cardtypesrecord.jsp cardtypesrecord.jsp fig.
.
the html pages generated by cardtypesgrid.jsp and cardtypesrecord.jsp .
stategs suppose the path to arrive to state gsis 1. based on gs labeled edges say llandl2 and their destination states are added to the std at the time sis explored sis then marked visited.
later smay be encountered again along some other path 2 in some other gui state gs .
ings labeled edge l1 may go to a different state s3 and edge l2may not exist.
this is not reflected in the std.
thus from the perspective of the std the path 2.l1ought to go to s1but in reality would go tos3 and the path 2.l2cannot be traversed.
d. our approach our approach works in two phases.
in the first phase we create a coarse std of the application under test using relaxed notions of state equivalence.
the first phase does not consider the business rules to be covered.
the purpose of this phase is to crawl the application with no particular coverage goal to recover an initial std that in the second phase can guide test generation and can be refined in a goal oriented manner.
the novelty in our approach is in the second phase.
for each business rule we begin with a set of plausible abstract paths and refine each one until a desired traversable path is found.
in refining an abstract path we split certain states in the std using stricter notions of state equivalence in an attempt to discover newer potentially rule relevant states.
the graph on the right in figure illustrates that the initial state sis split to create a new state s which leads to the discovery of states4along the newly explored link l3.
the benefit of our approach is that it spends the extra effort only in portions of the state space that are relevant for covering rules.
thus it can aggressively search for state elements that are relevant for rule coverage without risking getting stuck in parts of the application s state space unrelated to the rules.
e. related approaches although many approaches for web application testing have been presented e.g.
to the best of our knowledge none of them has been designed specifically to cover business rules.
however among these atusa is a related approach.
atusa first creates a stateflow graph a web application model that is very similar to the std using a certain state abstraction.
then it traverses allk length paths on this graph to generate tests.
although atusa can provide good structural coverage we found that it is not effective in generating tests that cover rules.
for one reason paths in an abstract std are subject 1 2 1 2 fig.
.
illustration of non traversable paths in the std created due to state abstraction.
state splitting is shown on the right.
to the problems mentioned earlier.
if the std is sufficiently refined to detect rule relevant concrete states path coverage as performed by atusa would eventually cover a given rule.
the problem is that it would take far too long to create an adequately refined std in a rule oblivious manner.
in our evaluation section iv we compared our approach with an enhanced implementation of atusa hereafter referred as kpath .kpath shares the key idea of atusa namely bounded length path generation over an std.
however kpath includes refinement by state splitting as shown in figure so that the paths generated are traversable.
unlike our approach kpath still aims at creating k length paths without considering rule coverage.
f .
highlights of results we implemented our approach in a tool called wateg web application test generator and conducted empirical studies using five open source web applications to evaluate the effectiveness and efficiency of the technique.
in the evaluation with business rules over all subjects we found that wateg covered of the rules within a maximum time budget of minutes per rule.
we also implemented and evaluated kpath this technique covered only of the rules even though it exercised additional paths over all applications compared to wateg .
g. contribution this paper makes an important contribution in the area of automatic functional testing of web applications.
business rules are a common form of functional specification of enterprise applications.
our technique is able to automatically generate tests that exercise business rules and to our knowledge it is the first technique with that capability.
we show that the key to searching for a state in a webapplication s gui state space is a two phase approach.
the first phase provides approximate reachability information whereas the second phase refines an abstract path into a traversable one.
this bypasses the problems in creating a very refined state space upfront.
the metaphor is borrowed from work in program verification but applied in a different context.
in this paper we present the two phase approach in the context of business rules but it is applicable more generally to other forms of functional specifications for which the goal of testing is to cover certain interesting application states.
164table i formal specification of the bookstore business rules shown in figure .
rule antecedent consequent invariants r1cardtyperecordpage.name negationslash empty cardtyperecordpage.name regpage.cardslist explored cardtyperecordpage.insert r2.1cartpage.invoice checkout page.discount cartpage.invoice r2.
cartpage.invoice checkout page.discount cartpage.invoice .
r2.3cartpage.invoice checkout page.discount cartpage.invoice .
r3regpage.login usercollection regpage.login myinfopage.login explored loginpage.logout regpage.login loginpage.user regpage.email myinfopage.email explored loginpage.login regpage.fname myinfopage.fname regpage.lname myinfopage.lname r4loginpage.user adminusercollection exists administration menu explored loginpage.logout explored loginpage.login ii.
b usiness rules and rule coverage a business rule specifies some aspect of the logic of an application and could pertain to business calculations access permissions and so on see figure .
formally a business ruler is a triple consisting of an antecedent aconsequent and a set ofinvariant conditions.
the interpretation of a business rule r is that if holds at some point in a program execution must not be violated along any path from that point.
moreover if holds along a path the invariant must hold at each step of the execution between the step where becomes true and the step where holds.
conversely if there is an execution in which and hold but is violated that execution reveals a fault in the rule s implementation.
revealing such faults is in fact the goal of rule directed test case generation.
business rule specifications enable the construction of test cases with automated oracles the oracle is basically an assertion on the consequent condition.
table i illustrates the formal specification of the bookstore business rules from figure .
for example the antecedent ofr3states that a login name that is not in the set of existing users is entered on the registration page the same login name is also entered on the login page and the login button is clicked.
together these three conjuncts specify the condition that a new user registers and logs in.
the consequent states that the data entered on the registration page must match the data shown on the user information page.
finally the invariant ensures that at no point after the antecedent becomes true and before the user information page is reached the logout button is clicked i.e.
the user logs out .
each antecedent consequent and invariant is stated in an application specific vocabulary of business rule variables.
a business rule variable is drawn from an application specific domain of page based labels and collection labels.
a pagebased label e.g.
reg page.login is represented as p.l where p is a page and lis a label on the page.
a label can be associated with a user interface element such as a hyperlink a button or a textbox.
a collection label e.g.
usercollection represents a predefined collection of values.
the antecedent the consequent and the invariants are composed using business rule variables constants and operators.
a constant represents a string including the empty string.
an operator can be an arithmetic operator a logical operator or the set containment operator.
in addition to these operators we use three special operators on page based labels exists enabled andexplored .exists p.l evaluates true if label lexists on page p.enabled p.l evaluates true if the user interface element associated with page based label p.lis enabled i.e.
the user can perform an action on the element .
explored p.l evaluates true if the user interface element associated with p.l has been explored e.g.
the element has been clicked or a data value has been entered .
for ajax applications static page