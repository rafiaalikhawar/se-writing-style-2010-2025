how should we measure functional sameness from program source code?
an exploratory study on java methods y oshiki higo osaka university y amadaoka suita osaka japan higo ist.osaka u.ac.jpshinji kusumoto osaka university y amadaoka suita osaka japan kusumoto ist.osaka u.ac.jp abstract program source code is one of the main targets of software engineering research.
a wide variety of research has been conducted on source code and many studies have leveraged structural vocabulary and method signature similarities to measure the functional sameness of source code.
in this research we conducted an empirical study to ascertain how we should use three similarities to measure functional sameness.
we used two large datasets and measured the three similarities between all the method pairs in the datasets each of which included approximately million java method pairs.
the relationships between the three similarities were analyzed to determine how we should use each to detect functionally similar code.
the results of our study revealed the following.
method names are not always useful for detecting functionally similar code.
only if there are a small number of methods having a given name the methods are likely to include functionally similar code.
existing file level method level and block level clone detection techniques often miss functionally similar code generated by copy and paste operations between different projects.
in the cases we use structural similarity for detecting functionally similar code we obtained many false positives.
however we can avoid detecting most false positives by using a vocabulary similarity in addition to a structural one.
using a vocabulary similarity to detect functionally similar code is not suitable for method pairs in the same file because such method pairs use many of the same program elements such as private methods or private fields.
categories and subject descriptors d. .
computer aided software engineering d. .
restructuring reverse engineering and reengineering general terms experimentation measurement permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.keywords functionally similar code clone detection structural similarity vocabulary similarity method name similarity .
introduction in software engineering program source code is one of the main research targets.
various studies have been conducted on source code and these studies often utilize similarity of structure and or vocabulary to measure the functional sameness of source code.
for example clone detection is a family of research studies that utilizes the similarities of code structure such as token sequences or abstract syntax trees .
detected clones are generally code instances implementing the same functions.
they are sometimes merged as new modules .
on the other hand keyword based code searching is a representative study that utilizes the similarity of code vocabulary .
developers can obtain reusable code from keyword based code searching systems by inputting keywords related to the function that they want.
clone detection research assumes that if the structures of two code units are identical or similar to each other their functions are also identical or similar to each other.
on the other hand keywordbased code searching research assumes that if the vocabulary in a code unit is similar to that of another unit their functions are also similar.
however of course those assumptions do not always make sense.
for example herein we consider two code units one is an implementation of quicksort and the other is bubblesort.
both code units have the same function which sorts numerical values stored in an array in ascending descending order.
thus both code units should include the same words such as sort or array .
in this case the functional sameness appears in their vocabulary but not in their structures because the two code units implement different algorithms.
in addition in some program languages such as c or java for statements are often used to perform an action for each element in a given array iteratively.
thus many code units using forstatements have a common operation that iteratively does something.
however such an iterative operation with a forstatement is a stylized implementation.
such stylized implementations do not necessarily include the same words.
if a code unit is a declarative unit in programming language the code has its own name.
for example in java language classes and methods have names.
corazza et al.
reported that the vocabulary appearing in the signature of a method is the most informative one in java language .
on the other hand there are many java methods whose names are not at all informative such as main or actionperformed .the purpose of this research is to reveal how we should leverage the three similarities structural similarity vocabulary similarity and method name similarity for measure functional sameness from program source code.
in this research we have investigated the relationships between functional sameness and the three similarities.
in the investigation we selected the java method as the target code unit.
to reduce bias in the investigation results we conducted the same investigation on two different datasets.
we investigated the relationships for approximately million method pairs in the two datasets.
the following are the main findings of this research.
the name of a method does not always reflect its function.
in cases where a given name is used by a small number of methods the degree of the functional sameness of the methods is likely to be high.
however if there are many methods that have the same given name the degree of their functional sameness is low.
checking the number of methods having a given name is a way to learn whether the name well represents its function.
there are hash based clone detection techniques at the file level method level and block level.
however such techniques often miss functionally similar code generated by copyand paste operations between different projects.
if we use structural similarity to detect functionally similar code in java we obtain many false positives such as consecutive switch case or consecutive else if statements.
such consecutive instructions are dependent on java.
if we use vocabulary similarity in addition to structural similarity we can avoid the detection of most false positives.
method pairs in the same class share the same private fields an private methods.
as a result such method pairs tend to have a high vocabulary similarity.
consequently using a vocabulary similarity is not suitable for method pairs in the same class.
the remainder of this paper is organized as follows section describes the experimental design used in this study section explains how we measure the three similarities in section we describe how we prepared the datasets for the experiments section shows the experimental results and section discusses future research based on these results section describes some threats to the validity of these experiments section introduces existing works related to our experiment lastly in section we conclude this paper.
.
experimental design in this research we investigate how the following three types of similarity should be used in detecting functionally similar code.
structural similarity vocabulary similarity method name similarity although all of the above similarities have been leveraged in existing research studies they are not complete measures.
code pairs regarded as similar by these measures are occasionally recognized as false positives by humans.
for example in code clone detection where structural similarity is generally leveraged code fragments including repeated instructions tend to be detected as clones but they are generally regarded as false positives .
consequently the authors made the following hypotheses.
a b c d e f g structure similarity vocabulary similarity method name similarity figure three types of similarities used in this research code pairs regarded as similar by two measures are more likely to be recognized as similar by humans than ones regarded by only one measure.
code pairs regarded as similar by all three measures are more likely to be recognized as similar by humans than ones regarded as similar by two measures.
figure shows the relationships between the three similarities.
by using this figure the probabilities that code pairs are functionally similar code are presented as follows.
a b c d e f g in this research we determine whether code pairs in each region from atog are truly functionally similar code and the characteristics of code pairs in each region.
we conducted experiments on two large sets of open source projects written in the java language.
the details of the experimental targets are described in section .
java is an object oriented language and multiple classes operate by cooperating with one another.
each class should have its own responsibility so that two methods in the same class tend to be more closely related to each other than two methods in different classes.
in addition java has the notion of package which includes a set of classes that closely cooperate with each other.
thus two methods in the same package should tend to be more closely related to each other than two methods in different packages.
to summarize the above mentioned assumption the degree of similarity between two methods depends on their distance apart in source code.
in this research we took into account the distance between a given code pair when investigating it.
more concretely we used four distance categories within file wf two methods are in the same file within directory wd two methods are in different files but in the same directory within project wp two methods belong to different directories but to the same project and across project ap two methods are defined in different projects.
.
similarity measures in this section we explain how we measured structural vocabulary and method name similarities from a given pair of java methods.
.
structural similarity the measurement procedure for structural similarity ss consists of the following steps which are based on the clone detection procedure of nicad .
step the source code of each target method is transformed into a token sequence.
in this step all white spaces tabs and new line characters are deleted.
step all the tokens representing variable names method names and type names are replaced with special tokens.
the three types of special tokens are all different from each other.
step the longest common subsequence between the two normalized token sequences is identified.
step a quantified value of ssis calculated using the following formula.
ss ta tb min jlcs ta tb j jtaj jlcs ta tb j jtbj where ta and tb are normalized token sequences obtained from methods a and b and jtaj represents the number of tokens included in ta .
lcs ta tb shows the longest common subsequence between ta and tb .
an identified longest common subsequence is not necessarily a consecutive subsequence of the original sequence.
in other words the longest common subsequence algorithm considers additional shorter equal subsequences among two sequences as common sequence in addition to the longest equal consecutive subsequence.
the experiment in this paper we used .
as a threshold for determining whether given two methods are structurally similar to each other or not.
.
vocabulary similarity we use jaccard similarity as vocabulary similarity vs .
the steps for measuring jaccard similarity in this research are as follows.
step variable names and method names are extracted from the source code of each method by performing syntax analysis.
step nouns and verbs are obtained from the extracted names with their dictionary forms by performing camel snake case splitting and stemming.
note that stop words are ignored.
step a quantified value of vsis calculated using the following formula.
vs va vb jva vbj jva vbj where va and vb show sets of words in two methods a and b respectively.
jvaj is the number of words included in va .
the experiment in this paper we used .
as a threshold for determining whether given two methods have vocabulary similarity or not.
.
method name similarity in this research the unit of investigation is the java method.
each java method has its own signature so we need to quantify the similarity between two given signatures.
however quantifying signature similarity appropriately as a single value is very difficult because a signature includes multiple elements that need to be considered.
for example we need to take into account the method name number of parameters type of each parameter and name of each parameter.
in this research instead of quantifying the similarity of a whole signature we use the simplest way to determine whether signatures of two given methods are similar that is if their method names are exactly the same their signatures are regarded as similar.
if not they are regarded as not being similar.
readers may think why method name similarity is not measured in an analogous way with vocabulary similarity .
generally a method name consists of a few english words.
measuring jaccard similarityfrom such a small number of words is meaningless.
consequently in this research we chose a binary similarity for method name similarity .
.
datasets in this research we conducted experiments on the following two datasets in order to reduce bias due to the datasets used1.
apache the entire set of java projects included in the apache software foundation2.
the svn repositories are open to the public.
in the experiment we used a snapshot taken on oct .
uci a large set of java software projects that includes approximately projects and million methods3.
if we were to use the entire uci dataset we would need to measure similarity between trillion method pairs.
in this research we used projects in the dataset which were extracted by using the following steps.
step projects were sorted in the order of the number of methods they included.
step the sorted list was divided equally into sections.
step projects were randomly extracted from each of the sections.
theapache dataset consists of directories and files that were checked out from svn repositories.
svn repositories often include branches andtagsdirectories.
the former directories include files that belong to branches and the latter ones include files of tagged versions.
in order to exclude source files under such directories we used only source files under trunk directories which are used for storing mainstream development.
1the two datasets are open to the public on our website http sdl.ist.osaka u.ac.jp higo fse2014 table overview of datasets apache uci no.
of projects no.
of files no.
of methods total loc 635in addition we expended considerable effort to eliminate test cases from the datasets.
we obtained a list of source files whose paths included test .
then we checked every source file in the list manually to identify whether it was a test case.
our elimination targets were not only test cases but also source code generated by tools.
here we used the same strategy as for generated code.
that is first we obtained source files whose paths include generated .
then we checked each of them manually.
we also obtained a list of source files where code comments include generated antlr javacc sablecc or the names of other compiler compilers.
then each of them was interactively checked and eliminated if it was regarded as generated code.
the same data cleansing was performed on the uci dataset because it included projects that had been checked out from svn repositories.
table shows numerical data of the two datasets such as the number of source files the number of methods and loc.
however some of the methods should not be targets even if they are neither test cases nor generated code.
when we make programs using the java language we generally define many small methods such as getters and setters.
measuring the similarity between such small methods does not make sense.
in addition merlo et al.
reported that small methods tend to have similar metric values even if their contents are different .
consequently we removed small methods from our measurement targets.
in this research a given method was regarded as small and ignored if it satisfied either of the following conditions.
it included or fewer tokens.
it included or fewer words that appeared in user defined identifiers.
as mentioned above method pairs were classified into four categories based on the distance between the two methods in the pairs.
table shows the number of method pairs in each category.
the within file category has the least number of method pairs and the across project category has the largest number of method pairs.
.
investigation results we investigated method pairs in each region shown in fig.
by browsing their source code manually.
in this investigation we used .
for the thresholds of structural similarity andvocabulary similarity .
table shows the number of method pairs in each of the regions.
if or more method pairs were included in a given region we investigated at least pairs.
if fewer than pairs were included in a given region we investigated all the pairs.
in the reminder of this section we describe the result for each of the regions.
in this paper we describe only the results for the apache dataset due to space limitations.
however we would like to note that we obtained the same result from both the datasets.
some of the graphs for the uci dataset can be seen on our website4.
table number of method pairs in each category category apache uci within file within directory within project across project total .
region c method pairs in region c had the same name but their structural similarity andvocabulary similarity were low.
manual investigation revealed that none of the selected pairs contains related methods.
hence it does not seem worthwhile to detect them as functionally similar code.
they quite often had highly abstract names such as get or execute or language dependent names such as main or addactionlistener .
in the graph for across project in fig.
many method pairs having the same name are located near the bottom left corner.
that is their structural similarity andvocabulary similarity are low.
on the other hand some of the same name method pairs are located near the top right corner.
in order to ascertain the differences in characteristics between bottom left method pairs and top right method pairs we analyzed the relation between the abstractness of their names their structural similarity and their vocabulary similarity .
figure shows the result.
for example in fig.
a the left most boxplot shows the distribution of structural similarity of same name method pairs where there are five or fewer methods having the same name.
this figure shows that the lower the number of methods that have the same name the higher their strucutral similarity andvocabulary similarity .
besides fig.
shows histogram representing frequency of structural and vocabulary similarities for the same name anddifferentname method pairs for the category across project .
we can see that even most the same name method pairs have low structural and vocabulary similarity.
this result shows that the method name sameness of a given method pair does not necessarilly indicate its high structural similarity or high vocabulary similarity .
.
regions a and e method pairs in region a have a high structural similarity but they have low vocabulary similarity and different method names.
method pairs in region e have high structural similarity and the same method names but have a low vocabulary similarity .
in the category across project many method pairs included consecutive switch case statements and consecutive if else statements.
in java language such implementations are often used in cases where we need to bifurcate a procedure into multiple branches.
in other words the reason their structural similarity was high was that they included language dependent implementations.
we were not able to find any other reason such as that they had been created by copy and paste operations.
such code repeated instructions is occasionally regarded as false positives in clone detection .
there is even a clone detection technique that has a special function to avoid detecting repeated instructions as clones .
in the categories within project andwithin directory many methods had similar procedure logic for different object types.
for example in project qpid the following two files had methods whose names were construct see fig.
table number of method pairs in each region region apache uci a b c d e f g 918figure overview of three types of similarities for apache each dot represents a method pair.
each black dot is a method pair whose names are different and each red dot is a method pair whose names are the same messeging codec propertiesconstructor.java and transport codec attachconstructor.java .
their structural andvocabulary similarities were .
and .
respectively.
such method pairs are latent refactoring opportunities.
however refactoring them is not an easy task because they generally include small code fragments that are different from each other.
complicated operations such as the form template method are required to refactor them.
we also found method pairs thatincluded the language dependent repeated code mentioned in the previous paragraph.
in the category within file there were only method pairs whose structural similarity was high but whose vocabulary similarity was low.
the lowest value of vocabulary similarity was .
.
if two methods are defined in the same class they can use the same private methods and private fields.
that is method pairs in the same class tend to have a higher vocabulary similarity .
figure supports this conclusion.
.
.
.
.
.
.
a across project structural similarity .
.
.
.
.
.
b across project vocabulary similarity figure boxplot representing relationship structural vocabulary similarity distribution and name abstractness for the category across project .
x axis represents the degree of name abstractness.
there are levels of name abstractness.
.
regions b and f method pairs in region b have a high vocabulary similarity but a low structural similarity and different method names.
pairs in region f have a high vocabulary but low structural similarity and the same method names.
in the category across project we found many cases of code reuse between different projects.
after copying and pasting a code fragment it was modified extensively in many cases new statements had been added to the pasted code .
such large modifications lowered the structural similarity between the original code and the structure similarityfrequency .
.
.
.
.
.
a structural similarity vocabulary similarityfrequency .
.
.
.
.
.
b vocabulary similarity figure histogram representing frequency of structural vocabulary similarity for same name differnet name method pairs for the category across project .
the black bars represent frequency of different name method pairs and the red bars represent same name ones.
copied code.
however user defined names were not changed in such modifications.
consequently their vocabulary similarity had been kept high.
we could not find any different characteristics between pairs having the same names and different names.
in the categories within project andwithin directory the structures of method pairs were partially similar to each other.
they should be detected by token based or string based clone detection techniques such as ccfinder .
some method pairs having the public properties construct object properties obj new properties obj.setmessageid val obj.setuserid binary val obj.setto string val obj.setsubject string val obj.setreplyto string val obj.setcorrelationid val obj.setcontenttype symbol va obj.setcontentencoding symbol obj.setabsoluteexpirytime dat obj.setcreationtime date val obj.setgroupid string val obj.setgroupsequence unsigned obj.setreplytogroupid string public attach construct object und attach obj new attach obj.setname string val obj.sethandle unsignedintege obj.setrole role.valueof val obj.setsndsettlemode senderse obj.setrcvsettlemode receiver obj.setsource source val obj.settarget target val obj.setunsettled map val obj.setincompleteunsettled b obj.setinitialdeliverycount obj.setmaxmessagesize unsign if val instanceof symbol obj.setofferedcapabilities obj.setofferedcapabilities ne if val instanceof symbol obj.setdesiredcapabilities obj.setdesiredcapabilities ne obj.setproperties map val figure method pair whose structural similarity is high but whose vocabulary similarity is low different variables are underlined.
bidirectional arrows show statement correspondences.
identical statements are omitted due to space limitations.
same names are semantically the same procedure even if their implementation ways are different.
some of them were overriding the same method in a common parent class.
some method pairs having different names implemented opposite procedures such as uncompress and compress or implemented related procedures such as logical and andoroperators.
in the category within file methods can use the same resources such as private methods or private fields.
this is because their vocabulary similarity tends to be higher.
figure shows the distributions of structural similarity andvocabulary similarity in each category.
this figure shows that vocabulary similarity in the category within file stay higher than the other categories even if their structural similarity is not high.
.
regions d and g in none of the categories did we find false positives regardless of the methods name sameness.
we also found that if both structural similarity andvocabulary similarity were .
their method names were always the same.
in the category across project we found many examples of code reuses between different projects.
in the category within file the method pairs seemed to be good opportunities for performing the extract method refactoring pattern.
if both the similarities of a given method pair are .
their difference exists only in data types for example one is a quicksort implementation for an int array and the other is also a quicksort implementation for a byte array.
in the categories within project andwithin directory such method pairs can be latent opportunities that similar procedures are pulled up to common parent classes.
however methods that are exactly figure vocabulary similarity in each category the same are a minority.
if a given method pair includes different statements we need to use complicated modifications such as the form template method to treat the differences.
in addition if two classes that include methods of a given pair do not have a common parent class we first need to create it.
if either of the two classes has an explicit parent class which means it has an extends clause the class hierarchy must be changed to create a new common parent class.
however creating a new class and changing an existing class hierarchy make up a large task and may be a design level modification.
thus we need to give careful consideration to it.
in other words if two classes already have a common parent class we need less effort to refactor the method pair.
we investigated to what extent method pairs had common parent classes.
in this investigation java.lang.object and the other classes in jdk were not treated as a common parent class.
table shows the result.
we can see that a considerable number of method pairs have common parent classes.
the category within directory has a higher rate of method pairs having a common parent class than the category within project .
interestingly however if we consider only method pairs whose structural similarity andvocabulary similarity are .
the category within project has a higher rate.
it is not a hard task to pull up method pairs if they are completely the same and have a common parent class.
.
toward future research in this section we discuss some directions for future research based on the investigation results.
.
pulling up similar methods in the categories within directory andwithin project we found many pairs of functionally similar methods.
however most of them included different statements from each other.
to promote refactoring of such method pairs we need techniques to help refactoring.
hotta et al.
proposed a technique to identify the differences between a given pair of java methods .
they leveraged program dependence graphs to detect non duplicated statements which should be kept in child classes in a case where we apply the form template method refactoring pattern to a given pair of similar methods.
krishnan and tsantalis proposed a technique to identify a set of statements that should be extracted as a new method .
clone50 .
.
.
.
.0within file structure similarityvocabulary similarity .
.
.
.
.0within directory structure similarityvocabulary similarity .
.
.
.
.
.0within project structure similarityvocabulary similarity .
.
.
.
.
.0across project structure similarityvocabulary similarity .
.
.
.
.
.
0within file vocabulary similaritystructure similarity .
.
.
.
.
.0within directory vocabulary similaritystructure similarity .
.
.
.
.
.0within projet vocabulary similaritystructure similarity .
.
.
.
.
0across projet vocabulary similaritystructure similarityfigure structural similarity based and vocabulary similarity based boxplots detection tools generally identify maximum duplications in source code as clones.
however maximum duplications often include various differences such as different variables different literals or different statements.
their technique identifies duplications that include a small number of differences.
clones detected by their technique are suited to refactoring and developers can create easily reusable methods from detected clones.
hotta s technique suggests method pairs where the form template method pattern can be applied.
however humans may not think suggested method pairs should be refactored.
if removing duplicate code is the primary goal of refactoring it is worth supporting the deletion of duplicate code as far as possible even by using complicated operations.
on the other hand there are many table number of method pairs where common parent classes exist.
the numbers in parentheses are method pairs whose structural and vocabulary similarities are .
a apache within directory within project a all in d and g b common parent rate of b against a .
.
.
.
b uci within directory within project a all in d and g b common parent rate of b against a .
.
.
.
cases where developers do not want to change a class hierarchy or do not want to perform complicated refactoring operations.
krishnan s technique suggests code fragments that can be refactored easily with some duplicate code remaining.
his technique is intended for the extract method pattern.
however the same strategy should prove useful for other refactoring patterns such as pull up method .
there are probably many cases where developers want to perform simple refactorings that leave some duplicate code remaining rather than complicated refactorings designed for removing all duplications.
we need techniques for pulling up a chunk of duplicated code to a parent class with a small amount of effort.
.
detecting semantic clones detecting semantic clones type clones is a challenging research topic.
existing graph based detection techniques can detect a part of semantic clones such as a pair of iterative procedures one is implemented using a forloop and the other is implemented using awhile loop .
however their detection capabilities are not adequate.
kim et al.
proposed a technique that leverages states of memory while a target program is executing .
this technique can detect semantic clones that are not detected by graph based detection techniques.
however we need to prepare many test cases to use this technique.
in addition such a dynamic analysis suffers from scalability issues.
within directory andwithin project method pairs in region f told us that using vocabulary and method name is a good way to detect semantic clones.
such method pairs were often semantic clones in the experiment.
however within file method pairs in two regions were often false positives because they tended to have a higher vocabulary similarity see fig.
.
... package org.apache.activemq.filter ... public abstract class comparisonexpression extends binaryexpression implements booleanexpression ... suppresswarnings rawtypes unchecked protected boolean compare comparable lv comparable rv class ?
extends comparable lc lv.getclass class ?
extends comparable rc rv.getclass if the the objects are not of the same type try to convert up to allow the comparison.
if lc !
rc try if lc boolean.class if convertstringexpressions rc string.class lv boolean.valueof string lv .booleanvalue else return boolean.false else if lc byte.class if rc short.class lv short.valueof number lv .shortvalue else if rc integer.class lv integer.valueof number lv .intvalue else if rc long.class lv long.valueof number lv .longvalue else if rc float.class lv new float number lv .floatvalue else if rc double.class lv new double number lv .doublevalue else if convertstringexpressions rc string.class rv byte.valueof string rv else return boolean.false ... a method compare in project activemq ... package org.apache.qpid.filter ... public abstract class comparisonexpression extends binaryexpression implements booleanexpression ... protected boolean compare comparable lv comparable rv class lc lv.getclass class rc rv.getclass if the the objects are not of the same type try to convert up to allow the comparison.
if lc !
rc if lc byte.class if rc short.class lv number lv .shortvalue else if rc integer.class lv number lv .intvalue else if rc long.class lv number lv .longvalue else if rc float.class lv number lv .floatvalue else if rc double.class lv number lv .doublevalue else return boolean.false ... b method compare in project qpid figure source code of the vocabulary similar method pair whose structural similarity is the lowest .
identifying code reuse between different projects we found many instances of code reuse between different projects in regions b and d .
after copying and pasting code from a different project reused code was modified.
if the modifications were small the pair of original and reused code fell into region d .
if large modifications were performed the structural similarity decreased and it fell into region b .
there were and methodpairs whose vocabulary similarity was larger than .
in apache anduci and all of them seemed to be examples of code reuse by copy and paste operations.
figure shows a method pair whose vocabulary similarity is greater than .
and whose structural similarity is the lowest .
.
although structural similarity is low it is obvious that the pair was made by copying and pasting because the head parts of the two methods are quite similar to each other.
there are several approaches to detect clones between different projects.
they can be classified into two categories fine grained detection and unit level detection .
fine grained detections can identify duplications even if they are only small code chunks in source files.
however their scalability is inferior to unit level detections.
for example livieri et al.
took two days to complete clone detection from million lines of code using personal computers .
unit level detections can identify duplications only if whole units such as file class or method are duplicated.
however they have high scalability.
for example ishihara et al.
took less than two hours to complete clone detection from million lines of code by using a single workstation .
to date there has been no empirical study that has compared across project clone detection results between fine grained and unitlevel detection.
this research shows there is a risk of missing clones even if we use both fine grained and unit level detection techniques.
consequently we need to develop new methodologies for detecting across project code reuse by using code characteristics other than its structure.
.
threats to validity in order to relieve bias due to the dataset being used we used two different datasets in this experiment.
the experimental results which are described in section were almost the same for the two datasets.
consequently we can say that if we use another dataset in the future the result will be almost the same.
however we used only a set of parameters where the minimum length of token sequences was and the minimum number of words was and both of the structural similarity and the vocabulary similarity were .
.
if we use another set of parameters we may obtain different tendencies in the result.
the category within directory means that given two methods are in different files but in the same directory.
directories are generally nested but the top most directories in the source folder should be the deciding factor.
consequently if we had counted for only the top most directories for the category within directory we might have obtained a different result.
we classified method pairs into eight categories based on binary determinations on the three similarities.
then we sampled method pairs from each of the categories.
in such a way the degree of similarities on the structural similarity andvocabulary similaritymay not be considered appropriately.
a random sampling of method pairs based on the similarity values should be an appropriate way.
we used the longest common subsequence algorithm to measure thestructural similarity among methods because it is popular and its computational complexity is not so high.
however there are various ways to detect structurally similar code .
if we had used another way to measure the structural similarity we would have obtain a different distribution of structural similarity among methods.
bellon et al.
compared some techniques that detect structurally similar code .theuci dataset includes the projects of apache software foundation .
consequently the projects extracted from uci dataset may include projects included in apache dataset.
we split camel snake cases performed stemming and removed stop words in extracting vocabulary from source code.
however some of the words were not extracted appropriately due to reasons such as they were short names.
to extract vocabulary more appropriately it would be better to use lawrie et al.
s method .
.
related work tiark et al.
conducted an experiment on type clones5 .
their concern was what kinds of code characteristics contributed to type clone detection.
they revealed that if a given clone pair had a similar word set in their identifiers humans were not likely to reject it.
their result is similar to our result described in section .
.
however they investigated only code that had been detected as clones.
they investigated neither code where the vocabulary similarity was high nor code having the same signature.
abebe et al.
proposed using not only the structure of code but also its vocabulary for predicting fault prone modules .
they confirmed that using vocabulary had improved the accuracy of prediction.
in their experiment predictions using a ck metrics suite were compared with ones using ck metrics and bad smell information of a vocabulary.
the majority of cases using vocabulary with ck metrics improved prediction.
bigger et al.
investigated the vocabulary relationship between comments identifier and literal on projects .
they found that of words in the vocabulary appeared in identifiers.
on the other hand only a few words appeared only in comment or literal.
their investigation is a comparison between comment identifier and literal.
they did not compare vocabulary between projects.
marcus et al.
proposed a class cohesion metric based on code comments and identifiers in code .
in their evaluation they made two bug prediction models one was made from the proposed metric and existing structure based cohesion metrics such as lcom1 the other was made only from existing metrics.
then they compared the bug prediction accuracy of both the models and they confirmed that the proposed metric was useful for bug prediction.
haiduc and marcus investigated how many words in source code were domain terms .
their investigation targets were six graph theory libraries and they found that that of words were domain terms.
the result indicates that methods within a project or domain have the same words in their code.
we did not investigate vocabulary similarity of same domain software.
however our investigation result showed that methods within a project have a higher vocabulary similarity than ones across projects.
our investigation result showed the same trend as their investigation result.
source code clustering is a promising technique for maintaining legacy code or software evolution.
for example clustering can be used for detecting source code that should be re modularized or identifying abstract data types .
maletic and marcus showed that identifying similar modules in a software system was helpful in understanding it .
they utilized latent semantic indexing techniques to make similar module clusters.
such support reduces the developer s cost for finishing a given task when developing or maintaining systems and a developer can finish the task better than without support.
different software programs use different words even if they include the same processing .
this is known as the vocabulary problem which states that no single word can be chosen to de5type clones are duplicate code that include gapped lines.scribe a programming concept in the best way .
bajracharya et al.
developed a system to automatically learn how apis can be used .
they assumed that source code using the same apis implemented similar processing contents even if the source code used different user identifiers such as variable names.
they then developed a technique called structural semantic indexing .
in addition there are methods that automatically identify a set of words related to one another even if they are not related as english words .
corazza et al.
proposed a software clustering technique using vocabulary information .
they classified vocabulary into six categories class name field name method name parameter name comments and statements.
they gave different weights to different categories and clusters are made by weighted vocabulary similarities.
they showed that vocabulary based clustering was more accurate than structure based clustering in the context of remodularization in their experiment.
hotta et al.
compared fine grained and unit level clone detections .
they developed a unit level detection tool that detects similar blocks such as an ifstatement or forstatements in java source code.
they evaluated the tool by using the four java software projects included in bellon s benchmark .
they revealed the unit level detection had enough accuracy but did not have high recall compared to fine grained detectors.
they conducted experiments for each of the projects and they did not target across project clones.
.
conclusion in this paper we investigated the relationships between structural similarity vocabulary similarity and method name similarity of java methods with consideration of their positional relationship which has four categories within file within directory within project andacross project .
our experimental targets were two different sets of open source projects.
for each of the datasets we measured the three similarities on approximately million method pairs.
as a result we found the following.
method names do not always reflect functional code similarity.
if there are a small number of methods that have a given name the methods are likely to include functionally similar code.
existing hash based clone detection techniques at the file level method level and block level miss many instances of copy and pasted code between different projects.
in cases where we use structural similarity for detecting similar code we obtain many false positives.
however most of the false positives are avoidable by using vocabulary similarity in addition to structural similarity .
using vocabulary similarityfor detecting similar code is not suitable for method pairs in the same file because such method pairs use many of the same program elements such as private methods or private fields.
their high vocabulary similarity is due to using the same program elements not due to using the same words.
we also showed some directions for future research based on the experimental results.
they include the following a techniques for pulling up similar methods to the common parent classes b detecting semantic clones and c identifying code reuse between different projects.
.