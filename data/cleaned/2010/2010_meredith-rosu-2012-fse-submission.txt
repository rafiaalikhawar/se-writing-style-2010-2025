efficient parametric runtime verification with deterministic string rewriting patrick meredith university of illinois at urbana champaign urbana il usa pmeredit illinois.edugrigore ro su university of illinois at urbana champaign urbana il usa grosu illinois.edu abstract early e orts in runtime veri cation and monitoring show that parametric regular and temporal logic speci cations can be monitored e ciently.
these approaches however have limited expressiveness since their speci cations always reduce to monitors which are nite state machines.
more recent developments showed that parametric context free properties can be e ciently monitored with overheads generally lower than .
while context free grammars are more expressive than nite state approaches they still do not allow every computable safety property.
this paper presents a monitor synthesis algorithm for string rewriting systems srs .
srss are well known to be turing complete allowing for the formal speci cation of any computable safety property.
earlier attempts at turing complete monitoring have been relatively ine cient.
this paper demonstrates that monitoring parametric srss is practical.
the presented monitoring algorithm uses a modi ed version of the aho corasick string searching algorithm for quick pattern matching with an incremental rewriting approach that avoids reexamining parts of the string known to contain no redexes.
categories and subject descriptors d. .
software program veri cation assertion checkers reliability d. .
software engineering testing and debugging monitors general terms algorithms reliability security veri cation keywords runtime veri cation monitoring string rewriting supported in part by nsf grant ccf and by nsa contract h98230 c .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
copyright 20xx acm x xxxxx xx x xx xx ... .
.
.
introduction runtime veri cation rv is a formal analysis approach in which speci cations of requirements are given together with the code to check as in traditional formal veri cation but the code is checked against its requirements at runtime as in testing.
a large number of runtime veri cation techniques and systems including temporalrover jpax javamac hawk eagle tracematches j lo pql ptql mop pal ruler etc.
have been developed recently and the overall approach has gained enough traction to spawn its own conference .
in a runtime veri cation system monitoring code is generated from the speci ed properties and integrated with the system to monitor.
therefore a runtime veri cation approach consists of at least three interrelated aspects a speci cation formalism used to state properties to monitor a monitor synthesis algorithm and a means to instrument programs.
the chosen speci cation formalism determines the expressivity of the runtime veri cation approach and or system.
monitoring safety properties is arbitrarily complex .
early developments in runtime veri cation showed that parametric regular and temporal logic based formal speci cations can be e ciently monitored against large programs.
a parametric monitor associates monitor states with di erent object instantiations for the given parameters.
this allows for speci cation of properties about the relationships of objects e.g.
a relationship between a collection object and its associated iterator objects in java1.
as shown by experiments with tracematches and the most recent experiments using javamop parametric regular and temporal logic specications can be monitored against large programs with little runtime overhead on the order of or lower.
however both regular expressions and temporal logics are monitored using nite automata so they have inherently limited expressivity.
more speci cally most runtime veri cation approaches and systems consider only at execution traces or execution traces without any structure.
consequently users of such runtime veri cation systems are prevented from specifying and checking structured properties those properties referring to the program structure such as properties with requirements on the contents of the program call stack.
pql hawk eagle and ruler provide more expressive logics but these are relatively ine cient .
more recently javamop was extended to support e cient context free monitors with runtime overheads very similar to 1typestates a popular concept in software engineering and software analysis can be monitored with parametric monitors that have only one parameter.public class randomequality int numberofnumbers public randomequality int numberofnumbers this.numberofnumbers numberofnumbers public int nextnumber return gennextnumber numberofnumbers public boolean hasnextnumber return numberofnumbers private int gennextnumber int currentnumber some logic that may or may not be correct figure a java class that provides random number sequences of any length that maintain equality the earlier nite state logics .
while this work allows for checking many structured properties it does not have the full power to specify any possible safety property.
in this paper we introduce an algorithm for monitoring parametric deterministic string rewriting systems to serve as an e cient runtime veri cation technique for specifying and monitoring arbitrarily complex properties indeed string rewrite systems are known to be as expressive as turing machines .
we also provide an implementation of our algorithm as an mop logic plugin so it can be used as integral part of the javamop runtime veri cation system.
by abuse of vocabulary we will refer to deterministic string rewriting systems as string rewriting systems and abbreviate them srss.
.
examples safety properties that require more expressivity than a context free language are generally more intimately related to the speci cs of the program under veri cation test than those that may be monitored using context free or nite logics.
conversely less speci c properties such as correct api usage tend to be nite state .
as a relatively simple and admittedly contrived example of a non context free property consider the java class randomequality de ned in figure .
the idea of this class is to provide a random string of numbers from the set f0 2gof a given length de ned by the parameter passed to the constructor that maintains equality that is that the number of s is equal to the number of s is equal to the number of s. the javamop speci cation presented in figure which uses the new srslogic plugin is able to catch any failures of this class to provide equality.
javamop speci cations begin with a declaration of the name of the speci cation and parameters.
here the property is named equalitycheck and one parameter reof type randomequality .
the parameters allow us to associate separate monitor states with each object instantiation of the parameters.
in this case with one parameter there will be one monitor state associated with each object instance of randomequality in the program under test.
this is important because we would not wantequalitycheck randomequality re event done after randomequality re returning boolean b call randomequality.hasnextnumber target re condition !b event e0 after randomequality re returning int i call randomequality.nextnumber target re condition i event e1 after randomequality re returning int i call randomequality.nextnumber target re condition i event e2 after randomequality re returning int i call randomequality.nextnumber target re condition i srs e1 e0 e0 e1 .
e2 e0 e0 e2 .
e2 e1 e1 e2 .
e0 e1 e .
e e1 e1 e .
e e0 e0 e .
e e2 epsilon .
e2 e epsilon .
done succeed .
e0 done fail .
e1 done fail .
e2 done fail .
succeed system.out.println p.tostring worked perfectly!
fail system.out.println p.tostring failed!
figure a javamop speci cation that nds equality failures in the randomequality class calls to di erent object instances of the randomequality class to interfere with each other as such would assuredly lead to false positives and negatives.
the next part of a javamop speci cation is the declaration of events.
here we are able to generate four di erent events done e0 e1 and e2.
the events are de ned using a superset of aspectj advice with embedded pointcuts.
here the event done is de ned to occur when thehasnextnumber method is called and returns false signalling the end of the randomly generated number string2.
the events e0 e1 and e2all correspond to calls of nextnumber where the proper number in f0 2gis returned.
after the event de nitions we list the formalized property.
the keyword srstells javamop that the following property will be a deterministic string rewriting system.
rules in our srs formalism take the form l!r .
meaning that the string of events on the left hand side of the arrow rewrites to that on the right side.
the three rules on the rst line of this srs sort the events all e0come before all e1which come before all e2.
the rule e0 e1!edenotes that we have 2note that this requires properly calling hasnextnumber before calling hasnextnumber .
this can be ensured in javamop using a di erent nite state property.found a pair of e0and e1 which must be matched by an e2.
note that the srs rules can be applied in any order when a new event is received so it is user s responsibility to write con uent srss or to use the deterministic order of rule application explained in section .
.
the two rules on the third line move all instances of eto the right so that they will eventually become adjacent to any instances of e2.
the two rules on line four correspond to when such a situation occurs.
when eis adjacent to e2we have found a triple and we can safely remove the symbol efrom the string by rewriting it to epsilon which is a keyword speci c to the srs formalism in javamop.
the next rule is the success case which occurs when done is at the beginning of the string denoting that all s s and s have been equal .
the symbol corresponds to the beginning of the string.
similarly corresponds to the end but is not used here.
succeed is a special keyword that stops the rewriting process with the monitor signalling that a success was found.
like succeed fail is a keyword that stops the monitor with a failure returned.
the next three lines are the failure cases each rewrites to fail .
they occur when the number of s s and s was not equal because the string will always be empty when a done occurs if they were properly balanced.
the failure cases rely on the incremental nature of the string rewriting process.
if taken as a normal srs with complete strings as input this would not be con uent.
that means the choice of what order to apply rules would result in di erent normal forms see section .
.
because the normal form is computed between the arrival of each event e0 e1 or e2can only occur before done in the string if an unequal number occurred.
the string rewriting process is explained fully in sections .
.
.
the last part of a javamop speci cation is the handler section.
handlers are arbitrary java code that is executed when the monitor raises a particular condition.
here the keywords succeed and fail denote that the code within the subsequent braces is run when the string rewrites to succeed or fail respectively.
in this example the handlers simply print out informative messages when such situations occur.
in general handler code may be used for anything such as running a speci c algorithm or recovering from the error denoted by the failure of the safety property in question.
aside from specifying properties which cannot be expressed by context free grammars string rewriting systems can be useful for expressing context free and nite properties in a natural and often times more compact form.
below are two properties from earlier papers written as srss.
the rst property called hasnext is a property of the java iterator interface stating that hasnext should always be called and return truebefore next is called.
below it is speci ed as a regular expression hasnexttrue next next the corresponding srs is as follows hasnexttrue next !
epsilon hasnexttrue hasnexttrue !
hasnexttrue next!
fail while this srs is certainly larger than the original ere it may be easier to understand by some users because it directly captures the semantics of the property by simply enumerating all the cases that one has to worry about.
the rule hasnexttrue hasnexttrue !hasnexttrue conveys the notion that multiple calls to the hasnext method are idempotent.hasnexttrue next rewrites to epsilon because it is a safe operation.
if next is seen at the beginning of the string a failure is raised as hasnexttrue was not properly called.
because our algorithm is incremental and deterministically rewrites from left to right it is not strictly necessary to match the beginning of the string but it is more clear conceptually.
the second property is a properly context free property called safelock which corresponds to the proper nesting of acquiring and releasing locks.
proper nesting in this case means that corresponding calls to acquire and release occur within the same method body.
here begin and end denote the beginning and end of a method body.
s!
jsacquiremreleasea m!
jmbeginmendjmacquiremrelease a!
jabeginjaend the property is fairly complex and a complete explanation can be found in .
the srs for the property follows begin end!
epsilon acquire release!
epsilon begin release!
fail acquire end!
fail in this case the srs is quite a bit less complex than the context free grammar specifying the same safety property.
again it conveys interesting semantic information.
from the srs it is clear that a begin followed immediately by a release results in an error because we require all release to occur in the same method call as the corresponding acquire .
similarly an acquire follow by a endresults in an error because the lock is not correctly released within the method body.
begin end and acquire release rewrite to epsilon because they are properly nested when they occur adjacently.
.
contributions there are two main contributions to this paper an e cient optimized string rewriting algorithm.
it builds upon a modi cation of the aho corasick algorithhm .
the original algorithm was designed for quickly nding strings in text.
our modi ed algorithm keeps track of substitution boundaries so that a rewrite step can be performed in time linear to the length of the right hand side of the matched rule3.
to our knowledge this is the rst time it has been applied to string rewriting.
an optimization has also been devised which checks for early termination of rewriting.
an implementation and extensive evaluation of the above algorithm as an mop logic plugin for runtime veri cation.
this way it can serve as a speci cation formalism for parametric safety properties in instances of the mop framework such as javamop.
we show that its performance in practical runtime veri cation of large systems is acceptable when compared to other means to specify the same properties.
additionally we show that it outperforms one of the state of the art rewrite engines maude which implicitly supports string rewriting as rewriting modulo associativity.
.
paper outline section presents related work in the eld of runtime veri cation popular runtime monitoring systems with a 3the right hand side must be copied so that the rule is still viable the next time it matches.approach logic scope mode handler jpax ltl class o ine violation temporalrover mitl class inline violation javamac pastltl class outline violation hawk eagle global inline violation ruler ruler global inline violation tracematches reg.
exp.
global inline validation j lo ltl global inline violation pal modi ed blast global inline validation pql pql global inline validation ptql sql global outline validation figure a selection of monitoring systems particular emphasis on those with greater than nite state speci cation languages and on our framework of choice for our implementation and experimental testbed mop.
section presents our string rewriting algorithm with its use and construction of pattern match automata and and optimization that allows for early termination.
section presents our experimental results and section concludes.
.
related work and mop many approaches have been proposed to monitor program execution against formally speci ed properties.
interested readers can refer to for an extensive discussion on existing runtime monitoring approaches.
brie y all runtime monitoring approaches except mop have their speci cation formalisms hardwired and few of them share the same logic.
there are four orthogonal attributes of a runtime monitoring system logic scope running mode and handlers.
the logic speci es which formalism is used to specify the property.
the scope determines where to check the property it can be class invariant global interface etc.
the running mode denotes where the monitoring code runs it can be inline weaved into the code online operating at the same time as the program outline receiving events from the program remotely e.g.
over a socket or o ine checking logged event traces .
the handlers specify what actions to perform under exceptional conditions such conditions include violation and or validation of the property.
it is worth noting that for some logics violation and validation are not complementary to each other i.e.
the violation of a formula does not always imply the validation of the negation of the formula.
mop allows for handlers for any number of user de ned exceptional situations called handler categories .
most runtime monitoring approaches can be framed in terms of these attributes as illustrated in figure which shows an incomplete summary of runtime monitoring systems.
for example jpax can be regarded as an approach that uses linear temporal logic ltl to specify class scoped properties whose monitors work in o ine mode and only detect violation.
in general javamop the java instance of mop has proven to be the most e cient of the runtime monitoring systems despite being generic in logical formalism.
of the systems mentioned in figure only pql hawk eagle and ruler provide logical formalisms with greater than nite state power.
hawk eagle adopts a turing complete x point logic but it has problems with large programs because it does not garbage collect the objects used in monitoring.
in addition hawk eagle is not publicly available4.
because of this and the fact that hawk eagle makes an argument for the ine ciency of hawk eagle.has not been run on dacapo with the same properties we cannot compare javamop with our new string rewriting systems plugin with hawk eagle.
rulerr is a rule based monitoring system which has the ability to also specify turing complete properties.
the current implementation of ruler is not built for e ciency and is additionally not publicly available.
pql is not turing complete and performance comparisons with pql using an older less e cient version of javamop can be found in .
string rewriting was used in the context of monitoring for detection of malware in .
this was in many ways the inspiration for adding string rewriting to mop.
however the string rewriting patterns allowed in that work were regular i.e.
can capture only regular languages while our goal is to provide a true turingcomplete logical formalism for parametric monitoring.
mop is an extensible runtime veri cation framework that provides e cient logic independent support for parametric speci cations.
javamop is an instance of mop for the java programming language.
it allows the developer to specify desired properties using formal speci cation languages along with code to execute when properties are matched or fail to match.
monitoring code is then automatically generated from the speci ed properties and integrated together with the user provided code into the original system.
mop is a highly extensible and con gurable runtime verication framework.
the user is allowed to extend the mop framework with his her own logics via logic plug ins which encapsulate the monitor synthesis algorithms.
this extensibility of mop is supported by an especially designed layered architecture which separates monitor generation and monitor integration.
by standardizing the protocols between layers modules can be added and reused easily and independently.
mop also provides e cient and logic independent support forparametric parameters which is useful for specifying properties related to groups of objects.
this extension allows associating parameters with mop speci cations and generating e cient monitoring code from parametric speci cations with monitor synthesis algorithms for non parametric speci cations.
mop s generic support for parametric patterns simpli ed our srs plug in s implementation.
the javamop instance provides two interfaces a webbased interface and a command line interface providing the developer with di erent means to manage and process javamop speci cations.
aspectj is employed for monitor integration javamop translates outputs of logic plug ins into aspectj code which is then merged within the original program by an aspectj compiler.
seven logic plug ins are currently provided with javamop nite state machines extended regular expressions context free grammars past time linear temporal logic linear temporal logic with past and future operators past time linear temporal logic with calls and returns and now string rewriting systems.
descriptions of the rst six plugin ins can be found in .
.
monitoring srs specifications in this section we present some basic notation for string rewriting systems and our string rewriting algorithm which was implemented as a logic plugin in the mop framework.
since hawk eagle is not publicly available only its rewrite based algorithm is public the authors of hawk eagle kindly agreed to monitor some of the simple properties from .
we have con rmed the ine ciency claims of with the authors of hawk eagle.
.
preliminaries we refer the reader to for an in depth presentation of string rewrite systems.
for an alphabet astring rewriting system srs is a binary relation r on that is a subset of .
the setfl2 j l r 2rgis called the domain of r denoted dom r while similarly the set fr2 j l r rgis called the range denoted range r .
we refer here to any element l r 2ras a rule inr any l2dom r as a left hand side lhs of a rule in r and any r2range r as a right hand side rhs of a rule in r. in our srs speci cations in this paper and in javamop rules l r 2r are written using the earlier shown syntax l!r .
the single step reduction relation on that is induced byris de ned as for any u v2 u!rvif and only if there exists l r 2rsuch that for some x y2 u xly andv xry.
the reduction relation on induced by ris the re exive transitive closure of !rand is denoted by !
r. if forx y2 x!
ryandyis irreducible yis anormal form forx.riscon uent if there is only one such yfor any givenx regardless of the order in which rules are applied.
in our srss in mop the symbols s2 correspond to either events of our property or symbols that appear in the rhs of rules in r. we call our string rewriting systems deterministic because the same normal form will always be chosen in the presence of a non con uent r. speci cally rules are applied left to right with the smallest rule matching rst in the case of overlap e.g.
for lhss a aand a a b the rule with a aas its lhs will always be applied rst starving the other rule .
in the case of a con ict that is not resolved by the above the order of rules in the srs speci cation is used to determine which rule to apply e.g.
if two rules have the same lhs the one speci ed rst will always be applied .
.
string rewriting algorithm overview there are two major parts to our srs algorithm .
finding matches of the lhss of rules and .
performing replacements with rhss of rules.
to make replacements as e ciently as possible the string of events symbols that we rewrite is a linked listed of the splicelist class which was specially created for our purposes to allow constant time replacement of a section of the list with another list splicing .
the splicelist class has a special type of iterator de ned for it called the sliterator that does notfollow the normal iterator interface in java.
rather than only having next and hasnext methods the sliterator has next int i which moves the sliterator forward itimes and returns true if it is successful i.e.
does not reach the end of the splicelist and get which returns the current element that the sliterator points to.
sliterator also has a method splice sliterator second splicelist replacement which takes another sliterator to the same splicelist and replaces the sequence denoted by those two sliterator s inclusively by a speci ed sequence replacement.
it is because of the inclusive nature of the splice method that the sliterator must have a method to retrieve its current element without advancing.
the splice method makes it imperative for our string matching algorithm to maintain sliterator s to the beginning and end of the current lhs under consideration.
in section .
we discuss how this matching occurs using a modi cation of the aho corasick string searching algorithm that unlike the base algorithm keeps track of the beginning of a match so that rewrites can be performed in constant time after copying the rhs in time proportional toits length .
to make the paper self contained we give all the necessary information regarding the aho corasick algorithm rather than only this modi cation but the modi cation is clearly delineated.
to our knowledge this is the rst time any variation on the aho corasick algorithm has been used in string rewriting and no implementations of srss exist that we could nd.
in section .
we present an in depth explanation of how the pattern matching ts into the string rewriting algorithm and how we optimize string rewriting to avoid considering sequences that cannot match any lhs.
.
pattern match automata the pattern match automata used by our string rewriting process as mentioned is a modi cation of the aho corasick algorithm for nding strings in text .
the aho corasick algorithm which was originally not designed for string rewriting is able to nd all matches in a string in one linear pass rather than performing separate passes for each rule lhs as would a naive matching algorithm.
our modi cation of the algorithm allows us to correctly adjust the sliterator to the beginning of our current match facilitating quick rewrites.
.
.
using pattern match automata figure shows the pattern match automaton for the safelock property.
each node has at least its state number and state depth listed as a pair number depth .
the depth is used in two places in the automata generation algorithm and simply states how many symbols events have been processed since the start state in one of the lhss of the rewrite rules in our srs.
this will be explained in more detail below.
additionally states which correspond to matching the left hand side of a given rule also display that rule e.g.
in state the begin release!
fail rule is matched.
each edge is marked by the list of symbols that cause that transition as well as a number following a .
that number which we refer to as the action is the number of times to increment the rst sliterator except in the self transitions of state .
when a self transition in state occurs the rst iterator must be incremented once.
when a forward transition with is encountered a transition to the next state is made and the next input is considered.
if the transition is su xed with something other than the transition must be a backward transition and the same symbol that is currently under consideration must be evaluated in the next state.
this is why we handle self transitions in state as a special case if it were su xed with and handled as a backward transition the same symbol would be considered in nitely.
figure shows the pseudocode for pattern matching using a given pattern match automaton.
the only global variable for the algorithm is the given patternmatchautomaton pma.
the algorithm begins by initializing the rst and second sliterator s to the beginning of the argument splicelistl using thehead method.
the local currentstate is initialized to the initial machine state here represented as .
the while loop beginning on line will only exit when the end of lis reached denoted by the break statements on lines and .
we know that the end of lis reached on lines and when the next int i method returns false.
we never need to check if rst.next returns false because it may never advance past second due to the construction of the patternmatchautomaton .
lines cover the self transition 5it is actually a class that may contain a matched rule as we can see in figure .acquire 0begin acquire end begin end acquire release 2begin end acquire release release 0end release release 0begin acquire 1begin end acquire release 2begin 0begin end acquire release end begin end !
epsilon acquire end !
fail acquire release !
epsilon begin release !
fail figure pattern match automaton for the safelock property see section .
to state mentioned earlier while lines represent a normal forward transition.
are a forward transition because the action of the transition is .
as mentioned earlier the only di erence between the self transition and a forward transition is that in the self transition the rst sliterator need be incremented line .
lines handle a backward transition in the patternmatchautomaton .
as expected with a backward transition the rst sliterator is incremented a number of times speci ed by the action of transition and second isnotincremented so that the same symbol will be considered in the next iteration of the loop.
one interesting property of this algorithm is that if one pattern is a pre x of another such as the patterns aa!c and a a b!d both matches will be reported.
this is undesirable behavior for rewriting because aa will be rewritten to cimmediately and a a b should no longer be matchable.
this will be accounted for in section .
.
as an example of how the pattern match algorithm functions suppose that the following series of events have been seen at a given point in a program begin begin acquire begin end.
at this point the safelock property will experience its rst match of a rule lhs.
figure shows the state transitions as each symbol is considered as well as the position of the rst sliterator .
an important thing to note is that every time we transition back to state the rst sliterator index is incremented by speci ed by the back transitions and the symbol is evaluated again in state .
in general back transitions need not be to state as we shall see.
at the end of the input the algorithm is in state which matches the rule begin end!
epsilon .
the rst sliterator correctly points to index which is the last begin event.
the second sliterator always points at the current input which is end.
these sliterator s can then be used to quickly replace begin endwith epsilon as we will see in section .
.
.
.
generating pattern match automata there are two main phases to the creation of pattern match automata.
in the rst phase the forward transitions of the automaton are created.
in the second phase all of the backward transitions and the self transition that almost always exists in state are added.
during the computation of the backward transitions the actions for the backward transition are also computed and added to the backward transitions.
as mentioned only backward transitions ever have non actions since they correspond to places in the automaton where there is a switch from matching one potential set of lhss of rules to another.
for instance in figure between the third begin and the rst acquire there is a switch from potentially matching fbegin end begin release gtofacquire end acquire release g which requires no longer considering thebegin event for match purposes thus the action of .
to create the forward transitions for an automaton we add one path that corresponds directly to the left hand side of each rule in our string rewriting system.
we add these paths one at a time and reuse as many states as possible.
each forward transition is assigned the action .
figure shows the forward transitions for the pattern match automaton originally presented in figure .
for each lhs we begin at state and add a transition for the rst symbol.
because all patterns safelock begin with either begin oracquire we have only two transitions one labeled with begin and one labeled with acquire .
we continue to transitively add transitions based on the remainder of each lhs.
for the two rule lhss beginning with begin one ends with endand the other ends with release so there are two transitions out of state labeled accordingly.
as each new state is added to the machine during the forward transition phase the depth of the state is recorded.
the depth is simply the number of symbols from state .
for instance state is at depth since two symbols begin followed by end lead to state .
the largest depth always corresponds to the longest rule lhs.1globals patternmatchautomaton pma 2locals sliterator rst second state currentstate nextstate symbol symbol transition transition 6procedure match splicelistl rst l head 8second l head 9currentstate 10while true f if currentstate hasmatch f signal match 13g symbol second get transition pma get currentstate symbol 16nextstate transition state if nextstate f rst next if second next f break 21g 22g else if transition action f if second next f break 26g 27g elsef rst next transition action 30g currentstate nextstate 32g figure pattern match algorithm current state symbol next state rst index begin begin begin acquire acquire begin begin end figure a run of the pattern match algorithm on begin begin acquire begin end 2begin 0acquire end 0release acquire 0end figure forward transitions for safelock matched rules omitted in the second phase the self transition on state is added rst if needed.
the self transition is only necessary if there is not a forward transition out of state for every symbol used in the srs or speci ed by the javamop front end6.
after potentially adding the self transition in state the backward transitions are added to the pattern match automaton.
backward transitions are only added from a given state for symbols that do not have forward transitions out of that state.
all backward transitions from a given state s will go to the same place so we de ne fail s s0 wheres0 is the destination of a backward transition out of s. to nd the destination for the backward transitions out of a state in pattern match automaton pma with depth d we consider each staterof depthd 1and perform the following actions transitions are added in depth rst order .ifpma.get r a is a backward transition for all symbols a do nothing.
.otherwise for each symbol asuch that pma.get r a s do the following a lets0 fail r .
b compute s0 fail s0 until such point as pma get s0 a action .
because state must have either a forward transition or a self transition for every symbol such an s0must exist.
c for alla0such that pma get s a0 has no forward transition assign pma get s a0 state s0 pma.get s a0 .action s.depth s .depth .
the procedure above is essentially the same as .
the part in bold is speci c to our algorithm for string rewriting.
the action is assigned as such because the depth of a given state represents the number of symbols processed since state in the automaton thus the di erence in the depths tell us the number of symbols that we need to skip with the rst sliterator in figure .
while the pattern match automaton forsafelock has backward transitions that only go to state as mentioned this is not always the case in general.
when the su x of one lhs overlaps with the pre x of another backward transitions that do not go back to state are generated.
an example of this can be seen in figure where the srs in question is b a a!
epsilon a a c!
epsilon .
because b a a and a a c have a su x pre x overlap the backward transitions from state at depth go to state at depth resulting in an action of only .
for example consider input b a a c .
when we switch from matching b a a to matching a a c which occurs between states and we wish to only forget the bat the beginning an action of .
.
rewriting using pattern match automata the rewriting algorithm we use to monitor srs s is presented in figure .
not pictured in figure is the action of the monitor itself.
as any monitoring algorithm in the mop framework events arrive one at a time.
as each event occurs we add it as a symbol representing that event to asplicelist that contains the results of rewriting previous sequences of events.
additionally if any rules make use of the symbol it will be added to the beginning of the splicelist 6javamop allows one to de ne events that do not appear in the speci ed property these will correspond to symbols that are never rewritten by the speci ed srs.c b a a c b 1a c b a b a 0c a c 0c b 1b a c b b a a!
epsilon a a c!
epsilon figure a pattern match automaton with overlap and treated as a normal symbol by the rewriting algorithm.
as for uses of the current event must be added before .
after an event is added to the splicelist the algorithm in figure is evaluated to completion before another event can be accepted.
the algorithm is similar to the pattern match procedure of figure .
the changes are in bold.
there are three main changes the inclusion of a loop that ensures that a normal form is reached the actual rewriting step itself and a section that recognizes early termination.
the rst new control structure to notice is the do...while loop from line to .
this loop ensures that rewriting continues until there is a pass through the loop in which nothing changes i.e.
the string is in normal form.
the new boolean variable changed controls this loop.
it is set to false at the beginning of an iteration of the do...while loop and to trueon line which is only executed when a rewrite occurs.
lines perform the actual rewriting step.
the element match of a state contains the right hand side of the rule matched in that state .
if the match is one of the two special keywords succeed or fail a success or fail handler is executed as appropriate and rewriting terminates.
if either handler is executed the monitor is considered dead unless it is reset see .
if match is something else the splice method is called on line .
the splice method is a special method of sliterator that replaces a range speci ed by the thisand an argument sliterator with the argument sequence.
here the range is speci ed by rstandsecond and currentstate .match 7because of this there is a very small performance hit for using in a rule but is essentially free.1globals patternmatchautomaton pma 2locals sliterator rst second last state currentstate nextstate symbol symbol transition transition boolean changed pastlast 7procedure match splicelistl 8dof rst l head second l head currentstate changed false pastlast false while true f if currentstate hasmatch f if currentstate .match succeed f raise succeed g if currentstate .match fail f raise fail g rst.splice second currentstate .match nextstate changed true pastlast false last second second rst.copy 28g symbol second get transition pma get currentstate symbol 31nextstate transition state if nextstate f rst next if second next f break 36g 37g else if transition action f if second next f break 41g 42g elsef rst next transition action 45g if changed f if second last f pastlast true g if pastlast andnextstate f return g g currentstate nextstate 55g 56gwhile changed figure rewriting algorithmevent initial l l in normal form begin begin begin end begin end epsilon begin begin begin acquire begin acquire begin acquire release begin acquire release begin acquire begin acquire begin acquire end begin acquire end fail figure an srs monitoring run for safelock is passed as the replacement.
note that if the right hand side of the rule is epsilon it is represented as an empty sequence which splice is able to handle.
the splice method also correctly sets rst and second to point to the beginning and end of the spliced in match sequence or the next symbol ifmatch was epsilon .
on line we set lasttosecond so that lastpoints to the end of the last replacement this will be used to determine early termination.
then on line second is set as a copy of rst.
this ensures that segments of string which are transitively rewritten will be rewritten immediately.
because splice changes the splicelist it is important to set currentstate back to state because any matching will occur in the newly rewritten segment of the splicelist .
in the last new addition to the match algorithm from lines to we test for early termination of the algorithm.
the idea here is to exit early if we enter a segment of the splicelist that we know for certain cannot be rewritten.
this happens when we reach a point that is past the end of the last sliterator which was set in a previous iteration no rewrites have occurred in the current iteration and currentstate returns to .
the rst two requirements are fairly straight forward if a change occurs new matches are possible and if we are in a segment of the splicelist before the last rewrite we are still investigating symbols that are potentially new.
however if there is no rewrite in the current iteration and we are past the last change from the previous iteration we are seeing symbols that were seen in the previous iteration with no change.
the last condition that we must return to state is more subtle.
the reason for this is that there could have been a rewrite in the last iteration that inserted a segment that appears in the middle of a left hand side of one of the rules.
a simpler way to look at this requirement is that if pma is not in state it is actively matching something .
this condition for early termination can lead to an unbounded amount of saving as thesplicelist can be of an unbounded length.
figure shows a monitor run as non parametric events for safelock arrive.
the non parametric events are dispatched to the correct monitor instance by the indexing of javamop or whatever projection method is used in future language instances of mop .
the rst column shows the arriving event the second column shows the state of the splicelistl before any rewriting and the last column shows the normal form forlafter the rewriting algorithm of figure has run.
after the last event a failure has occurred and the fail handler will execute.
.
evaluation our srs implementation is evaluated in two contexts rst we show how it compares within the context of javamop to nite state logics on the dacapo benchmark suite .then we give a comparison of our underlying srs rewrite engine against the maude term rewriting engine modulo associativity.
the goal of the rst evaluation is to show that srs monitoring is e cient enough to be used in large programs being not much less e cient than nite state logics extended regular expressions in this case .
the goal of the second experiment is to show that our srs implementation is more e cient than the state of the art8.
all experiments were performed on a machine with a .82ghz intel r coretmi7 hexcore with hyper threading hardware threads and gb of ram.
ubuntu .
bit was used as the operating system and version .
of dacapo was used as the benchmark suite with default inputs and the converge option to gain convergence within .
openjdk version .
.
as the java virtual machine.
all compiled javamop specs were weaved into dacapo using ajc .
.
.
maude .
was used for comparison with maude.
the following properties were used in the dacapo experiments.
the srs versions of them shown below are new while the extended regular expression versions were borrowed from .
hasnext do not use the next element in an iterator without checking for the existence of it see section .
safesynccol if a collection is synchronized then its iterator also should be accessed synchronously sync asynccreateiter !
fail sync synccreateiter accessiter !
fail safesyncmap if a collection is synchronized then its iterators on values and keys also should be accessed in a synchronized manner sync createset asynccreateiter !
fail sync createset synccreateiter accessiter !
fail unsafeiter do not update a collection when using the iterator interface to iterate its elements update use!
fail use use!
use update update!
update createiterator!
epsilon unsafemapiter do not update a map when using the iterator interface to iterate its values or its keys update use!
fail use use!
use update update!
update createiterator!
epsilon createcollection !
epsilon for the comparison with maude strings of equal numbers of s s and s with the s preceding the s preceding the s were generated and the following rewrite system applied.
note that the language of strings that reduce to epsilon with this rewrite system is non context free.
it is very similar to equalitycheck from section .
.
!
!
!
!
!
!
!
epsilon !
epsilon 8note that maude is more general than our srs engine but there is a price for that generality and general term rewriting makes little sense in the context of mop event traces.benchmark original ms hasnext safesynccol safesyncmap unsafeiter unsafemapiter ere srs ere srs ere srs ere srs ere srs avrora batik eclipse fop h2 jython luindex lusearch pmd sun ow tomcat tradebeans tradesoap xalan figure comparison of javamop with extended regular expressions ere and with the same properties expressed as string rewriting systems srs average percent overhead convergence within except those marked with n maude time ms srs time ms dnf dnf figure comparison of maude versus srs rewrite.
dnf did not nish in one hour figure shows a comparison of nite state properties speci ed in javamop using ere and srs.
the rst column shows the individual dacapo benchmarks and the second column shows runtime of the original uninstrumented benchmarks in milliseconds.
all other columns are percent overhead.
each benchmark property pair converged to within except the instances of avrora marked with .
the results presented for avrora that did not converge are the average of twenty runs with outliers removed but they are still not as trustworthy as the converging results.
this lack of convergence is a problem on highly multithreaded machines.
we can see that even the uninstrumented original run fails to converge.
negative overheads are the result of noise in the experimental settings and changes in code layout due to instrumentation resulting in slightly more e cient programs.
overall the average overhead on the dacapo benchmark suite was for srs while it was for ere.
when fop hasnext which has by far the worst overhead of any trial is removed from both the overhead drops to and respectively.
it must be noted that the properties we use are speci cally selected for generating large overheads they are very intensive properties that generate many events see .
the overhead numbers are slightly larger than reported in previous papers because we have moved to a multithreaded and quite simply faster machine.
the monitors in javamop must be synchronized which results in higher overhead for programs that actually make use of multiple threads.
any monitoring system must do the same thing ifthe monitors are for cross thread properties like all of those properties used here .
in most of the benchmark property pairs the performance of ere and srs are very comparable.
for pmd hasnext and avrora safesyncmap srs shows more than three times the overhead of ere but for all other trials srs is never more than three times worse.
figure shows the comparison of maude to our srs engine with the rewrite system discussed above.
n refers to the number of each digit i.e.
n has characters in it each of and .
as we can see from the results our srs engine runs in of the time of maude at n .
at n our srs engine runs in .
of the time of maude.
with larger inputs maude fails to complete in an hour while our srs engine takes less than seconds on every tested input.
.
conclusion we provided the rst means to e ciently monitor parametric turing complete speci cations using string rewriting systems.
by using a modi ed version of the aho corasick string matching algorithm and a means to terminate the rewriting process early the resultant string rewriting algorithm is quite practical as shown in our extensive evaluation9.
the average overhead on the dacapo benchmark suite was for srs while it was for ere.
when the largest benchmark property pair is removed from both the overhead drops to and respectively.
a less extensive comparison of our core string rewriting algorithm with the term rewrite engine maude which provides implicit support for string rewriting through its rewriting modulo associativity suggests that our approach can lead to new string rewriting engines that outperform the state of the art.
9special thanks to dongyun jin for help with dacapo experimental settings.
.