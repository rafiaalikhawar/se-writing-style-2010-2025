targeted test input generation using symbolic concrete backward execution peter dinges university of illinois urbana champaign usa pdinges acm.orggul agha university of illinois urbana champaign usa agha illinois.edu abstract knowing inputs that cover a speci c branch or statement in a program is useful for debugging and regression testing.
symbolic backward execution sbe is a natural approach to nd such targeted inputs.
however sbe struggles with complicated arithmetic external method calls and datadependent loops that occur in many real world programs.
we propose symcretic execution a novel combination of sbe and concrete forward execution that can e ciently nd targeted inputs despite these challenges.
an evaluation of our approach on a range of test cases shows that symcretic execution nds inputs in more cases than concolic testing tools while exploring fewer path segments.
integration of our approach will allow test generation tools to ll coverage gaps and static bug detectors to verify candidate bugs with concrete test cases.
categories and subject descriptors d. .
testing and debugging symbolic execution keywords concolic symcretic backward execution goal directed .
introduction the distribution of bugs in real world programs tends to be highly non uniform .
thus a test suite that covers most of a program may nevertheless fail to cover the parts that contain many bugs.
generally the goal of test generation tools is to maximize the overall coverage .
however it has been argued that this yields test inputs that are often of limited use for developers .
we take an alternative approach our goal is to automatically nd targeted test inputs that cover a speci c branch or statement in the full version of this paper is available as uiuc technical report september .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
code.
developers can then use such targeted inputs for example to triage a reported bug or to verify that a suspicious instruction pattern is an actual problem or to add a test case to cover a speci c code change .
a natural approach for nding targeted inputs is to use symbolic backward execution sbe .
sbe explores a program in the reverse direction of normal forward execution.
starting from a speci c target statement sbe continues until it reaches an entry point thus considering only those execution paths that can reach the target.
by collecting a set of constraints the path condition during this exploration sbe builds a symbolic characterization of the execution path it explored.
a path condition is similar to a weakest precondition solving it yields inputs that drive the program down the characterized path to cover the target.
unfortunately symbolic backward execution poses some challenges because path conditions may contain arbitrary integer constraints they may be undecidable or solving them may be computationally infeasible.
in this case when asked to check the satis ability of a path condition a decision procedure may reply unknown .
symbolic decision procedures cannot reason about external methods such as native methods in java.
data dependent loops can require an arbitrary number of iterations to nd a satis able path condition leading to an unbounded search space.
following the general idea of concolic execution we show how to combine symbolic backward execution with concrete execution to e ciently nd targeted inputs despite these challenges.
our approach called symcretic execution operates in two phases phase i. symbolic backward execution is used to nd a feasible execution path from the given target to any of the program s entry points.
unlike prior approaches symcretic execution skips over constraints that are problematic for the symbolic decision procedure and defers their solution until the second phase.
phase ii.
concrete forward execution begins when the symbolic backward execution reaches an entry point.
executing a trace of the program along the discovered path this phase uses heuristic search to nd inputs that satisfy the constraints that were skipped in phase i.
1public void challenges intx double u f 2intres 3inti 4while i x f inttmp i if tmp f res res 8gelsef res res 10g i 12g if res f error condition if math.sin u f error condition throw new assertionerror 16gelse ... long and deep computation 17gelse ... long and deep computation 18g figure example program whose data dependent loop line non linear integer arithmetic line and call to an external method line make it hard for symbolic execution to nd inputs that trigger the exception in line .
the integration of concrete execution allows symcretic execution to solve a range of arithmetic constraints that are too hard for symbolic decision procedures and enables the e ective handling of external methods.
moreover if a loop along a path requires too many symbolic traversals symcretic execution treats the loop as call to an external method thus delegating the problem of nding the right number of iterations to the cheaper concrete phase.
this paper contains the following research contributions it describes the symcretic execution algorithm for nding targeted program inputs.
to the best of our knowledge symcretic execution is the rst algorithm to use concrete execution to mitigate undecidable or infeasible constraints external method calls and data dependent loops in symbolic backward execution.
we compare symcretic execution with related techniques section and evaluate an implementation of our algorithm on a corpus of small programs section .
we show that our approach is feasible and more e cient than concolic execution for targeted input generation.
.
motivation suppose that during a code review and cleanup we discover that the test suite fails to throw the exception on line of the program shown in figure .
to add a test case that covers this line we have to nd inputs for an entry point of the program that lead to the execution of this line.
however manually deriving such targeted inputs is tedious and can be complicated.
for example the challenges method in figure must be called with the input x to satisfy the rst error condition res on line .
instead of manual derivation automated test generation techniques can be used to nd targeted inputs.
one of the strongest techniques is concrete symb olic concolic1 execution .
concolic execution explores a program by 1concolic execution is also known as directed automated random testing anddynamic symbolic execution.running it on concrete input values for example x and u .
and at the same time using symbolic execution to collect the constraints of the followed program path.
this path condition characterizes the set of all concrete inputs that drive the program down the followed path.
to explore another path in the program concolic execution derives a new set of concrete inputs by negating one of the constraints and solving the derived path condition.
if the path condition cannot be solved concolic execution uses concrete execution to improve coverage while sacri cing completeness.
targeted input generation the goal of concolic execution and other automated test generation techniques is not to cover a speci c target but to achieve high overall coverage.
these techniques try to explore as much of a given program as possible to discover a bug or to generate a test suite that is as complete as possible.
in contrast our objective is similar to that of sbe instead of covering as much as possible we are interested in covering speci c relevant targets in a program.
any part of a program that does not contribute to this goal for example lines and in figure is irrelevant exploring it wastes resources.
sbe starts at the target and explores the program in the opposite direction of normal forward execution until it reaches an entry point e.g.
a public method .
during the exploration it maintains the path condition of the followed path.
after reaching an entry point it solves the path condition to obtain concrete inputs that lead to the execution of the target.
for example if the target is line in figure the execution starts on this line and steps backwards collecting the constraint tmp .
moving further towards the top it constructs the path condition tmp tmp imod i x i res solving the path condition yields an input such as x that would trigger the execution of the desired target line .
however sbe faces challenges mentioned in section the modulo operation on line forces state ofthe art decision procedures such as the z3 smt2solver to reply unknown after few traversals of the loop the math.sin method on line is native and may not have an interpretation in the solver and the data dependent loop on line must be traversed times to yield res .
.
approach following the general idea of concolic execution we propose to overcome the aforementioned drawbacks of symbolic backward execution by combining it with concrete execution.
our approach symbolic con crete symcretic execution consists of the two phases outlined in this section.
a detailed description and formalization of both phases is available in the full version of this paper.
phase i uses sbe to try to nd a feasible execution path from the target statement to an entry point.
speci cally starting from the target statement it explores the program s controlow graph backwards and uses an abstract interpreter to construct the path condition.
branches in the search path for example statements with multiple predecessors or call sites of virtual methods are explored depth rst.
2satis ability modulo theories 321public void simpli ed challenges intx double u f 2intres x 3if res f if math.sin u f throw new assertionerror 6g 7g 8g figure program from figure without the loop.
after each search step the algorithm checks the satis ability of the current path condition with a symbolic decision procedure.
the search continues if the path condition is satis able.
it backtracks if the condition is unsatis able.
if the decision procedure cannot answer the query the algorithm removes the most recent constraint from the path condition treating it as potentially satis able and deferring its solution to the second phase.
phase i also constructs a trace of the program along the followed path.
at each search step the algorithm prepends the trace with the current statement regardless of whether it was removed from the path condition or not.
for removed statements the algorithm furthermore adds a call to the special change method that marks the statement s result as needing adjustment in the second phase.
because the search follows a single execution path if statements and other conditionals are not directly added to the trace.
instead the algorithm adds a call to the special t method that signals which of the conditional s branches the search traversed.
boolean connectives of conditions are encoded in the controlow which implies that all conditions along the path are non compound and valid inputs must satisfy their conjunction.
once the search reaches the beginning of an entry point the second phase begins.
phase ii uses heuristic search on the trace to nd input values that satisfy constraints that were problematic in phase i. speci cally the algorithm repeatedly evaluates the program trace on input values determines how close the branch conditions in the trace are to being satis ed and modi es some of the inputs to move closer to a full solution.
symcretic execution does not prescribe which heuristic search algorithm to use possible choices include genetic algorithms and the concolic walk algorithm .
we illustrate our approach on the program in figure .
assume we select line as target.
using sbe we obtain the path condition math.sin u res res x unfortunately our symbolic decision procedure cannot solve the path condition because it cannot reason about the native method math.sin .
symcretic execution therefore skips the problematic constraint math.sin u which results in the satis able path condition res res x with solution x .
simultaneously symcretic execution creates a trace of the program 1void trace1 int x double u f phase ii instructions 2intres x t res find inputs with res 4double v math.sin u 5change v adjust inputs that in uence v t v find inputs with v 7g the call to the change method in the trace signals that the value of vmust be found by heuristic search.
phase ii thus begins by executing the trace on the inputs x andu .
solutions obtained during phase i. by evaluating the calls to the t method phase ii determines that the constraint v is not yet satis ed.
it therefore adjusts one of the inputs that in uence v here u and re executes the trace.
this process continues until a solution has been found or the time budget has been exceeded.
data dependent loops another challenge for symbolic execution are data dependent loops that require many iterations such as the loop on line of figure .
triggering the error on line requires x iterations of the loop a number far beyond typical loopunrolling bounds.
for example the state of the art concolic testing tool pex fails to nd the right number of iterations even with extended exploration limits.
to discover this input symcretic execution starts from line collects the required constraints math.sin u res and starts unrolling the loop.
after a number of traversals it exceeds the maximum number of iterations and gives up on the loop.
it therefore treats the loop as though it were a call to an external loop method whose body is the loop body whose parameters are the variables read inside the loop and whose return values are the values written inside the loop.
in this way phase i jumps over the loop and continues on line .
after taking the last two symbolic steps the trace for the execution path looks as follows 1void trace2 int x double u f 2intres 3inti 4res i extractedloop res i x wraps lines in fig.
5change res 6change i t res 8double v math.sin u 9change v t v 11g the body of the extractedloop method consists of lines to in figure .
the second phase of symcretic execution uses heuristic search to nd inputs that in uence res i and v and satisfy the goal conditions res and v .
.
discussion comparison with concolic execution like concolic execution symcretic execution is stronger than symbolic execution because of its ability to mitigate solver limitations through concrete execution.
unlike concolic execution symcretic execution can avoid exploring irrelevant paths for example if the target is unreachable as in the unreachable method shown in figure .
the method contains an error condition that is prevented by a guarding ifstatement.
trying to nd inputs that trigger the error symcretic execution starts its symbolic phase at the error statement in line and begins stepping backwards.
it rst adds the constraint y to the path condition and next y which yields the unsatis able path condition y y .
this two step search path is branch free the search thus explored the rst segments of the only backwards path towards the method entry.
as a consequence symcretic execution ends after these two steps with a proof that the error in line cannot occur.
331void unreachable intx1 intx2 intx3 ... intxn f 2inty 3if x1 fy y gelsefy y g ... 5if xn fy y gelsefy y g 7if y f if y f error condition for e.g.
division by zero error 10g 11g 12g figure program with an unreachable error condition in line .
while symcretic execution recognizes the unreachability after two steps concolic execution explores 2nexecution paths before giving up.
1void slicing intx1 intx2 intx3 ... intxn f none of the blocks uses or de nes y 3if x1 f...gelsef...g ... 5if xn f...gelsef...g 7inty 8if y f error 10g 11g figure program for which slicing improves symcretic execution.
concolic execution starts its exploration of the unreachable method at the top.
once the execution has passed the initial computation which can be long and contain many branches it arrives at the if statement in line .
assuming that y 0holds the execution cannot explore the unreachable branch in the next line leading to a path condition y y6 where describes the path above the if statement.
if the concolic execution follows the common exploration strategy it tries to derive the next set of inputs by inverting the last constraint in the path condition and solving it.
however the new path condition is unsatis able it contains both y and y leading to backtracking.
as concolic execution cannot recognize the unreachability of the target statement this repeats for every constraint in .
concolic execution therefore explores up to 2j jirrelevant paths in the method before giving up.
in some cases guiding concolic execution via data dependencies can reduce the number of paths that are explored before the search gives up.
however even with this reduction the number of explored irrelevant paths can still be large.
in our admittedly contrived example the branch condition in line that prevents covering the target statement depends on every block of the preceding if statements.
the guidance therefore achieves no reduction at all.
comparison with backward slicing a backward slice of a program with respect to a slicing criterion consists of all the statements in the program upon which the criterion depends .
slices are therefore similar to the traces that symcretic execution collects along the followed execution path.
similar to a dynamic slice the trace follows a single execution path.
unlike slicing the trace is not xed by the program inputs but by the path1void narrow int x f 2inty 3if x fy x gelsefy x g y math.abs x 4if y f error reachable for x integer.min value 6g 7g figure program that is problematic for searchbased software testing but not for symcretic execution.
the narrow branch condition in line relies on an artifact of machine arithmetic.
the solution is hard to discover for heuristic search but not for symbolic bit vector solvers.
condition which represents the class of all program inputs for this path at once.
a further more important di erence is that the slice is a partial program whereas the trace is a straight line sequence of statements in which all controlow has been unrolled .
symcretic execution currently does not slice the program.
however slicing can accelerate symcretic execution by reducing the number of paths that have to be explored.
for example when targeting the error statement in line of the slicing method in figure slicing removes the nirrelevant conditionals in the lines .
having much of the necessary information for slicing available during symcretic execution we plan to integrate it in future work.
comparison with search based software testing search based software testing sbst nds test inputs that meet a coverage criterion by iteratively selecting inputs that according to a tness function seem closer to a solution.
in contrast to our focus on primitive values inputs can vary in granularity ranging from primitive values to method sequences for constructing objects.
common heuristics for nding better inputs are genetic algorithms as well as the alternating variable method .
the concrete phase of symcretic execution can be regarded as a special instance of applying sbst to the program trace.
heuristic search can be slow in discovering the speci c solutions of narrow branch conditions.
for example the method narrow in figure fails if called with the minimal value for integers because in two s complement the additive inverse of the smallest integer does not t into the available bits.
therefore it is x x but x6 .
this exceptional behavior for one out of 232integers assuming bit is problematic for heuristic search because the tness function will typically optimize the condition x xfor the solution x .
however symbolic solvers that support bitvector arithmetic know about these special cases and can solve the conditions directly.
assuming such a solver the symbolic phase therefore gives symcretic execution an advantage over sbst.
.
evaluation we now compare our implementation of symcretic execution with two other input generators symbolic pathfinder spf and jcute .
to measure the e ectiveness and e ciency in generating target speci c inputs we de ne target statements for a set of small programs and count how many search steps each tool takes before either nding inputs that reach the target or giving up.
34table programs used to evaluate symcretic execution.
the loc column lists the number of source code lines in the program excluding comments and empty lines.
the ifandl.columns show the number of if statements and and loops in the program thet.column contains the number of targets.
program description loc if l. t. hard loop figure dart concolic example unreach figure slicing figure narrow figure easy loop decrementing loop trityp triangle classi cation experiment setup we have implemented symcretic execution of a subset of java in a tool called cilocnoc concolic backwards .
cilocnoc relies on wala to process class les.
the symbolic backward execution engine of cilocnoc uses z3 to solve primitive constraints and a custom solver for object shape constraints.
the heuristic phase nds inputs using the concolic walk algorithm .
table lists the programs used in our evaluation.
each program represents a speci c challenge for symbolic and concolic execution see section .
the dart easy loop and tritypprograms are examples that appear in related work dart is close to the standard example for concolic execution easy loop is a simple data dependent loop that was used to evaluate jaut and trityp is the classic highly branching program for classifying triangles.
the remaining programs consist of the methods shown in the figures and .
in each program we arbitrarily place target statements that we wish to cover.
we generate inputs for every program using the cilocnoc jcute and spf cw tools.
jcute is a classic concolic test generator that relies on a linear constraint solver.
spfcw is a variant of symbolic pathfinder that solves complex arithmetic path conditions including calls to external methods with the same concolic walk algorithm that cilocnoc employs in its concrete phase.
jcute and spfcw both generate high coverage test suites for java programs.
aiming for high overall coverage neither tool implements a guiding heuristic towards a target statement.
however as discussed in section the data dependency guidance proposed in prior work would have little impact on the programs in our corpus.
all tools explore the program depth rst without depth bound but with a second time limit.
during the input generation we count the execution path segments the tool traverses before reaching the target.
a segment is a straight line sequence of statements between two branching points in the execution path.
we choose this metric because it depends less on implementation choices than measuring execution time.
nevertheless we also report the run times in seconds to give some intuition of the usefulness of the tools to programmers.
the times exclude the duration of static setup tasks because the values generated by these tasks could and should be cached.
for jcute the static setup consists of instrumenting the target program s byte code this adds about second to theprocessing time of each program.
for cilocnoc the static setup consists of loading and indexing the jdk class hierarchy which takes about .
seconds per program on an intel core i7 notebook with gb of ram.
results is symcretic execution effective?
cilocnoc nds inputs for all reachable targets which suggests that symcretic execution is e ective in nding branchspeci c inputs.
in contrast the inputs generated by jcute reach just one of three targets in the trityp program and the single target in the easy loop program the other eight targets in the program corpus remain uncovered.
the spfcw tool performs slightly better it additionally covers both targets in the dart program.
bene ting from a strong symbolic solver cilocnoc uses concrete execution for only three targets those in the easyloop andhard loop programs and the second target in the dart program which contains an external method call.
the target in the narrow program can be covered because the symbolic solver knows about bit vector arithmetic and the irregularity of negating the smallest integer.
results how efficient is symcretic execution?
the results of our experiments support the hypothesis that symcretic execution is more e cient than concolic and symbolic execution.
for all targets except one case in trityp cilocnoc explores fewer path segments than its competitors and at the same time discovers all desired inputs.
on the unreach program cilocnoc bene ts from being able to recognize unreachable branches as discussed in section instead of exceeding the time limit exploring jcute or segments spf cw it stops after just .
seconds or one segment.
furthermore the extraction of loops considerably shortens the explored path on the easy loop and hard loop programs whereas jcute and spf cw descend deeply into the respective loops and for jcute and segments for spf cw cilocnoc delegates the loop traversal to the concrete phase after just and segments which quickly nds a solution.
the results also show that pure symbolic execution has an exploration advantage over concolic execution.
unlike jcute both spf cw and cilocnoc in the symbolic phase support backtracking the search state.
when a search path becomes infeasible before having reached the target they can revert the changes of the last branch before descending into another branch of the search tree.
in contrast jcute has to re execute the entire program starting from the beginning.
both spf cw and cilocnoc can therefore explore paths much faster than jcute.
for example on the slicingprogram jcute is more than twenty fold slower than cilocnoc.
.
related work backward execution is a common technique in dataow analysis.
building on the ifds dataow framework chandra et al.
develop a backward analysis called snugglebugthat symbolically computes the weakest precondition of a target statement at a program entry point.
snugglebug s focus is shrinking the search space by lazily constructing the call graph.
snugglebug and our approach complement each other using snugglebug s search space reduction would accelerate cilocnoc while symcretic execution would allow snugglebug to handle complicated arithmetic 35constraints external method calls and long data dependent loops.
manevich et al.
use backward analysis based on ifds to nd typestate violations.
however the approach is limited to pointer operations and cannot reason about arithmetic constraints.
constraint logic programming clp supports the major components of symbolic execution inference with backtracking symbolic reasoning over numerical values and symbolic reasoning over data structures terms .
building on this support g omez zamalloa et al.
show how to obtain a test case generator for bytecode programs by compiling the bytecode to clp rules .
however it is unclear how to extend the approach for handling native code or complicated non linear arithmetic.
backward analysis is also the foundation for some heuristics that guide symbolic forward execution towards a target statement.
similarly to backward slicing zam r and candea compute which control ow edges must be passed to reach the target.
among the paths containing these edges they prioritize the paths with the lowest estimated number of operations.
ma et al.
propose a search heuristic that follows the call chain backwards from the target method.
however inside each method it uses forward search to nd the call site.
do et al.
use the chaining approach to guide concolic execution towards uncovered code elements.
the chaining approach chooses di erent inputs for a branch s reverse dependencies when it must take the branch but cannot solve it.
.
conclusions program inputs that cover a speci c target are useful in debugging and regression testing.
symcretic execution combines symbolic backward execution and concrete forward execution to e ciently nd targeted inputs even if a program contains complicated arithmetic external method calls or data dependent loops.
an experimental evaluation shows that symcretic execution nds inputs in more relevant cases than concolic testing tools while exploring fewer path segments.
in future work we plan to accelerate the search for potentially feasible paths by integrating heuristics that steer the search towards entry points by supporting con ict driven back jumping and by lazily expanding called methods.
furthermore we plan to complete the support for objects and add support for arrays and static elds to the cilocnoc tool.
.