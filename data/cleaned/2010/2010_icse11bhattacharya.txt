assessing programming language impact on development and maintenance a study on c and c pamela bhattacharya iulian neamtiu department of computer science and engineering university of california riverside ca usa pamelab neamtiu cs.ucr.edu abstract billions of dollars are spent every year for building and maintaining software.
to reduce these costs we must identify the key factors that lead to better software and more productive development.
one such key factor and the focus of our paper is the choice of programming language.
existing studies that analyze the impact of choice of programming language suffer from several deficiencies with respect to methodology and the applications they consider.
for example they consider applications built by different teams in different languages hence fail to control for developer competence or they consider small sized infrequently used short lived projects.
we propose a novel methodology which controls for development process and developer competence and quantifies how the choice of programming language impacts software quality and developer productivity.
we conduct a study and statistical analysis on a set of long lived widely used open source projects firefox blender vlc and mysql.
the key novelties of our study are we only consider projects which have considerable portions of development in two languages c and c and a majority of developers in these projects contribute to both c and c code bases.
we found that using c instead of c results in improved software quality and reduced maintenance effort and that code bases are shifting from c to c .
our methodology lays a solid foundation for future studies on comparative advantages of particular programming languages.
categories and subject descriptors d. .
metrics complexity measures d. .
management productivity general terms languages measurement keywords software quality developer productivity software evolution highlevel languages empirical studies permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.
.
introduction building and maintaining software is expensive.
studies indicate that maintenance costs are at least and sometimes more than of the total costs associated with a software product .
a nist survey estimated that the annual cost of software bugs is about .
billion .
these findings indicate that there is a pressing need in understanding factors associated with building and maintaining software.
at the same time we are currently witnessing a shift in the language choice for new applications with the advent of web .
dynamic high level languages are gaining more and more traction these languages raise the level of abstraction promising faster development of higher quality software.
however the lack of static checking and the lack of mature analysis and verification tools makes software written in these languages potentially more prone to error and harder to maintain so we need a way to quantitatively assess whether they indeed improve development and maintenance.
to that end in this paper we present a methodology for assessing the impact of programming language on development and maintenance a long standing challenge .
we first introduce an approach for attributing software quality and ease of maintenance to a particular programing language then exemplify the approach by comparing c and c .
c was designed extending c to include features object oriented constructs overloading polymorphism exception handling stronger typing aimed at faster construction of less error prone software.
to understand whether using c instead of c leads to better easier to maintain software we answer several questions directly related to software construction and maintenance are programs written in c easier to understand and maintain than programs written in c?
are c programs less prone to bugs than c programs?
are seasoned developers with equal expertise in c and c more productive in c than in c?
are code bases shifting from c to c ?
we answer these questions via an empirical study we are now in a good position to conduct such a study because both c and c are mature and have been used in large projects for a time long enough to study the effects of using one language versus the other.
prior efforts on analyzing the impact of choice of programming language suffer from one or more deficiencies with respect to the applications they consider and the manner they conduct their studies they analyze applications written in a combination of two languages but these applications are small sized and have short lifespans or they consider software built entirely using a singlelanguage rather than performing a cross language evaluation or they examine applications that are written in different languages bydifferent teams .
using such methodologies often results in analyses which cannot be generalized to large real world applications.
we aimed to address all these shortcomings.first we consider four large long lived open source applications mozilla firefox vlc media player blender animation software and mysql our analysis covers official releases and a combined years of evolution.
all these applications are mature stable have large code bases in both c and c and have large user bases their long histories help us understand issues that appear in the evolution of multi developer widely used software.
second we ensure the uniformity of software development process when comparing c and c code.
prior work has compared languages by considering applications written exclusively in a single language e.g.
by implementing the same small task in c c fortran or visual basic .
we only studied projects that contain both c and c code to guarantee uniformity in the development process of the application.
third we effectively control for developer competence to ensure that changes to software facets e.g.
quality can be attributed to the underlying programming language.
we use a statistical analysis of committer distribution to show that the majority of developers contribute to both c and c code bases section .
we confirm this with the developers as well section .
we present our research hypotheses in section followed by data collection and statistical methodology in section .
we first investigated whether code bases are shifting from c to c and found that this shift occurs for all but one application section .
.
we then compared internal qualities for code bases in each language and could confirm that c code has higher internal quality than c code section .
.
we found the same trend for external quality i.e.
that c code is less prone to bugs than c code section .
.
finally we found that c code takes less maintenance effort than c code section .
.
to our knowledge this is the first study that compares programming languages while controlling for variations in both developer expertise and development process and draws statistically significant conclusions.
in summary our main contributions are a novel way to analyze factors that impact software quality while controlling for both developer expertise and the software development process.
a multi faceted software evolution study of four large applications measuring software quality development effort and code base shifts between languages.
a formulation of four hypotheses and statistical analyses designed to capture whether a particular language leads to better software.
.
research hypotheses our study is centered around four research hypotheses designed to determine whether c a higher level programming language produces better software than c a lower level language h1 c is replacing c as a main development language.
at the beginning of the development process for an application the best suited language is chosen as the primary language.
later on developers might decide to replace the primary language e.g.
if the potential benefits of migrating to a new language outweigh the costs.
our hypothesis is that as the advantages of c become apparent applications that have started with c as their primary language are shifting to c .
to verify this we measured the change in percentage of c and c code over an application s lifetime if the c percentage increases over time we can conclude that c is being replaced by c .
h2 c code is of higher internal quality than c code.
one of the trademarks of high level languages is that they enable the construction of software that displays higher internalquality than software written in low level language i.e.
software that is less complex easier to understand and easier to change.
to test this hypothesis for each application we computed normalized code complexities for c and c using several metrics.
if the hypothesis held we should observe that on average c code is less complex than c code.
h3 c code is less prone to bugs than c code.
software bugs are due to a variety of reasons e.g.
misunderstood requirements programmer error poor design.
the programming language plays a key role in preventing bugs for example polymorphic functions can avoid code cloning and copy paste errors and strongly typed language eliminate many potential runtime errors.
we use this reasoning to postulate our next hypothesis due to the higher level features c code is less bug prone than c code.
h4 c code requires less effort to maintain than c code.
computing the effort that goes into software development and maintenance is difficult especially for open source projects where the development process is less structured than in commercial settings .
our findings indicate that even when there is no explicit allocation of tasks to developers most developers contribute to both the c and c code bases.
our hypothesis is that the effort required to maintain and extend the c code base is lower than the effort associated with the c code base.
.
methodology and data sources we ran our empirical study on four popular open source applications written in a combination of c and c .
we used several criteria for selecting our test applications.
first since we are interested in long term software evolution and pursue statistically significant results the applications had to have a long release history.
second applications had to be sizable so we can understand the issues that appear in the evolution of realistic production quality software.
third the applications had to be actively maintained by a large number of developers.
fourth the applications had to be used by a wide number of users who report bugs and submit patches.
table presents high level data on application evolution.
the second and third columns show the time span we considered for each application and the number of official releases.
the rest of the columns contain information version date and size for the first and last releases.
the period in column is different from the time interval between the first and last release dates of the application as reported in columns and because we could find bug and file change information that predate the first official releases.
.
applications we now provide a brief overview of each application.
firefox is the second most widely used web browser .
originally named phoenix it was renamed to firebird and then renamed to firefox in .
we considered phoenix and firebird in our study because the application s source code remained unchanged after the renamings.
firefox is mostly written in c and c it also contains html and javascript code that contribute to less than of the total code.
blender is a 3d content creation suite available for all major operating systems.
it is mostly written in c and c it also has a python component that contributes to less than of the total code.
we used the source code available in the svn repository for our analyses .
vlc is a popular crossplatform open source multimedia framework player and server maintained by the videolan project.
mysql is a popular openapplication period releases first official release last official release version date size version date size years loc loc firefox .
phoenix .
blender .
.49b vlc media player .
.
.
.
mysql .
.
table application information.
source relational dbms.
mysql was first released internally in followed by a publicly available windows version in .
in with version .
the source code was made available to the public.
therefore for measuring internal quality and maintenance effort we consider major and minor releases since .
.
our external quality measurements depend on the bug databases of the applications for mysql the database stores bug and patch reports for major releases .
.
.
.
and .
only thus our external quality findings for mysql are confined to major releases only.
.
data collection we now describe our data collection methodology.
we first checked out the source code of all official releases from the version control management systems the applications use then collected file change histories and finally extracted bug information from the application specific bug databases.
committer distribution.
an explicit goal of our study was to look at c and c code that was part of the same project to keep most factors of the software development process constant.
one such factor is developer expertise anecdotal evidence suggests that expertise greatly affects software quality .
ideally to understand the difference between the c and c languages we need to study code written by developers who are proficient in both c and c .
in figure we plot the percentages of developers who contribute to c code base only top area c code base only bottom area and to both c and c code bases middle area .
we observe that a large percentage of developers contribute to both c and c code.
to verify that developers in the middle area commit in equal measures to both code bases we selected random versions from each application.
we then compared the mean values for the c commits and c commits for all those developers who commit to both code bases.
we found that the mean values for c and c commits are comparable using welch s t test as explained in section .
i.e.
most developers commit in equal measures to both code bases.
this ensures that we effectively control for developer competence and any changes to software attributes e.g.
quality can be attributed to the underlying programming language only.
in section we present further evidence against selection bias i.e.
that perceived task difficulty and developer competence do not determine language choice.
dividing source code into c and c groups.
identifying whether a file belongs to the c code base or the c code base is not trivial because header files often use the extension .h for both c and c headers while .hpp or .hh extensions are reserved for c headers.
we considered a header file as a c header file if and only if all the files it is included in are c files otherwise we consider it as a c header file.
the implementation files were divided based on extension .c for c files and .cpp or .cc for c files.
collecting file change histories.
for testing hypotheses and we need precise information about bugs and code changes a firefox b blender c vlc d mysql figure committer distribution.
associated with each version.
we obtain this information by analyzing change logs associated with source files after dividing files into c and c groups.
note that it is not sufficient to extract change histories for files in the last version only because some files get deleted as the software evolves rather we need to perform this process for each version.
accurate bug counting.
we use defect density to assess external quality.
collecting this information is non trivial due to incomplete information in bug databases.
as we explain shortly to ensure accuracy we cross check information from bug databases1 with bug information extracted from change logs.
one problem arises from bugs assigned to no particular version for instance of the fixed bugs in firefox are not assigned to a specific fire1defect tracking systems vary firefox uses the bugzilla database blender uses it own tracker vlc uses trac and mysql uses bazaar and launchpad .fox version in the bugzilla database.
this problem is compounded in applications which exhibit parallel evolution as the co existence of two or more parallel development branches makes version assignment problematic.
another problem is that often for bug fixes that span several files the bug databases report only a partial list of changed files.
however if we search for the bug id in the change logs we get the complete list of files that were changed due to a particular bug fix.
therefore we used both bug databases and change logs as bug data sources.
we used a two step approach for bug counting.
first we searched for keywords such as bug bugs bug fixes and fixed bug or