evodroid segmented evolutionary testing of android apps riyadh mahmood computer science dept.
george mason university fairfax va usa rmahmoo2 gmu.edunariman mirzaei computer science dept.
george mason university fairfax va usa nmirzaei gmu.edusam malek computer science dept.
george mason university fairfax va usa smalek gmu.edu abstract proliferation of android devices and apps has created a demand for applicable automated software testing techniques.
prior research has primarily focused on either unit or gui testing of android apps but not their end to end system testing in a systematic manner.
we present evodroid an evolutionary approach for system testing of android apps.
evodroid overcomes a key shortcoming of using evolutionary techniques for system testing i.e.
the inability to pass on genetic makeup of good individuals in the search.
to that end evodroid combines two novel techniques an android specific program analysis technique that identifies the segments of the code amenable to be searched independently and an evolutionary algorithm that given information of such segments performs a stepwise search for test cases reaching deep into the code.
our experiments have corroborated evodroid s ability to achieve significantly higher code coverage than existing android testing tools.
categories and subject descriptors d. .
testing and debugging general terms reliability experimentation keywords android evolutionary testing program analysis .
introduction mobile app markets have created a fundamental shift in the way software is delivered to the consumers.
the benefits of this software supply model are plenty including the ability to rapidly and effectively deploy maintain and enhance software used by the consumers.
by providing a medium for reaching a large consumer market at a nominal cost this paradigm has leveled the playing field allowing small entrepreneurs to compete head to head with prominent software development companies.
platforms such as android that have embraced this model of provisioning apps have seen an explosive growth in popularity.
this permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.paradigm however has given rise to a new set of concerns.
small organizations do not have the resources to sufficiently test their products thereby defective apps are made available to the consumers of these markets.
these defects are exploited with malicious intent compromising the integrity and availability of the apps and devices on which they are deployed.
this is nowhere more evident than in google play a popular android app market where numerous security attacks have been attributed to vulnerable apps .
the situation is likely to exacerbate given that mobile apps are poised to become more complex and ubiquitous as mobile computing is still in its infancy.
automated testing of android apps is impeded by the fact that they are built using an application development framework adf .
adf allows the programmers to extend the base functionality of the platform using a well defined api.
adf also provides a container to manage the lifecycle of components comprising an app and facilitates the communication among them.
as a result unlike a traditional monolithic software system an android app consists of code snippets that engage one another using the adf s sophisticated event delivery facilities.
this hinders automated testing as the app s control flow frequently interleaves with the adf.
at the same time reliance on a common adf provides a level of consistency in the implementation logic of apps that can be exploited for automating the test activities as illustrated in this paper.
the state of practice in automated system testing of android apps is random testing.
android monkey is the industry s de facto standard that generates purely random tests.
it provides a brute force mechanism that usually achieves shallow code coverage.
several recent approaches have aimed to improve android testing practices.
most notably and closely related to our work is dynodroid which employs certain heuristics to improve the number of inputs and events necessary to reach comparable code coverage as that of monkey.
since prior research has not employed evolutionary testing and given that it has shown to be very effective for event driven software we set out to develop the first evolutionary testing framework targeted at android called evodroid .
evolutionary testing is a form of search based testing where an individual corresponds to a test case and a population comprised of many individuals is evolved according to certain heuristics to maximize the code coverage.
the most notable contribution of evodroid is its ability to overcome the common shortcoming of using evolutionary techniques for system testing.
evolutionary testing techniques are typically limited to local or unit testing as for system testing they are not able to promote the genetic makeup of good individuals during the search.
evodroid overcomes this challenge by leveraging the knowledge of how android adf specifies and constrains the way apps can bepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
599built.
it uses this platform specific knowledge to statically analyze the app and infer a model of its behavior.
the model captures the dependencies among the code snippets comprising the app and the entry points of the app i.e.
places in the code that the app receives external inputs .
the inferred model allows the evolutionary search to determine how the individuals should be crossed over to pass on their genetic makeup to future generations.
the search for test cases reaching deep into the code occurs in segments i.e.
sections of the code that can be searched independently.
since a key concern in search based testing is the execution time of the algorithm evodroid is built to run the tests in parallel on android emulators deployed on the cloud thus achieving several orders of magnitude improvement in execution time.
the remainder of this paper is organized as follows.
section provides a background on android.
section outlines an illustrative example that is used to describe our research.
section motivates the research problem using the illustrative example.
section provides an overview of our approach while sections to provide the details and results.
the paper concludes with a summary of the related research in section and a discussion of our future work in section .
.
android background the google android framework includes a full linux operating system based on the arm processor system libraries middleware and a suite of pre installed applications.
it is based on the dalvik virtual machine dvm for executing programs written in java.
android also comes with an application development framework adf which provides an api for application development and includes services for building gui applications data access and other component types.
the framework is designed to simplify the reuse and integration of components.
android apps are built using a mandatory xml manifest file.
the manifest file values are bound to the application at compile time.
this file provides essential information to an android platform for managing the life cycle of an application.
examples of the kinds of information included in a manifest file are descriptions of the app s components among other architectural and configuration properties.
components can be one of the following types activities services broadcast receivers and content providers .
an activity is a screen that is presented to the user and contains a set of layouts e.g.
linearlayout that organizes items within the screen horizontally or vertically .
the layouts contain gui controls known as view widgets e.g.
textview for viewing text and edittext for text inputs .
the layouts and its controls are typically described in a configuration xml file with each layout and control having a unique identifier.
a service is a component that runs in the background and performs long running tasks such as playing music.
unlike an activity a service does not present the user with a screen for interaction.
a content provider manages structured data stored on the file system or database such as contact information.
a broadcast receiver responds to system wide announcement messages such as the screen has turned off or the battery is low.
activities services and broadcast receivers are activated via intent messages.
an intent message is an event for an action to be performed along with the data that supports that action.
intent messaging allows for late run time binding between components where the calls are not explicit in the code rather made possible through android s messaging service.
all major components including activity and service follow pre specified lifecycles managed by the adf.
the lifecycle event handlers are called by the adf and play an important role in our research as explained later.
.
illustrative example we use a simple android app called expense reporting system ers to illustrate our research.
the ers app allows users to submit expense report from their android devices.
as shown in figure ers provides two use cases that allow the user to create two types of report quick report anditemized report .
when quick report is chosen the user enters the expense item name and the amount and subsequently presented with the summary screen.
the user can choose to submit or quit the application on the summary screen.
the itemized report option presents the user with the option to enter the number of line items by tapping the plus and minus buttons.
when next is tapped the application prompts the user to enter the expense name and amount.
this screen is repeated until all line items have been entered.
once all items are entered the user is presented with a summary screen with the line items their amount and the total amount.
the user can again choose to submit or quit the application at this time.
.
research challenge achieving high code coverage in android apps such as ers requires trying out a large number of sequences of events such as user interactions and system notifications.
our research is inspired by prior work that has shown evolutionary testing to be effective when sequences of method invocation are important for obtaining high code coverage.
however application of evolutionary testing has been mostly limited to the unit level as when applied at the system level it cannot effectively promote the genetic makeup of good individuals in the search.
figure 2a illustrates the shortcoming of applying an evolutionary approach for system testing of ers.
here we have two individuals in iteration of the search.
in this representation an individual is comprised of two types of genes input genes e.g.
values entered in text fields and event genes e.g.
clicked buttons .
the test case specified in an individual is executed from the left most gene to the right most gene.
in essence each individual is a test script.
using the screenshots of ers in figure we can see that the two individuals in iteration of figure 2a represent reasonable tests as each covers a different part of the app.
for system testing we would need to build on these tests to reach deeper into the code.
the problem with this representation however is that there is no effective approach to pass on the genetic make up of these individuals to the next generations.
for instance from figure 2a we can see that the result of a crossover between the two individuals in itfigure expense report system ers .600figure existing evolutionary testing techniques a a representation where the individual represents a test case and b a representation where the individual represents a test suite eration is a new individual in iteration that does not preserve the genetic makeup of either parents in any meaningful way.
in fact using the screenshots of ers in figure we can see that the tests cannot even be executed.
there are two issues that contribute to this the crossover strategy does not consider which input and action genes are coupled to one another.
for instance the genes lunch and next are coupled with one another as only together they can exercise the expense item screen.
the crossover strategy mixes genes from two different execution paths in the system.
thus it produces a test that is likely to be either not executable or inferior to both its parents.
in evolutionary search the inability to promote and pass on the genetic makeup of good individuals to the next generations is highly detrimental to its effectiveness.
to overcome the issues with this representation prior approaches use evolutionary algorithm in conjunction with gui crawling techniques.
one such approach called exsyst represents test suites as individuals and tests as genes as depicted in figure 2b.
this approach generates tests that correspond to random walks on the gui model.
an individual is comprised of many random tests i.e.
each gene of the individual corresponds to a system test.
exsyst evolves the suites of tests to minimize the number of tests and maximize coverage.
however the probability of a single gene test achieving deep coverage remains the same as in the case of random testing.
the overall coverage is no better than theinitial population randomly generated tests as the evolutionary algorithm is mainly used to minimize the number of tests.
evodroid is the first evolutionary testing approach for system testing of android apps.
to that end it had to overcome the conceptual challenges of using evolutionary techniques for system testing.
evodroid achieves this through a unique representation of individuals and a set of heuristics that allow the algorithm to maintain and promote individuals with good genetic makeup that reach deep into the code.
.
approach overview the overall evodroid framework is shown in figure .
the input is an android app s source code.
from the source code evodroid extracts two types of models representing the app s external interfaces and internal behaviors to automatically generate the tests interface model im and call graph model cgm .
the models are automatically extracted by analyzing the app s code.
im provides a representation of the app s external interfaces and in particular ways in which an app can be exercised e.g.
the inputs and events available on various screens to generate tests that arevalid for those screens.
a partial representation of im for the ers is shown in figure 4b.
evodroid uses the im to determine the structure of individuals tests i.e.
the input and event genes that are coupled together.
cgm is an extended representation of the app s call graph.
a typical call graph shows the explicit method call relationships.
we augment that with information about the implicit call relationships caused by events messages .
an example of cgm for the ers is shown in figure .
a particular use case e.g.
quick report or itemized report from figure follows a certain path through the cgm.
evodroid uses cgm to determine the parts of the code that can be searched independently i.e.
segments and evaluate the fitness quality of different test cases based on the paths they cover through the cgm thus guiding the search.
using these two models evodroid employs a step wise evolutionary test generation algorithm which we call segmented evolutionary testing .
it aims to find test cases covering as many unique cgm paths from the starting node of an app to all its leaf nodes.
in so it logically breaks up each path into segments.
it uses heuristics to search for a set of inputs and sequence of events to incrementally cover the segments.
by carefully composing the test cases covering each segment into system test cases covering an entire path in the cgm evodroid is able to promote the genetic makeup of good individuals in the search.
evodroid executes the automatically generated test cases in parallel possibly on the cloud to address scalability issues.
the test cases are evaluated based on a fitness function that rewards code coverage and uniqueness of the covered path.
the focus of evodroid is on generating test cases that maximize code coverage not on whether the test cases have passed or failed.
we acknowledge that automatically generating test oracles is a significant challenge.
this has been and continues to be the focus of many research efforts.
currently we collect two types of results from the execution of tests any exceptions that may indicate certain software faults as well as code coverage information.
section describes the models used for testing while section presents the details of evodroid.
.
apps models extraction evodroid needs three types of information about the app under test for automatically generating test cases the genes comprising a valid individual e.g.
determining the input fields and gui controls that should be paired up to have a valid test case for an activity which as you may recall from section represents a gui screen the app s segments i.e.
parts of the app that can be searched separately to avoid the crossovers issues described earlier and the fitness value of different test cases.
we developed android specific program analysis techniques to infer two models that can provide evodroid with this information.
.
interface model the interface model im provides information about all of the input interfaces of an app such as the widgets and input fields belonging to an activity.
it also includes information about the application and system level intents handled by each activity.
the im is obtained by combining and correlating the information contained in the configuration files and meta data included in android apk such as android manifest and layout xml files .
first we list all the android components e.g.
activities services comprising an app with the help of information found in the manifest file.
afterwards for each activity we parse the corresponding layout file.
an example of such layout file for expenseitemactivity is shown in figure 4a.
it is quite straightforward to ob 601figure evodroid framework.
tain all information on each screen such as widget type name and identifier from this xml document to generate the im.
figure 4b depicts the im for the ers activities.
we use the information captured in im to determine the structure genes of individuals for testing each component of the app.
.
call graph model the call graph model cgm contains a set of connected call graphs capturing the different possible invocation sequences within a given application.
we use modisco an open source program analysis tool to extract the app s call graph.
however since android is an event driven environment modisco generates disconnected call graphs for each app.
figure shows ers s cgm.
as described later we have extended modisco to infer the dashed lines to create a fully connected graph.
the root node of each call graph snippet is a method that no other part of the application explicitly invokes.
there are two types of root nodes .inter component root nodes these root nodes represent methods in a component that handle events generated by other components or android framework itself e.g.
an activity generating a startactivity event that results in another activity s oncreate method to be called or the android framework sending a resume event that results in an activity s onresume method to be invoked.
.intra component root nodes these root nodes correspond to events that are internal to a component.
for example a button on an activity has a click event associated with it.
this event is handled by a class within the same activity that implements the onclicklistener interface and overrides the onclick method.
these sorts of callback handlers are also root nodes as they are called by the android framework.
the inter component root nodes are the logical break points for segments and the inputs received at these nodes form the structure of individuals for the corresponding segments.
we can determine the structure of this input using the im.
on the other hand the intra component root nodes do not mark a new segment as they do not result in the execution to move to a different component e.g.
different screen and thus are not susceptible to the crossover problem.
finally for evodroid to generate tests and to determine their fitness it needs the cgm to be fully connected.
to that end we have extended modisco with an android specific program analysis capability to infer the relationships among the disconnected nodes of the call graph.
as depicted in figure we start with the oncreate root node of the main activity which we know from android s adf specification to be the starting point of all apps.
we then identify the intent events and their recipients as well as gui controls and their event handlers to link the different parts of linearlayout xmlns android .com apk res android android orientation vertical android layout width fill parent android layout height fill parent ... edittext android id id expensenameid android layout width match parent android layout height wrap content requestfocus edittext edittext android id id expenseamoundid android layout width match parent android layout height wrap content requestfocus edittext button android id id nextbtn android layout width wrap content android layout height wrap content android text next ... linearlayout figure a parts of the layout file for expenseitem activity b ers interface model602figure part of ers s call graph model the call graph and arrive at the final cgm.
we know that the links would have to be to other root nodes and achieved through sending of intent events.
the links formed as a result of this inference tell us the implied control flow as depicted with the dashed lines in figure .
in the case of inter component events the sender of intent identifies its handler as one of the intent s parameters.
in the case of intra component events the root node responsible for handling that event is registered as a callback method with the sender.
for instance a button s onclick method is registered with an object that implements the onclicklistener to receive a callback when the button is clicked.
examples of this in figure are decrementbutton andincrementbutton that are registered with itemcountactivity which implements the onclicklistener interface.
as the call graph snippets are linked and connected they are traversed in a similar fashion to arrive at the final connected cgm for the app.
.
evodroid the goal of evodroid is to find a set of test cases that maximize code coverage.
this is encoded as covering as many unique paths from the starting node of the cgm to its leaf nodes.
in the context of ers depicted in figure it is to find test cases from node a to leaf nodes n1 n2 and n3.
for example possible paths in this graph area!b!c!n1 and a!b!e!f!n3.
the former involves two segments while the latter involves four segments.
for each such path in figure evodroid starts from the beginning node and searches for test cases that can reach the leaf nodes.
each test case is represented as an individual in evodroid and its genes are the app inputs and the sequence of events.
unlike any prior approach evodroid takes each path in the cgm breaks it into segments and runs the evolutionary search for each segmentseparately.
accordingly the evolutionary process described here is repeated for each segment along each path in the cgm.
for each segment in each path a population with a configurable number of individuals is generated.
the evolutionary process is continued until all of the paths and their segments are covered or a configurable threshold e.g.
time limit certain level of code coverage number of total test cases etc.
is reached.
the search is abandoned for a segment and potentially a path if the coverage is not improved after a configurable number of generations.
this ensures the search does not waste resources on genes that cannot be further improved it also prevents the search from getting stuck in infinite loops when there are cycles in the path.
fitness is measured based on how close an individual gets to reach the next segment as well the uniqueness of the covered path.
with each iteration evodroid breeds new individuals by crossing over current individuals selected with likelihood proportional to their fitness value and then mutates them e.g.
changes some of the input values or events .
the ideal individuals from each segment are saved.
an ideal individual is a test that covers the entire segment and reaches the root node of another segment.
an ideal individual from the previous segment is prepended to the genes of a new individual for the next generation as described further in the next section.
essentially the test cases gradually build on the solutions found for the prior segments to build up to a system test case.
a segment may also optionally be skipped if it was covered while attempting to cover another segment.
for example in figure since the segment e!fis shared in the following two paths a!b!e!f!n3 anda!e!f!n3 it would only need to be evolved once assuming ideal individuals were found the first time .
similarly if while evolving a!b the algorithm inadvertently reaches a!e those ideal individuals are saved and evodroid may optionally skip solving a!e.
the maximum number of individuals or test cases executed in the search process can be calculated as follows t jpathj i 1segi gensegi pop gen segi wherejpathjis the number of unique paths from the starting node to the leaf nodes in cgm segis the number of segments for each path genis the number of generations per segment and popis the population or the number of individuals per generation.
the remainder of this section describes the details of evodroid.
.
representation the models from section are used to determine the structure of genes for each segment.
im tells us the inputs their data type such as integer double etc.
the number of gui elements such as buttons and or system events relevant to the current segment.
an individual is represented as a vector shown in figure 6a.
here previous segment corresponds to the genes of an ideal individual from the previous segment input corresponds to specific input values from the current segment and event corresponds to the sequence of possible user actions or system events from the current segment.
each index in the vector contains a gene.
the previous segment is a recursive relationship.
the number of input genes is fixed as we only need to change the input values i.e.
mutate the existing input genes.
the number of event genes is variable to handle the situations in which unexplored parts of the application require a certain number of button clicks or certain sequence of events.
for instance in the line item count screen from figure the plus button must be clicked more than the minus button and before clicking the next button to be able to reach the next screen.
we execute the test case specified in an individual603from the left most gene to the right most gene including all previous segment genes essentially traversing a path in the cgm.
.
crossover the first step in creating a new individual for the next generation is crossover.
this process selects two individuals from the current population and creates a new individual by mixing their genetic makeup.
evodroid uses a multi point probabilistic crossover strategy.
there is at least one and potentially multiple crossover points between the two selected individuals.
the segment crossover probability is calculated as follows p c e s c where eis a configurable constant to achieve a decay factor sis the index of the current segment being searched and c is the index of a prior segment between and s. the probability is .0for the current segment that is to say when c s. this exponential decay function ensures that the earlier genetic makeup is not changed frequently while leaving the possibility open to find individuals that may explore new areas of the search space.
the crossover point for the current segment can be at any gene index and at most the length of the smaller of the two individuals.
we only allow one crossover for the current segment as this is sufficient to create variability in the new individual.
figure 6c shows the crossover steps for a pair of parent individuals in segment of ers.
the newly created individual inherits part of the genetic makeup of the parents.
the previous segments are treated separately from the current segment and the probability function p c dictates the chance of crossover in each segment.
there can potentially be a crossover at each of the previous segments but we only allow swapping of the entire ideal individual for each segment not in the middle of a previous ideal individual.
figures 6b and c show how ideal individuals found in prior segments are used to arrive at the parent individuals in figure 6c.
here the new individual in figure 6c inherits the previous segment individual from the left parent.
if the probability function p c had dictated otherwise it would have been inherited from the parent on the right.
this crossover strategy aims to preserve the genetic makeup of the solutions found for earlier segments as we only allow the crossover to use the complete ideal individual for a given segment.
any ideal individual from that segment can be substituted as they are all solutions for that segment.
the previous segments for the new individual in figure 6c share the same path as the evolutionary process is applied within the context of a path thus the structure of the individuals at each previous segment line up properly.
note that this crossover strategy does not provide any guarantees that the input values and events satisfying an earlier segment in a path will be able to satisfy later segments in that path.
for example solving a particular constraint in segment 3may require a specific value to have been entered in segment .
indeed the objective of the search is to find such combinations.
the evolutionary search guided by heuristics embedded in the fitness function naturally weeds out sub optimal tests.
in addition since we save many ideal individuals for each segment each with different input event genes evodroid is quite effective at eventually discovering individuals that solve the entire path.
.
mutation mutation changes parts of the genetic makeup of the newly created individual.
only the current segment genes are mutated with a probability threshold that is configurable.
we mutate both inputand event genes with several creation transformation andremove operations.
the first type of mutation is done to the input genes of an individual.
the creation of a numerical input includes boundary values random special interesting values such as the number zero.
for a string input we generate purely random uniformly distributed characters from the alphabet of a certain length or null.
transformation operations for inputs include random value of same primitive data type bit flipping arithmetic operations and binary space reduction between boundary values.
removal operation for inputs is not applicable they are included as nullinstead.
the second type of mutation is done to the event genes.
the creation operator simply creates an event from the list of valid events specified in the im.
the number of added events is random with a minimum of one and a configurable upper threshold.
transformation operations for events include swapping event gene indexes changing one event to another and inserting a new event at a random index.
removal operation for events removes one or more event genes.
the length of the overall individual can change as a result.
figure 6d show the mutation of a single gene to create a final unique individual that is different from both parents.
.
fitness a key aspect of evolutionary algorithms is the notion of fitness.
in each generation individuals are assessed for their fitness with respect to the search objective to be selected to pass on their genes.
the fitness value ranges from to .
evodroid considers two factors when assessing the fitness of individuals.
the first is the distance traveled number of nodes covered between segments to reach the next segment and the second is the uniqueness of the path covered compared to the other individuals in the same generation.
the fitness of an individual iis determined as follows f i x n u i where xis the number of covered nodes in the path to the destination segment nis the total number of nodes in the path to the destination segment and u i is the uniqueness function of the individual as follows figure evodroid s a representation of individual b ideal individuals from segment c crossover steps for creating an individual in the 3rd segment and d mutation604figure fitness evaluation u i x n l k unique rk l k where rkis the covered node at index kin the path covered by the individual and unique rk is if the covered node at index kis unique compared to other individuals coverage at the same index and otherwise and lis the length of the path that this individual has covered.
when an individual for a given segment covers the entire segment path we identify it as an ideal individual for that segment with a fitness score of .
of course this means that there can be multiple individuals per generation that are ideal for a segment.
for illustration of how fitness is calculated consider the hypothetical example depicted in figure .
it shows that the total distance number of nodes to reach summaryactivity from lineitemactivity is .
when the first individual executes the shaded nodes are marked as covered by that individual.
it covers out of the nodes along the path to segment root node so it gets a distance score of x n a uniqueness score of u i as the entire path is unique at this time for a total fitness score of f i .
if another individual test case is executed but covers the path with nodes lineitemactivity!n1!n2!n3 it would get a distance score of x n and additionally a uniqueness score.
the length of the path this individual covered is and all but the first node are unique i.e.
n1 n2 n3 so the uniqueness score is u i .
the total fitness score for this individual would be f i .
although the individual did not cover much of the path to the destination segment node it is awarded a fractional score as it may discover a new area of uncovered code.
note that the formulation of eq.
and ensures that the uniqueness score alone never makes the value of fitness function to be without reaching the destination.
this prevents an individual to be labeled ideal without first reaching the destination.
finally a configurable number of test cases with the highest scores are directly copied to the future generations without any changes to ensure the individuals with the best genetic makeup remain in the population.
.
ev aluation we evaluated evodroid on a large number of apps with varying characteristics.
the goal of our evaluation was twofold compare the evodroid code coverage against the prior solutions and characterize its benefits and shortcomings.
.
experiment environment evolutionary testing requires the execution of a large number of tests.
this is especially challenging in the case of the android emulator as it is known to be slow even when running on workstations with the latest processors and abundant memory.
to mitigate this issue we have developed a novel technique to execute the tests in parallel possibly on the cloud which makes it suitable for use by small as well as large organizations.
we set up an instance of amazon ec2 virtual server running windows server and configured it with java sdk android sdk android virtual device and a custom test execution manager engine developed by us.
for each test the test execution manager launches the emulator installs the app sets up and executes the test.
it is also responsible for persisting all of the results along with the log and monitored data to an output repository.
a virtual machine image was created from the above instance to be replicated on demand.
with this we were able to scale in near linear time and cut down on the execution time.
we report the results for both extremes when the test cases are executed in sequence using a single processor and when they execute completely in parallel.
we have implemented evodroid using ecj a prominent evolutionary computing framework.
in the experiments we used emma to monitor for code coverage and all of the test cases were in robotium format.
our implementation and evaluation artifacts are available from .
.
experiment setup we compare evodroid with android monkey and dynodroid in terms of code coverage and execution time.
android monkey is developed by google and represents the state of the practice in automated testing of android apps.
it sends random inputs and events to the app under test.
dynodroid is a recently published work from researchers at georgia tech that uses a smaller number of inputs and events than monkey for reaching similar coverage.
we are not able to compare directly with exsyst and evosuite as they are not targeted for android.
we do not compare against as that is for model generation only while evodroid creates models and performs a step wise segmented evolutionary search.
at first blush it may seem unreasonable to compare evodroid a whitebox testing approach against android monkey and dynodroid which are blackbox and greybox testing approaches respectively.
however there are two reasons that makes this comparison relevant.
first most android apps can be reverse engineered using one of the existing tools see to obtain the source code necessary for whitebox testing.
therefore our approach could be used for testing almost all android apps.
second in the evaluation of any stochastic search algorithm it is desirable to compare the results of the algorithm against the unbiased random sample of the solution space.
we believe the comparison against monkey and dynodroid helps us in that vein.
it should be noted that unlike evodroid monkey and dynodroid are not designed to run in a distributed manner and neither tools are configurable to run for a specific amount of time.
to achieve a fair comparison with android monkey and dynodroid however we had to allot each approach similar number of events.
the events for android monkey and dynodroid are similar to the genes in evodroid.
since there is no one to one mapping we ran evodroid first and then mapped the total number of generated tests to monkey and dynodroid events.
thus the number of events allotted for running monkey and dynodroid varied as a function of the number of test cases executed for evodroid as follows max g t where gis the maximum number of genes allowed for605figure android complexity metrics distribution from a random sample of apps test cases in evodroid and tis the number of test cases executed for a given app.
in all experiment scenarios for each segment in each path we used a maximum of generations of individuals with a maximum of genes.
the number of maximum generations along with the coverage of all segments served as the terminating conditions.
euler s constant e was used as the crossover decay number in eq.
and during the mutation phase each gene had a chance of mutation.
to evaluate evodroid two sets of experiments were performed.
the first on apps developed by independent parties from an open source repository and the second on synthetic apps.
the synthetic apps helped us benchmark evodroid s characteristics in a controlled setting.
.
open source apps we selected open source apps to evaluate the line coverage between evodroid monkey and dynodroid.
we were not able to run dynodroid on two of the subject apps and thus we are not able to report on those.
as shown in table evodroid consistently achieves significantly higher coverage than both monkey and dynodroid.
on average evodroid achieves and higher coverage than monkey and dynodroid respectively.
the generation of test oracles is outside the scope of our work nevertheless we collected information about unhandled exceptions which allowed us to detect several defects in these apps.
for instance we found several cases of unhandled number format exception in tipster tippytipper and bites that were due to either leaving the input fields empty clicking a button that clears the input field followed by clicking a button that would operate on the inputs or simply putting a string that could not be converted to a number.
as another example we found a defect in bites an app for finding and sharing food recipes in which an unhandled index out of bounds exception would be raised when editing recipes without adding the ingredients list first.
some of the reasons for not achieving complete coverage are unsupported emulator functions such as camera as well as spawning asynchronous tasks that may fail not finish by the time the test finishes and thus not get included in the coverage results.
other reasons include code for handling external events such as receiving a text message dependence on other apps such as calendars and contacts lists and custom exception classes that are not encountered or thrown.
additionally some of the applications contained dead code or test code that was not reachable thus the generated evodroid model would not be fully connected.
indeed in many of these apps achieving coverage is not possible regardless of the technique.
the limitations of emulator peculiarities in the third party apps and incomplete models made it very difficult to assess the characteristics of evodroid independently.
in other words it was not clear whether the observed accuracy and performance was due to the aforementioned issues and thus an orthogonal concern or due to the fundamental limitations in evodroid s approach to test generation.
we therefore complemented our evaluation on real apps with a benchmark using synthetic apps as discussed next.
.
synthetic benchmark apps to control the characteristics of the subjects i.e.
apps under test we developed an android app generator that synthesizes apps with different levels of complexity for our experiments.
since we needed a way of ensuring the synthetic apps were representative of real apps we first conducted an empirical study involving real world apps chosen randomly from an open source repository called f droid .
the selected apps were in various categories such as education internet games etc.
we analyzed these apps according to four complexity metrics that could impact evodroid root nodes per app the number of disconnected call graphs in the app these are the methods called by adf and potentially the break points for evodroid segments.
method call sequence depth the longest method call sequence in the app.
mccabe cyclomatic complexity the average number of control flow branches per method.
block depth per method the average number of nested condition statements per method.
figure shows the distribution of these metrics among the android apps from f droid.
our app generator is able to synthesize apps with varying values in these four metrics.
since we wanted to evaluate the accuracy and performance of evodroid on subjects with different levels of complexity we had to derive some complexity classes from this data.
for that we aggregated the data collected through our empirical study as shown in figure and divided it into equal complexity classes ranging from to .
for instance the 1st complexity class corresponds to the 10th percentile in all of the four metrics shown in figure .
essentially an app belonging to a lower class is less complex with respect to all four metrics than an app from a higher class.
.
.
impact of complexity to benchmark the impact of complexity on evodroid we generated two apps for each complexity class.
apps were set up such that exactly path contained no input constraints while other paths contained nested conditional input constraints.
these constraints were generated to simulate the block depth per method dimension and would have to be satisfied in order for the search to progress table open source apps line coverage.
app name sloc evodroid android dynodroid monkey caladder tipster munchlife justsit anycut tippytipper notepad bites passwordmaker bookworm 606table execution time for testing apps from different complexity classes in minutes .
complexity of evodroid monkey evodroid evodroid android dynodroid class segments test cases dynodroid events single cpu parallel monkey .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
further and attain deeper coverage.
the generated conditional statements had a satisfiability probability given a random input value.
of course some of the conditional statements were nested in the synthetic apps resulting in a lower probability of satisfying certain paths.
the line coverage results are summarized in figure 9a.
as the complexity class of apps increases the coverage for monkey and dynodroid drops significantly.
since evodroid logically divides an app into segments the complexity stays relatively the same i.e.
it is not compounded per segment.
in all experiments evodroid achieves over line coverage.
the cases where coverage is not reached is due to evodroid abandoning the search when reaching the maximum number of allowable generations.
increasing the number of generations is likely to resolve those situations.
once monkey traverses a path it does not backtrack or use any other systematic way to test the app.
therefore monkey s test coverage is shallow as others have confirmed in .
dynodroid periodically restarts from the beginning of the app and is able to outperform monkey.
note that for very complex apps dynodroid would crash and thus we were not able to obtain results.
table summarizes the execution time for evodroid monkey and dynodroid.
even though the execution time for evodroid significantly increases as the apps become more complex it could be alleviated by running evodroid in parallel possibly on the cloud.
evodroid parallel times are roughly equivalent to the worst path execution time.
the numbers presented assume as many parallel instances running as there are test cases.
in practice we expect evodroid to be executed on several machines but perhaps not hundreds producing an execution time in between the worst case and best case reported in table .
we can see that as the depth of the segments increases the time to execute evodroid increases.
the results also show that monkey runs fairly quickly while dynodroid takes longer as one would expect due to its backtracking feature.
.
.
impact of constraints input constraint satisfaction is a known weakness of search based testing techniques.
a set of experiments was conducted to assess the efficacy of our approach as the satisfiability probability of conditional statements was lowered below .
we took the second app from the 3rd complexity class shown in figure 9a and low1this is because above events dynodroid needs more than .4gb memory which is more than the maximum memory size the bit virtual machine that georgia tech researchers provided us for our experimentation could support.ered the satisfiability probability of its conditional statements to and .
as shown in figure 9b when the probability of constraint satisfiability decreases the line coverage drops significantly for evodroid.
android monkey coverage stays the same as it takes the one path with no constraints and does not backtrack.
the coverage for dynodroid drops also but remains better than monkey as it restarts from the beginning several times during execution.
the results demonstrate that evodroid as well as any other evolutionary testing approach performs poorly in cases where the apps are highly constrained e.g.
the probability of satisfying many conditional constraints with random inputs is close to zero such as an ifcondition that specifies an input value to be equal to a specific value .
fully addressing this limitation requires an effective approach for solving the constraints such as symbolic execution as described further in section .
fortunately from figure we see that for a typical android app the average cyclomatic complexity is approximately and block depth is approximately .
these numbers are encouraging as they show that on average most android apps are not very constrained.
.
.
impact of sequences given the event driven nature of android apps there are situations when certain sequences of events must precede others or certain number of events must occur to execute a part of the code.
we evaluated evodroid for these types of situations by generating apps from the 3rd complexity class with ordered sequence lengths ranging from to .
sequences of events with these lengths would have to be satisfied per segment in all paths in order to proceed with the search e.g.
certain buttons on an activity must be clicked in a certain sequence of length to .
figure 9c summarizes the results from these experiments.
while evodroid s coverage decreases it does so at a much slower pace than monkey or dynodroid.
we observe that evodroid is effective in generating system tests for android apps involving complex sequence of events.
this is indeed one of the strengths of evodroid that is quite important for android apps as they are innately event driven.
.
related work the android development environment ships with a testing framework that is built on top of junit.
robolectric is another testing framework for android apps that runs tests without relying on the android emulator.
while these frameworks automate the ex a b c figure benchmark apps coverage results a line coverage results for testing apps from different complexity classes b impact of constraints on line coverage c impact of sequences of events on line coverage ecution of the tests the test cases themselves have to be developed manually.
amalfitano et al.
described a crawling based approach that leverages completely random inputs to generate unique test cases.
in a subsequent work they presented an automated android gui ripping approach where task lists are used to fire events on the interface to discover and exercise the gui model.
hu and neamtiu presented a random approach for generating gui tests that uses the android monkey to execute.
we use program analysis to derive the models.
this sets us apart from these works that employ black box testing techniques.
yang et al.
described a grey box model creation technique that similar to our work is concerned with deriving models for testing of android app and can potentially be substitued for our models.
they also found that models generated using their approach could be incomplete.
jensen et al.
presented a system testing approach that combines symbolic execution with sequence generation.
they attempt to find valid sequences and inputs to reach prespecified target locations.
their approach neither uses an evolutionary search technique like ours nor is their goal maximizing code coverage.
anand et al.
presented an approach based on concolic testing of a particular android library to identify the valid gui events using the pixel coordinates.
dynodriod is an input generation system for android that was used extensively in our experiments.
evolutionary testing falls under search based testing techniques and has typically been used to optimize test suites or has been applied at the unit level .
evolutionary testing approaches such as have attempted to optimize a test suite for coverage.
these are all blackbox approaches that build their gui models at run time by executing and crawling or by recording user behavior and therefore the generated models may not be complete.
since our approach uses program analysis we obtain a more complete model of the app s behavior.
they also differ from us in that they represent test cases as genes.
two unit level evolutionary testing approaches were presented in .
a combination of approaches were also presented in .
evolutionary algorithm and symbolic execution techqniques were combined in while evolutionary algorithm and hill climbing algorithm were used together in .
these techniques are all geared towards unit testing.
an ant colony optimization search was used in along with a call graph similar to ours for gui testing.
however their call graph is generated by executing the system and connecting overlapping call nodes to attempt to form the entire call graph.
this approach suffers from the same issue as the gui crawling methods meaning that the call graph model may be incomplete.
choi et al.
proposed a machine learning approach to improvethe app models by exploring the states not encountered during manual testing.
this work is complementary to our work as it may be possible to use these improved models in evodroid.
there has also been a recent interest in using cloud computing to validate and verify software.
taas is a testing framework that automates software testing as a service on the cloud .
cloud9 provides a cloud based symbolic execution engine.
similarly our framework is leveraging the computational power of cloud to scale evolutionary testing.
.
concluding remarks we have presented evodroid a novel framework for automated testing of android apps.
the key contributions of our work are an automated technique to generate abstract models of the app s behavior to support automated testing a segmented evolutionary testing technique that preserves and promotes the genetic makeup of individuals in the search process and a scalable system wide testing framework that can be executed in parallel on the cloud.
although our approach has shown to be significantly better than existing tools and techniques for automated testing of android apps in the worst case scenario it can degrade quite a bit due to its inability to systematically reason about input conditions.
this is a known limitation of search based algorithms such as evolutionary testing.
in our ongoing work we are developing an android specific symbolic execution engine.
we are extending java pathfinder which symbolically executes pure java code to work on android.
we plan to use both techniques in tandem to complement one another.
we are also exploring relational logic and the associated model finders for generating reduced combinatorics in testing android apps .
another weakness of our approach is not being able to fully generate models for apps that use third party libraries or native code.
there is also a significant variability in the way the app code is generally written.
as a result the models may in fact be incomplete.
however as mentioned earlier and evaluated in section .
evodroid is able to work on partial and or incomplete models.
in the future we plan to improve our models generation capabilities to handle a larger subset of the android specifications.
.