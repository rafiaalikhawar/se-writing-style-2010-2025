manual refactoring changes with automated refactoring validation xi ge emerson murphy hill department of computer science nc state university raleigh nc usa xge ncsu.edu emerson csc.ncsu.edu abstract refactoring the practice of applying behavior preserving changes to existing code can enhance the quality of software systems.
refactoring tools can automatically perform and check the correctness of refactorings.
however even when developers have these tools they still perform about of refactorings manually which is error prone.
to address this problem we propose a technique called ghostfactor separating transformation and correctness checking we allow the developer to transform code manually but check the correctness of her transformation automatically.
we implemented our technique as a visual studio plugin then evaluated it with a human study of eight software developers ghostfactor improved the correctness of manual refactorings by .
categories and subject descriptors d. .
coding tools and techniques general terms design experimentation languages human factors keywords refactoring restructuring tool ide .
introduction refactoring is the process of altering software s internal structure without modifying its external behavior .
studies show refactoring can improve cohesion maintainability evolvability and reusability of existing software systems.
because of these benefits refactoring is an important part of modern software development.
according to cherubini and colleagues survey of427developers at microsoft developers consider refactoring as important as or more important than understanding code and producing documentation .
refactoring is also an integral part of agile development processes such as extreme programming .
developers can perform refactorings manually or with automated tools.
manual refactorings are error prone according to our permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.previous study of twelve professional developers one third of their manually performed refactorings inserted defects to the software system .
automated refactoring tools will perform refactorings for developers and automatically check their correctness enabling developers to quickly and safely refactor their code.
although automated refactoring tools refactor more correctly than developers do developers rarely use them.
according to existing studies only of145refactorings in real world open source systems were performed automatically .
to solve this underuse problem researchers have proposed novel tools to encourage developers to refactor automatically.
for instance benefactor and witchdoctor automatically finish refactorings after developers start refactoring manually .
these tools significantly reduce but do not completely remove the barriers to using refactoring tools.
for instance developers must still explicitly invoke most refactoring tools.
in addition researchers found that developers do not trust automatic refactorings to be correct .
existing tools remove neither of these barriers developers are unlikely to change their behavior to use a tool they distrust .
to address these problems in this paper we propose a novel static analysis technique.
we make the following contributions a technique called ghostfactor that can detect manually performed refactorings and check their correctness.
ghostfactor is novel for combining light weight static analysis with refactoring detection algorithms to quickly detect refactoring errors.
section describes the design of ghostfactor.
we implemented our technique in an open source plug in for the visual studio ide .
this plugin also called ghostfactor instantly notifies developers when they refactor incorrectly and suggests ways to fix the error.
unlike previous refactoring tools ghostfactor integrates into the ide s notification system a familiar mode of interaction for developers.
section describes the implementation.
we evaluated ghostfactor by conducting a human study with eight developers.
in this study we compared how participants refactored with or without ghostfactor.
ghostfactor improved the correctness of their manual refactorings by .
section presents the design and results of the study.
before describing our technique we first provide further motivation for the technique in section and describe related work in section .
.
motiv ation one desirable property of software development tools such as refactoring tools is that they should accommodate the developer permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
void m bool b int a do something.
void m int a bool b do something.
a a developer changes a method declaration.
m true m false m false m true m false m false m true m false m false m true m false m false b a developer relies on compiler errors to update call sites.
figure refactoring with compiler warnings.
rather than the developer having to accommodate the tools.
in this section we give two common patterns developers use when refactoring show how existing refactoring tools do not accommodate this behavior and describe how our proposed approach accommodates this behavior.
developers refactoring patterns.
our previous work found two common patterns in developers refactoring behavior.
we found developers transformed their code manually nine out of ten times rather than using a refactoring tool .
part of the reason for this is that developers do not trust the changes refactoring tools make .
the second pattern we found in developers refactoring behavior was using compiler errors to guide and check the correctness of manual refactorings .
for example suppose a developer is going to change the signature of method m in figure 1a by exchanging the positions of its first and second parameters.
she might first change the method declaration as illustrated in figure 1a.
the compiler raises errors at all the method s call sites because the types of their arguments no longer match the declared type signature.
the developer can use these compiler errors to find all the call sites then correct them to finish the refactoring as illustrated in figure 1b.
in some cases such as the example in figure developers can use this pattern to finish refactorings completely and correctly.
however this is not always the case.
for example changing the parameters of void n int a int b tovoid n int b int a will not raise any compiler errors because the exchanged parameters share the same type.
our previous study found developers who rely on such compiler errors make more refactoring errors .
existing tools do not accommodate these patterns.
existing refactoring tools do not accommodate these common refactoring patterns they require developers to manually invoke them so developers must change their workflow to use them.
however we found some developers do not know what refactoring tools are available.
even when they do developers sometimes complete part of a refactoring before realizing they are refactoring.
they often choose to simply complete the refactoring manually rather than un previous changes and invoking a tool .
thus requiring explicit invocation is a barrier to the use of traditional refactoring tools.
the refactoring tools benefactor and witchdoctor address these awareness problems but do not accommodate developers existing refactoring patterns.
specifically both tools require the developer to trust the transformations the tools make.
as mentioned previously many developers do not trust tools to make correct changes .
our new approach accommodates these patterns.
ghostfactor fits into more developers workflows because it does not assume that developers know about refactoring tools or trust automatic code transformations.
our approach separates automatic transforchecker2 checker4checker1 checker3conditon checking history savingdetector1 refactoring detection detector3detector2 detector4violation pass code snapshotsnapshot listdetected refactoring refactoring warning active editoradd remove warnings figure ghostfactor components.
mations from automatic correctness checks so developers can benefit from the second without adopting the first.
ghostfactor uses familiar notifications similar to compiler warnings to inform the developer of errors made while manually refactoring.
.
related work before delving into the detail of ghostfactor we first review the existing research related to our work.
there is a huge body of existing works related to ours.
we briefly summarize them in the following categories refactoring studies improvement of refactoring tools and refactoring detection.
refactoring studies.
researchers have conducted multiple studies related to refactorings.
kim and colleagues study suggested that developers avoid refactoring tools in spite of the fact that they know their intended refactorings can be automated .
murphy hill and colleagues showed how refactoring tools are used and that they are significantly underused .
based on this study vakilian and colleagues further investigated how refactoring tools are misused in various situations .
the study conducted by tokuda and batory suggested that software evolution could be significantly accelerated by applying a set of general purpose refactorings .
in contrast to these studies our study in this paper investigates whether developers can perform manual refactorings more correctly with assistance of enhanced compiler like warnings.
improvement of refactoring tools.
researchers have proposed various ways to improve automated refactoring.
for instance mens and colleagues formalize refactoring by using graph transformations .
bavota and colleagues automatically identify method chains and refactor these method chains to cohesive classes .
extending refactoring to the aspect oriented programming hannemann and colleagues introduced an interactive way of transforming code base .
to improve the quality of refactoring tools daniel and colleagues proposed an automatic testing framework .
lee and colleagues proposed a drag and drop refactoring tool that liberates developers from remembering different refactoring types .
the aim of these approaches is to provide more powerful refactoring capabilities or user interfaces the aim of our approach is to align refactoring tools with the way developers manually refactor.
benefactor and witchdoctor can both detect manual refactorings and finish them automatically relieving the programmer from having to recognize that the task she is about to perform is a refactoring.
to further reduce the barriers of automatic refactorings ghostfactor can check the correctness of manually performed refactorings without being invoked explicitly.
although ghostfactor and benefactor share similar user interfaces they are significantly different from each other.
firstly benefactor looks for incomplete manual refactorings ghostfactor to the contrary detects manually finished refactorings.
secondly benefactor ap 1096snapshot snapshot snapshot snapshot distance ...distance distance figure snapshots compared in a snapshot list.
plies quick fix changes to finish refactorings whereas ghostfactor applies quick fixes to remedy existing refactoring errors.
drag and drop refactoring tool infers developers refactoring intention by the source and the destination of their drag and drop actions and finishes the intention automatically .
different from the tool ghostfactor seeks to correct manual refactorings instead of eliminating the obstacle to invoking automatic refactorings.
refactoring detection.
researchers have proposed many refactoring detection techniques for various purposes.
prete and colleagues proposed ref finder to identify complex refactorings by using template logic rules .
bavota and colleagues proposed refactoring detection techniques by using semantic measurement and game theory .
benefactor and witchdoctor detect ongoing manual refactorings in order to finish them automatically.
although in this paper we implemented algorithms for detecting refactorings from scratch reusing these existing techniques is an alternative way to implement the refactoring detection component of ghostfactor.
refactoring conditions.
conventional refactoring tools adopt a heuristic based technique to ensure the correctness of automatic refactorings namely refactoring condition checking .
as alternatives sch fer and colleagues proposed the concepts of dependency notions and microrefactorings to implement automatic refactorings more understandably and correctly overbey and colleagues proposed a language agnostic technique called differential precondition checking .
in contrast this paper applies the conventional technique of refactoring condition checking to detect defects introduced by manual refactorings.
.
approach ghostfactor detects developer introduced defects to ensure the correctness of manual refactorings.
in this section we describe its design.
ghostfactor has several independent components each of which handles a different task.
figure illustrates these components and how they interact with each other.
the first component is the history saving component.
this component records the change history of different files that a developer has worked on.
it registers a listener to content change events issued from the active editor.
when an event occurs the component takes a snapshot of the source file currently opened in the active editor and saves its content in memory.
the change history of a specific source file is maintained as a snapshot list to facilitate sequential access where the head of the list is the most recent snapshot.
after saving the source file s content and updating its snapshot list the component feeds the list to the next component.
the refactoring detection component detects refactorings that the developer completes manually.
this component takes the snapshot list for a source file as input then dynamically loads available refactoring detectors and applies them to the snapshot list.
this component uses each detector to compare the latest snapshot in the snapshot list with one of the previous snapshots.
for instance figure depicts a snapshot list where the latest node is snapshot .
we show the compared snapshots by drawing arcs between them.
in this figure we also label the distance between compared snapshots where the distance is one more than the number of snapshots between the two.
ghostfactor does not compare snapshots if thedistance between them is larger than some constant maximum we have set this maximum 30in our implementation.
this constraint helps ensure that the detection finishes before another snapshot arrives.
all the refactoring detectors share a common interface that developers can use to implement their own detectors.
the interface takes two abstract syntax trees asts of the same source file as inputs and generates outputs that indicate whether a refactoring is detected the detected refactoring s type and the ast nodes affected by the refactoring.
for example the affected ast nodes of an extract method refactoring are the newly declared method and the invocations of that method.
if ghostfactor detects a manual refactoring it feeds the refactoring to the condition checking component .
this component dynamically loads available condition checkers for the given refactoring s type.
these condition checkers can check for both preconditions and post conditions for the given refactoring .
all of the condition checkers for a refactoring type share a common interface with which developers can implement their own condition checkers to add to ghostfactor.
the inputs of this interface include the detected refactoring and the asts in which the refactoring is detected.
the output indicates whether the refactoring violates or passes the condition.
the last component refactoring warning component keeps track of detected condition violations.
taking a condition violation as input the component first checks whether a warning has already been issued for this violation.
if one has this component discards the redundant violation otherwise the component saves it and issues a new refactoring warning.
taking a passing condition as input the component will check whether this passing condition resolves an existing refactoring warning.
if it does the component dismisses this warning.
for each refactoring warning ghostfactor also provides quick fixes with which the violation can be automatically resolved.
to illustrate how the last component works we next give an example.
suppose a developer is refactoring on a source file f consecutively generating four different snapshots f1 f2 f3 andf4.
f1is the original file f2contains an erroneous refactoring rthat violates a condition c f3also contains rviolating the conditionc f4contains the corrected rthat fixed its violation of c. in this example the refactoring warning component will consecutively receive three different condition checking results which are r s violation of c r s violation of cagain and finally r s pass of c. according to the mechanism of the refactoring warning component ghostfactor will issue a refactoring warning at f2andf3 while removing the warning at f4.
.
implementation built on the microsoft roslyn project we implemented ghostfactor as a plug in for the visual studio ide to help refactor c software the source code of this plug in is open to the public1.
in this section we describe this implementation.
.
supported refactoring types the ghostfactor plug in currently supports the following three refactoring types.
extract method according to fowler s refactoring catalog extract method is a type of refactoring that turns a set of statements into a new method whose name clearly explains that purpose of the method as illustrated in figure 4a.
m n void n do something.
void m do something.
a extract method.
void m n void n do something.
void m do something.
b inline method.
int m int b int a return a b int m int a int b return a b ... c m ... ... c m ... c change method signature.
figure refactoring examples.
fowler recommends extract method to eliminate code smells such as long method and duplicated code .
change method signature change method signature is a refactoring type that changes the parameter list of a given method without modifying the method s functionality as illustrated in figure 4c.
according to fowler s list change method signature can be further divided into subcategories such as add parameter remove parameter and introduce parameter object .
change method signature is mainly for eliminating code smells such as long method signature data clumps and long method .
inline method the opposite of extract method inline method is a refactoring type that puts a method body into its caller and remove the method as illustrated in figure 4b.
the refactoring is intended to eliminate methods that are short and unnecessary .
we selected these refactoring types for two reasons according to murphy hill and colleagues previous study of refactoring tool usage these refactoring types are among the most frequently performed ones and in our previous study about manual refactorings developers introduced the most defects when manually performing extract method and change method signature .
for inline method although we do not have evidence we speculate that it is as error prone as extract method because of both refactorings similar complexity.
.
refactoring detectors to check the correctness of refactorings ghostfactor needs to detect them first.
taking two versions of a source file as an input each detector outputs whether a refactoring is performed and describes the detected refactoring for later analysis.
in this subsection we present our currently implemented detectors.
extract method.
our detecting algorithm for extract method is based on the observation that after a refactoring finishes a new method declaration will contain part of a previously existing method.
by comparing the new method against the removed part of the previously existing method this detector determines whether an extract method refactoring took place.
the details of this detection algorithm could be found in appendix .
change method signature.
for change method signature ghostfactor warns developers about call sites that fail to be updated after a method signature changes.
in most cases conventional compiler warnings are enough to achieve this as the example in section illustrated.
however when the changed signature has exactly the same parameter count and types with its previous version conventional compiler warnings are not able to help as illustrated in the manual refactoring study .
our algorithm detects these situations the detail of the algorithm can be found in appendix .inline method.
our inline method detection algorithm is based on the observation that simply replacing the invocations of nwith n s method body in m s body before the refactoring will result in a method that is similar to mafter the refactoring.
details of this algorithm can be found in appendix .
.
condition checkers after detecting a manual refactoring we next check whether the refactoring preserves the software s external behavior.
multiple ways exist to check correctness such as formal verification testing and checking refactoring conditions .
formal verification proves the behavior preserving of software before and after refactorings however this technique is prohibitively heavy potentially jeopardizing the goal of providing developers instant feedback .
testing or more specifically regressing testing can expose software s behavior changes though a recent study from kim and colleagues shows that the test cases associated with a project are often insufficient to expose refactoring errors .
as another option automatically generating tests instead of using the existing ones likely leads us to the other problems like the object creating issue .
therefore we chose to use similar condition checking to existing refactoring tools .
checking refactoring conditions although ad hoc in nature has two advantages that other ways do not a checking refactoring conditions is more time efficient aligning with the requirement of instant feedback and b condition checking allows us to issue informative refactoring warnings convenient for developers to resolve rather than only telling that the external behavior of the software has been changed.
similar to the refactoring tools integrated into the mainstream ides condition checkers in ghostfactor check whether a given manual refactoring violates a predefined set of conditions.
however not every condition requires an implementation in ghostfactor because some violations can trigger conventional compiler errors.
before implementing ghostfactor we categorized the refactoring conditions into three categories those whose violations trigger conventional compiler errors those whose violations do not those whose violations sometimes do and sometimes do not.
interested readers can find the categorization in our project website2.
in summary we manually surveyed the 10most frequently used refactoring types and none of them have all its conditions in category .
ghostfactor dynamically loads condition checkers at runtime to allow developers to easily add new checkers by implementing our predefined interfaces.
we selected three refactoring conditions to implement.
the criteria for selecting these conditions were the condition should be associated with a refactoring type that our implementation can detect violation of the condition does not trigger conventional compiler errors and violation of the condition should happen frequently according to our previous study .
in the rest of this section we present the implementation of the checkers for these three conditions.
.
.
return value checker when performing extract method statements to extract may modify the values of some local variables that are accessed after the extracted statements.
the modified values of these variables need to be returned from the extracted method otherwise the code after the extracted statements in the original method will get incorrect values for these variables.
take the code in figure as an example if we intended to extract statements from line 4to line the ghostfactorstudy private double internalfunction double x ... for int i i this.
simplexvariablelist.length i if this.
simplexvariablelist .fixed false this.
externalvariables x this.
simplexvariablelist .scalefactor varfreevarindex ... figure code before extract method refactoring.
private double internalfunction double x ... for int i i this.
simplexvariablelist.length i loopbody x varfreeindex ... private void loopbody double x int varfreeindex if this.
simplexvariablelist .fixed false this.
externalvariables x this.
simplexvariablelist .scalefactor varfreevarindex figure missing return value error.
updated value of varfreevarindex needs to be returned and assigned back to the local variable varfreevarindex .
without returning this value as illustrated in figure although incorrect as a refactoring the change will not result in compiler errors.
to help developers recognize such errors we implement a checker for missing return values.
the idea of the return value checker is straightforward it first applies data flow analysis to find local variables accessed by the code after the extracted statements in the original method it applies data flow analysis to find local variables written in the extracted statements and local variables that are found in both steps and need to be returned from the extracted method.
finally we check whether the manually extracted method has all these variables returned and assigned back.
if not ghostfactor will issue a refactoring warning for a missing return value at the extracted method s declaration.
ghostfactor provides a quick fix option with the warning.
after the developer invokes the quick fix a return statement will be added automatically and the returned value will also be assigned back to the modified local variable as illustrated in figure .
if multiple return values are needed ghostfactor makes the parameters passby reference.
.
.
parameter checker when performing the extract method refactoring the newly extracted method needs to have correct parameters.
taking the program in figure as an example to extract code from line 4to line the extracted method needs to take xas a parameter.
failing to do so changes the code s external behavior.
in most cases if the extracted method accesses variables that are not passed the undefined symbols will trigger compiler errors.
however compiler errors are not always reliable consider the case when the extracted method needs a parameter whose name is identical to a field of the containing class.
code in figure illustrates this situation.
to ensure the extracted method has the correct parameters the parameter checker gets the needed parameters by applying data flow analysis to the extracted statements.
next it checks if the extracted method has all of these needed variables as parameters.
if not ghostfactor issues a refactoring warning for the missing parameters.
similar to the return value warnings a warning for missing parameters comes with a quick fix option.
after the developer invokes private double internalfunction double x ... for int i i this.
simplexvariablelist.length i varfreevarindex loopbody x varfreeindex ... private int loopbody double x int varfreeindex if this.
simplexvariablelist .fixed false this.
externalvariables x this.
simplexvariablelist .scalefactor varfreevarindex return varfreevarindex figure extract method errors fixed.
private double x a field named x exists.
private double internalfunction double x ... for int i i this.
simplexvariablelist.length i varfreeindex loopbody varfreeindex ... private int loopbody int varfreeindex if this.
simplexvariablelist .fixed false this.
externalvariables x this.
simplexvariablelist .scalefactor varfreevarindex return varfreeindex figure missing parameter error.
the quick fix the correct parameters will be added to the declaration of the extracted method and the correct arguments will be added to its call sites.
figure illustrates the code after fixing the error.
.
.
stale invocation checker the change method signature detector described in section .
detects signature changes of a method declaration where a compiler will not issue errors.
the stale invocation checker for the change method signature refactoring simply finds invocations of the changed method and issues warnings to those that have not been updated.
the warning also has a quick fix option that can automatically update all of these invocations.
.
.
modified variable checker this checker aims at identifying two kinds of errors when performing inline method refactorings which are incorrectly updated variables andincorrectly non updated variables .
when performing the inline method refactoring after the developer replaces the invocation s of the inlined method with its method body any variable updates that were inside the method body may now change variables values in its caller possibly causing the modification to the caller s behavior.
we illustrate this incorrectly updated variable error in figure .
notice that in the method body of gotodefinitioncplusplus the parameter target is updated at line .
suppose a developer tries to inline the method gotodefinitioncplusplus after she replaces its invocation in method gotodefinition with its method body the logged value of target at line 6may differ from its previous version when target null andspan.issome true introducing a subtle bug that compiler warnings will not alert the developer about.
line 8in figure illustrates this refactoring error.
another error in inline method refactorings is incorrectly nonupdated variables .
also taking the code in figure as an example the return value of gotodefinitioncplusplus is assigned to a local variable successful at line .
to guarantee the semantic equivalence after replacing the invocation with its method body the developer needs to assign the value of10991 public void gotodefinition ... successful gotodefinitioncplusplus text target ... if successful logger.info target private bool gotodefinitioncplusplus itextview textview string target if target null ... var span wordutil.getfullwordspan wordkind .normalword caretpoint update parameter.
target span.issome ?
span.value.gettext null ... return safeexecutecommand commandnamegotodefinition figure code before inline method refactoring.
public void gotodefinition ... if target null ... var span wordutil.getfullwordspan wordkind .normalword caretpoint error .
target span.issome ?
span.value.gettext null safeexecutecommand commandnamegotodefinition error .
... if successful logger.info target figure inline method errors.
safeexecutecommand tosuccessful .
failing to do so may also cause unintentional changes to the logged message.
line 10in figure illustrates this inline method error.
to help developers identify these inline method errors the modified variable checker again performs data flow analysis the detail of which can be found in appendix .
after identifying any of these errors ghostfactor presents a refactoring warning to the developer with the problem declaration and also provides a quick fix option to help him automatically resolve this issue.
after the developer clicks the quick fix option ghostfactor performs the following changes for any incorrectly updated variable v ghostfactor introduces a new local variable v to store the value of vbefore the inlined statements and assigns the value of v back to v after the inlined statements.
line 3and line 12in figure illustrate how ghostfactor resolves the problem in figure .
for any incorrectly non updated variable ghostfactor first finds out return statements in the inlined method body before refactoring next ghostfactor finds the local variables that are supposed to save these returned values after refactoring finally ghostfactor inserts statements that assign the returned values to these local variables at proper positions.
line 11in figure illustrates how ghostfactor resolves this problem in figure .
.
limitations in this subsection we summarize the known limitations of ghostfactor.
snapshots.
ghostfactor s detection of manual refactorings relies on the snapshots taken from the developer s code changes which in turn rely on ides notifications of such event .
different ides notify plugins about source code changes at different frequency.
if the frequency is too low some significant snapshots may be missing leading to manual refactorings remaining undetected.
to deal with this limitation we plan to investigate mechanisms that optimize the likelihood of manual refactorings being public void gotodefinition ... var originaltarget target fixing error .
if target null ... var span wordutil.getfullwordspan wordkind .normalword caretpoint target span.issome ?
span.value.gettext null fixing error .
successful safeexecutecommand commandnamegotodefinition target originaltarget fixing error .
... if successful logger.info target figure inline method errors fixed.
detected without losing significant computing resources.
another limitation is that currently ghostfactor only compares the snapshots of a single file to detect refactoring.
for some refactoring types such as move method the refactorings can only be detected by synergically comparing snapshots across file boundaries.
we plan to add this feature in future work.
false positives.
like most static analysis techniques false positives happen in ghostfactor.
especially when developers interleave their refactoring changes with non refactoring changes a violation detected by ghostfactor may actually be what the developer intended .
false positives may also lead to stubborn warnings.
as we show in section the removal of a refactoring warning relies on the successful detection of a corrected refactoring.
if ghostfactor successfully detects an erred refactoring while failing to detect its later correction a refactoring warning may persist longer than appropriate.
to deal with these false positives we plan to improve ghostfactor in the following two ways add a user interface affordance that allows developers to dismiss false positive warnings and design more sophisticated algorithms for refactoring detection utilizing data collected in .
when developers dismiss false positives in ghostfactor the refactoring detection algorithms could adapt future violations accordingly.
for instance when several refactoring errors are consecutively accepted by the developer she is likely performing rootcanal refactorings where non refactoring code changes are less often interleaved .
in that situation ghostfactor can more aggressively assume detected refactorings are actual refactorings.
on the other hand if refactoring errors consistently marked by the developer as false positives ghostfactor should lower the sensitivity of refactoring detection to maintain the developer s confidence in future error messages.
false negatives.
developers may perform multiple refactorings together which may hinder ghostfactor from detecting some of them.
one example is when a developer first extracts some statements to a new method and afterwards renames the variables used in these statements.
because ghostfactor detects the extract method refactoring by measuring text similarity the detection component may not recognize this as a refactoring.
.
example we next use an example to illustrate how ghostfactor works.
suppose susan is a c developer working on the dotnumeratic open source project .
she has installed ghostfactor into her ide.
one day susan noticed that the method in figure was undesirably long.
therefore she decided to extract part of the method into a new method.
after she manually extracted the code in the box susan transformed the code in figure to the code in figure .
susan thought she had finished the refactoring correctly.
right before she started coding somewhere else ghostfactor detected the1100figure original code.
figure code after manually extracting method.
refactoring by comparing the code in figure and figure .
further analysis performed by the return value checker of ghostfactor found that the extracted method failed to return s. after that ghostfactor issued a refactoring warning to the newly extracted method as illustrated in figure .
susan noticed this warning message and was aware of this refactoring error.
so she invoked the quick fix options associated with the refactoring warning as illustrated in figure .
ghostfactor automatically added a return statement and assigned sback to the proper local variable resulting in the code shown in figure where the code automatically changed by ghostfactor is in boxes.
susan refactored correctly this time with the help of ghostfactor which afforded her the benefit of refactoring tools without requiring her to explicitly use these tools.
.
ev aluation to evaluate the effectiveness of ghostfactor in improving manual refactoring s correctness we conducted a study with participants from both academia and industry.
with this study we intend to answer the following three research questions q1.
when manually refactoring can ghostfactor help developers to refactor more correctly compared to not using it?
q2.
when manually refactoring can ghostfactor help developers achieve correct refactorings more quickly?
q3.how can we improve ghostfactor to better assist developers with manual refactorings?
our study consists of three parts a pre study questionnaire that collects participants demographic data several refactoring tasks for participants to manually finish either with or without ghostfactor and a post study questionnaire that collects participants opinions on ghostfactor.
in this section we present the design of the study and summarize the study results.
figure ghostfactor error message.
figure ghostfactor quick fix.
.
pre study questionnaire in total we recruited 8participants 6from the computer science department of north carolina state university and 2from local it companies.
we required the participants have a college degree in computer science.
as compensation each participant received a 10dollar gift card after finishing the study.
before we asked them to perform any refactorings we asked participants to complete a pre study questionnaire.
the questions collected demographic data relevant to our study.
these questions include .
how many years have you been a programmer?
.
how familiar are you with java programming language?
please rate yourself from 1to5 1for not at all and 5for expert.
.
how familiar are you with c programming language?
please rate yourself from 1to5 1for not at all and 5for expert.
.
how familiar are you with refactoring practices?
please rate yourself from 1to5 1for not at all and 5for i refactor every time i program .
.
what is the percentage of your programming time involving with refactoring?
please specify the percentage.
.
what is the percentage of your refactorings finished by applying refactoring tools?
please specify the percentage.
table presents the participants responses where the number of opaque stars indicates participants ratings on scales from 1to1101figure code after ghostfactor fixes.
.
the participants had a median of 5years for programming experience a median java proficiency of uni2600 uni2600 uni2600 uni2600 whitestar.alt1 a median c proficiency of uni2600 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 and a median refactoring proficiency of uni2600 uni2600 uni2600 uni2600 whitestar.alt1 .
all participants considered refactoring an integral part of their programming.
two participants one in the treatment group and one in the control group indicated that they do not use refactoring tools at all.
.
refactoring tasks after participants finished the pre study questionnaire we asked them to manually finish a set of refactoring tasks in visual studio .
we did not mention that the purpose of the study is to evaluate our tool we only informed participants that we were interested in how correct manual refactorings are.
afterwards we randomly assigned participants to the treatment group t in table or the control group c in table .
the treatment group refactored with ghostfactor s assistance while the control group refactored without it.
the only difference between these two groups development environments was whether ghostfactor was running.
both groups of participants were allowed to use conventional compiler warnings.
we also disabled ghostfactor s quick fix options to avoid the bias introduced by automatic code completion which could enable participants in the treatment group achieve correct refactorings faster.
we selected real code examples from an open source project called dotnumerics .
written in c dotnumerics implements multiple algorithms for linear algebra differential equations and optimization problems.
we selected this project for two reasons dotnumerics has a non trivial code base of over 10k lines of code in which we easily found real refactoring opportunities and dotnumerics contains procedures for solving well known mathematical problems that we expected participants to easily understand.
we selected 6code examples from dotnumerics where refactoring could be properly performed.
we selected these code examples based on five criteria refactoring these code examples should be particularly error prone the refactorings to be performed on these code examples should be of the types detectable by ghostfactor mentioned in section .
the errors that participants may make when refactoring these code examples should include those checkable by ghostfactor mentioned in section .
the code examples should not be too complex to refactor manually and the code examples should not manifest any syntactic differences between c and java as all 8participants had less experience in c than in java.table pre study questionnaire results for both treatment t and control c group.
years as programmerjava proficiencyc proficiencyrefactoring proficiency t uni2600 uni2600 uni2600 uni2600 whitestar.alt1 uni2600 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 uni2600 whitestar.alt1 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 uni2600 uni2600 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 uni2600 whitestar.alt1 c uni2600 uni2600 uni2600 uni2600 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 uni2600 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 uni2600 uni2600 whitestar.alt1 whitestar.alt1 whitestar.alt1 uni2600 uni2600 uni2600 whitestar.alt1 whitestar.alt1 for all of the code examples used in our study we refer readers to our project website for detail.
of these 6code examples we asked participants to perform the extract method refactoring on and the inline method refactoring on .
we chose more examples for the extract method refactoring because we have implemented twice as many checkers for that refactoring.
we did not include any refactoring tasks for the change method signature refactoring.
in exploratory iterations of this study although participants correctly performed change method signature refactorings with ghostfactor s assistance they refactored exactly as though they were using compiler warnings.
this indicated that including these tasks in the study may not produce interesting results hence we excluded them from the study described here.
the first author led participants through the code examples sequentially and asked the participants to manually complete the refactoring tasks as correctly as possible.
before a participant started to refactor we reminded her or him of the definition of refactoring correctness mentioned previously in section .
.
we recorded the screencast of participants manual refactorings using camstudio .
we used these recordings to compare the treatment and the control group s refactorings to answer research questions q1andq2.
q1.
with ghostfactor can developers refactor more correctly?
we answer this research question by comparing the correctness of refactorings assisted by ghostfactor and those that were not.
figure 17a shows the number of correct refactorings for each task performed by participants in each group.
em stands for extract method and im stands for inline method.
overall we collected refactoring assisted by ghostfactor and 24refactorings performed without ghostfactor s assistance.
23of the 24refactorings performed with ghostfactor were correct.
in contrast only 7of the 24refactorings performed without ghostfactor were correct.
ghostfactor performed especially well when assisting inline method refactoring which no participant in the control group did correctly.
ghostfactor improved our participants likelihood of performing correct manual refactorings by slash.left24 .
to further evaluate the improvement we performed the mann whitney u test on the collected data which is a statistic test that assumes neither that the data follows the normal distribution nor the minimum sample size .
we found p to be which indicates that ghostfactor significantly improves the correctness of manual refactorings .
q2.
with ghostfactor can developers achieve correct refactorings more quickly?
we answer this research question by comparing the time needed to perform correct refactorings with and without ghostfactor.
figure 17b plots the average time in seconds taken by participants in each group to correctly finish tasks.
since no participant in the control group performed the inline method refactoring correctly figure 17b does not include these tasks for participants in the control group.
according to this data the participants who used ghostfactor finished faster in three out of four110201234 im2 im1 em4 em3 em2 em14 0correct counts a refactoring correctness.
control treatment im2 im1 em4 em3 em2 em1237244 average time in seconds b refactoring time.
figure study results summary.
tasks.
to further evaluate the time difference we again apply the mann whitney u test.
we found pto be suggesting thatghostfactor may not significantly shorten the time needed to perform correct manual refactorings .
.
post study questionnaire after participants completed the refactoring tasks we asked them to take a post study questionnaire.
the post study questionnaires administered to participants in the treatment group collected participants opinions about their experiences with ghostfactor.
before they answered these questions we used the screencast of their refactorings to show the participants which ide warnings they encountered were issued by ghostfactor.
this ensured that participants differentiated ghostfactor s warnings from other warnings in the visual studio ide such as those for undefined variables and syntax errors.
the post study questionnaire asked participants to rate their agreement from 1to5 1for not at all and 5for totally agree with the following statements refactoring warnings are useful in identifying refactoring errors.
refactoring warnings are a desirable feature in ides.
overall the median rating for participants agreement with each of these statements was suggesting that developers found ghostfactor useful in helping manual refactorings and that ghostfactor may be a desirable feature in ides.
the second part of the post study questionnaire was an open question about how we could improve refactoring warnings.
participants raised several interesting points.
we use their answers to answer the research question q3.
q3.
how can we improve ghostfactor?
one participant suggested that refactoring warnings are not intuitively understandable .
like error messages from conventional refactoring tools the warning messages issued by ghostfactor are difficult to understand in the current implementation.
one way to tackle this problem is by giving developers code examples or by visualizing these errors.
to meaningfully compare the time to finish the refactorings we intentionally disabled ghostfactor s quick fix suggestions during our study but when developers use ghostfactor in the wild the quick fix preview as shown in the gray boxin figure may help developers understand refactoring warnings better.
however better ways to convey warnings meaning remains an open question for future exploration.
another participant suggested that refactoring warnings should come earlier than the refactoring s end .
he would prefer if refactoring warnings reminded him of possible refactoring pitfalls before or while he refactored instead of providing corrective messages after he has already made an error.
while we agree that showing potential refactoring errors early may help developers perform correct refactorings faster knowing a developer s intent to refactor before he actually starts refactoring is technically difficult if not impossible.
to better answer this research question we also examined the refactoring videos of those participants who used ghostfactor but did not refactor correctly.
one participant in the treatment group failed to complete im2 correctly as illustrated in figure 17a.
delving into the causes of her error we found that she accidentally deleted a statement in the method where another method should be inlined to.
even though her refactoring passed all of ghostfactor s condition checkers our tool failed to detect that the mistakenly deleted statement changed the program s behavior.
this observation suggests a need for new condition checkers that guarantee no code has been unintentionally removed by a manual refactoring.
.
discussion our study showed that ghostfactor can effectively improve the correctness of manual refactorings.
we next discuss some other interesting observations.
learning effects.
the data in figure suggests that participants generally performed later refactoring tasks more correctly and faster than earlier ones.
this observation holds for participants in both study groups.
we speculate that this performance enhancement was due to learning effects participants may have applied knowledge gained from earlier tasks to the later ones.
the knowledge gained might include what code elements need more attention during manual refactoring the meanings of refactoring warnings and how to resolve refactoring warnings.
attitude towards ghostfactor.
we observed that participants sometimes over rely on ghostfactor warnings.
one participant when refactoring manually with ghostfactor told the first author that messages are quite informative i feel like i am1103not really thinking .
this statement suggests that she feels ghostfactor warnings are guiding her refactorings rather than correcting them.
ironically one of the reasons we designed ghostfactor was to decrease developers reliance on conventional compiler warnings in refactoring for this developer ghostfactor became the tool that she relied on too much.
we believe that manually inspecting ghostfactor warnings before addressing them is a better strategy than totally relying on them while refactoring.
in contrast to the over reliant participant another participant became much more careful when performing refactoring tasks after ghostfactor first warned him of a refactoring error.
he manually examined the correctness of each complete refactoring even when ghostfactor found no errors.
we speculate that using ghostfactor increased his awareness of the error prone nature of manual refactoring.
we did not anticipate this benefit to using ghostfactor.
refactoring time improvement.
although the refactoring data we collected suggests that ghostfactor does not improve the time taken to refactor manually we speculate that as developers become expert ghostfactor users they can use ghostfactor s assistance to refactor faster.
also to reduce bias introduced by quick fixes we disabled them in the study.
we postulate that developers can correct refactoring errors faster by applying quick fixes.
furthermore ghostfactor helps developers assess the correctness of refactorings potentially saving time spent testing and inspecting refactored code.
we believe that a more comprehensive long term study of ghostfactor use may show that using ghostfactor can improve the efficiency of manual refactorings.
.
threats to validity although the study gives us confidence about the usefulness of ghostfactor several threats need to be considered when interpreting the study results.
the first threat is the limited number of refactoring tasks as well as the recruited participants 6tasks for each of 8participants which externally threatens the results generalizability to other developers refactoring tasks in the wild.
also by solely studying extract method and inline method refactorings we cannot conclude that ghostfactor can perform equally well when helping developers perform other types of refactorings.
another threat is that the tasks we picked can always lead to refactoring mistakes that ghostfactor detects.
in spite that these mistakes according to our previously collected data are frequent among developers failing to consider other refactorings performed in the wild may lead to the hasty conclusion .
the third threat lies in other reasons why participants in two groups refactor with varied correctness and speed.
ghostfactor may not be the only reason for the differences.
since we randomly assign participants to the two groups the participants in the treatment group may by themselves have better programming skills than those in the control group allowing them to refactor more correctly and quickly regardless of ghostfactor s existence.
to eliminate this threat in the future we plan to assign participants according to their reported expertise to the groups under study so that the knowledge gap between the groups are minimized.
.
future work we have implemented the ghostfactor technique as a plug in visual studio ide.
although the initial study yields promising results we plan to further explore the possibility of adopting ghostfactor as an integral part of modern ides.
in this section we summarize possible future work.
better tool.
at this point ghostfactor only supports three types of refactorings namely extract method change method signatureand inline method.
existing ides usually support more than different refactoring types .
to improve the usefulness of ghostfactor adding more refactoring types is necessary.
also as the cornerstone of ghostfactor we plan to improve the refactoring detection algorithms in terms of reducing the false negative and the false positive rates thus developers can benefit from the tool more often without being frequently disrupted by spurious warnings.
currently ghostfactor only supports checkers for refactoring errors that were manifested in our previously conducted studies.
however these errors may be only a small fraction of all the refactoring errors developers could make.
in order to better guarantee refactoring correctness we need to investigate more refactoring error patterns.
we plan to apply data mining techniques to software repositories to find these error patterns.
in the future we also plan to summarize a catalog for frequent refactoring errors like findbugs does for commonly occurring defects.
richer study.
to evaluate ghostfactor we conducted an in lab study session participated by 8developers and collected limited amount of data.
to further investigate the benefit of ghostfactor as well as its limitations a field study to observe what happens when professional developers use ghostfactor under in real world development can be beneficial.
in such a setting developers frequently interleave refactorings with non refactorings potentially leading to ghostfactor s false positives and false negatives measuring these two indicators are important to evaluate ghostfactor s effectiveness.
another goal of this richer study is to investigate the refactoring detection algorithms.
in our controlled human study the detection algorithms successfully detected all of the manual refactorings performed by the participants.
however when used in the wild the detection algorithms performance is still an open question such as their precision and recall.
the richer study may also compare ghostfactor with other tools assisting developers refactorings such as dndrefactoring and witchdoctor in terms of the usability and the usefulness.
although these tools assist refactoring in different ways such a study could compare developers effort saved during refactoring.
.
conclusion manual refactorings are error prone.
although refactoring tools are available to help they require the developer to adapt herself to the tool.
to help create a tool that is adapted to the developer we proposed and implemented a novel technique called ghostfactor that runs in the background of ides and warns developers about refactoring errors in the same manner of compiler warnings a way that most developers accustom to.
ghostfactor allows developers to benefit from refactoring tools without explicitly invoking these tools and works independent of how developers refactor by hand.
to evaluate the effectiveness of ghostfactor we conducted a human study with eight software developers who performed manual refactorings with or without the help of ghostfactor.
our evaluation results provide evidences that ghostfactor improves the correctness of manual refactorings and suggests promising future directions.
.