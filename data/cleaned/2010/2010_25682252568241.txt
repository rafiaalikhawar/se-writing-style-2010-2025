design rule spaces a new form of architecture insight lu xiao yuanfang cai drexel university philadelphia pa usa lx52 yfcai cs.drexel.edurick kazman university of hawaii sei cmu honolulu hi usa kazman hawaii.edu abstract in this paper we investigate software architecture as a set of overlapping design rule spaces formed by one or more structural or evolutionary relationships and clustered using our design rule hierarchy algorithm.
considering evolutionary coupling as a special type of relationship we investigated whether design rule spaces can reveal structural relations among error prone les whether design rule spaces can reveal structural problems contributing to error proneness.
we studied three large scale open source projects and found that error prone les can be captured by just a few design rule sub spaces.
supported by our tool titan we are able to exibly visualize design rule spaces formed by di erent types of relationships including evolutionary dependencies.
this way we are not only able to visualize which error prone les belong to which design rule spaces but also to visualize the structural problems that give insight into whythese les are error prone.
design rule spaces provide valuable direction on which parts of the architecture are problematic and on why when and how to refactor.
categories and subject descriptors d. .
general terms design keywords software architecture software quality architecture recovery .
introduction in this paper we present design rule spaces a new form of architecture representation that uniformly captures both architecture and evolution structures to bridge the gap between architecture and defect prediction.
in the eld of reverse engineering numerous techniques have been proposed permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may a s june hyderabad india copyright acm ... .
.to recover a software architecture from source code such as bunch acdc and lda .
these approaches aim to improve the accuracy and comprehensibility of the recovered architecture.
however a means of leveraging the recovered architectural structure to inform software quality issues such as the location of defects has not been explored.
on the other hand in the eld of data mining many approaches have been proposed to leverage co change information in revision history to locate error prone les and construct defect predictors .
although our recent industrial case study revealed that architecture problems are the root cause of a large number of defects the relationships between le error proneness and architectural properties have been largely ignored by the software community.
our work is rooted in baldwin and clark s concept of design rule dr architectural interfaces that decouple the system into independent modules.
we consider design rules and modules framed by the design rules as basic elements of software architecture and propose a new concept the design rule hierarchy drh to capture their relationships.
after examining how les change together in revision histories we found that when a group of les frequently changes together but they lack syntactical or architectural relationships it often implies unencapsulated assumptions implementation errors or architectural problems.
we term these modularity violations .
in our prior studies however we had to manually examine hundreds of co changed les and read thousands of developers comments to verify if a modularity violation indeed indicated an issue.
the problem is that we lack a methodology to directly and e ectively link software architecture with error proneness not all error prone les have modularity violations and vice versa.
in this paper we introduce the concept of design rule space drspace to bridge the gap between architecture and quality concerns.
a drspace is a special graph whose vertices are a set of classes with the following features its edges can be one or more selected types of relationships between classes including evolutionary coupling derived from revision history.
some of these relationship types can be designated as primary relations and the other types are secondary relations .
it must have one or more leading classes which are usually the design rules of the space.
it has to be clustered into the form of a design rule hierarchy based on its primary relation .permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in this paper we show that analysis based on just a single relationship is not su cient to capture the complexity of software systems.
instead software architecture should be viewed as multiple overlapping drspaces.
an extended example that we present in section shows that each type of dependency relation such as aggregation and inheritance forms its own meaningful drspace.
by choosing evolutionary coupling as a secondary relation within a drspace the modularity violations within the space can be visualized.
moreover design patterns used in the system also form unique drspaces that overlap with other drspaces formed by other patterns or relations.
as the rst step toward evaluating the potential of drspaces especially in terms of informing quality issues we investigated the relation between drspaces and bug spaces the spaces formed by error prone les in three large scale open source projects jboss hadoop and eclipse jdt.
supported by our tool titan we obtained three major results first if the le leading a drspace is error prone then a signi cant portion of the les within the drspace are also error prone.
we call a drspace led by an error prone le anerror prone drspace .
second although a project may have hundreds of errorprone les these les are usually contained in a few errorprone drspaces.
in all three projects more than of the error prone les are captured by just error prone drspaces.
third all error prone drspaces exhibit multiple structural and evolution issues either violating commonly accepted design principles or revealing exceptionally unstable architectural interfaces.
our result also shows that not all structural problems such as cyclic dependencies cause quality or maintainability issues.
by choosing evolution coupling as the secondary relation within a drspace we can visualize which structural problems are actually incurring high maintenance costs.
these results imply that when investing the root cause of bugs we should consider the drspace that these error prone les belong to because structural issues may contribute to their buggniness.
we will present evidence that error prone les in uence the error proneness of other les within the same drspace.
furthermore the drspace can help in identifying the root cause of the bugginess for example cyclic dependencies and thus indicate how such problems may be resolved.
the rest of the paper is structured as follows.
section presents our prior work that this work is based upon.
section introduces the concept of drspaces using an example.
section introduces our tool titan.
section presents our evaluation and results.
sections and discuss the results present related work and provide our nal conclusions.
.
background our work is rooted in the concept of a design rule dr .
drspaces based on design rules are presented in the form of adesign structure matrix dsm organized as a design rule hierarchy drh .
a drspace can help to visualize modularity violations .
design rule dr .
baldwin and clark proposed that a modular structure should be framed by design rules the architectural decisions that decouple the rest of system into modules so that modules can evolve independently fromeach other.
in modern object oriented software systems design rules are usually implemented in the form of interfaces or abstract classes.
for example if a software system employs an observer pattern the pattern should be led by an observer interface which decouples subjects from concrete observers.
if the interface is stable changes to concrete observers and subjects should not in uence each other.
in this case we consider the observer interface as a design rule and the subjects and concrete observers form two independent modules .
design structure matrix dsm .
these concepts can be visualized as a design structure matrix dsm .
a dsm is a square matrix with its rows and columns labeled by the same set of element names and or numbers in the same order.
a cell along the diagonal represents self dependency and an non empty o diagonal cell captures some relation between the element on the row to the element on the column.
for example in figure the mark in cell c r4 c1 indicates that mij.ast.number row depends on mij.ast.
node column .
the shaded squares along the diagonal model sets of elements that are grouped together.
design rule hierarchy drh .
in our prior work we proposed a concept called design rule hierarchy drh a layered structure that reveals how design rules decouple the rest of the system into modules.
a dsm with drh structure has the following characteristics the elements in the lower layers of the hierarchy only depend on the elements within higher layers i.e.
design rules elements within the same layer are separated into mutually independent groups that is independent modules .
figure depicts a drh dsm with two layers l1 rc1 and l2 rc6 .
within l2 there are mutually independent modules m1 rc6 m2 rc8 and m3 rc10 .
in this case the elements in the rst layer are the design rules of the second layer because they in uence the second layer elements but are not in uenced by them.
in our recent work we extended the original drh algorithm to better support architecture recovery from source code which we called the architectural design rule hierarchy archdrh algorithm.
archdrh recognizes the existence of another special type of element commonly found in a software architecture control programs .
a control program such as a class with a main function usually depends on many other classes but is not depended on by them.
archdrh additionally separates these control elements into the bottom of a module and supports recursively clustering the rest of the module into a drh structure.
figure depicts an output of archdrh.
the algorithm rst identi es three layers l1 rc1 l2 rc3 and l3 rc2232 .
within l2 it then calculates two modules m1 and m2 and then recursively calculates the drh structure within each module.
for example m2 is further calculated into a two layer hierarchy l4 rc11 and l5 rc2121 .
it rst separates mij.parse.parser the control class of the module into l5 and then aggregates the rest into one module m rc10 within l4.
all the dsms shown in this paper are calculated using this archdrh algorithm.
to simplify the presentation we will call the structure processed and output by our recursive archdrh algorithm a design rule hierarchy drh .
modularity violation.
in our rst work exploring the relationships between structure and history we presented a tool called clio that computes the discrepancies between968how les should change together based on their modular structure and how they actually changed together as revealed by version history a concept called modularity violation .
our experiments with open source projects showed that clio not only revealed many known structural problems such as code clones or poor inheritance it also detected large numbers of unde ned couplings that were subsequently veri ed to be harmful.
in the work of schwanke et.
al.
we reported a case study of applying the modularity violation detection approach to an industrial project.
in this study we identi ed a project s architectural problems by analyzing and investigating the structural signi cance of the most complicated and error prone les.
we also investigated how les evolved together without being structurally related.
in this way we identi ed large number of shared secrets undocumented assumptions implementation errors and architecture violations.
many of these problems directly responsible for subsequent defects.
the developers con rmed the architecture problems we identi ed and the project manager then wrote a refactoring proposal based on the results of our study.
the proposal was accepted by management and implemented.
in this paper we build and improve upon the above concepts methodologies and tools.
in particular our prior tool for identifying modularity violations clio usually outputs hundreds of modularity violations.
we had to spend a great deal of e ort manually verifying which ones really indicated architecture problems by reading developers commit messages reading the source code or talking to developers directly.
the drspace presented in the next section helps identify these problems much more e ciently.
.
design rule spaces in this section we use an example to illustrate the concept of a design rule space drspace .
de nition.
as already mentioned a drspace is dened as a graph with the following characteristics a drspace is composed of a set of classes les and one or more selected types of relations between them.
the major types of relations we explore in this paper include three major structural relations in object oriented design inheritance realization aggregation and dependency as well as one evolutionary relation evolutionary coupling derived from revision histories .
for example if two les are committed together times as recorded in the version control system we consider that they are evolutionarily coupled with a weight of during the speci ed time period.
theoretically a drspace can accommodate additional types of relations such as run time or dataow relations which we will explore in the future.
the vertices classes of a drspace must be clustered into the form of design rule hierarchy drh based on one or more selected types of relations.
we call these selected relations that form a drh structure the primary relations of the drspace.
using our tool titan the user can choose to include other types of relations in a drspace for analysis purposes which we call the secondary relations of the drspace.
for example to visualize modularity violations we rst create a drspace with one or more of the three structural relations to show the designed modular structure and then choose evolutionary coupling as the secondary relation to visualize where violations occur.
a drspace must have one or more leading classes that is the de facto design rules of the space.
if the drspace s drh has more than one layer then the classes within the rst layer are the leading classes of the drspace.
if a drspace only has one layer then all the classes can be considered as leading classes.
if a drspace ds has a leading class c we also say that dsis led by c. we call them leading classes to distinguish them from the original concept of design rules .
the latter usually refers to architecture decisions of the overall system.
a leading class of a drspace by contrast is only leading relative to a speci c drspace and may or may not be an architecturally important design rule.
at one extreme if a drspace only has one class we still call this class the leading class of the space but it cannot be a design rule because there are no other classes in its space and it doesn t decouple and frame modules.
illustration.
we now use an example to demonstrate that each type of relation or group of types can form a meaningful drspace.
using titan drspaces can be automatically calculated.
all the dsms shown in the rest of the paper are exported from titan.
for the sake of space in these dsms inheritance realization aggregation dependency and nested relations are marked in the cells using ih rl ag dp and ntrespectively.
mij.ast.node x mij.ast.treevisitor mij.ast.funcexpr x mij.ast.number xx mij.ast.operexpr xx mij.ast.unaryoperexpr xx mij.ast.variable xx mij.bnf.addexpr x mij.bnf.exponexpr x mij.bnf.grammartype mij.bnf.lexexpr x x mij.bnf.multexpr x mij.bnf.node mij.bnf.paramexpr x mij.bnf.unaryexpr x mij.bnf.valueexpr x mij.
io mij.lex.lextype mij.lex.lexeme x mij.lex.lexer x x xx mij.parse.convert x xxxxx x x x x x mij.parse.parser xxxxxxxxxxxx xxx mij.parse.parser entry x mij.filter mij.filterexception mij.interpreter x x xx x mij.interpreter calculator xxxxxxx x x x mij.repository mij.console x xxx xxx figure package clustering figures through depict the di erent modular views of a simple calculator program recovered from its java source code.
this program supports basic math calculations such as addition subtraction and multiplication.
the system is designed using an interpreter pattern with a parser and lexer.
it also employs a visitor pattern so that di erent operations can be done in the same abstract syntax tree ast .
di erent components of the system such as lexer and parser communicate with each other using a pipe and lter pattern.
as a reference we present figure to show its package structure similar to the dsm created by most reverse engineering tools such as lattix1.
figure shows that this system has ve packages depicted as shaded groups along the diagonal.
this program has classes.
the dsm shows just elements because the iopackage is collapsed.
the cells of the dsm are marked with x because it uniformly models all types of relations asdependency .
we show that the architecture of this system is composed of multi layer drspaces.
.
inheritance drspace.
figure depicts the drspace that uses inheritance realization relation as the primary relation.
there are three layers in this drspace.
the rst layer l1 rc1 contains four leading classes mij.io.pipe mij.filter mij.bnf.node and mij.ast.node .
they are leading because they do not depend on any other class and many other classes depend on them.
the second layer contains mij.io.inputpipe and mij.io.outputpipe .
because they both realize the same parent class our archdrh algorithm considers them as belonging to the same module.
the classes within these two layers decouple the rest of system into independent modules as shown in the third layer of the dsm m1 rc7 m2 rc9 m3 rc11 m4 rc1319 m5 rc20 m6 rc24 .
it is easy to see that each module has its own meaning.
for example m4 captures all the bnf classes in a module m6 groups all the ast classes into a module and m5 contains all the classes that are of type filter .
this obviously meaningful modular structure cannot been seen in other views generated by other clustering methods or using other types of relations.
mij.io.pipe mij.bnf.node mij.ast.node mij.filter mij.io.inputpipe rl mij.io.outputpipe rl mij.io.memoryoutputpipe rl mij.io.writeroutputpipe rl mij.io.readerinputpipe rl mij.io.memoryinputpipe rl mij.ast.treevisitor mij.interpreter calculator rl mij.bnf.exponexpr ih mij.bnf.unaryexpr ih mij.bnf.lexexpr ih mij.bnf.multexpr ih mij.bnf.addexpr ih mij.bnf.valueexpr ih mij.bnf.paramexpr ih mij.interpreter rl mij.parse.convert rl mij.parse.parser rl mij.lex.lexer rl mij.ast.operexpr ih mij.ast.number ih mij.ast.funcexpr ih mij.ast.variable ih mij.ast.unaryoperexpr ih figure inheritance dr space mij.io.inputpipe mij.io.outputpipe mij.io.memorybuffer mij.lex.lextype mij.lex.lexeme ag mij.ast.node ag mij.bnf.lexexpr ag mij.io.memoryoutputpipe ag mij.io.memoryinputpipe ag mij.interpreter agag mij.parse.convert agag mij.lex.lexer agag mij.parse.parser agag figure aggregation dr space .
aggregation drspace.
figure depicts the drspace in which the primary relation is aggregation.
there are two layers in this drspace.
the rst layer l1 rc1 contains four modules of leading classes and the second layer contains three meaningful modules.
for example m1 rc8 is amemorybuffer module that contains two classes using it m2 rc10 groups major components such as parser and lexer together because they all communicate through pipes and thus aggregate mij.io.inputpipe and mij.io.outputpipe.
.
dependency drspace.
figure depicts the drspace with dependency as the primary relation.
completely different from the other two drspaces this drspace shows how classes work together to accomplish a function.
for example m rc11 shows which classes the parser needs in order to accomplish the parsing function.
mij.filterexception mij.lex.lexeme mij.ast.treevisitor mij.ast.node mij.interpreter dp dp mij.ast.operexpr dp mij.ast.number dp mij.ast.funcexpr dp mij.ast.variable dp mij.ast.unaryoperexpr dp mij.bnf.lexexpr mij.bnf.exponexpr mij.bnf.valueexpr mij.bnf.unaryexpr mij.bnf.multexpr mij.bnf.addexpr mij.bnf.paramexpr mij.bnf.node mij.bnf.grammartype mij.lex.lextype mij.parse.parser dpdp dpdpdpdpdpdpdpdpdpdp mij.parse.parser entry mij.interpreter calculator dp dp dpdpdpdpdp mij.io.memoryoutputpipe mij.io.inputpipe mij.io.memoryinputpipe mij.lex.lexer dpdp mij.io.memorybuffer mij.parse.convert dp dp dpdpdpdpdpdp dp mij.io.readerinputpipe mij.filter mij.console dp dp dp dpdpdpdpdpdpdpdp figure dependency dr space mij.ast.treevisitor mij.ast.node mij.ast.number dpih mij.ast.operexpr dpih mij.ast.funcexpr dpih mij.ast.variable dpih mij.ast.unaryoperexpr dpih mij.interpreter dp ag mij.interpreter calculator rldpdpdpdpdpdp mij.parse.convert dpdpdpdpdpdp figure visitor dr space .
pattern drspace.
figure depicts a drspace led bymij.ast.treevisitor .
as we can see this drspace captures the overall structure of the classes that participate in the visitor pattern.
the key design rules of this pattern include mij.ast.treevisitor acting as the role of visitor interface and mij.ast.node acting as the element interface.
the classes in the module m rc3 contains all the concrete elements of the pattern.
these classes are all subclasses the ih relation of mij.ast.node which lls the element role in the visitor pattern.
they all accept the visitor interface and pass themselves to the visitor interface the dp relation as required by the pattern.
the calculator class takes the concrete visitor role through the realization rl relation to mij.ast.treevisitor .
.
hybrid drspace.
figure depicts a drspace in which the drh is produced using all three types of structural relations as primary ones.
as we can see all the interesting and meaningful modular structures that can be observed from previous drspaces are all mixed up and become less obvious.
the drh now has many more nested layers.
in this drspace we also choose evolutionary coupling as the secondary relation.
for example cell c r13 c4 has number meaning that mij.ast.node and mij.io.inputpipe changed together times in the revision history.
this cell has dark background and white font to indicate that there97012 mij.io.pipe mij.io.outputpipe rl mij.io.writeroutputpipe rl mij.io.inputpipe rl mij.io.memorybuffer mij.filterexception mij.filter mij.lex.lextype mij.lex.lexeme ag mij.bnf.node mij.bnf.lexexpr ag 3ih mij.ast.treevisitor mij.ast.node ag mij.ast.operexpr dp ih mij.ast.number dp ih mij.ast.funcexpr dp ih mij.ast.variable dp ih mij.ast.unaryoperexpr dp ih mij.io.memoryoutputpipe rl ag mij.io.memoryinputpipe rl ag mij.lex.lexer ag ag dp rl dp mij.repository mij.interpreter ag ag dp rl dp ag mij.interpreter calculator dp rl 3dp dp dp dp dp dp ag mij.parse.convert ag ag rl dp dp dp dp dp dp dp dp dp mij.bnf.exponexpr ih mij.parse.parser entry mij.bnf.valueexpr ih mij.bnf.unaryexpr ih mij.bnf.multexpr ih mij.bnf.addexpr ih mij.bnf.paramexpr ih mij.bnf.grammartype mij.parse.parser ag ag dp rl dp dp dp dp dp ag 4dp dp dp dp dp dp mij.io.readerinputpipe rl mij.console dp dp dp dp dp dp dp dp dp dp dp figure dr space with history are no structural relations between these classes.
the content in cell c r23 c2 is ag meaning that mij.interpreter aggregates mij.io.outputpipe and they changed together times in the revision history.
as an illustrative example the history of this system is faked.
in real systems as shown in section the dark cells indicate modularity violations.
in summary it is clear that the architecture of this small system can be viewed as a set of multi layer drspaces.
each drspace re ects a unique aspect of the architecture that cannot be captured using any other types of relations or clustering methods.
.
tool support in this section we brie y introduce our tool titan that supports the creation and visualization of drspaces.
all the gures and tables in the paper were created using data exported from titan.
titan accepts dsm les with extension .dsm and clustering les with extension .clsx as input.
a .dsm le captures pair wise relations among classes.
for a structure dsm the number in a cell is used to represent di erent types of relations.
so far our tool processes inheritance realization dependency nested and evolutionary coupling relations.
for a history dsm the number in a cell represents the number of times the two classes changed together where changed together means that both classes were involved in the same commit which is called co change frequency .
one .dsm le can be associated with multiple clustering les each representing a di erent way the dsm can be clustered.
figure shows a snapshot of titan s gui.
similar to commercial tools with dsm based user interfaces titan has a tree structure view the top right part and a dsm view the lower right part .
the tree view.
when a structure dsm le is rst opened the tree view renders classes randomly.
after the user loads a clustering le the tree view is redrawn to reect the given structure.
using the tree view the user can expand collapse group and ungroup classes and the dsm view will be updated when the user clicks the redraw button.the user can also cluster the dsm using an algorithm by choosing the clusters menu item.
as shown in the gure currently titan supports the following clustering methods .
package cluster.
the dsm will be clustered based on the project s package and namespace structure as supported by other commercial tools.
.
archdrh cluster.
this is the clustering method we employed to generate drspaces in this paper.
the algorithm is described in our prior work .
.
archdrh acdc cluster and archdrh bunch cluster.
as introduced in each inner module of a dsm rst framed using archdrh can be further clustered using other algorithms.
we do not further discuss these functions here.
the user can also view partial dsms in two ways.
if a tree node folder is selected the subsystem button will be activated.
clicking it creates a new gui instance showing just the subspace within the chosen folder.
if a dsm is clustered using archdrh and at least one tree leaf class is selected the split button will be activated.
clicking it creates a new window that contains only the classes in the drspace led by the selected class es .
all the drspaces in this paper are generated this way.
the window created by clicking the split or subsystem button is exactly the same as the original gui so that the user can treat the subspace as an entirely independent design space which can be further manipulated or split.
the dsm view.
in the dsm view each group of classes are colored using a dark background.
a nested group always has a darker background than the outside group.
the diagonal line is labeled with the index of the class.
the relation displayed in the cells can be controlled using the check boxes located at the left lower corner of the gui.
the user can check and uncheck any listed relation or any combination of them to control the display.
once the relation types are selected clicking the clustering menu item will cluster the dsm using the selected relations as primary relations.
that is how we generated the aggregation inheritance and dependency drspaces for example.
to show the evolution coupling together with structure relations the user rst loads a history dsm and then checks971the history checkbox.
the cells of the dsm will then display how many times each pair of classes have changed together in the history.
for example the dsm in figure displays aggregation nesting and history relations.
the cell c r8 c2 has aggregate meaning that jdbcstopcommand aggregates jdbcentitybridge and they changed together times.
if two classes do not have any structural relation but still changed together the cell will have a red background.
for example cell c r2 c1 shows that although jdbcentitybridge and relationdatamanager have no structural relation they changed together times.
the user can control the threshold of the co change frequency to be displayed by checking the threshold box and lling a number in a pop up window.
in the dsm of figure the threshold is set to so that only cells with co change frequency of or more are displayed.
to summarize the key di erences between titan and other commercial dsm tools titan allows the user to choose any combination of relation types and to cluster the dsm based on the selected primary relation s only.
moreover it supports the display of evolutionary coupling data together with structure relations so that their discrepancies can be visualized.
.
evaluation as our rst evaluation of the usefulness of drspaces we determine whether they can provide insights on bug location.
we explore the following research questions rq1 is it true that if a design rule is error prone then the les contained in its drspace are also error prone?
if the answer is yes it means that these error prone les within the same drspace should be considered together because they are structurally related even though these les may not depend on each other directly these design rules should be given higher priority in terms of bug xing and potentially refactoring given their signi cant impact.
rq2 are most error prone les concentrate in a few dr spaces?
if the answer is yes this implies that even if a system has hundreds of error prone les we should be able to understand their relationships by just looking into a few drspaces.
furthermore this implies that these error prone les or error prone le groups are not isolated they are figure the graphical user interface of titanstructurally related and thus should be analyzed and xed as a group.
rq3 by combining information about evolution and structure coupling can we get more insight into architectural problems?
can this help us nd not just the locations of errors but also the reasons for them?
so far the prevailing bug location research focuses on where the bugs are rather than why these locations are error prone.
although error proneness can be caused by many reasons our recent work has shown that structural errors can be an important cause of bugginess.
here we explore whether the combination of di erent types of drspaces can shed light on the structural problems among these errorprone les.
.
subjects we choose three large scale open source projects as our evaluation subjects jboss2 a java application server hadoop common3 the common utilities supporting a suite of distributed computation tools and eclipse java development tools jdt a core ast analysis toolkit in the eclipse ide.
for each project we choose one target release to analyze its drspaces.
we made sure however that there were at least releases before the target release so that we could produce history dsms and identify error prone les.
the target project releases evolution history time span and the number of releases before the target can be found in table .
similar to our prior work we generated history dsms using revision and issue tracking histories.
using hadoop as an example we investigated its svn repository to extract transactions.
in table we present data regarding the number of les files releases rel.
transactions trans.
and issues issues we studied.
we removed commits with only one le or more than les because they either do not contribute to evolution coupling or they introduce substantial noise in the data such as bulk changes to les to update license information.
table subject system information subject history files rel.
trans.
issues jboss3.
.
apr jun hadoop0.
feb oct eclipse3.
.
may mar .
drspace error proneness to answer the rst research question for each target release we rst ranked all the les by the number of times they were involved in bug xes.
as others have observed in bug prediction research the more often a le is involved in a bug x the more error prone it is.
for each of the most error prone les in each project we used titan to determine its drspace.
if the size of a drspace is small it means that this le does not have high impact.
we then rank the size of the drspaces of the most error prone les and we only consider drspaces with at least les which we calltop drspaces .
table summarizes the status of top drspaces for each project.
for example in jboss out of the most errorprone les lead a drspace with at least les.
in both top drspaces topdrsavg.
in bug2 avg.
in bug5 avg.
in bug10 dsb bsc dsb bsc dsb bsc jboss hadoop eclipse hadoop and eclipse this number is .
because there is no obvious threshold on the number of bug xes to determine if a le is error prone for each project we use the following conventions we de ne a bug space bugn as the set of les with at least nbugs.
the size of a bug space is the number of les within it.
in this research we chose values of and for n resulting in three bug spaces bug2 bug5 and bug10.
we next de ne design space bugginess dsb if a drspace has m les and nof them are within a bug space we de ne n m as the design space bugginess of the drspace represented as dsbin the tables.
and we de ne bug space coverage bsc if a drspace hasn les in bugx then the bug space coverage of the drspace with respect to bugn is n size bugn .
for example in jboss there are a total of les with or more bug xes bug2 les with or more bug xes bug5 and les with or more bug xes bug10 .
table jboss s top drspaces drs bug bug2 bug5 bug10 rank dsb bsc dsb bsc dsb bsc dr1 2nd dr2 4th dr3 7th dr4 12th dr5 21st consider design rule dr2 org.jboss.ejb.container whose data is shown in the second row of table .
it is the 4th most error prone le in jboss and leads a drspace with les.
of these les of them have more than bug xes.
thus the bscof dr2 in jboss is with respect to bug2.
similarly we calculate the bscfor bug5 as out of and for bug10 as out of .
furthermore the dsbof dr2 is with respect to bug2 out of the les within dr2 are in bug2 with respect to bug5 of the les are in bug5 and with respect to bug10 of the les are in bug10 .
table lists the rst out of most error prone drspaces in jboss.
consider dr5 beanmetadata it has the largest drspace with les.
within these les have more than bug xes have more than bug xes and have more than bug xes.
these les cover more than of the all the les in bug10.
this result shows that not only is beanmetadata itself bug prone it has bug xes and is ranked the 21st overall in terms of error proneness but a substantial part of the drspace it is leading is also error prone.
the other4 drspaces show similar results their dsbvalues for bug2 bug5 and bug10 range from and respectively.
table shows the average dsband bscvalues for each project.
the rst line of the table shows that in jboss there are drspaces led by the most error prone les.
on average within each drspace of the les have more than bug xes of them have more than bug xes and have more than bug xes.
although the dsb decreases with higher threshold of bugginess the bscincreases.
for example the average bug space coverage of a jboss drspace in bug10 is meaning that on average each top drspace in jboss contains about one third of the most error prone les with or more bug xes each .
interestingly table also shows that the bscand dsb for eclipse drspaces are much lower than the other two projects.
for example its design space bugginess for bug5 is only about one third of the other two projects and .
to explore why eclipse is special we calculate the dependency density of each top drspace of each project.
the dependency density is the number of dependencies within a drspace divided by the square of its size.
the higher the density the more tightly coupled the les within the drspace.
the result shows that the average density for jboss and hadoop drspaces are and respectively while the density for eclipse is only .
now the results become intuitive the more highly coupled the les within a drspace the more that the drspace can be in uenced by error prone design rules and neighbor les.
in summary these results show that if a le is error prone and leading a highly coupled drspace then a signi cant portion of the drspace is also error prone.
we thus call a drspace led by an error prone le an error prone drspace .
.
error prone drspace coverage now we investigate the second research question.
a project may have hundreds of error prone les.
can they be captured by a much smaller number of drspaces led by errorprone design rules?
we explore this problem by answering two complementary questions how many drspaces are needed to maximally cover bug2 bug5 and bug10?
how large a bug space can the top largest drspaces cover?
to answer these questions we ranked all the drspaces with at least les led by error prone les based on their non overlapping bug space coverages.
the results summarized in table answer the rst question.
take jboss for example the rst drspaces cover of the bug2 space the rst drspaces cover of the bug5 space and the rst drspaces cover of bug10 space.
we never reach coverage because we are only considering drspaces with at least les the other error prone les are distributed in smaller drspaces.
table minimal error space coverage projbug2 bug5 bug10 drs bs drs bs bs jboss hadoop eclipse to answer the second question we list the bscof the rst and drspaces in table .
this table shows that the top 5973drspaces of any of the three projects within any of bug2 bug5 or bug10 can capture more than half of the errorprone les within each bug space.
the top drspaces can cover from to of a bug space.
interestingly by looking at just the top drspaces we do nearly as well we can cover from to of a bug space.
in summary the answer to the second research question is yes indeed most error prone les are concentrated in just a few drspaces.
table top space bug coverage projbug2 bug5 bug10 top top top top top top jboss hadoop eclipse .
the structure of error prone spaces the results reported in the previous sections imply that large numbers of error prone les belong to the same few drspaces.
the question is whether these drspaces can provide insights into the reasons why these les are errorprone.
for example figure depicts the drspace led by jdbccmrfieldbridge .
we obtained this drspace by rst clustering the overall dsm using archdrh.
we then chose this le in titan and clicked the split button.
this le has bug xes and is ranked as the 2nd most error prone in the project.
this figure shows its drspace with only the aggregation relation together with evolutionary coupling.
a pair of les that have no structural relation but only evolutionary coupling are shown as dark background cells with white font.
the threshold of evolutionary coupling is set to .
first the large number of dark cells indicates that there are many modularity violations.
these violations can be separated into two categories the les whose names include command are always changed together the relationdatamanager always changed together with these command les.
although it is not possible to know why this le is error prone this dsm reveals obvious structural issues that violate well known design principles.
first consider l rc5 a layer containing all the command classes and the jdbcstoremanager class.
the latter aggregates all the command classes and is aggregated by of them.
this cyclical aggregation relation obviously violates good design principles.
it seems that the developers intended to apply a command pattern but the dsm does not reveal a valid command pattern structure where the client which in this case seems to be jdbcstoremanager should only depend on an abstract command interface rather than on concrete commands.
this dsm also shows another aggregation cycle in rc .
second it is not obvious why concrete commands always change together with relationdatamanager even though there is no structural relation between them.
it seems that relationdatamanager shares some secrets with these command classes.
we studied all the error prone drspaces of each project and observed that they often exhibit the following problems .
aggregation dependency cycles once we select just aggregation or dependency as the primary relation we found that many error prone drspaces exhibit multiple aggrega tion or dependency cycles.
for example in the drspace led bymetadata.jdbcentitymetadata there are aggregation cycles.
in one of them jdbcentitybridge 71st most errorprone and jdbccmrfieldbridge 2nd most error prone aggregate each other!
di erent from other tools that can detect cyclic relations our tools show the penalty of such relations.
for example our tools show that jdbcentitybridge and jdbccmrfieldbridge changed together times.
furthermore it should be noted that not all cyclical relations are harmful.
cascadedeletestrategy and jdbccmrfieldbridge also aggregate each other but they never changed together and cascadedeletestrategy has no bug xes.
a tool that simply identi es cyclic relations can not distinguish between harmful and harmless cases.
as another example fsnamesystem has bug xes and is ranked as the number most error prone le in hadoop.
from its drspace with les we can see that fsnamesystemis involved in a dependency cycle with les and an aggregation cycle with elements.
.
problematic inheritance hierarchy.
inheritance issues manifest themselves in di erent ways including parent and children frequently changing together a client inheriting a parent class while aggregating its child a parent depending on one of its children etc.
figure shows the inheritance drspace of filesystem ranked the 13th most error prone .
we obtained this space by clustering the drspace using inheritance as the primary relation and then selecting dependency as the secondary relation when we saw that filesystem depends on one of its children distributedfilesystem .
after choosing evolutionary coupling as another secondary relation we can see that these two les changed together times while the other elements within the same space changed together to times.
figure also depicts an example where problematic cochanges may notbe modularity violations titan did not mark the relation between distributedfilesystem andfilesystem as a violation because they do have structural relations.
however the fact that they changed together unusually frequently and that they have both inheritance and dependency relations indicates that there is something wrong.
org.apache.hadoop.fs.filesystem dp org.apache.hadoop.fs.filterfilesystem ih org.apache.hadoop.fs.rawlocalfilesystem ih org.apache.hadoop.fs.s3.s3filesystem ih org.apache.hadoop.fs.kfs.kosmosfilesystem ih org.apache.hadoop.dfs.distributedfilesystem ih org.apache.hadoop.dfs.hftpfilesystem ih org.apache.hadoop.fs.inmemoryfilesystem rawinmemoryfilesystem ih figure hadoop filesystem inherit drspace as another example jobtracker in hadoop is ranked most error prone with bug xes.
in its inheritance drspace after choosing dependency and aggregation as secondary relations we saw that jobtracker depends on conf.
con guration and aggregates mapred.jobconf which in turn is a child of conf.con guration.
both of mapred.jobconf and conf.con guration are highly buggy ranking 21st and 26th respectively.
they both lead large error prone drspaces with and les respectively.
since jobtracker either depends on or aggregates them it is not surprising that it is the most error prone le of the entire project.
relationdatamanager jdbcentitybridge ag cascadedeletestrategy ag ag jdbccmrfieldbridge ag ag ag jdbcinsertrelationscommand jdbcdeleterelationscommand jdbcpostcreateentitycommand ag ag jdbcstopcommand ag ag jdbcremoveentitycommand ag ag jdbcstartcommand ag ag jdbcloadrelationcommand ag ag readaheadcache ag jdbcstoremanager ag ag ag ag ag ag ag ag ag jdbcabstractquerycommand ag ag jdbcejbqlcompiler ag relationdata ag relationpair ag leftjoincmrnode ag relationset ag cmrchainlink ag figure jboss jdbccmrfieldbridge drspace although we can not enumerate all possible problems in all the error prone drspaces there are many possible combinations of relation types and drspaces we observe that indeed each error prone drspace has more than one type of structural issue.
again we consider them as problematic because they violate common design principles and the les involved in these structural problems are both highly errorand change prone.
shared secrets.
by displaying evolutionary coupling together with structural drspaces we were able to identify large numbers of co changes among les with neither structural relations nor obvious structural problems.
we hypothesize that this indicates that there are shared secrets that cannot be captured by structural information alone.
in our future work we will investigate this hypothesis.
.
result summary now we can positively answer the three research questions posed at the beginning of the section.
rq1 indeed if a le is error prone itself and leading a non trivial and highly coupled drspace then a signi cant number of the les within its drspace are also error prone.
rq2 although each project may have hundreds of errorprone les these les are often captured by just a few drspaces.
in all projects studied with all three types of bug spaces the largest drspaces always captured more than half of the les in the bug space.
rq3 by examining drspaces with di erent types of primary and secondary relations we found that all errorprone drspaces also have more than one structural problem that violate commonly accepted design principles.
the most prominent problems include large dependency or aggregation cycles problematic inheritance hierarchies the aggregation or inheritance of highly error prone les and the existence of potential shared secrets.
.
discussion in this section we discuss the threats to validity of our evaluation as well as our planned future work.
threats to validity.
our evaluation is subject to internal threats to validity.
we chose several thresholds purely based on our observations.
for example we only consider a drspace with at least les because we observed that the smaller the drspace led by an error prone le the larger the percentage of les within the drspace that are also error prone.
consider drspaces with or fewer les only the average design space bugginess of these small drspaces in jboss and hadoop are and respectively where the smaller the size we see the highest percentages.
this is intuitive because in smaller drspaces the les are more closely related and thus impacted by each other and their structural problems are relatively easy to directly identify.
the larger the drspace the more indirect the relationships among the les in general and thus their structural problems will be more complex and subtle.
other important thresholds we choose include the sizes of bug spaces we choose and based on the observation that when the threshold reaches the number of drspaces with more than les is already very small.
both hadoop and eclipse have such drspaces and jboss only has .
as a result we believe that is a reasonable threshold and that bug2 bug5 bug10 re ect drspaces with low medium and high error proneness across all three projects.
we used the threshold of most error prone les because we observed that in all three projects the bug ranking of les leading the largest drspaces are within this scope.
for example in hadoop the le beanmetadata is the 21st errorprone and leads the largest drspace of size .
our results may however be impacted if we choose di erent thresholds for di erent projects.
in the data reported thus far we used all the history for each project to calculate evolutionary coupling and bug proneness.
our prior work showed that recent history has a di erent impact than more distant history.
to determine the impact of history we recalculated all the data reported here based on just the most recent releases of each project.
this analysis showed that the top drspaces and bug ranking order of their leading les are somewhat di erent but the general conclusions are exactly the same a signi cant part of the drspace led by an error prone le is also error prone and a small number of drspaces can cover most of the bug spaces in consideration.
our evaluation is also subject to several external threats.
first as with other history based bug prediction work we link a bug with a le by searching developers commit messages when they submit changes to a le trying to nd bug ids associated with the commit.
however as prior work has pointed out since there is no guarantee that developers always report which commits are xing which bugs the bug space we considered may be biased.
the second threat comes from the subject projects we chose.
we only studied open source projects all of which are written in java.975the results could be di erent for closed source industrial projects and for projects implemented using other objectoriented programming languages.
future work.
we envision that drspaces can be useful in many ways.
first we have observed the potential of using drspaces to identify design patterns.
we observe that a design pattern typically leads its own design space.
the visitor pattern in figure is an example.
we plan to investigate how to leverage drspaces for design pattern detection and compare the results with other existing design pattern detection techniques.
our prior work has shown that modularity violations usually reveal architecture problems or shared secrets.
while the work reported in this paper investigated the relation between drspaces and error proneness one interesting future research direction is to study the relation between drspaces and change proneness and architecture violation proneness.
we also plan to investigate the possibility of leveraging drspaces to detect architecture violations design pattern degradation and implementation errors that violate the designed modular structure using both open source and real industrial projects.
.
related work our work is related to considerable prior research.
design structure matrix tools.
there are several commercial dsm tools available such as lattix structure 5and ndepend.6these tools also reverse engineer dsms from source code.
sangal et al.
reported a study of using lattix to identify dependency violations.
however this required manually specifying which classes should not depend on which other classes.
unlike these dsm tools titan integrates structural relations and evolutionary coupling and supports archdrh clustering to reveal multiple drspaces by exibly choosing any combination of primary and secondary relations.
metrics and defects.
using dependency structure to locate software defects has been widely studied as exemplied by the work of selby and basili .
researchers have proposed various metrics to predict failure proneness from coupling measures such as the work of chidamber and kemerer .
the relation between evolutionary coupling and error proneness has also been widely studied.
for example cataldo et al.
reported a strong correlation between change coupling density and failure proneness.
fluri et al.
also reported that a great deal of evolutionary coupling is not captured by structural dependencies.
ostrand et.
al.
reported that le size was the most signi cant factor in uencing the number of faults.
nagappan et.
al.
demonstrated that complexity metrics can be successful bug predictors.
they also claimed there was no single best set of metrics for all projects.
in their investigation of network measures such as closeness zimmermann and nagappan reported that network measures were capable of predicting twice as many defects as complexity measures.
by contrast our study revealed that most error prone les can be captured by a few drspaces led by error prone design rules and how these error prone les in uence each other structurally suggesting how these les should be changed.
recovery.
several algorithms have been proposed to recover software modular structure from source code.
the most representative ones include bunch acdc and lda .
bunch is a coupling and cohesion based clustering method proposed by mitchell and mancoridis .
it groups highly interdependent nodes of a dependency graph into one subsystem and separates independent nodes into di erent subsystems to maximize cohesion and minimize coupling within a subsystem.
algorithm for comprehension driven clustering acdc is a patterndriven algorithm developed by tzerpos and holt .
it rst constructs a system skeleton by identifying frequently recurring patterns and then uses an orphan adoption algorithm to cluster leftover les.
gethers and poshyvanyk claimed that structure based clustering algorithms cannot capture conceptual dependency and proposed a new coupling metric called relational topic based coupling rtc to capture latent topics and relationships among source code leveraging lda a probabilistic topic model.
these algorithms however only process one type of relation.
by contrast our drspaces revealed multi layer multitype modular structures formed by the exible combination of primary and secondary relations.
while their purpose is to help developers understand the structure more easily our goals are to use drspaces to inform the root causes of defects.
.
conclusions in this paper we have introduced design rule spaces a new form of architecture representation that uniformly captures both architecture and evolution relations using design structure matrices.
we proposed that software architectures should be viewed and analyzed as multi layered overlapping drspaces because each drspace formed using di erent types of primary and secondary relations exhibits meaningful and useful modular structures.
each of these structures promotes and supports a di erent kind of analysis.
as the rst attempt to bridge the gap between architecture and defect prediction we studied the relationships between drspaces and bug spaces in three large scale open source projects.
the results showed that error prone les usually lead error prone drspaces in which most of the les are also error prone and that a few error prone drspaces can capture a large portion of the project s error prone les.
most interestingly by viewing di erent drspaces of the same architecture formed and complemented by di erent types of relations we were able to identify a large number of structural and evolutionary problems that may contribute to the root cause the structural cause of bugginess.
this analysis can aid the architect in determining when and how these error prone les should be xed.
we envision that drspaces have the potential to change how software architecture is viewed modeled and analyzed today and to bridge the gap between architecture and defect prediction by not only locating error prone les but also providing suggestions for corrective maintenance.
.