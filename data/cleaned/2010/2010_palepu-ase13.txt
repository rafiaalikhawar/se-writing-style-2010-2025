improving efficiency of dynamic analysis with dynamic dependence summaries vijay krishna palepu guoqing xu james a. jones university of california irvine abstract modern applications make heavy use of third party libraries and components which poses new challenges for efficient dynamic analysis.
to perform such analyses transitive dependent components at all layers of the call stack must be monitored and analyzed and as such may be prohibitively expensive for systems with large libraries and components.
as an approach to address such expenses we record summarize and reuse dynamic dataflows between inputs and outputs of components based on dynamic control and data traces.
these summarized dataflows are computed at a fine grained instruction level the result of which we call dynamic dependence summaries.
although static summaries have been proposed to the best of our knowledge this work presents the first technique for dynamic dependence summaries.
the benefits to efficiency of such summarization may be afforded with losses of accuracy.
as such we evaluate the degree of accuracy loss and the degree of efficiency gain when using dynamic dependence summaries of library methods.
on five large programs from the dacapo benchmark for which no existing whole program dynamic dependence analyses have been shown to scale and versions of n ano xml the summarized dependence analysis provided accuracy and a speed up of i.e.
on average when compared to traditional exhaustive dynamic dependence analysis.
i. i ntroduction as the needs of society are increasingly accomplished with software systems and those software systems become more complex and interrelated software developers are to an increasing extent building components of software that interact with and build upon existing software components.
rather than writing all needed functionality from the low level operating system to the high level client interfaces developers regularly use features that were developed by others provided by components such as apis libraries middleware and infrastructures.
today s reality is a scenario that was predicted by mcilroy in the 1960s.
numerous researchers have identified some of the challenges that can be faced when depending upon and assembling existing components often referred to as components off the shelf or cots .
one of the common challenges to reusing third party components is that analysis tasks become increasingly expensive as the extent and depth of component reuse increases e.g.
layer upon layer of transitive component reuse .
to properly analyze the program the effects of the infrastructure must be understood.
as such complete analysis should also analyze all transitively underlying components to determine how they affect the program under test.
orso et al.
discussed some of the challenges of performing analysis in the presence of external components and proposed abstract representations i.e.
metadata to provideinformation about component functionality.
later orso et al.
extended these ideas for component metadata by specifying a concrete metadata scheme to enable regressiontest selection in the presence of components.
although orso s solution for regression test selection provides a powerful solution for that specific task such challenges extend to many other more heavyweight dynamic software analysis tasks.
for example when performing a dynamic dependence analysis the analysis needs to trace data flows through any encountered libraries and components during the whole execution.
frequent profiling of methods in these libraries and components contributes extensively to the already large run time costs making the analysis prohibitively expensive for large scale long running applications.
for example our experiments show that recording a whole dependence trace for dacapo antlr with even small workloads requires more than hours.
the analysis time can be reduced to less than hours if the library methods in rt.jar are not instrumented.
an important technique to reduce the analysis costs and provide such metadata is to summarize the behaviors of these components.
once generated summaries are then applied during future executions to improve analysis efficiency.
in fact summary based analysis has been extensively studied in the static analysis community and various techniques such as have been developed to summarize procedural effects to achieve both modularity and efficiency.
however static summaries provide conservative overapproximations when describing heap data effects.
for example such summaries are often imprecise in modeling heap locations and distinguishing among array elements making it particularly difficult for a dynamic analysis to use.
in this paper we propose to compute summaries dynamically to improve the efficiency of dynamic analyses and to provide precise dependence metadata.
summaries generated over representative runs of the selected library methods are abstracted and applied in the analysis of a program that invokes these methods leading to substantially reduced analysis running time and trace size.
in this paper we use dynamic dependence analysis as an example and show how to compute dynamic dependence summary information to enable developers to characterize and capture external effects of reused components for modern object oriented languages.
as dependence analysis provides a basis for a variety of dynamic techniques such as program slicing bloat analysis tainting based information flow analysis and potential parallelism detection our technique providesa mechanism to provide increases in efficiency in terms of time and space with the potential tradeoff of accuracy loss.
this work provides the first technique for producing dynamic summaries and evaluates the tradeoff between speed and accuracy.
to evaluate we implemented our summary based dynamic dependence analysis and performed two experiments.
the first experiment evaluates the efficiency and cost gains by reusing external component analysis on large programs to which no existing dynamic dependence analyses have been shown to scale.
the second experiment examines the analysis accuracy of using the summarized metadata versus performing exhaustive analysis through all external components.
our experiments show an accuracy of and a speed up i.e.
on average when compared with traditional exhaustive dynamic dependence analysis.
the main contributions of this work are definition of the technique for producing summarized analysis results for software components which can enable improved efficiency of subsequent analysis tasks.
designation of the process by which developers can capture and encode component analysis results in the form of dynamic dependence summaries and then reuse those summaries for future analysis tasks.
evaluations of the impact of utilizing such summary metadata for dynamic analyses in terms of both effectiveness and efficiency.
ii.
m otivation and challenges motivating example.
we now present a motivating example program that will be used throughout the paper.
figure a shows the simple program containing the implementation of a data structure intlist and a client that creates and uses two intlist objects line and .
lines show a loop each iteration of which adds an element into the intlist object created in line .
lines and retrieve elements from the two intlist objects respectively.
figure b shows the dynamic data dependence graph of the program.
each node in the dependence graph is represented by the line number of a source code statement annotated with an integer irepresenting the ithexecution of the statement.
each edge represents a data dependence relationship between two statement executions.
a dashed line box excapsulates nodes and edges in a single method execution.
in this paper we address the summarization of the data dependence relationships.
summaries for control dependence can be similarly computed and will be described in the future work.
a typical object oriented application makes heavy use of libraries and frameworks such as class intlist in our example.
library methods such as add andget are frequently executed tracking and profiling all their executions can be extremely expensive.
for instance the loop in line may iterate for a great number of times leading to a prohibitively large execution trace and dependence graph.
a natural idea to reduce the profiling cost would be to summarize the effects of such library methods and apply thesummaries when they are invoked.
summaries can be computed via static analysis as proposed by horwitz reps and binkley by summarizing all possible statically computed dependence relationships between the inputs and outputs of a method.
when a library method is invoked during a dynamic dependence analysis the statically computed summaries can be applied to find the appropriate dependence relationships while avoiding the dependence profiling of the library method.
however the overly conservative modeling in a static analysis can lead to rather imprecise summary information e.g.
.
for example a typical static analysis unifies all possible effects of the invocation of a polymorphic method resulting in spurious dependence relationships between the site of the method invocation and the instructions in all possible implements that realize the polymorphic method in question.
dynamic analyses based on such spurious relationships may not produce useful information because polymorphism is a widely used feature of object oriented programming.
we propose to compute summaries using dynamically observed information.
we envision that such dynamic summaries may be computed in the following two ways.
the dynamic information may be generated and recorded in a separate training phase in the from of execution traces using a test suite the dependence information and subsequently the summaries are computed from the execution traces and stored to a disk file for use in a future dynamic dependence analysis.
alternatively the dependence information and thus the summaries may be computed entirely online i.e.
during execution and then be used later in the same execution.
for instance for the program in figure we can use the first execution of add orget to compute its dependence summary and apply it to reduce the profiling cost of its second execution.
while the first approach to compute summaries is used in this work it can be easily modified to adopt the second approach.
we now present the challenges against computing dynamic based summaries.
challenge defining dependence summaries in java.
horwitz et al.
pioneered the work of summary based dependence analysis a summary edge of a procedure connects an input parameter iwith an output parameter o abstracting away intermediate dependence relationships inside the procedure.
this summary edge indicates that the value in input i may contribute directly or transitively to the computation of the value in output o. while we use a similar idea in this work the handling of modern object oriented languages like java imposes many new research challenges that none of the existing techniques have yet addressed.
for example the notions of the input and output of a java method can be much broader than those discussed in because the method can access not only its parameters i.e.
passed into the method from its caller but also potentially all objects reachable from them.
in this paper for a given method the inputs are considered as a set of heap or stack locations that existed before the call and that can be read in the call and the outputs are considered as a set of locations that can be written in the call and that will still exist after the call .
class intlist int arr int size intlist int tmp new int this.arr tmp this.size void add int i int t this.size int a this.arr a i t t this.size t int get int i int a this.arr int ret a return ret void main intlist k new intlist intlist l new intlist int num k.add num int j if j num l.add j j goto ... int s int r1 k.get s int r2 l.get s a code example b full dynamic dependence graph32110191 6272341add1 add2get1 get2add i add i arrsizesize arr ... ...before line after line c concrete and abstract dependen ce summaries for addo21.size o21.arr p0abstract dependence summary p0.size p0.size p0.size p0.size p0.arr.index p0.arr p0.arr p1 p0.arr field points to edge transitive data dep.
edgeconcrete dependence summary o21 o21.size o21.size o21.size o21.arr io21.arr o21.arr 52o21o21fig.
example program dependence graph and summaries.
example.
to illustrate consider the top part of figure c that shows transitive data dependence relationships between a set of input memory locations before the call at line and a set of output memory locations after the call.
o21denotes the run time intlist object created in line .
each box represents a reference typed field and each circle represents a primitive typed field.
from the example we can see that the value contained in location o21.arr after the call depends transitively on the values in three other heap or stack locations before the call o21.size o21.arr and the parameter i. the five transitive dependence edges shown in the middle part of figure c form the concrete dynamic summary for the method add.
note that each such location in the summary is named using a combination of a parameter root object e.g.
o21 and an access path that specifies how the location is reached from the parameter e.g.
arr .
a data location unreachable from a parameter or a global variable is either inaccessible in the method or does not escape the method and thus will have no impact beyond the scope of the method.
of course for a different execution of the method a different set of transitive dependence edges may be generated.
in this work summary edges computed from different executions in the training phase are combined to serve as the eventual summary for the method.
challenge abstracting concrete summaries.
a concrete dynamic summary contains information specific to the execution of the method where the summary is computed.
for example the use of the concrete object o21in the concrete summary the middle part of figure c prevents us from applying and reusing the summary in the future execution of add.
for the summary of a specific invocation of a given method the concrete information should be replaced by abstract information such that the reproduction of the concrete information may be possible for all invocations of the method in question from the abstract information.
in other words the abstraction of concrete summaries allows application of the summaries for all invocations of the method instead of specificinvocations.
to do this we propose to use symbolic names for parameters.
for example the concrete object o21is replaced by a symbolic name p0 and the concrete stack variable i is replaced by a symbolic name p1.
a corresponding set of abstract summary edges is shown at the bottom of figure c .
challenge accounting for varying method behavior.
an important observation on which our technique is based is that while different executions of a library method may handle different incoming data from different clients their behaviors in these executions often do not differ significantly.
such behavioral consistency can be attributed to the relative simplicity of many library methods and that all behaviors in our case data dependencies may be realized in a small number of executions.
however a method invocation may take objects of different types as parameters.
although these types may have the same supertype their fields can differ significantly or they might result in the execution of entirely different method implementations due to polymorphism and thus abstract summaries generated for one method execution may not be directly applicable in a different execution.
when an abstract summary is generated we additionally record the type information of each parameter with the symbolic name representing the parameter.
before a summary edge is concretized during the dependence analysis we first check whether the recorded type in the edge matches the type of its corresponding actual parameter in the current execution and only apply those summaries that match.
challenge precise handling of array accesses.
precise handling of array accesses can be critically important in the dependence analysis of software.
particularly when an abstract summary involving an array access is applied at a method call we wish to understand precisely which array element is used or defined inside the method execution.
without such information spurious dependence relationships may be generated any data retrieved from an array would depend on any data added into the array.
precise handling of array accessesget get222 add2 r 22compose add2 get21fig.
summary application at call sites in lines .
is challenging because the index used to access the array is often not an output of the method and thus no summary will contain its dependence information.
to solve the problem we create a special symbolic name for each array index.
if the accessed array is an input or output of the method the index used to access the array is considered as a special output and thus the transitive dependence relationships leading to the computation of the index would be included in the summary.
if the index is a constant value i.e.
its computation does not depend on any method input this constant value is recorded in the summary.
in our example index tused in line of figure a is abstracted by a symbolic name p0 arr index which is dependent on the symbolic location p0 size .
when the summary is applied we concretize p0 size to obtain its run time value before a call to add which will be used to understand which array element is accessed during the call.
example.
figure shows the application of the summaries for add andget at their second call sites i.e.
lines and in figure a with a focus on how we recover the transitive dependence relationship between the int value retrieved from theintlist object in line and the one added into the object in line .
symbol prin figure a denotes the symbolic name for the return variable in get.
figure b shows the summary application process all symbolic names are replaced with their actual run time locations.
by composing the concretized summaries for add andget we see that there exists a transitive data dependence relationship between r2andjif the array indices involved in the summaries of add andget are the same.
by tracking dependence for array indices we see that the array index in add is computed from o22 size and the array index in get is computed from s and hence if a certain condition holds between the values of o22 size ands r2will depend on j. for most library classes such as data structures injava.util different methods in the same data structure often use the same algorithm to compute array indices from the input s .
for instance add andget in our example directly use inputs as indices while put andget in the java hashmap use the hashcodes of their input key objects tocompute array indices.
based on this observation we assume this condition is equals if the values of the inputs on which the array indices depend in the two summaries are equal the array elements accessed in the two methods are considered to be the same.
in our example figure c therefore a transitive dependence relationship is added between the statement that defines r2 i.e.
and the statement that defines j i.e.
because the values of both o22 size before line and s before line are .
while equals is sufficient for precise tracking of most methods in standard java libraries this condition can be easily redefined by the user to handle other user defined data structures.
note that one situation that cannot be appropriately handled is that a range of array locations are accessed in the method.
this case of accessing multiple array locations is further discussed in section viii.
iii.
a pproach and concepts this section formally defines concrete and abstract dependence summaries and in this context presents our core technique that computes and uses summaries to improve the efficiency of dynamic data dependence analysis.
concrete summaries.
let us first define the inputs and outputs of a java method.
note that our implementation treats static fields as additional parameters to a java method.
definition heap graph hg .we use c m a0 a1 a n to denote a call site c. ifmis an instance method the receiver object is a0.
for each actual argument ai we define a location graph gi in which each node is a heap location i.e.
a reference typed or primitivetyped field in an object reachable from the root object referenced by ai each edge connects a parent heap location that