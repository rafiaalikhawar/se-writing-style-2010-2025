crosscutting revision control system sagi ifrah david h. lorenz open university of israel dept.
of mathematics and computer science university rd.
p .o.box raanana israel.
sagiy cslab.openu.ac.il lorenz openu.ac.il abstract large and medium scale software projects often require a source code revision control rc system.
unfortunately rc systems do not perform well with obliviousness and quantification found in aspect oriented code.
when classes are oblivious to aspects so is the rc system and the crosscutting effect of aspects is not tracked.
in this work we study this problem in the context of using aspectj a standard aop language with subversion a standard rc system .
we describe scenarios where the crosscutting effect of aspects combined with the concurrent changes that rc supports can lead to inconsistent states of the code.
the work contributes a mechanism that checks in with the source code versions of crosscutting metadata for tracking the effect of aspects.
another contribution of this work is the implementation of a supporting eclipse plug in named xrc that extends the jdt ajdt and svn plug ins for eclipse to provide crosscutting revision control xrc for aspect oriented programming.
keywords revision control version control aspects i. i ntroduction from the beginning of aspect oriented software development aosd the question ow do i know what aspect affects my code?
has been asked and partially resolved by enhancements made to the integrated development environment ide for supporting aspect oriented programming aop .
the aspectj development toolkit ajdt an eclipse plug in for aspectj for example visualizes the crosscutting effect of aspects by displaying markers on a vertical ruler in the editor to denote advice inter type declarations itds annotations and soften exceptions.
when rolling the mouse cursor over the markers a hint message with addition information is displayed.
however there is no support in ajdt for tracking these markers in previous versions of the software.
consequently it is difficult to discover which aspects advised previous versions of a class.
it is especially difficult to compare two versions and review any changes to the crosscutting effect.
viewing a previous version history and comparing versions diff are two of several classic operations provided by a revision control rc system.
use of rc systems is common in organizations that develop code and is often integrated with the ide.
indeed the eclipse ide provides a gui for common rc services.
in eclipse diffdisplays the text of the compared revisions of the file highlighting thedifferences in a compare view.
however the compare view displays neither ajdt markers advice itds annotations soften exceptions nor jdt markers breakpoints tasks warnings etc.
.
needless to say there is no support for comparing markers.
a. aop and revision control systems many rc systems follow the tradition of source code control system sccs in managing revisions of programs as text documents organized in files e.g.
rcs .
they store and display textual differences between successive revisions.
they also offer facilities for merging parallel revisions by reconciling the differences.
however aop by nature defies these principles.
first concerns crosscut the file structure.
second obliviousness leaves certain crosscutting effects undetected in the textual display of files and changes.
third quantification may escape version dependency management.
for example let cbe a versioned class and let abe a versioned aspect that advises c. let c primeanda primebe newer versions of canda respectively.
assume that revision v1 comprises the set of files c a and that revision v2 comprises the set of files c a prime .
assume that revision v prime comprises the set of files c prime a modified in parallel to revision v2 and that revision v3comprises the files c prime a prime by merging revisions of v2andv prime .
let v1 v3 denote the delta between the two revisions v1andv3.
in rc systems inspecting v1 v3 typically amounts to displaying diff c c prime and diff a a prime where diff is an external tool for comparing two text files.
however thanks to obliviousness a primemay have an effect on the woven behavior of c primethat is not visible in diff c c prime .
similarly thanks to quantification a primemay have an effect onc primethat is not visible in diff a a prime .
let eff a c denote the invisible crosscutting effect that ahas on c. since neither eff a c noreff a prime c prime are observable in code the difference between eff a c andeff a prime c prime is too not observable.
in addition eff a prime c andeff a c prime may be of interest but are also invisible.
b. contribution this work introduces xrc which stands for crosscutting revision control .
xrc is an approach backed up by a978 .
c ieee icse zurich switzerland prototyped tool for better supporting revision control of aop programs.
intuitively the core idea of xrc is to persist to the rc system the otherwise transient eff a c ascrosscutting metadata xmd associated with c. this combined with new rc and ide capabilities for displaying and comparing the xmd provides crosscutting revision control for aop programs that is currently lacking.
the general problem of applying rc to xmd may be broken down into four sub problems metadata persistence metadata comparison versioned metadata display viewing a previous version and displaying the differences and integration with the software development process.
as a proof of concept we prototyped an xrc eclipse plug in for aspectj and subversion svn .
specifically the plug in provides persistent representation of metadata.
the xrc plugin maintains the xmd and checks it in with the source code files.
diff engine for metadata comparison.
since the crosscutting effect is often not visible in the code the plug in introduces a semantic diffthat is xmd aware.
visual means for versioned metadata display.
markers and hint messages are currently ignored by the rc system and by the ide compare tool.
the xmd plugin introduces new visual markers and new means to visually display a comparison and present the xmd differences with the compared files.
rc ide integration .
a traditional rc system treats the file as the unit of revision.
however xmd by essence crosscuts the file structure.
for example the xmd may change while the code in the file remains unchanged.
this requires adapting the rc ide processes for save build check in display version compare versions etc.
the inherent difficulty in bridging rc and ide services for aop stems from their respective biases.
traditional ide support for aop is associated with the build process compilation in order to provide the necessary weaving information while rc systems are associated with the storing and retrieving of unwoven files and are ignorant of any weaving information.
we provide a solution for aop related xmd.
however the solution can be generalized to handle metadata that represents other kinds of markers.
support for save compare and display of metadata might be useful for errors and warnings as well or any other metadata that is associated with the source code.
ii.
p roblem illustrated to illustrate the problem and its consequences consider a bank account application comprising an account class with several methods among them a method named withdraw .
a developer might misspell the name of the method as withdr ow o instead of a .
figure diff between and .
no markers are shown despite the existence of an aspect that advises withdrow in .
a. being unaware of an aspect scenario ii a suppose that another developer notices the typo and in the next revision account prime corrects the spelling everywhere except for an occurrence in the code of an aspect named blacklistadvice a reasonable oversight when using the rename refactoring tool in eclipse.
this oversight will often go unnoticed.
on comparing the class source code to its previous versions diff account account prime the only visual difference is the spelling correction.
figure depicts the compare view comparing account withaccount prime.
there is no indication that the crosscutting effect has changed.
actually there is no visible reason to expect a different behavior when executing the method.
hopefully if we were to use junit or the like a test might now fail and yield an error otherwise this bug would be very hard to discover .
in figure 2a account is shown with the typo ajdt markers indicate the aspect s crosscutting effect.
junit runs successfully indicated by a green bar.
a limited user was identified and the account has .
in figure 2b account is shown after correcting the typo there is no indication of the aspect s effect.
seemingly everything is fine.
note that also the project view shows no warnings or errors since it is perfectly legal for an aspect not to advise any method.
junit fails indicated by a red bar.
a withdraw that should have been rejected was committed successfully.
a with the typo withdr ow in the method name.
b after correcting the typo in the method name.
figure account code displayed in eclipse with the ajdt plug in.
public class limitedusertester test public void withdraw string user black mamba account account new account user blacklist.getinstance .add user account.withdraw expect to display error and avoid the withdraw.
system.out.println balance of account.getowner is account.getbalance asserttrue account.getbalance listing limitedusertester class after the fix.
however inspecting the test code listing provides no indication as to why the test has failed or for that matter as to why the test passed in the first place.
we only see that a user was added to the black list and somehow withdraw should have been blocked with an error.
there is nothing to assist the developer in finding and fixing the bug.
there is no indication in the ide of any aspect advising the code.
should we discover the aspect that ceased to advise only then the mysterious bug might be revealed.b.
fixing only the aspect scenario ii b alternatively suppose that the typo was fixed in theblacklistadvice aspect but not in the advised classes and that the aspect was checked in.
consequently blacklistadvice ceases to advise account resulting in an error that similarly to the previous scenario is not observed when inspecting the class account or its revisions.
a similar scenario could occur in concurrent development.
assume two developers sagi and dave participate in a project.
sagi works on a logic domain that is not a crosscutting concern while dave is responsible for the security domain which is a crosscutting concern.
dave deletes an aspect or changes a pointcut that causes some target in the logic domain to stop being advised.
dave checks in his code.
sagi might then find out that his code is broken.
it could be difficult for him to discover the reason for the problem since he does not have a way to identify aspects that advised the previous version but stopped advising the current version of his class.
c. consequences rc systems play an important role in supporting a healthy software development process.
loss of rc support has 1incidentally this scenario was the motivation for this research.323negative consequences on the entire software development processes.
loss of code review code inspection or code review refers to the ability to examine the source code in order to inspect correctness or to investigate failure.
however scenario ii a illustrates that viewing the previous version of account a version that worked does not reveal the complete behavior of withdraw .
loss of change control before code is checked in it is considered good practice to have the code reviewed by another programmer review before merge policy .
this practice keeps the rc system safe with relatively stable code since all checked in changes have been reviewed.
however altering the behavior of a class through an aspect occurs without change control on the affected class.
when an aspect is checked in the rc system does not ask for approval nor does the rc system require to check in the affected classes.
these classes thus escape code review and bypass change control.
in scenario ii a account was developed prior to blacklistadvice .
when blacklistadvice was added and checked in loss of change control occurred from the account class point of view.
in scenario ii b after correcting the blacklistadvice aspect there was no need to check in the account class and therefore loss of change control occurred again.
loss of code evolution tracking loss of change control might lead also to loss in evolution tracking.
a change to an aspect that advises a class does not require to check in that class.
if the class is not checked in it has no version for that change which makes evolution especially difficult to track.
in scenario ii b after the aspect blacklistadvice ceased to advise account it was checked in but account was not.
the changes to the woven behavior ofaccount is thus an evolution that went unnoticed.
note that figure does not expose the change in the behavior ofaccount .
even when the aspects that advise the versioned classes are known the order of the changes might be obscure.
for aop code the evolution of a class is not necessarily sequential.
without aspects every change to the class is checked in through consecutive versions.
it is clear that the change did not affect previous versions.
with aspects the versions of the classes and aspects are independent and they evolve in parallel.
even with timestamps and version numbers that expose the check in order still one cannot determine the actual history.
for example assume that an aspect aadvises a class c and both a c were checked in then evolved to a prime c prime and checked in again and then evolved to c prime prime a prime prime .
viewing the history if the check in order was a c prime a prime one cannot tell if c primeworked with aor with a prime.
if the checkin order was a prime c prime a prime prime one cannot tell if c primeworked witha primeora prime prime.even when everything about the aspects that advise the versioned classes is known the changes to the class might be spread over many versioned aspects and classes.
tracking the changes without tool support is a difficult and tedious task that requires navigating through multiple files back and forth.
the eclipse compare view for example will no longer display all the changes in a single view.
loss of reversion to a stable revision rc systems help to locate and revert to a previous stable version.
however due to loss of code evolution tracking it becomes more difficult to find a stable point in the history to revert to.
loss of team development support rc systems enable several developers to check out and modify the same class and then merge and resolve conflicts on checkin.
however when different developers work on different aspects that advise the same class the rc system is unaware of the potential conflicts.
the aspects will be checked in with no errors or warnings from the rc system since they are in different files.
conflicting changes will be discovered during build in case of a failure or during deep code review or at runtime.
iii.
s olution and implementation the main requirement for crosscutting revision control xrc is adding revision control support for the crosscutting metadata xmd .
the root of the problem is that the rc system is unaware of the xmd.
an instance of the problem is that the eclipse ide with the ajdt and svn plug ins does not manage store or display the xmd.
to provide revision control for xmd there is a need to represent persist compare and display xmd.
the required components for the solution are an abstract data type adt for representing xmd and the ability to associate and store the xmd with a source code file.
a diffengine that enables comparing the xmd of two files or two versions of the same file .
visual enhancements that enable displaying markers e.g.
markers that the java editor displays for advice when comparing java source files and when viewing a previous version.
rc ide integration that together with the other components provides a mechanism for saving comparing and displaying xmd.
we implemented an xrc plug in for eclipse that demonstrates the feasibility of the approach.
the xrc plug in extends jdt and ajdt and uses the svn plug ins for eclipse to provide the xrc solution.
a. crosscutting metadata xmd in section i we denoted by eff a c the crosscutting effect of aonc.
since cmight be advised by multiple324aspects its xmd sums to xmd c uniondisplay aeff a c where aranges over all aspects in the project.
similarly xmd a uniondisplay ceff a c where cranges over all classes in the project.
it should be noted that xmd c andxmd a include concrete information such as the line numbers of specific pieces of advice and effected program elements.
for conciseness and for symmetry considerations we focus in this paper mainly onxmd c .
hereafter we call the metadata that we want to preserve xmd information or simply xmd .
ajdt metadata the ajdt plug in displays xmd information visually using markers and hint messages in the eclipse editor.
internally ajdt represents the xmd with a map adt map int list irelationship a key in this map represents a line number in the source code.
a value in this map is a list of irelationship objects where irelationship is an interface defined in ajdt.
an implementation of irelationship contains the relevant data of a single piece of advice source target list name and kind of the advice.
this map is the xmd in ajdt.
xrc metadata the xmd that xrc writes to and reads from the rc system is essentially the ajdt xmd enriched with data that xrc requires the version of the advising aspect a flag in case the advising aspect was modified locally and differs from its version in the rc system repository and the details of the parent in a declare parents advice.
b. diff engine the diff engine takes the xmd of two class versions compares them and returns a data structure with the differences.
comparing only the markers is obviously not good enough because the same icon might represent different kinds of advice or advice from different aspects.
a simple straightforward comparison would be to compare the pieces of advice per line and mark the differences.
however this solution gives false positive results.
for example adding a single empty line at a beginning of a class checking it in and comparing it with its previous version will flag all the advice as being different from the previous version.
a developer will have to inspect each one of them just to conclude that the crosscutting effect stayed the same.
comparing the pieces of advice sorted according to their line number may still give false positive results e.g.
for a piece of advice that is moved before another piece of advice.
in order to avoid such false positives a piece of advice that has moved from one line to another with the same content isconsidered unchanged.
this is adapted from ldiff an enhanced line differencing tool that is capable of tracking text that was moved to another line thereby distinguishing line additions and deletions from line modifications.
each line has a list of irelationship each comprising multiple targets that the piece of advice affects.
the xrc diff engine compares xmd c with xmd c prime by first flattening the data then computing the differences and finally inflating the result back into a format that eclipse understands diff xmd c xmd c prime xmd c xmd c prime for this xrc uses two methods that translate the xmd representation required for display to the representation required for comparison and back flatten xmd set irelationship denoted squaresmallsolid takes an xmd object and returns a set irelationship based on the irelationship objects in the xmd.
it breaks each irelationship with multiple targets into single target irelationship objects and removes the line numbers.
inflate xmd set irelationship xmd denoted squaresmallsolid takes an xmd object and a set irelationship .
it constructs and returns a new xmd with the irelationship objects from the input set restored to their original structure and line numbers accumulating targets of the same line to a list in order for eclipse to be able to use the data for displaying the xmd.
c. visual enhancements ajdt markers and rulers ajdt displays the markers in the editor via a ruler to the left of the source as shown in figure 2a.
table i summarizes the ajdt marker types sub types and their icons.
a marker represents a relationship between the class being edited in the editor and the aspects that advise it or vice versa a relationship between the aspect being edited in the editor and the classes it advises .
since one implies the other the table reflects a symmetry in both the marker types and their icons.
ajdt also provides navigation from the aspect to the class and vice versa via a pop up menu by clicking on a marker.
ajdt markers are created and updated on build.
xrc markers and rulers in order to display the differences in a compare view we use rulers similar to the one used in the editor.
for this we extended the eclipse jdt infrastructure to provide support for rulers in a compare view.
a side benefit of this effort is that these rulers can also be used for other tasks that involve displaying markers in the compare view.
on a ruler named advice ruler we display the ajdt markers and use a changed advice highlight marker table ii to emphasize the differences.
this marker changes the background of a marker that has changed and can thus be visually superimposed over existing markers.325table i ajdt markers.
marker type on class marker type on aspect subtype icon on class icon on aspect advised by advisesbefore before advice source before advice after after advice source after advice around around advice source around advice advice advice source advice extension itd source itd aspect declarations declared onimplementation itd source itd declare a member itd source itd declare a method itd source itd warning warning source itd error error source itd annotated by annotates n a itd source itd soften by soften n a itd source itd table ii xrc markers.
marker type on class subtype icon on class changed advice highlight n a changedadvice changed adviceadd add2 remove remove2 modified modified2f on a second ruler named diff ruler inspired by the obsolete ajdt crosscutting comparison view reviewed in section v b1 we mark the nature of the change.
two addition markers add and remove table ii are used to indicate advice addition and removal respectively.
a fourth marker named modified table ii is used to warn the programmer that the advising aspect for the marked advice is not a versioned one but its state was nonetheless modified when the advised class was checked in.
to understand the need for the modified marker consider the following scenario.
let cbe a versioned class.
let a be a versioned aspect that advises c. leta primebe a modified version of athat was not checked in yet but advises cdifferently than a. suppose cis being reviewed and checkedin as c prime with the metadata that represents eff a prime c .
leta prime primebe a modified version of a primethat advises cdifferently thanaora prime.a prime primeis checked in while a primewas never checked in.
this scenario leads to a situation that the metadata of c is allegedly deceptive.
diff c c prime will display the modifiedmarker since a primeis unattainable and it can only hint on a as its predecessor.
the modified marker helps distinguishing between the situation where the version of the aspect is known and trusted and the situation where it is unknown and only the previous version of the aspect that has been checked in is known.
d. rc ide integration xrc is integrated with the ide and modifies its save build check in history and compare processes.
save save is done in three steps execute jdt s save process .
when the developer saves a file the jdt s save process runs and at some point xrc gains control over the save process.
extract and save the markers .
xrc extracts the markers from the file into a serializable object and saves it in the rc system as a property associated with the file.
create and register an ajbuildlistener for the saved resource .
an ajbuildlistener is created and registered for the file in order to handle it on the next build.
build build is done in four steps execute jdt s and ajdt s build processes.
xrc works in post build when the models in jdt and ajdt are already updated.
xrc hooks to the postajbuild hook by using ajbuildlistener.
the listeners are registered when saving a file.
find affected files.
xrc compares the xmd of the file with its predecessor and analyzes which of the affected files differ.
extract and enhance the xmd.
for each affected file xrc uses jdt and ajdt to find the ajdt xmd and326enhances it with the xrc xmd adding parent details target revisions etc.
.
write the xmd.
xrc writes the enhanced xmd as a property of the working copy of the file.
the file is then marked as dirty svn marks the file as dirty automatically when its properties are modified .
check in svn supports version properties per file.
a file might have properties and svn stores them with the file.
from the svn point of view modifications to the properties are similar to modifications to the file and the properties are checked in with the file.
xrc exploits this feature to attach metadata to the file letting this metadata be versioned with the file.
display a previous version when reading a file from the rc system xrc reads the xmd from the properties of the file and displays the markers accordingly.
compare versions when comparing two previous versions execute jdt s compare process .
when the developer compares files with a .java or .aj extension xrc takes control over the compare process.
read the xmd.
xrc reads the xmd for each of the compared versions.
run the diff engine.
the diff engine compares the xmd and returns an object with the differences.
create and display the markers.
xrc creates markers according to the differences.
the markers are assigned to the advice ruler and to the diff ruler on each side of the compare view.
iv.
e valuation the magnitude of the problem in practical settings can be learned from related studies.
ferrari et al.
for example conducted an exploratory analysis of twelve releases of three medium sized real word aspect oriented systems taken from different application domains.
their analysis examined how obliviousness influences the presence of faults in evolving aspect oriented programs.
they found that obliviousness facilitates the emergence of faults under software evolution conditions.
their analysis confirmed with statistical significance that the lack of awareness between base and aspectual modules tends to lead to incorrect implementations .
to regain crosscutting awareness xrc enables integrated rc support for crosscutting metadata.
to assess the ability and efficiency of xrc in tracking down inconsistency problems we performed coverage tests and examined the behavior of xrc on several small examples qualitatively as well as on a larger open source project.
ajhotdraw is an aspect oriented refactoring of jhotdraw a relatively large and well designed open source java framework for technical and structured 2d graphics.
we reviewed the ajhotdraw code with xrc including modifying checking in viewing previous versions and comparing versions of aspects and figure diff between and with xrc.
in comparison with figure markers are displayed and compared.
classes.
we noticed no apparent degradation in performance and we confirmed that the overall user experience is consistent with that of jdt.
a. comparing two advised versions revisiting the scenarios presented in section ii but this time with the eclipse plug in for xrc comparing the account to its previous version immediately reveals that something is different with the advice figure .
rolling the mouse cursor over the marker shows a hint message stating that the blacklistadvice aspect ceased to advise.
b. viewing an advised revision from svn history with the eclipse plug in for xrc markers are displayed also for old versions of account .
in figure the selected title tab confirms that we are looking at of myclass.
the figure displays a variety of markers that represent xmd.
note that without the xrc plug in none of these markers would have been displayed in the left toolbar.
c. regaining rc support for sw development processes regaining code review viewing a previous version ofaccount with xrc now displays every advice that affected that version.
the hint messages help understand the way the code used to work.
regaining change control repeating scenario ii b with xrc once the blacklistadvice aspect is fixed the xmd of the account class is updated during build and flags the class for check in.
a code review of account will probably expose the bug before check in.
however even a327figure viewing an old version of a class retrieves the xmd from svn and displays the ajdt markers in the left toolbar.
check in without fixing the bug will distinguish the previous version that worked from the new version that does not work.
regaining code evolution tracking with xrc the developer has to check in the account class whenever the aspect is modified.
this check in enables tracking code evolution.
the diff in figure shows the change in the behavior of account .
on both sides of the compare view a marker indicates that an aspect ceased to advise.
rolling the mouse cursor over the marker displays a more detailed hint message that explains why.
regaining reversion to stable revision checking in a revision of account also helps to later identify a stable revision to be checked out.
regaining team development support when change control is regained the rc system will detect and prevent overlapping changes to the xmd of a class without first resolving all conflicts.
d. threats to validity while the findings in ferrari et al.
s study indicate a need for a tool like xrc a user study would be needed to assess the effectiveness of the xrc plug in as a productivity tool in practice.
analyzing what percentage of the faults reported in the study could supposedly be avoided had xrc been used is also a topic for future work.
the xrc tool was built and tested to work with a specific rc system and ide namely svn version .
.
eclipseversion .
indigo and ajdt version .
.
.
however the approach should be applicable in general and plug ins can be implemented for other rc systems or for persisting other sorts of metadata.
a limitation of the approach is that the change control provided via xrc depends on the build process to keep the xmd up to date.
recall that ajdt updates its markers on build and xrc is based on ajdt.
consequently build must be done before check in.
eclipse requires to perform team cleanup for a project or a folder in order to synchronize changes with the svn.
this should be done after build and before code reviews in order to gain the xrc change control.
however this limitation can be minimized by setting autobuild in the eclipse configuration which is also the default setting in eclipse .
xrc does not require saving the woven classes.
for each file it only persists the source and its relevant xmd so it is efficient in terms of space requirements.
getting the metadata requires a single read from the rc system.
the recommended development process is thus save build if auto build configuration is not set review all the changes and check in all the files that have been changed.
v. r elated work a. aspectj development toolkit the ajdt eclipse plug in adds to the ide new capabilities for visualizing crosscutting effects.
it computes the crosscutting metadata and introduces markers that hint about eff a c when editing cora.
eclipse uses a vertical ruler in the editor in order to display these markers.
additional hint messages are displayed when rolling the mouse cursor over the markers.
however these markers are not saved with the file and thus not checked in with revisions of cora.
ajdt displays this information only for the current version.
when viewing previous versions of canda the markers which are likely to be different since different versions of aspect could advise different versions of classes are not shown.
ajdt uses advice markers in order to display crosscutting metadata in the current version.
we reuse the ajdt markers in order to display the same kind of metadata also for viewing a previous version and for displaying the diff of two versions.
we added in the compare view a ruler and designated markers for the purpose of displaying the essence of the change.
b. obsolete features of ajdt interestingly early versions of ajdt did include facilities for crosscutting comparison and changes which were eventually removed.
crosscutting comparison obsolete feature a crosscutting comparison capability was part of the ajdt .
.
and .
releases.
crosscutting comparison enabled a developer to take a snapshot of the crosscutting relationships in the project save it to a file and then compare the snapshot with the relationships present in a later version of the project.
the results of the comparison were displayed in a special designated view .
in ajdt .
.
the crosscutting model enhancements and the internal representation of the crosscutting model became redundant and removed in order to improve the performance of the edit save and build operations.
the crosscutting comparison functionality and view relied on the model that was removed and thus abandoned.
in comparison to xrc the ajdt crosscutting comparison obsolete feature had the following disadvantages.
first the crosscutting comparison view lacked consistency with the eclipse compare view and did not integrate the display of differences with the compare view.
second it managed all the relationships of the project in a single file.
specifically it did not allow one to save or examine the differences per class or per aspect.
third it required to save snapshots manually.
fourth it did not support the enhanced crosscutting model of eclipse.
eclipse version .
and higher requires ajdt version .
.
or higher which no longer supports this functionality.
crosscutting changes obsolete feature ajdt .
introduced another relevant feature named crosscutting changes .
with this feature advice markers were highlighted when the crosscutting effect has changed such as when a method is advised for the first time or when there has been a change in the set of places affected by some advice.
the reference point for the comparison could be chosen using a drop down menu on the crosscutting comparison view.
the possible choices were to use the last build of any type the last full build or a crosscutting map file in the project.
this feature has been abandoned as well in favor of the crosscutting model enhancements in ajdt .
.
.
the crosscutting changes feature relied on the crosscutting comparison which is obsolete.
in comparison to xrc it did not support the resolution of versioned classes and aspects from a rc system.
c. specialized differencing tools many semantic differencing tools enhance the simple diff textual comparison tool for the purpose of tracking software evolution.
some analyze the rc repository to better detect high level structural changes e.g.
umldiff infer systematic changes e.g.
lsdiff or even recommend adaptive changes for keeping up with the software evolution e.g.
semdiff .
in contrast xrc adds to the rc system repository new xmd information which is readily available in the ide but not tracked.
this extrainformation may help mining tools and programmers detect more crosscutting inconsistencies and avoid potential bugs.
d. crosscutting configuration management tofra is a tool that addresses the problem of configuration management cm in the context of crosscutting frameworks cfs .
cfs are aspect oriented frameworks that handles a single crosscutting concern.
one or more cfs may be weaved with the application and cfs might be reused across different applications.
tofra s support for version control in cf based development focuses on managing the dependencies among versioned cfs and versioned applications.
in comparison xrc provides actual rc support for developing aop applications integrated with the ide and the rc system.
vi.
c onclusion traditional rc systems predate aop and external diff tools code history views and other elements of the rc system and its integration with the ide were never fully adapted to aop.
since software product development medium or large requires revision control the lack of appropriate support is an obstacle that hinders the use of aop.
this work introduces crosscutting revision control a novel approach and a supporting eclipse xrc plug in that improves the revision control of aop code.
the xrc plugin for eclipse provides the essential means for persisting comparing and displaying crosscutting metadata xmd .
the xmd is maintained and checked in with the code.
the persisted xmd is then used by the eclipse ide to mark with marginal icons the effect of aspects on previous versions of the code and to indicate whether or not that effect has changed.
xrc reintroduces rc to the aspect oriented software development process and identifies the gap that rc systems should bridge in order to improve rc support for evolving aspect oriented programs.
the approach however is not limited to aop.
it may be applied to breakpoints warnings and other markers and metadata.
acknowledgment we thank gennady agranov shai koenig oren mishali boaz rosenan and the anonymous reviewers for their useful comments.
this research was supported in part by the israel science foundation isf under grant no.
.