easing software component repository evolution j r me vouillon cnrs pps umr univ paris diderot sorbonne paris cit france jerome.vouillon pps.univparis diderot.frmehdi dogguy edf s.a. france debian release team debian project mehdi debian.orgroberto di cosmo univ paris diderot sorbonne paris cit pps umr cnrs inria france roberto dicosmo.org abstract modern software systems are built by composing components drawn from large repositories whose size and complexity increase at a fast pace.
maintaining and evolving these software collections is a complex task and a strict quali cation process needs to be enforced.
we studied in depth the debian software repository one of the largest and most complex existing ones and we developed comigrate an extremely e cient tool that is able to identify the largest sets of components that can migrate to the reference repository without violating its quality constraints.
this tool outperforms signi cantly existing tools and provides detailed information that is crucial to understand the reasons why some components cannot migrate.
extensive validation on the debian distribution has been performed.
the core architecture of the tool is quite general and can be easily adapted to other software repositories.
categories and subject descriptors d. .
software program veri cation formal methods d. .
management lifecycle general terms algorithms reliability veri cation keywords component repository software lifecycle open source .
introduction component based software architectures maintained in a distributed fashion and evolving at a very quick pace have been popularised by the wide adoption of free and open this work was partially performed at irill center for free software research and innovation in paris france http permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
software foss .
these components are usually made available via a repository which are storage locations from which they can be retrieved.
a large variety of repositories are available ranging from specialised ones for components written in a given programming language like cpan hackage or pypi application speci c ones like the eclipse plugin collection and more general repositories like maven central or most gnu linux distributions.
all these component repositories share the common concern of organising the process of integrating changes new components are regularly added debian grew by more than packages since the last stable release two years ago outdated versions are being replaced by more recent ones and superseded or abandoned components get dropped.
to maintain the quality of a repository it is necessary to set up a formal process that allows to add update and remove components in a safe place where they will be tested and quali ed before moving them to the o cial repository.
for large repositories this process can only be enacted with the help of automated tools.
existing tools are often unable to cope with all the quality requirements that depending on the needs of the user community of a repository may vary from basic unit testing to extensive bug tracking to sophisticated integration tests striving to ensure that components can be combined with each other a property known as coinstallability .
we have studied in depth the process used to evolve the debian distribution which has been in place for more than a decade managing hundreds of thousands of components called packages for multiple architectures since it is open to public inspection we had access to its formal requirements and we collaborated closely with the debian release team of which the second author is a member on solving the problems faced by repository maintainers due to the limitations of the current tools.
the debian evolution process is organised around three repositories see figure stable which contains the latest o cial release and does not evolve anymore apart for security and critical updates testing a constantly evolving repository to which packages are added under stringent quali cation conditions and that will eventually be released as the new stable and unstable a repository in which additions removals and modi cations are allowed under very liberal conditions.
a stringent set of requirements which are formally de ned must be satis ed by packages coming from unstable to be accepted in testing also known as package migration and the repository maintainers have responsibility for enforcing them with the help of ad hoc tools.
unfortunately maintainers are currently all too often con permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm figure the debian process simpli ed fronted with large sets of packages that are stuck in unstable due to complex package interdependencies with no useful clue to unblock them.
a single package can prevent the migration of hundreds of others and without e ective tools to nd the culprit sometimes migration takes months to complete with a huge amount of manual intervention.
in other occasions the current tool allows into testing packages that disrupt co installability w.r.t.
the previous state of the repository with dire consequences for the users.
indeed in debian many applications are split into distinct package that need to be installed together in order to obtain their full functionality and when this becomes impossible because of an unfortunate modi cation to the repository the user need to le bugs and the maintainers end up spending a signi cant amount of energy to restore their co installability.
this article presents comigrate a powerful tool able to e ciently compute maximal sets of packages that can migrate from unstable totesting it signi cantly advances the state of the art by ensuring that no new co installability issues arise and providing highly valuable explanations for those packages that cannot migrate helping maintainers nd the x it is so fast that it can be used interactively to narrow down repository issues it has been validated on various complex migration problems in collaboration with the debian release team.
the comigrate tool is designed using a general architecture similar to the one of a sat modulo theory solver it uses a very e cient boolean solver to quickly identify a large set of packages candidate for migration starting from general migration criteria that can be encoded as boolean clauses and then uses coinst upgrade to look for coinstallability issues when some issues are found new clauses are added to prevent migration of problematic packages.
the process is iterated until a complete solution is found.
this general architecture can be reused for building similar tools for other component based repositories.
the article is structured as follows in section we brie y recall basic notions from package based distributions and give an overview of the debian integration process with its requirements section presents in details an example of how comigrate is used to manage a real complex migration in section the full architecture of the tool and its algorithm are described extensions to the algorithm are presented in section the di erent ways to use the tools are described in section section contains an evaluation of the tool on the debian integration process related works are discussed in section and section concludes.
.
package migration in debian .
packages and repositories debian software components are called packages and come in two avours binary packages contain the les to be installed on the end user machine and source packages contain all of the necessary les to build these binary packages.
a typical example of the metadata attached to a package is shown in figure where we can see that the logical language used for expressing dependencies and con icts is quite powerful as it allows conjunctions symbol disjunctions symbol and version constraints the symbols and stand for the usual and operators it is now well known that checking whether a component is installable is an np complete problem though real world instances are tractable .
in figure we nd the binary package ocaml base version .
.
which is built from the source package ocaml version .
.
.
each binary package holds a pointer to its source in the source entry which may have the same version in which case only its name is present or not.
there is a di erent namespace for source packages and regarding binary packages for each architecture so there can be both a source package and a collection of binary packages named ocaml one for each architecture.
in a given namespace though there cannot be two packages with the same name and version and with the notable exception of unstable there can only be one version of a package in any given namespace.
1package ocaml base 2source ocaml 3version .
.
4architecture amd64 5provides ocaml base .
.
6depends ocaml base nox libc6 .
libx11 tcl8 .
.
.
tk8 .
.
.
ocaml base nox .
.
10package ocaml 11version .
.
12build depends debhelper pkg config autotools dev binutils dev tcl8 .
dev tk8 .
dev libncurses5 dev libgdbm dev bzip2 dh ocaml .
.
figure inter package relationships of the ocaml source component and ocaml base one of the binary packages generated from it.
the debian distribution is huge we gathered the following statistics on february .
the number of binary packages is per architecture an instance of each of these packages is typically built for the thirteen supported architectures.
all these instances have to be considered individually during the migration process.
source packages binary packages unstable testing stable ahealthy installation is a set of packages in which all dependencies are satis ed and with no con ict.
if all is well the set of packages currently installed on your machine under757debian is a healthy installation.
a package is installable if there exists at least one healthy installation that contains it.
a minimal requirement for a software repository is that all packages are installable.
a set of packages are co installable if there exists at least one healthy installation that contains them all.
it is normal to have con icts between some packages such as for instance between two mail transport agents.
hence one should not expect all subsets of a software repository to be co installable.
however when switching to a new version of a software repository an end user expects to remain able to use all still supported packages.
his installation may need to be modi ed by removing some packages which are no longer supported and by adding new packages but having to remove any still supported package should remain exceptional.
hence any set of packages present in both the old and new version of the software repository and which used to be co installable should normally remain so.
.
package integration and migration the integration process of new packages and new versions of existing packages in the debian distribution involves two repositories testing andunstable and is very complex.
we only provide here a general overview and refer the interested reader to for more details.
when a new version of a source package s is available it is introduced in unstable and then the corresponding binary packages are gradually built and added to unstable as well.
when a binary package is rebuilt it replaces the previous version and when all binary packages are rebuilt the old version of s is dropped.
binary packages that are no longer built from the new version of s are dropped as well.
building binary packages can be a long process because of compilation errors and broken dependencies so it is possible to nd inunstable several versions of the same source package and a mixture of binary packages coming from these di erent versions of the same source.
after a quarantine period which is useful to detect critical bugs and ranges from zero to ten days according to the priority of a package the following actions can be performed replace a package in testing by a package of the same name and a newer version available in unstable remove a package that no longer exists in unstable adda new package from unstable intesting .
following the debian release team we call migration of a package any of these operations1.
.
constraints package migrations must satisfy many di erent quality constraints of di erent nature.
some of these constraints can be checked by looking only locally at each set of packages built from a source package bug reduction a package with new release critical bugs cannot migrate binary with source binary and source packages migrate together no downgrades packages that migrate have strictly greater version number.
1the only anti intuitive case being the second one where the migration leads to suppressing a package from testing .others require a global inspection of the repositories to be assessed installability a new package accepted in testing should be installable no breakage other packages in testing should not become non installable co installability sets of packages that were compatible before migration should remain compatible afterwards.
often because of these quality constraints many packages have to migrate simultaneously about source packages for the lastest migration of haskell packages for instance.
when such a large set of packages is stuck it can be very di cult to manually nd out which ones have issues.
we need tools to nd that out.
.
the current migration tool the tool currently used in debian to help the release team migrate packages from unstable totesting is a program named britney which heavily relies on heuristics it rst tries to migrate individual source packages together with the associated binary packages and then looks for clusters of packages that need to migrate together.
since britney is unable to nd all possible migrations by itself it provides a complex hint mechanism used by the team to help britney nd sets of packages that can migrate together the hint and easy hints or when nothing else goes to force a migration even when this breaks other packages the force hint hint .
the britney tool only checks for installability of individual packages and not for co installability of sets of packages which can have a signi cant impact on the quality of the repository as we will see in section .
it can also be fairly slow and can use up considerable computing resources but the main complaint from the repository managers is that it provides little help when a migration does not go through.
in the next section we provide a real example of how our replacement tool comigrate signi cantly improves over the current state of the art.
.
finding migration issues on june we investigated the ghccompiler and other associated haskell packages the britney tool was unable to migrate the ghcsource package right away and this prevented the migration of hundreds of related binary pacakges a most unsatisfactory situation.
the only information at the disposal of the maintainers was the cryptic output from britney that looked like trying easy from autohinter ghc .
.
... leading ghc haskell hxt haskell devscripts ... start i a ... orig i a ... easy i a ... i386 haskell platform libghc tls dev ... amd64 libghc attoparsec text dev ... ... failed with each line containing hundreds of package names.
apart from the very clear last line that stated that the migration failed there was no hint of what was going wrong.
comigrate c britney2 .
conf migrate ghc 2package ghc cannot migrate package ghc binary package ghc haddock i386 cannot migrate .
package ghc haddock i386 needs binary package libghc happstack state doc would break package libghc happstack state doc libghc happstack state doc testing depends on haddock interface ghc haddock testing package libghc happstack state doc i386 a dependency would not be satisfied would break package libghc6 happstack state doc libghc6 happstack state doc depends on libghc happstack state doc libghc happstack state doc testing figure output of comigrate explaining why package ghccannot migrate.
our comigrate tool is designed to provide valuable help when a migration cannot be performed running it on exactly the same data we got the output given in figure that conveys concisely a wealth of information using abbreviations and conventions that we detail below and contains a precious starting hint to explain the situation.
line says that we are attempting to migrate the source package ghc using the con guration le britney2.conf and line shows that it cannot migrate right away.
the rest of the output explains why line tells us that the source package ghccannot migrate because one of the binary packages built from it ghc haddock cannot migrate at least on architecture i386.
in turn line says that ghc haddock cannot migrate unless the binary package libghc happstack state doc migrates the architecture i386 is omitted as it is the same as forghc haddock .
the fact that we read the excerpt would break package libghc happstack state doc right after in line means that not migrating the two packages simultaneously would make package libghc happstack state doc non installable.
indeed the version of libghc happstack state doc in testing depends on haddock interface and we nd in line inside the curly braces all the packages that can satisfy this dependency.
as the binary package ghc haddock from testing is the only one appearing in the braces we know that this dependency is not satis ed by the version of ghc haddock inunstable and migrating ghc haddock alone would render libghc happstack state doc uninstallable.
but libghc happstack state doc cannot migrate on line and we discover that its migration would break libghc6 happstack state doc and looking at the explanation of this fact on line we see that the dependency libghc happstack state doc is only satis ed by the version present in testing .
this tells us that the migration oflibghc happstack state doc is actually a removal and that removing it from testing breaks an existing package.
hence following these few lines of comigrate output we learned that migrating package ghcis not possible as it would break libghc6 happstack state doc .
so we focus on libghc6 happstack state doc and looking at it we nd out that it is in fact a bit special it contains no le and is just there to ease upgrades when a package is renamed3.
following the history of modi cations to this package we discover that at some point in time all the libghc6 packages were renamed into libghc packages 2this is actually a virtual package a named functionalities that can be provided by more than one package and on which other packages may depend.
3this is known as a transitional dummy package see http wiki.debian.org renaming a packageand a single source package haskell dummy was introduced in the distribution to build all the corresponding dummy packages whose role was just to make sure that if somebody needs a libghc6 package he will actually pull in the corresponding libghc one.
but over time some libghc stopped being supported and were removed from unstable while the corresponding libghc6 package were still generated by haskell dummy .
it thus seems worthwile to try removing this source package for simplicity we focus on thei386 architecture.
comigrate c britney2.conf arches i386 migrate ghc remove haskell dummy successful age days haskell bindings libzip .
source package xmonad .
fix bugs source package haskell cryptocipher .
.
fix bugs age days haskell platform .
.
.
easy this time the tool has been able to nd a way to perform the migration it is enough to x two bugs and to wait for two packages to become old enough.
making the migration go through on all architectures requires some extra e ort because some binary packages were not built successfully everywhere and have to be removed as well.
at the end we get a list of packages to remove and a large britney hint source packages which make it possible to migrate the ghcpackage.
we posted this information on the debian release mailing list4and it helped successfully migrate the whole set of packages involved.
this concrete example shows how comigrate can be used to progressively depending on the complexity of the migration problem understand the actions needed to make packages go through.
.
main applications the comigrate tool we have seen at work in section is highly exible and very fast see section for real world benchmarks .
this allows it to be be used for package migration in several ways.
.
automatic package migration by default comigrate computes the largest set of packages that can migrate without breaking any other package or violating any of the constraints de ned in the debian migration process.
in this modality comigrate can output the list of packages that should be in testing after migration.
this allows it to be used as a drop in replacement for msg00317.html759thebritney tool for automatic package migration.
as an option comigrate can spend extra e ort as explained in section .
to split the result in clusters of packages that can migrate independently of each other .
this makes it easier for humans to understand which package can migrate which packages need to migrate together and allows maintainers to nely control the process if needed.
clustered results can also be fed directly into britney in the form of easy hints easing the adoption of comigrate that can then fruitfully coexist with britney for a period.
sometimes there are good reasons for some packages to become incompatible after a migration thus violating the preservation of co installability.
to this end one can use the break directive followed by a list of one or more binary packages for instance gnuplot x11 gnuplot nox to specify that these packages and just these packages are allowed to become non co installable.
an underscore can be used as a wildcard package libjpeg62 dev was at some point superseded by the incompatible package libjpeg8 dev and one can write break libjpeg62 dev to specify that it is allowed to become in con ict with any other package.
this option provides a means of controlling which set of packages become non co installable which is way more precise than other approaches like the force hint hint of britney .
it can also be useful to temporarily remove a package that prevents the migration of other more important packages.
in fact this is a common way to guide package migration.
to this end one can use the remove directive which corresponds to the homonymous hint of britney .
followed by a source package name it makes the tool behave as if this source package and all its associated binary packages had been removed from unstable comigrate will perform the removal of these packages together with the expected migration if this preserves co installability.
an updated version of the removed packages can be put back by a subsequent run of the tool but in this case for comigrate these will be new packages so it will only guarantee that they are installable.
.
explaining migration failures for the packages that cannot migrate it is very important to provide concise and informative explanations on the reasons that block them.
when used with the excuses directive comigrate takes the set of constraints generated by a migration attempt and outputs an html report presenting them in a user friendly way giving for each package the precise reasons that prevent its migration.
in particular a graph like the ones shown in figure in svg format is generated for each co installability issue detected.
as we have seen in the real world example of section these explanations are precious for nding a way to unblock a migration.
it is important to detect co installability issues as soon as possible so that issues regarding a newly introduced package can be immediately brought to the attention of the maintainers and not only after the quarantine period of ten days.
hence the migration algorithm is run initially while omitting age and bug constraints so as to collect as much constraints due to co installability issues as possible.
.
focusing on a given package as described in section one can use the migrate directive to focus on the migration of a particular source package.
in this modality comigrate drops progressively the less interface propositional solver external verifiersp s p s yes no why figure solver architecture used in comigrate important constraints age number of new bugs out of date packages in unstable that prevents this migration until either the migration succeeds or a hard reason to refuse the migration is reached.
in case of success the hints overriding these constraints and the list of packages that need to migrate together are printed.
otherwise the constraints preventing the migration are printed.
by adding the break and remove directives described above the user can interact with comigrate to get a clear view of all migration issues related to this particular package and nd the best possible course of action in order to allow a given source package to migrate.
in conclusion comigrate is a sophisticated and exible tool that allows a full range of modes of operation from automatic package migration to ne grained interactive analysis of the reasons why a package cannot migrate and progressive relaxation of the migration constraints when needed.
now it s time to look at the internals of comigrate and describe how it works.
.
core architecture of the tool as explained in section .
the constraints imposed on migration can be broadly separated in two classes.
the rst one contains constraints that can be easily expressed using boolean clauses disjunctive boolean formulas .
examples of such clauses are a binary package cannot migrate without its source or this binary package can only migrate if these two other binary packages migrate as well.
the second class contains constraints that cannot be easily encoded using boolean clauses and generally need a global analysis of the repository to be checked ensuring that a package that migrates to testing does not break existing packages requires checking installability for all the packages in the candidate new version of testing ensuring that co installability is preserved by the migrations needs a special and sophisticated algorithm to be checked e ciently which is implemented in a separate tool coinst upgrade described in details in .
this is a quite interesting situation that can be handled by using an architecture inspired by the architecture of smt solvers and summarised in figure .
to nd a migration solution for a particular repository con guration p comigrate uses a simple and fast boolean solver on the constraints that are easily encoded as boolean clauses and comes up with the largest possible candidate solution s satisfying them all then a series of external veri ers are used to check whether other constraints not easily encoded as boolean clauses are satis ed.
if this is not the case these veri ers return an explanation which is used to learn some extra boolean clauses760that approximate soundly the constraints and are added to the original problem on which the boolean solver is called again producing a smaller solution.
the process is iterated until a valid solution is found.
in our case there is always at least one solution performing no migration.
each learnt clause forces at least one additional package not to migrate.
thus the process eventually terminates.
we now detail each component of this core architecture.
.
the boolean solver the encoding of the migration problem uses one boolean variable per package with the intended meaning that if the variable is true the package cannot migrate and if the variable is false it can migrate.
we have thus to deal with hundreds of thousands of variables one per package and the encoding of a typical debian migration problem is quite big clauses in the migration on december so the choice of the boolean solver has to be done carefully.
we observed that the clauses in the encoding that express constraints like if some set of packages cannot migrate then a given package cannot migrate or assertions like this package cannot migrate are actually horn clauses boolean clauses with at most one positive literal .
for instance the encoding of the fact that the binary package ocaml base in example needs to migrate together with its source ocaml is the pair of clauses ocaml ocaml base ocaml ocaml base indeed with the exception of the constraints that come from the external veri ers all clauses in the encoding are horn clauses and for this reason in the current version of the tool we use a horn clause solver that has the following important advantages simplicity we just need to implement resolution if the hypotheses of a rule hold then so does its conclusion no backtracking is needed speed it is well known that satis ability of horn clauses can be checked in linear time optimality if a set of horn clauses is satis able then there exists a minimal solution setting to true the least possible number of variables and which can also be found in linear time this means that the horn solver will propose the largest possible migration compatible with the constraints exibility it is possible to remove some clauses and update the solver state incrementally to nd a new minimal solution easy explanation of why a variable is set we can explain why a package cannot migrate by printing the tree of horn clauses which justify it.
in the rare cases when the external veri ers return a boolean clauses that is not a horn clause we approximate it using a stronger horn clause and when it happens we may not nd the optimal solution for the migration.
as we will see in section .
this happens so rarely that it is not an issue in practice and we have not felt the need to switch to a more sophisticated solver.
in any case we do not envision any di culty in replacing this solver with a full blown pmax sat solver or pseudoboolean solver able to handle all kind of boolean clauses with the addition of an optimisation function to maximise the number of packages that migrate.
the performanceshould remain good the fact that we are able to nd optimal solutions with the horn solver means that little backtracking will be needed.
but its a signi cant engineering e ort to integrate such a solver with our tool in particular to still be able to provide readable explanations.
.
the external verifiers our boolean solver specialised for horn clauses nds a solution that maximises the number of migrating packages given the constraints it knows about.
this solution corresponds to a candidate replacement repository for testing that lies in between testing and unstable and we need to check whether it contains violations of the second class of quality constraints described in subsection .
new coinstallability issues and new packages that are not installable old packages that become non installable are an instance of co installability issues .
the veri cation is performed independently on each of the thirteen architectures supported by debian and all the issues found are then used to learn new clauses which are added to the constraints known to the boolean solver.
we detail below the approach taken for each of the two classes of constraints.
.
.
new co installability issues the coinst upgrades tool is used to nd all co installability issues introduced in the candidate repository with respect to testing .
this tool is extensively described in and we just recall here that it takes as input an old and a new repository and computes what is called a cover ofbroken sets of packages which concisely subsumes all co installability issues introduced in the new repository.
a broken set is a set of packages which are co installable in the old repository but no longer in the new one.
a cover is a collection of broken setssuch that any healthy installation of packages from the old repository that cannot be successfully upgraded contains at least one of these sets of packages.
all healthy installations can be successfully upgraded if and only if there exists a unique empty cover in which case the check is successful.
otherwise each broken set is analysed in order to generate a clause to be added to the set of constraints known to the boolean solver.
this analysis was not performed by coinst upgrades and had to be implemented for comigrate .
as a rst step we extract a small graph of dependencies and con icts called full explanation in that summarises why the set of packages becomes non co installable in the candidate repository.
some examples of these explanations drawn from actual migrations in debian are given in figure they were produced using our tool with the excuses directive see section .
for details .
the captions indicate what the tool learns then how each issue can be xed by the distribution maintainers.
in these graphs colored packages are the elements of the broken set.
dependencies are represented by arrows and con icts by lines connecting two packages.
packages dependencies and con icts are drawn with di erent styles solid lines indicate an object present in both the old and new repositories dashed lines indicate an object present only in the new repository and dotted lines indicate an object present only in the old one.
thus for instance on the rst graph evince depends in unstable on package libevview3 which is only inunstable .
on the second graph mysql common is present in both testing and unstable and the version in unstable con icts with mysql server core .
in both repositories.761libevince3 libevview3 evince a package evince cannot migrate as it depends on a new library which con icts with the old libevince3 library this latter library should be removed.
mysql common mysql server core .
b package mysql common cannot migrate as it con icts with a previous version of mysql server core this old version should be removed.
piwigo smarty c package smarty cannot be removed as package piwigo still depends on it piwigo needs to be removed as well.
libghc hbro dev none d package libghc hbro dev cannot migrate as it has unsatis ed dependencies it probably depends on a package that has been updated and should be recompiled.
libghc darcs dev libghc text dev e package libghc darcs dev intesting resp.
unstable depends on package libghc text dev intesting resp.
unstable hence both packages must migrate together.
figure examples of full explanations.
these small graphs explain why the proposed migration creates a co installability issue but do not indicate which parts of the proposed migration are the root cause of the problem.
for example looking at the second graph we know that the boolean solver has proposed to migrate both mysql common and mysql server core .
and that this creates an issue.
but it would be ine cient to just conclude that they cannot migrate together and learn the clause mysql common mysql server core .
.
indeed one can see that the actual reason for this problem is the migration of mysql common as it con icts with all versions of mysql server core .
and we can learn the much more informative clause mysql common which also happens to be a horn clause while the rst one was not.
to extract a clause from an explanation we proceeds by iteratively relaxing the constraints on the individual packages in the explanation allowing some packages to come from either testing orunstable rather than just from the candidate repository until we have a minimal set of constraints packages forced to come from testing orunstable that still make the co installability issue appear.
then we know that for the co installability issue to disappear at least one of the corresponding packages should not take part in the migration.
this gives us the boolean clause we will pass back to the boolean solver.
if we apply this process on the rst four graphs shown in figure we learn that evince mysql common smarty andlibghc hbro dev should not migrate which all provide unit clauses.
in the last graph where the proposed migration contains the new version of libghc darcs dev and the old version of libghc text dev the clause is already minimal and we learn that either libghc darcs dev should not migrate or libghc text dev should migrate.
since the veri er nds co installability issues caused by the proposed migrations each boolean clause contains at least one positive literal which leads to removing the corresponding package from the migration candidates a variable set to true means that the corresponding package cannot migrate .
if there is a single positive literal the clause is a horn clause and can be passed back to the boolean solver as is.
if there are more than one positive literal examples are given in section .
we approximate the clause by only keeping a single positive literal we know that several packages cannot migrate together and make the decision to keep one back arbitrarily which may lead to suboptimal solutions.in order to reduce the risk of making suboptimal choices we delay any choice resulting in information loss by ignoring non horn clauses as long as the analysis of the architecture produces at least a horn clause.
.
.
new non installable packages a sat solver is used to decide which new packages of the candidate repository are not installable.
from the output of this solver we can produce for each non installable package an explanation of the same shape as the ones produced by coinst upgrades .
then boolean clauses can be computed in exactly the same way as described previously.
.
speeding things up amd64i386controller sources amd64 s390x...s390x figure parallel structure of comigrate .
since the veri ers work independently on di erent architectures performance can be greatly improved by using multiple processes as depicted in figure .
a main process handles source packages and runs the horn clause solver.
there is one secondary process per architecture.
it parses the per architecture binary package description les and sends to the main process the constraints corresponding to these packages after that it behaves as an external veri er for its speci c architecture reading the candidate solution from the main process and sending back clauses to be learnt when issues are found.
.
extensions the algorithm described up to now produces the largest possible migration candidates except possibly in the rare cases where one non horn clause was produced by the external veri ers.
it ensures the absence of co installability issues.
this core algorithm has been extended to accommodate two additional needs described below that lead to interesting variations in the results obtained.
.
clustering migrating packages instead of writing out the whole set of packages that can migrate as a single huge easy hint an e ort is made to cluster packages in sets of packages which can migrate independently of one another in any order.
this approach makes it easier for a human being to understand what a particular migration does smaller sets are also more resilient to last minute changes to the repositories while the migration is computed.
each source package de ne a group of packages the source package and its associated binary packages.
we need a way to nd out which groups need to migrate together to avoid co installability issues.
the idea is to encode in package dependencies all possible con gurations of group migrations and then use an approximation of the coinst upgrade algorithm to nd out which con gurations may result in coinstallability issues.
package dependencies are thus annotated with special literals that indicate whether they hold when a group migrates or when it does not.
for instance the dependency g old h new dsays that the dependency dmust be satis ed when group gdoes not migrate we have the old version of the group and group hdoes we have the new version .
we know from that to have a coinstallability issue one must have either a new con ict or a set of new dependencies which did not exist in testing connected through con icts.
thus to avoid co installability issues it is enough to put together the groups of packages connected by a new con ict as well as those which occur in pairs of new dependencies connected through a con ict.
this gives us a collection of independent migrations that correspond to the original global migration.
we do not claim the result to be minimal grouping together packages as we do is a su cient condition but not a necessary condition to avoid co installability issues although in practice the results are quite satisfactory.
as seen in section comigrate can output its results in hint format so that it can be used as an external migration solver to help out britney .
a so called easy hint lists source packages that britney should attempt to migrate simultaneously together with their associated binary packages5.
.
preserving just installability it is possible to run the comigrate with an option that makes it preserve just package installability instead of coinstallability even though this is not a good idea in general as the users of the repository may face serious problems when co installability is not preserved see section .
due to the architecture of the tool this is just a matter of replacing the external veri er based on coinst upgrades which computes a collection of sets of packages which are no longer co installable with an external veri er that computes a collection of singleton sets of packages which are no longer installable using for instance the now standard edos debcheck tool .
checking installability may seem a simpler task than checking co installability but in fact surprisingly this is not the case and running comigrate in such a mode takes longer than in the default mode.
indeed non co installability is 5a new version of some binary packages are sometimes built on a given architecture without changing their source package their migration can be speci ed by giving a pair formed of the source package name and the architecture.
we ignore this case here for the sake of clarity.a property which is more local than installability.
for instance when a con ict is added between two packages p and q it is su cient to report the broken set fp qgwhen checking co installability on the other hand when looking for new installability issues one may need to check the installability of the possibly huge number of packages that depend directly or not on these two packages to see if any needs both.
so in our case it turns out that asking for a less precise analysis will actually take more time even if not prohibilitively more so.
.
ev aluation and v alidation we have performed a number of experiments and analyses to assess comigrate comparing it with both britney the o cial tool used in debian today and sat britney an experimental tool based on a satis ability solver.
we wanted to check the following points.
first to replace britney our tool should be at least as good at migrating packages our systematic approach should ensure that our tool can deal with complex migration situations where britney s heuristics fail but the fact that we do not use a complete boolean solver could be a concern.
second a key novelty of our tool is that it can be used interactively to troubleshoot migration issues it should be fast enough for this task less than one minute is ne more than ten minutes is way too slow.
third our tool is able to perform more stringent checks than britney or sat britney preserving not just package installability but also co installability we need to verify that this is indeed useful and that the amount of real issues found outweighs the burden of false positives.
to check all this we have taken a snapshot of all the information needed for package migration twice a day for about two months from june 24th to september 8th which gives samples and we have run the three tools on these con gurations.
we have also investigated co installability issues for a longer period between january and june start of the freeze period using the historical information on the state of the debian repositories which is publicly available through the debian snapshot archive .
we could not reproduce accurately migrations over this longer period as some of the required information number of bugs package ages .
.
.
is not archived.
.
tool comparison migrations we have compared the quality of the migrations performed bybritney andcomigrate for the situations mentioned above.
to get a meaningful comparison comigrate has been con gured with the option to only check for installability.
we have not been able to run sat britney on all the architectures simultaneously as its memory usage exceeded the eight gigabytes of ram available on our testing machines.
hence we are not able to provide a meaningful comparison with the output of sat britney.
we found out that comigrate almost always migrates more packages than britney which failed on eleven occasions to nd a suitable set of packages that had to migrate together.
in fact we found a single corner case where comigrate migrates less packages than britney when the 6on june 15th after a freeze period started in june during which most migrations were blocked debian released its new stable repository and migration were allowed again so we nally had new fresh data to analyse.763britney comigrate installability comigrate co installability sat britney running time seconds figure performance comparison of the di erent migration tools on a logarithmic scale.
we use standard box plots the central vertical bar is the median time the rectangle spans from the rst to the third quartiles it contains half the data whiskers denote the largest and smallest data within .
times the interquartile range outliers are represented as isolated dots.
actual data are plotted just below with some vertical jitter.
source used to build a binary package changes britney sometime removes the package from testing without waiting for the new version of the package to migrate from unstable.
in this situation the extra migration makes the package unavailable for some time and comigrate rightfully refuses to allow it.
as a remarkable example the arrival of kde .
in testing required to migrate packages at once our tool was able to nd automatically which packages had to migrate simultaneously while a force hint was used by the debian release team to bypass britney s checks and make the packages go through.
we could also verify in all of the runs that comigrate never made any suboptimal choice due to the limitations of the solver.
.
tool comparison execution time the execution times taken by each tool to compute package migrations on a gib desktop computer using an intel core i7 at .93ghz are shown in figure .
the comigrate tool takes reliably well less than a minute to compute possible package migrations when only checking for installability issues across upgrades and is quite faster in the default mode that also checks for co installability.
the britney tool is usually one order of magnitude slower but can occasionally take much longer to complete we observed a maximum of eight hours over the two month period.
we could run sat britney on only seven of the thirteen architectures.
it is much slower than the other tools even when running on this limited subset of the distribution to the point that we aborted the experiment after just a few runs.
.
relevance of preserving co installability we have compared the output of comigrate while checking for co installability or just installability in the situations mentioned above.
we comment shortly on the result.
a few packages libphonon4 liboss4 salsa asound2 and libgl1 mesa swx11 are incompatible with a huge number of other packages and there is no point in keeping them coinstallable with other packages.
a break directive can be added once and for all to deal with them.
often when switching to a new version of a library the packages of the old version are kept for some time in testing .
if there is any incompatibility between these packages comigrate will report many harmless con icts during the transition.
this can be avoided by using break directives to indicate that the old library is deprecated.
we encountered vesuch transitions.
in some case lots of con icts are introduced.
for instance on september 10th there were packages depending on libopenmpi1.
and packages depending on the con icting package libopenmpi1.
.
it is thus not possible to use any of the packages with any of the other packages.
temporarily introducing incompatibilities this way can sometimes be justi ed in order to ease package migration but britney does not provide any way to control precisely what incompatibilities are introduced and member of the release team are sometimes not even aware of them.
genuine issues can justify new con icts between packages.
we counted ten of them.
for instance package quantum now con icts with python cjson as the latter is a seriously buggy json encoder decoder package parallel con icts with moreutils as they both provide a binary of the same name but with a di erent semantics though in fact it is not clear this is allowed at all in debian packagelxsession now replaces package lxpolkit and therefore con icts with it.
sometimes maintainers can introduce bugs when attempting to x this kind of issue the maintainer ofcolord meant to add a con ict with previous versions ofcolorhug client as the packages contained a common le which is not allowed but he added a con ict with the current version as well.
in fact we encountered three instances of overly strong dependencies or con icts such as the colord one.
in four cases the con icts preventing migration was with a broken or obsolete package that should be removed mingw w64 con icts with libpthreads mingw w64 kde window manager con icts with kwin style dekorator .
finally in six cases a package migrated when it should have waited for another package remaining in unstable .
in particular package bandwidthd meant to be used with a web server is in con ict with the version of apache in testing the freebsd kernel kfreebsd image .
amd64 kfreebsd amd64 architecture is incompatible with the bootloader grub common package scrapbook a firefox extension is incompatible with firefox.
we have also checked all co installability issues introduced each week over two years and a half from january to june which we can nd thanks to our previous tool coinst upgrades and have assessed their impact.
they were most often due to britney only checking for installability rather than being introduced by the release team by forcing the migration of a package we veri ed this by checking that the culprit packages could migrate without help.
we observed that they were real issues in the large majority of764figure impact of not preserving co installability.
cases where britney migrated a package that did not break installability of any other package and yet made an application unusable.
we found about fteen occurrences of a package migrating in isolation when it should have migrated together with a new version of one or more other packages.
in some cases packages remained kept back in unstable for some time with a disruptive impact on debian users.
we could verify the importance of this impact by analysing the statistics of debian package installations automatically collected from the users of the popularity contest package and for which an historical archive is available.
the two graphs in figure show how many users of the package popularity contest have the packages tesseract ocr and openclipart libreoffice installed over a period of time before and after the disruptive migration takes place.
the vertical bar indicates the date of migration of a new version of respectively tesseract ocr eng as well as other similar packages and openclipart libreoffice .
these packages con icts with the versions of their companion packages tesseract ocr and libreoffice common intesting while the new versions of these latter packages remained kept back inunstable .
one can clearly see that this wrong migration caused tesseract ocr andopenclipart libreoffice to be removed on a large fraction of the user base.
as a consequence the application tesseract that is split in a common core and a series of language packs became unusable similarly the open clip art library could not be used in integration with libreoffice .
overall checking for co installability is a signi cant improvement while there is some additional work when new con icts are justi ed it does not harm to double check them and one gains better control on which incompatibilities are introduced allowing to nd a signi cant number of bugs.
.
validation with the debian release team a close connection with the debian release team has been established over the past year and comigrate has been shown to consistently provide valid results and very useful information to track down the reasons why large package sets cannot migrate the case shown in section is an actual example .
it is now being seriously considered for inclusion in the debian release management process.
.
related work ensuring the correct behaviour of components when composed into an assembly is a fundamental concern and has been extensively studied.
one may detect automatically behavioural incompatibilities from the component source code or deploy and upgrade such systems .
intermodule dependencies have been used to predict failures identifying sensitive components or used as a guideline for testing component based systems .
maintaining large collections of interrelated software components and in particular gnu linux distributions poses new challenges that only recently become subject of research.
we know how to identify what other components a package will always need and what pairs of packages are incompatible sophisticated algorithms allow to answer all the questions about package co installability .
we can identify the component upgrades that are more likely to break installability in a repository and e ciently identify the co installability issues introduced in a new version of a repository .
package migration is encoded as a pmaxsat instance in the sat britney tool which only ensures preservation of installability.
.
conclusions we developed comigrate an e cient tool able to compute migration candidates for evolving the debian repositories according to the stringent quality constraints imposed by the policy ensuring that no co installability issues arise and providing concise and precise explanations when some packages cannot migrate.
the unique combination of speed and explanations enable for the rst time to perform interactive tuning of the migration process even when hundreds of interrelated packages are involved.
extensive testing and validation has been performed on real world problem instances in collaboration with the debian release team.
the core architecture of comigrate is particularly suitable for handling migrations.
it should be straightforward to adapt it to any other integration process where the quality requirements are composed of a mixture of simple constraints and complex conditions veri ed by external tools.
source code is at