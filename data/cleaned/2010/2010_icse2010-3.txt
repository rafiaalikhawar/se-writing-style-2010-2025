permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwis e or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
from behaviour preservation to behaviour modification constraint based mutant generation friedrich steimann lehrgebiet programmiersysteme fakult t f r mathematik und informatik fernuniversit t in hagen d hagen steimann acm.org andreas thies lehrgebiet programmiersysteme fakult t f r mathematik und informatik fernuniversit t in hagen d hagen andreas.thies fernuni hagen.de abstract the efficacy of mutation analysis depends heavily on its capability to mutate programs in such a way that they remain executable and exhibit deviating behaviour.
whereas the former requires knowledge about the syntax and st atic semantics of the programming language the latter requires some least understanding of its dynamic semantics i.e.
how expressions are evaluated.
we pre sent an approach that is knowledgeable enough to generate only mutants that are both syntactically and semantically correct and likely exhibit non equivalent behaviour.
our approach builds on our own prior work on constraint based refactoring tools and works by negating behaviour preserv ing constraints.
as a proof of concept we present an enhanced implementation of the access modifier change operator for java programs whose naive implementations create huge numbers of mutants that do not compile or leave behaviour unaltered.
while we cannot guarantee that our generated mutants are non equivalent we can demonstrate a considerable reduction in the number of vain mutant generations leading to substantial temporal savings.
categories and subject descriptors d. .
testing and debugging testing tools.
d. .
language constructs and features constraints.
general terms languages experimentation.
keywords mutation analysis refactoring testing accessibility constraints object oriented programming.
.
introduction mutation analysis often also referred to as mutation testing is the effort of detecting insufficient test coverage by making small changes to a program and observing whether these changes are caught by the present test cases .
for a program mutation to be useful it must respect the syntactic and the semantic rules of the programming language as checked by a compiler while at the same time have the potential to change the observable meaning of the program where obser vable here means observable by means of testing .
the efficiency of mutation analysis crucially depends on the effectiveness of mutation operators in creating mutated programs called mutants that satisfy both conditions.
refactoring is the process of changi ng the design of a program without changing its observable be haviour .
refactoring usually involves a set of preconditions deciding whether an intended refactoring is at all possible and a set of steps referred to as its mechanics prescribing the necessary program changes.
while the required meaning preservation make s refactoring appear the converse of mutation analysis both share the necessity to obey the language s syntactic and semantic rules.
constraint based refactoring utilizes techniques borrowed from constraint programmi ng to formulate and check the preconditions of a refactoring and to ensure that performing it has the desired effect.
it builds on a set of constraint rules that when applied to a given program and its intended refactoring produce a set of constraints whose satisfiability decides the applicability of the refactoring and whose so lution drives its mechanics.
in this paper we show how the constraint rules of constraintbased refactorings can be adapted in such a way that they system atically generate syntactically and semantically correct mutants that likely exhibit changed behaviour.
intuitively this can be achieved by negating precisely those constraints that are to guarantee meaning preservation in the case of refactoring by keep ing all other constraints unchange d generated mutants are guaranteed to compile saving the mutation process numerous vain at tempts.
as a proof of concept we present experimental data ob tained from applying our approach to a set of sample programs and compare its performance to that of using a compiler for filtering out invalid mutants.
results indicate that we are not only up to two orders of magnitude faster than the compiler but also re ject large numbers of mutants that are provably equivalent.
the remainder of this paper is organized as follows.
in section we motivate our work by giving an impression of the problem of generating non equivalent program mutations and by discussing how this has been addressed by related work.
as an example and for much of the rest of this pape r we resort to mutations changing the accessibility of declared program entities a problem identified in as a prominent source of error in object oriented pro gramming however it should become clear that our approach is not restricted to precisely these kinds of mutations.
in section we go into the details of our approach and explain how it works for several different kinds of mutations.
section shows how when we fail to generate mutants directly we can still select from mutants generated by other means those that are potentially useful for mutation analysis.
in section we demonstrate the effective ness of our method by generating mutants for a number of sample programs and comparing the results with those of a naive ap proach.
a brief discussion of possibilities for further development concludes our work.
one more word before we start in this paper we refrain from formally introducing the constraints and constraint rules we used since their sufficient explanation would have forced us to use up much of the available space.
the technically interested reader is referred to for the origins and general working of constraint based refactoring and to for the constraint rules relevant for the work presented here.
.
motivation applying mutation operators to a program without a prior specific program analysis can produce large numbers of useless mutants.
indeed in offut reports that the fraction of useless mutants generated can grow as high as .
a negative record that has been set by his access modifier change amc mutation operator the amc operator usually creates useless mutants.
if the access is strengthened for example public to private the mutated program usually does not compile the mutant tries to use a variable that is out of scope.
if the access is weakened the mutated program is often equivalent the mutant can still use the same variables.
at the same time offut recognizes that using the wrong access modifier is a relevant source of error in our experience in teaching oo software development and consulting with companies that rely on oo software we have observed that access control is one of the most common sources of mistakes among oo programmers.
the semantics of the various access levels are often poorly understood and access for variables and methods is often not considered during design.
this can lead to careless decisions being made during implementation.
it is important to note that poor access definitions do not always cause faults initially but can lead to faulty behav ior when the class is integrated with other classes modi fied or inherited from.
indeed selecting the correct access modifiers in java can become quite tricky.
to see this consider the following simple example in which the invocation of m def in the main method of class b on an instance of a class a is meant to bind to a.m string but really binds to m object class a private void m string s ... void m object o m abc public class b extends a void m string s ... public static void main string args a a new a a.m def a b new b b.m true to change binding accessibility of a.m string must be increased .
however this also changes the dynamic binding of the invocation of m abc on an instance of b in a.m object which now binds to b.m string rather than a.m string as before.
tests revealing such potentially unintended changes of bindings clearly have value and so has mutation analysis showing that cor responding test cases are missing.
.
the problems of generating mutants automatically creating mutants exhibiting a lack of test coverage from access modifier change requires rather intimate knowledge of the java language specification .
for example java syntax mandates that not all access modifiers can be used in all places reducing accessibility of a method declared in an interface to a level below public the default causes a compile error since all interface methods must be publicly accessible changing accessi bility of a top level class to protected causes an error since protected is not allowed for top level classes and so forth.
while such vain applications of the amc operator can be prevented by obeying rules of java syntax others require a deeper semantic analysis.
for instance while increasing accessibility of method m in class a from default no access modifier given to protected or public presents no problem reducing it to private will lead to a compile error since m is no longer accessible from b the example assumes that a and b reside in the same package class a void m ... class b void n new a .m preventing vain applications of this kind is more difficult than in the examples based on syntax only since it requires an analysis of the program with regard to