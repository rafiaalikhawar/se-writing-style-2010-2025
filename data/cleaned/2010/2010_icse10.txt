using symbolic evaluation to understand behavior in configurable software systems elnatan reisner charles song kin keung ma jeffrey s. foster and adam porter computer science department university of maryland college park elnatan csfalcon kkma jfoster aporter cs.umd.edu abstract many modern software systems are designed to be highly con gurable which increases exibility but can make programs hard to test analyze and understand.
we present an initial empirical study of how con guration options affect program behavior.
we conjecture that at certain levels of abstraction con guration spaces are far smaller than the worst case in which every con guration is distinct.
we evaluated our conjecture by studying three con gurable software systems vsftpd ngircd and grep.
we used symbolic evaluation to discover how the settings of run time con guration options a ect line basic block edge and condition coverage for our subjects under a given test suite.
our results strongly suggest that for these subject programs test suites and con guration options when abstracted in terms of the four coverage criteria above con guration spaces are in fact much smaller than combinatorics would suggest and are e ectively the composition of many small self contained groupings of options.
categories and subject descriptors d. .
testing and debugging symbolic execution testing tools general terms measurement keywords empirical software engineering software con gurations software testing and analysis .
introduction many modern software systems include numerous usercon gurable options.
for example network servers typically let users con gure the active port the maximum number of connections what commands are available and so on.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.while this exibility helps make software systems extensible portable and achieve good quality of service it can also generate a huge number of con gurations in the worst case every combination of option settings is a distinct con guration.
this software con guration space explosion presents real challenges to software developers.
it makes testing even more costly as it signi cantly magni es testing obligations it makes static analysis much more di cult as di erent congurations can be con ated together and it generally complicates program understanding tasks.
in this paper we present an initial empirical study exploring how various program behaviors change in relation to system con guration.
we conjecture that at certain levels of abstraction the software con guration space is much smaller than combinatorics might suggest.
for example consider a web server that can be con gured with either sequential or concurrent connections and to enable or disable php scripts.
since these two option settings likely do not a ect each other we probably only need two con gurations say sequential with php and concurrent without php to achieve full block coverage.
if con guration options commonly follow this pattern then in future work new techniques and heuristics might be created to partition conguration spaces in ways that greatly simplify testing analysis and program understanding.
as far as we are aware our work is the rst to formalize and precisely quantify the structure of con guration spaces.
previous understanding of con guration spaces is either anecdotal or based on indirect measurements more discussion in section .
to evaluate our conjecture we studied three con gurable subject systems vsftpd ngircd and grep.
for each system we identi ed a sizable number of run time con guration options to analyze determined their possible settings and created a test suite.
we then ran the test suites using otter a symbolic evaluator we developed.
in our study we marked the selected con guration options assymbolic meaning they represent unknowns that can take on any value.
as otter evaluates a program if it encounters a branch that depends on a symbolic value it conceptually forks execution and explores both possible branches.
in this way we used otter to compute allpossible program paths forallpossible settings of the selected con guration options.
this required tens or hundreds of thousands of runs varying with the application but that is a small fraction of the tens of millions or more runs that would have been needed had we naively enumerated all con gurations.
we next projected the runs onto four types of structural coverage line basic block edge and condition coverage 1and used the results to nd interactions among con guration options.
we de ne an interaction to be a partial setting of con guration options such that speci c coverage is guaranteed to occur under that setting but is not guaranteed by any of its subsets.
for example if aand bare options then a b is an interaction if it guarantees some coverage that setting a 0orb 1individually do not guarantee.
interactions are interesting because they de ne small subsets of the con guration space that provide meaningful additional coverage.
we computed interactions incrementally starting with combinations of zero options i.e.
coverage that occurs in all runs then one option then two and so on.
we continued until the accumulated guaranteed coverage equaled the maximum possible coverage across all runs.
we found that for our subject systems and test suites the largest interactions included between ve and seven options.
this is much smaller than the total number of options in any of the systems.
similarly the total number of interactions is much smaller than what we would expect if we simply multiplied out the possible option combinations naively.
these trends and the others reported below were essentially the same under all four coverage metrics.
next we looked at which speci c interactions are needed to achieve high coverage.
we found that most coverage is supplied by low strength interactions though all three programs had a few one to three enabling options that must be set a certain way to get maximum coverage.
we also used a non optimal greedy algorithm to pack together interactions into full con gurations in order to nd the smallest set of con gurations that would achieve full coverage.
for example interactions a b and c 0can be joined into a single con guration whereas a 0and a 1must go into di erent con gurations.
we found that we needed at most con gurations for vsftpd and for ngircd and for grep to achieve full coverage.
this suggests that for the programs and test suites used the behavior of all con gurations when abstracted onto our coverage criteria can be derived from the composition of a small number of interactions.
finally we created graphs showing all option interactions to better understand what allows us to achieve coverage with so few con gurations.
from this data and the previous analyses we observe that for our programs coverage metrics test suites and con guration spaces many options do not interact with each other that when they do interact they often do so at low strength and that the interactions that exist often cluster into distinct groupings that can be combined into larger con gurations.
in summary our results strongly support our main conjecture that in practical systems when abstracting to speci c program execution behaviors the con guration space behaves less like a monolithic cross product of all option settings and more like the union of smaller con guration spaces.
we believe our work provides a basic but important starting point for understanding software con gurability and for creating techniques and heuristics for scaling many software development tasks across large con guration spaces.
.
configurable software systems for this work a con gurable system is a generic code base and a set of mechanisms for implementing pre planned variations in the code base s structure and behavior.
in practice these variations are wide ranging covering hardware1...else if tunable pasv enable strequal text p sess ftpcmd str epsv 3f handle pasv p sess 5g ...else if tunable write enable tunable anon mkdir write enablejj !psess isanonymous str equal text p sess ftpcmd str mkd jj strequal text p sess ftpcmd str xmkd handle mkd p sess 12g a boolean con guration options vsftpd 13if conf maxjoins channel countforuser client conf maxjoins return irc writestrclient client err toomanychannels msg client id client channame b integer valued con guration options ngircd 18else if conf opercanmode f irc operators can use mode as well if client operbyme origin f modeok true if conf operservermode useservermode true change origin to server 24g 25g ... if use servermode origin client thisserver c nested conditionals ngircd 29nottext binary les binary binary files !
outquiet 31jjbinary les without match binary files memchr bufbeg eol ?
n0 n200 bu im bufbeg 33if not text binary les without match binary files return 36done onmatch not text 37outquiet not text d options being passed through the program grep figure uses of con guration options bolded .
and operating system platforms e.g.
windows vs. linux software versions e.g.
mysql .
vs. mysql .
runtime features e.g.
enable disable debugging output and others.
in this paper we focus on run time con guration options which are usually given values via con guration les or command line parameters.
a con guration is a mapping of con guration options to their settings.
figure illustrates several ways that run time con guration options can be used and explains why understanding their usage requires fairly sophisticated technology.
all of these examples come from our experimental subject programs which are written in c. in this gure con guration options are shown in boldface.
the example in figure a shows a section of vsftpd s command loop which receives a command and then uses a 2long sequence of conditionals to interpret the command and carry out the appropriate action.
the example shows two such conditionals that also depend on con guration options all of which begin with tunable in vsftpd .
in this case the con guration options enable certain commands and the enabling condition can either be simply the current setting of the option as on line or may involve an interaction between multiple options as on lines .
not all options need to be booleans of course.
figure b shows code from ngircd in which conf maxjoins is an integer option that if positive line gives the maximum number of channels a user can join line .
in this example error processing occurs if the user tries to join too many channels.
figure c shows a di erent example in which two con guration options are tested in nested conditionals.
this illustrates that it is insu cient to look at tests of con guration options in isolation we also need to understand how they may interact based on the program s structure.
moreover in this example if both options are enabled then useservermode is set on line and its value is then tested on line .
this shows that the values of con guration options can be indirectly carried through the state of the program.
figure d shows another example of using con guration options indirectly.
here nottextis assigned the result of a complex test involving con guration options and is then used in the conditional lines to change the current setting of two other con guration options lines .
.
symbolic ev aluation to understand how con gurations resemble and di er from each other we have to capture their e ect on a system s runtime behavior.
as we saw above con guration options can be used in complex ways and thus simple approaches such as searching through code for option names will be insu cient.
instead we use symbolic evaluation to capture all executions a program can take under any con guration.
our symbolic evaluator otter 1is essentially a c source code interpreter with one key di erence.
we allow the programmer to designate some values as symbolic meaning they represent unknowns that may take on any value.
otter tracks these values as they ow through the program and conceptually forks execution if a conditional depends on a symbolic value.
thus if it runs to completion otter will simulate all paths through the program that are reachable for any values that the symbolic data can take.
to illustrate how otter works consider the example c source code in figure a .
this program includes input variables a b c d and input.
the rst four are intended to represent run time con guration options and so we initialize them on lines with symbolic values and respectively.
in the implementation the content of a variable v is made symbolic with a special call symbolic v .
the last variable input represents program inputs other than con guration options.
thus we leave it concrete and it must be supplied by the user e.g.
as part of argv not shown .
we have indicated ve lines represented by comments l1 l5 whose coverage we are interested in.
figure b shows the sets of paths explored by otter as execution trees 1dart and exe are two well known symbolic evaluators.
by coincidence dart and exe are the names of two rivers in devon england.
the others are the otter the tamar the taw the teign and the torridge.1inta b c d symbolic 3intinput ... concrete 4intx 5if a f l1 7gelse if b f l2 9x if !input f11 l3 12g 13g 14inty cjjd 15if x input f l4 if y f l5 19g 20g a example program x 0al1bx 1l2input x inputx input a d x 0al1bx 1l2 x inputx inputx input e g f input !inputx inputl4yl5 b c !input left branch true right branch false y c dy c dy c dy c dy c dy c dl3 b full execution trees figure example symbolic evaluation.
for two concrete test cases for this program the tree for input is on the left and the tree for input is on the right.
here nodes correspond to program statements and branches represent places where otter has a choice and hence forks exploring both possible paths.
for example consider the tree with input .
all executions begin by setting xto and then testing the value of a which at this point contains .
since there are no constraints on both branches are possible.
for the sake of simplicity we will assume that and the other symbolic values may only represent and but otter fully models symbolic integers as arbitrary bit quantities.
otter forks its execution at the test of a. first it assumes and reaches l1 left branch .
it then falls through to line the assignment to y and performs the test on line x input .
this test is false since xwas set to earlier hence otter does not fork.
we label this path through the execution tree as a .
note that here we model x input as a single test rather than treating as shortcircuiting.
this is sound when the right hand side of has no side e ects and provides more sensible coverage metrics we discuss this more in section .
.
notice that as we explored path a we made some decisions about the settings of symbolic values speci cally that .
we call this and any other constraints placed on the 3symbolic values a path condition .
here path a covers l1 and so any con guration that sets a corresponding to with arbitrary choices for and will cover l1.
this is what makes symbolic evaluation so powerful with a single predicate we characterized the behavior of many possible concrete choices of symbolic inputs.
otter continues by returning to the last place it forked and trying to explore the other path.
in this case it returns to the conditional on line adds to the path condition and continues exploring the execution tree.
each time otter encounters a conditional it calls a satis ability modulo theory smt solver to determine which branches possibly both of the conditional are possible based on the current path condition.
there are a few other interesting things to notice about these execution trees.
first consider the execution path labeled b .
because we have assumed on this path we set x and hence x input is true allowing us to reach l4 and l5.
this is analogous to the example in figure c in which a con guration option choice resulted in a change to the program state setting x that allowed us to cover some additional code.
also notice that if input there is no way to reach l3 no matter how we set the symbolic values.
hence coverage depends on choices of both symbolic values and concrete inputs.
in total there are four paths that can be explored when input and three paths when input .
however there are 25possible assignments to the input variables.
hence using symbolic evaluation for these test cases enables us to gather full coverage information with only paths rather than the runs required if we had tried all possible combinations of symbolic and concrete inputs.
.
guaranteed coverage otter forms the basis for our empirical study for each subject program we selected a number of con guration options marked them as symbolic and then used otter to execute a set of test cases.
the resulting execution trees contain all possible paths executed under all con guration option settings for those test cases.
without further analysis these paths tell us only a little about our subject programs.
by de nition each path explored for a particular test case is distinct from all the other paths for the same test case.
thus with no abstraction every con guration option combination given by a path is unique.
for example in figure b there are four distinct paths if input representing four distinct settings of conguration options.
thus far then we only know that that is fewer than the paths we might naively expect.
however if we are interested in more abstract properties of the program then paths are no longer unique and the con guration space collapses further.
for example suppose we are only interested in covering l2 in figure .
then we can see that paths a and d are irrelevant and either path b or c is su cient.
for our study we project the symbolic evaluation results onto line block edge and condition coverage.
the principal tool we use to relate con guration options to coverage is guaranteed coverage .
definition .given a test suite and a coverage criterion we say that a predicate pover the initial settings of the con guration options guarantees coverage of program entityxif there exists some test case in the test suite suchthat any con guration satisfying pis guaranteed to cover x. for example from figure b we can see that any con guration satisfying i.e.
a b is guaranteed to cover l2 no matter the choice of and .
we can use otter s output to compute the guaranteed coverage for a predicate p which we will write as cov p .
we rst nd covt p the coverage guaranteed under pby test caset for each test case then cov p s tcovt p .
to compute covt p letpt ibe the path conditions from t s symbolic evaluation and let ct pt i be the covered lines or blocks edges conditions etc.
that occur in that path.
then covt p is consistentt p fpt ijsat pt i p g covt p t q2consistentt p ct q in words rst we compute the set of path conditions pt i such thatpandpt iare consistent.
if this holds for pt i the items inct pt i may be covered if pis true.
since our symbolic evaluator explores all possible program paths the intersection of these sets for all such pt iis the set guaranteed to be covered if pis true.
going back to figure here are some predicates and the coverage they guarantee given the test cases input and input .
we abbreviate as and as .
pconsistent p consistent p cov p input input a e fl1g a b c e f b c d f g b c f fl2 l3 l4g b f fl2 l3 l4 l5g as we show in section we can use guaranteed coverage to discover interactions among options.
definition .aninteraction is a conjunction of option settingss v i xi vi that guarantees coverage that is not guaranteed by any subset of the conjuncts of s. for example cov is a strict superset of cov cov so is an interaction.
informally interactions indicate option combinations that are interesting because they guarantee some new coverage.
definition .thestrength of an interaction is the number of option settings it contains.
for example has strength .
lower strength interactions place fewer requirements on con gurations whereas higher strength interactions require more options to be set in particular ways to achieve their coverage.
.
implementation otter is written in ocaml and it uses cil as a front end to parse c programs and transform them into an easierto use intermediate representation.
the general approach used by otter mimics klee .
a symbolic value in otter represents a sequence of untyped bits e.g.
a bit symbolic integer is treated as a vector with symbolic bits in otter.
this low level representation is important because many c programs perform bit manipulations that must be modeled accurately.
when a symbolic expression has to be evaluated otter invokes stp an smt solver optimized for bit vectors and arrays.
4otter supports all the features of c we found necessary for our subject programs including pointer arithmetic arrays function pointers variadic functions and type casts.
loops which can cause symbolic evaluation to get stuck as it tries to unroll the loop an unbounded or extremely large number of times were not a major obstacle in our study con guration options almost never in uenced loop bounds see section so almost all loops were executed in the usual way with the concrete test cases determining the number of loop iterations.
otter currently does not handle dereferencing symbolic pointer values oating point arithmetic or inline assembly.
in all cases these features either do not appear in our subject programs or do not a ect the results of our study.
otter also does not support multiple processes which do occur in vsftpd and ngircd.
for vsftpd in which fork spawns a subprocess that handles client commands we interpret fork as the starting point of that subprocess and ignore the parent process since it would simply cycle around a loop.
for ngircd where the child process parses an ip address and passes the result to the parent we treat fork as a branching point we run both subprocesses but we ignore the child process s output instead supplying the input expected by the parent process as part of the test case.
all of our subject programs interact with the operating system in some way.
thus we developed mock libraries that simulate a le system network and other needed os components.
our libraries also allow test cases to control the contents of les data sent over the network and so on.
our mock library functions are written in c and are executed by otter just like any other program.
for example we simulate a le with a character array that also tracks the current position at which the le is to be read or written.
as otter executes it records the program paths explored so that we can later compute line block edge and condition coverage.
the precise de nitions of these metrics demand some elaboration because otter runs on cil s representation of the input program which is simpli ed to use only a subset of the full c language.
to compute line coverage we record which cil statements otter executes and project that back to the original source lines using a mapping maintained by cil.
for block and edge coverage we group cil statements into basic blocks which are sequences of statements that start at a function entry or a join point do not contain any join point after the rst statement end in a function call return goto or conditional or fall through to a join point.
normally cil expands short circuiting logical operators and into sequences of branches.
however for line block and edge coverage we disable that expansion as long as the right operand has no side e ect so that both operands are computed in the same basic block.
then to compute block coverage we record which basic blocks are executed and to compute edge coverage we compute which controlow edges between basic blocks are traversed.
lastly for condition coverage we enable expansion of and so that each part of a compound condition is always in its own basic block.
we then compute how many conditions that is how many branches are taken in the expanded program.
.
subject programs the subject programs for our study are vsftpd a widelyvsftpd ngircd grep version .
.
.
.
.
.
lines sloccount lines executable basic blocks edges conditions test cases symbolic conf.
opts.
boolean integer concrete conf.
opts.
full con g test space figure subject program statistics.
used secure ftp daemon ngircd the next generation irc daemon and gnu grep a popular text search utility.
all of our subject programs are written in c. each has multiple con guration options that can be set either in system con guration les or through command line parameters.
figure gives descriptive statistics for each subject program.
the top two rows list the program version numbers and lines of code as computed by sloccount .
the next group of rows lists the number of executable lines basic blocks edges and conditions these four metrics are what we measure code coverage against and they are based on the cil representation of the program as discussed in section .
.
to get more accurate measurements we removed some unreachable code before passing the sources to cil.
we commented out unreachable functions in grep and we eliminated les in vsftpd that are reachable only in two process mode which we disabled because otter does not support multiprocess symbolic evaluation.
one thing to note is that there are more basic blocks than executable lines of code in all programs.
this occurs because in many cases single lines form multiple blocks.
for example a line that contains a forloop will have at least two blocks for the initializer and the guard and lines with multiple function calls are broken into separate blocks according to our de nition.
the next row in figure lists the number of test cases.
in creating these test cases we attempted both to cover the major functionality of the system and to maximize overall line coverage.
we stopped creating new tests when we reached a point of diminishing returns for our e orts.
for example much of the code left uncovered by our test suites handles system call failures such as malloc returning null modeling these failures would have greatly increased the number of execution paths and hence analysis time without shedding extra light on the con guration spaces of these programs.
other uncovered code would have required signi cantly extending otter e.g.
to handle asynchronous signals which was beyond of the scope of this initial study.
vsftpd does not come with its own test suite so we developed tests to exercise its major functionality such as logging in listing downloading and renaming les asking for system information and handling invalid commands.
ngircd also does not come with its own test suite so we created tests based on the irc functionality de ned in rfcs and .
our tests cover most of the clientserver commands e.g.
client registration channel join part messaging and queries and a few of the server server commands e.g.
connection establishment state exchange with both valid and invalid inputs.
5vsftpd ngircd grep paths line block edge condition average paths line block edge condition coverage line block edge condition examined opts tot line block edge condition figure summary of symbolic evaluation.
grep comes with a test suite consisting of hundreds of tests.
to build our test suite for this study we ran all the test cases in otter to determine their line coverage.
then without sacri cing total line coverage we selected test cases from the original suite for our study.
next we created new test cases to improve overall line coverage.
the nal analysis was done using these test cases.
figure next shows the counts of the con guration options.
we give the total number of analyzed con guration options i.e.
those that we treated as symbolic and also break them down by type boolean or integer .
we also list the number of con guration options we left as concrete.
for vsftpd this count excludes con guration options that were not present in the code after preprocessing.
we decided to leave some options concrete based on two criteria whether the option was likely to expose meaningful behaviors and our desire to limit total analysis e ort.
we focused on boolean and integer options and so we left more complex options e.g.
strings concrete with one exception one of grep s string options is only three valued so we considered it an integer option and set it symbolic.
for many integer options only a few values or classes of values such as x are important in determining program execution so otter only had to consider these values.
a few of the integer options however led to an unmanageable number of paths when made symbolic e.g.
because they were passed to printf or used as a loop bound.
for these options we either constrained them to range over a small number of values chosen to maximize coverage or left them concrete.
even then the sheer number of symbolic options led to lengthy executions so we continued reverting additional options to concrete values until the executions and subsequent analysis were manageable.
this approach allowed us to run otter numerous times on each program to explore di erent scenarios and to experiment with different kinds of analysis techniques.
we used default values for the concrete con guration options except the one used to force single process mode in vsftpd.
finally we show how many executions would be required if we ran every test case under every possible con guration given the number of distinct values each symbolic option could take.
we will contrast these extremely large numbers with the results of symbolic evaluation in the next section.
.
data and analysis we ran our test suites in otter with symbolic con gura tion options as discussed above.
we then performed substantial analysis on the results to explore the con guration space of each subject program.
to do this we used the skoll system developed and housed at umd .
skoll allows users to de ne con gurable qa tasks and run them across large virtual computing grids.
for this work we used around client machines.
the nal results reported in this section required about two weeks of elapsed time.
figure summarizes otter s runs.
the rst two rows show the total number of paths executed by otter summed across all tests.
this is dramatically smaller than the number of executions that would have been necessary had we instead naively run each test case under all possible con guration option combinations .
of the naive count for vsftpd .
for ngircd and for grep.
also recall that these are actually allpossible paths for these test suites under any settings of the symbolic con guration options given otter s simulated environment.
notice that condition coverage which has logical operators expanded into sequences of conditionals as discussed in section .
has many more paths.
this e ect is most pronounced for vsftpd which more than quadruples the number of paths because it contains many logical expressions that test multiple con guration options at once.
for example if xjjyjjz would yield at most two paths before expansion but four paths after.
to aid comparison across our subjects we next show the total number of paths averaged over all test cases.
figure then lists the coverage achieved by these paths i.e.
the maximum coverage achievable for these test suites considering all possible con gurations except options left concrete.
we manually inspected the uncovered lines and found that approximately another of vsftpd and ngircd and of grep comprise code for handling low level errors and another of vsftpd in addition to the three les we removed is unreachable in single process mode.
if we adjust for the error handling and unreachable code our test suites line coverage is near or exceeds for all subject programs.
covering the remaining code would in many cases have required adding new mocked libraries adding further symbolic con guration options etc.
overall however based on our analysis of these systems we believe that the test cases are reasonably comprehensive and are su cient to expose much of the con gurable behavior of the subject programs.
the next group of rows shows the number of con guration options that appear in at least one path condition i.e.
were constrained in at least one path and thus distinguish di erent execution paths versus the total number of options set symbolic.
in grep the one unused option was only used when being printed which did not a ect any execution path.
in vsftpd there were six unused options.
one case was similar to grep a con guration option speci ed a port number which is ignored by our mock system.
three other options could have been covered with additional tests the remaining two options cannot be touched without changing the settings of some of the con gurations options we left concrete.
notice that otter constrains two more options with condition coverage than under the other metrics.
this occurs because of the expansion of logical operators into sequences of conditionals.
for example under line block and edge coverage the condition if xjj1 would be treated as a single branch that otter would treat as always true.
but under condition coverage the conditional would be expanded and 140no.
of paths normalized test casesngircd l b e c vsftpd l b e c grep l b e cfigure number of paths per test case l b e line block edge c condition .
otter would see if x rst causing it to branch on x. figure plots the number of paths executed by each test case for each program both with unexpanded logical operators l b e and expanded c .
the x axis is sorted from the fewest to the most paths and the y axis is the percentage of paths relative to the highest number of paths seen in any test case for the expanded c version of the program.
one interesting feature of figure is that for vsftpd and grep the numbers of paths of di erent test cases cluster into a handful of groups indicated by the plateaus in the graph .
this suggests that within a group the test cases branch on the con guration options in essentially the same manner most likely because the programs employ common segments of code to test the con guration options .
in ngircd this clustering also appears but is less pronounced.
finally recall from figure that grep despite still having many fewer paths than con gurations stands out as having a much larger number of paths than the other programs.
we believe this is due to grep s design.
in runs of grep with valid inputs most of grep s code is executed.
therefore many of its con guration options will typically be used resulting in signi cant branching in otter.
in contrast many of vsftpd and ngircd s options are not necessarily used in every run.
this can be seen clearly in figure only a handful of vsftpd and ngircd s tests exercise more than of the paths while only a handful of grep s tests exercise fewer than .
.
interactions by strength next we used our guaranteed coverage analysis to explore which con guration option interactions section .
are actually required to achieve the line block edge and condition coverage reported in figure .
first we computed cov true which we call guaranteed way coverage .
these are coverage elements that are guaranteed to be covered for any choice of options.
here when we refer to t way coverage tis the interaction strength.
then for every possible option setting x v we computed cov x v .
the union of these sets is the guaranteed way coverage and it captures what coverage elements will de nitely be covered by way interactions.
next we computed cov x1 v1 x2 v2 for all possible pairs of option settings which is guaranteed way coverage .
similarly we continue to increase the number of options in the interactions until cov x1 v1 x2 v2 reaches the maximum possible coverage.
for boolean options the possible settings are clearly 0t t t t t t t vsftpd line block edge condition ngircd line block edge condition grep line block edge condition figure number of interactions at each strength.
and .
for integer valued options that we constrained as described in section we used those chosen values for the remaining integer options we solved the path conditions discovered by otter and manually inspected the code to nd appropriate concrete settings.
figure shows the number of interactions at each interaction strength.
the rst thing to notice is that the maximum interaction strength is always seven or less.
this is significantly lower than the number of options in each program.
we also see that the number of interactions is quite small relative to total number of interactions that are theoretically possible.
for example grep has boolean options which by themselves lead to choose possible 2way interactions just with those options alone yet we see at most way interactions for grep.
also notice that there is little variation across di erent coverage criteria they have remarkably similar numbers of interactions.
we investigated further and found the majority of interactions are actually identical across all four criteria.
this is encouraging because it indicates that many interactions are insensitive to the particular coverage criterion.
for ngircd there are signi cantly more interactions at higher strength than for the other subject programs.
this is because almost all of ngircd s integer options can take on many di erent values across our test suite magnifying the number of interactions.
finally we can see that the number of interactions peak aroundt for vsftpd t or for ngircd and t or for grep.
we believe this corresponds to the number of enabling options in these programs discussed more below.
.
guaranteed cov.
by interaction strength figure presents the interaction data in terms of coverage.
thex axis is thet way interaction strength and the y axis is the percentage of the maximum possible coverage.
note that higher level guaranteed coverage always includes the lower level e.g.
if a line is covered no matter what the settings are way then it is certainly covered under particular settings way or higher .
as it turns out the trend lines for all four coverage criteria are essentially the same for a given program and so the plot shows a region enclosing each data set.
in ngircd the only program with some slight variation line coverage corresponds to the upper boundary of the region and edge block and condition coverage to the lower boundary.
this commonality across coverage criteria echoes the same trend we saw in figure .
7coverage normalized interaction strengthngircd vsftpd grepfigure guaranteed coverage versus interaction strength.
we also notice in this gure that the right most portion of each region adds little to the overall coverage.
thus for these programs and test suites high strength interactions are not needed to cover most of the code.
we can also see that vsftpd gains coverage slowly but then spikes with 3way interactions and grep has a similar spike with way interactions.
this suggests the presence of enabling options which must be set a certain way for the program to exhibit large parts of its behavior.
for example for vsftpd in singleprocess mode the enabling options must ensure local logins and ssl support are turned o and anonymous logins are turned on.
for grep either grep or egrep mode must be enabled to reach most of grep s code fgrep mode touches little code.
ngircd also has enabling options that account for the increasing coverage up to interaction strength three but the e ect of these options are less pronounced.
these enabling options also show up in figure .
for example in that gure we can see that most of vsftpd s interactions are strength t or greater i.e.
they generally involve the three enabling options plus additional options.
.
minimal covering configuration sets our results so far show that low strength interactions can cover most of the code.
next we investigated how interactions can be packed together to form complete con gurations which assign values to all con guration options.
for example way interactions a 0and b 0are consistent and can be packed into the same con guration but a 0and a are contradictory and must go in di erent con gurations.
we developed a greedy algorithm that packs options together aiming to nd a minimal set of con gurations that achieves the same coverage as the full set of runs.
we begin with the empty list of con gurations.
at each step of the algorithm we pick the interaction that if we also include the coverage of all subsets of that interaction guarantees the most as yet uncovered lines blocks etc.
then we scan through the list to nd a con guration that is consistent with our pick.
we merge the interaction with the rst such con guration we nd in the list or append the interaction to the list as a new con guration if it is inconsistent with all existing con gurations.
this algorithm will always terminate and cover all lines blocks etc.
though it is not guaranteed to nd the actual minimum set.
figure summarizes the results of our algorithm.
the column labeled shows how many lines blocks edges or conditions are covered by the rst con guration in the list.
thencon g vsftpd line block edge condition ngircd line block edge condition grep line block edge condition figure additional coverage achieved by each conguration in the minimal covering sets.
columnn forn shows the additional coverage achieved by thenth con guration over con gurations n .
notice that minimal covering sets range in size from to which is much smaller than the number of possible con gurations.
this suggests that when we abstract in terms of coverage in fact the con guration space looks more like a union of disjoint interactions that can be e ciently packed together rather than a monolithic cross product.
we can also see that each subject program follows the same general trend with most coverage achieved by just the rst con guration.
the last several con gurations very often add only one additional coverage element.
this last nding hints that not every interaction o ers the same level of coverage we explore this issue in detail in the next section.
finally we also used this algorithm to compute the full e ective con guration space of each program which is a set of con gurations that ensures that every realizable path is executed at least once.
the e ective con guration spaces of vsftpd ngircd and grep contained and con gurations respectively.
while signi cantly larger than for the simpler coverage criteria these numbers are still far smaller than the product of all possible values of con guration options.
.
configuration space analysis figure visualizes the interactions of each subject program to help us understand why the minimal covering sets are so small.
these graphs show interactions based on line coverage.
because the full set of interactions is too large to display easily we show only those interactions needed to guarantee of the maximum possible coverage.2in these graphs a node represents one or more option settings we merged nodes with common neighbors listing all settings the node represents.
shaded nodes are standalone interactions solid edges mark interactions between pairs of nodes and patterned triangles denote interactions among triples of nodes.
the boxes in figure a and b represent interactions among all options within them.
for ngircd the options within this super node also interact collectively with the other option settings as indicated.
the ngircd options are all pre xed with conf and similarly the vsftpd options are pre xed with tunable .
we omitted these pre xes 2diagrams of the full set of interactions can be found in a companion technical report .
8predefchannelsonly 0maxconnectionsip maxconnectionsip 2pongtimeout maxnicklength listenipv4 a ngircd ssl enable 0anonymous enable 1local enable 0anon mkdir write enable 1write enable setproctitle enable 1anon other write enable listen 1run as launching user 0ascii download enable dual log enable dirmessage enable mdtm write b vsftpd match words 1match icase 1match icase 0matcher fgrep matcher grep egrep c grep figure interactions needed for line coverage.
ngircd and vsftpd include some approximations.
from the graph to save space.
to unclutter the presentation and to highlight interesting interaction patterns we made some additional simpli cations.
for ngircd we merged two values for pongtimeout that had similar but not identical neighbor sets and similarly for maxnicklength .
for vsftpd we merged the options in the center node of figure b even though they have slightly di erent neighbors.
the main feature we see in ngircd s graph is the super node in the middle which contains ngircd s enabling options.
we can even see their progression setting listenipv4 is the rst crucial step that lets ngircd accept clients and it forms a way interaction.
next setting pongtimeout high enough avoids early termination of client connections and therefore this option forms a way interaction with listenipv4 .
the last enabling option maxnicklength forms a way interaction with the previous two.
in the full ngircd graph the full set of these enabling options is similarly connected to most of the nodes in the graph.
next considering vsftpd s graph we clearly see that all of the interactions involve the enabling options which appear in the center shaded node.
there are many interactions involving just one additional option setting such as the three options in the node at the right middle position.
these options control the availability of some features e.g.
dirmessage enable enables the display of certain messages.
moreover notice that we can combine all the settings in the nodes of figure b into one con guration.
this helps illustrate why the minimal covering set of con gurations forvsftpd is so small and why the initial con guration is able to cover so much one con guration can enable a range of features writing les logging etc.
all at once.
for vsftpd the full interaction graph is much like the image shown here.
the full graph includes a few additional higher strength interactions that include the enabling options plus some low strength interactions that each guarantee a few additional lines.
finally in grep s graph notice how few con guration options contributed to of the coverage.
these high coverage interactions of grep have very low interaction strength there are no interactions with strength higher than two and four out of the ve nodes have way interactions.
also all values of the matcher option appear in this graph making this the most important option for grep in terms of coverage.
the full con guration space graph of grep contains many more interactions and interestingly the important matcher option only takes part in a few interactions in the full graph.
while each program exhibits somewhat di erent con guration space behavior we can see that when abstracted in terms of line coverage many options either do not interact or interact at low strength and thus we can combine them together into larger con gurations.
this supports our claim that con guration spaces are considerably smaller than combinatorics might suggest.
.
threats to validity like any empirical study our observations and conclusions are limited by potential threats to validity.
for example in this work we used subject programs.
each is widely used but small in comparison to some industrial applications.
in order to keep our analyses tractable we focused on sets of con guration options that we determined to be important.
the size of these sets was substantial but did not include every possible con guration option.
the program behaviors we studied included four structural coverage criteria.
other program behaviors such as data ows or fault detection might lead to di erent results.
our test suites taken together have reasonable but not complete coverage.
individually the test cases tend to be focused on speci c functionality rather than combining multiple activities in a single test case.
in that sense they are more like a typical regression suite than a customer acceptance suite.
we intend to address each of these issues in future work.
.
related work symbolic evaluation.
in the mid s king was one of the rst to propose symbolic evaluation as an aid to program testing .
theorem provers at that time however were fairly simple limiting the approach s practical potential.
recent years have seen remarkable advances in satis ability modulo theory and sat solvers which has enabled symbolic evaluation to scale to more practical problems.
some recent symbolic evaluators include dart exe and klee .
there are important technical differences between these systems e.g.
dart uses concolic execution which mixes concrete and symbolic evaluation and klee uses pure symbolic evaluation.
however at a high level the basic idea is the same the programmer marks values as symbolic and the evaluator explores all possible program paths reachable under arbitrary assignments to those symbolic values.
as mentioned earlier otter is closest in 9implementation terms to klee.
se for configurable systems.
researchers and practitioners have developed several strategies to cope with the problem of testing con gurable systems.
one popular approach is combinatorial testing which given an interaction strengtht computes a covering array a small set of con gurations such that all possible t way combinations of option settings appear in at least one con guration.
the subject program is then tested under each con guration in the covering array which will have very few con gurations compared to the full con guration space of the program.
several studies to date suggest that even low interaction strength or way covering array testing can yield good line coverage while higher strengths may be needed for edge or path coverage or fault detection .
however as far as we are aware all of these studies have taken a black box approach to understanding covering array performance.
thus it is unclear exactly how well and why covering arrays work.
on the one hand a t way covering array contains all possiblet way interactions but not all combinations of options may be needed for a given program or test suite.
on the other hand a t way covering array must contain many combinations of more than toptions making it di cult to tell whether t way interactions or larger ones are responsible for a given covering array s coverage.
our work attempts to better understand what speci c con guration space characteristics control system behavior.
.
conclusions and future work we have presented an initial experiment using symbolic evaluation to study the interactions among con guration options for three software systems.
keeping existing threats to validity in mind we drew several conclusions.
all of these conclusions are speci c to our programs test suites and conguration spaces further work is clearly needed to establish more general trends.
first we found that we could achieve maximum coverage without executing anything near all the possible con gurations.
most coverage was accounted for by lower strength interactions across all of line basic block edge and condition coverage.
second if we packed interactions into con gurations greedily it took only ve to ten con gurations to achieve this maximal coverage.
third we also found that in fact it only took one con guration to get the vast majority of the maximum coverage.
finally by mapping the interactions we gained some insight into why the minimal covering sets are so small.
we observed that many options either did not interact or interacted at low strength and it is often possible to combine di erent interactions together into a single con guration.
taken together our results strongly suggest our main hypothesis that in practical systems con guration spaces are signi cantly smaller than combinatorics suggest and they can be understood as the composition of a small number of interactions.
based on this work we plan to pursue several research directions.
first we will extend our studies to better understand how con gurability a ects software development.
some initial issues we will tackle include increasing the number and types of options and repeating our study on more and larger subject systems.
second we plan to enhance our symbolic evaluator to improve performance which should enable larger scale studies.
one potential approach is touse path pruning heuristics to reduce the search space although we would no longer have complete information.
finally we will explore potential applications of our approach and results such as test prioritization con guration aware regression testing and impact analysis.