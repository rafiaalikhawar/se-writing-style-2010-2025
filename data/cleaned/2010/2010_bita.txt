bita coverage guided automatic testing of actor programs samira tasharofi michael pradely yu lin and ralph johnson department of computer science university of illinois urbana il usa email ftasharo1 yulin2 rjohnson g illinois.edu ydepartment of computer science eth zurich switzerland email michael binaervarianz.de abstract actor programs are concurrent programs where concurrent entities communicate asynchronously by exchanging messages.
testing actor programs is challenging because the order of message receives depends on the non deterministic scheduler and because exploring all schedules does not scale to large programs.
this paper presents bita a scalable automatic approach for testing non deterministic behavior of actor programs.
the key idea is to generate and explore schedules that are likely to reveal concurrency bugs because these schedules increase the schedule coverage.
we present three schedule coverage criteria for actor programs an algorithm to generate feasible schedules that increase coverage and a technique to force a program to comply with a schedule.
applying bita to real world actor programs implemented in scala reveals eight previously unknown concurrency bugs of which six have already been fixed by the developers.
furthermore we show our approach to find bugs 122x faster than random scheduling on average.
i. i ntroduction concurrent programs are becoming increasingly important as multi core and networked computing systems become the norm.
testing concurrent programs is challenging because a single input may exhibit different behavior due to nondeterministic scheduling.
a model of concurrent programming that has been gaining popularity is the actor model .
actor programs consist of computing entities called actors each with its own local state and thread of control that communicate exclusively by exchanging messages.
since actors do not share state the actor model reduces the potential for data races a common bug in the shared memory model.
the widespread use of message passing concurrency in industrial software development and the growing number of libraries and languages that support actor based programming evidence the popularity of the actor model.
despite the lack of shared state testing actor systems is difficult because the order in which actors receive messages theschedule of the execution is non deterministic.
this nondeterminism leads to race conditions at the level of messages.
for example consider the scala code in listing which is a simplified version of a bug we found in the real world actor program gatling .
there are three actor classes writer which stores information to external storage action which sends its results to the writer and terminator which is responsible for proper termination of the program.
a programhasactionnum instances of action and exactly one instance of each writer andterminator .
figure shows the message sequence diagram of an executions of a program with one action.
when the action receives an execute message it sends write to the writer and actiondone to the terminator.
when the terminator receives theactiondone message it decreases the number of current actions.
if this number reaches zero the terminator sends flush to the writer which causes the writer to write all results into external storage to assign null to the results variable and to send a flushed message to the terminator.
this execution is successful because the writer receives write before flush .
however an execution with a different schedule may reorder write andflush .
in this case not only the flushed records is incorrect but the results variable is null and the program throws an exception.
this paper presents bita a scalable automatic approach to test different schedules of an actor program.
the key idea is to leverage schedule coverage to focus the exploration of possible schedules on those schedules that are likely to be of interest for exposing bugs.
schedule coverage describes the extent to which a set of possible schedules has already been explored.
we present three schedule coverage criteria for actor programs.
bita exploits these criteria to tests a program in three steps.
first it runs the program to obtain an arbitrary initial schedule.
second it uses the initial schedule to generate schedules that increase the coverage.
finally it runs the program with each generated schedule.
existing approaches to test actor programs by exhaustively exploring all possible schedules do not scale to realworld programs even with advanced partial order reduction techniques .
another approach is to let developers explicitly specify which schedules to explore during test execution .
in contrast bita explores interesting schedules automatically.
for testing shared memory programs and not actor programs several schedule coverage criteria have been proposed and leveraged for exploring schedules .
to the best of our knowledge no existing work offers a scalable automatic technique for testing actor programs based on schedule coverage criteria.
in this paper we take advantage of schedule coverage criteria to propose a practical technique for automated test11class writer extends actorf 2varresults arraybuffer 3defreceive f called when a message is removed from the mail box case write result string if the message is write result results.append result case flush f if the message is flush writetoexternal results write the results into the external storage results null sender !
flushed send message flushed to the sender 10g 11g 12g 13class action name string terminator terminator writer writer extends actorf defreceive f called when a message is removed from the mail box case execute f if the message is execute writer !
write name send message write to the writer terminator !
actiondone send message actiondone to the terminator 18g 19g 20g 21class terminator actionnum int writer writer extends actorf varcuractions actionnum defreceive f called when a message is removed from the mail box case actiondone f if the message is actiondone curactions if curactions writer !
flush send message flush to the writer 27g 28g 29g listing .
real world example of a message ordering bug.
action n terminator writer terminator writer writer execute actiondoneflush flushedreorder errormain fl ex ad fd write n w fig.
.
sequence diagram of an executions of the code in listing with one action.
rectangles represent receive events.
ing of actor programs.
specifically we make the following contributions schedule coverage criteria for actor systems.
we present three schedule coverage criteria for actor programs that address common bugs patterns and a technique for measuring the coverage achieved by a set of schedules section iii .
coverage guided schedule generation.
we present a coverage guided approach for automatically generating schedules based on an initial schedule of a program section iv .
the schedule generator guarantees that each generated schedule is feasible and that it contributes to higher coverage.
previous work for shared memory programs generates infeasible schedules which reduces the efficiency of the testing process.
instead our approach creates feasible schedules by considering must happen before relations between messages.
generated schedules can be stored and served as a part of test cases for reproducing bugs or for validating the absence of a particular bug.
a technique for forcing a schedule at run time.
wepresent a runtime scheduler that intercepts messages to force a specified schedule while preserving the semantics of the actor model section v .
implementation and evaluation with real world programs.
we implement the bita approach for akka a popular actor library for scala and apply it to five real world programs and three smaller benchmarks section vi .
bita detects eight previously unknown bugs of which six have already been fixed by the developers.
compared to a scheduler that perturbs the execution by introducing random delays bita finds bugs substantially faster 122x on average .
ii.
b ackground actors are concurrently executing entities that do not share state but communicate through exchanging messages.
each actor has a mail box for incoming messages and amessage handler that determines which actions to perform for processing messages.
for example in akka as shown in listing the behavior of each actor is specified by a receive method and each case in the receive method is a message handler.
each step of computation is a receive event in which the actor removes a message from its mail box and processes that message.
upon processing a message the actor may update its local state change its behavior send more messages or create more actors.
the message processing is performed in anatomic step and without any interruption.
this property removes the fine grained non determinism and leaves the concurrency non determinism in the order of messages received by the actors.
in figure each rectangle indicates a receive event.
although the actor model is built upon asynchronous nonblocking communications it is possible to implement synchronous communications by composing multiple steps of asynchronous communications .
in synchronous communication the sender actor blocks until it receives the reply form the receiver.
if a receive event is the reply of a synchronous message sending then we call it synchronous receive otherwise we refer to it as asynchronous receive .
iii.
s chedule coverage criteria for actor systems this section presents three schedule coverage criteria for actor programs section iii a and how to measure the coverage achieved by a set of executions of an actor program section iii b .
sections iv and v use the coverage criteria to automatically generate and execute schedules that explore a subset of all possible schedules that is likely to trigger bugs.
our approach builds upon the notion of a schedule .
the schedule of a concurrent program is the order of all concurrency related events in the program execution.
for actor programs the schedule is given by the sequence of receive events.
formally a schedule sis a finite sequence of receive events s hr1 r2 r niwhere each receive event ris identified by the sender actor sender r the receiver actor 2rec r and the message msg r .
we ignore send events and actor creation events in the schedule because these events are caused by receive events.
that is scheduling receive events indirectly also schedules send and actor creation events.
there is a trade off between the bug detection capability of a criterion and the cost of fulfilling the criterion .
that is while satisfying a criterion that requires exploring a larger number of schedules increases the probability to detect bugs it also increases the cost of the testing process and limits scalability.
to balance this trade off we focus on criteria that consider pairs of asynchronous receive events of a single actor.
the rationale for this decision is threefold.
first considering pairs of receive events is beneficial because the cost of fulfilling these criteria is at most quadratic in the number of concurrent events.
second considering asynchronous receive events is sufficient because every synchronous receive in an actor is caused by an asynchronous receive and it happens just after that asynchronous receive and before any other asynchronous receive in that actor.
therefore each ordering of synchronous receive events can be achieved by at least one ordering of asynchronous receive events.
third considering events of a single actor is beneficial because actors do not share state that is only the receive events of a particular actor change the state of the actor.
a. coverage requirements the coverage requirements presented in the following are inspired by common bug patterns of actor programs and shared memory programs.
each criterion defines ordering goals to be achieved by schedules.
pair of consecutive receives many concurrency bugs are triggered when two accesses to a shared resource occur in a particular order .
inspired by this observation we define the following coverage criterion definition pair of consecutive receives pcr a schedule sthat contains two asynchronous receive events ri andrjachieves the ordering goal ri!pcrrjif and only if rec ri rec rj and riappears before rjinsand there exists no asynchronous receive event rkinsso that rec rk rec ri and that rkappears between riand rjins.
as an example consider a program based on the code in listing with twoactions.
the writer receives two write messages with receive events w1andw2 and one flush message with receive event fl.
the number of pcr ordering goals for the writer actor is and one of the possible sets of schedules that covers them is s fhw1 w2 fli hfl w w1i hw1 fl w 2i hfl w w2ig.
thepcr criterion relates to coverage criteria for shared memory programs that consider pairs of accesses to a shared object and adapts the idea to actor programs.
pair of receives this criterion is a less restrictive version of pcr in which the two receives for an actor do not need to be consecutive.
the variant of pcr is useful to detect concurrency bugs that manifest when changing the order oftwo receives in a single actor even if the actor receives other messages between the two receives.
for example consider an initialization bug where a receive rinitializes a field in an actor.
if a receive r0that dereferences that field appears before r the invalid null value is read and leads to an exception even if other receive events happen between r0andr.
definition pair of receives pr a schedule sthat contains two asynchronous receive events riandrjachieves the ordering goal ri!prrjif and only if rec ri rec rj and riappears before rjins.
while the number of ordering goals in the domain of pr andpcr for a given program are the same pcr may be satisfied by fewer schedules which brings a merit for prover pcr .
for the example in subsubsection iii a1 the number of ordering goals for the writer actor is for both pr and pcr .
however the ordering goals of prcan be covered by the first two schedules hw1 w2 fliandhfl w w1i of the four schedules required for pcr .
pair of behavior change and receive the behavior of an actor may be changed during its lifetime by changing the actor s message handler.
sending a message to an actor that does not have a compatible handler for the message is a common bug pattern in actor programs .
depending on the actor system such unsuccessful receives may lead to different kinds of unexpected program behavior.
for example in erlang and scala actors the message will stay in the mailbox which may lead to mailbox overflow in akka .
an exception is thrown in akka .x the message will be discarded which may confuse the sender because it assumes that the receiver has received the message .
we define the following criterion aimed at detecting this kind of potential error definition pair of behavior change and receive pbr for each receive event r letcb r denotes whether rchanges the actor behavior or not.
a schedule swith two asynchronous receive events riandrjachieves the ordering goalri!pbrrjif and only if rec ri rec rj and cb rj true orcb ri true and there exists no asynchronous receive event rkinssuch thatrkappears between riandrjins rec rk rec i andcb rk true .
the domain of pbr is a subset of the domain of pcr and therefore the cost of satisfying pbr is smaller than pcr .
for the example in subsubsection iii a1 suppose the writer changes its behavior when it receives the flush message.
the set of pbr ordering goals for the writer actor would be achieved by two schedules of hw1 w2 fliandhfl w w2i.
b. measuring coverage the following describes how to quantify the coverage achieved by a set of schedules for the criteria explained in section iii a. in general it is impractical to compute the coverage domain of a criterion all possible ordering goals for 3a given program and input because it requires exploring all possible schedules.
instead we compute the coverage achieved by different sets of schedules and compare them to each other.
definition coverage of a set of schedules for a coverage criterion cr a set sof schedules covers a pair ri rj crof receive events if and only if there exist schedules s1 s22ssuch that s1covers ri!crrjands2covers rj!crri.
that is to increase coverage one must cover both possible orders of a pair ri!crrjandrj!crri.
the rationale for this definition is that we are interested in detecting nondeterministic bugs that may manifest only with one of the two orders.
to measure the coverage achieved by a set of schedules we must match equivalent receive events across multiple executions.
a simple approach would be to match equivalent receive events based on the source code location of message handlers.
unfortunately this approach is very imprecise because a single message handler may execute many times.
for example in a program in which the actor receives thousands of messages of typem all of the receive events would be identical and hence the coverage for this actor would be equal to another program in which the actor receives one message of type m. to address the problem of precisely identifying receive events across executions we compute a hash value for each actor and each message and identify a receive event via its sender hash value receiver hash value and message hash value.
by assuming that the application entry point is a receive event with the hash value of zero we can compute the hash value of all receive events in an execution.
the hash value of an actor ais computed based on a s dynamic type the hash value of the receive event rthat creates a and the number of actors that rhas created before a. similar the hash value of a message mis computed based on m s dynamic type the hash value of the receive event rthat sends m and the number of messages that rhas sent before m. iv.
c overage guided schedule generation bita leverages the coverage criteria from section iii to automatically explore potentially bug revealing schedules.
therefore it combines a technique for automatically generating schedules explained in this section with a run time scheduler that forces a test execution into a specified schedule explained in section v. the basic idea of the schedule generator is to capture the schedule of an arbitrary execution of the program called the initial schedule and to create new schedules by modifying the initial schedule.
the schedule generation approach provides two guarantees.
first each generated schedule increases the coverage compared to the already generated schedules.
second each generated schedule is feasible that is there exists at least one execution of the program that satisfies all the ordering constraints of the schedule.
these guarantees are based on the assumption that the program does not have any other sources of non determinism except for message ordering.
more formally let s hr1 r2 r nibe a schedule ands0 hr0 r0 r0 n0ibe a schedule captured from an execution of the program.
we say s0satisfies siff for all ri2s 9r0 j2s0such that ri r0 j and lets0 sbe the sequence obtained from s0by retaining only the events in s then s0 s s. a schedule does not need to contain all events of an execution to be feasible.
for example in figure the schedule hw fliis a feasible schedule although it contains only two events.
however the schedule hfd adiwhich requires the receive of message flushed to happen before the receive of message actiondone in the terminator is infeasible.
the reason is that the receive of actiondone triggers the flush message which itself triggers the flushed message.
the schedule generator in bita avoids producing such infeasible schedules by analyzing the ordering constrains of all events.
a. overview of schedule generation the schedule generation algorithm is shown in algorithm .
an initial schedule sand the coverage criterion crare the inputs of the algorithm.
the algorithm uses sas the foundation to construct other schedules.
the list of generated schedules are kept in sand the set of ordering goals that have been achieved by sandsare held in a global set o. the algorithm updates owhenever it adds a schedule to s. for each pair of receives riandrjins the algorithm checks line if the events are related to the coverage metric crand whether swapping them yields a feasible schedule that is ri is not required to happen before rj.
these two conditions are explained in detail in section iv b and section iv c. if these conditions hold the algorithm tries to achieve both ordering goals related to riandrj.
it checks whether any of the goals ri!crrj line and rj!crri line has not yet been achieved by the schedules in sand the initial schedule s that is whether the goal is not yet in o. although riappears before rjins the ordering goal ri!crrjmay not be covered by sif the criterion is pcr orpbr and if the events are not consecutive.
for an ordering goal that has not yet been achieved the algorithm calls schedule to generate a new schedule that achieves the goal details in section iv d .
the fourth argument of schedule indicates whether the events should be swapped.
after generating a new schedule the algorithm updates the list of generated schedules sand the covered ordering goals o. b. identifying coverage related events to ensure that each generated schedule increases coverage compared to the already generated schedules algorithm checks whether two events riandrjare related to the coverage criterion cr.
to contribute to the pr andpcr criteria the events must have the same receiver to contribute to the pbr criterion the events must have the same receiver and at least one of them must change the receiver s behavior.
function iscrrelated ri rj cr implements this check as follows ifcr pr orcr pcr it returns true if and only if rec ri rec rj .
4algorithm generateschedules s cr input initial schedule s coverage criterion cr output listsof generated schedules s o cr ordering goals achieved by s for all riinsso that i jsjdo for all rjinsso that i j jsjdo ifiscrrelated ri rj cr and ri rj 2musthb then ifri!crrj62othen s0 crschedule s i j false s s fs0g o o cr ordering goals achieved by s0 ifrj!crri62othen s0 crschedule s i j true s s fs0g o o cr ordering goals achieved by s0 return s ifcr pbr it returns true if and only if rec ri rec rj and if either cb ri orcb rj .
c. must happen before constraints to avoid creating infeasible schedules algorithm checks whether two events can be reordered or whether the first must happen before the second.
for this purpose we compute themusthb relation by considering all ordering constraints that exist in actor programs.
a pair of events ri rj is in musthb s ifrimust happen before rjbased on the ordering constraints inferred from s. the following explains two kinds of ordering constraints in actor programs and how we compute must happen before relations from them.
causality constraints if one receive event causes another then these two events cannot be reordered.
in actor programs such causality constraints occur in two cases.
first a message receive ridirectly causes another message receive rjif executing risends the second message or creates the receiver of the second message.
second a message receive rimay indirectly cause another message receive rjif there is a third message receive rkbetween riandrjthat has the same receiver as riand if rkdirectly causes rj.
the second case implies causality because executing rimay change the receiver s state in a way that causes rkto send the message ofrj.
definition causality constraints the causality constraints musthb causality s of a feasible schedule scontain all pairs ri rj with0 i j jsjfor which one of the following conditions holds msg rj 2sent ri rec rj 2created ri 9k i k j so that rec ri rec rk andmsg rj sent rk 9k i k j so that rec ri rec rk andrec rj created rk for the example in figure musthb causality f ex w ex ad ad fl fl fd w fd g. sender receiver constraints some actor systems including the system we use for the evaluation guarantee that for a given pair of actors messages sent from the first to the second will not be received out of order.
definition sender receiver constraints the senderreceiver constraints musthb sendrec s for a feasible schedulescontain all pairs ri rj withsender ri sender rj andrec ri rec rj .
these constraints only concern the order of messages between a pair of actors.
messages received from different actors can be reordered unless this violates a causality constraint.
for the example in figure musthb sendrec is empty.
however suppose an extension of the example where handling theexecute message triggers two write messages w1and w2.
in this case musthb sendrec f w1 w2 g. computing must happen before constraints based on the constraints imposed by causality and by sender receiver message ordering we compute the set of all must happenbefore constraints as the transitive closure of the union of these constraints.
definition must happen before constraints for a feasible schedule s the must happen before constraints are musthb s musthb causality s musthb sendrec s our approach extracts these ordering constraints from the initial schedule and when writing musthb we mean musthb s where sis the initial schedule.
in addition to causality constraints and sender receiver constraints our implementation also considers ordering constraints imposed by synchronous communication between actors.
details are omitted for lack of space.
d. generating a feasible schedule that increases coverage once the schedule generator has determined that bringing two events riandrjin a particular order is feasible and that so achieves a not yet achieved ordering goal the schedule generator creates a new schedule to achieve this goal lines and in algorithm .
our approach to schedule generation addresses two important challenges.
first to create a schedule with enough information for the runtime scheduler to guarantee that it will succeed in forcing the schedule.
second to create a schedule that achieves not only a single new ordering goal but multiple new ordering goals.
to illustrate these challenges consider the sequence diagram in figure which is an extended version of figure .
for the extended example suppose that if the writer receives awrite message and the results variable is null it sends an error message to the terminator.
moreover the terminator accepts an additional message checkforerror from the application entry point which checks whether the terminator knows about an error.
figure shows an execution where the writer sends an error message and where the check for errors occurs before the terminator receives this error message.
5action n terminator writer terminator writer execute actiondone flush flushedmain ex ad fd writer terminator checkforerror errorch er fl w write n fig.
.
sequence diagram that shows an execution of the code in listing with some extensions in which the terminator accepts a checkforerror message and the writer sends an error message to the terminator if results isnull .
suppose that based on the execution in figure the schedule generator tries to reorder chander so that the checkforerror occurs after the terminator has received the error message.
a na ve approach would be to create a schedule that specifies only the two events her chi.
unfortunately this schedule does not address the two challenges.
first the schedule does not contain enough information for the runtime scheduler to force the schedule.
since there is no constraint on the order of flandw they may happen in the order of hw fli which results in no error message and hence no er event.
previous work shows that this problem can significantly reduce the efficiency of the testing process .
second the schedule achieves only a single additional ordering goal.
instead a longer schedule can achieve multiple additional goals at once.
for example a schedule hw fl ch fdiforpr covers the two ordering goals w!prflandch!prfd.
our schedule generation approach addresses both challenges.
first to create a schedule that contains enough information for the runtime scheduler to enforce it the approach uses the must happen before constraints to include all events necessary to make a pair of events happen.
second to achieve multiple not yet achieved goals in a single schedule the scheduler does not focus on only two events but it searches through all remaining events and reorders them to increase coverage.
algorithms and summarize our approach for generating a schedule.
the approach consists of two parts the first of which is described in algorithm .
as its input the algorithm takes a schedule s two indices iandj and a flag swap that indicates whether to swap the events at iandj.
the algorithm computes a schedule that brings riandrjin the desired order by scheduling all events that must happen before these two events and by appending riandrjin the desired order.
for example consider a program based on listing with two actions and a schedule s hex1 w1 ex w2 ad ad fl fdi.
the other inputs are i j cr pr and swap true that is the goal is to swap w1andw2to achieve an additional pr ordering goal.
at first the algorithm copies all the events before rito the generated schedule s0 line giving s0 ex1.
next it searches through all events between iandjinsand copiesalgorithm schedule s i j swap cr input feasible schedule s indices i jof events to schedule flagswap that indicates whether to swap these events coverage criterion cr output feasible schedule s0in which the event at jcomes before the event at iif and only if swap is true s0 empty list append all rkwith0 k i tos0 fork i 1toj 1do if rk rj 2musthb then append rktos0 ifswap then append rj ritos0 else append ri rjtos0 tail compute tail of s0 return scheduletail s0 tail cr those events that must happen before rjtos0 lines to which gives s0 hex1 ex 2i.
at this point all events required forriandrjto happen have been added to s0.
now the algorithm copies either ri rj line or rj ri line to s0 resulting in s0 hex1 ex w2 w1i.
after creating a scheduling that brings two events in a particular order algorithm invokes algorithm line which considers the remaining events and tries to order them in a way that achieves additional ordering goals.
the tailof events line contains all events that are not yet scheduled excluding events rkwith ri rk 2musthb or rj rk 2musthb .
it is crucial to exclude such events from the tail because these events may not be valid anymore after reordering riandrj.
depending on the coverage criterion the tail also contains the last event of the so far generated schedule s0.
for pcr andpbr riandrjmust be consecutive that is they should not be reordered as part of the tail.
for pr riandrjneed not be consecutive that is the second of the two events can be reordered is part of the tail.
for the example the tail of events to reorder is hw1 ad ad fli.
event w1is part of the tail because we consider the prcriterion which does not require w2andw1 to be consecutive.
event fdis excluded from the tail because w1 fd and w2 fd are in musthb .
algorithm takes a prefix pof scheduled events the tail t and the coverage criterion cras its input.
the basic idea is to append the tail to the generated schedule s0and to try to reorder the events in the tail to increase coverage as much as possible.
the algorithm uses an approach similar to algorithm for finding pairs of events to reorder.
once such a pair of events is found the algorithm reorders them by passing the concatenation p tof the prefix and the tail to algorithm .
since algorithm generates a schedule in which all events before the first event to schedule have the same order as the given schedule calling algorithm for the tail events guarantees that the events in the prefix remain in 6algorithm scheduletail p t cr input schedule prefix p tailt coverage criterion cr output feasible schedule that appends the tail events to p forriintso that i jtjdo forrjintso that i j jtjdo ifiscrrelated ri rj cr and ri rj 2musthb then ifri!crrj62othen s0 schedule p t i jpj j jpj false return s0 else if rj!crri62othen s0 schedule p t i jpj j jpj true return s0 return p the given order.
if the algorithm does not find any tail events to reorder then it omits the tail from the schedule that is the schedule does not specify the order of events in the tail.
algorithms and recursively call each other until the tail does not contain any events to reorder.
since the tail is becoming shorter for each recursive invocation of algorithm this recursion is guaranteed to terminate for every finite initial schedule.
for our example the first call to algorithm selects w1andflfor reordering and calls algorithm to create a schedule where flprecedes w1.
this call results in hex1 ex w2 ad ad fl w 1i.
after this step the tail is empty and algorithm returns the generated schedule.
this schedule achieves two new ordering goals w2!prw1and fl!prw1.
the schedule generation algorithm guarantees that each generated schedule increases the coverage compared to the already covered schedules and that each generated schedule is feasible.
the first property holds because the algorithm only generates a new schedule for an ordering goal if the goal has not been covered yet.
after generating each new schedule it adds all the orderings covered in the schedule to the current covered orderings.
therefore it will never generate a schedule for an ordering that has been already covered.
the second property holds because the schedule generator respects all must happen before relations.
for each event rithat it adds to the schedule it also adds all the events that must happen before ri.
moreover when it reschedules an event riin the schedule it eliminates all the events rjthat require rito happen before them in specific order i.e.
ri rj 2musthb .
v. r un timescheduler this section describes the third part of bita which is the run time scheduler that runs the program with a given schedule.
the inputs of the scheduler are the program the test input and a feasible schedule.
we instrument the actor system to intercept all calls to the actor system for sending receiving actor creation and behavior change.
for each such call the scheduler updates its information about the program execution and forces the execution to follow the schedule.
to force aspecific schedule the scheduler interferes with the send events and delivers messages one by one according to the schedule.
for each receiver actor the scheduler holds the next message until the last sent message whose receive event is the head of the schedule is processed by the actor.
for sending messages the scheduler is called when the message is going to be placed in the mail box.
when the schedule is not empty it compares the corresponding receive of the message with the receive event at the head of the schedule.
if it matches the scheduler allows the message to be placed in the receiver mail box otherwise it keeps the message in a pool of held messages to be delivered later.
note that even if the message is not placed in the mail box the sender actor does not block for sending messages.
upon receiving messages the scheduler compares the receive event with the head of the schedule.
if it matches the scheduler updates the current schedule by removing the head of the schedule.
after each receive event the scheduler compares the current head of the schedule with the corresponding receive events of the messages held in the pool.
if any held message is eligible to be sent it delivers them to the receiver.
in addition to forcing schedules we leverage the infrastructure of the scheduler to measure coverage and to gather information for computing ordering constraints.
vi.
e valuation to evaluate the effectiveness of our approach we have implemented it for akka a popular commercially supported actor library for scala and apply it to five real world actor programs and three smaller actor programs.
in summary we have the following results bita detects twelve bugs including eight previously unknown bugs.
six of seven bugs that we reported to the developers have already been fixed.
bita is more effective in finding bugs than existing approaches it finds bugs 122x faster than a random scheduler and 656x faster than the default scheduler.
within a given time bita gives higher coverage than existing approaches for example 3x higher pr coverage.
a. experimental setup programs table i lists the programs used in the experiments.
the first five programs are open source real world programs.
for fyrie redis we use two independent branches of the program.
the other three programs are implementations of classical actor problems and the translation of a program used in earlier work .
for two of the real world programs we use the same inputs provided in the test suites of the source repository and for the others we use variants of the inputs in the test suites.
the test oracle checks for crashes in the program with a valid input.
bita relies on the assumption that the tested programs only source of non determinism is message ordering.
to match this assumption we must deal with programs that interact with external entities such as an http server or the actor system scheduler or that have time dependent behavior.
for example 7program loc description gatling v1.
ga stress testing tool for http servers geotrellis v0.
geo geographic data processing engine fyrie redis v1.
fr1 redis client written in scala fyrie redis v2.
fr2 redis client written in scala signalcollect v2.
sc framework for scalable graph computing barber ba sleeping barber problem messenger ms instant messaging application procreg pr translation of process registry in erlang table i programs used in the experiments .
some actors in signalcollect send messages depending on the time passed between the last receive and the current receive.
to deal with programs that interact with external entities we extend bita so that for each external entity we can define artificial actors as the senders of the external messages.
as a result bita can treat the external messages as regular messages.
to deal with time dependent behavior we introduce a logical time and replace checks for the system time by checks for the logical time.
the logical time is a counter that is increased when a message is received.
baselines we compare our approach with two other ways to explore the schedules of an actor program i repeated execution with a scheduler that adds random delays before delivering a message similar to what describes for sharedmemory programs and ii repeated executions with akka s default scheduler.
the random scheduler respects message ordering constraints when it chooses the delay value.
for example to respect sender receiver constraints for a particular pair of sender and receiver the scheduler always delays a later messages long enough to arrive after an earlier message.
the effectiveness of the random scheduler depends on the range from which delays are taken.
we experiment with delays in the range for three values of dmax 100ms 200ms and 300ms.
larger delays are impractical because of the timeout of synchronous communications.
b. bug detection real world bugs applying bita to the programs in table i reveals twelve bugs as shown in the first column of table ii.
we experiment with four known bugs and bita finds all of them.
for example the developers of the known bug sc3 mention that in rare cases the test fails in the following way which means they cannot reproduce the bug easily but they occasionally observed the bug.
bita finds this bug in every experiment and takes seconds on average.
since bita stores the schedules bugs can be easily reproduced and their absence can be verified after fixing them.
in addition to previously known bugs bita detect eight previously unknown bugs four in gatling two in signalcollect one in fyrie redis and one in barber.
except for the bug that we found in barber which is implemented by the authors we reported these bugs to the respective developers in the form of six issues.
all but one bug has already been confirmed and fixed by the developers.
comparison with baselines to compare our approach with random scheduling and akka s default scheduler we measure for each bug how long each approach takes to find it.
for each approach we stop testing if the bug is found or after a timeout of one hour.
for programs that contain more than one bug such as gatling we fix all but one bug at a time.
the schedules generated by bita depend on the schedule from the initial execution.
to address this source of nondeterminism we run bita ten times for each bug.
similar the random scheduler depends on a random seed and the default scheduler may be influenced by various system effects.
we repeat each experiment ten times giving different random seeds to the random scheduler.
given the three coverage criteria which criterion should developers use when testing with bita?
we prioritize criteria based on their cost which is the number of generated schedules.
based on the discussion in section iii and initial experiments the number of generated schedules for pr and pbr are usually smaller than for pcr .
the number of generated schedules for pr andpbr may not be comparable.
we configure bita to obtain an initial schedule and to use at firstpr then pbr and finally pcr until a bug is found.
the bug detection time is the sum of the time for obtaining the initial schedule the time for generating schedules and the time for executing the program with the generated schedules until the bug is found or timeout is reached.
table ii summarizes how long each approach requires to find each bug.
for all measured values we give the arithmetic mean and confidence intervals confidence level .
all times are in seconds.
to means the approach does not find the bug before timeout in any of our experiments.
if an approach finds a bug in some but not all runs we compute the average time by optimistically using the timeout value for the runs that do not detect the bug.
this situation happened only for pr and the default scheduler.
the tried criteria column shows the set of criteria tried by bita until it finds the bug.
for programs where pbr is not applicable because these programs do never change the behavior of an actor bita skips pbr and uses pcr afterpr.
the schedule column indicates the number of schedules tested by bita.
the exec column for the baselines shows the number of executions until the bug is detected or until the timeout is reached.
the results show that bita finds all bugs within a time that is reasonable for an automatic testing tool whereas the other approaches miss most bugs within the one hour timeout.
the best configurations of the random scheduler dmax ms anddmax ms detect only three bugs.
the default scheduler finds only one out of twelve bugs.
bita finds ten of the twelve bugs with the first criterion pr and by running the program with at most three schedules.
the pcr and pbr criteria each detect one bug missed by pr.
the small confidence intervals for bita and the large confidence intervals for the baselines show the stability of bita in detecting bugs.
the bottom of table ii summarizes the results for all twelve bugs and for all ten repetitions per bug.
for each approach we give four values i the total time that the approach spends 8bita random scheduler default scheduler bug issue dmax 100ms dmax 200ms dmax 300ms tried criteria time schedule time execs time execs time execs time execs ga1 u pr to to to to ga2 u pr to ga3 u pr to ga4 u pr to to sc1 u pr to to to to sc2 u pr to to to to sc3 k pr to to to to fr11 u pr to to to to fr12 k pr to to to to ba u pr pbr to to to to ms k pr to to to to pr k pr pcr to to to summary of all bugs with ten repetitions per bug total time total bugs avg.
time to detect a bug slowdown 1x 203x 124x 122x 656x table ii bugs detected and comparison of our approach to other approaches .
times are in seconds .
abbreviations u means unknown and k means known bug to means timeout .
240pcr pr 240pbr pr 240pbr pcr fig.
.
pairwise comparison of the four configurations.
when trying to find each of the twelve bugs ten times ii the number of times the approach finds a bug iii the average time to find a bug iv the slowdown of the approach relative to bita.
the results show that bita clearly outperforms the other approaches.
compared to the best configuration of the random scheduler bita finds bugs 122x faster.
compared to the default scheduler bita is even 656x faster.
comparison of coverage criteria to compare the three coverage criteria to each other we measure how long bita takes to find the bugs in table ii if it generates schedules for only one criterion.
for each bug bita obtains an initial schedule analyzes the program with each of the three criteria and measures the time to detect the bug using a timeout of one hour.
we run this experiment for all twelve bugs and repeat it ten times.
figure compares pairs of criteria to each other.
each point x y corresponds to one experiment.
the xandy values respectively show the time in which the bug is detected by the criterion at the xaxis and the criterion at the yaxis.
points on the dashed line are runs where a criterion does not detect the bug due to timeout.
that is if most of the dots are in the upper left part of the graph the criterion at the x axis is better and if most of the dots are in the lower right part of the graph the criterion at the y axis is better.
figure shows that both pr andpbr perform much better than pcr .
because most programs do not change actor behavior at runtime pbr is not applicable for them and there are fewer points in the plots for pbr .
for the programsprogr.
pr pcr pbr time bita rand impr.
time bita rand impr.
time bita rand impr.
ga .
.
geo .
.
n a n a n a n a sc .
.
n a n a n a n a fr2 .
.
n a n a n a n a geom .
.
table iii comparison of the coverage achieved by bita and random scheduling with dmax ms. times are in seconds .
the last column of each criterion shows the improvement of bita over random scheduling .
the last row is the geometric mean .
3000coverage time sec signalcollect pr bita rand 1500coverage time sec gatling pcr fig.
.
comparison of coverage achieved by bita and random scheduling withdmax ms. that change actor behavior at runtime prandpbr perform similarly.
in summary the results suggest that among all three criteria pr is the most effective criterion for detecting bugs.
c. coverage to evaluate bita s effectiveness in increasing schedule coverage we experiment with non buggy versions of the realworld programs excluding fr1 because the developers have not yet provided a fixed version.
for each criterion we run a program with bita and measure the coverage achieved by all schedules generated for the criterion and the time bita needs for testing all of them.
then we repeatedly run the test with random scheduling and with the default scheduler for the same amount of time and measure the achieved coverage.
9table iii compares the average over five runs of coverage achieved by bita and random scheduling with dmax ms. we only report the best configuration for random scheduling and omit the default scheduler which performs worse.
on average bita achieves at least twice the coverage of random scheduling for all three criteria.
for pr which is the most effective criterion in detecting bugs bita gains coverage three times faster than random scheduling.
figure illustrates the coverage achieved by bita and random scheduling for two programs and two criteria.
the figure illustrates that bita achieves coverage much faster than random scheduling.
the coverage improvement of bita over random scheduling is smaller than the improvement in bug finding ability table ii because bita s coverage domain is smaller.
there are two reasons.
first our approach is based on a single initial schedule whereas random scheduling can discover additional ordering goals in later executions.
second our approach conservatively considers must happen before relations and therefore may miss feasible ordering goals.
despite the smaller coverage domain bita clearly outperforms random scheduling in both coverage and bug finding ability.
vii.
r elated work a. exploring schedules of concurrent programs one baseline for our evaluation are random delays of message delivery which is similar to existing work that introduces random delays before thread synchronization points .
other random based approaches schedule threads based on the partial order of events or based on heuristics .
software model checkers for shared memory programs or for actor programs explore all possible schedules exhaustively possibly optimized through partial order reduction to avoid redundant schedules.
in contrast to exhaustive exploration our scheduling approach scales to large programs.
to reduce the complexity of exhaustive exploration one can bound the search space for example by bounding the number of preemptions .
we are not aware of a bounded model checker for actor programs.
active testing combines an analysis that finds potential concurrency bugs with schedule generation aimed at exposing these potential bugs .
the idea has been applied to data races deadlocks atomicity violations memory related errors concurrent access anomalies and other errors .
in contrast our approach is not focused on a particular kind of error but it generates schedules to increase coverage.
another stream of work forces shared memory programs into unusual schedules under the assumption that these schedules are not tested sufficiently .
adapting the ideas of these approaches to actors is subject to future work.
several testing frameworks have been developed for both shared memory programs and actor programs that run the tests with a schedule given by the programmers.
in contrast our approach automatically generate the schedules of interest without requiring the programmers to write the schedules.finally the idea to use coverage to guide schedule generation has recently been proposed for shared memory programs .
hong et al.
generate schedules based on synchronization pair coverage .
yu et al.
consider multiple interleaving idioms to construct a coverage domain .
similar to our work both approaches define ordering goals based on one or more initial runs.
our work differs by considering actor programs instead of shared memory programs and by generating only feasible schedules.
b. coverage of concurrent programs measuring coverage is widely accepted to assess the effectiveness of tests and to guide the creation of a test suite.
taylor et al.
are the first to propose to apply coverage criteria to concurrent programs .
yang et al.
adapt all definitionuse pair coverage to concurrent programs and show how to measure it .
synchronization coverage is a set of coverage criteria focused on synchronization primitives of shared memory programs .
lu et al.
propose a hierarchy of seven schedule coverage criteria and theoretically analyze the cost of each criterion .
krena et al.
propose a set of saturation based coverage metrics that are derived from dynamic analyses to find concurrency errors .
in contrast to all the above approaches this paper addresses the problem of coverage for actor programs.
souza et al.
propose structural coverage criteria for mpi message passing interface programs .
their coverage criteria are based on mpi synchronization primitives and cannot be directly applied to actor programs.
in contrast to their work we leverage coverage criteria for schedule generation.
c. debugging actor programs claessen et al.
propose to detect bugs in actor programs by automatically generating tests and by using the linearizations of a concurrent execution as an oracle for the concurrent execution .
in contrast to our approach their technique relies in finite state models that formally specify how the program under test should behave.
christakis and sagonas describe a static analysis of erlang programs to find message passing errors based on four common bug patterns .
in contrast to their analysis which suffers from false positives our approach guarantees that each detected bug is feasible and our approach is not limited to particular bug patterns.
viii.
c onclusion this paper presents bita an automatic testing approach to efficiently explore the non deterministic behavior of actor programs.
guided by three novel coverage criteria the approach automatically generates schedules and forces the program execution to follow these schedules.
each generated schedule is feasible and achieves coverage goals not achieved by previous schedules.
applying the approach to real world actor programs shows that it finds bugs substantially faster than random scheduling and than repeated execution with the default scheduler.
bita reveals eight previously unknown concurrency bugs six of which have already been fixed by the developers in reaction to our bug reports.
10references fyrie redis.
gatling stress tool.
geotrellis.
signal collect.
g. agha.
actors a model of concurrent computation in distributed systems .
mit press cambridge ma usa .
j. armstrong.
making reliable distributed systems in the presence of software errors .
phd thesis kungl tekniska h ogskolan .
http j. bon er v .
klang r. kuhn et al.
akka library.
a. bron e. farchi y .
magid y .
nir and s. ur.
applications of synchronization coverage.
in ppopp pages .
s. burckhardt p. kothari m. musuvathi and s. nagarakatte.
a randomized scheduler with probabilistic guarantees of finding bugs.
in asplos pages .
s. bykov a. geller g. kliot j. r. larus r. pandya and j. thelin.
orleans cloud computing for everyone.
in socc pages .
f. chen t. f. serbanuta and g. rosu.
jpredictor a predictive runtime analysis tool for java.
in icse pages .
m. christakis and k. sagonas.
detection of asynchronous message passing errors using static analysis.
in padl pages .
m. christakis and k. f. sagonas.
detection of asynchronous message passing errors using static analysis.
in padl pages .
k. claessen m. palka n. smallbone j. hughes h. svensson t. arts and u. t. wiger.
finding race conditions in erlang with quickcheck and pulse.
in icfp pages .
k. e. coons s. burckhardt and m. musuvathi.
gambit effective unit testing for concurrency libraries.
in ppopp pages .
o. edelstein e. farchi y .
nir g. ratsaby and s. ur.
multithreaded java program test generation.
ibm syst j .
c. flanagan and s. n. freund.
adversarial memory for detecting destructive races.
in pldi pages .
l. a. fredlund and h. svensson.
mcerlang a model checker for a distributed functional programming language.
in icfp pages .
q. gao w. zhang z. chen m. zheng and f. qin.
2ndstrike toward manifesting hidden concurrency typestate bugs.
in asplos pages .
p. godefroid and n. nagappan.
concurrency at microsoft an exploratory survey.
in ec2 .
p. haller and f. sommers.
actors in scala .
artima .
c. hewitt p. bishop and r. steiger.
a universal modular actor formalism for artificial intelligence.
in ijcai pages .
s. hong j. ahn s. park m. kim and m. j. harrold.
testing concurrent programs to achieve high synchronization coverage.
in issta pages .
j. huang and c. zhang.
persuasive prediction of concurrency access anomalies.
in issta pages .
v .
jagannath m. gligoric d. jin q. luo g. rosu and d. marinov.
improved multithreaded unit testing.
in esec fse pages .
p. joshi m. naik c. s. park and k. sen. calfuzzer an extensible active testing framework for concurrent programs.
in cav pages .
r. k. karmani a. shali and g. agha.
actor frameworks for the jvm platform a comparative analysis.
in pppj pages .
b. krena z. letko and t. v ojnar.
coverage metrics for saturation based and search based testing of concurrent software.
in rv pages .
z. lai s. c. cheung and w. k. chan.
detecting atomic set serializability violations in multithreaded programs through active randomized testing.
in icse pages .
s. lauterburg m. dotta d. marinov and g. a. agha.
a framework for state space exploration of java based actor programs.
in ase pages .
b. long d. hoffman and p. strooper.
tool support for testing concurrent java components.
ieee tr softw eng june .
s. lu w. jiang and y .
zhou.
a study of interleaving coverage criteria.
inesec fse pages .
m. musuvathi s. qadeer t. ball g. basler p. a. nainar and i. neamtiu.
finding and reproducing heisenbugs in concurrent programs.
in osdi pages .
c. s. park and k. sen. randomized active atomicity violation detection in concurrent programs.
in fse pages .
s. park s. lu and y .
zhou.
ctrigger exposing atomicity violation bugs from their hiding places.
in asplos pages .
v .
pech d. k onig r. winder et al.
gpars.
w. pugh and n. ayewah.
unit testing concurrent software.
in ase pages .
k. sen. effective random testing of concurrent programs.
in ase pages .
k. sen. race directed random testing of concurrent programs.
in pldi pages .
k. sen and g. agha.
automated systematic testing of open distributed programs.
in fase pages .
f. sorrentino a. farzan and p. madhusudan.
penelope weaving threads to expose atomicity violations.
in fse pages .
s. r. s. souza s. r. vergilio p. s. l. souza a. s. sim ao and a. c. hausen.
structural testing criteria for message passing parallel programs.
concurr comput pract exper nov. .
s. tasharofi m. gligoric d. marinov and r. johnson.
setac a framework for phased deterministic testing of scala actor programs.
in scala days .
s. tasharofi r. k. karmani s. lauterburg a. legay d. marinov and g. agha.
transdpor a novel dynamic partial order reduction technique for testing actor programs.
in fmoods forte .
r. n. taylor d. l. levine and c. d. kelly.
structural testing of concurrent programs.
ieee tr softw eng .
w. visser k. havelund g. p. brat s. park and f. lerda.
model checking programs.
autom software eng .
c. s. d. yang a. l. souter and l. l. pollock.
all du path coverage for parallel programs.
in issta pages .
j. yu s. narayanasamy c. pereira and g. pokam.
maple a coveragedriven testing tool for multithreaded programs.
in oopsla pages .
w. zhang j. lim r. olichandran j. scherpelz g. jin s. lu and t. w. reps. conseq detecting concurrency bugs through sequential errors.
in asplos pages .
w. zhang c. sun and s. lu.
conmem detecting severe concurrency bugs through an effect oriented approach.
in asplos pages .