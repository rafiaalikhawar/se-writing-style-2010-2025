taming test inputs for separation assurance dimitra giannakopoulou nasa ames research center moffett field ca usa dimitra.giannakopoulou nasa.govfalk howar carnegie mellon university moffett field ca usa howar cmu.edumalte isberner tu dortmund university dortmund germany malte.isberner udo.edu todd lauderdale nasa ames research center moffett field ca usa todd.a.lauderdale nasa.govzvonimir rakamari c school of computing university of utah usa zvonimir cs.utah.eduvishwanath raman fireeye inc. usa vishwa.raman gmail.com abstract the next generation air transportation system nextgen advocates the use of innovative algorithms and software to address the increasing load on air tra c control.
autoresolver is a large complex nextgen component that provides separation assurance between multiple airplanes up to minutes ahead of time.
our work targets the development of a light weight automated testing environment forautoresolver.
the input space of autoresolver consists of airplane trajectories each trajectory being a sequence of hundreds of points in the three dimensional space.
generating meaningful test cases for autoresolver that cover its behavioral space to a satisfactory degree is a major challenge.
we discuss how we tamed this input space to make it amenable to test case generation techniques as well as how we developed and validated an extensible testing environment around autoresolver.
categories and subject descriptors d. .
testing and debugging symbolic execution d. .
testing and debugging testing tools general terms veri cation experimentation keywords test case generation air tra c control test coverage these authors did this work while at carnegie mellon university.
c association for computing machinery.
acm acknowledges that this contribution was authored or co authored by an employee contractor or affiliate of the united states government.
as such the united states government retains a nonexclusive royalty free right to publish or reproduce this article or to allow others to do so for government purposes only.
ase september vasteras sweden copyright acm ... .
.
loss of separation and resolution.
lateral view of two airplanes their trajectories and areas of horizontal separation assurance.
left con ict in the near future.
center loss of separation.
right detour that will prevent loss of separation.
.
introduction the next generation air transportation system nextgen is a nasa research program that addresses the increasing load on the air tra c control system through innovative algorithms and software systems.
this paper reports on collaborative work between the robust software engineering rse group and the nextgen group at the nasa ames research center.
the work aims at developing an automated light weight testing infrastructure for autoresolver a proposed nextgen component for prediction and resolution of loss of separation between multiple airplanes in the to minutes time horizon.
loss of separation between two airplanes occurs when they are closer to each other than a prede ned safe vertical or horizontal distance.
separation assurance aims to eliminate the occurrence of loss of separation in the air space.
figure shows a sketch of a potential loss of separation between two aircrafts and how it can be avoided by letting one airplane take a detour.
testing autoresolver presents various challenges.
the input data consists of several airplane trajectories each trajectory being a sequence of points in the three dimensional space that the airplane is expected to y. if trajectory points were exposed directly as input parameters to the testing problem the vast majority of generated test cases would not correspond to a realistic airplane trajectory.
it would also be extremely hard to express constraints between trajectory points to avoid this problem.
moreover the autoresolver logic involves millions of paths that must be tested thoroughly.
a practical challenge when testing au373 toresolver is that it was designed and developed as a component of a heavyweight airspace simulation environment named aces .
given the complexity of generating appropriate input data forautoresolver the nextgen team typically uses historical airport data recordings as test inputs.
such inputs usually involve thousands of airplanes and each test case takes several hours to run.
note that it is hard to isolate subsets of the airplanes that would lead autoresolver to similar behavior.
our e orts therefore concentrate on generating a light weight but accurate enough testing environment where thousands of test cases can be run within minutes to achieve some targeted coverage of autoresolver.
to achieve this goal our team has developed the following components .
a wrapper that provides parameterized loss of separation scenarios for autoresolver is presented in section .
each concretized scenario corresponds to input airplane trajectories for autoresolver.
while allowing exibility through its input parameters this wrapper only generates realistic trajectories.
.
stubs for the aces database which result in a less precise but signi cantly more light weight testing environment overall section .
.
black box and white box techniques for test case generation at the wrapper level as described in section .
.
tools for evaluation of our developed environment.
we developed extensions to the coverage measuring tool jacoco1for comparing how di erent scenarios and test case generation techniques contribute to test coverage of autoresolver section .
we also connected our tools to nextgen visualization tools and evaluated the quality of the test inputs and the aces stubs that we created section .
in previous work we focused on tsafe a nextgen component that also targets separation assurance but at a shorter time horizon.
testing the more complex autoresolver system presented us with new challenges.
tsafe is a standalone application whose inputs consist of position airspeed and heading for airplanes.
this enabled us to generate inputs for the system directly even so only black box test case generation was successful at scaling for tsafe .
on the other hand trajectory generation has been a major challenge in testing autoresolver as has been the stubbing of the aces system.
moreover in the last four years we have developed robust white box techniques these have been applied successfully to autoresolver as reported in this paper.
finally our new testing environment has been integrated with nextgen tools to make its application and evaluation simple and intuitive for nextgen developers.
note that the topic of de ning oracles for the testing process although crucial for automated testing is not addressed here.
similarly to tsafe oracles are hard to de ne for this type of problem.
for example autoresolver producing a successful resolution does not necessarily correspond to correct behavior as the following requirement should be met a proposed resolution should not create a more imminent con ict with a third aircraft .
we intend to identify formalize oracles in the future in collaboration with the domain experts.
.
autoresolver the advanced airspace concept aac is a concept for automating separation assurance in the future.
a key feature of this concept is the use of multiple independent layers of separation assurance for increased reliability.
one component of aac is a strategic problem solving tool known as autoresolver .
this algorithm was originally developed in the aces environment taking full advantage of the zero error trajectory prediction available and many studies of the e ectiveness of this algorithm in the zero uncertainty environment have been performed .
autoresolver uses an iterative approach to resolve all of the con icts found by the con ict detection system.
the algorithm attempts to generate many di erent types of resolutions for each con ict.
after the resolution trajectories have been generated the successful resolution expected to impart the minimum airborne delay is chosen for implementation.
autoresolver consists of approximately 65k lines of java code.
for each resolution that it attempts it communicates with aces a simulation environment whose core consists of approximately klines of code.
testing of autoresolver is typically performed using test cases of or airplanes and take between and hours to run.
the results are monitored by domain experts to see whether autoresolver behaves as expected.
to ensure more systematic testing of the behavior of autoresolver potentially targeting some type of test coverage a lighter weight testing environment would be desirable to complement the current testing process.
the capability to generate tests automatically would also be useful for generating smaller in terms of numbers of airplanes involved more focused and easier to run tests.
the results of our collaborative work with the autoresolver team in creating such an environment are presented in the rest of this paper.
.
test environment as mentioned the input to autoresolver consists of a set of trajectories as sequences of points that an airplane is expected to y. neighboring points are seconds apart and each one describes the three dimensional position of the airplane latitude longitude and altitude as well as other details such as airplane speed and heading.
based on these trajectories autoresolver checks if loss of separation occurs between any pair of airplanes within its time horizon of to minutes.
for any such pair autoresolver attempts to resolve the loss of separation by proposing maneuvers that modify the originally planned trajectory.
the aces tool is responsible for creating new trajectories for the proposed maneuvers.
.
replacing aces aces developed at nasa ames is a sophisticated tool that simulates airplane ights taking into account airplane characteristics as well as other factors that may a ect ight such as winds and weather.
autoresolver relies on the aces trajectory generation in order to evaluate resolution maneuvers for each loss of separation scenario as .
despite the fact that aces is very precise it is a heavy374aces autoresolvercon ict trajectories maneuvers updated trajectories figure integration of autoresolver and aces.
weight tool that adds a signi cant burden to the testing process.
in creating a light weight testing environment we have therefore created stubs that replace the functionality of aces with more approximate behavior.
the main capability that our aces stubs provide is the generation and modi cation of airplane trajectories.
in our implementation each airplane is associated with an abstract trajectory.
an abstract trajectory basically captures the intent of a trajectory it consists of a number of commands that describe points in time at which the airplane changes airspeed heading maintains some temporary altitude or climbs or descends to a target altitude.
an abstract trajectory with no commands corresponds to simply cruising at the initial altitude with no heading or airspeed changes.
in our framework the autoresolver maneuvers are then simply translated to the addition removal or modi cation of commands in the abstract trajectory.
consider for example the trajectories illustrated in figure b and e .
the resolution displayed in e corresponds to an extend altitude maneuver which delays a climb or descend command for a short period of time.
abstract trajectories are turned into concrete trajectories to be understood by autoresolver.
this is achieved by computing ight points at second intervals that correspond to the abstract trajectory and initial airplane position.
we use the nasa open source worldwind libraries to perform required great circle calculations for computing latitude and longitude.
.
scenarios how does one automatically generate airplane trajectories to exercise the behavior of autoresolver?
our goal with this work was to enable the application of existing test case generation approaches to this complex system.
as mentioned it is practically impossible to automatically generate realistic trajectories as sequences of unconstrained points in the three dimensional space.
imagine for example that one was to use some sophisticated symbolic execution tool to generate trajectories that exercise the paths of the autoresolver code.
even if such a tool were able to scale to the size of the problem the points generated by the tool would most likely not correspond to a trajectory that can be own by an airplane.
it would also be infeasible to introduce constraints between the points to ensure that they represent a viable trajectory.
moreover our goal is for the majority of generated tests to represent scenarios where loss of separation occurs.
our approach to dealing with this problem is to create a modular extensible wrapper around autoresolver that implements parameterized loss of separation scenarios.
each concretized scenario is translated into a set of trajectories with which the wrapper invokes autoresolver.
note that loss of separation is handled for two airplanes at a time while each proposed resolution is evaluated against the setof all airplanes in the airspace sector that autoresolver is currently handling all other airplanes are called secondary .
we therefore create loss of separation scenarios between two airplanes.
in order to ensure that the test inputs that are thus generated mostly correspond to loss of separation scenarios we proceed as follows.
first of all a point is selected in threedimensional space representing a position at which the two airplanes will meet.
even though loss of separation will actually occur prior to the airplanes reaching that point for simplicity we will refer to this point as the loss of separation point.
given airplane heading airspeed altitude an abstract trajectory representing the targeted scenario and some time point tin the future at which the airplanes are to reach the loss of separation point we y the two airplanes backwards headings are reversed to reach their respective initial positions.
trajectory generation is then used as implemented for the aces stub to create appropriate trajectories for the two airplanes.
in the following we describe three types of scenarios that are currently implemented in our framework.
these scenarios are well understood by the autoresolver developers team to be standard loss of separation scenarios that may exercise the behavior of autoresolver in interesting ways.
thecruise scenario represents the simplest case where each airplane is in level ight i.e.
its altitude remains constant .
an example of such a scenario is illustrated in figure a .
since the exact position at which each scenario occurs is not important all parameters of one airplane are kept constant as is the point of loss of separation its lateral coordinates and altitude .
however we parameterize the scenario on the heading deg.
and airspeed kts.
of the other airplane as well as on the time sec.
of loss of separation and the o set sec.
with which the airplanes arrive at the speci ed point.
by letting two airplanes pass the same point in space with some time in between we can control if there will be a loss of separation and create situations in which it is su cient to slow down one airplane for a little while in order to avoid a con ict.
in the climb scenario both airplanes climb or descend for some portion of the short term trajectory.
figure b illustrates such an example where one airplane descends and the other airplane climbs and loss of separation occurs during descent climb.
variations of this scenario include cases where the airplanes lose separation after one or both of them level o .
in addition to the input parameters of thecruise scenario this scenario parameterizes the type of trajectory for each airplane through the speci cation of initial cruise sec.
time and the level o sec.
time as well as the climb ft. min rates.
theturn scenario is similar to cruise but introduces a change of heading for one or both airplanes at some point in the trajectory as illustrated in figure c .
in addition to the input parameters of the cruise scenario this scenario is for each airplane parameterized on the change of heading deg.
and the respective time of change sec.
.
we would like to stress that these are a subset of the scenarios that one could de ne for this problem and that we are currently only dealing with loss of separation during ight as opposed to during arrivals and departures.
we are also not dealing with weather con icts.
the architecture of our tool is extensible making it easy for us or the au375 a b c d e f figure con ict scenarios and examples of successful resolutions.
a lateral view of cruise con ict and d resolution through path stretch maneuver b longitudinal view of climb con ict and e resolution through extend altitude maneuver c lateral view of turn con ict and f resolution through direct to maneuver.
axes of lateral plots are longitude and latitude in degrees.
axes of altitude plots are time in milliseconds and minutes and altitude in feet.
fig.
b and e show commands from abstract trajectories.
aactestwrapper testclcl climb1 !
.
climb2 !
... head1 double ... climb1 double cruise1 double leveloff1 double time double ... figure testgen speci cation for scenario climb.
toresolver developers to add more scenarios to exercise additional behavior of the system.
.
test input generation by instantiating with meaningful values the parameters exposed by our test wrapper it is possible to generate realistic test cases for autoresolver.
in this section we present two di erent tools that we have developed for this purpose.
the two tools have very di erent philosophies and characteristics as described in detail below.
.
black box testing to perform black box testing we developed a tool called testgen.
testgen generates test cases in a black box fashion based on a declarative speci cation of the input space of the system under test.
testgen takes as input a method of some java class and a description of ranges for primitive parameter values that are to be tested.
it then generates test cases that correspond to the cartesian product of the input value ranges.figure illustrates a testgen speci cation for the climb scenario.
each scenario parameter is associated with a range together with a step for generating values to be tested within the range.
for example the heading values that are to be tested consist of .
in addition testgen also supports automatically ltering out uninteresting cases.
for example the very rst line of the speci cation requires that the generated test cases include at least one aircraft with a non zero climb rate.
this is to avoid generating tests that are covered by the cruise scenario.
testgen automatically generates all possible combinations of the speci ed input values lters out the uninteresting ones and turns the remaining ones into junit tests that can be executed on the system under test.
for the example of figure testgen generated tests.
in our previous work we used the java pathfinder2 open source model checking tool to generate blackbox tests.
in this work we decided to avoid using a heavyweight model checking tool to solve this relatively simple problem.
testgen is intuitive to use.
it can if required automatically parse java code to identify public methods and their corresponding parameters and create a csvspreadsheet for developers to enter their test speci cations.
.
concolic testing jdart is a concolic execution engine based on the java pathfinder framework it can be used to generate test cases exercising a large number of paths in a program.
the tool executes java programs with con2 376crete and symbolic values at the same time and records symbolic constraints describing all the decisions i.e.
conditional branches taken along a particular execution path.
combined these path constraints form a constraints tree.
the constraints tree is continually augmented by trying to exercise paths to unexplored branches.
concrete data values for exercising these paths are generated using a constraint solver.
even though we exclusively use microsoft s z3 smt solver at the moment jdart is independent of a particular solver implementation thanks to a solver abstraction layer.
the e cacy of concolic testing stands and falls with the availability of a potent decision procedure for the respective theory in which the program constraints are formulated.
as such it seems unlikely that jdart would ever be able to cope with a huge complex system like autoresolver.
however under the motto failure is not an option we focused on improving the robustness of jdart to reap the bene ts of improving coverage even under adverse conditions such as unsupported theories.
the following paragraphs brie y describe the major challenges we faced and how we were able to cope with or mitigate them.
approximating floating point arithmetic.
unsurprisingly autoresolver makes heavy use of oating point calculations.
at the time of publication z3 comes with only a very rudimentary and undocumented implementation of a oating point theory.
we quickly found that we would be unable to bene t from this especially as common operations such as conversion between integers and oats are entirely unsupported.
therefore similarly to some previous work we chose a di erent approach of approximating oating point values using reals.
while this approximation is not sound as it does not account for the limited precision e ects it might frequently yield valuable solutions even if they are incorrect see below .
furthermore in the latter case jdart can be instructed to try harder by imposing additional constraints.
for instance if a constraint involving an integer tooat conversion yields an incorrect result we will rst try to restrict the solution space to those integers that can be losslessly stored in a oating point number before giving up.
similarly the limited precision e ects a ecting arithmetic operations can be mitigated by restricting the relative di erence of the operands involved.
this of course increases the chance that the solver might return don t know or even unsatis able which also needs to be interpreted as don t know because of the additional constraints we imposed but this is no worse than the initial incorrect solution.
another aspect concerns special oating point values such as nan not a number or in nity.
these cannot be mapped to a value in the solver s theory on reals.
in principle we currently assume that these values do not occur.
however we intercept methods that are common sources of nan or in nity results such as math.asin if the argument is symbolic we branch on whether it lies in the interval.
as this branch is re ected in the constraints tree we at least identify some paths on which nan values occur and can furthermore safely discard any symbolic information about the function result.
handling native calls.
most complex java programs make use of methods that need to be executed outside of the jvm e.g.
if they are provided by a library implementedin c. the java pathfinder tool is not able to handle such native calls out of the box.
instead native calls need to be re ected by so called native peers i.e.
java methods that are executed in the host jvm the jvm executing java pathfinder itself .
thanks to the recent jpf nhandler extension 3these native peers can now be generated automatically on they for arbitrary third party native methods.
however we cannot keep track of symbolic information during the execution of native methods as this does not happen under java pathfinder s control.
jdart can be instructed to deal with this in three di erent ways which can be combined a discarding all symbolic information and simply continuing with the concrete value returned b symbolically annotating the return value with an uninterpreted function over method parameters 4or c performing symbolic execution through a symbolic peer which may augment the constraints tree and symbolically annotate return values.
these symbolic peers need to be implemented manually.
for autoresolver we used them to implement the above described branching in java.lang.math methods possibly returning nan.
for trigonometric functions and other mathematical functions we let jdart only annotate the return value symbolically with the function name.
during constraint solving we make some simple assumptions about the ranges of these functions.
dealing with incorrect solutions.
the aforementioned problems frequently cause the solver to return solutions which despite being correct modulo the employed theory fail to exercise the intended concrete path in the program.
whether this is due to the unsound approximation of oating point values by reals or loss of symbolic information through a native call when analyzing a program like autoresolver such incorrect solutions have to be considered the default rather than the exceptional case.
simply discarding these solutions would hence be a huge waste of computation time.
instead jdart analyzes every solution and tests if it can nonetheless be used to exercise some even if not the originally intended path that is still unexplored in the program.
hence a computed concrete solution is discarded only when we are absolutely sure that no new information i.e.
paths can be gained from it.
selective exploration.
as described in section .
we employ a wrapper to generate complex loss of separation scenarios.
this narrows down the input space from trajectories consisting of three dimensional coordinates each to a handful of oating point variables such as the airplane speed or heading.
to symbolically keep track of the e ects that these variables incur in the autoresolver code the wrapper needs to be executed by jdart .jdart will then try to exhaustively explore the behavioral space of the wrapper combined with autoresolver.
however given limited resources it may be bene cial to focus on maximizing path coverage for autoresolver and not necessarily the wrapper.
to achieve that jdart can be con gured to explore the path space selectively by suspending or resuming exploration upon method entry or exit.
for example we could con gure jdart to not explore the initialization phase i.e.
when executing the scenario generation wrapper .
exploration could be speci ed to start when 4for non pure native methods this is incomplete but there is no means of checking purity.
377a method of any class in the main autoresolver package nasa.arc.aac is invoked and suspended again during methods of the uninteresting datalogger class contained in this package.
this is complemented by the possibility of specifying sets of input values for replay jdart will replay these cases and explore according to the above criteria.
.
coverage analysis in the previous sections we described our infrastructure for generating test suites for testing autoresolver.
the generated tests must be evaluated both in terms of how well they exercise the system under test and also how realistic they are with respect to the problem that is being solved.
we have established application dependent measures of coverage to complement standard structural coverage criteria forautoresolver.
in this section we describe these criteria and the tool support that we have developed for evaluating and comparing test suites accordingly.
moreover we discuss how we have developed support for evaluating the generated tests within visualization tools developed by the autoresolver team.
.
coverage metrics code coverage.
among the multitude of code coverage criteria that exist branch coverage has been identi ed as a good measure for comparison of test suite quality .
moreover path coverage at the bytecode level provides the most exhaustive structural coverage for exercising all behaviors of a system.
branch coverage corresponds to the percentage of branching bytecode instructions conditional jumps or ifandswitch statements on the language level that have been executed with both possible outcomes jump or no jump .
each branching instruction is considered in isolation.
path coverage on the other hand also takes into account the combination of the di erent branching instruction outcomes in single executions.
note that in our experiments we do not expect to achieve coverage.
first of all our current scenarios do not cover all the possible cases that autoresolver is designed to handle such as arrivals and departures.
it would be extremely hard for us to isolate the part of the code that deals with our scenarios in order to establish a coverage target.
on the other hand coverage is very hard to achieve in general since it is a purely theoretical value.
for example a program may contain unreachable code the detection of which is in the general case undecidable.
some branches may not be satis able determining whether the condition of a branching instruction is satis able requires at the very least a complete decision procedure for the underlying theory.
for these reasons we report our coverage results both in terms of absolute numbers of paths or branches covered and percentages.
resolution coverage.
branch and path coverage measure the quality of a test suite at a very low level.
a measure more targeted to the system under test is to look at the system s high level functionalities.
as described in section autoresolver attempts di erent prede ned maneuvers to resolve loss of separation and executes the optimal maneuver among the successful ones.
hence we introduce the resolution coverage metric by considering maneuver typestable maneuver types.
id description 1temp.
altitude climb to intermediate alt.
3step alt.
climb level o descend to original alt.
4step alt.
descend level o climb to original alt.
5direct to take a shortcut to route point 8temp.
speed temporarily increase decrease speed path stretch take a detour to route point extend altitude extend current alt.
for some time o set temporarily move to a parallel path that result in successful resolution attempts maneuver types that are selected as the executed resolution and how many unique combinations sets of successful maneuver types in order of application of successful resolution attempts are exercised while running a test suite.
the maneuver types attempted by autoresolver in our generated scenarios are shown in table .
this is only a subset of all implemented maneuver types.
maneuvers not shown in the table are outside the scope of our current scenarios.
for instance they are related to losses of separation during arrivals or departures or to con icts involving weather which we currently do not generate.
selection of relevant maneuvers was performed for us by the autoresolver developers.
.
analysis tools jacoco.
jacoco is a free java library for measuring code coverage.
we use this library to record branch coverage on autoresolver for the generated test suites.
covcomp.
we developed covcomp to compare branch coverage of di erent test suites.
the tool uses the jacoco library to measure branch coverage for multiple test suites and then visualizes the di erences.
it displays branch coverage for two individual test suites as well as for their union at the level of classes or for the actual source code.
lines with branching instructions in the code are colored according to their coverage by the two test suites and their union.
we used covcomp for analyzing the di erences in coverage between generated test suites in detail.
aacviz.
aacviz is a tool for visualizing and replaying resolutions produced by autoresolver.
it is used for debugging and analyzing the behavior of autoresolver by its developers.
to connect to aacviz our wrapper and stub code implementations output logging information to an sql database which is the interchange format used by the autoresolver development environment.
we were thus able to use aacviz to visualize the trajectories that we generate in lieu of aces as well as trajectories that we generate in response to attempted maneuvers by autoresolver e.g.
see figure .
hence with the help of the autoresolver team we were able to validate that our framework provides a useful and realistic enough low delity testing environment for the autoresolver system.
.
evaluation the components we have developed for testing autoresolver are assembled into a three phase testing work ow illustrated in figure data is shown as trapezoids and tools as rectangles.
378test speci cationjdart testgentests alt level off head cruise climb turnautoresolverlogs code coverageaacviz covcomp jacoco figure work ow for testing autoresolver.
table statistics and path coverage for jdart scenarios.
explorescenariono.
of no.
of depth decisions per path path coverage runtime wrapper params.
seeds limit shortest longest sat unsat d k no alt level off head yes alt level off as above as above head the rst phase of the testing process consists of test case generation.
testgen andjdart see section both take as input a declarative speci cation for the target method also prescribing ranges or sets of valid inputs to this method.
the generated test cases target the wrapper scenarios for autoresolver.
test case execution and information logging happens during the second phase.
we record branch coverage using jacoco path coverage using jdart resolution coverage using the autoresolver s built in logging mechanism as well as several performance statistics e.g.
runtimes sizes of test suites or path constraints.
all obtained results and statistics are analyzed and compared during the third phase.
we analyze and compare branch coverage using the reports generated by jacoco andcovcomp .
interesting or odd test cases can be studied in detail using aacviz.
our resulting framework is modular and extensible in all of its components.
it can easily accommodate new testcase generation tools.
test speci cations give us exibility in changing the focus of test suites within the domains of the currently implemented scenarios.
additional scenarios can be incorporated for arrivals departures and for weather con icts.
the abstract trajectories presented in section .
provide a robust basis for extending scenarios or de ning entirely new ones.
currently we execute test cases with jacoco to record code coverage.
since we generate junit tests we could also use other java tools and record coverage for alternative code coverage metrics.
in the following sections we describe how we applied evaluated and validated our framework on autoresolver.
.
testing the autoresolver as discussed our framework implements test scenarios that tame the input space of autoresolver by providing input parameters that enable the generation of realistic trajectories.
however the input space of the scenarios is still in nite since input values such as heading and speed are continuous.
our test case generation tools testgen andjdart have fundamentally di erent philosophies for addressing this problem.
testgen reduces the input space by enforcing discretization of the speci ed input ranges through the speci cationof a step between values that it explores see figure .
jdart on the other hand relies on path constraints to create equivalence classes of input values where a single test case is generated as a representative of each class.
bounding the depth of exploration ensures that a nite number of equivalence classes is created.
we expect that jdart will be successful in identifying tests that are not covered by testgen when the step de ned for the discretization of ranges skips over values that are essential for covering speci c paths in the program.
generating tests with testgen.
to apply testgen we de ne three scenarios that correspond to the ones discussed in section .
and specify value ranges and lters as follows.
in the cruise scenario headings for one airplane range between and degrees with a step of degrees.
we use airspeeds from to knots at increments of knots.
the time to loss of separation is set to whole minutes with a minimum of minute and a maximum of minutes.
the time o set for the arrival at the point of loss of separation is set from to seconds at intervals of seconds allowing for situations where no loss of separation occurs.
ranges for all parameters were selected with help of the developers of autoresolver to create realistic concrete scenarios.
a total of test cases is generated as a result cf.
table .
for the climb scenario we let one or both airplanes climb or descend at a climb rate of feet per minute.
headings range between and degrees at intervals of degrees.
we do not use a time o set at the point of loss of separation and we use the same range for the time to loss of separation as the cruise scenario.
finally we allow both airplanes to start their climb descent at multiples of seconds and end the climb descent at multiples of seconds.
for climb we include a lter that ensures that airplanes always cruise at multiples of feet commercial aircrafts typically do this and do not climb above feet.
moreover to avoid recreating cruise scenarios we use a lter to ensure that at least one airplane climbs or descends.
altogether this results in test cases of which exhibit loss of separation cf.
table .
for the turn scenario we use the same time and initial heading ranges as for the climb scenario.
we allow both 379table resolution coverage of maneuvers by test suites per scenario.
tool scenariono.
of no.
of no.
of successful executed unique params.
tests con icts resolutions resolution comb.
testgencruise .
.
.
climb .
.
.
.
.
turn .
.
.
.
jdart alt .
level off .
head .
.
airplanes to change heading between and degrees at a step of degrees.
changes in heading are allowed at multiples of minutes.
our lters require that at least one of the airplanes changes heading thus avoiding to recreate test cases covered by the cruise scenario.
with test cases this is the largest test suite we generate.
as discussed the lters that we use also ensure that the test suites for the three scenarios are mutually disjoint cf.
table .
generating tests with jdart.
to apply jdart we similarly de ne three scenarios these are small variations of the scenarios for testgen or limited versions of them necessitated by the scalability issues of this more sophisticated tool.
alt xes two airplanes in level ight.
the only parameter exposed to jdart is the altitude di erence at the time of loss of separation.
this is a variation of cruise where the altitude di erence was xed to zero.
we also constrain airplane altitudes to multiples of feet similarly totestgen.
level off is a variation of the climb scenario.
we x two airplanes in a situation where one airplane is in level ight and the other is climbing for some stretch of time.
we letjdart control the altitude di erence at the time of loss of separation.
the e ect in this case is di erent than in the alt scenario since one airplane is in the process of climbing at the time of loss of separation this airplane does not have to be at a multiple of feet when the loss of separation occurs.
we only constrain the inputs that jdart generates to an interval from feet to feet.
head is a variation of the turn scenario.
we x all parameters except for the change of heading for one of the airplanes i.e.
jdart controls the new direction of the airplane s ight.
similarly to the turn scenario the change of heading ranges between and degrees.
we use two di erent con gurations in our experiments with jdart .
in the rst we limit the initial exploration until the execution enters autoresolver in the second we do not limit the start of the exploration i.e.
we explore both the wrapper and autoresolver but as a result impose stronger limits on the depth of exploration i.e.
the depth up to which we negate path constraints to nd new executions .
one con guration explores more paths analyzing shorter pre xes of path constraints while the other one explores fewer paths but analyzes path constraints to a greater depth.
in both con gurations we use a small number of manually selected input values seeds as starting points for the concolic execution.
results.
table reports statistics for test case generation withjdart .
note that we include both con gurations i.e.
with and without wrapper exploration.
the table shows the number of parameters for each scenario the number of seeded input values the manually xed depth bound thenumber of satis able paths used to generate test cases the number of unsatis able path pre xes the number of inconclusive don t know d k path pre xes and runtimes.
additionally we ran jdart without a constraint solver and only recorded the length of path constraints for the found test cases.
we report the length in terms of number of conjuncts of the shortest and longest respective path constraint.
for all three scenarios exploration proceeds faster and deeper into autoresolver when restricting exploration of the wrapper.
however the test cases found in this deeper exploration are subsumed by the ones found in shallow exploration.
in general few test cases are generated as discussed in section .
the high number of unsatis able path prexes is due to the exclusion of special oating point values nan and in nity methods isnan and isinfinite are used heavily in great circle computations .
high numbers of inconclusive path pre xes are seen for the head scenario where symbolic parameters are often used in trigonometric computations.
table shows the test suites that were generated for all six scenarios and how the generated tests cover the maneuvers that autoresolver uses to resolve con icts.
for each scenario we report the number of parameters exposed to the test case generation tool testgen for the upper part of the table and jdart for the lower part the number of tests generated and the number of test cases exhibiting loss of separation.
we then report the set of successful resolutions for each test suite i.e.
the classes of maneuvers that resolve the loss of separation.
note that autoresolver typically generates multiple successful resolutions for each test case.
among these resolutions autoresolver selects a single one to be executed executed resolutions .
the table reports the types of executed resolutions and the percentage of test cases in the suite where they occur.
finally we report the number of unique combinations of successful resolutions see section .
unsurprisingly testgen generates much larger test suites than jdart since it is cheap fast and unsophisticated it does not explicitly target coverage and does not attempt to generate minimal test suites.
each testgen test suite upper part of table includes unique successful resolutions.
temporary speed maneuvers are only successful incruise test cases.
this maneuver became possible for this scenario when we exposed as a parameter the o set in time with which the airplanes arrive at the point of loss of separation.
larger o sets in combination with a temporary change in airspeed lead to both airplanes passing this point with enough space to ensure separation.
temporary altitude and extend altitude maneuvers are only successful inclimb scenarios since they do not apply to airplanes in cruise ight.
finally direct to maneuvers are only successful in turn where the angle formed in the trajectory by 380table test execution times and branch coverage for a total of branches.
scenariono.
of execution branch coverage tests cruise .
climb .
turn .
alt .
level off .
head .
the change of heading can be shortcut by omitting a point in the future route.
the test cases generated with jdart for the restricted scenarios cover only a subset of the successful resolutions executed resolutions and unique combinations covered by the corresponding testgen generated tests for the more general scenarios.
finally table shows execution times and achieved branch coverage for all six test suites.
as can be seen in contrast to the unique combinations coverage the di erence in percentual coverage between the smallest test suites with only three test cases and the larger ones is modest.
this indicates that branch coverage may not be a good metric of behavioral coverage for this application autoresolver tries a limited set of maneuvers with di erent parameters in changing order.
all test cases exercise almost the same set of maneuvers maneuvers are tried to learn that they are not successful .
additional coverage comes from few branches when choosing parameters and rating successful maneuvers.
.
discussion the testing framework that we developed for autoresolver relies on four hypotheses that we assess in this section based on our experimental results.
h1.
theaces stubs a allow for a light weight and targeted approach to testing autoresolver and b are precise enough to yield meaningful results see section .
.
evaluation.
the hypothesis has two parts.
our experiments show that we can run thousands of tests with a high percentage of con icts in minutes.
our environment accepts small approximate test cases as opposed to fully detailed scenarios with thousands of ights not all of which are conicts corresponding to airport data.
the second part namely that our stubs for aces generate trajectories with su cient precision is harder to assess without the help of domain experts.
we tested this hypothesis by logging trajectory and resolution data from test cases and analyzing this data together with the developers ofautoresolver ve trajectories for each of the three scenarios .
by expert judgment our implementation of maneuvers and generation of trajectories is good enough for testing autoresolver without aces.
h2.
scenarios are su ciently complementary and generic to allow for exercising a relevant subset of the behavior in autoresolver see section .
.
evaluation.
to evaluate this hypothesis we compared the coverage contributed by each scenario.
figure visualizes the di erences and overlap in coverage.
it con rms the hypothesis by showing that no scenario completely subsumesanother scenario in terms of coverage.
chart a compares the overlap in unique combinations of successful resolutions for the test suites generated with testgen.
for every pair of scenarios the lined and dotted parts of the bars represent unique combinations that occur only in one scenario while the white area represents the number of unique combinations that are exercised by both scenarios.
as can be seen the overlap between the scenarios is signi cantly smaller than the number of individually covered combinations.
this indicates that each scenario contributes to the overall coverage of autoresolver.
chart b visualizes the overlap in branch coverage in the same fashion.
in this case the overlap between scenarios is signi cant.
as mentioned this indicates that branch coverage may not be a good metric of behavioral coverage for this application.
h3.
the parameterization of scenarios with only a few primitive parameters is su cient for generating test cases of high quality see section .
.
evaluation.
at the current stage we measure quality mainly in terms of coverage mostly concentrating on behavioral coverage at the level of resolutions since this is an important criterion for the autoresolver team.
in the future we plan on extending our work towards evaluating errornding capabilities of generated test cases.
the parameters that we expose control the airplanes in the scenarios and enable us to create test cases that emulate realistic situations.
we checked our results for consistency against the expectations of the developers of autoresolver.
they con rmed for example that step altitude maneuvers are expected to be chosen at a high rate in the cruise scenario as these maneuvers create very little delay.
further evidence that the hypothesis holds is provided by the recorded branch coverage.
we analyzed the coverage for methods in the central classes of autoresolver though branch coverage overall is low for the targeted methods corresponding to maneuvers the coverage is much higher approximately on average .
uncovered branches are mostly related to null checks on method parameters and to parameters of airplanes that we do not currently control in our scenarios e.g.
ags that describe if an airplane can maneuver .
these ags could easily be exposed in additional scenarios.
h4.
the implementation of parameterized scenarios as an interface between the tester and autoresolver tames the input space su ciently to make autoresolver amenable to automated test case generation techniques see section .
.
evaluation.
this hypothesis is con rmed through the mere fact that we were able to generate realistic input trajectories forautoresolver with both black and white box techniques.
moreover the other three established hypotheses speak to the fact that the generated test cases are not only realistic but also useful for exploring the behavioral space of this complicated system.
while we have spent considerable e ort on making jdart robust enough to run on autoresolver i.e.
record and analyze single paths only the restrictions de ned through the scenarios drastically reduced the number of paths to be analyzed.
60crui se turncruise climbturn climb u nique combinationsuni que coverage a ov erlap a b uni que coverage b a 000crui se turncruise climbturn climb co vered branches b figure coverage comparison.
.
related work autoresolver has previously been integrated and evaluated with other national airspace system nas simulations which have non zero trajectory prediction errors .
in contrast to these simulation based approaches we address the problem of test case generation.
the generation of structurally complex inputs is targeted by several researchers.
in a black box setting frameworks like korat and udita support test case generation through declarative speci cations of the test inputs.
in a white box setting sage is a fuzzer for security testing based on concolic execution applied successfully to microsoft systems such as media players and image processors.
in ideas from procedural content generation an automated approach to generating content for computer games are used to generate complex test scenarios.
the generation of method sequences for object oriented systems is another focus of current testing research.
in this context black and white box techniques are combined for the generation of sequences and data values for primitive method parameters respectively .
jpf doop combines the randoop approach of feedback directed random testing with concolic execution jdart to improve code coverage of testing java software components.
garg et al.
take a similar approach but for c c .
mace combines black and white box techniques active automata learning and concolic execution to build an abstract model of an application under test in order to increase code coverage and exploration depth.
mace targets testing of the protocol between a system under test and its environment and as such is not directly applicable to autoresolver .
however our idea of restricting the initial exploration of jdart in order to reach deeper into the autoresolver code is similar in spirit to the mace s approach.
existing test case generation approaches can be added to our testing framework for autoresolver e.g.
plainrandom input generation or evolutionary test case generation which targets large input domains and has been used successfully in industrial applications .
however as already explained it is impossible for any such tools to directly tackle the autoresolver input space.
therefore they would have to be used as prescribed by this paper through our wrapper that tames the input space of the problem.
note that the fact that autoresolver makes heavy use of nonlinear arithmetic and oating point operations presents a major challenge for many existing tools.
finally some works focus on guiding or restricting test case generation by program invariants inferred from executions .
while our lters and input ranges are currently derived manually from expert knowledge it would be interesting to investigate the potential of inferring these from simulations of autoresolver on recorded ight data.
.
conclusions and future work in this paper we described collaborative work of several years between formal methods and domain experts in generating a light weight testing environment for a complex system for separation assurance called autoresolver .
the main challenge of this project has been to nd a way to tame the input space of autoresolver.
we achieved this through the implementation of parameterized scenarios that make the input space amenable to meaningful test case generation.
we developed a modular extensible framework that puts together several tools and techniques for test case generation execution and evaluation.
speci cally we stubbed outaces developed testgen andcovcomp put major e ort into robustifying and adding features to jdart and implemented logging to connect to aacviz used by the autoresolver developers.
our e orts have paid o we have been able to generate thousands of meaningful test cases that run in a matter of minutes.
in the future we plan to extend the currently supported test scenarios introduce secondary aircrafts as well as experiment with new ways of combining our test case generation techniques.
for example our experiments show that when limiting the exploration of the wrapper by jdart the space of behaviors that can be explored can be very narrow unless the jdart seed values are chosen carefully.
it would be interesting to explore an approach where the tests generated by testgen are used to create di erent paths for entering the autoresolver code for subsequent concolic exploration.
finally our experiments have shown that trigonometric constraints still limit the scalability of our concolic approach even though we have made advances in handling them.
for example for the very restricted head scenario where only the heading change of one airplane is explored there are constraints that could not be solved as opposed to and for the other scenarios under the same con guration see table .
we plan to investigate additional techniques for dealing with trigonometric constraints such as using randomized constraint solvers .