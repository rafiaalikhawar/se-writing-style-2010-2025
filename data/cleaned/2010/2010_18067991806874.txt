leakpoint pinpointing the causes of memory leaks james clause college of computing georgia institute of technology clause cc.gatech.edualessandro orso college of computing georgia institute of technology orso cc.gatech.edu abstract most existing leak detection techniques for c and c applications only detect the existence of memory leaks.
they do not provide any help for fixing the underlying memory management errors.
in this paper we present a new technique that not only detects leaks but also points developers to the locations where the underlying errors may be fixed.
our technique tracks pointers to dynamicallyallocated areas of memory and for each memory area records several pieces of relevant information.
this information is used to identify the locations in an execution where memory leaks occur.
to investigate our technique s feasibility and usefulness we developed a prototype tool called leakpoint and used it to perform an empirical evaluation.
the results of this evaluation show that leakpoint detects at least as many leaks as existing tools reports zero false positives and most importantly can be effective at helping developers fix the underlying memory management errors.
categories and subject descriptors d. .
testing and debugging general terms performance reliability keywords leak detection dynamic tainting .
introduction memory leaks are a type of unintended memory consumption that can adversely impact the performance and correctness of an application.
in programs written in languages such as candc memory is allocated using allocation functions such as malloc andnew.
allocation functions reserve a currently free area of memory mand return a pointer pthat points to m s starting address.
typically the program stores and then uses p or another pointer derived from p to interact with m. when mis no longer needed the program should pass pto a deallocation function e.g.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.free ordelete to deallocate m. a leak occurs if due to a memory management error mis not deallocated at the appropriate time.
there are two types of memory leaks lost memory and forgotten memory.
lost memory refers to the situation where mbecomes unreachable i.e.
the program overwrites or loses pand all pointers derived from p without first being deallocated.
forgotten memory refers to the situation where mremains reachable but is not deallocated or accessed in the rest of the execution.
memory leaks are relevant for several reasons.
first they are difficult to detect.
unlike many other types of failures memory leaks do not immediately produce an easily visible symptom e.g.
a crash or the output of a wrong value typically leaks remain unobserved until they consume a large portion of the memory available to a system.
second leaks have the potential to impact not only the application that leaks memory but also every other application running on the same system because the overall amount of memory is limited as the memory usage of a leaking program increases less memory is available to other running applications.
consequently the performance and correctness of every running application can be impacted by a program that leaks memory.
third leaks are common even in mature applications.
for example in the first half of over leaks in the firefox web browser were reported .
because of the serious consequences and common occurrence of memory leaks researchers have created many static and dynamic techniques for detecting them e.g.
.
the adoption of static techniques has been limited by several factors including the lack of scalable precise heap modeling.
dynamic techniques are therefore more widely used in practice.
in general dynamic techniques provide one main piece of information the location in an execution where a leaked area of memory is allocated.
this location is supposed to serve as a starting point for investigating the leak.
however in many situations this information does not provide any insight on where or how to fix the memory management error that causes the leak the allocation location and the location of the memory management error are typically in completely different parts of the application s code.
to address this limitation of existing approaches we propose a new memory leak detection technique.
our technique provides the same information as existing techniques but also identifies the locations in an execution where leaks occur.
in the case of lost memory the location is defined as the point in an execution where the last pointer to an unallocated memory area is lost or overwritten.
in the case of forgotten memory the location is defined as the last point in an execution where a pointer to a leaked area of memory was used e.g.
when it is dereferenced to read or write memory passed as a function argument returned from a function or used as an operand in an arithmetic expression .
as our evaluation shows main openfile initprogram safe mallocreadparfileyset random seed readblck readcellreadnetsfindcostassignroinitialize rowsinitialize costvert statisticsutemp print stats getcompiledate safe freestrcloneparserhashfindconfiguresafe reallocmaketabladdhashconfig1delhtabsortpinshellsortuloop savewolf countfuloop2 finalwiregrdcellreassignfindunlapunlap findfeedsfixwolf add dummy feedsupair align initalignfeedglobeglobroute findrchk mergplistoutpinsoutput yacm randomxpick intucxx2ucxx1uc0rowcon controlfnew oldfind new posold assgnto new2sub penaladd penalterm newposnew dboxaccepttnew assgnto old2dbox pos add cellterm newpos aterm newpos bnew dbox adbox pos 2old assgnto new1new assgnto old1 expected value combinationexpected svaluecompute and combinationpartitioncpu timeconfigureffindcostfprep feed count 1insert rowfeed situationprep feed countinstallfgparserqsortxxcompactqstcomparexprepglobdetfeedimpfiximpclobrucxxp qsortg detgroupsearchgqsorteclosepins comparegqstgchkgroupaddedgecompareeqstechangridreadseg findrcostsafe callocqsortgdxsafe cfreeqstgdxcomparegdxmerge pinsassign group valuesinitialize pinsadd pinsmerge delhtab .
int i .
hashptr hptr zapptr .
for i i i .
hptr hashtab .
if hptr !
hashptr null .
zapptr hptr .
while hptr hnext !
hashptr null .hptr hptr hnext .free zapptr .zapptr hptr .
.
free hptr .
.
.
free hashtab .
return addhash char hname .
int i .
hashptr hptr .
unsigned int hsum .
for i i strlen hname i .
sum unsigned int hname .
.
hsum .
if hptr hashtab hashptr null .
hptr hashtab hashptr malloc sizeof hashbox .
hptr hnext hashptr null .
hptr hnum netctr .
hptr hname char malloc strlen hname sizeof char .
sprintf hptr hname s hname .
return .
else ... .
figure call graph and relevant code for a memory leak found in .twolf.
identifying the locations where leaks occur can accurately guide developers to the points in the code where the memory management errors that cause the leaks may be fixed.
to evaluate the effectiveness of our technique we implemented it in a prototype tool called leakpoint and performed an empirical evaluation on a number of subjects.
as subjects we used applications that contain real memory management errors that cause leaks.
the results of this evaluation show that for the subjects that we considered our technique finds at least as many leaks as existing techniques reports zero false positives and can be effective at guiding developers directly to the locations where the memory management errors may be fixed.
the contributions of this paper are a novel technique that identifies the locations in a program s execution where memory leaks occur.
a prototype tool leakpoint that implements our technique.
an empirical evaluation that shows the effectiveness and usefulness of our technique.
the rest of this paper is organized as follows section presents a motivating example for our technique.
section describes our technique in detail.
section presents our empirical evaluation.
sections and discuss related work and present our conclusions.
.
motiv ating example as a motivating example for our technique we use one of the real leaks that we found in .twolf during our evaluation.
.twolf is a computer aided design program that calculates the routing and placement of transistors for microchip design .
the leak that we are considering occurs when the application is executed using its test input set which is provided with the application.
figure shows the dynamic call graph for this execution top and relevant portions of the application s code displayed as call outs from their respective locations in the call graph bottom .
the plus icon in the right call out indicates the information that most existing leak detection tools provide for this leak thelocation where the leaked memory was allocated.
for this example they would inform a developer that the memory area allocated at line in function addhash is leaked during the execution.
as we mentioned previously in most cases including our example this information does not provide a developer with any guidance or insight on how to fix the error that causes the leak.
the faucet icon in the left call out indicates the additional information that our technique provides the location where the leak occurs.
for this example our technique would inform a developer that the area of memory allocated at line in function addhash is leaked at line in function delhtab.
with this additional information it becomes much simpler to identify the memory management error for this example the error is that the memory area pointed to by hptr at line in function delhtab is deallocated without first deallocating the memory pointed by hptr hname and the modifications that are necessary for fixing the error in this case the necessary modifications consist of inserting an appropriate call to free free hptr hname immediately before line in function delhtab.
in fact using information provided by our tool i.e.
both the location where the leaked memory area is allocated and the location where it is leaked we were able to quickly diagnose and fix this error even though we had never seen .twolf s code before see section .
for details .
this example is a good representative of the type of leak we expect to encounter in practice in real programs.
first it is a real leak that occurs in a released commonly used application.
second it is caused by a common programming error forgetting to deallocate a component of an object before deallocating the object itself.
third its occurrence does not noticeably impact the application even though it leaks memory .twolf runs to completion and produces the correct output.
and fourth the allocation site and the location where the error may be fixed are far apart in the code they are in two separate functions and as the call graph shown in figure illustrates these two functions do not occur near one another in the call graph.
.
leakpoint technique in this section we present our technique for identifying the locations in an execution where leaks occur.
we first provide an intuitive description of the technique and then discuss its main characteristics in detail.
.
general approach our technique for leak detection is based on dynamic tainting or dynamic information flow .
simply stated dynamic tainting is an analysis technique that is concerned with tracking information in an application as the application executes.
intuitively it consists of three parts tainting interesting program data e.g.
variables or memory locations with a taint mark propagatingtaint marks along with their associated data as the program executes and checking which taint marks are associated with program data at specific points in the execution.
specifically our technique uses dynamic tainting to track pointers to dynamically allocated areas of memory as a program executes.
during an execution when an area of memory mis allocated the technique creates a new taint mark tmand uses tm to taint the returned pointer.
the technique stores five additional pieces of information with each taint mark.
collectively we refer to these pieces of information as taint mark metadata.
allocation location the location in the execution where memory area mis allocated.
allocation size the size in bytes of memory area m. deallocated indicator a boolean flag that indicates whether memory area mhas been deallocated.
pointer count the number of pointers that are tainted with tm i.e.
the number of pointers that currently point to m .
last use location the location in the code where a pointer tainted with tmwas last used i.e.
the location where it was last dereferenced to access m passed as a function argument or return value manipulated using an arithmetic or bitwise operator or copied using an assignment operator .
note that the allocation location and allocation size are immutable whereas the deallocation indicator pointer count and last use location are mutable they are updated by the technique as it propagates taint marks see section .
.
while propagating taint marks and updating taint mark metadata during an execution the technique performs two checks.
each check is designed to detect one type of leak.
to detect lost memory each time a pointer tainted with a taint mark tmis lost or overwritten the technique checks whether that pointer was the last pointer tom.
if it was the technique reports the current location in the execution as the location where mis leaked.
to detect forgotten memory at the end of an execution the technique checks which memory areas have not been deallocated.
for each area of memory mthat was not deallocated the technique reports the corresponding taint mark tm s last use location as the location where mis leaked.
in rest of this section we describe in detail the three parts of our technique tainting propagating and checking.
1the current implementation of our technique uses stack traces with line number information to represent location information.
.
tainting this part of our technique is responsible for assigning taint marks to pointers to dynamically allocated memory areas.
to taint such pointers our technique intercepts all calls to allocation functions.
by default the technique intercepts calls to system provided allocation functions i.e.
malloc calloc realloc new and new .
however for some applications only considering these functions limits the technique s ability to detect leaks.
for example this is the case for applications that use memory pools a common approach for avoiding the overhead of dynamic memory allocation.
at a high level a memory pool is a single large dynamicallyallocated memory area that is divided into smaller memory chunks that are managed using custom allocation and deallocation functions.
without considering these custom functions our technique can only check whether the entire memory pool is leaked it cannot check whether any of the chunks of manually managed memory are leaked during an execution.
to support leak detection inside memory pools and handle other similar situations our technique allows developers to indicate which functions in a program should also be considered allocation and deallocation functions.
additional allocation functions must fulfill the same requirements as the system provided allocation functions they must take as input the size of the memory area to allocate and return either a pointer to the allocated area of memory or null if the allocation is unsuccessful.
regardless of whether an allocation function is in the default set or added by a programmer the technique operates in the same way.
when an allocation function successfully allocates an area of memorym i.e.
the return value is not null the technique creates a new taint mark tmand initializes tm s taint mark metadata the allocation location and last use location are initialized to the current location in the execution the allocation size is initialized to the size passed as a parameter to the allocation function the deallocation indicator is set to false and the pointer count is initialized to one to indicate that there is currently a single pointer to m. then the technique taints the pointer that is returned by the allocation function with tm.
.
propagating this part of our technique performs two main tasks tracking pointers throughout an execution and updating taint mark metadata.
we describe each of these tasks in the following subsections.
.
.
tracking pointers the first task of the propagation part is to track the flow of pointers through an execution by propagating taint marks.
in order to correctly propagate taint marks our technique must use a propagation policy that correctly models all operations that can be performed on pointers.
in many situations creating such a model is challenging because of the ambiguity between pointers and integers depending on the context in which an operator is used the result of an operation may be either a pointer or an integer.
the propagation policy that our technique uses is the result of combining information about the semantics of c and c and knowledge of and intuition about the common usage of operators.
we present our technique s propagation policy by discussing how it models each operator.
arithmetic operators.
assignment c a in the case of an assignment the left hand side is simply tainted with the same taint mark that is associated 517with the right hand side.
if ais tainted cis tainted with the same taint mark whereas if ais not tainted cis not tainted.
addition c a b in the case of addition we consider four different cases depending on the taint marks associated with the operands that are being added.
c a b tm tm tm tm tm tn each of the four cases is shown in the above table.
the first and second rows illustrate how the propagation policy models situations where a numeric offset not tainted is added to a pointer to an area of memory m tainted with tm .
in this situation the most likely result of the addition is a pointer that points inside memory area m e.g.
when an offset is added to pointer to index into a dynamically allocated array .
therefore the result is tainted with tm.
the third and fourth rows illustrate how the propagation policy models situations where two pointers tainted with tmandtn respectively or two non pointers not tainted are added.
in both of these situations it is unlikely that the result of the addition is a pointer and the result is therefore not tainted.
subtraction c a b subtraction is handled in a manner similar to addition and also involves four cases.
c a b tm tm tn tm tn the first row in the above table illustrates how the propagation policy models situations where a numeric offset not tainted is subtracted from a pointer to an area of memory m tainted with tm .
like for addition in this situation the most likely result of the subtraction is a pointer that points inside memory area m. therefore the result is tainted with tm.
unlike addition however subtraction is not commutative a pointer subtracted from a numeric offset is most likely not a pointer.
this situation is illustrated in the second row in the table the result of subtracting a tainted operand from a non tainted operand is not tainted.
the remaining two cases shown in the third and fourth rows are again similar to addition.
the result of subtracting two pointers or two non pointers is most likely not a pointer and therefore is not tainted.
multiplication division modulus we could not identify any situation where the result of these operators should be considered a pointer.
therefore regardless of the taint marks associated with the operands the result of these operations is never tainted.
bitwise operators.
and c a b bitwise and is also handled similarly to addition and involves the same four cases.
c a b tm tm tm tm tm tn the first and second rows in the above table illustrate how the propagation policy handles situations where a numeric offset not tainted is anded with a pointer tainted with tm .
although this situation is not common it does occur in certain cases such as when byte aligning dynamically allocated memory i.e.
ensuringthat the starting address of a memory area is a multiple of a given size .
this case is conceptually similar to indexing into an array by adding an offset to a pointer the result is a pointer to the same area of memory that the pointer operand points to.
therefore in this situation the result is tainted with tm.
the third and fourth rows illustrate how the propagation policy models situations where two pointers or two non pointers are anded together again the result is most likely not a pointer and therefore is not tainted.
or xor shift not similar to multiplication division and modulus we could not identify any situation where the result of these operators should be considered a pointer.
therefore regardless of the taint marks associated with operands the result of these operations is never tainted.
comparison operators less than greater than less than or equal to greater than or equal to equal to not equal to and or not the result of these operators is never a pointer and therefore is never tainted.
as we mentioned previously accurately modeling operators that operate on pointers is challenging as it is possible for developers to use any operator in creative and inventive ways.
therefore it is unlikely that a propagation policy can be proven to be sound and complete.
as far as our policy is concerned as stated previously we defined it based on domain knowledge and on experience and we verified that it works correctly for all of the software that we studied so far as discussed in section .
if additional experimentation would reveal shortcomings of our propagation policy we will refine it accordingly.
.
.
updating information the second task of the propagation part of our technique is to update the mutable pieces of taint mark metadata pointer counts deallocation indicators and last use locations.
we describe how our technique updates each piece of information separately.
to correctly update pointer counts the technique must handle assignments function returns and deallocations of dynamicallyallocated memory areas.
assignment operator to handle the assignment operator the technique performs two actions in addition to propagating taint marks.
for an assignment statement c a the technique first checks whether cis currently tainted.
if cis tainted with a taint mark tm the technique decrements tm s pointer count because a pointer to memory area mis being overwritten.
then as previously described the technique assigns the taint mark associated with a if any to c. finally it checks whether cis tainted after the propagation.
if cis tainted with taint mark tn the technique increments tn s pointer count because a new pointer to memory area nwas created as a result of the assignment.
function return our technique intercepts all function return events.
for each of the returning function s local variables the technique checks whether the variable is a pointer i.e.
whether it is tainted .
if it is the technique decrements the pointer count stored in the taint mark associated with the local variable.
the pointer count is decremented because after the function returns the local variable is no longer in scope and cannot be accessed by the program.
deallocation of dynamically allocated memory dynamically allocated memory is deallocated using an explicit call to a deallocation function i.e.
free delete delete which takes as a parameter a pointer to the area of memory that should be deallocated.
programmer defined deallocation functions are supported in the same manner as programmer defined allocation functions 518see section .
.
the technique intercepts deallocation functions and identifies the taint mark tmthat is associated with the pointer passed to the deallocation function.
it then searches memory area m checking whether mcontains any pointers.
for each pointer p that it finds the technique decrements the pointer count of the taint mark associated with p. this handles situations where memory is indirectly leaked i.e.
the only pointer to memory area nis stored inside memory area mand when mis deallocated nis leaked .
updating deallocation indicators and last use locations is simpler than updating the pointer counts.
to update deallocation indicators the technique again intercepts deallocation functions identifies the taint mark associated with the pointer that is passed to the function and sets the taint mark s deallocation indicator to true.
to update last use locations the technique sets the last use location of a taint mark tmto the current location in the execution each time a pointer tainted with tmis propagated as described in section .
.
passed as a function argument returned from a function or used to access memory area m. .
checking this third and last part of our technique checking is also responsible for two tasks identifying when leaks occur and generating the leak reports presented to developers.
leak reports comprise three pieces of information the location where the leaked area of memory was allocated the location where the leak occurred and the size of the leaked memory area.
presenting the sizes of leaked memory areas does not necessary help developers identify the locations where the memory management errors may be fixed but it does provide a mechanism for judging the relative severity of a particular memory leak.
typically leaks of larger areas of memory should be investigated before leaks of smaller areas.
to identify when memory leaks occur our technique performs two checks one to detect lost memory and the other to detect forgotten memory.
to detect lost memory the technique uses pointer counts.
each time the pointer count of a taint mark tmis decremented the technique checks whether the count s value after the decrement is zero.
if the count is zero and tm s deallocation indicator is false the technique classifies mas lost memory and generates a lost memory leak report.
the report s allocation location and size information are initialized to the allocation location and the allocation size stored in taint mark tm respectively.
the leak location is initialized to the current location in the execution.
after generating the report the technique deallocates memory area m. this causes the technique s deallocation of dynamically allocated memory handler described in section .
.
to update the pointer count of any taint marks associated with pointers stored inside m. the recursive interaction of these two parts of the technique allows it to detect indirect leaks that are caused by the leaking of m. the check used to detect forgotten memory is performed at the end of an execution.
the technique first identifies all taint marks whose deallocation indicator is set to false because the deallocation indicator gets set when memory areas are deallocated each taint mark with a false deallocation indicator corresponds to an area of memory that has not been deallocated.
the technique classifies each such area of memory mas forgotten memory and generates a forgotten memory leak report.
like for lost memory leak reports the allocation location and size for forgotten memory leak reports are initialized to the corresponding taint mark tm s allocation location and allocation size.
however unlike for lost memory leak reports the leak location is set to tm s last use location.
because programs often repeat sequences of calculations it is possible for multiple leak reports to have both the same allocation location and the same leak location.
therefore to avoid over whelming developers with identical leak reports reports that have the same allocation location and the same leak location are merged.
the allocation location and leak location of the merged report are the same as its component reports while the merged report s size is the sum of the sizes in the component reports.
furthermore our technique sorts leak reports by two criteria type lost memory leak reports are presented before forgotten memory leak reports and size leak reports for larger areas of memory are presented before leak reports for smaller areas of memory .
it is worth noting that although our technique is currently defined to generate leak reports when memory leaks are detected it can be easily modified to support other actions.
for example when detecting a leak the technique could attach a debugger to the running program or it could terminate the execution.
it is also possible to support more complex actions such as only generating leak reports after a specified amount of memory is leaked.
the specific action chosen may depend on the context or on the goals of the developers who are using the technique.
.
empirical ev aluation to assess the effectiveness and usefulness of our technique we implemented it in a prototype tool called leakpoint and investigated the following research questions rq1 how does leakpoint s ability to detect memory leaks compare to existing leak detection tools?
rq2 how effective is leakpoint at guiding developers to the locations where the memory management errors that cause memory leaks may be fixed?
note that although by definition our technique should be able to detect all leaks rq1 is a relevant research question the difficulties of tracking pointers that we describe in section .
.
may cause leakpoint to miss some leaks or report spurious ones.
comparing leakpoint against existing tools can provide a better understanding of how our technique will perform in practice and provides evidence that the technique s propagation policy is accurate.
in the following subsections we discuss leakpoint our subjects and our experimental protocol and results for each research question.
we also present a small case study in which we investigated the performance of leakpoint in terms of the runtime overhead that it imposes on running applications.
.
prototype tool leakpoint is a prototype implementation of our technique for linux x86 binaries that is built as a valgrind tool.
valgrind is a generic binary instrumenter that is optimized to support heavyweight dynamic analyses .
we chose to use valgrind because it operates at the binary level which allows our technique to easily handle shared libraries.
source level techniques would require recompilation of every library an application may use a task that may be difficult or even impossible i.e.
if source code is unavailable .
moreover valgrind abstracts away much of the complexity of the underlying operating system and architecture.
this means that leakpoint can easily support multiple operating system and architecture combinations i.e.
linux on x86 amd64 ppc32 and ppc64 and darwin mac os x on x86 with limited additional implementation effort.
we leverage valgrind s built in functionality to implement the three parts of our technique.
to taint pointers to dynamicallyallocated areas of memory we use valgrind s function interception capabilities which allow us to intercept all calls to allocation and deallocation functions.
to implement taint mark propagation and 519subject description loc detected memory leaks false positives mtrace omega memcheck leakpoint lost forgotten total lost forgotten total .gzip compression .vpr fpga circuit placement .gcc compiler .mcf vehicle scheduling .crafty chess .parser word processing .eon computer visualization .perlbmk programming language .gap group theory .vortex database .bzip2 compression .twolf computer aided design table applications in the first set of subjects and results for rq1.
subject description loc errors gcc .
compiler lighttpd .
.
web server transmission .
bittorrent client table applications in the second set of subjects.
checking we created a set of functions one for each instruction in valgrind s intermediate representation.
these functions model the semantics of the instructions and implement the appropriate propagation and checking functionality.
we use valgrind s instrumentation capabilities to insert a call to the appropriate function before each instruction.
finally we developed a client api for supporting custom memory management functions described in section .
.
to use this api developers insert calls in their code that inform leakpoint when memory areas are allocated and deallocated by their custom routines.
however to remove a potential source of bias we did not use any of these functions in our evaluation.
.
subjects in our empirical evaluation we used two sets of subjects.
the first set consists of the twelve applications from the integer portion of the spec cpu2000 benchmark suite version .
.
table lists these applications and shows for each application a brief description of the application s functionality description and size in lines of code loc .
we chose these applications for several reasons.
first they cover a wide range of problem domains and range in size from .5k loc .mcf to 129k loc .gcc .
second they contain numerous memory management errors which means that they are good subjects for investigating rq1.
and third the spec benchmarks were designed to evaluate performance so the applications are also appropriate subjects for investigating the runtime overhead imposed by leakpoint .
the spec benchmarks are also distributed with several sets of inputs which we used when running the applications.
thesecond set consists of applications that contain documented memory management errors that were fixed by the application s original developers.
because we need documentation of how the leaks were fixed we were unable to reuse subjects from related work.
the subjects that they used were either proprietary e.g.
or did not have a record of how the leaks were fixed e.g.
.
to select subjects that meet this requirement we surveyed on line bug databases and issue trackers for large commonly used applications.
although leaks are common they are often difficult and time consuming to reproduce based solely on information provided in bug reports.
in fact none of the bug reports we encountered in our survey provided correct detailed steps on how to reproducethe leak at best they provided a general description of the necessary conditions for the leak to occur.
as subjects we chose the applications which contain the first four leaks that we were able to reproduce successfully gcc version .
which contains one memory management error note that this version is different from the one that is included in the spec benchmarks 2lighttpd version .
.
which contains two memory management errors andtransmission version .
which contains one memory management error.5information about these applications is shown in table .
this second set of applications is ideal for investigating rq2.
the fact that the memory management errors were fixed by the original developers means that we can assess in an unbiased way how effective leakpoint is at identifying the locations where the memory management errors may be fixed.
.
rq1 to gather the necessary data for investigating rq1 we used the twelve applications from our first set of subjects.
we ran each application using its test input set and checked them for leaks using leakpoint and three other leak detection tools mtrace memcheck and omega .
we chose these tools because they are freely available and are widely used.
memcheck and mtrace only detect memory leaks while omega provides information that is similar to what is provided by our technique.
additional information about the techniques these tools use for detecting leaks is presented in section .
for each leak report generated by each tool we manually verified whether it corresponds to an actual leak or is a false positive.
table shows for each subject the number of leak reports generated by each tool which correspond to actual leaks and in parentheses the number of leak reports that are false positives.
to eliminate clutter in the table false positive counts of zero are not shown.
for leakpoint andmemcheck the table also shows how many of the leak reports are for lost memory and how many are for forgotten memory.
we are unable to provide this information for mtrace oromega because mtrace does not distinguish between the two types of leaks and omega only detects lost memory.
we are also unable to determine if there are any false negatives because the total number of leaks in a program is generally unknown.
as the table shows leakpoint memcheck and mtrace report zero false positives and detect an identical number of leaks 520for all subjects except .perlbmk for which mtrace reports fewer leaks.
this difference is due to the fact that mtrace fails to record a large number of calls to malloc that allocate memory that is subsequently leaked.
these calls are not intercepted because mtrace uses malloc hooks which are known to be unreliable.
in fact malloc hooks and presumably mtrace will be removed from future versions of the gnu c library.
the result that leakpoint andmemcheck have the same performance is not unexpected memcheck is a widely used and thus extensively tested tool and it would be surprising if leakpoint were able to detect more leaks than memcheck can detect.
this is an important result nevertheless as it provides strong evidence that our technique is as effective as existing tools in identifying memory leaks while potentially providing more beneficial information for developers.
in addition the result is a sanity check on the correct implementation of leakpoint .
the table also shows that leak point outperforms omega in several ways.
first as we mentioned previously omega is unable to detect forgotten memory.
as the table shows forgotten memory is common and not handling it may cause a large number of leaks to go undetected.
second unlike leakpoint omega generates false positives for three of the subjects.
these drawbacks reduce omega s effectiveness and limit its usefulness in practice.
like any empirical evaluation our investigation of rq1 is limited in scope and its results may not generalize.
however our subjects are real programs that span a wide range of application types and contain actual leaks.
therefore although further evaluation is needed we believe that our results are promising.
they show that leakpoint is likely to be as effective at detecting leaks as tools that focus only on leak detection and more effective than existing tools that provide the same type of information as our technique.
.
rq2 to gather the data necessary for investigating rq2 we ran each application from our second set of subjects while checking them for leaks using leakpoint .
as an initial metric for judging the effectiveness of the technique when helping developers fix memory management errors we compared the location of the leak reported byleakpoint against the location where the memory management error was fixed.
in future work we plan on performing userstudies to better assess the performance of our technique in a fully realistic setting.
the remainder of this section presents a detailed discussion of the technique s performance when using our initial metric for each of the considered errors.
figure 2a shows the relevant portion of code for the error in gcc.
memory allocated at line in function push string is leaked when gcc s type verifier switches from an inner context to an outer context.
the leak occurs at line where spelling base is overwritten but the memory area it points to is not deallocated.
the commented code in the figure shows the code that was added by the developers to fix this error a call to free was added at line to deallocate the memory area before spelling base is overwritten.
leakpoint identifies line as the location where the leak occurs.
this location is close to the location where the memory management error was fixed by the developers it is in the same function and less than lines away.
moreover the error could indeed be fixed by adding the call to free directly before line .
the reason why the developers chose to place the call at line instead is most likely because lines msg00108.htmlare conceptually an atomic region of code together they restore values stored inside the structure pointed to by p. the first error in lighttpd causes a memory leak if the option url.rewrite repeat is set in the web server s configuration file.
figure 2b shows the relevant portion of lighttpd s code.
memory allocated at line in mod rewrite uri handler is leaked if this section of code is executed twice.
in the first execution the only pointer to the allocated memory area is stored in the plugin context array at line .
during the second execution this pointer is overwritten and because the area of memory it points to is not deallocated a leak occurs.
as in figure 2a the commented lines in figure 2b show the code that was added by the developers to fix this memory management error the code now checks whether memory was already allocated.
leakpoint identifies line as the location where the leak occurs.
this location is even closer to the location where the memory management error was fixed than in the previous case the two locations actually overlap.
the second error in lighttpd causes a leak when the web server parses a request with duplicated http headers.
figure 2c shows the relevant portion of lighttpd s code for discussing this error.
memory allocated at line in http request parse is leaked because the function returns without deallocating it.
to fix this error the developers inserted the commented code at line .
because lighttpd is concerned with performance it maintains a list of allocated request headers that it reuses to save the overhead of memory allocation.
the inserted call fixes the error by adding the allocated memory area to the pool of request headers.
leak point identifies line as the location where the leak occurs.
like for the first leak in lighttpd leakpoint precisely identifies the location where the memory management error was fixed the location of the fix is immediately before the location identified byleakpoint .
figure 2d shows the relevant portion of code for the error in transmission.
this error causes memory allocated at line ininvokerequest to be leaked when the download of the corresponding torrent file is stopped.
the developers fixed this error by inserting a call to a deallocation function at line in onstoppedresponse which is called at line in processcompletedtasks.
leakpoint identifies line in processcompletetasks as the location where the leak occurs.
also in this case the location identified by leakpoint is near the location where the memory management error was fixed.
although the locations are in separate functions they are executed in close proximity to each other only statements apart.
moreover we verified that the memory management error can also be fixed by moving the call to the deallocation function immediately before line in processcompletedtasks.
to gather further evidence of the technique s effectiveness we also examined the leak reports generated by leakpoint for rq1.
because we do not have a developer provided fix for these leaks we cannot perform the same evaluation that we performed for the four leaks described above.
instead for each detected leak we investigated whether the reported location was a suitable point for fixing the leak by inserting a memory deallocation statement at the location indicated by leakpoint and rerunning the application to verify that the leak no longer occurs.
the results for these additional leaks although anecdotal in nature were encouraging all of the locations reported by leakpoint proved to be appropriate locations for introducing fixes to the memory errors i.e.
adding a deallocation statement at the reported location prevented the leak from occurring .
based on these results we can make some initial observations about the effectiveness of our technique in helping developers un521 void finish init ... .
free spelling base .
constructor decl p decl ... .
spelling base p spelling base ... static struct spelling spelling base static void push string char string ... .
spelling base xmalloc spelling size sizeof struct spelling ... a relevant code for the error in gcc.
urihandler func mod rewrite uri handler ... .
if con plugin ctx null .
hctx handler ctx init .
con plugin ctx hctx .
else .
hctx con plugin ctx .
... b relevant code for the first error in lighttpd.
int http request parse server srv connection con ... .
if null ds data string array get unused element con request.headers type string .
ds data string init ... .
else if cmp cmp buffer caseless compare const buf len ds key const str len content length .
char err815.
unsigned long int r .
size t j817.
if con length set .
con http status .
con keep alive .
if srv srvconf.log request header on error .
log error write srv file line s duplicate ... .
log error write srv file line sb request header n con request.request .
.
array insert unique con request.headers data unset ds .
return ... c relevant code for the second error in lighttpd.
void tr webrun tr session session ... void done func user data .
struct tr web task task ... .
task done func user data done func user data ... .
tr runineventthread session addtask task ... static void onstoppedresponse tr session session ... void torrent hash .
dbgmsg null got a response ... message .
tr free torrent hash .
onreqdone session static void processcompletedtasks tr web web ... .
task done func web session ... task done func user data ... .
evbuffer free task response .
tr free task url .
tr free task ... static void invokerequest void vreq ... .
hash tr new0 uint8 t sha digest length .
memcpy hash req torrent hash sha digest length .
tr webrun req session req url req done func hash .
freerequest req d relevant code for the error in transmission.
figure excerpts of code that illustrate our technique s ability to guide developers to the locations where memory leaks may be fixed.
522derstand and eliminate leaks.
for the four leaks with developer provided solutions the location of each leak identified by leakpoint was close to if not coinciding with the location where the memory management error was fixed.
and for the leak reports without developer provided solutions adding deallocation statements at the identified locations fixed the considered leaks.
these results albeit preliminary in nature strongly suggest that our technique can be effective in guiding developers to the locations where the memory management errors that cause leaks may be fixed.
.
runtime overhead to investigate the runtime overhead that leakpoint imposes we used the twelve applications from our first set of subjects.
we ran each application using its reference input set twice once normally and once while checking for leaks using leakpoint and compared the execution times of these runs.
based on these measurements we found that leakpoint imposes a runtime overhead of100 times.
although this is a considerable overhead it is comparable to the times reported by tools that provide the same type of information as our approach .
identifying the locations of leaks is inherently expensive because it requires adding instrumentation for nearly every instruction.
however we believe that the detailed information provided by our technique justifies its cost.
in our experience developers will accept high overheads for tools that produce accurate results.
this is especially true when as is the case for leakpoint the tools do not require any developer interaction and can be run overnight possibly as part of an automated build system whose results are inspected by developers the next day.
in addition there are several possibilities for reducing leakpoint s overhead that we plan on investigating.
first leakpoint is an unoptimized prototype.
it may be possible to reduce its overhead by applying some recently described optimizations for tainting based approaches .
second it is also possible to reduce leakpoint s overhead by using a twophase approach.
in the first phase the technique could perform a lightweight leak detection that simply identifies the location of memory allocations that are leaked like most existing approaches do .
in the second phase it could use the fully fledged approach to monitor only such allocations rather than every allocation in the program.
such an approach could potentially decrease the overhead imposed by the technique dramatically while still providing developers with information that guides them to the locations where the memory management errors may be fixed.
.
related work as we mentioned in the introduction the common occurrence and serious consequences of memory leaks have resulted in a large body of research describing techniques for detecting them.
in this section due to space considerations we limit our discussion to the most closely related dynamic techniques for c c applications.
valgrind s memcheck tool mac os x s leaks tool andpurify operate at the binary level and use an approach inspired by mark and sweep garbage collection.
during a program s execution these tools track memory allocation and deallocation and record the starting address and size of every allocated block of memory.
to detect leaks they scan the application s heap looking for pointers to allocated memory blocks.
the scan classifies blocks into three categories non leaked pointers to the start of the block exist possibly leaked only pointers to the interior of the block exist and leaked no pointers to the block exist .
unlike our technique these tools do not provide any assistance in identifying the location where the underlying memory management errors could be fixed.the gnu c library provides a facility for debugging memory allocations that is commonly known as mtrace .
this approach intercepts calls to malloc realloc and free and logs allocation and deallocation events.
the logged events are then postprocessed to match allocations with deallocations and reveal any allocations without a corresponding deallocation.
because mtrace only observes allocations and deallocations it is also incapable of providing any information beyond the location where the leaked memory is allocated.
parasoft s insure tool uses a source level technique that identifies the locations in an application where pointers are lost or overwritten due to an assignment statement or function return .
at runtime each time one of these locations is executed the tool uses the same mark and sweep approach that memcheck leaks andpurify use to identify leaks.
this approach allows insure to provide information that is similar to what our technique provides.
however like omega it cannot detect forgotten memory.
also because insure does not handle shared libraries it is unable to identify memory leaks that originate or occur inside them i.e.
when memory is allocated or leaked within a shared library .
we were unable to directly compare leakpoint against insure because parasoft did not respond to our request for an evaluation copy of insure .
the technique proposed by maebe and colleagues and independently implemented by meredith in the omega tool which we compared against leakpoint in section .
is most similar to our approach.
their technique also maintains a pointer count for each area of allocated memory but instead of tracking the flow of pointers it intercepts all writes to memory.
each time a value v is written to memory area m vand the content of mare checked to see whether they are pointers.
a value is considered to be a pointer if it is equal to the starting address of one of the currently allocated areas of memory.
if the contents of mare considered to be a pointer the pointer s count is decremented and a leak report is generated if the count is zero.
if vis considered to be a pointer then its count is incremented.
unlike leakpoint which accurately tracks pointers using its propagation policy maebe and colleagues technique uses a heuristic approach to identify pointers.
consequently their technique can generate both false positives as demonstrated in section .
and false negatives .
moreover the combination of using a heuristic and only considering memory writes can also lead to inaccuracies in identifying the locations where leaks occur.
for example when run on the memory management error in gcc presented in section .
omega identifies line6998 in function cse insn as the location where the error should be fixed.
this location is very far from the location where the actual fix was made they are in separate functions and different files.
most importantly we were unable to prevent this leak by adding a deallocation statement at the identified location.
finally as we mentioned in section .
maebe and colleagues technique does not detect forgotten memory.
hauswirth and chilimbi developed a statistical leak detection technique called swat .swat is similar to maebe and colleagues technique in that it examines memory accesses and uses a heuristic to identify pointers.
however unlike their technique swat samples accesses and uses a user provided timeout value to detect leaks if an area of memory is currently allocated and has not been touched by an observed memory access within the length of the timeout a leak is reported.
sampling greatly reduces the overhead of the technique and allows it to be used on live applications which is a significant benefit.
however sampling also increases the number of false positives generated by the approach.
when run on the applications in our first set of studies hauswirth and chilimbi 523report that the false positive rate depending on the sampling rate ranges from 3to35 .
in comparison leakpoint reports zero false positives for these subjects.
sampling can also exacerbate the inaccuracies caused by using a heuristic and by only considering memory accesses when identifying the locations where leaks occur i.e.
memory accesses that are not observed will not update the accessed memory s last use location .
we could not directly compare leakpoint against swat because swat is not publicly available.
.
conclusions in this paper we presented a novel leak detection technique that not only detects leaks but also identifies the locations in an execution where leaks occur.
our approach uses taint marks to identify and maintain information about pointers to dynamically allocated areas of memory.
taint marks are propagated as an application executes and are checked to identify the locations where leaks occur.
the identified locations are then presented to developers as locations where the memory management errors that cause the detected leaks may be fixed.
we also presented leakpoint a prototype tool that implements our technique.
in the evaluation of our technique we used leak point to detect memory leaks in programs from the spec benchmarks as well as several real world applications.
the results of the evaluation show that for the subjects that we considered leak point detects at least as many memory leaks as existing tools reports zero false positives and can be effective at helping developers understand and fix memory errors.