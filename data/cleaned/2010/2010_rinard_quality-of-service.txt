mit open access articles quality of service profiling the mit faculty has made this article openly available.
please share how this access benefits you.
your story matters.
citation misailovic sasa et al.
quality of service profiling.
in proceedings of the 32nd acm ieee international conference on software engineering icse may cape town south africa acm .
as published publisher association for computing machinery persistent url version author s final manuscript final author s manuscript post peer review without publisher s formatting or copy editing terms of use creative commons attribution noncommercial share alike .
quality of service profiling sasa misailovic mit csail misailo csail.mit.edustelios sidiroglou mit csail stelios csail.mit.eduhenry hoffmann mit csail hank csail.mit.edu martin rinard mit csail rinard csail.mit.edu abstract many computations exhibit a trade o between execution time and quality of service.
a video encoder for example can often encode frames more quickly if it is given the freedom to produce slightly lower quality video.
a developer attempting to optimize such computations must navigate a complex trade o space to nd optimizations that appropriately balance quality of service and performance.
we present a new quality of service pro ler that is designed to help developers identify promising optimization opportunities in such computations.
in contrast to standard pro lers which simply identify time consuming parts of the computation a quality of service pro ler is designed to identify subcomputations that can be replaced with new and potentially less accurate subcomputations that deliver signi cantly increased performance in return for acceptably small quality of service losses.
our quality of service pro ler uses loop perforation which transforms loops to perform fewer iterations than the original loop to obtain implementations that occupy di erent points in the performance quality of service trade o space.
the rationale is that optimizable computations often contain loops that perform extra iterations and that removing iterations then observing the resulting e ect on the quality of service is an e ective way to identify such optimizable subcomputations.
our experimental results from applying our implemented quality of service pro ler to a challenging set of benchmark applications show that it can enable developers to identify promising optimization opportunities and deliver successful optimizations that substantially increase the performance with only small quality of service losses.
categories and subject descriptors d. .
metrics performance general terms performance experimentation measurement permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.keywords pro ling loop perforation quality of service .
introduction performance optimization has been an important software engineering activity for decades.
the standard approach typically involves the use of pro lers for example gprof to obtain insight into where the program spends its time.
armed with this insight developers can then focus their optimization e orts on the parts of the program that o er the most potential for execution time reductions.
in recent years a new dimension in performance optimization has emerged many modern computations such as information retrieval computations and computations that manipulate sensory data such as video images and audio exhibit a trade o between execution time and quality of service.
lossy video encoders for example can often produce encoded video frames faster if the constraints on the quality of the encoded video are relaxed .
developers of such computations must navigate a more complex optimization space.
instead of simply focusing on replacing ine cient subcomputations with more e cient subcomputations that produce the same result they must instead consider a potentially much broader range of subcomputations that increase performance may produce a di erent result but still maintain acceptable quality of service.
for such developers existing pro lers address only one side the performance side of the trade o .
they provide no insight into the quality of service implications of modifying computationally expensive subcomputations.
to effectively develop computations with an appropriate trade o between performance and quality of service developers need new pro lers that can provide insight into both sides of the trade o .
.
quality of service profiling the goal of quality of service pro ling is to provide information that can help developers identify forgiving subcomputations i.e.
subcomputations that can be replaced with di erent and potentially less accurate subcomputations that deliver increased performance in return for acceptable quality of service losses.
note that a necessary prerequisite for quality of service pro ling is the availability of multiple implementations with di erent performance and quality of service characteristics of the same subcomputation.
we present a technique loop perforation and an associated pro ler that is designed to give developers insight intothe performance versus quality of service trade o space of a given application.
loop perforation automatically generates multiple implementations with di erent performance and quality of service characteristics of a given subcomputation.
the pro ling tool leverages the availability of these multiple implementations to explore a range of implementation strategies and generate tables that summarize the results of this exploration.
the goal is to help developers focus their optimization e orts on subcomputations that do not just consume a signi cant amount of the computation time but also o er demonstrated potential for signi cant performance increases in combination with acceptable quality of service losses.
.
.
loop perforation given a loop loop perforation transforms the loop so that it performs fewer iterations for example the perforated loop may simply execute every other iteration of the original loop .
because the perforated loop executes fewer iterations it typically performs less computational work which may in turn improve the overall performance of the computation.
however the perforated loop may also produce a di erent result than the original loop which may in turn reduce the computation s quality of service.
an appropriate analysis of the e ect of loop perforation can therefore help the developer identify subcomputations that can be replaced with less computationally expensive and potentially less accurate subcomputations while still preserving an acceptable quality of service.
the rationale behind the use of loop perforation to identify promising optimization opportunities is that many successful optimizations target partially redundant subcomputations.
because this partial redundancy often manifests itself as extra loop iterations one way to nd such subcomputations is to nd loops that the pro ler can perforate with only small quality of service losses.
our experimental results see sections and support this rationale many of the optimization opportunities available in our set of benchmark applications correspond to partially redundant subcomputations realized as loops in heuristic searches of complex search spaces.
our results indicate that quality of service pro ling with loop perforation is an e ective way to uncover these promising optimization targets.
.
.
quality of service metrics and requirements to quantify the quality of service e ects the pro ler works with a developer provided quality of service metric.
this metric takes an output from the original application a corresponding output from perforated application run on the same input and returns a non negative number that measures how much the output from the perforated application di ers from the output from the original application.
zero indicates no di erence with larger numbers indicating correspondingly larger di erences.
one typical quality of service metric uses the scaled di erence of selected output elds.
another uses the scaled di erence of output quality metrics such as peak signal to noise ratio.
a quality of service requirement is simply a bound on the quality of service metric.
for example if a di erence from the output of the original program is acceptable the appropriate quality of service requirement for a scaled difference metric is .
.
.
individual loop profiling the pro ler starts by characterizing the impact of perforating individual loops on the performance and quality of service.
for each loop in the program that consumes a significant amount of the processing time it generates a version of the program that perforates the loop.
it then runs this perforated version recording the resulting execution time and quality of service metric.
it is possible for the perforation to cause the program to crash or generate clearly unacceptable output.
in this case the pro ler identi es the loop as a critical loop .
loops that are not critical are perforatable .
the developer can use the individual loop pro ling results as presented in the generated pro ling tables see section to obtain insight into potentially fruitful parts of the program to explore for optimizations.
the pro ling tables can also identify parts of the program that show little potential as optimization targets.
.
.
combined loop profiling the pro ler next explores potential interactions between perforated loops.
given a quality of service requirement the pro ler searches the loop perforation space to nd the point that maximizes performance while satisfying the quality of service requirement.
the current algorithm uses a cost bene t analysis of the performance and quality of service trade o to order the loops.
it then successively and cumulatively perforates loops in this order discarding perforations that exceed the quality of service requirement.
the result is a set of loops that when perforated together deliver the required quality of service.
the developer can use the combined loop pro ling results as presented in the generated tables see section to better understand how the interactions both positive and negative between di erent perforated loops a ect the performance and quality of service.
positive interactions can identify opportunities to optimize multiple subcomputations with more performance and less quality of service loss than the individual loop perforation results might indicate.
conversely negative interactions may identify subcomputations that cannot be optimized simultaneously without larger than expected quality of service losses.
.
results and scope we have applied our techniques to a set of applications from the parsec benchmark suite .
this benchmark suite is designed to contain applications representative of modern workloads for the emerging class of multicore computing systems.
our results show that in general loop perforation can increase the performance of these applications on a single benchmark input by a factor of between two or three the perforated applications run between two and three times faster than the original applications while incurring quality of service losses of less than .
our results also indicate that developers can use the pro ling results to develop new alternative subcomputations that deliver signi cantly increased performance with acceptably small quality of service losses.
separation of optimization targets our results show that quality of service pro ling produces a clear separation of optimization targets.
some perforated loops deliver signi cant performance improvements with little quality of service loss.
the subcomputations in which these loops appear are good optimization targets at least one optimization at tempt loop perforation succeeded and the application has demonstrated that it can successfully tolerate the perturbations associated with this optimization attempt.
other potentially more targeted optimization attempts may therefore also succeed.
other perforated loops on the other hand either fail to improve the performance or produce large quality of service losses.
these loops are much less compelling optimization targets because the rst optimization attempt failed indicating that the application may be unable to tolerate perturbations associated with other optimization attempts.
application properties guided by the pro ling results we analyzed the relevant subcomputations to understand how loop perforation was able to obtain such signi cant performance improvements with such small quality of service losses.
in general we found that the successfully perforated loops typically perform at least partially redundant subcomputations in heuristic searches over a complicated search space.
for ve out of seven of our applications the results show that it is possible to obtain a signi cantly more e cient search algorithm that nds a result that is close in quality to the result that the original search algorithm nds.
this analysis clearly indicates that for our set of benchmark applications loops that perform partially redundant computations in heuristic search algorithms are an appropriate optimization target and an optimization target that our pro ler can enable developers to quickly and easily nd .
manual optimization results we also used the proling results to identify optimization opportunities in two parsec applications x264 a video encoder and bodytrack a computer vision application .
guided by the proling results we manually developed alternate implementations of the identi ed subcomputations.
these alternate implementations deliver signi cantly increased performance with small quality of service losses.
scope we note that our overall approach is appropriate for computations with a range of acceptable outputs.
computations such as compilers or databases with hard logical correctness requirements and long dependence chains that run through the entire computation may not be appropriate targets for optimizations that may change the output that the program produces.
.
contributions this paper makes the following contributions quality of service pro ling it introduces the concept of using a quality of service pro ler to help the developer obtain insight into the performance and quality of service implications of optimizing di erent subcomputations.
loop perforation any quality of service pro ler needs a mechanism to obtain alternative subcomputations with a range of performance and quality of service characteristics.
this paper identi es loop perforation as an e ective mechanism for automatically obtaining alternative subcomputations for this purpose.
rationale it explains why loop perforation is an effective mechanism for identifying promising optimization opportunities.
many optimizable subcomputations manifest themselves as loops that perform extra iterations.
eliminating loop iterations in combination with measuring quality of service e ects is an e ective way to nd such subcomputations.
experimental results it presents experimental results that characterize the e ectiveness of quality of service pro ling.
these results use a set of benchmark applications chosen to represent modern workloads for emerging multicore computing platforms.
loop perforation results it presents individual and cumulative loop perforation tables for our benchmark applications.
the information in these tables provides a good separation between optimization targets enabling developers to identify and focus on promising targets while placing a lower priority on less promising targets.
manual optimization results it presents results that illustrate how we were able to use the pro ling results in two manual optimization efforts.
these e orts produced optimized versions of two benchmarks.
these versions combine signi cantly improved performance with small quality of service losses.
unsound program transformations over the last several years the eld has developed a range of unsound program transformations which may change the semantics of the original program in principled ways .
this paper presents yet another useful application of an unsound transformation loop perforation further demonstrating the advantages of this approach.
.
loop perforation we implemented the loop perforation transformation as an llvm compiler pass .
our evaluation focuses on applications written in c and c but because the perforator operates at the level of the llvm bitcode it can perforate applications written in any language or combination of languages for which an llvm front end exists.
the perforator works with any loop that the existing llvm loop canonicalization passes loopsimplify and indvars can convert into the following form for i i b i ... in this form there is an induction variable in the code above i initialized to 0and incremented by 1on every iteration with the loop terminating when the induction variable iexceeds the bound in the code above b .
the class of loops that llvm can convert into this form includes for example forloops that initialize an induction variable to an arbitrary initial value increment or decrement the induction variable by an arbitrary constant value on each iteration and terminate when the induction variable exceeds an arbitrary bound.
the perforation rate r determines the percentage of iterations that the perforated loop skips the loop perforation transformation takes ras a parameter and transforms the loop to skip iterations at that rate.
modulo perforation transforms the loop to perform every nth iteration here the perforation rate is r n n for i i b i n ... our implemented perforator can also apply truncation perforation which skips a contiguous sequence of iterations at either the beginning or the end of the loop or random perforation which randomly skips loop iterations .
the loopperforator takes as input a speci cation of which loops to perforate what kind of perforation to apply modulo truncation or random and the perforation rate r. it produces as output the corresponding perforated program.
all of the experimental results in this paper use modulo perforation with an nof and a perforation rate of1 i.e.
the perforated loop skips half the iterations of the original loop .
.
quality of service metric in general it is possible to use any quality of service metric that given two outputs typically one from the original application and another from the perforated application produces a measure of the di erence between the outputs.
the quality of service metric for our benchmark applications all use a program output abstraction to obtain numbers from the output to compare.
these abstractions typically select important output components or compute a measure such as peak signal to noise ratio of the quality of the output.
the quality of service metric simply computes the relative scaled di erence between the produced numbers.
speci cally we assume the output abstraction produces a sequence of numbers o1 o m. given numbers o1 o m from an unmodi ed execution and numbers o1 omfrom a perforated execution the following quantity d which we call the distortion measures the accuracy of the output from the perforated execution d mmx i oi oi oi the closer the distortion dis to zero the less the perforated execution distorts the output.
by default the distortion equation weighs each component equally but it is possible to modify the equation to weigh some components more heavily than others.
the distortion measures the absolute error that loop perforation or for that matter any other transformation induces.
it is also sometimes useful to consider whether there is any systematic direction to the error.
we use the bias metric to measure any such systematic bias.
if there is a systematic bias it may be possible to compensate for the bias to obtain a more accurate result.
.
profiling results to evaluate the e ectiveness of our approach we apply quality of service pro ling to seven benchmarks chosen from the parsec benchmark suite .
unless otherwise noted the input for the pro ling runs is the simlarge input provided as part of the benchmark suite.
x264.
this media application performs h. encoding on a video stream.
the quality of service metric includes the mean distortion of the peak signal tonoise ratio psnr as measured by the h. reference decoder and the bitrate of the encoded video.
we ran this application on the tractor input from xiph.org available at .
streamcluster.
this data mining application solves the online clustering problem.
the quality of service metric uses the bcubed b3 clustering quality metric .
this clustering metric calculates the homogeneity and completeness of the clustering generated by the application based on external class labels for data points.
the value of the metric ranges from badclustering to excellent clustering .
the quality of service metric itself is calculated as the di erence between the clustering quality of the perforated and original application.
it is possible for the perforated program to perform better than the unmodi ed version in which case the quality of service metric is zero.
for this application the simlarge input contains a uniformly distributed set of points with no clusters.
this input is therefore not representative of production data.
we instead ran streamcluster on the covtype input from the uci machine learning repository .
swaptions.
this nancial analysis application uses monte carlo simulation to solve a partial di erential equation and price a portfolio of swaptions.
the quality of service metric uses the scaled di erence of the swaption prices from the original and perforated applications.
with the simlarge input from the parsec benchmark suite all swaptions have the same value.
to obtain a more realistic computation we changed the input to vary the interest rates of the swaptions.
canneal.
this engineering application uses simulated annealing to minimize the routing cost of microchip design.
the quality of service metric is the scaled difference between the routing costs from the perforated and original versions.
blackscholes.
this nancial analysis application solves a partial di erential equation to compute the price of a portfolio of european options.
the quality of service metric is the scaled di erence of the option prices.
bodytrack.
this computer vision application uses an annealed particle lter to track the movement of a human through a scene.
the quality of service metric uses the relative mean squared error of the series of vectors that the perforated application produces to represent the changing con gurations of the tracked body as compared with the corresponding series of vectors from the original application .
the metric divides the relative mean squared errors by the magnitudes of the corresponding vectors from the original application then computes the mean error for all vectors as the nal quality of service metric.
the simlarge input from the parsec benchmark suite has only four frames.
we therefore used the rst sixty frames from the parsec native input.
these sixty frames contain the four frames from the simlarge input.
ferret.
this search application performs content based similarity search on an image database.
it returns a list of images present in the database whose content is similar to an input image.
the quality of service metric is based on the intersection of the sets returned by the original and perforated versions.
speci cally the quality of service metric is minus the number of images in the intersection divided by the number of images returned by the original version.
in addition to these benchmarks the parsec benchmark suite contains the following benchmarks facesim dedup uidanimate freqmine and vips.
we do not include freqmine and vips because these benchmarks do not successfully compile with the llvm compiler.
we do not include dedup and uidanimate because these applications produce complex binary output les.
because we were unable to decipher the meaning of these les given the time available to us for this purpose we were unable to develop meaningfulquality of service metrics.
we do not include facesim because it does not produce any output at all except timing information .
.
single loop profiling results table presents the results of the single loop pro ling runs.
the rows of the table are grouped by application.
each row of the table presents the results of the pro ling run for a single perforated loop.
the rows are sorted according to the number of instructions executed in the loop in the original unperforated application.1our pro ling runs perforated all loops that account for at least of the executed instructions.
for space reasons we present at most the top eight loops for each application in table .
first column function the rst column contains the name of the function that contains the loop optionally augmented with additional information to identify the speci c loop within the function.
many functions contain a single loop nest with an outer and inner nested loop the loops in such functions are distinguished with the outer and inner labels.
other functions contain multiple loops the loops in such functions are distinguished by presenting the line number of the loop in the le containing the function.
second column instruction the second column presents the percentage of the dynamically executed instructions in the loop for the pro ling run.
note that because of both interprocedural and intraprocedural loop nesting instructions may be counted in the execution of multiple loops.
the percentages may therefore sum to over .
third column quality of service the third column presents the quality of service metric for the run.
recall that a quality of service metric of zero indicates no quality of service loss.
a quality of service metric of .
typically indicates a di erence in the output of the perforated application as compared with the output of the original application.
a dash indicates that the perforated execution either crashed or produced a clearly unacceptable output.
fourth column speedup the fourth and nal column presents the speedup of the perforated application i.e.
the execution time of the perforated application divided by the execution time of the original application.
numbers greater than indicate that the perforated application runs faster than the original numbers less than indicate that the perforated application runs slower than the original.
interpreting the results good candidate subcomputations for manual optimization contain loops with the following three properties the application spends a signi cant amount of time in the loop perforating the loop significantly increases the performance and perforating the loop causes small quality of service losses.
the developer can easily identify such loops by scanning the data in table .
for example and as discussed further in section the pixel satd wxh loops in x264 are promising candidates for optimization because they have all three properties.
the success of the loop perforation optimization provides evidence that the computation is amenable to optimization and that other optimization attempts may also succeed.
1our technique is designed to work with any execution time pro ler.
our pro ling runs use an execution time pro ler that counts the number of times each basic block executes.
this execution time pro ler uses an llvm compiler pass to augment the program with the instrumentation required to count basic block executions.perhaps more importantly the developer can easily reject otherwise promising candidates that fail to satisfy one of the properties.
for example the pixel sub wxh2018 outer loop in x264 would be a reasonable candidate for optimization except for the large quality of service loss that the application su ers when the loop is perforated.
in comparison with a standard pro ler which only provides information about where the application spends its execution time the additional information present in a quality of service pro le can help the developer focus on promising optimization opportunities with demonstrated potential while placing a lower priority on opportunities with more potential obstacles.
.
multiple loop profiling results table presents the pro ling results for the multiple loop pro ling runs.
the quality of service requirement for each application is set to .
which corresponds to a di erence between the outputs from the original and perforated applications .
the rows are grouped by application with each row presenting the pro ling results from augmenting the existing set of perforated loops with the next loop.
the rst column function identi es the loop added to set of perforated loops from the preceding rows.
the next two columns repeat the pro ling results for that loop from the single loop pro ling runs as presented in table .
the nal two columns present the quality of service metric and speedup from the corresponding cumulative pro ling run.
this run perforates all loops from all rows up to and including the current row.
interpreting the results the multiple loop pro ling results identify a group of loops that have demonstrated potential when optimized together.
the lack of negative interactions between the perforated loops in the group indicates that other optimization attempts that target all of the corresponding computations as a group may also succeed.
.
individual application results pro ling results for x264 the single loop pro ling results for x264 indicate that the the top two loops in the table the outer and inner loops from pixel satd wxh are promising optimization candidates these loops account for a signi cant percentage of the executed instructions and perforation delivers a signi cant performance improvement with more than acceptable quality of service loss.
guided by these pro ling results we were able to develop an optimized implementation of the corresponding functionality with even more performance and less quality of service loss than the perforated version see section .
the pro ling results also identify subcomputations that are poor optimization candidates.
perforating the loops in pixel sub wxh2018 for example produces a large quality of service loss for relatively little performance improvement.
perforating the loop in x264 mb analyse inter p8x8 as well as several other loops causes x264 to crash.
the cumulative pro ling results in table highlight these distinctions.
the nal perforated collection of loops contains all of the promising optimization candidates from table and none of the poor optimization candidates.
the cumulative pro ling results also include loops that were not in the top loops from table .
because perforating these loops adds relatively little performance but also relatively little quality of service loss they made it into the cumulative set of perforated loops.x264 function instruction quality of service speedup pixel satd wxh outer .
.
.
pixel satd wxh inner .
.
.
re ne subpel .
.
.
pixel subwxh2018 outer .
x264 mbanalyse inter p8x8 .
pixel subwxh2018 inner .
.
.
pixel avg outer .
.
.
x264 mbanalyse inter p8x16 outer .
streamcluster function instruction quality of service speedup pfl inner .
.
.
pgain .
.
.
dist .
.
.
swaptions with bias correction function instruction quality of service speedup worker .
.
.
hjm swaption blocking outer .
.
.
hjm simpath forward blocking l. .
.
.
hjm simpath forward blocking l. .
.
.
hjm simpath forward blocking l. .
.
.
hjm simpath forward blocking l. .
.
.
hjm simpath forward blocking l. .
.
.
hjm simpath forward blocking l. .
.
.
canneal function instruction quality of service speedup annealer thread run .
.
.
netlist elem swap cost l. .
.
.
netlist elem swap cost l. .
netlist netlist .
.
.
mtrand reload l. .
.
.
netlist elem routing cost given loc l. .
.
.
netlist elem routing cost given loc l. .
mtrand reload l. .
.
.
blackscholes function instruction quality of service speedup main outer .
.
.
main inner .
.
.
bodytrack function instruction quality of service speedup mainpthreads .
.
.
particlefilter update .
.
.
imagemeasurements imageerrorinside outer .
.
.
imagemeasurements imageerrorinside inner .
.
.
imagemeasurements insideerror outer .
.
.
imagemeasurements imageerroredge outer .
.
.
imagemeasurements imageerroredge inner .
.
.
imagemeasurements insideerror inner .
.
.
ferret function instruction quality of service speedup rawquery l. .
emd l. .
.
.
lsh query l. .
.
.
lhs query bootstrap l. .
lhs query bootstrap l. .
.
.
emd l. .
.
.
emd l. .
lsh query bootstrap l. .
table single loop pro ling results.
for quality of service smaller is better.
for speedup larger is better.x264 individual cumulative function quality of service speedup quality of service speedup pixel satd wxh outer .
.
.
.
pixel satd wxh inner .
.
.
.
re ne subpel .
.
.
.
pixel sad8x8 outer .
.
.
.
pixel sad8x8 inner .
.
.
.
x264 mesearch ref .
.
.
.
streamcluster individual cumulative function quality of service speedup quality of service speedup pfl inner .
.
.
.
swaptions with bias correction individual cumulative function quality of service speedup quality of service speedup hjm swaption blocking outer .
.
.
.
hjm swaption blocking middle .
.
.
.
hjm swaption blocking inner .
.
.
.
hjm simpath forward blocking l. .
.
.
.
canneal individual cumulative function quality of service speedup quality of service speedup mtrand reload l. .
.
.
.
blackscholes individual cumulative function quality of service speedup quality of service speedup main outer .
.
.
.
bodytrack individual cumulative function quality of service speedup quality of service speedup particlefilter update .
.
.
.
imagemeasurements imageerrorinside outer .
.
.
.
imagemeasurements imageerrorinside inner .
.
.
.
trackingmodel getobservation .
.
.
.
imagemeasurements insideerror inner .
.
.
.
imagemeasurements insideerror outer .
.
.
.
imagemeasurements imageerroredge inner .
.
.
.
imagemeasurements edgeerror l. .
.
.
.
imagemeasurements edgeerror l. .
.
.
.
imagemeasurements imageerroredge outer .
.
.
.
ferret individual cumulative function quality of service speedup quality of service speedup emd l. .
.
.
.
lsh query bootstrap l. .
.
.
.
table multiple loop pro ling results using .
quality of service bound.
for quality of service smaller is better.
for speedup larger is better.
an analysis of x264 shows that the vast majority of successfully perforated loops perform computations that are part of motion estimation .
motion estimation performs a heuristic search for similar regions of di erent frames.
the pro ling results indicate that perforation somewhat degrades the quality of this heuristic search but by no means disables it.
indeed eliminating motion estimation entirely makes the encoder run more than six times faster than the original version but unfortunately increases the size of the encoded video le by more than a factor of three.
the cu mulatively perforated version on the other hand runs more than a factor of two faster than the original program but increases the size of the encoded video le by less than which indicates that motion estimation is still working well even after perforation .
this result which is directly reected in the pro ling tables shows that there is a signi cant amount of redundancy in the motion estimation computation which makes this computation a promising target for optimizations that trade small quality of service losses in return for substantial performance increases.pro ling results for streamcluster perforating the loop in pgain actually decreases the performance.
upon examination the reason for this performance decrease becomes clear this loop is embedded in a larger computation that executes until it satis es its own internally calculated result quality metric.
perforating this loop causes the computation to take longer to converge which decreases the performance.
perforating the inner loop in pfl on the other hand does produce a performance improvement.
this loop controls the number of centers considered when generating a new clustering.
perforation causes the computation to relax the constraint on the actual number of centers.
in practice this modi cation increases performance but in this case does not harm quality of service there is enough redundancy in the default set of potential new centers that discarding other new centers does not harm the overall quality of service.
the loop in distcomputes the euclidean distance between two points.
perforating this loop causes the computation to compute the distance in a projected space with half the dimensions of the original space which in turn causes a signi cant drop in the quality of service.
pro ling results for swaptions the single loop proling results for swaptions indicate that there is only one promising optimization candidate the outer loop in the function hjm swaption blocking .
further examination reveals that perforating this loop reduces the number of montecarlo trials.
the result is a signi cant performance increase in combination with a reduction in the swaption prices proportional to the percentage of dropped trials.
the bias correction mechanism see section corrects this reduction and signi cantly decreases the drop in quality of service.
perforating the other loops either crashes the application or produces an unacceptable quality of service loss.
the cumulative pro ling results re ect this fact by including hjm swaption blocking from the single loop pro ling runs plus several other loops that give a minor performance increase while preserving acceptable quality of service.
pro ling results for canneal the pro ling results for canneal identify no promising optimization candidates perforating the loops typically provides little quality of service loss but also little or no performance gain.
pro ling results for blackscholes the pro ling results for blackscholes indicate that there are only two loops of interest.
perforating the rst loop the outer loop in main produces a signi cant speedup with no quality of service loss whatsoever.
further investigation reveals that this loop was apparently added to arti cially increase the computational load to make the benchmark run longer.
while this loop is therefore not interesting in a production context these pro ling results show that our technique is able to identify completely redundant computation.
perforating the other loop in main inner produces unacceptable quality of service loss coupled with signi cant performance improvement.
pro ling results for bodytrack the pro ling results for bodytrack indicate that almost all of the loops are promising optimization candidates.
only one of the loops the top loop mainpthreads has substantial quality of service loss when perforated.
the others all have very small quality of service losses.
and indeed the cumulative pro ling results show that it is possible to perforate all of these loops and more the cumulative pro ling results in table present only the rst eight perforated loops while keeping the quality of service losses within more than acceptable bounds.we attribute this almost uniformly good quality of service even after perforation to two sources of redundancy in the computation.
first bodytrack uses a monte carlo approach to sample points in the captured images.
it subsequently processes these points to recognize important image features such as illumination gradients.
sampling fewer points may reduce the accuracy of the subsequent image processing computation but will not cause the computation to fail or otherwise dramatically alter its behavior.
second bodytrack does not simply perform one sampling phase.
it instead performs a sequence of sampling phases with the results of one sampling phase used to drive the selection of points during the next sampling phase.
once again performing fewer sampling phases may reduce the accuracy of the overall computation but will not cause the computation to fail or dramatically alter its behavior.
optimizations that target such sources of redundancy can often deliver signi cant performance gains without corresponding reductions in the quality of service.
this application shows how quality of service pro ling can help the developer identify such sources of redundancy.
see section for a discussion of how we used quality of service pro ling to develop a manually optimized version of this application.
pro ling results for ferret for each query image ferret performs two processing phases.
in the rst phase ferret divides the image into segments.
in the second phase ferret uses the image segments to nd similar images in its database.
our pro ling results show that the most time consuming loops are found in the database query phase.
for most of these loops perforation produces unacceptable output.
for two loops the output distortion is acceptable but perforation does not signi cantly improve the performance.
.
case studies we next present two case studies that illustrate how we used the pro ling information to guide application optimization while preserving acceptable quality of service.
x264 the top two perforated loops in the x264 pro le see tables and both occur in the pixel satd wxh function.
the pro ling results indicate that perforating these loops delivers a signi cant performance improvement with acceptable quality of service loss which makes the pixel satd wxh subcomputation a promising candidate for optimization.
a manual examination of the pixel satd wxh function indicates that it implements part of the temporal redundancy computation in x264 which nds similar regions of di erent frames for motion estimation .
the function pixel satd wxh takes the di erence of two regions of pixels performs several hadamard transforms on subregions then computes the sum of the absolute values of the transform coe cients a hadamard transform is a frequency transform which has properties similar to the discrete cosine transform .
one obvious alternative to the hadamard based approach is to eliminate the hadamard transforms and simply return the sum of absolute di erences between the pixel regions without computing the transform.
replacing the original pixel satd wxh function with this simpler implementation delivers a speedup of with a quality of service loss of .
.
this loss is due to a .
increase in the size of the encoded video and a .
db loss in psnr.
as table indicates the automatically perforated version of pixel satd wxh delivers speedup of .
with a quality of service loss of .
a larger performance improvement than the manually optimized version but also a larger quality of service loss.
our next optimization subsamples the sum of absolute di erences computation by discarding every other value in each row of the subregion.
this optimization produces a speedup of and a quality of service loss of .
.
this loss results from a .
db loss in psnr with the size of the encoded video remaining the same.
note that this psnr loss remains well below the accepted .
db perceptability threshold.
these results show that guided by the pro ling information we were able to identify and develop an optimized alternative to an important x264 subcomputation while preserving acceptable quality of service.
bodytrack bodytrack processes video streams from four coordinated cameras to identify and track major body components torso head arms and legs of a subject moving through the eld of view see figure .
it uses a particlebased monte carlo technique it randomly samples a collection of pixels each sampled pixel corresponds to a particle then processes the samples to identify visual features such as sharp illumination gradients and map the visual features to body components.
the application itself performs an annealing computation with several phases or layers of samples.
each layer uses the image processing results from the previous layer to guide the selection of the particles during its sampling process.
the top loop in the individual loop pro le table is the mainpthreads loop.
but the results show that perforating this loop causes an unacceptable quality of service loss.
we therefore focus our optimization e orts on the next loop in the pro le particlefilter update which can be perforated with signi cant performance improvement and very little quality of service loss.
this loop performs the core of bodytrack s computation in which it randomly samples and processes particles using the annealed particle lter algorithm to perform edge and foreground silhouette detection.
the loop itself iterates through the annealing layers performing directed particle ltering at each layer.
guided by the pro ling results we developed an optimization that reduces the number of particles sampled at each layer.
speci cally the optimization reduces the number of sampled particles from to .
this optimization produces a speedup of .
with a quality of service loss of .
a larger performance increase than the automatically perforated version of this loop with a smaller quality of service loss.
figure presents the output of this optimized version.
this gure shows that this optimized version of bodytrack successfully identi es all of the major body components with the exception of one forearm .
each gure presents four frames one from each of the cameras.
.
related work performance pro ling.
pro ling a system to understand where it spends its time is an essential component of modern software engineering.
standard pro lers simply identify the amount of time spent in each subcomputation .
a quality of service pro ler in contrast adds the extra dimension of providing developers with information about the quality of service implications of changing the implementation of speci c subcomputations.
this additional information can enhance developer productivity by enabling the developer to focus on promising subcomputations that loop perforation has already shown can be opti mized with acceptable quality of service losses while avoiding less promising subcomputations for which one optimization attempt has already failed.
automatic generation and management of performance versus quality of service trade o s. we have also used loop perforation to automatically enhance applications with the ability to execute at a variety of different points in the underlying performance versus quality of service trade o space .
we have demonstrated how an application can use this capability to automatically increase its performance or in combination with an appropriate monitoring and control system dynamically vary its perforation policy to adapt to clock frequency changes core failures load uctuations and other disruptive events in the computing substrate .
rinard has developed techniques for automatically deriving empirical probabilistic quality of service and timing models that characterize the trade o space generated by discarding tasks .
loop perforation operates on applications written in standard languages without the need for the developer to identify task boundaries.
an alternate approach to managing performance quality of service trade o s enables developers to provide alternate implementations for di erent pieces of functionality with the system choosing implementations that are appropriate for a given operating context .
loop perforation in contrast automatically identi es appropriately optimizable subcomputations.
unsound program transformations.
we note that loop perforation is an instance of an emerging class of unsound program transformations.
in contrast to traditional sound transformations which operate under the restrictive constraint of preserving the semantics of the original program unsound transformations have the freedom to change the behavior of the program in principled ways.
unsound transformations have been shown to enable applications to productively survive memory errors code injection attacks data structure corruption errors memory leaks and in nite loops .
they have also been shown to be e ective for automatically improving application performance and parallelizing sequential programs .
the success of loop perforation in enabling quality of service pro ling provides even more evidence for the value of this class of program transformations.
.
conclusion to e ectively optimize computations with complex performance quality of service trade o s developers need tools that can help them locate promising optimization opportunities.
our quality of service pro ler uses loop perforation to identify promising subcomputations.
developers can then leverage the generated pro ling tables to focus their optimization e orts on optimization targets that have already demonstrated the potential for signi cant performance improvements with acceptably small quality of service losses.
experimental results from our set of benchmark applications show that our quality of service pro ler can e ectively separate promising optimization opportunities from opportunities with less promise.
and our case studies provide concrete examples that illustrate how developers can use the pro ling information to guide successful e orts to develop new alternate and e ectively optimized implementations of important subcomputations.figure bodytrack reference output.
figure bodytrack output after manual optimization.
.