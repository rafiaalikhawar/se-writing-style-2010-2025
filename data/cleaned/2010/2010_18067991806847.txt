recurring bug fixes in object oriented programs t ung thanh nguyen hoan anh nguyen nam h. pham jafar al kofahi tien n. nguyen electrical and computer engineering department iowa state university tung hoan nampham jafar tien iastate.edu abstract previous research confirms the existence of recurring bug fixesin software systems.
analyzing such fixes manually we found that a large percentage of them occurs in code peers the classes methods having the similar roles in the systems such as providing similar functions and or participating in similar object interactions.
based on graph based representation of object usages we have developed several techniques to identify code peers recognize recurring bug fixes and recommend changes for code units from the bug fixes of their peers.
the empirical evaluation on several open source projects shows that our prototype fixwizard is able to identify recurring bug fixes and provide fixing rec ommendations with acceptable accuracy.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms algorithms design reliability measurement .
introduction a bug fixing change is considered recurring if it is repeated identically or with relevant slight modifications on several code fragments at one or multiple revisions.
previous research confirms the existence of recurring bug fixes .
such existence inspires us with many research questions why where and how often do such changes recur?
how could they be characterized and recognized?
and importantly how could we use them to help the developers to fix recurring bugs more effectively?
this paper aims to answer such questions.
our ultimate goal is to build a semiautomated tool that helps the developers in fixing bugs by recommending relevant useful code changes based on theknowledge about the program and its recurring bug fixes.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.we have conducted an empirical study in which experienced programmers manually examined all the bug fixes occurring in about a thousand of fixing revisions in five popular open source projects containing several thousands of fixing changes.
some projects were also used in previous research in recurring bug fixes .
the result shows that in those systems there are about of total fixing changes that could be considered as recurring.
while many recurring fixes occur on multiple files at the same revisions i.e.
in space fewer fixes recur on different revisions i.e.
in time .
some of them recur in both time and space.
some recurring fixing changes are identical or have slight lexical modifications.
a few others are complicated and scattered e.g.
the fixes involving algorithmic modifications transformations to a new design pattern or project specific requirements.
however they generally have similar syntactical changes to the code such as adding new statements or modifying current expressions.
since we focus only on object oriented code we found that most of recurring fixes affect object usages similarly e.g.
adding the same similar method invocations.
more interestingly recurring changes often occur on the parts of code that have certain interrelations such as methods being code clones classes extending the same parentclass classes implementing the same interface methods overriding the same parent method or classes belonging to the same design pattern.
investigating such code units we found they are the representatives of a broader and more interesting phenomenon.
that is in a large object oriented program there tends to exist multiple objects that play similar roles provide similar functions or perform similar interactions with the other objects in the system.
those functions interactions are realized with similar code and or in similar object usage scenarios.
then when the functions interactions need to be changed e.g.
due to bug fixing the corresponding code usages are changed in the similar manner resulting in recurring fixes.
in this paper such methods classes are called code peers .
the term peeris used to denote the similar roles of such code units.
here is a simple example.
in a graphic editor different shape objects e.g.
rectangle circle triangle have similar behaviors e.g.
drawing moving checking whether a point lies in its area etc .
some behaviors might be implementedsimilarly such as the drawing functions of rectangle and triangle objects because one draws four lines and the otherdraws only three.
in contrast the drawings of rectangle and circle could have different concrete implementations.
nevertheless the interactions between each shape and the editor as well as other graphical objects in drawing scenarios would be similar.
assume that the drawing procedure of the shapes in the editor is required to record the drawingoperations and parameters into a log file.
then the drawingfunctions of all shapes will be added with similar code for the logging task resulting in recurring changes.
using knowledge of code peers and recurring bug fixes learnt from the empirical study we developed several techniques to identify code peers in object oriented programs recognize recurring bug fixes and recommend fixing changes to code units from the fixes of their peers.
those techniques are realized in a prototype tool fixwizard.
in fixwizard code peers are formulated as the code units e.g.
methods classes involving similar object interactions.such interactions are represented by groum a graph based representation for object usages in our previous work .to avoid pairwise checking for all pairs of code units weuse several heuristics to find the peer candidates.
generally peer candidates are code units that are similar in implementation code or naming scheme or2 share the same ancestor method class or implement the same interface s i.e.
promising the same set of functions or3 belong to the classes that have other code peers or recurring fixes.
can didates with sufficient similarity in functions interactions measured based on the object usage models extracted from their implementation code and client code are considered aspeers and used for later recommendation of bug fixing.
to characterize fixing changes and recognize recurring ones fixwizard represents the change to a code unit as the changes of the corresponding object usage models i.e.
groums .
using our previous tree edit scripting algorithm in fixwiz ard derives the changed nodes in the abstract syntax tree ast representing the code fragment.
then it maps suchchanged ast nodes to the corresponding nodes of the groum connects such nodes into sub groum s and considers them belonging to the impact usage of the change.
eventually two changes are considered as recurring if their correspond ing impact usages are sufficiently similar.
fixing recommendation is useful in two cases when a fragment is fixed the tool recommends similar fixes toits not yet fixed peers and while a developer is fixing abuggy code fragment it recommends the fix derived from thesimilar fixes of its peers in the past.
to derive such recommended fixes fixwizard first determines the code elements e.g.
methods statements expressions variables involvedin the change of the source peer x. then it maps them tothe corresponding code elements of the target peer y basedon their similarity in structure and object usages.
eventually for each changed element of x the tool derives and recommends the relevant editing operations and parametersfor its mapped elements in y. we have conducted an empirical experiment to evaluate the correctness and usefulness of our approach.
the resultsshow that in the recognition of recurring bug fixes fixwiz ard achieves a high accuracy level with average precision of81 and recall of .
in fixing recommendation fixwiz ard suggests correct locations and necessary coarse grained operations such as adding deleting modifying methods and statements with precision and recall on average.
the key contributions of this paper include1.
an empirical study on recurring bug fixes that provide insight observations on such changes.
it provides the evidence confirming that a large percentage of recurring bug fixes occurs at code peers i.e.
methods classes having sim project app.
type revision range fixes argouml graphic modeling columba mail client zk ajax framework flashrecruit job listings geclipse dev environment table subject systems project rbf percentage in space in time both argouml .
.
.
.
columba .
.
.
.
zk .
.
.
.
flashrecruit .
.
.
.
geclipse .
.
.
.
table manually identified recurring fixes ilar functions and interactions in the system.
.
new concepts formulations and algorithms to identify code peers to characterize and recognize recurring fixes andto recommend such changes to the code peers.
.
an empirical evaluation shows the correctness and usefulness of our approach.
section describes our empirical study on recurring fixes.
sections present our approach.
evaluation is in section .
related work is in section .
conclusions appear last.
.
empirical study .
hypotheses in object oriented programming a software system is modeled via objects and their interactions which are realized in the classes methods providing the abstraction to the objectsand their behaviors.
the interactions of an object otoward other objects are expressed in the implementation code of itsclass methods in which it uses the other objects internalusage .
in contrast the interactions of other objects towardoare expressed in its client code within other classes methods in which it is used by other objects external usage .
ineither case the interactions of the objects could be realizedvia object usages i.e.
method invocations field accesses their usage orders and the relevant control structures.
in a large scale system there tends to exist several objects having similar functions and or interactions with other objects.
thus in the program such similar functions interac tions are implemented by classes and methods having sim ilar object usages which we call code peers .
bug fixing is to change the functions and or interactions of objects.
because similar functions and or interactions usually need to be changed in the similar ways we hypothesize that similar fixing changes would often occur on code peers h1 .
as conventional in object oriented programming the objects with similar functions will often be abstracted into par ent classes.
the specific behaviors are implemented in thechildren classes.
in other cases the methods classes mightnot be implemented in the similar ways but they implementthe same interface i.e.
promise the similar functions.
the other objects could interact in the same way with the objects in such classes via their promised methods.
the class es methods having similar functions and or being relatedvia inheritance interface will often be named similarly bythe developers to help themselves in better understanding the roles of such classes methods.
in other cases to implement the methods classes having similar functions de316public void setcolspan intcolspan throws wrongvalueexception if colspan throw new wrongvalueexception ... if colspan !
colspan colspan colspan final execution exec executions.getcurrent if exec !
null exec.isexplorer invalidate smartupdate colspan integer.tostring colspan ... public void setrowspan introwspan throws wrongvalueexception if rowspan throw new wrongvalueexception ... if rowspan !
rowspan rowspan rowspan final execution exec executions.getcurrent if exec !
null exec.isexplorer invalidate smartupdate rowspan integer.tostring rowspan ... figure bug fixes at v5088 v5089 in zk usage in method colspan usage in method rowspan usage in changed codeexecutions.getcurrent execution.isexplorerif wrongvalueexception .
init if auxheader.smartupdateauxheader.invalidateifexecutions.getcurrent execution.isexplorerif wrongvalueexception .
init if auxheader.smartupdateauxheader.invalidateif figure graph based object usages for figure velopers tend to copy and paste the implementation code thus creating similar code fragments.
therefore we hypoth esize that code peers i.e.
classes methods having similarfunctions interactions tend to have similar implementation code similar naming schemes inherit from the same class or implement the same interface h2 .
.
manual analysis of recurring fixes we conducted a manual analysis of recurring bug fixes in a two phase experiment.
first a group of experienced pro grammers examined all fixing changes of the subject systems and manually identified the similar ones.
then we analyzed their reports to characterize such recurring fixes and theirenclosing code units in order to verify the main hypothesish1 similar fixes tend to occur on code units having similarroles i.e.
providing similar functions and or participating in similar interactions in term of object usages.
we represented object usages in such code units by graphbased object usage model a technique in our previous work grouminer .
in general each usage scenario is modeled as a labeled directed acyclic graph called a groum in which nodes represent method invocations field accesses of objects as well as control structures e.g.
if while and edges repre sent the usage orders and data dependencies among them.
table shows subject systems used in our study.
two of them were also used by kim et al.
in previous research on bug fixes.
the fixes are considered at the method level i.e.
all fixing changes to a method at a revision of a sys tem are considered as an atomic fix.
seven ph.d. studentsin software engineering at iowa state university with the average of year experience in java manually examined all those fixes and identified the groups of recurring bug fixespublic class umloperationslistmodel extends umlmodelelementcachedlistmodel public void add intindex object target gettarget if target instanceof mclassifier mclassifier classifier mclassifier target collection oldfeatures classifier.getfeatures moperation newop mmutil.singleton.buildoperation classifier classifier.setfeatures addelement oldfeatures index newop operations.isempty ?null operations.get index public class umlattributeslistmodel extends umlmodelelementcachedlistmodel public void add intindex object target gettarget if target instanceof mclassifier mclassifier classifier mclassifier target collection oldfeatures classifier.getfeatures mattribute newat mmutil.singleton.buildattribute classifier classifier.setfeatures addelement oldfeatures index newat attributes.isempty ?null attributes.get index figure bug fixes at v0459 v0460 in argouml usage in umloperationslistmodel.addelement if mclassifier.getfeatures mmutil.buildoperation mclassifier.setfeaturesumloperationslistmodel.addelementlist.getlist.isemptyusage in umlattributeslistmodel.addelement if mclassifier.getfeatures mmutil.buildattribute mclassifier.setfeaturesumlattributeslistmodel.addelementlist.getlist.isempty figure graph based object usages for figure rbfs .
conflicting identifications were resolved by the ma jority vote among them.
there were only disputed groups.
table shows the collective reports.
columns rbfand percentage show the total numbers and the percentage of recurring bug fixes in all fixing ones.
we can see that rbfsare between of all fixing changes.
this is consistent with the previous report .
while many rbfs occur at the same revisions on different code units column in space less rbfs occur in different revisions column in time .
analyzing such recurring fixes we found that most of them involve object usages e.g.
method calls and field accesses .
this is understandable because the study is focused on object oriented programs.
.
representative examples example .
figure shows two recurring fixes taken from zk system with added code shown in boxes .
two methods setcolspan and setrowspan are very similar in structure and function thus are considered as cloned code.
when theirfunctions need to be changed they are changed in the sameway.
figure shows the object usage models of those twomethods with the changed parts shown in the boxes.
the nodes such as executions.getcurrent and auxheader.smartupdate represent the invocations of the corresponding methods.
an edge such as the one from executions.getcurrent toexecution.isexplorer shows the usage order i.e.
the former is called before the latter.
as we could see both methods are implemented with the same object usage.
then they are also modified in the same way as shown in the boxes.
317public class tablecontroller implements treeselectionlistener public tablecontroller mailframecontroller mailframecontroller this.mailframecontroller mailframecontroller headertableitem tableitem mailconfig.getmainframeoptionsconfig .
gettableitem headertablemodel new headertablemodel headertableitem view new tableview headertablemodel tableselectionmanager new tableselectionmanager mailframecontroller.getselectionmanager .addselectionhandler new tableselectionhandler view tablechangedlistenerlist new vector actionlistener new headertableactionlistener this ... public class treecontroller implements treeselectionlistener public treecontroller mailframecontroller mailframecontroller treemodel model this.model model this.mailframecontroller mailframecontroller view new treeview model actionlistener new foldertreeactionlistener this treeselectionmanager new treeselectionmanager mailframecontroller.getselectionmanager .addselectionhandler new treeselectionhandler view view.addtreewillexpandlistener this ... figure bug fixes at v0224 v0225 in columba example .
figure shows another example of recurring fixes.
the two methods also have similar code.
in fact they override the same method in the common parent of their classes.
analyzing two classes we found that the majorityof their methods are similar.
in other words they could beconsidered as clones in class design i.e.
having the similarroles both in function and interaction.
the groums representing the interactions of those two methods with other classes methods are shown in figure .
they have identicalstructures and if we consider buildoperation and buildattribute ofmmutil a sw e l la st w o addelement so f umloperationslistmodel and umlattributeslistmodel having the same role the two usages could be considered representing the same rou tines.
since two listobjects operations and attributes are used in the same way as a caching mechanism their us ages are changed in the same manner i.e isempty should be checked before using method geton the listobject.
example .
figure shows a more interesting case.
the changes in the boxes are very similar although the enclos ing methods are not much similar to each other as in theprevious examples.
however analyzing the usages of two enclosing classes tablecontroller and treecontroller we found that they are used only once and used together in class threepanemailframecontroller .
figures and show the code and the groums representing their usage scenarios.
it couldbe seen that such two classes are used in the similar ways in threepanemailframecontroller and thus in the whole system .
this explains why their constructors are changed similarly resulting in recurring fixes.
that is they need to inter act to their respective mailframecontroller object in the same manner i.e.
adding to its selectionmanager a relevant selectionhandler object for their corresponding views .
another interesting point is that the interaction of tablecontroller totableview tableselectionmanager a n d tableselectionhandler isidentical to that of treecontroller totreeview treeselectionmanager a n d treeselectionhandler .
examining such classes we found that they follow the model view controllerpublic threepanemailframecontroller viewitem viewitem ... trctrl new treecontroller this foldertreemodel.getinstance tbctrl new tablecontroller this tableselectionhandler tbhdl new tableselectionhandler tbctrl getselectionmanager .addselectionhandler tbhdl treeselectionhandler trhdl new treeselectionhandler trctrl.getview getselectionmanager .addselectionhandler trhdl tbctrl.getview .addmouselistener new tablemouselistener trctrl.getview .addmouselistener new treemouselistener ... figure external usages of code units in figure tablecontroller .
init tableselectionhandler .
init selectionmanager.addsellectionhandlertreecontroller .
init foldertreemodel.getinstance treeselectionhandler .
init selectionmanager.addsellectionhandlerthreepanemailframecontroller .getselectionmanager threepanemailframecontroller .getselectionmanager tablecontroller.getview treecontroller.getview tableview.addmouselistenertablemouselistener .
init treemouselistener .
init treecontroller.getview treeview.addmouselistener figure graph based object usages for figure mvc design pattern.
therefore they in pairs have the identical roles.
we also found many similar cases in which two methods classes have similar interactions with other ob jects in one or multiple usage scenarios although they arenot implemented in the similar ways or do not belong to thesame class hierarchy interface.
example .
this example is taken from two classes proppanelclass and proppanelnode at the revision of argouml project.
we found many instances of the modification from addcaption extends toaddcaption specializes .
observations .
the code units in first three examples share the common nature that they have similar object interactions in term of object usages as represented by groums.
such similarity could be seen in their implementation code examples and or in their client code example .
since they all have similar roles in the system we call them code peers .
in contrast the fixes as in example are due to system requirements and occur in several classes andmethods having no peer relations.
.
analysis of enclosing code units table shows the result of our semi automatic analysis on the locations of recurring fixes.
column rbfshows the total number of recurring fixing changes.
column idusage shows the percentage of fixes recurring in methods that haveidentical object usages example .
column simint refers to the code units which do not have exact object usages project rbf idusage simint simext others argouml columba zk flashrecruit geclipse table locations of recurring fixes 318but have similar object interactions example .
column simext refers to the fixes to code peers that are used similarly but are not implemented with similar object usages example .
column others refers to other recurring fixes.
the numbers show that a large percentage of recurring fixes are at code peers the sum of three columns idusage simint a n d simext .
many of code peers with recurring fixes are closely related in the inheritance hierarchy or share the same interface s or have similar implementations object usages and naming schemes.
this result confirms both of our hypotheses h1 and h2.
.
implications the empirical study gives us the following observations .
a considerable portion of fixing changes are actually recurring.
most of them are madeat the same revision.
.
a large percentage of recurring fixes occurs at code peers i.e.
methods classes having similar functionsand or object interactions.
.
code peers and their recurring changes involve similar object usages e.g.
method invocations and usage orders .
peer classes tend to have several peer methods.
.
code peers often have similar implementations or naming schemes and are related via inheritance or interface.
observation implies the necessity of a recommendation tool helping developers with recurring fixes.
observation 2suggests that the tool could be based on code peers i.e.
identifying code peers and recommending the fixes for them.observation implies that the code peers and the recurringfixing changes to them could be identified based on objectinteractions.
observation provides more information for finding the candidates of code peers.
we have built such a recommendation tool fixwizard based on those implications.
in general its main task is toidentify code peers and when one peer changes it recommends the fix to other peers .
fixwizard identifies code peers and the recurring fixes via object usages.
that is codepeers are code units methods classes having similar objectusages internally i.e.
in their implementation code and orexternally i.e.
in the code using them .
recurring fixes at code peers are also the changes involving in similar object usages.
the formulation and algorithms of our approach willbe discussed in the next sections.
.
formulation .
code peer and usage similarity definition internal external usage .
internal usage of a method a.m denoted by ui a.m is the set of all groums and sub groums subgraphs in its implementation code.
external usage of a.m denoted by ue a.m i s the set of all groums and sub groums in the implementationcode in the system that could have an invocation of a.m. this definition also takes into account dynamic binding in object oriented programming.
that is an invocation ofa .mori.mmight actually be an invocation of a.mifais a subclass of class a0oraimplements interface i. definition peer .
two methods are peers if and only if iff the usage similarity measured by a functionsim of their respective internal or external usages exceeds a pre defined threshold.
two classes are peers iff the numberof their peer methods exceeds a chosen threshold.
peer relation between methods classes is denoted by .
it is reflexive a method class is a peer of itself symmetric i.e.
if xis a peer of y t h e n yis also a peer of x and not transitive.
definition could be written as a.m b.niff sim u i a.m u i b.n 1orsim u e a.m u e b.n 2 in which 1and 2are chosen thresholds.
the formulation of sim the usage similarity measure between any two sets of graph based usages will be presented next.
definition peer isomorphic usage .
two groums arepeer isomorphic if there exists a bijective one to one mapping for their nodes such that the mapped nodes repre sent the invocations of the same or peer methods and their usage orders are the same.
figure shows an illustrated example for peer isomorphic usages.
assume that buildoperation and buildattribute ofmmutil a sw e l la st w o addelement so f umloperationslistmodel and umlattributeslistmodel are peer methods.
then all the nodes between two groums in figure could be mapped while the usage orders are still preserved.
thus the two usages arepeer isomorphic.
note that peer isomorphism for groums subsumes label isomorphism peer relation is reflexive .
however the usages could not always be peer isomorphic.
they could be similar as in figure .
therefore we define the similarity of two object usages as follows.
definition usage similarity .
given two groums gandh.
assume that g oandhoare their largest peerisomorphic sub groums respectively the size of groum ismeasured by the number of nodes .
then the usage similarity of gandhis defined as gsim g h g o h o g h .
let us revisit figure .
assume that all corresponding methods of tablexxx classes and treexxx classes are peer methods.
then two graphs could be mapped such that two peer isomorphic subgraphs have their sizes up to nodes.
two methods foldertreemodel.getinstance and treecontroller.
getview could not be mapped .
thus the similarity of two usages is .
.
using the usage similarity gsimfor any pair of groums we could define function simused in definition that measures the usage similarity of two methods as in the following.
definition similarity of two usage sets .
given two sets of groums uandv.
their usage similarity sim u v is the ratio between the total usage similarity of the maxi mum weighted matching between the members of uandv and their average size.
this definition could formally written as sim u v max m summationtext g h mgsim g h u v for all m g h g u h v such that g h g prime h prime m g g prime h h prime for example assume that two methods have the external usage sets g1 g2 and h h2 respectively.
the usage similarity of each pair is sim g1 h1 .
sim g1 h2 .
sim g2 h1 .
and sim g2 h2 .
.
then the maximum matching of two sets is g1 h1 a n d g2 h2 with the total similarity is .
.
.
.
since their average size is the usage similarity is .
.
.
.
recurring changes in code peers if code peers are modified their corresponding object usages represented by groums tend to be changed.
thechange of a groum might include the added deleted relabeled or edge changed nodes.
for example in figure the node list.isempty is added.
then three nodes list.get umloperationslistmodel.addelement a n d mclassifier.setfeature are edge changed because they have the added edges due tothe addition of list.isempty .
in this case we could say that the change affects all four nodes and such impact could berepresented by the sub groum containing them.
of course the change of a groum could affect several nodes and they might belong to different usages i.e.
thechange might affect different sub groums.
two disconnected sub groums are considered belonging to different usages since if they had dependency they would have been connected.therefore the impact of a change is modeled as a set ofconnected sub groums.
definition impact usage .
impact usage of a change to a code peer is the set of connected sub groums of thechanged nodes in the groum of that code peer.
since code peers have similar object usages if their object usages are changed in the similar ways i.e.
having simi lar impacts on the corresponding groums we could considersuch changes as recurring.
definition recurring changes .
two changes are recurring if their impact usages are sufficiently similar.
for example in figure and figure the changes are recurring since their respective impact usages are identical as in figure or peer isomorphic as in figure .
.
algorithmic solution in this section we will discuss three algorithms to identify code peers recognize recurring bug fixes and de rive the recommended fix for a code peer from the fix of its peer.
algorithms and are used in the recommendation task.
algorithm is needed to record recognize the recur ring fixes which helps in verifying and improving the cor rectness of code peer identification which in turn improvesthe fixing recommendation.
.
code peers identification if we use pair wise comparison between all methods to identify all code peers as in definition in section thecomputational cost could be expensive because in large systems the number of methods could be huge which makes pair wise comparison too expensive.
finding maximum peer isomorphic subgraphs to calculate the similarity between two usage sets is hard findingmaximum isomorphic subgraphs is already np hard .
there is a possibility that the computation of peerisomorphic subgraphs would result in an infinite loop dueto the recursive nature of the definition of code peers.
for example in figure to calculate the similarity of the extern a lu s a g eo f tablecontroller.
init and treecontroller.
init inthreepanemailframecontroller figure we need to check the peer relation of tableselectionhandler.
init and treeselectionhandler.
init .
however both internal and external usages of two xxxselectionhandler s constructors use two xxxcontroller s constructors respectively.
thus the peer checking for two xxxselectionhandler s constructors requires the peer checking for two xxxcontroller ones.
this recursive checking could cause infinite computation.
we design an approximate algorithm for code peer identification using the following ideas .
instead of pair wise comparison for all methods fixwizard uses observation section .
to find candidates foridentification of code peers.
generally it checks the peerrelation for only the methods classes that are similar in their implementation code or naming scheme or2 share the same ancestor method class or implement the same interface s i.e.
promising the same set of functions or3 belong to the classes that have other peers or recurring fixes.
.
graph based usage similarity is computed approximately.
instead of finding maximum peer isomorphic sub graphs of two groums to calculate their similarity fixwiz ard extracts their characteristic features.
if such features aresimilar the corresponding groums are considered as similar.
.
to avoid the possibility of recursive calculation of peer relations fixwizard iteratively calculates the usage similar ity of candidates using only already identified peers.
whenany candidates are identified as peers they will be used toupdate the usage similarity of the remaining candidates.
.
.
feature based usage similarity in we proposed the use of structural features to compare the similarity of groums labeled directed acyclic graphs .we extend that technique to support peer based similarity.
definition .a feature extracted from a path within a groum is the sequence of method names represented by thenodes along that path.
for example in figure the extracted features could be path of size path of size path of size etc.
such features could describe an objectusage approximately such as the method invocations theirusage orders and the interactions between objects by se quences of method calls in the usage.
definition similar feature .
two features x x x2 ... xnandy y1 y2 ... ynare considered similar denoted as x y i fx i yifor all i. for example if addelement methods of umloperationslistmodel and umlattributeslistmodel are peers then two features and are considered similar.
the similarity of two feature sets is de fined using the following definition definition similarity of two feature sets .
similarity of two feature sets xandy denoted as fsim x y is the ratio between the size of their maximum matching based on the similar feature relation and their average size.
this could be written formally as fsim x y max f f x y for all f x y x x y y x y such that x y x prime y prime f x x prime y y prime.
identifycodepeer prog 2m.add similarmethod prog add cloned methods as candidates 3c.add similarclass prog find similar classes and 4c.add similarfixedclass prog classes with recurring fixes 5m.add similarnamedmethod c match methods as candidates do a.m b.n m.next repeatedly process candidates ifsim u i a.m u i b.n 1or sim u e a.m u e b.n 2 if similar enough move a.m b.n from mtopm add as peers c.add a b and check enclosing classes m.add similarnamedmethod a b for new candidates while new peers are still identified pc.add peerclass c find peer classes figure code peer identification the similarity of two groums is measured by the similarity of its two feature sets i.e.
function fsim is used instead of gsim in the calculation of function simin definition .
.
.
code peer identification algorithm figure shows the algorithm for identifying code peers.
as any time we have the persistent lists of identified code peers and candidates pcandcfor classes and pmandm for methods.
each element of such list is a pair of classes or methods.
the algorithm works by iteratively updatingthe elements of those lists.
it is run incrementally for eachrevision i.e.
whenever new code is added.
step .
find candidates .
structural clones are detected by our incremental clone detection algorithm .pairs of cloned methods are added to the candidate list m line function similarmethod .
candidates are also scanned from the classes that have similar interface or inheritance or names line function similarclass or used to have recurring fixes reported from the previous revisions line function similarfixedclass .
in function similarclass for each class the extracted features include its name its parent name the interface s itimplements the names of its methods fields.
then theclasses are compared pair wise to find the ones having sim ilar features.
classes methods names are compared as fol lows.
first each name is separated into words.
for example umloperationslistmodel is separated into uml operations list a n d model.
then the similarity of two names as two sequences of words are calculated based on their largest common subsequence.
for example uml operationslist model and uml attributes list model will be matched respectively.
their largest common subsequence has the sizeof .
thus the overall similarity is .
.
for each pair of candidate classes in c their methods are matched based on the similarity of their names function similarnamedmethod and are added to the list m. step .
evaluate candidates .
peer candidates pairs of methods in mare stored as a descending sorted list based on their current usage similarity either of internal usage orexternal usage whichever higher .
such usage similarity is calculated via features i.e.
using fsim in definition and the features are compared using identified peers in p m only.
that is features having the names of the methods that are not determined as peers yet will not be consideredas similar to any other feature definition .
each pair of candidates having usage feature similarity internal or external larger than chosen thresholds line recognizerecurringfixes fixes for each fixes iu impactusage extract impact usage for each pair of changes prime pair wise comparison ifsim iu iu prime 3 if impacts are similar rbf .add prime report as recurring fixes figure recurring fixes recognition will be moved from mtopm line .
their corresponding classes are considered as candidate classes line .
othermethods are then matched function similarnamedmethod t o get new candidates for adding into m line .
this step repeats until all candidates are evaluated and no new peer is detected.
finally after all peer methods are identified the candidate classes are evaluated to find peer classes line .
.
recurring fixes recognition figure shows the algorithm to recognize recurring fixes.
generally it first extracts the impact usages of all fixingchanges and then compares them to identify the fixes withsufficient similar impact usages as the recurring ones.
step .
extract impact usages .
for each fix in the setfixes of all fixes the algorithm parses two versions of the corresponding code unit into two asts and builds twocorresponding groums.
then it uses treed a tree editing algorithm to detect all ast node level tree edit operations i.e.
inserting deleting updating relabeling and moving an ast node.
using the mapping between ast nodes and groums nodes it determines the changed nodesof the groums corresponding to the changed nodes in the ast.
from those nodes it traverses the groums to find edgechanged nodes and connects all the changed nodes into con nected sub groums to form the impact usage of the change.
let us illustrate this via the example in figure .
based on treed the algorithm knows that the ast node of type method invocation operations.isempty isadded.
thus the corresponding node list.isempty in the groum is determined asadded.
this addition also adds new edges from list.isempty to three other nodes list.get mclassifier.setfeature a n d umloperationslistmodel.addelement due to the changes in usage orders figure .
from list.isempty the algorithm traverses through such edges and detects those three edge changed nodes.
then the sub groum of those four nodes is extractedas the impact usage of the change.
step .
clustering.
after the impact usages of all fixes are extracted fixwizard compares them pair wise.
pairswith sufficiently similar impact usages are added to the listof detected recurring bug fixes rbf.
similar to the peer detection algorithm this comparison uses the usage feature similarity i.e.
function fsim in calculating the total similarity simbetween two impact usages of any pair of fixes.
.
fixing recommendation for code peers because recurring fixes are modeled by the impact usages the recommendation should be also represented as the change operations to the groums i.e.
inserting deleting re labeling changing nodes edges in groums etc .
however to make the fixing changes more readable and instructiveto developers fixwizard recommends bug fixes via change operations at the syntactic level.
figure shows the recommendation algorithm.
it is used recommendfix x x for each y peerof x for each peer of x x affect x x detect affected sub trees of x m map x y map them and other code elements to y for each mapped pair x y m for the mapped elements o deriveoperation x y derive the relevant operation recommend o to recommend figure fixing recommendation for code peers w h e nac o d eu n i t xis fixed by a fixing change x and the tool derives the recommended changes for every code peer y ofx xmight have no peer or multiple peers .
to do that the algorithm first determines the impact usage of xtox as in section .
.
via the mappings between changed nodes of the groum and the ast it identifies the changed sub trees in ast relevant to the change in object usage of x line .
then those sub trees are mapped into the corresponding sub trees in y line .
each pair of sub trees is mapped based on their structural similarity and usage similarity of the sub groums extracted from those two sub trees.
then the mapped sub trees are used to map other code elements such as fields variables types method invocations.
finally for each mapped element xinx if it is affected by a tree edit operation we will suggest the corresponding operation to its mapped element yiny lines .
let us revisit figure .
assume that the above method xchanges and the tool needs to recommend for the below method y. first the algorithm determines the change to the expression containing operations.isempty .
it knows that the corresponding groum node list.isempty is added.
it could determine the statement containing mclassifier.setfeatures and the ifstatement as the relevant sub trees.
it then maps those subtrees to the corresponding ones of y. from the mapped expressions the algorithm is able to map two variables operations and attributes .
thus the addition of operations.isempty is used to derive the addition of attributes.isempty fory.
other added nodes of the expressions are the same.
after applying such operations intothe corresponding sub trees in y it outputs them as texts for the recommendation.
similarly for the example in figure the algorithm derives the correct addition of the statement.
however since it could not map two types tableselectioncontroller and treeselectioncontroller the recommendation for the below method contain the incorrect class name tableselectioncontroller .t h u s in the current implementation we stop at the recommenda tion of the locations of code peers at the method and statement levels with the first change operation.
from there developers could be able to complete the changes.
.
ev aluation we implemented those three algorithms in a prototype tool named fixwizard.
its main function is to identify thecode peers in the program and when a code unit xis fixed it recommends the similar fixes to all the code peers of x if any .
currently fixwizard could recommend the locations e.g.
class method statement and operations e.g.
add or delete a method a statement a method invocation for thefixes.
it is also able to analyze the history of bug fixes in any period then recognize and report the recurring ones.
we performed an empirical study to evaluate fixwizardsystem class method rbf prec.
rec.
fscore argouml columba zk flashrecruit geclipse table recognition accuracy accuracy from zk 8090100accuracy from zk precision 60708090100accuracy from zk precision recall 30405060708090100accuracy from zk precision recall 2030405060708090100accuracy from zk precision recall revisionaccuracy from zk precision recall revisionaccuracy from zk precision recall figure recognition accuracy on zk regarding those two functions.
in the evaluation we specified the parameters for fixwizard with the feature size be tween and threshold of .
for all similarity measurements.
all experiments were carried out in a computer with intel core duo 2ghz 3gb ram and windows xp.
.
recurring fixes recognition to evaluate the recognition of recurring fixes in fixwizard we execute it on the subject systems whose recurring fixes were manually verified as described in section .
metrics for performance evaluation are precision recall and fs core.
the precision value is defined as the number of correctly detected recurring fixing changes over the total number of detected ones.
the recall value is defined as the number of correctly detected recurring fixing changes over the total number of recurring fixing ones.
we also use fscore a metric combining both precision and recall by the formula fscore precision recall .
for each system we selected the range of fixing revisions r 1tornas exactly as the one in the experiment in section .
we incrementally executed fixwizard for each fixing revi sionr kin the range from r1torn.
at each rk based on the recognized recurring fixes and detected code peers in the past from r1tork fixwizard examines the current fix and detect if those fixing changes are recurring.
note that all fixing changes to the same method at a fixing revisionare considered as an atomic fix.
we compared the detected result with the human verified data.
the accumulated precision and recall values are recorded at each fixing revisions.
an accumulated value at r krefers to the value measured for all fixing revisions from r1tork.
the accumulated values reflect better the accuracy of fixwizard over time than instant precision recall at a single revision.
figure shows the accumulated precision and recall values respectively for the project zk in the fixing revisions.
for example among fixing revisions in zk project wecould see that after the initial phase of about revisions the accumulated precision and recall values reach the ranges between and respectively.
in the initial 322phase because the number of accumulated recurring fixes is still small precision and recall are affected much by a coupleof miss or incorrectly detected recurring fixes.
the similargraph results are also achieved for other systems in which after the initial phases the average precision and recall values are and respectively see table .
due to thespace limit we could not show the graphs for all subjects.
the values are quite consistent and stable after the initial phase for all projects.
moreover comparing with the percentage of the recurring fixes that occur in code peers see the empirical study in section we could see that fixwiz ard is able to detect the majority of such recurring fixes vs on average .
this shows that our formulationand algorithms for detecting code peers and recurring fixes are quite accurate in object oriented programs.
other experiments .
to confirm that our formulation and algorithms are still valid on other systems than the onesused in the empirical study section we also run fixwizard on two other java application server systems jetty and apache tomcat.
we manually checked the results reportedby fixwizard for precision values.
on jetty fixwizard re ported recurring fixes and were verified to be correct precision .
on tomcat out of reported fixes were truly recurring precision .
.
fixing recommendation this section describes our evaluation for the accuracy of the recommendation algorithm.
we used the same set of subject systems as in the previous experiment.
we also per formed a similar process as in the detection experiment inwhich fixwizard was incrementally executed for each fixing revision in the chosen range from r 1torn.
at each fixing revision rk we executed the tool for each fixing change and recorded the recommendations for its code peers.
then we compared with the actual fixes.
the number of pro duced recommendations and the number of correct ones are counted.
a recommendation is considered as correct if it correctly suggests the fixing location and the first change op eration.
we recorded the correctness of recommended loca tions at both method and statement levels e.g.
add delete methods add delete modify statements .
only the first operation is considered because if the correct location is sug gested it would already save much effort for developers.
because the human verified oracle section did not contain the detailed change operations we had to check the recommendation results manually.
therefore we chose a smaller range of fixing revisions to check.
table showsthe recommendation results.
column check is the number of recurring fixes we manually checked which is less thanthe total number of recurring fixes in the subject systems.
columns recom.
and correct are the number of changes that fixwizard recommended and that of changes that we considered to be correct.
two columns prec.
and rec.are the precision and recall values respectively.
it could be seenthat on average for all subject systems fixwizard has recall and precision.
this result shows that using code peers to suggest the locations for recurring fixes are accept ably accurate.
the mapping task between the nodes in codepeers and the detected editing operations need to improve.
.
threats to validity open source bug databases used in our research could be incomplete because there exist bug fixes that might not besystem check recom.
correct prec.
rec.
fscore argouml columba zk flashrecuit geclipse table recommendation accuracy reported in such repositories.
since our empirical study isbased on the reported bug fixes in those databases its results might be affected.
moreover recurring bug fixes in our study are examined and identified by human beings thus theycould be biased due to human subjective views.
.
related work there exist other research that aims to record and recommend recurring bug fixes .
sun et al.
present a template and rule based approach to automatically prop agate bug fixes.
their approach supports some pre definedtemplates rules e.g.
orders of pairs of method calls con dition checking around the calls and requires a fix to beextracted expressed as one or more rules in order to propagate it.
in contrast our approach is peer based thus if a new fix occurs in a code unit fixwizard is still able to rec ommend the similar fix to its code peer s without requiringany predefined templates or rules.
moreover their approachrelies on rule matching via label isomorphism that does not take the peer relation into account.
another research close to our work is bugmem .
bugmem uses the line based textual differencing approach to identify changed textual areas called hunks .
bugmem s atomic fix is a pair of textual hunks bug hunk in the olderrevision and fix hunk in the new one .
for each line in a hunk bugmem extracts program units with type informa tion and uses them as the features of the hunk.
a fix ischaracterized by the features existing in the bug hunk but not in the fix hunk.
first fixwizard differs from bugmem on the program context used to extract the features of a fix.
because examining onlythe changed area bugmem misses the recurring fixes that involve the addition of new code.in these cases bugmem faces empty bug hunk.
fixwizard could detect these recurring fixes because it examines also the impact area of the change.
moreover it handles global recurring fixes in code peers with the impact areaslying outside of the changed regions.
importantly fixwiz ard performs program data analyses from the changed area in its enclosing method even on code peers and extracts features based on object usages.
finally fixwizard can recommend in both fixing locations andoperations .
in patch miner after making a fix developers could use the tool to create a patch.
it finds all code snapshotswith similar snippets i.e.
cloned code to the fragment thatwas fixed.
it uses largest common subsequences of programtokens to find such cloned code.
since the level of abstrac tion of features is at program tokens it could not handle the cases requiring complex program analysis e.g.
code peers .
moreover patch miner detects code clones to suggest a fix while fixwizard can also detect similar fixes.
thus patch miner could not suggest a fix even though a similar fix oc curred in the past to a peer of the current fragment.
many approaches for code clone detection have been proposed .
the key difference of fixwizard with this research 323is that fixwizard is able to detect not only similar code but alsosimilar changes .
a cloned fragment is a candidate for code peers because it could have the similar object usageswith another fragment.
cp miner mines frequent subsequences of tokens to detect bugs caused by inconsistent editing to cloned code.
jiang et al.
detect clone related bugs via formulating context based inconsistencies.
exist ing supports for consistent editing of cloned code are limited to interactive synchronization in code editors such as clonetracker and codelink editor .
libra searches code fragments for simultaneous changes using token based cloneanalysis.
fixwizard could support off line clone synchro nization because it is extended from clever .
several bug finding approaches are based on mining of code patterns in the project s history .some tools detect pre defined common bug patterns using syntactic pattern matching .
they do not detecthigh level project specific bugs.
in contrast jadet performs mining the object usage patterns and detects the violations as potential bugs.
hipikat extracts lexical information while building the project s memories and rec ommends related artifacts including documentation.
sev eral approaches mine usage patterns in term of the orders of method calls dynamine mapo williams and hollingsworth s or association rules .
however they focus only on a small set of patterns and bugs e.g.
codeusages error handling condition checking .in fixwizard a new fix pattern can be characterized recognized and used in recommendations.
some of such approaches find the methods that are used changed to gether.
however they analyze only the client code of meth ods.
fixwizard looks at their internal usages as well.
several approaches have been proposed to help users localize buggy code areas .
some leveragethe project s historical information the amount of changedloc over the total in a time period frequently recentlymodified fixed modules code co changes and bug locality change and complexity metrics social network among developers etc.
although theyhave achieved the good level of accuracy thegranularity levels of buggy area are still coarse ranging frommodules to files or methods .
with slightly lower accuracy fixwizard is able to recommend fixes at the statement level and provide useful semantics operations.
.
conclusions this paper investigated recurring bug fixing changes both theoretically and empirically and found that a high percent age of such recurring fixes occur at code peers i.e.
certainclasses and methods having similar roles in a system such asproviding similar functions and or participating in similar usage scenarios.
to aim for that high percentage portion of recurring fixes we developed several novel techniques torecognize code peers and the similar fixing changes made tothem as well as to recommend the fixing changes for a codepeer from the fixes made to one of its peers.
our empirical evaluation showed that our approach achieves high level of accuracy in both recognizing recurring fixes and recommend ing the bug fixing changes.
in future we will investigate theapproaches to deal with similar usages involving design pat terns to improve the quality of our recommendations.
acknowledgment.
this project was partially funded by a vietnam education foundation grant for the first author.
.