automatic synthesis of modular connectors via composition of protocol mediation patterns paola inverardi and massimo tivoli dipartimento di ingegneria e scienze dell informazione e matematica universit a degli studi dell aquila italy fpaola.inverardi massimo.tivoli g univaq.it abstract ubiquitous and pervasive computing promotes the creation of an environment where networked systems nss eternally provide connectivity and services without requiring explicit awareness of the underlying communications and computing technologies.
in this context achieving interoperability among heterogeneous nss represents an important issue.
in order to mediate the nss interaction protocol and solve possible mismatches connectors are often built.
however connector development is a never ending and error prone task and prevents the eternality of nss.
for this reason in the literature many approaches propose the automatic synthesis of connectors.
however solving the connector synthesis problem in general is hard and when possible it results in a monolithic connector hence preventing its evolution.
in this paper we define a method for the automatic synthesis of modular connectors each of them expressed as the composition of independent mediators.
a modular connector as synthesized by our method supports connector evolution and performs correct mediation.
i. i ntroduction the near future envisions an ubiquitous and pervasive computing environment that enables heterogeneous networked systems nss to provide and access services without requiring an explicit awareness of the underlying communications and computing technologies .
in this scenario a problem that arises when composing heterogeneous nss is how to achieve their interoperability by solving protocol mismatches.
a widely used technique to cope with this problem is to build connectors that bridge the communication among heterogenous protocols and coordinate their interaction.
however due to the potentially infinite number of different available protocols connector development is a never ending and error prone task and prevents the eternality of nss.
the efficacy of composing nss is proportional to the level of interoperability of the respective underlying technologies.
for this reason starting from the pioneering work in many approaches propose the automatic synthesis of connectors see just to cite a few.
as a matter of fact the connector synthesis problem is hard in the sense that not all possible protocol mismatches are solvable.
for instance building a connector that reconciles the component interaction by reordering certain sequences of exchanged messages can lead to unbounded executions.
as shown in a suitable termination criterion can be defined with the aim of under approximating unbounded interactions by means of bounded ones whenever a pattern of behaviour indicating potential infinity occurs.
thus practical solutionscan only deal with a combination of specific mediation patterns that correspond to tractable protocol mismatches .
however these solutions eventually result in a monolithic connector hence preventing evolution synthesis and maintenance.
in this paper we define a method for the automatic synthesis of modular connectors.
a modular connector is a composition of independent mediators .
each mediator is a primitive sub connector that realizes a mediation pattern which corresponds to the solution of a recurring protocol mismatch.
the advantage of our connector decomposition is twofold i it is correct i.e.
as for its monolithic version a modular connector performs a mediation that is free from possible mismatches and ii it promotes connector evolution hence also easing code synthesis and maintenance.
to show i we define the semantics of protocols as well as of mediators and connectors by using a revised version of the interface automata ia theory described in .
then we prove that a modular connector for two protocols pandrenjoys the same correctness properties of the monolithic connector obtained by expressing the synthesis problem as a quotient problem betweenpandr .
concerning the set of considered mediation patterns and hence connector modularization our synthesis method relies on a revised version of the connector algebra described in .
it is an algebra for reasoning about protocol mismatches where basic mismatches can be solved by suitably defined primitives while complex mismatches can be settled by composition operators that build connectors out of simpler ones.
we revise the original algebra by adding an iterator operator and by giving its semantics in terms of our revised ia theory.
for ii we make use of a case study in the e commerce domain to illustrate that relevant changes can be applied on a modular connector by acting on its constituent mediators without entirely re synthesizing its protocol.
the paper is organized as follows.
section ii puts the bases for the definition of our synthesis method.
section iii introduces the purchase order mediation scenario that we use as case study in the sequel of the paper.
in section iv we formalize our method and illustrate it at work on the case study.
in section v we state correctness and show how the method supports connector evolution.
section vi discusses related work and section vii provides final remarks and future research directions.
.
c ieee icse san francisco ca usa3 ii.
p reamble on the synthesis method we assume that a ns comes together with a ia based specification of its interaction protocol ip .
note that this assumption is supported by the increasing proliferation of techniques for software model elicitation see just to cite a few .
the ip of a ns expresses the order in which input andoutput actions are performed while the ns interacts with the environment.
actions are used to abstract messages that can be sent outputs or received inputs .
inputs are received from and controlled by the environment whereas outputs are controlled and emitted by the ns.
a ns can perform also hidden actions corresponding to internal computation.
in this section we instantiate some definitions from the ia theory in to our context and when needed for the purposes of connector synthesis we also add new ones.
definition interaction protocol specification aninteraction protocol specification ips pis a tuple ai p ao p ah p sp s0 p p whereai p ao p ah pare disjoint sets referred to as input output and hidden actions the union of which we denote by ap spis a finite set of states withs0 p2spbeing the designated initial state and p sp ap!spis the partial transition function .
intuitively from a state the ns may either emit any output that is enabled according to its ips or perform internal computation.
if the environment supplies an input that is enabled the reaction of the ns is according to its ips.
if the input is not enabled this causes an inconsistency .
letabe an action we denote with aitscomplement .
ifa is an input action then ais the corresponding output action and vice versa.
when ais a hidden action ais hidden as well and its label is the one of afollowed by .
abusing notation we extend the complement also to ipss.
that is let pbe an ips thenpdenotes its complement and it is pwhere all input output and hidden actions have been complemented.
furthermore we consider a special kind of ips denoted by i and called identity .
it is defined as the ips fs0 ig s0 i .
to give the possibility to express ipss that take a message as input and forward the same message as output given an action a we consider also the action a0as semantically equivalent toa yet syntactically different .
we write sa !ps0to denote that p s a s0 or equivalently that s a s0 p .
an actionaisenabled ins if p s a is defined.ap s denotes the set of actions in pthat are enabled in s. we denote withsa ps0a sequence of internal actions starting from s terminating to s0 and with an observable action ain some point in the middle of the sequence.
we write sa pto denote that froms pcan perform a sequence of hidden actions terminating with a. abusing notation p s a denotes the set of states in p that are reachable from sby performing a sequence of hidden actions terminating with a. definition traces of an ips letp ai p ao p ah p sp s0 p p be an ips a trace ofp is atp2 ai p ao p f g defined in such a way thattp 9n sp sp n2sp tp a1a2 a n sp 0a1 an sp n where denotes the so called empty trace .
we denote with atptheset of actions intp jtpjis the length oftp.
furthermore tp a is the first position of ain tp.
finally tr p denotes the set of traces ofp.
from hereon let p ai p ao p ah p sp s0 p p and r ai r ao r ah r sr s0 r r be two ipss.
pandrmay only be composed if their action sets are compatible with each other.
ipss pandrarecomposable ifah p ar ap ah r ai p ai r andao p ao r .
we denote withcommon p r the setap arof common actions.
note that if pandrare composable then common p r ai p ao r ao p ai r .
to define the parallel composition of composable ipss we use a product operation that accounts for possible semantically equivalent actions.
definition product of two ipss the product of pandris an ips p r ai p r ao p r ah p r sp sr s0 p s0 r p r where ai p r ai p ai r ncommon p r ao p r ao p ao r ncommon p r ah p r ah p ah r common p r p r a !p r p0 r0 pa resp a0 !
pp0 r r a0 resp.
r r a is not defined r r0 a resp.
a0 2common p r p p0 p p a0 resp.
p p a is not defined ra resp a0 !
rr0 a resp.
a0 2common p r pa resp a0 !
pp0 ra resp a0 !
rr0 a resp.
a0 2common p r pa resp a0 !
pp0 ra0 resp a !
rr0.
the product can introduce a number of inconsistencies when one of the two protocols is willing to offer an output action in the common alphabet but the second is not able to offer possibly after a sequence of hidden actions the corresponding input action accounting also for possible semantically equivalent actions .
inconsistencies p r is the set of states in p rfrom which inconsistencies can arise.
the kernel of the inconsistencies in p ris the set of states p r for which either i there is some a2common p r resp.
a02common p r such that one of pandrcan make an alabelled resp.
a0 labelled output transition but the other cannot match it with the corresponding input transition or ii one ofpandrcan make an a labelled resp.
a0 labelled output transition but the other cannot match it with the semantically equivalent input transition.
thus inconsistencies p r is then the set of those states in the kernel plus those that can reach a state in the kernel by a sequence of transitions labelled by either output or hidden actions.
definition composition of two ipss the composition of two composable ipss pandr written aspjjr is defined to be p rafter pruning all states in inconsistencies p r providing the initial state sp sr 4is contained within the remaining automaton.
otherwise the composition is undefined.
as formally proven in jjis a compositional operator meaning that given three composable ipss p q andr then pjjq jjr pjj qjjr .
as it will be clear in section v to state correctness of our synthesis method we use a notion of refinement based on a version of alternating simulation that accounts for both hidden actions and semantically equivalent ones.
informally r refinespif all input steps of pcan be simulated by r and all the output steps of rcan be simulated by p considering that internal steps of pandrare independent and an observable step can be simulated by a semantically equivalent one.
we make use of a semantic inclusion operator denoted by sem between sets of actions.
its meaning is the same as but it accounts also for semantically equivalent actions.
that is given two sets of actions sands0 ifs s0thens sems0 and given an action a either fag s sem fa0g s0 or fa0g s sem fag s0 .
definition refinement between ipss rrefinesp i.e.
p r if the following conditions hold ai p semai r ao r semao p there exists an alternating simulation as a binary relation sp srsuch that for all states s2spandr2sr withs r the following conditions hold ii.
fxjsx p x2ai pg semfyjry r y2ai rg ii.
fyjry r y2ao rg semfxjsx p x2ao pg ii.
8z2fxjsx p x2ai pg fyjry r y2ao rg r02 r r z 9s02 p s z s0 r0 s0 p s0 r. refinement between ipss is a preorder i.e.
reflexive and transitive .
note that pandpare always composable and under refinement pjjpandiare equivalent i.e.
pjjp iand i pjjp.
the same holds for pjjiandp i.e.
p pjjiand pjji p. furthermore refinement is compositional meaning thatpjjp0 rjjr0 if bothp randp0 r0.
as already mentioned in section i in order to reason about protocol mismatches we consider a revised version of the connector algebra described in .
in the following we report only the portion of the algebra that is relevant for the purposes of this work.
from hereon letabe the universal set of actions.
to define the primitives ap a of the connector algebra we exploit a categorisation of mediator patterns that represent possible solutions to recurring protocol mismatches.
as described below for each type of mismatch a pattern can be defined as a solution to the interaction incompatibility.
extra send it concerns the possibility for a ns to generate either a redundant or an additional message.
such a mismatch can be solved by considering a pattern which represents mediators that consume messages.
missing send it occurs when a ns expects either a redundant message or a message that is not sentby another ns.
it can be solved by a pattern which represents mediators that produce messages.
signature mismatch two messages of two nss can be functionally compatible yet syntactically inconsistent.
mediators compliant with a pattern that translates a message into another can solve this mismatch.
split message mismatch a ns may expect to receive a message as a sequence of fragments of it.
this mismatch can be solved by introducing mediators compliant with a pattern that splits the message into an ordered sequence of its fragments.
merge message mismatch it is symmetric to the previous one.
the mismatch can be solved by exploiting a pattern which represents mediators that merge an ordered sequence of message fragments into a composite message.
reordering mismatch a ns expects to receive messages in an order different from the order used by the sending ns.
it can be solved by mediators compliant with a pattern that reorders an ordered sequence of messages into another one that is ordered by applying a specific message permutation.
according to the pattern categorisation discussed above the syntax of a term tinap a is given by t t tjt j t jp p jcons a jprod a jtrans a b j split a jmerge a j order a0 a0 n wherea ai a0 i b2a and is a permutation of f1 ng.
the symbol is a binary operator called plugging and is an unary operator called iterator .
the semantics of ap a is given in terms of a function j k ap a !ips f errg whereips is the universal set of ipss and err represents the undefined ips i.e.
it has no states.
for any term t the denotation jtkis defined inductively.
iftis a primitive then jtkis the corresponding ips1 providing the parameters are well defined otherwise jtk err .
iftis a compound term such as t p r then jtkis given by if either jpkorjrkis equal toerr then jtk err.
alternatively if jpkand jrkare not composable or jpkjjjrk is not defined then jtk err.
otherwise jtk jpkjjjrk.
iftis an iterative term such as t p then jtkis given by the ips jpksuitably adjusted by means of hidden transitions for allowing cyclic behaviour .
otherwise if jpkis undefined then jtk err.
iii.
t hepurchase order mediation scenario we borrow a case study from slightly revised to better show the peculiarities of our method.
the case study concerns the so called purchase order mediation scenario from the semantic web service sws challenge2.
as stated in it represents a typical real world problem that is as close to industrial reality as practical... this scenario highlights 1e.g.
trans a b is the ips that takes aas input and gives bas output.
various mismatches that can be encountered when making heterogeneous systems interoperable .
the scenario considers two nss implemented using different standards and protocols theblue service bs and the moon client mc .
figures and show the ipss of mc andbs respectively.
the box that encloses the transition system corresponds to the protocol interface.
labelled arrows pointing at the interface correspond to inputs whereas departing arrows are outputs.
bothmc andbsdo not perform hidden actions.
moon client mc login createorder selectitem setitemquantity closeorder confirmitem close paythirdparty login createorder selectitem setitemquantity paythirdparty close confirmitem closeorder fig.
.
mc moon client interaction protocol mc orders products by assuming to interact with a moon service according to the following protocol mc performs authentication login to prove that it represents an authorized customer then an order can be created createorder by starting from an empty cart and individual items can be added to it.
thus an item is selected selectitem by also specifying the needed quantity setitemquantity .
mc is asked from the moon service to confirm the addition of the item to the order closeorder followed by confirmitem .
finally the order payment is asked by a third party payment system paythirdparty so as the order can be closed close .
bs is a service for purchasing orders.
a client initiates an order startorder and adds items to it additemtoorder .
for each added item bs asks its clients to confirm the item addition getconfirmation and then to place the order placeorder .
finally a client can quit the session quit .
blue service bs startorder additemtoorder getconfirmation placeorder quit getconfirmation startorder additemtoorder additemtoorder quit getconfirmation placeorder fig.
.
bs blue service interaction protocol mc cannot communicate with bs due to the following protocol mismatches of two different types.
communication mismatches concern the semantics and granularity of the protocol actions.
for instance a client of bs provides its identifier while placing the order whereas mc has to authenticate before performing any operation.
furthermore bsprovides a single operation to add an item with the needed quantity to the order whereas mc expects to use two different operations one for the addition and one for the quantity specification.
to solve these kind of mismatches it is necessary to assume and use ontology knowledge in order to align the two protocols to the same concepts and language.coordination mismatches concern the control structure of the protocols and can be solved by means of the mediator that can mediate the conversation between the two protocols so that they can actually interact.
for instance bs requires its clients to confirm the ordered items and then place the order whereasmc expects to confirm the ordered items only once the order is placed.
finally bsallows the addition of several kinds of items in the same order whereas mc performs the addition of only one kind of item per order.
as stated in mc andbs are provided by the sws challenge organizers and can not be altered although their description may be semantically enriched .
in particular in by exploiting an ontology in the domain of purchase processes the description of both mc andbshas been semantically enriched.
this domain ontology is denoted bydo and shown in figure .
do shows the relations holding between the various concepts used by mc andbs as purchase order systems.
typically ontologies account for two fundamental relations between concepts subsumption and aggregation .
a concept aissubsumed by a concept b in a given ontology o if in every model of othe set denoted byais a subset of the set denoted by b. a concept a isan aggregate of conceptsb1 b nif the latter are part of the former.
it is worth to mention that our use of the ontology concept is specific of the connect project this work is part of .
thus in the following we will exploit these notions to our purposes.
that is concepts in do correspond to ns input output actions.
the two relations between concepts are then used to account for the granularity of the data that define the structure of the messages exchanged by the respective input output actions.
for example the message associated to the request of additemtoorder is an aggregate of the messages associated to the requests of selectitem and setitemquantity.
subsumption prop card objectproperty ontological relation owlclass ... ontological concept domain ontology do owlclass additemtoorder haspart some selectitem setitemquantity owlclass paythirdparty owlclass selectitem ispartof some additemtoorder owlclass setitemquantity ispartof some additemtoorder ispartof some ispartof some owlclass getconfirmation owlclass confirmitem owlclass placeorder owlclass closeorder owlclass createorder owlclass startorder owlclass login ispartof some ispartof some owlclass close owlclass quit ispartof some fig.
.
do domain ontology indeed in the current practice of ontology development one cannot expect to find a highly specific to the considered nss ontology as do.
the production of do involves the extension of a more general ontology in the domain of ecommerce.
this extension allows the definition of two specific ontologies that represent a semantic description for mc and bs respectively.
then do results from discovering mappings between these two ontologies.
note that nowadays there exist6several ontologies e.g.
for e commerce domains see at http that can serve as common descriptions of specific domains which can be shared among different applications.
furthermore they are expressed by using languages e.g.
owl daml oil rdf schema just to mention a few that allow ontology extension and automated reasoning for ontology mapping discovery .
iv.
s ynthesis of modular connectors a mediator has an input output behaviour not necessarily strictly sequential e.g.
for allowing reordering of messages and it is a reactive software entity harmonizing the interaction between heterogeneous nss by intercepting output messages from one ns and eventually issuing to another ns the co related input messages.
message co relations can be inferred by taking into account ontological information which is characterized as follows.
we recall that the following definitions apply in the scope of our problem that is defined by two nss enriched with the respective ips and ontologies as discussed in the previous section.
definition protocol ontology aprotocol ontology ois a triple co so ao whereco is the set of ontological concepts and it is partitioned into the two disjoint sets icoandocoofinput andoutput ontological concepts respectively.
soandaoare the subsumption and aggregation relations among concepts respectively.
the following properties hold co a co ico oco ico oco so ico oco ao ico ocn o n .
if a b 2sothen we write that ais subsumed by b and a b is a subsumption pair .
this means that the output bfrom a component cmust precede the input afrom a different component c0.
in other words since the set of data constituting ais a subset of those constituting b to build the message associated to a one needs to process the data contained in the message associated to bfirst.
a mediator that makescandc0able to interoperate would take bfromcand send as co related message atoc0.
if a b1 b n 2ao then we write that b1 b nare part of a. furthermore a b1 b n is an aggregation tuple andacan be built by merging the messages associated to b1 b n. thus a mediator would take b1 b nin any order and send aas the merge of them plus possible additional data explicitly specified in ofora.
we write that a protocol ontology o ico oco so ao isvalid for protocols pandrif and only if ico ai p ai r andoco ao p ao r. coming back to our case study let o ico oco so ao be the protocol ontology shown in figure then ico fconfirmitem paythirdparty closeorder startorder additemtoorder quitg oco fgetconfirmation login createorder selectitem setitemquantity placeorder closeg so f confirmitem getconfirmation closeorder placeorder g ao f additemtoorder selectitem setitemquantity quit close startorder login createorder g and it is a valid protocol ontology for mc andbs.
synthesis of communication mediators alphabet alignment automatic synthesis of coordination mediators .
.
2login createorder selectitem setitemquan5ty closeorder confirmitem close paythirdparty login createorder selectitem setitemquan5ty paythirdparty close confirmitem closeorder p startorder additemtoorder getconfirma2on placeorder quit getconfirma2on startorder additemtoorder additemtoorder quit getconfirma2on placeorder r placeorder closeorder closeorder placeorder startorder login login createorder createorder login startorder createorder owlclass additemtoorder haspart some selectitem setitemquan ty owlclass paythirdparty owlclass selectitem ispartof some additemtoorder owlclass setitemquan ty ispartof some additemtoorder ispartof some ispartof some owlclass getconfirma on owlclass confirmitem owlclass placeorder owlclass closeorder owlclass createorder owlclass startorder owlclass login ispartof some ispartof some owlclass close owlclass quit ispartof some do w wi wj startorder selectitem setitemquan0ty closeorder confirmitem close paythirdparty startorder selectitem setitemquan0ty paythirdparty close confirmitem closeorder p wrapped by w startorder additemtoorder getconfirma2on closeorder quit getconfirma2on startorder additemtoorder quit closeorder r wrapped by w m mk selectitem setitemquan ty setitemquan ty selectitem setitemquan ty selectitem selectitem setitemquan ty mx paythirdparty paythirdparty paythirdparty paythirdparty my 1automatic synthesis of communication mediators fig.
.
overview of the method in sections iv a and iv b we formalize our synthesis method as organized into two phases respectively.
they are performed only if the protocol ontology is valid.
before going into the details of the two phases we give an overview of them.
figure pictorially shows the phases as roundedcorner rectangles with their related input output artefacts.
the numbers denote the order in which the phases are carried out.
the first phase splits into two sub phases 1and1 it takes as input a domain ontology do for ipsspandr and automatically synthesizes a set w ofcommunication mediators cms .
cms are represented as terms in ap a and they are responsible for solving communication mismatches as defined in section iii.
in particular the cms in ware used as wrappers for pandrso to align their different alphabets to the same alphabet.
roughly speaking the goal of this phase is to make two heterogeneous protocols speak the same language.
to this aim the synthesized cms translate an action from an alphabet into a certain sequence of actions from another alphabet.
however despite the achieved alphabet alignment coordination mismatches as defined in section iii are still possible the second phase is for solving such mismatches.
the synthesis of coordination mediators coms is carried out by reasoning on the traces of the wrapped p andr.
as detailed in section iv b for all pairs of traces if possible a com that makes the two traces interoperable is synthesized as a term in ap a .
the parallel composition of the synthesized coms represents under alphabet alignment the correct modular connector for pandr.
a. automatic synthesis of communication mediators our method synthesizes cms by defining the semantics of subsumption pairs and aggregation tuples in terms of ipss.
we do this by exploiting the primitives and operators of ap a 7hence following a modular approach.
cms align different alphabets of two protocols according to the defined ontological relations figure .
for instance the cms for the case study introduced in section iii are m1 jsplit getconfirmation cons x1 k m2 jsplit placeorder cons x2 k m3 jtrans selectitem x trans setitemquantity x prod x5 merge additemtoorder k m4 jtrans close x prod x7 merge quit k m5 jtrans login x trans createorder x prod x10 merge startorder k. definition semantics of subsumption pairs leto co so ao be a protocol ontology the semantics of a b 2sois given by jsplit b cons x k. definition semantics of aggregation tuples leto co so ao be a protocol ontology the semantics of a b1 b n is given by jtrans b1 x1 trans bn xn prod xn merge a k. for the purposes of alphabet alignment when synthesized out of a subsumption pair a b a cm is used as a wrapper for the outputbof a protocol .
instead when synthesized out of an aggregation tuple a b1 b n a cm is used as a wrapper for the input aof a protocol .
thus we define a further derived composition operator called wrapping .pcan be wrapped by ron actionaif and only if pandrare composable a2 common p r andris a cm.
definition wrapping of an ips the wrapping of pby a cmr on actiona is an ipsp ar ai p r ao p r ah p r sp ar s0 p p ar where sp ar sp sr p ar p r nf s a s0 js s02 sp sr g f p s0 r s0 r j p a p0 p r s0 r a is not definedg f r p0 p0 j p a p0 p r6 s0 r r r a is definedg f p r0 r0 j p a p0 p r s0 r a is definedg.
definition alphabet alignment givenpandrto be mediated let o co so ao be the valid protocol ontology specification for pandr.
let s1 s nbe the cms synthesized according to so and leta1 a hbe those synthesized according to ao.
the algorithm for the alphabet alignment step is as follows procedure alignment input p r o s1 sn a1 ah output alignedprotocols alignedprotocols foreach j ai p ao aj6 ao aj fag do p p aaj end for foreach k ao p ai sk6 ai sk fbg do p p ask7 end for alignedprotocols alignedprotocols fpg foreach j ai r ao aj6 ao aj fag do r r aaj end for foreach k ao r ai sk6 ai sk fbg do r r ask end for alignedprotocols alignedprotocols frg return alignedprotocols it is worth to note that after having performed the procedure alignment pandrhave the same alphabet of actions except for possible third party and hidden actions.
hereafter given a setwof cms and a protocol p we denote with p wthe protocolpwhose alphabet has been aligned by means of the cms inw.
coming back to our case study after having performed the alphabet alignment step the protocol of bsbecomes the one shown in figure .
the protocol of mc does not change.
login selectitem confirmitem closeorder close confirmitem blue service bs after alphabet alignment confirmitem closeorder login createorder selectitem setitemquantity close createorder createorder login selectitem setitemquantity setitemquantity selectitem resp.
setitemquantity setitemquantity resp.
selectitem fig.
.
bs after the alphabet alignment step however we recall that cms are not able to solve all mismatches such as coordination mismatches.
for instance although the two protocols shown in figures and share the same alphabet of actions their interaction can still exhibit some mismatches.
they are due to i messages sent received in a different order see the sequences made of confirmitem andcloseorder ii thirdparty messages paythirdparty and iii extra missing sends corresponding to redundant messages possibly also coming from looping cyclic behavior e.g.
selectitem and setitemquantity .
thus in general the construction of coms that can delegate receive3 consume produce and reorder messages is required.
b. automatic synthesis of coordination mediators given two protocols to be mediated pandr whose alphabets have been aligned our method produces their respective sets of traces.
pandrare prefix closed and hence their sets of traces are finite.
furthermore possible loops cycles are consideredktimes where kis a parameter of our synthesis algorithm .
this means that our method produces finite sets of finite traces.
we recall that by definition possible hidden actions are not represented within a considered trace.
3to from a third party.8hereafter we denote with tr p ktheset of traces ofp where for each trace cycles loops are considered ktimes.
as it will be clear later in this section once tr p kand tr r khave been generated for all tp tr 2tr p k tr r k our method tries to synthesize a com that makes the protocols corresponding to tpandtrable to interoperate.
if no mediator has been synthesized then a modular connector forpandrdoes not exist.
otherwise a non empty set of coms is produced.
indeed considering all pairs in tr p k tr r kis not needed.
it is sufficient to consider only the subset of pairs of semantically related traces.
traces tpand trare semantically related if every action that does not belong to their set of common actions is a third party action.
definition pairs of semantically related traces givenpandrto be mediated let kbe an integer such that k tp tr 2tr p k tr r kis apair of semantically related traces if and only if the following conditions hold a2atpnatr t2tr r kntr a2at a2atrnatp t2tr p kntp a2at.
we denote with p r k thek bounded set of pairs of semantically related traces for pandr.
before continuing our formalization definition deserves some discussion.
it formalizes a strong notion of semantic co relation for traces.
for instance let us consider traces tp andtras shown in figure .
they are not semantically related because both actions eandfare in the set of common actions ofpandrand hence cannot be considered as third party actions although are not common for tpandtr.
b c p d a b f e a f a a r b c d e f e b d c e c d f tp tr fig.
.
tpandtr two traces that are not semantically related however note that a way of mediating tpandtrexists e.g.
by re ordering aandband producing eand afterwards f. this mediation logic is correct only if eandfare independent fromaandb and a causality dependency is defined for f ande e.g.
the production of fdepends on the production ofe.
otherwise e.g.
the production of edepends on the production of f it could result in an inconsistent mediation.
note that the relations defined in the protocol ontology do not necessarily represent all the possible causality dependencies.
they are those related only to the semantics and structure of the exchanged data.
that is causality dependencies related to the control structure and hence depending on the protocol semantics could not be represented.
thus despite theexistence of a protocol ontology without further information about protocol actions and their causality dependencies one cannot in general know how to correctly mediate tpand tr.
the safest choice that one can take while synthesizing coms is to discard this pair of traces.
however to avoid inconsistencies discarding a pair of traces means that the com being synthesized has to consume all the outputs from the two traces.
in other words although this strong notion of semantic co relation leads to synthesize correct modular connectors i.e.
that do not introduce inconsistencies the synthesized connector might constrain too much the set of interactions on which the two protocols are made able to interoperate hence possibly under using them.
to avoid this problem we can consider a weak notion of semantic co relation.
this notion assumes the existence of a specification of the desired coordination protocol that the com to be synthesized should satisfy.
for instance by referring to the example depicted in figure the coordination protocol specification could express that emust always precedesfor equivalently that fmust be always eventually performed after e. for space reasons we do not formalize this weak notion of semantic co relation and hereafter we consider only the notion formalized by definition .
continuing the formalization of our method for each tp tr p r k the method computes the so called difference pair t0 p t0 r .t0 p resp.
t0 r is a sub trace of tp resp.
tr representing in a single sequence the sequences of actions in which tp resp.
tr differs from tr resp.
tp .
due to the alphabet alignment finding a com for tpand trmeans finding a com for t0 pandt0 r. sincetpandtr are semantically related their possible hidden actions have been removed and their loops cycles are considered ktimes t0 pandt0 rcan be different for three reasons only i they have unshared actions i.e.
third party inputs outputs ii they exhibit extra missing sends i.e.
redundant messages possibly also coming from looping cyclic behavior and iii they have complementary shared actions that appear in a different order.
by means of the coms to be synthesized the first ones should be received by a third party resp.
an ns and delegated to the receiving ns resp.
third party the second ones should be produced consumed and the third ones reordered.
definition coordination mismatches resolution letwbe the set of synthesized cms for protocols pandr and valid protocol ontology o. letkbe the bound considered for the length of possible loops cycles in p wandr w. the algorithm for the coordination mismatches resolution step i.e.
the automatic synthesis of coms is as follows procedure coordinationmismatchesresolution input p w r w k output coordmediators coordmediators foreach tp w tr w p w r w k do computes the difference pair t0 p w t0 r w of tp w tr w foreach a2 at0 p wnat0 r w at0 r wnat0 p w do coordmediators coordmediators fthirdparty a g96 remove afrom either t0 p wort0 r w end for ifjt0 p wj6 jt0 r wjthen foreacha2at0 p w at0 r wthat appears more than once in either t0 p wort0 r wdo coordmediators coordmediators fextraormissing a g remove afrom either t0 p wort0 r w end for end if ift0 p w6 t0 r wthen coordmediators coordmediators freorder a t0 p w t0 r w g coordmediators coordmediators freorder a t0 r w t0 p w g end if end for foreach tp w tr w p w r w k do coordmediators coordmediators discard tp w tr w p w r w end for return coordmediators where thethirdparty extraormissing reorder and discard sub procedures are defined as follows procedure thirdparty input a output mediator mediator jtrans a a0 k return mediator procedure extraormissing input a output mediator ifais an input action then mediator jprod a k else mediator jcons a k end if return mediator procedure reorder input a t0 p w t0 r woutput mediator alist ptuple foreach a2at0 p wdo ifais an output action then addaas last element of alist addt0 r w a as last element of ptuple end if end for mediator order alist ptuple alist0 where alist0 a0 a0 n andalist mediator jmediator k return mediator procedure discard input tp w tr w p w r w output mediators foreach a2atp w atr w a2ao p w ao r wdo mediators mediators fjcons a kg end for return mediatorscoming back to our case study the synthesized coms are m6 jtrans paythirdparty paythirdparty0 k m7 jorder k m8 jorder k m9 j prod selectitem k m10 j prod setitemquantity k m11 j cons confirmitem k. by referring to definition the modular connector for our case study is given by the following composition of coms m m6jj jjm11 plus the set w fm1 m 5gof cms used for the alphabet alignment.
as formally shown in the next section under alphabet alignment mis a correct connector i.e.
bothp w mjj r w andr w p w jjmhold.
v. c orrectness and connector evolution by taking into account hidden actions and denying broadcast communication as done in the ia theory described in can be used to synthesize via a quotient operator a monolithic connector msuch thatg pjjmjjr i.e.
m g pjjr .
the formal definition of gis out of the scope of this work.
for the purposes of this section it is sufficient to say that gis an ips representing the connected system goal which explicitly models three crucial conditions for correct communication and coordination c1 pjjmjjris not permitted to generate any inconsistencies c2 pjjmjjris only permitted to deadlock when all p m andrdeadlock and c3 pjjmjjrmust satisfy the constraints imposed by the given protocol ontology.
stating correctness of our synthesis method means showing that a modular connector msynthesized for protocols pand ris such that c1 c2 and c3hold under alphabet alignment.
however note that c2andc3trivially hold by construction.
in fact when composing in parallel protocols the only possibility to have sink states concerns scenarios in which none of the protocols is willing to perform any action c2 and cms ensure alphabet alignment c3 .
thus in this section by considering was the set of synthesized cms we focus on proving that p wjjmjjr wis free from inconsistencies i.e.
it is defined c1 .
to do this we can exploit definition hence checking both p w mjjr wandr w pjjm w. theorem correctness under alphabet alignment letmbe a modular connector synthesized for aligned protocolsp wandr w then the following properties hold p w mjjr w and r w p wjjm.
proof to prove we must prove that i ai p w sem ai mjjr w ao mjjr w semao p w and ii there is an alternating simulation from mjjr wtop w withs0 p w s0 mjjr w. by construction ai m ao p w ao r wandao m ai p ai r. furthermore common m r w is given by the union set of ao r wand a subset of ai r w. thus by definition of complement operator for ipss it follows that both ai p w semai mjjr wandao mjjr w semao p whold.
to prove ii we have to show that ii.
ii.
and ii.
of10definition hold where pandrhave been replaced with p wandmjjr w respectively.
let us assume that ii.
does not hold.
this means that p w would perform an output actionxthat is not consumed by m. this is a contradiction since by construction malways consumes output actions from bothp w andr w .
analogously if ii.
would not hold thenmjjr wwould produce an output action that does not match any input action of p w .
again this is a contradiction becausemjjr wproduces output actions only when there is the need to match an input from r wwith an input from p w. ii.
directly follows from the previous considerations hence recursively propagating the alternating simulation relation frommjjr wtop w. the proof of is analogous and hence for space reasons we omit it.
concerning the ability for modular connectors to evolve in response of changes the most interesting scenario is related to changes at the level of the protocol ontology.
in fact syntactic changes at the level of the nss interface directly correspond to a relabeling of mediator inputs outputs and related concepts in the ontology.
we recall that the synthesis of coms deals with sets of traces.
thus changes at the protocol level imply to re iter the synthesis step on the affected traces only hence accordingly changing the corresponding mediators.
however in the worst case i.e.
all the traces of a protocol share at least one action the entire synthesis step must be repeated.
as an example of a possible change at the level of the protocol ontology let us go back to our case study and apply the following modification to the ontology oshown in figure so so f additemtoorder selectitem additemtoorder setitemquantity gandao ao nf additemtoorder selectitem setitemquantity g. although simple this change highlights the effectiveness of our decomposition with respect to supporting connector evolution.
in fact to address the applied change it is sufficient to reason compositionally at the level of the algebra based description of the modular connector mand related setwof cms instead of reasoning in terms of its underlying ia based monolithic representation.
in particular by just looking at the mediators interface one can easily recognize that the cm affected by the proposed change is m3 whilem8 m9 andm10are the affected coms.
due to the fact that the aggregation tuple additemtoorder selectitem setitemquantity has been removed by ao m3is removed as well.
in place of it two cms m3 j split selectitem cons z k andm3 j split setitemquantity additemtoorder k cons k k are synthesized due to the addition tosoof the above considered subsumption tuples.
furthermore we recall that the ips of bs has been modified in order to align its alphabet to the one of mc.
to reflect the change on the performed alphabet alignment a trace in tr mc kthat contains selectitem and orsetitemquantity is modified by considering the following substitution fadditemtoorder selectitem additemtoorder setitemquantity g. analogously a trace in tr bs kthat contains either the sequence hselectitem setitemquantity iorhsetitemquantity selectitemiis modified by replacing any of these sequences withadditemtoorder .
according to the new alphabet alignment m8is removed and in place of both m9andm10 the com j prod additemtoorder kis synthesized.
note that in the monolithic connector selectitem and setitemquantity would always appear one after the other and modifying the connector according to the applied change would mean to solve again the entire quotient problem.
vi.
r elated work interoperability and mediation have been investigated in several contexts among which integration of heterogeneous data sources architectural patterns patterns of connectors web services and algebra to solve mismatches .
for space reasons we discuss only the works from the different contexts closest to our method.
the interoperability mediation of protocols have received attention since the early days of networking.
indeed many efforts have been done in several directions including for example formal approaches to protocol conversion like in .
the seminal work in is strictly related to the notions of mediator presented in this paper.
compared to our connector synthesis this work does not allow to deal with ordering mismatches and different granularity of the languages solvable by the split and merge primitives .
recently with the emergence of web services and advocated universal interoperability the research community has been studying solutions to the automatic mediation of business processes .
however most solutions are discussed informally making it difficult to assess their respective advantages and drawbacks.
in the authors present an approach for formally specifying connector wrappers as protocol transformations modularizing them and reasoning about their properties with the aim to resolve component mismatches.
in the authors present an algebra for five basic stateless connectors that are symmetry synchronization mutual exclusion hiding and inaction.
they also give the operational observational and denotational semantics and a complete normal form axiomatization.
the presented connectors can be composed in series and in parallel.
although these formalizations supports connector modularization automated synthesis is not treated at all hence keeping the focus only on connector design and specification.
in the authors use a game theoretic approach for checking whether incompatible component interfaces can be made compatible by inserting a converter between them which satisfies specified requirements.
this approach is able to automatically synthesize the converter.
in contrast to our method their method needs as input a deadlock free specification of the requirements that should be satisfied by the adaptor by delegating to the user the non trivial task of specifying that.
in other work in the area of component adaptation it is shown how to automatically generate a concrete adaptor from i a specification of component interfaces ii a partial11specification of the components interaction behavior iii a specification of the adaptation in terms of a set of correspondences between actions of different components and iv a partial specification of the adaptor.
the key result is the setting of a formal foundation for the adaptation of heterogeneous components that may present mismatching interaction behavior.
assuming a specification of the adaptation in terms of a set of correspondences between methods and their parameters of two components requires to know many implementation details about the adaptation that we do not want to consider in order to synthesize a connector.
vii.
c onclusions and future work in this paper we formalized a method for the automated synthesis of modular connectors.
a modular connector is structured as a composition of independent mediators each of them corresponding to the solution of a recurring protocol mismatch.
we have proven that our connector decomposition is correct and by means of a case study we have shown how it promotes connector evolution.
an overall advantage of our approach with respect to the work in the state of the art section vi is that our connectors have a modular software architecture organized as a composition of fundamentals mediation primitives.
this supports connector evolution and automated generation of the connector s implementation code.
in particular we have recently released a first implementation of both the algebra primitives and the plugging operator.
this implementation is based on the use of enterprise integration patterns http and is developed through the apache camel framework because of the way a modular connector is structured the automatic generation of its actual code written in terms of our algebra implementation is viable and can be achieved with little effort.
we have started to show through its application to the real world case study presented in this paper that our method supports connector evolution.
as future work we intend to carry out a rigorous empirical investigation to confirm the results reported in this paper.
another future research direction concerns the ability to infer the needed ontological information out of the interface description of the two protocols rather than assuming it as given.