university of washington technical report uw cse unifying fsm inference algorithms through declarative specification ivan beschastnikh yuriy brun jenny abrahamson michael d. ernst and arvind krishnamurthy computer science and engineering school of computer science university of washington university of massachusetts seattle wa usa amherst ma usa fivan jabrah mernst arvind g cs.washington.edu brun cs.umass.edu abstract logging system behavior is a staple development practice.
numerous powerful model inference algorithms have been proposed to aid developers in log analysis and system understanding.
unfortunately existing algorithms are difficult to understand extend and compare.
this paper presents invarimint an approach to specify model inference algorithms declaratively.
we apply invarimint to two model inference algorithms and present evaluation results to illustrate that invarimint leads to new fundamental insights and better understanding of existing algorithms simplifies creation of new algorithms including hybrids that extend existing algorithms and makes it easy to compare and contrast previously published algorithms.
finally invarimint s declarative approach can outperform equivalent procedural algorithms.
i. i ntroduction understanding a system s behavior is a difficult development task that is required when a system behaves in an unexpected manner or when a developer must make changes to code they did not write.
logging and log analysis of captured system behavior is one of the most ubiquitous simple and effective tools for system understanding.
unfortunately the size and complexity of logs often exceed a developer s ability to navigate and make sense of the captured data.
for example production systems at google log billions of events each day these are stored for weeks to help diagnose errant future behavior .
model inference is one promising approach to help users make sense of large and complex executions.
the goal of modelinference algorithms is to produce a model typically a finite state machine that accurately and concisely represents the system that produced the log.
numerous such algorithms and corresponding tools already exist to help debug verify and validate systems .
unfortunately it is challenging to apply and build on top of this rich body of work.
this is because model inference algorithms are primarily expressed procedurally as algorithms that iteratively modify a representation of the log e.g.
a graph to infer and output a model that can be shown to a user.
the procedural specification of these algorithms makes them difficult to understand extend and compare .
understand.
for most algorithms it is difficult to understand which temporal and structural properties of the log are preserved in the inferred model.
for example if an inferred property minerpropertycompositionpropertyinstancescompositionfunctionlogpropertytypesinvarimint algorithmalgorithmspecificationmodelfig.
.
an overview of the invarimint approach.
an invarimint algorithm is parameterized by an algorithm specification which consists of a set of property types and a composition function.
the resulting invarimint algorithm is a modelinference algorithm it takes a log of traces as input and outputs an inferred model which describes the process that generated the input log.
internally the algorithm uses property types to mine property instances and then applies the composition function to the property instances to derive the model.
model of an email client requires each login event to be immediately followed by a check mail event a developer may wish to know whether that property is true for all traces in the log or is an artifact of the model inference algorithm.
.
extend.
it is difficult to modify or to compose existing model inference algorithms to create interesting hybrids.
for example a developer may use two inference algorithms one to model exceptional executions and another that identifies executions with sequences of library calls not observed during testing.
the developer may want to compose these two algorithms to generate a single model but combining the existing algorithms may require a complete algorithm redesign.
further it is difficult or impossible to exclude a specific instance of a log property from a specific invocation of the algorithm.
if a log has every login event followed by a check mail event and if the developer decides that this property is an artifact of an incomplete log the developer may want the model inference algorithm to not preserve this property.
however because a procedural algorithm definition does not explicitly specify properties such exclusions may be difficult.
.
compare.
previously published algorithms lack a common form to aid comparison and juxtaposition.
instead researchers must reason about pseudocode and work out complex proofs.
a declarative approach in which a model inference algorithm is specified in terms of log properties that the inferred model will satisfy allows researchers to for example identify 1university of washington technical report uw cse when two algorithms with vastly different procedural definitions produce models with identical or overlapping sets of properties.
this paper proposes invarimint a technique to specify modelinference algorithms declaratively .
invarimint has two key features it explicitly specifies the types of properties that will be enforced in the final model and it decouples the mechanism of property mining from property specification .
we illustrate the advantages of invarimint by specifying three procedural algorithms declaratively.
we find that invarimint alleviates the above problems .
understand.
invarimint expresses an algorithm in terms of the properties that the inferred model must satisfy.
with this formulation algorithms become more clear concise and comprehensible.
further this formulation makes evident certain complexities that may otherwise be hidden such as nondeterminism.
.
extend.
with invarimint it is easy to add remove and modify both the instances of properties in a specific inference execution e.g.
each login event must be followed by a check mail event and the types of properties the algorithm preserves e.g.
an event may only follow another event if it did so in the log .
new algorithms can be created and multiple algorithms can be trivially composed to create hybrid approaches.
for example the synoptic algorithm uses the ktails algorithm as a final coarsening step to derive a more compact final model.
synoptic s invarimint specification expresses this by simply merging the ktails property types into the synoptic specification.
.
compare.
invarimint makes it easier for those using and developing model inference algorithms to compare and improve on those algorithms.
for example algorithms with incomparable procedural definitions may enforce overlapping sets of properties on their inferred models.
invarimint makes this overlap evident.
a model inference algorithm outputs a model that accepts a formal language.
the model s language is smaller than s it is limited by certain temporal or structural properties that the algorithm mined from the log.
some of these properties may be explicit in the algorithm definition whereas others may be implicit and deeply hidden in the procedural definitions.
invarimint figure represents a model inference algorithm with the types of properties that are expected to be true of the inferred model.
invarimint mines instances of these properties from the log represents each property as a dfa and composes the dfas using standard dfa operations such as dfa union and intersection .
well understood work on formal languages allows invarimint to perform these operations efficiently and to produce minimal models .
to evaluate invarimint we applied it to two previouslypublished algorithms.
first we used invarimint to declaratively and exactly specify the well known ktails algorithm.
from our past experiences with ktails we know that this algorithm behaves non trivially on large log inputs.
for instance it is neither apparent which states will be merged nor what synthetic tracesthe final ktails inferred model will accept.
the invarimint formulation decomposes a ktails execution into a set of properties that are easy to inspect to better understand the characteristics of the final ktails inferred model.
the invarimint ktails specification also provides the user with more fine grained control over the execution of the algorithm the user may remove a particular merge by modifying a property instance without having to modify the algorithm implementation.
second we used invarimint to approximate synoptic .
synoptic is a more recent algorithm constructed with explicit log properties in mind.
although synoptic attempts to make certain properties explicit we found that it in fact preserves a set of implicit or hidden properties in its procedural declaration.
specifically synoptic allows a log event type to be immediately followed by another type only if such following occurred in the observed log.
for example synoptic forbids a login event from being immediately followed by a compose mail event if in the log login wasalways immediately followed by a check mail .
synoptic s procedural declaration does not allow this property to be removed altered or relaxed and hides this property from the user.
in contrast an invarimint formulation of synoptic makes this property explicit and allows a user to remove all properties of this type or to select individual instances of this property for specific log event types to enforce.
more importantly invarimint makes the algorithm s user and developer explicitly aware of the properties it enforces.
finally synoptic is a non deterministic algorithm.
depending on the order with which synoptic satisfies the mined log properties the algorithm might produce a different final model.
although our invarimint synoptic formulation is an approximation of synoptic its advantage is that it is deterministic and highly predictable.
in particular it is easier to check whether two different logs produce identical models.
as an added benefit the invarimint versions of ktails and synoptic with efficient property mining scale linearly with log size and greatly outperform their procedural counterparts.
the rest of this paper is structured as follows section ii uses an example model inference algorithm to explain the invarimint approach.
sections iii and iv present invarimint specifications of ktails and synoptic respectively.
section v discusses implications of our work.
section vi covers related prior research and section vii concludes.
ii.
t heinvari mint approach this section describes a model inference algorithm named simplealg and then overviews the invarimint approach by outlining the invarimint steps in specifying an example algorithm called simplealg.
sections iii and iv extend simplealg s specification to derive the ktails and synoptic algorithms.
a. simplealg a model inference algorithm s input is a log a set of traces of a system s execution.
each trace is an ordered sequence of events elements of a finite alphabet that occur during execution.
simplealg s output is a model a finite state machine whose language is a set of traces.
figure shows example input and 2university of washington technical report uw cse logincheckcomposesendlogout b output models1logins2s3s4checkchecklogouts6composesendlogincheckchecklogout a input logtrace trace s5logout fig.
.
a an example log of an email client with two traces.
b the model inferred with simplealg figure for the input log in a .
output.
the language corresponding to the model accepts all the traces in the log as well as other traces.
a model inference algorithm s goal is to infer a model that accurately describes and generalizes the log the extra accepted traces should be ones that are likely to be generated by the system that produced the log.
simplealg is a model inference algorithm.
it generalizes in the following way if simplealg ever observes an event e1to be immediately followed by an event e2in the log then whenever the system being modeled produces or consumes an e1event simplealg assumes that it is legal for the system to then produce or consume an e2event.
pseudocode for simplealg appears in figure .
in the generated model each state represents an event that has just occurred.
input log l let m new fsm model create states 5m.addstate init foreach trace tinl foreach event eint let y event type of e if m.hasstate sy m.addstate sy add transitions among the states.
foreach trace tinl add transition from init state to first event.
let f event type of first event in t m.addtransition src init dst sf label f for each pair of adjacent events add a transition between states of corresponding event types.
foreach event eint if e.hasnext let y event type of e let z event type of e.next if m.hastransition sy sz m.addtransition src sy dst sz label z output m fig.
.
procedural pseudocode of the simplealg algorithm.the model contains one state for each unique event type that occurs in the log plus one initial state.
the model contains a transition from the state for event type e1to the state for event type e2 with the label e2 iff there exists a trace in the log in which an e2event immediately follows an e1event.
figure a lists an email client log with two traces.
the event alphabet isflogin check mail shortened to check compose send logoutg.
figure b shows the model simplealg infers for this input log.
the model has six states one for each event type e.g.
s4 corresponds to compose plus the initial state s1 .
simplealg s models are compact the number of states is one more than the number of unique event types in the log which is independent of the total number of events in the log.
the running time is asymptotically linear in the size of the log.
the inferred model s language always contains every trace in the input log plus other traces simplealg deemed likely.
b. invarimint overview invarimint is an approach or a common language for describing model inference algorithms such as simplealg.
figure overviews the invarimint approach.
like other modelinference algorithms an invarimint algorithm takes as input a logof traces to be modeled and outputs a model .
the common language invarimint uses to specify an algorithm is a set of property types that describe properties to be mined from the log to derive property instances and a composition function that combines the mined property instances into a final model.
different model inference algorithms take different approaches to generalizing the traces in the log to infer traces likely traces that are not in the log.
what constitutes reasonable generalization is often subjective and depends on features of the system its environment and the specific development task that the model will be used for.
while typical model inference algorithms hard code these features as assumptions in their procedural definitions invarimint uses property types and the composieval logl hx a y bi true 8t2l 9b2b a!
b i nt 8b2b 9t2l a!
b i ntfalse otherwise a property type pfsm and eval compose pro p1 ... pr o pn minimize pro pi b composition functions1s2yxs3y x fig.
.
an invarimint specification of simplealg.
this is equivalent to the pseudocode in figure .
a the property type event xcan be immediately followed by an event from set y represented as a parameterized fsm pfsm and a corresponding evaluation function eval .
given an input log eval determines the validity of bindings of parameters in the pfsm to event types.
b the composition function which invarimint uses to compose a model from mined property instances.
3university of washington technical report uw cse ...s1s2checklogins3s1s2check logout composechecks3send loginsend login logout composesend check logout composesend login logout composepro p1pro p2sendlogin check logout composesend login check logout compose fig.
.
property instances mined by invarimint from the log in figure a based on property types in figure a .
prop1represents event login can be immediately followed by an event from set fcheckg .prop2represents event check can be immediately followed by an event from set fcheck logout composeg .
tion function to generalize the model inference process.
property types define desirable properties of the final model.
for example the simplealg inferred model preserves log properties such as event xcan be immediately followed by an event from set y .
a property type consists of a parameterized fsm pfsm an fsm with variable labeled transitions e.g.
top portion of figure a and an evaluation function to decide which bindings of pfsm variables to event types are valid in the log e.g.
bottom portion of figure a .
together the pfsm and evaluation function encode relationships between event types.
using these evaluation functions invarimint mines the log for property instances which are instantiations of the corresponding pfsm.
invarimint then combines the derived property instances into a model using the composition function e.g.
figure b .
theminimize procedure referenced in this composition is the fsm minimization algorithm which guarantees that the final model will be minimal.
we now illustrate invarimint on the simplealg example.
c. specifying simplealg with invarimint invarimint s formulation of simplealg has only a single property type event xcan be immediately followed by an event from set y .
figure shows the invarimint specification of simplealg.
figure a shows the property type a pfsm and an evaluation function .
the pfsm is an fsm with variable labels that accepts all traces that relate event xand a set of events y. the evaluation function defines which bindings of variables to log events result in valid property type instances.
we use ltl to compactly specify evaluation functions.
ltl statements use the operators always eventually until u and next .
for example the evaluation function in figure a returns true for event aand events set bwhenever acan be immediately followed by only events from bacross all traces in the log that is there is a trace for every b2band there is a b2bfor every trace such that eventually if we observe an aevent then we will observe a bas the next event.
by indicating how to evaluate a binding of xandyto event types the evaluation function specifies how xandymust relate an event of type xmust be immediately followed by one event from the set y. while all bindings can create property instances the evaluation function determines which instances are valid for a given log.
figure lists two of the property instances that are valid1 input log l property typeshpfsm eval 1i hpfsm n eval ni let props fg foreach property type hpfsm i eval ii foreach binding of variables in pfsm i b if eval i l b props props fpfsm i b g output props fig.
.
the generic property miner algorithm.
input property instances prop1 propn composition function c let model c prop1 propn output model fig.
.
the generic property composition algorithm.
for the log in figure a hx yi fhlogin fcheckgi and hx yi hcheck fcheck logout composegi.
in addition to these two property instances there are three others one for each of compose send and logout .
note thathlogout 0iis necessary to prevent allowing all events to follow logout in the inferred model.
finally invarimint composes property instances using the composition function in figure b to produce the final model.
for simplealg the composition function returns the minimized version of the intersection of the property instances.
therefore the resulting model is compact and includes only those traces that satisfy all of the mined property instances.
this final model is identical to the one produced by simplealg figure b .
this paper mostly focuses on composition functions that involve only intersections and minimizations but this limitation is not inherent to invarimint.
more complex functions may include unions set differences and other set operations.
for example an algorithm that uses positive and negative trace example may subtract the model of negative traces from one of positive traces.
d. invarimint benefits the invarimint formulation of simplealg provides three benefits over the simplealg pseudocode the invarimint formulation helps us understand the key properties of the final model derived with simplealg by decoupling these properties from the mining and composition procedures while the pseudocode mixes all three.
we can more easily add new constraints to the model by defining new property types and eliminate behavior from the model by omitting property instances.
for example if we do not want login to only be immediately followed by check we can simply omit prop1in figure .
we can and will extend the invarimint formulation of simplealg to construct invarimint specifications for ktails and synoptic.
the pseudocode for these algorithms looks completely different from simplealg s pseudocode yet the invarimint specification reveals that both ktails and synoptic are based on the same property type figure a used by simplealg.
the fact that all 4university of washington technical report uw cse input log l intk let m initial fsm model of traces in l let merged true while merged merged false foreach states s1 s2inm if s1 s2arek equivalent m.merge s1 s2 merged true output m fig.
.
the ktails algorithm.
section iii a defines k equivalence.
three algorithms share this property type is one of the insights gained from specifying these algorithms with invarimint.
invarimint s goal is not to produce models per se but rather to provide a common language for expressing or specifying model inference algorithms.
specifying different algorithms with the same language allows us to understand combine and compare the algorithms.
invarimint s common language is property types and composition functions.
once specified the resulting property mining and property composition procedures figure are straightforward.
figures and list the unoptimized pseudocode for these two procedures.
note that in practice both of these algorithms can be further optimized and tailored to specific choices of property types and composition functions.
next we describe and evaluate the invarimint specification of two previously published model inference algorithms ktails and synoptic.
iii.
e xpressing k tails with invari mint ktails is an extremely popular algorithm that has served as the basis for many modern model inference algorithms.
unfortunately there are many procedural descriptions of ktails and it is difficult to tell if they produce identical or different models.
this section defines the ktails algorithm section iii a demonstrates its invarimint declarative specification sectioniii b discusses the insights about ktails that invarimint reveals section iii b and reports on our empirical comparison of the procedural and declarative implementations of ktails section iii c .
a. ktails ktails is a state merging algorithm.
ktails takes a log and a parameter k. it represents the log as a dfa composed of linear sub dfas one per trace that are joined in a parallel fashion with a single initial state transitioning to the start of each trace and all traces finishing by transitioning to a single terminal state.
ktails then iteratively merges states in the dfa that are k equivalent .
two states are k equivalent if their ktails are identical.
a state s ktail is the set of strings of length kor b ktails k property typeeval logl hx a y b z ci true 8t2l 9c2c a b!
c i nt 8c2c 9t2l a b!
c i ntfalse otherwise s1s2yzxs4s3 x y z eval logl hx a y bi true 8t2l 9b2b a!
b i nt 8b2b 9t2l a!
b i ntfalse otherwise a ktails k property types1s2yxs3y x fig.
.
a ktails k property type.
a b ktails k property types.
each of these is equivalent to the pseudocode in figure for the specific value of k. shorter that map to valid paths starting from that state.
the algorithm terminates and outputs the model when no two remaining states are k equivalent.
figure lists the ktails pseudocode.
the intuition behind ktails is that if two execution points have identical k long sequences of observed events following them then those points likely represent the same program state.
therefore to infer a concise model ktails merges execution points that it considers to represent the same program state.
the process stops once all points deemed equivalent are merged.
the parameter kdetermines the size and generality of the inferred model a smaller kleads to more merges and produces more compact and more general models while a greater krestricts state equivalence.
in invarimint ktails we introduce a pre and a post processing step.
we modify each input trace to include an aandwsymbols at the start and end of each of the traces respectively.
after the property instances are composed into a final model we update states in the model with incoming atransition to be initial states update states with outgoing wtransition to be accept states and also remove all aandwtransitions from the model.
invarimint uses property types to capture tail equivalence and to specify ktails.
figure a lists the k 1property type for ktails.
for k invarimint requires two property types the property type for k 1in figure a and a new property type shown in figure b .
note that the property type for k 1ktails in figure a is identical to the can be immediately followed by property type in figure a .
this equality is not a coincidence the kparameter generalizes the can be immediately followed by property type to ksteps into the future.
the greater kis the finer the granularity of the properties ktails enforces.
for example the property type in figure b says that an event x followed by an event y must be followed by one any one of the events in the set z. in other words it corresponds to merging all x ytails together.
section v discusses in more detail the granularity of properties and how the wrong granularity may cause the algorithm to overfit to the input log.
an important feature of the invarimint ktails specification is 5university of washington technical report uw cse z z x0x1xi 1t0t1tixi 2t0... t1...xgtg 1tg tg eval logl ha0 ... ai ci true 8t2l 9c2c a0 a1 iai !
i c int 8c2c 9t2l a0 a1 iai !
i c intfalse otherwise fig.
.
the ktails k i property type.
that it is deterministic.
this feature helped us better understand the ktails algorithm and helped to reveal a bug in our procedural implementation which happened to be non deterministic.
b. comparing procedural and invarimint formulations of ktails the model produced by the ktails algorithm behaves identically to the model produced by the invarimint formulation of ktails.
next we formally define the ktails algorithm based on the formulation in and provide a proof of equivalence.
letskdenote the set of all strings of length kor less.
let a trace be a string over alphabet s fa wg and let a log lbe a set of traces each of which starts with an asymbol and terminates with the wsymbol.
let pflbe the set of all prefixes of strings inl.
we use p tto denote concatenation of string ttop and refer to tas the tail.
for example consider the log l faabcw aabw acdwg.
then the corresponding pfl faew aaw aabw aabcw acw acdwg.
and the string aabcw aa bcw in which bcwis a tail.
definition ktails fsm fktails .the ktails algorithm takes a log land an integer kas inputs and generates a ktails fsm fktails.
the states offktails correspond to equivalence classes of prefixes from pfl.
an equivalence class eis a set of prefixes such that p p0 2e 8t2sk p t 2pfl p0 t 2pfl that is all prefixes in a class ehave the same set of tails of length kor less and every prefix in pflis assigned to some equivalence class.
thetransition function dfor equivalence classes or states infktails is defined as follows.
given a state eiand a symbol a2s d ei a e 8p2ei where e is the equivalence class of p a. theinitial state offktails ise and an equivalence class ei is an accept state offktails if9s2l such that s2ei.
definition invarimint ktails fsm finvmint .for a log land an integer k letfinvmint be the fsm derived using the invarimint algorithm specified by the ktails k property types and the inputlogl.
we can express finvmint as a composition of property instances1 finvmint p1 p1 n1 pk pk nk where pi pj niare the property instances for the pfsm corresponding to ktails k i property type.
figure shows this generalized property type.
definition terminal rejection .letfbe an fsm.
fterminally rejects sif69tsuch that s tis accepted by f. observation .
finvmint does notterminally reject strings in pfl.
proof consider a string s2pfl.
choose a tail tsuch that s tis a trace in l. such a tail must exist since sis a prefix for some trace in l. by construction finvmint accepts all strings in l. therefore finvmint accepts s t 2l and does not terminally reject s. theorem invarimint specification of ktails is exact .for an input log land an integer k letfktails be the corresponding ktails fsm and let finvmint be the invarimint ktails fsm.
then the languages of the two fsms are equivalent or l fktails l finvmint proof we prove the two directions of equality in theorem separately.
l fktails l finvmint proof by contradiction assume that9s2l fktails ands62l finvmint .
because s62l finvmint there is a non empty set of rejecting non accepting property instances .
that is 8p2 s62l p .
letrbe the shortest prefix of sto be rejected by some property instance pi j2 with i k. now consider the prefix string r which is rejected by pi j. we can express rasr u afor some a2s.
the property instance pi j in figure can reject rin two ways 1a pi jrejects rby terminating in state xi because a62z.
in this case rmust be at least i 1symbols long and can be expressed as r v t0 ti a. consider the equivalence class ev e .
this class must be non empty because there exists a transition on t0from evtoe .
since evis non empty consider a prefix p2ev.
because i k and since t0 ti ais a tail of v by definition of equivalence classes p t0 ti a2pfl.
however because t0 timatches the tail corresponding to pi j a2z.
contradiction a62z .
1b pi jrejects rby terminating in xh h i and s r. note that the ltl formula of the general ktails property type evaluation function in figure mandates that each ambound totmmust be followed by some am 1in some trace.
since wis the last symbol in any trace it cannot be bound to any amin the evaluation function.
the above implies that 8g g i 1there is no transition onwintoxg.
since every trace terminates with w we can express 1we omit fsm minimization as it does not change the fsm s language.
6university of washington technical report uw cse rasr v w. but this contradicts pi jrejecting rin state xh since pi jcan only terminate on v win states xi 2orx0.
we have shown that pi jcannot reject rsince it cannot terminate onrin any non accepting states.
therefore by contradiction s2l finvmint andl fktails l finvmint .
l finvmint l fktails note that s2l finvmint implies that sis accepted by all property instances that make up finvmint .
lets a0 an.
by induction on kandn we will show that ifs2l finvmint then there exists a valid and accepting path of equivalence classes that corresponds to s and thus s2fktails.
base case k we prove this base case by induction on n assuming k .
base case n show that s a0 a1 a2 a a1 wmaps to an accepting path e0 e1 e2 e3infktails.
lete0 e .
since a2s there must be a property instance p1 j of the property type in figure a that binds t0toa.
this p1 jaccepts a a1 and therefore p1 jmust bind yto a set b such that a12b.
next the ltl formula corresponding to p1 jtells us that9t2l such that a!
a1 .
since ais the first symbol for any trace this means that a a1is a prefix for this t. since ais a valid prefix there must exist a non empty equivalence class e1 e .
e0has a transition to e1ona because ais a valid prefix for traces in l. now consider the string a1 w. since a1appears in some trace there must be a corresponding property instance p1 m. by the same reasoning as above p1 mbinds t0toa1and binds yto a setb0such that w2b0.
the ltl formula corresponding to p1 m tells us that9t02lsuch that a1!
w .
we can represent thist0ast0 p a1 w. note that p a prefix of t0 andahave identical tails namely fa1g.
by construction of fktails this means that pandabelong to the same equivalence class e1.
since p a1is a valid prefix there must exist an equivalence class e2 e and there must be a transition from e1toe2ona1.
finally we will use t0to construct e3.
since p a1maps to e2 there must be a transition on wtoe3.
this e3must be terminal because it contains the trace t0.
as a result we have constructed an accepting path e0 e1 e2 e3for the string s. inductive hypothesis n i assume that a0 aimaps to a valid path e0 ei.
show that a0 ai 1maps to a valid path e0 ei .
consider the string ai ai .
since aiappears in some trace there must be a corresponding property instance p1 j. by the reasoning in the base case p1 jbinds t0toaiand binds yto a set bsuch that ai 12b.
the ltl formula corresponding to p1 jtells us that9t2lsuch that ai!
ai .
we can represent this tast p ai ai .
based on our induction assumption there exists an equivalence class ei 1that corresponds to ai .
since the prefix pis followed by aiint pmust also map to ei .
therefore we can 50time s log length thousands of events ktails invarimint ktailsfig.
.
the running time of procedural ktails and the declarative invarimint version of ktails for different log input sizes.
the number of property instances true of the log was held constant at .
extend e0 ei 1with e0 iandei where e0 i e and ei .
inductive hypothesis k j we prove this by induction on n. we assume that the proof statement is true for k jand perform induction on nto show that the statement is true for k j .
base case n show that s a0 a1 a2 a a1 wmaps to an accepting path e0 e1 e2 e3infktails.
since k j finvmint includes property instances corresponding to the ktails k property type definition .
this means that we can re use the base case for k 1above and construct the path e0 e1 e2 e3corresponding to sinfktails in the same manner.
this construction also holds for k j .
inductive hypothesis n i assume that a0 aimaps to a valid path e0 ei.
show that a0 ai 1maps to a valid path e0 ei .
consider the string t ai j ai.
each symbol in tcorresponds to a property p for a particular kvalue that makes up finvmint and which accepts all of the symbols at the tail of tin front of the symbol.
for example ai jcorresponds to some property pj which accepts the tail ai j aioft.
using the base case construction of overlapping prefixes we construct a path e0 ei 1that corresponds to a0 ai .
c. empirical evaluation we implemented invarimint and the ktails algorithm in java and evaluated their relative performance in two experiments.
both experiments were executed on an os x .
machine with a .8ghz intel i7 processor and 8gb of ram.
in all experiments the bottleneck resource was the cpu.
our experiments used logs with tens of thousands of events.
from our previous studies we consider this to be a representative log size for logs generated by developers during debugging sessions.
in the first experiment we ran both algorithms on logs that ranged in size from 5k to 50k events but maintained a constant number of property instances per log.
each log ranged over an alphabet of event types and each log was partitioned into traces of equal length.
the number of property instances true for each log was held constant at .
we performed this experiment three times.
figure plots the average runtime of the three runs for each log size.
7university of washington technical report uw cse in the figure as the log size increases the standard ktails algorithm scales poorly because it needs to perform more merges.
the invarimint ktails algorithm maintains an almost constant running time.
this is because for a constant number of property instances invarimint ktails composes property instances in constant time composing property instances used in the experiment took about seconds.
although the time to mine property instances does increase linearly with log size it remains insignificant for a 50k event log all property instances are mined in under one second .
in the second experiment we varied the number of property instances for the log from to but maintained a constant log size of 25k events.
logs were drawn from an alphabet that had between and event types.
as above each run was repeated three times and figure plots the average for each set of three running times.
overall invarimint ktails had a lower running time than procedural ktails.
however the relative ratio between the two running times indicates that invarimint ktails scales worse than procedural ktails as the number of property instances increases.
overall we found that our declarative invarimint ktails implementation outperforms ktails on large logs with few property instances while procedural ktails scales better with increasing number of property instances.
iv.
e xpressing synoptic with invari mint this section describes the synoptic model inference algorithm formulates it with invarimint and evaluates the resulting formulation.
a. synoptic and its shortcomings synoptic is a model inference algorithm that explicitly infers properties from the log then constructs a model that satisfies them.2synoptic first infers an overly general model of the log which accepts too many traces.
then synoptic progressively refines the model until every trace in the language of the model satisfies specific properties mined from the log.
because synoptic models enforce these observed properties prior work has found that the models accurately describe the underlying system and can improve understanding and aid debugging .
the synoptic algorithm has four steps mine three kinds of properties from the log xalwaysfollowedby y whenever event xoccurs in a trace event yalso occurs later in the same trace xalwaysprecedes y whenever event yoccurs in a trace event xalso occurs earlier in the same trace and xneverfollowedby y whenever event xoccurs in a trace event ynever occurs later in the same trace .
build an initial model by merging all anonymous3states with the same outgoing event into a single state.
iteratively apply counterexample guided abstraction refinement cegar to derive a model that satisfies 2for simplicity and despite minor differences we use property where the synoptic literature uses the term invariant .
3synoptic uses an event based graph model with nodes representing event types and unlabeled edges representing observed event orderings in the log.
this model is equivalent to an fsm with anonymous states which is the model type we use in this paper.
1600time s property instancesktails invarimint ktailsfig.
.
the running time of procedural ktails and the declarative invarimint version of ktails for logs with different number of property instances.
the size of the log was held constant at 25k events.
all of the mined properties.
synoptic does this by model checking the current e.g.
initial model against the mined properties to find counterexample traces in the model s language which falsify one or more of the properties.
synoptic then traces the found counterexample in the model to find the first state responsible for falsifying the property and refines splits that state to remove the counterexample path.
synoptic repeatedly refines the model to eliminate counterexamples until it reaches a model that satisfies all of the properties.
finally to compact the model synoptic applies ktails k to the refined model but only performs a merge if it does not un satisfy any of the properties.
while empirically shown to help developers improve their system understanding and find bugs synoptic has two features that may cause its users difficulty.
first synoptic is non deterministic.
the order in which it resolves the counterexamples may affect the language of the final model it produces.
more generally the problem synoptic tries to solve is np complete so the non deterministic algorithm attempts to balance running time against the size of the final model.
if a user makes a change to the input log and synoptic produces a different model the user does not know if the input log difference explains the change in the returned model.
this makes it difficult to apply synoptic to verify a bug fix or to check how a new feature impacts the model.
second while significantly more efficient on large traces than ktail based model inference synoptic may still be slow.
this is because synoptic must maintain all of the parsed log traces in memory and it makes repeated model checking invocations and repeatedly traverses the model.
next we present an invarimint formulation that approximates synoptic.
we show that the invarimint algorithm resolves the above two issues of non determinism and performance and discuss insights that we gained about synoptic through this formulation.
b. modeling synoptic with invarimint synoptic s use of well defined properties simplifies the task of declaratively specifying it with invarimint each of the three 4in an event based model synoptic uses ktails k to merge nodes with identical event labels.
this is equivalent to ktails k in a state based model.
8university of washington technical report uw cse a x alwaysfollowedby y property typeeval logl hx a y bi true 8t2l a!
b i ntfalse otherwises1s2yx x y b x alwaysprecedes y property types1s2yxs3 x y eval logl hx a y bi true 8t2l b!
bua i ntfalse otherwise c x neverfollowedby y property types1yxs3s2 x y eval logl hx a y bi true 8t2l a!
b i ntfalse otherwise fig.
.
three of the four property types used by invarimint to model the synoptic algorithm.
figure a shows the fourth property type which captures synoptic s initial model.
mined properties in synoptic alwaysfollowedby alwaysprecedes and neverfollowedby has a corresponding property type shown in figure .
however while synoptic explicitly specifies some of the log properties that the inferred models will enforce its original procedural definition imposed a property that was unknown both to synoptic users and to us the researchers who developed the algorithm.
the process of specifying synoptic declaratively with invarimint revealed this property.
we found that the initial synoptic model is not captured by the three explicit properties and the invarimint formulation requires the additional immediately followed by property type which is exactly simplealg s property type figure b .
to compose synoptic property instances invarimint uses a composition formula that is similar to simplealg compose prop1 propn minimize minimize prop1 prop2 propn .
this composition minimizes intermediate models so as to maintain a small model in memory at runtime.
for a large number of property instances this composition yields a faster algorithm.
next we evaluate this invarimint formulation of synoptic.
c. theoretical evaluation we were already intimately familiar with synoptic.
nonetheless when we modeled synoptic with invarimint we discovered a new feature demonstrating how invarimint can improve algorithm understanding.
the invarimint formulation of synoptic is in fact an approximation of the synoptic algorithm.
a key invarimint synopticsynopticmodel 1synopticmodel 2logfig.
.
the inclusion relationships between an input log the language of the model derived from the log with invarimint synoptic and the languages of two potential non deterministically derived synoptic models for the log.
feature of synoptic models is that they have no spurious transitions.
that is every transition in the model is associated with some event in the log there are no uncovered or spurious transitions.
the reason for this feature is that synoptic models are defined in terms of traces a transition between two states in the model exists only if there are two observed states in the log that map to the model states and have this transition.
invarimint models on the other hand are specified in terms of event types so the particular trace specific constraints are absent from an invarimint model unless they are explicitly specified with property types.
therefore invarimint models may contain spurious transitions.
figure summarizes the relationships between the language of the model derived using an invarimint formulation of synoptic the languages of possible non deterministically derived synoptic models and the input log.
the invarimint formulation is more permissive than synoptic and includes the language of all possible nondeterministically derived synoptic models.
here we prove that a synoptic model s language is a subset of the model derived using invarimint synoptic algorithm.
we also show that the invarimint model does not satisfy any synoptic property instances that are not true of the input log.
this result is analogous to theorem in .
theorem invarimint specification of synoptic encompasses synoptic .letlbe a log.
let fsynoptic andfinvmint be the fsms produced by the synoptic algorithm and the invarimint synoptic algorithm on l respectively.
let l fsynoptic andl finvmint be the languages of those models.
then l fsynoptic l finvmint .
proof lettbe a trace in l fsynoptic .
by construction synoptic terminates when all traces accepted by its inferred model satisfy all instances of the alwaysfollowedby alwaysprecedes and neverfollowedby property instances mined from l. therefore tmust satisfy all such property instances.
consider each of the property instances intersected to form finvmint .
first each property instance of the three types described in figure is mined from l and therefore must be true in each trace in l. since tsatisfies all such property instances the language of each of these instance fsms must contain t. second each property instance of the type described in figure a accepts all traces whose transitions are pairs of consecutive events observed in l. since each transition in finvmint maps to at least one pair of consecutive events in at least one trace in l a property instance fsm must accept t. since every property instance intersected to form finvmint accepts t t2l finvmint .
therefore l fsynoptic l finvmint .
9university of washington technical report uw cse 50time s log length thousands of events synoptic invarimint synoptic fig.
.
the running time of procedural synoptic and the declarative invarimint version of synoptic for different log input sizes.
the number of property instances true of the log was held constant at .
theorem models produced by invarimint synoptic do not include false property instances .letlbe a log and let finvmint be the fsm produced by the invarimint synoptic algorithm on l. more specifically let f invmint compose p1 pn .
letpf alse be a setof property instances such that 8pf2 pf alse pfis an instantiation of some synoptic property type hpfsm evali such that9a binding bf pf pfsm bf and eval l bf isf alse .
that is pf alsecontains well formed property instances that are not true for the input log l. then8i pi62pf alse.
proof we present a proof by contradiction.
assume the opposite 9pi pi2pf alse.
since piis used to construct finvmint it must correspond to some property type hpfsm evali and by the pseudocode in figure 9b pi pfsm l b andeval l b istrue.
however by definition of the set pf alse eval l b must be false.
contradiction.
as discussed in section iv a synoptic is non deterministic and executing synoptic on two similar logs may produce different models even when using identical random number generator seeds.
the invarimint formulation of synoptic removes this non determinism because fsm intersection and minimization are commutative.
this in turn makes it possible to use the algorithm to assist in other development tasks such as to verify a bug fix or to check how a new feature impacts the model.
d. empirical evaluation we compared the performance of procedural synoptic against the declarative invarimint synoptic implementation.
both algorithms are implemented in java and we use the same experimental setting as in the ktails experiments section iii c .
we carried out two experiments to compare algorithm performance across different log sizes figure and across logs with varying number of property instances figure .
as with the ktails algorithm figure indicates that the declarative version of synoptic outperforms procedural synoptic on large logs.
as the number of property instances increases in figure invarimint synoptic continues to outperform synoptic.
45time s property instancessynoptic invarimint synopticfig.
.
the running time of procedural synoptic and the declarative invarimint version of synoptic for logs with different number of property instances.
the size of the log was held constant at 25k events.
v. d iscussion although this paper has presented insights derived from expressing existing model inference algorithms with invarimint there are other benefits to the invarimint formulation.
if the model is used for model checking or runtime verification a declarative specification can be more efficiently checked e.g.
in parallel against a property and can yield more efficient runtime conformance checking of a trace.
a violated property instance can also be more helpful than a path counterexample in understanding why the property does not hold or why a trace does not conform to the model.
as an example of the generality and expressiveness of our approach an evaluation function may deem a property valid if it is true in most of the traces.
this can be useful when the properties are probabilistic or the log is incomplete as when it is not feasible to capture a log from a live online system s start of execution to its end.
for example some traces at the start may be missing the login event while others at the end may be missing thelogout event.
invarimint can still mine the property that all traces start with login and end with logout as long as an overwhelming fraction of the traces satisfy that property.
other kinds of property types include conditional properties e.g.
an event is present only if the username is root properties on resource usage e.g.
time or space and anomaly detecting properties e.g.
two events co occur rarely .
in this paper we use ltl to compactly specify evaluation functions.
as a result in all of the presented examples the pfsm could be automatically derived from the ltl the pfsm is a parameterized version of the b uchi automaton corresponding to the ltl formula.
however this is not possible for the alternative evaluation functions mentioned above as these cannot be expressed with ltl.
invarimint can be robust to specifications with overlapping or conflicting property types.
for example an evaluation function that intersects property instances will ignore overlapping property instances and will immediately reveal conflicting property instances as their intersection would be the empty set.
a. tips for declaratively expressing algorithms with invarimint first identify the right property type granularity.
do not simply simulate the procedural version of the algorithm with the 10university of washington technical report uw cse property types.
instead consider the properties that the procedural algorithm enforces.
property types that are too fine grained and too close to the input traces e.g.
union of positive example trace dfas lead to models that overfit the log rather than describe the algorithm.
property types can describe algorithm operations.
for example section iii showed how a single property type describes merging of all states with the same k tail.
if the procedural algorithm deals with positive examples of traces as both ktails and synoptic do starting from a formulation that produces a model that is a generalization of the desired model may be easier as this model may enforce fewer properties.
then refine this model towards the desired model by introducing new property types or by refining the existing properties.
if the procedural algorithm deals with both positive and negative examples of traces we have not shown such an algorithm in this paper consider building separate models one for the positive examples and one for the negative examples.
then in the composition function subtract the negative example model from the positive example model.
vi.
r elated work the ktails algorithm is the basis for numerous modelinference algorithms .
many of these algorithms can be modeled with invarimint to better understand extend combine and compare them.
at least two of the techniques require richer models than the standard fsm models we use in this paper.
gk tails requires efsms and rpni requires probabilistic fsms.
there are numerous algorithms to mine temporal properties like the ones we have used in this paper .
data value properties that relate internal program variables can encode method preand post conditions as well as class level properties.
automatically inferring these properties from program executions can improve model inference .
combining data value and temporal properties can improve scenario based specification mining .
recent work by gabel and zhendong can also be applied to validate property instances during an invarimint execution .
model inference frameworks can facilitate algorithm comparison .
however to date these frameworks have been used to compare model performance and accuracy not properties of model inference.
further much of the ktail based modelinference work compares the recall and precision of inferred models against manually specified ground truth models.
this process is manual error prone and again compares model quality as opposed to model inference properties.
model quality is a notoriously challenging aspect of model inference .
quark a comparison framework allows for comparing the quality of models generated by algorithms such as ktails and sk strings .
invarimint is complementary to these frameworks as it aims to unify model inference algorithms with a declarative specification language facilitating algorithm comparison and model property comparison.
non fsm model inference e.g.
of uml sequence diagrams communicating automata and symbolic message sequence graphs can also aid developer tasks.
some of thiswork is similar to ktails and we believe invarimint can be extended to accommodate such algorithms.
similarly invarimint may be extendable to other types of properties such as those used to infer behavioral models of web services .
walkinshaw et al.
propose a model inference technique in which the user provides a model inference algorithm with ltl formulae which are then checked by a model checker and are used as constraints on feasible state merges in the inference algorithm.
invarimint uses ltl differently.
our intent is generalize the specification of model inference algorithms.
to this end ltl formulae encode valid bindings of variables in a parameterized fsm to event types for a particular log input.
vii.
c onclusion model inference algorithms can automatically mine models of complex systems.
such models aid numerous development tasks such as program understanding and debugging.
unfortunately existing model inference algorithms are defined procedurally making them difficult to understand extend and compare to one another.
we have presented invarimint a declarative specification approach for model inference algorithms.
invarimint enables specification of algorithms in terms of the types of properties they enforce in the models they infer.
invarimint s declarative specifications provide insight into how inference algorithms work and how the model relates to the underlying system allow for easy extension of existing algorithms to construct hybrid alternatives and provide a common language for comparing and contrasting the essential aspects of model inference algorithms.
we demonstrated the benefits of invarimint by declaratively specifying two existing algorithms ktails and synoptic.
for example the invarimint versions of these algorithms greatly outperform their procedural analogs.
we look forward to applying invarimint s declarative approach more broadly and bringing these benefits to additional algorithms.
invarimint is available as an open source tool viii.
a cknowledgments we would like to acknowledge joseph devietti who proposed an early version of the invarimint idea in a conversation.
we also thank the anonymous reviewers for their helpful feedback.
invarimint is supported by google darpa grant fa8750 and nsf grants cns and ccf .
11university of washington technical report uw cse