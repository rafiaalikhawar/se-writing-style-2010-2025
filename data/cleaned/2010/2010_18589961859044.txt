eliminating navigation errors in web applications via model checking and runtime enforcement of navigation state machines sylvain hall universit du qu bec chicoutimi canada shalle acm.orgtaylor ettema chris bunch and tevfik bultan university of california santa barbara usa tettema cgb bultan cs.ucsb.edu abstract the enforcement of navigation constraints in web applications is challenging and error prone due to the unrestricted useofnavigationfunctionsinwebbrowsers.
thisoftenleads to navigation errors producing cryptic messages and exposinginformationthatcanbeexploitedbymalicioususers.
we propose a runtime enforcement mechanism that restricts the control flow of a web application to a state machine model specified by the developer and use model checking to verify temporal properties on these state machines.
our experiments performed on three real world applications show that our runtime enforcement mechanism incurs negligible overhead under normal circumstances and can even reduce server processing time in handling unexpected requests by combining runtime enforcement with model checking navigation correctness can be efficiently guaranteed in large web applications.
categories and subject descriptors d. .
design tools and techniques d. .
software program verification h. .
online information services web based services general terms theory verification keywords navigation web applications model checking this work was done when sylvain hall e was at the university of california santa barbara.
this work is supported by nsf grants ccf and ccf .
permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.
c129 http ok c50http get post c50action executionbootstrap script persistent session storagedatabase c130 c131action session idrequest parameters session variables c132 c133 c134 figure processing of an http request in an mvc web application.
.
introduction browser functionalities such as bookmarks and the back button allow users to request pages from web applications in unpredictable ways.
when incorrectly handled an unexpected request from the user can execute an unintended action produce a cryptic and confusing error message or even expose details about the application that can be exploited for malicious purposes.
in fact our experiments on real worldwebapplicationsdemonstratethatmorethanhal f of unexpected navigation sequences are not properly caught and processed by web applications.
the enforcement of navigation constraints is therefore a critical issue in web app lication development.
an increasing number of web applications are being developedusingthemodel view controller mvc designpattern through frameworks like zend ruby on rails and codeigniter.
mvc pattern facilitates the separation of contr ol flow logic controllers business logic and data model an d user interface logic view .
as a consequence mvc web applications break the concrete link between a uri and a specific resource residing on the server.
all incoming requests are rather directed to a single bootstrap script tha t parses and evaluates them and then determines the actions to execute see figure .
by clicking on a link in a page or by typing a url in the browser s location bar a user actually requests a new page on the application server through an http get or post request figure label .
this request is relayed to the application s bootstrap script.
based on the requested url the script extracts the name of the actionto beexecutedandany request parameters carriedinthehttp request if one of these parameters is an identifier called a session cookie the script also fetches from the server s persistent storage an additional set of session variables and their values .
all this data is then used to execute the action proper this may include back end database read and write access.
finally the application returns an outpu t pagebacktothebrowserasthehttpresponsetotheinitial request and possibly modifies the session information in the server s persistent storage .
by navigating through an mvc web application a user produces a sequence of triplets angbracketleftaction request parameters session variables angbracketright with each such triplet representing the information related to one button click on the browser.
we call such a sequence a navigation trace .
in a standard desktop application not all sequences of actions are considered valid.
for example it is nonsensical to call the save command if no document has been opened beforehand.
well designed products prevent such odd sequences by disabling or hiding from the user interface any menu items or buttons which do not make sense in the current state of the application.
in web applications however this is far more difficult to achieve.
even when the pages returned by an application after each request only provide links to valid actions from the current state the browser itself provides many ways of bypassing these measures through the use of the back button bookmarks multiple windows and the location bar where arbitrary urls can be typed.
none of these gui elements can be reliably disabled controlled or even hidden by a web application.
the task is made even more difficult by the http protocol which is by design stateless and treats requests independently of each other.
in an mvc application the handling of navigation constraints should clearly be the responsibility of the contro ller.
however mvc based applications do not fully exploit this feature.
in particular they do not support the enforcement of constraints across multiple controllers and actions an d they do not provide a mechanism to store the navigation history that is necessary to enforce these navigation constraints.
the developer therefore becomes responsible of writing customized mechanisms for these two features a tedious and cumbersome task.
in this paper we propose a solution to this problem with a runtime enforcement mechanism that restricts the control flow of a web application to a navigation state machine model specified by the developer by exploiting the existing structure of the mvc pattern.
we then use model checking to verify temporal properties of the navigation state machine itself.
we implemented our approach by developing a navigation state machine language for specification of navigation constraints a plugin for mvc style php applications that enforces the navigation state machine constraint s at runtime a translator that generates smv models from navigation state machines for model checking.
our experiments show that the runtime enforcement plugin incurs negligible overhead under normal circumstances and can even reduce server processing time when handling unexpected requests by avoiding the generation of error pages.
moreover with our runtime enforcement mechanism the verification of temporal properties about navigation can be done efficiently using model checking even on web applications containing more than lines of code.
.
na vigation errors although stateful web applications should keep track ofapplication modules controllers actions kloc digitalus bambooinvoice capstone table number of modules controllers actions and thousands of lines of php code for each of the three applications studied in this paper.
figure output of error in digitalus.
navigation traces and validate each request based on that history most of them do it partially if at all.
therefore i t is generallyeasyforausertoproducenon compliantsequences of actions that are improperly handled by a web application.
to illustrate this point we studied three real world appli cations see table digitalus11.
an open source content management system cms written using the php zend framework bambooinvoice20.
.
an invoice management system for small businesses written using the php codeigniter framework capstone manager a project management system used at ucsb written using the php zend framework.
below we describe examples where these applications erroneously handle non compliant navigation trace s producing what we call navigation errors classified according to the method by which they are created.
basic errors.
thisfirstcategorycorrespondstoerrorsthat can be reproduced by simply using the application s navigation links and possibly the web browser s back button and bookmark functionality.
a first example taken from digitalus involves the following sequence of steps error delete yourself .
login as any user say bob with superadmin status.
click on the site tab.
in the admin users sidebar click on bob to get to the user edit page.
click on delete in the top right corner.
bob is deleted from the user list yet you are still logged in as bob.
click on the browser s back button this will take you back to the edit page for bob which no longer exists.
the resulting page is shown in figure .
this navigation error has two consequences first the user interface is disrupted with php error messages in par1 236figure output of error in digitalus.
ticular the messages show the absolute location of apache s root directory on the web server.
this can be used e.g.
to deduce that the server is a windows xp machine running under the user sylvain off local drive d .
most importantly since the deleted user is the one that is actually logged in the application should immediately log out and redirect to the login page.
instead the deleted user is stil l logged in and has access to all administrative functions.
a similar error also exists in bambooinvoice.
a second example taken from the bambooinvoice application involves the browser s bookmarking functionality error edit a deleted invoice .
login to the system.
go to the invoice list and click on an invoice to get to the edit page.
bookmark this page.
go back to the invoice list by pressing the browser s back button.
click on delete invoice .
invoke the bookmark.
this summons a page with php errors similar to figure .
multi window errors.
as in the previous category these errors can be reproduced solely by using the application s and web browser s buttons however they require two different browser windows.
for example in digitalus error update a deleted page .
login in as an administrator and go to the pages tab.
select any page and right click on the link for this page in the pages tab at the right choose open the link in a new tab .
in the first window left click on the link for this page.
there are now two tabs containing the edit form for the same page.
in the first tab click on delete .
go to the second tab click on update .
the resulting page is shown in figure .
this navigation error involves even further disruption of the user interface.
this time the basic page template does not load at all and the user is presented with the white page that php generates in case of a fatal error.
similar errors can be created with bambooinvoice when trying in a first window to create an invoice for a user that was previously deleted in a second window.
direct url errors.
this type of errors are caused by typing a url in the web browser s location bar from the wrong context.
for example in digitalus error no user logged .
reproduce all the steps for error .
then try to return to the login page by typing admin in the browser s url bar.
this summons a php white fatal error page similar to figure .
error forbidden pages .
in digitalus typing any of the urls mentioned in figure either causes a page with php warnings similar to figure or a white page with php fatal errors similar to figure .
this time the problem lies in the fact that the application assumes that these pages are called from a previous page that gives values to some mandatory request parameters.
calling the page outside that context creates errors.
all in all we found different ways to cause warnings and fatal errors.
navigation constraints.
the previous examples show sequences of actions where the web application fails to realize that an action has been called in the wrong context.
most of the navigation errors presented above could be prevented by simply keeping track of the last triplet angbracketleftaction request parameters session variables angbracketright and by granting or blocking the execution of the requested action according to that triplet.
for example navigation error can be prevented by a checking that the session id is different from the user id in the delete request or b otherwise only allowing admin auth logout as the next page this also takes care of navigation error .
navigation error can be prevented by making sure that the edit action is only accessed if the last action is view with both actions having the same id parameter.
navigation error can be prevented by making sure that the page delete action is only accessed if the pre viouspageis pageedit .
finally thesolutionfornavigatio n error is similar for each page mentioned for example the problem for admin page edit can be solved by accessing it only from admin page new or admin page index.
inthefollowingsections weformallydescribetheproblem of navigation errors in web applications and introduce a mechanism to enforce navigation constraints like the ones above in web applications.
.
a formal model we formalize the global behavior of an mvc web application which we will simply refer as an application as follow s mis a set of data model states where the data model can include any stateful representation of application data such as a database vis a set of session variables i.e.
data stored on the server on a per client basis iis a set of sessions used by the server to associate clients with session variables ais a set of actions i.e.
the program segments that are invoked based on the http requests sent by the user pis a set of request parameters i.e.
input data from the user received as part of the http requests via get or post.
237to simplify our presentation we will denote the set of values a session variable or a request parameter can take as d. thestateof an applicationis uniquely defined by the combination of a model state and the valuations of the session variables for each session.
the requestsfrom the user on the other hand are used to uniquely identify a transition from one state of the web application to another state.
each request consists of an action and a set of request parameters.
definition .an application is a tuple a angbracketleftq b angbracketright where q m d i v is the set of states.
given a state q q we useq i v to denote the value of session variablev vfor session i iin stateq andq i to denote the vector vector v d v containing values of all session variables for session iin stateq.
b qis the set of initial or begin states where for allq bandi i q i v denotes null .
q a d p i qis thetransition function .
the function satisfies the following two constraints .
ifq prime q a vector p i then for any session j i j negationslash i q prime j q j .
.
ifq prime q epsilon1 p thenq prime i q i for any sessioni i. in an application each session can only change its own session variables as specified by the first constraint on the transition function .
the second constraint states that th e epsilon1 transition does not change any session variable and only accounts for changes in the data model state independent of any session activity.
we use the epsilon1 transition to represent the fact that a web application can update the data model state e.g.
the back end database without receiving a request from the user.
starting from an initial state q0 b a succession of tuples q0 epsilon1 p q1 a1 vector p1 i1 q2 a2 vector p2 i2 ...is called a global trace of aif for every k qk qk ak vector pk ik .
each element represents the current application state the previous action and the request parameters and the session for which the previous action was executed.
since there is no previous action in the initial state we use the epsilon1 transition as default in the first tuple of the trace.
our definition of a global trace implies that the actions are executed atomically.
this is not true in a real web application.
two actions from different sessions can be executing at the same time.
however the interleaved trace semantics we defined above is equivalent to such an execution for the following reasons session variables are disjoint and ea ch session only modifies its own session variables although the model is shared among the sessions it is typically managed through a database and conflicts and race conditions are resolved through the use of database transactions.
.
a simple example we define a simple web application based on the account management in digitalus to demonstrate our formal model.
the set of actions is a index open delete edit create wherethe indexaction returns a page that lists the available account managementoptions openreturns a page for editing deleting or creating an account and the remaining actions are self explanatory.
there is a single request parameter p rid denoting theidentityoftheaccountthattheuserwantstoexecutethe action on and there is a single session variable v sid denoting the identity of the current user.
the domain for these variables is d u v denoting two user accounts and the null value.
typically the data model would store detailed information about the user accounts and the edit action would require extra request parameters to update an account which are ignored in this simple example.
the set of sessions is i where does not correspondtoanactualsession .
givenastate qofthisapplication q sid identifies the user who initiated the session which would be set using a login action that is not modeled here .
a transition q prime q edit u corresponds to the accountubeing edited by the user who initiated the session .
another transition q prime q delete v corresponds to the account vbeing deleted by the user who initiated the session .
note that in this transition we would probably wantq sid negationslash vso that the user does not self delete.
in this paper we focus on navigation constraints that restrict the possible traces of individual sessions such as theedit deleteandcreateactions can only be executed immediately after an openaction.
for theopen delete andeditactions to be executed theridparameter has to be non null.
theridparameter and the sidvariable cannot be equal when deleteaction is executed.
.
session traces to express navigation constraints we need to define session traces that only track the actions request parameters and session variables of individual sessions.
to do this we define a function that projects a global trace to an individual session by removing all the session variables and actions of other sessions.
definition .let q0 epsilon1 p q1 a1 vector p1 i1 q2 a2 vector p2 i2 ...be a global execution trace of an application a andi ibe a session of a. let prime q0 epsilon1 p q prime a prime vector p1 prime i prime q prime a prime vector p2 prime i prime ...be the subsequence of the trace obtained by deleting all tuples qk ak vector pk ik from whereik negationslash iandk .
thenavigation trace for session iin denoted as i is the following sequence obtained from prime i q0 i epsilon1 p q prime i a prime vector p1 prime q prime i a prime vector p2 prime .... note that given an execution trace of a web application the session trace i lists only the actions executed by sessioniand the request parameters for those actions and it only keeps track of the session variables of session i. we define a navigation constraint as a constraint that can be specified using the information available in a session trace .
this definition has several benefits.
first it clearly separates constraints on the data model from the navigation logic.
second this separation enables us to enforce navigation constraints independently on each session without any interference from other sessions and without querying the state of the data model.
third since all the session trace information is visible to the bootstrap script as shown in figure we are able to develop a runtime enforcement 238open index edit delete createuser site r.id s.id c185 c94 c185r.id r.id r.id r.id c185 c94 r.id c185 c94 r.id c185 c94r.id c185 c94 r.id c185 c94 figure a portion of the navigation state machine for the digitalus system.
mechanism that does not require us to change any part of the application for navigation constraint enforcement.
.
na vigation state machines all solutions to navigation errors discussed in section have one point in common they can be represented by a finite state machine which takes into account the last executed action the session variables and the request parameters.
unfortunately analogous to the stateless nature of http mvc based web application frameworks lack mechanisms for tracking state.
each request is routed completely independently of history based purely on the content of the current request.
thus while the mvc framework vastly improves web application organization and control flow management it is left to the developer to implement any statefu l behavior that may be desired.
in this section we introduce a specification mechanism for characterizing stateful navigation behavior.
anavigation state machine nsm specifies the allowable execution orderings for actions.
its states correspond to ac tions and a transition from one state to another state indicates that the action in the target state can be executed immediately after the execution of the action of the source state this relation need not be deterministic .
additionally the transitions contain guard expressions that specif y the pre and post conditions for execution of an action on the session variables and request parameters.
definition .anavigationstatemachine nsm nis a tuple angbracketlefts s0 angbracketrightwhere s d v a d p is the set of states s0 v p is the initial state s a d p 2s is the transition relation.
a state of a navigation state machine stores the last action performed in a session and the request parameters for that action as well as the values of the session variables re sulting from that last action.
given the last action request parameters for that action and the current values of the session variables the transition relation of the nsm identifie s which actions and request parameters can come next in the session trace and how session variables can change by executing those actions.
figure shows an nsm for the account management example we discussed above.
it contains additional highlevel constructs that ease the representation of nsms and makes them less verbose.
first states are hierarchical ea ch super state corresponds to a module of the application an d each atomic state represents the last action that was executed.
for example if the nsm is in state open then this means that the openaction of the usermodule was the last action executed by this session.
this way one can use anarrow from the userbox to the indexstate to represent a group of transitions one from each action in usertoindex.
similarly a single openstate can be used to represent all combinations of session variables and request parameter s for that action.
the same goes for other actions.
the transitions specify pre conditions on the previous request parameters rid prime the current session variables sid and the current request parameters rid .
for example the arrow from state opento state deleteis associated with the pre condition rid rid prime rid negationslash rid negationslash sidwhich means that if the last action executed was open then the deleteaction can be executed as long as the current request parameter ridis equal to the previous request parameter rid prime the current request parameter ridis not null and the current request parameter ridand the current session variablesidare not the same.
although not shown in the figure constraints on how session variables are updated can be specified by writing post conditions on the current and next session variables and current and previous request parameters.
we assume that if there is no post condition specified then the session variables do not change their values.
apart from this syntactical sugar the semantics of the state machine shown in figure precisely matches the formal model we defined above.
note that this state machine enforces all the navigation constraints we identified for thi s application.
.
navigation conformance a navigation state machine nsm recognizes the session traces that are compliant to the expected use of the web application.
definition .let v epsilon1 p vector v1 a1 vector p1 vector v2 a2 vector p2 ...be a session trace and let n angbracketlefts s0 angbracketrightbe a navigation state machine.
we say that naccepts if and only if vector v1 epsilon1 p v p a1 vector p1 and for all k vectorvk ak vector pk vector vk ak vectorpk ak vector pk .
basedontheabovedefinition wecandefinewhatitmeans for a web application to conform to the navigation constraints specified as a navigation state machine.
definition .given an application aand a navigation state machine n we say that aconforms to n if and only if all the session traces generated by aare accepted by n. .
runtime enforcement note that at any point during the execution of the web application if an action and a set of request parameters are requested by the user that causes a session trace to be rejected by the navigation state machine then the web application should not execute that action.
all the errors we discussed in section are caused by execution of actions that violate the navigation constraints.
if we can find a mechanism that guarantees that such actions are not executed by the web application then we can eliminate navigation errors.
.
the nsm plugin we achieve this by implementing a navigation state machine nsm plugin which takes an nsm specification as input and enforces the navigation constraints specified by the input nsm during the execution of the web application.
we developed a simple xml based language for specificationofnsms.
thensmpluginisbasicallyaninterpreterfor 239this language.
a state is defined as a module controller action tuple.
given the hierarchical relationship between modules controllers and actions it is also possible to sp ecify a class of states as a module controller tuple contains a set of states one for each action present in the specified controller or even just a module contains a set of states one for each action present in each controller present in the specified module .
the plugin has lines of php code which adds less than to the source code size in the smallest application we tested.
it operatesproactively.
as each requestis routed a decision is made as to whether or not the next state requested by the client is an acceptable transition from the previously visited state.
in the event the request is prohibited the current action is re executed effectively produci ng a page refresh .
in the particular case where the current action is undefined which can only happen at the very beginning of a transaction or when a page reload is flagged in the specification as not appropriate such as when the last action executes a cash transfer the initial state of the nsm is loaded.
once the requested action has executed control returns to the nsm plugin in order to verify that the action has conformed to the specification.
the plugin compares a snapshot of the session variables taken before the execution of the action with the values of the session variables after the actio n has executed and ensures that the action has modified only the variables it is allowed to modify according to the specification the variables have been updated to a valid value a value identified in the specification and the postcondition of the action has been established.
if the executed actionisapagerefreshcausedbyanavigationerrorthatwas blocked this second pass into the nsm plugin is skipped.
.
compliant web applications the nsm plugin enables us to convert a web application to acompliant application that does not allow navigation errors.
this is achieved simply by inserting the nsm plugin rightbeforetheapplication scontrollerappliesitsnavig ation logic.
for the zend framework the nsm plugin is registered with the application s front controller by a single line of c ode in thebootstrap.php file.
for the codeigniter framework the plugin invocation is added just before the point where actions are called in the bootstrap file codeigniter.php .
below we formalize the semantics of a compliant web application that has been extended with the nsm plugin.
in order for the plugin to remember the state of the application an additional session variable is stored for each sess ion keeping track of the last state of the nsm in that session.
definition .leta angbracketleftq b angbracketrightbe an application and n angbracketlefts s0 angbracketrightbe a navigation state machine.
the compliant application an angbracketleftq prime b prime prime angbracketrightis an application where q prime q s i b prime b s i and q prime vectors prime prime q vector s a vector p i if and only ifq prime q a vector p i s prime i si a vector p ands prime j sjfor each j iandj negationslash iwheresiandsjdenote the i th andj th elements of the vector vector s respectively.
a compliant application restricts the navigation behavior so that each session trace conforms to the navigation state machine a. we formalize this property as follows theorem .given a web application aand a navigation state machine n the compliant application anconforms to the navigation state machine n. .
model checking an nsm by automatically analyzing an nsm using model checking we can iteratively refine its specification and discover and fix potentially critical errors in navigation constraint s beforetheymanifestthemselvesatruntime.
withoutaspecification mechanism like navigation state machines it would be extremely difficult to automatically analyze navigation constraints of a web application at the implementation leve l since navigation errors may only manifest themselves after a series of client server interactions and they may be hard to detect.
.
actl model checking navigation constraints can be expressed in terms of the actions session variables and request parameters used by the application.
to this end we employ the universal fragment of ctl called actl.
the ground terms of an actl formula are defined as follows if x yare session variables or request parameters x y p v andais an action a a thenx yandx negationslash y aand aare ground terms.
actl formul are then built from ground terms using the standard boolean connectives and and the ctl temporal operators ax in the next state of every trace ag in every state of every trace af in some state of every trace and au a u holds when for every trace is true until is true .
intuitively the satisfaction of a ground actl formula depends on the lastaction taken and the request parameters for that action and the current values of the session variables.
an actl formula is satisfied by an nsm a denoted as a if for every initial state sofawe have s .
since the session projection is also a form of nsm the same semantics applies to it as well.
given an nsm our plugin produces an smv model that is sent to the nusmv model checker .
to relate the verification results obtained by analyzing a nsm to the application extended by that nsm we need to define a projection from an application to a session.
definition .leta angbracketleftq b angbracketrightbe an application whereq m d v i and leti ibe a session.
the projection of ato sessioniis an nsm i.e.
a i n angbracketlefts s0 angbracketrightwhere s d v a d p is the set of states.
s0 v p is the initial state.
s a d p 2sis the transition relation where vectorv prime a prime vectorp prime vector v a vector p a prime vectorp prime if and only if there exist q q prime qsuch thatq prime q a prime vectorp prime i andq prime i vectorv prime andq i vector v. the projection of an application ato sessioniis the nsm that recognizes exactly the set of navigation traces for sessioniina.
theorem .letabe an mvc application and i ibe some session.
a navigation trace is a trace of a i if and only if there exists a trace primeofasuch that prime i .
the following theorem shows that for a compliant applicationan the navigation projections for each session are guaranteed to satisfy provided that the nsm nsatisfies it.
240digitalus bambooinvoice capstone states bdd nodes memory .
mb .
mb .
mb model building .
s .
s .
s table summary of model checking results.
theorem .letabe an application nbe an nsm and be an actl formula.
if n then for every session i i an i .
proof.
suppose the contrary that is n but there exists some session isuch that an i negationslash .
since is in the universal fragment of ctl this entails that there exists a trace of an i which is a counter example of .
but by theorem we know that every trace of an i is a trace ofn hence there is also a counter example of inn a contradiction.
this theorem has an important consequence.
although navigation state machines provide a mechanism for specification and verification of navigation constraints any conclusions drawn from such a verification effort are valid only if we can guarantee that a web application conforms to a given navigation state machine specification.
by the previous result the seemingly daunting task of guaranteeing conformance to a specific navigation model across an entire application becomes a manageable task for web applications built based on the mvc architecture.
in other words the verification results we obtain by model checking a navigation state machine are guaranteed to hold for a compliant web application that uses that navigation state machine.
.
sample navigation properties in actl equipped with this theorem it is now possible to perform formal verification of some navigation properties in the web applications we studied.
the plugin we developed automatically translates an nsm into an input file to the nusmv model checker.
the results are summarized in table .
as one can see from these figures buildingand loadingthe model from each nsm is a trivial task and takes nusmv less than a second for all three applications.
indeed none of the nsms generated smv models of more than states and used more than a few megabytes of memory to be processed.
we identified several generic navigation properties that can be used for many applications.
we regard these properties as good indicators of the correct navigation design of an application consequently a routine check of the following actl formulas could be used to identify potential navigation issues if they are violated.
an index action must be eventually executed af action index the index actions are generally intended as the starting point consequently if an index action is never executed this hints at a navigation problem.
once you login the only way to go back to the login page is by traversing the logout page ag controller login a controller login ucontroller logout application states transitions variables digitalus bambooinvoice capstone table size of navigation state machines for each application this property summarizes the expected behavior of a login system we have seen that it is false both in the plain digitalus and bambooinvoice applications.
however the nsm of both applications satisfies this property by the previous theorem the compliant extensions of digitalus and bambooinvoice satisfy it as well.
eachcontroller chasthe index actionasitsonlyentry point from other controllers ag controller negationslash c ax controller negationslash c action index this property is similar in spirit to some form of visibility mechanism clearly two controllers do not implement separate functionalities if they refer to pages other than thei r respective entry points.
the property is false in digitalus both with and without the nsm plugin.
indeed the action admin site index calls admin user open this is expected by the application and must be allowed by the nsm.
the property is also false in bambooinvoice where the clients controller calls non index actions in the clientcontacts controller and the invoices controller calls non index act ions in the clients controller.
due to the small size of the models at least according to model checking standards verification times for these properties are negligible.
nusmv s internal timefunction returned an elapsed time of seconds for all properties we tested.
this is due to session modularity and should be contrasted with the expected model of the application if all sessions had to be considered.
.
empirical ev aluation for each of the three applications described in section we defined a navigation state machine.
this nsm was created manually in parallel to an exploration of the possible navigation paths in the application.
guards were later added to the transitions when request parameters or session variables were required to execute a particular action.
statistics about these state machines are summarized in table .
equipped with these nsms we evaluated the performance of the nsm plugin on the resulting extended mvc applications.
building the nsm for each application took roughly hours this approximation is generous as it also includes the time required to carefully write down sample navigation errors for the purpose of this paper as well as the capture of screenshots for each step of these errors.
yet in general w e believe that the specification of an nsm which should be done along with the development of the application should not be too daunting.
following a natural design principle each module should be self contained and implement a unit functionality hence it should have an index like action a s its only entry point from the other modules this is one of the properties we checked in section .
.
in so cross module dependencies are limited what remains to specify is 241the behavior of each module separately which consist each of only half a dozen actions and transitions in our examples.
case in point lots of errors in the web applications we studied are caused by cross module dependencies for pages other than the main module page.
.
error prevention a first qualitative component of evaluation is the plugin s capability to prevent navigation errors and in particular t he ones described in section .
therefore our first experiment was to reproduce the sequences of actions for navigation errors error while the nsm plugin is in action and to compare the pages received with the original application s response.
we observed that all five navigation error types were caught by the plugin on the last step of each sequence instead of returning an error page or error messages within a page the nsm plugin prevents the faulty action from being executed and simply recalls the last valid page.
this readily presents advantages in terms of user experience by allowing a graceful handling of all navigation errors and security by preventing implementation detail s from leaking through uncaught error messages .
however the nsm plugin does not merely catch and hide error messages once they are triggered it actually prevents them by diverting the control flow before anything happens.
hence in the case of navigation error the user delete action s side effect removing a user from the database is avoided instead of coped with after the fact.
apart from these qualitative considerations we were also interested in estimating the proportion of navigation error s that each application would let through were it not for the presence of the plugin.
as we have seen without a navigation state machine it is possible to jump from any action to any other.
if we denote by n s k the number of valid traces of length k ending in state s then the number of traces of length k which are valid for the first k actions and which violate the nsm at the k th is given by nv k summationdisplay s sn s k s prime s s negationslash s prime i.e.
we extend each valid trace of length k ending in sby one of the actions s primethat are not adjacent to sin the nsm giving us a bad trace of length k. however in some occasions violating the nsm has no undesirable side effects this is the case for all actions who se incoming transitions are not guarded.
however the actions thathaveguards ifcalledfromthewrongpreviouspage will havetheirpreconditionviolated theresultsofsuchviolati on have been shown in section .
let sgbe the set of such guarded actions in the nsm.
the number of traces which violate a guard at the k th step is given by ng k summationdisplay s sn s k sg s prime s s negationslash s prime i.e.
we restrict ourselves to non adjacent actions that are guarded.
therefore the proportion of bad traces of lengt h kwhich actually cause errors is given by ng k nv k .
this ratio represents the proportion of traces for which a navigation constraint is assumed but not checked by the application.
we computed this ratio for increasing values of k using both the nsm for the digitalus cms and for bambooinvoice.application no plugin with plugin digitalus bambooinvoice capstone figure server processing time in milliseconds for nsm compliant actions both with and without the nsm plugin.
the resulting curve converges to a stable value after k reaches which is approximately the depth of the application s state machine in both cases.
with digitalus when a user or an automated web crawler invokes the wrong action from its current point in the application there is ap proximately a chance that this error will not be caught by the application and create a page containing php errors or warnings as shown in figures .
with bambooinvoice this chance is .
alternately this indicates that in both applications the majority of the pages blocked by the nsm plugin would actually cause errors without the plugin.
one can also consider the number of traces that the nsm prevents but which would not have caused an error in the original application.
while the number of errors caught by the nsm gives us information about the application s success or lack thereof at enforcing its own navigation logic the converse only gives us information about how conservative is a particular instance of nsm for that application.
fo r this reason we did not compute this measurement.
.
impact on processing time we then measured the incurred costs of using the nsm plugin on all three applications.
in a first time a validsequenceofoperations producingnoerrorsandvisitingallthe actions including create delete operations was manual ly executed on each application.
the application was instrumented to record and write to a file the start and end time of each php processing request.
the same sequence was then re executed this time with the nsm plugin registered and running.
the average processing time per request in each application is shown in figure the times were measured on an amd .
ghz windows xp machine using mb of ram and running apache and php .
.
while this figure shows that the nsm plugin does induce processing overhead during normal use of an application this overhead is negligible in the case of digitalus and in the case of bambooinvoice.
in absolute numbers this amounts to at most milliseconds per request in the worst case.
moreover in its present version the plugin has to load and parse the state machine s xml file on each page request therefore these figures should be seen as an upper bound as they could easily be improved.
in addition to processing overhead in valid requests we studied the performance consequences of error processing.
to this end we selected actions in each application and called them out of context to deliberately violate the nsm specification.
we retained the situations where the applica tion produced uncaught errors errors where the applicatio n is still able to load part of the page or which display only php errors of the class warning or notice as in figure and errors where the application crashes and the error page is produced by php itself this is generally the case for fatal errors as in figure .
for each action we calculated its processing time in242page no plugin with plugin admin media create folder admin media upload admin user edit admin user open invoices newinvoice a warnings page no plugin with plugin admin page edit admin media delete folder folder admin user delete invoices view b errors figure server processing time in milliseconds for pages that produce php warnings and fatal errors both with and without the nsm plugin.
cluding the php error handling repeating the operation times and taking the average of those measurements.
we then proceeded to the same invocation this time with the nsm plugin enabled.
in that situation no php error is produced and the application simply reloads the last valid page.
sample processing times for various warnings and errors are shown in figure .
while in some cases the nsm plugin induces the same overhead as before surprisingly in some cases the running time with the plugin is lowerthan without the plugin.
in these situations it takes more time for php to execute the script and generate the warnings than it takes to simply run the nsm plugin determine that the requested action violates the state machine and reload the last valid page.
this phenomenon is even more marked in the case of fatal errors where the action does not execute at all and php simply returns a white page with an error message.
in the case of digitalus running the nsm plugin is more than ten times faster than letting the application provoke a fatal er ror.
therefore although the plugin induces a slight overhead over the normal use of an application its capability to catc h navigation errors can actually save server processing time.
.
related work the problem of navigation inconsistencies in web applications has been described in earlier work by licata et al.
where it has been shown that multiple browser windows can lead the user of a popular travel reservation site to purchas e the wrong flight.
to alleviate the problem the authors suggest the development of a new programming language based on scheme in which such navigation inconsistencies reduce to type checking errors .
in contrast the approach presented in this paper neither warrants the introduction of a new programminglanguage nor does it require any substantial modification to an existing application.
moreover sinc e nsms are based on statecharts a common specification formalism that is part of uml we believe that their adoption will not require a significant learning effort.
modeling web applications as state machines was suggested a decade ago and has already been used to automatically generate test sequences and perform some form of model checking .
the verification of standard non mvcweb applications has also been attemptednumer ous times in recent years .
there has also been work on specification of interfaces between two components as state machines .
however the usefulness of these works is mitigated by one key limitation one cannot assume that the navigation flow intended by the programmer is the only possible path of execution in the implementation.
indeed as much as formal finite state models are used for testing and verification none of the previous works actually use this model to enforceproper navigation sequences on a running application as the nsm plugin allows.
guha et al.
statically analyze an ajax application on the client side and extract a control flow graph from its source code.
a monitor then enforces on the server side that the requests received follow the extracted client model.
this approach cannot be used to prevent navigation errors since the specification is based on the client s code which may not correspond to what the server expects.
han and hofmeister define a formal navigation model for web applications based on statecharts.
however the model does not include request parameters such as http get or post fields consequently most navigation constraints presented in our work can not be handled.
this remark also applies to the dialog flow notation .
the spring framework3allows the definition of a state machine called web flow however the flow s identifier is passed as a parameter in the url for each action which makes the application vulnerable to sequences involving bookmarks as in navigation error .
book et al present a formal model for specifying input validation rules for web applications a nd present a framework where an implementation can be generatedfromtheformalspecification.
incontrast ourapproac h combines the constraints on sequencing of user actions with constraints on input data.
moreover our approach can be integratedinexistingapplicationsanddoesnotrequireuser s to adopt a new framework for developing web applications.
finally none of the above approaches combine model checking with runtime enforcement or provide an empirical analysis of the overhead incurred by runtime enforcement.
the enforcement of nsms on a web application can also be viewed as a form of runtime monitoring of linear temporal logic properties .
such a monitor has been developed for ajax web applications communicating with web services through soap .
its working principle is similar to the nsm plugin but on the client side instead of the server side therefore it does not have access to session variables like the nsm plugin.
moreover the use of ltl as a specification language can make the specification of some navigation constraints problematic as ltl is too weak to encode a finite state machine.
it also raises the issue of model checkingactlproperties asinsection6.
overasystemdefined by a conjunction of ltlformulas.
finally the use of the mvc design pattern to centralize navigation decisions bears some similarity to aspectoriented programming aop .
the nsm plugin registered inthemvcapplication actsasa pointcut thatistriggere d whenever a new page is requested the advice associated with that pointcut is used to enforce the navigation state machine.
in that respect the nsm plugin could also nicely fit into an aspect oriented web application framework .
.
conclusion we have shown that web applications mishandle unexpected navigation sequences caused by the uncontrolled use of a web browser s navigation functionalities.
in particula r we calculated that more than half of all possible unexpected navigation sequences are improperly handled in three realworld applications we studied.
we showed that the navigation state machines presented in this paper can help relieve these problems by restricting the control flow of an application to sequences intended by the developer.
our main conclusion is that the benefits of the extra layer of verification largely outweigh its overhead .
this is particularly true if some unexpected user requests produce php error pages.
in this case in addition to producing a cryptic message possibly revealing implementation details processing the error can incur a cpu overhead of as much as times the time required to check the error and redirect to a correct page.
as future work we plan to investigate automatic extraction of navigation state machine skeletons either through automated crawling or by analyzing the source code.
in addition the implementation of the plugin as a reverse proxy directly in the http server could detach its application from any language or mvc platform.
.