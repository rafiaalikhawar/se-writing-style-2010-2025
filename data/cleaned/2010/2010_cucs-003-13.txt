effective dynamic detection of alias analysis errors jingyue wu gang hu yang tang junfeng yang columbia university fjingyue ganghu ty junfeng g cs.columbia.edu abstract alias analysis is perhaps one of the most crucial and widely used analyses and has attracted tremendous research efforts over the years.
yet advanced alias analyses are extremely difficult to get right and the bugs in these analyses are most likely the reason that they have not been adopted to production compilers.
this paper presents n eongoby a system for effectively detecting errors in alias analysis implementations improving their correctness and hopefully widening their adoption.
n eongoby works by dynamically observing pointer addresses during the execution of a test program and then checking these addresses against an alias analysis for errors.
it is explicitly designed to be agnostic to the alias analysis it checks for maximum applicability and ease of use and detect alias analysis errors that manifest on real world programs and workloads.
it reduces false positives and performance overhead using a practical selection of techniques.
evaluation on three popular alias analyses and real world programs apache andmysql shows that n eongoby effectively finds alias analysis bugs with only false positives and reasonable overhead.
to enable alias analysis builders to start using n eongoby today we have released it open source at along with our error detection results and proposed patches.
categories and subject descriptors d. .
software program verification d. .
testing and debugging f. .
semantics of programming languages general terms algorithms design reliability experimentation keywords error detection alias analysis dynamic analysis .
introduction alias analysis answers queries such as whether pointers pandq may point to the same object.
it is perhaps one of the most crucial and widely used analyses and the foundation for many advanced tools such as compiler optimizers bounds checkers and verifiers .
unsurprisingly a plethora of research over the last several decades has been devoted to improve the precision and speed of alias analysis and pldi and popl alone have accepted over alias analysis papers since .
most citation lists in this paragraph are seriously incomplete for space.
unfortunately despite our reliance on alias analysis and the tremendous efforts to improve it today s production compilers still use the most rudimentary and imprecise alias analyses.
for instance the default alias analysis in llvm for code generation basicaa simply collapses all address taken variables into one abstract location the default alias analysis in gcc is type based and marks all variables of compatible types aliases.
these imprecise analyses may cause compilers to generate inefficient code.
we believe the key reason hindering the adoption of advanced alias analyses is that they are extremely difficult to get right.
ad vanced alias analyses tend to require complex implementations to provide features such as flow sensitivity context sensitivity and field sensitivity and to handle corner cases such as c unions external functions function pointers and wild void andintcasts.
as usual complexity leads to bugs.
buggy alias results at the very least cause research prototypes to yield misleading evaluation numbers.
for instance our evaluation shows that llvm s anders aa implementing an interprocedural andersens s algorithm is actually lessprecise than basicaa x8.
.
after we fixed anders aa bugs.
worse buggy alias results cause optimizers to generate incorrect code commonly believed to be among the worst possible bugs to diagnose.
moreover they compromise the safety of bounds checkers and verifiers yet this safety is crucial because these tools often have high compilation runtime or manual overhead and are applied only when safety is paramount.
this paper presents n eongoby 1a system for effectively detecting errors in alias analysis implementations improving their correctness and hopefully vastly widening their adoption.
we explicitly designed n eongoby to be agnostic to the alias analysis it checks the only requirement is a standard mayalias p q interface that returns true if pandqmay alias and false otherwise.2this minimum requirement ensures maximum applicability and ease of use.
to check an alias analysis with n eongoby a user additionally chooses a test program and workload at her will.
for instance she can choose a large program such as apache andmysql and a stressful workload that together exercise many diverse program constructs such as the corner cases listed in the previous paragraph.
this flexibility enables n eongoby to catch alias analysis bugs that manifest on real world programs and workloads.
given the test program n eongoby instruments the program s pointer definitions to track pointer addresses.
the user then runs the instrumented program on the workload and n eongoby dynamically observes pointer addresses and checks them against the alias analysis.
it emits bug reports if the addresses contradict the alias results i.e.
the pointers did alias during the test run based on the dynamically observed addresses henceforth referred to as addresses but the alias analysis states that the two pointers never alias.
we use didalias p q to refer to n eongoby s algorithm for determining whether pointers pandqdid alias.
the invariant neongoby checks is thus didalias p q !mayalias p q .
to ease discussion we use didalias mayalias to refer to both the corresponding algorithm and the set of pointer pairs on which didalias mayalias returns true.
although the idea of dynamically checking alias analysis enjoys conceptual simplicity implementing it faces a key challenge how to reduce false positives a major factor limiting the usefulness and 1we name our system after the neon goby fish which helps other fish by cleaning external parasites off them.
2neongoby can be easily extended to check must alias but few alias analyses implement a more than shallow must alias analysis.
no alias if field sensitive structfchar f1 char f2 gs p s f1 q s f2 no alias if flow sensitive for i i i p addr q addr p s address is addr no alias if context sensitive void foo void arg f void p malloc .
.
.
void q arg pis freshly allocated so doesn t alias q return p g foo foo null figure false positive examples caused by sensitivities.
adoption of error detection tools .
false positives arise from two main sources first a na vedidalias algorithm may be less precise than the alias analysis checked.
figure shows three examples on which an imprecise didalias may emit false positives.
specifically if an imprecise didalias considers pointers with one byte apart as aliases because they likely point to the same object it may emit a false positive for a field sensitive alias analysis on the first example if it considers pointers ever assigned the same address as aliases it may emit a false positive for a flow sensitive alias analysis on the second example or for a context sensitive alias analysis on the third example.
to reduce such false positives while remaining agnostic to the alias analysis checked n eongoby must provide a very precise didalias .
second the same observed address of a pointer is not always intended to refer to the same object which occurs for two reasons.
spatially pointers may have invalid addresses e.g.
go off bound or be assigned undefined values .
for instance an off by one pointer for marking the end of an array may accidentally have the same address as a pointer to the next object.
temporally the same piece of memory may be reused for different objects.
for instance two heap memory allocations may return the same address if the first allocation is freed before the second allocation.
thus n eongoby cannot simply claim that two pointers did alias if their addresses are identical instead it may need to track whether a pointer is valid and if so what object it points to.
this problem appears familiar to the problem bounds checkers solve but it is actually very different n eongoby assumes a test program is largely correct and runs it to detect alias analysis errors whereas bounds checkers are for preventing buffer overflow attacks.
thus it is an overkill for neongoby to borrow complex bounds checking techniques such as tracking base and bounds for each pointer.
a secondary challenge facing n eongoby is performance overhead.
n eongoby is designed to detect errors so overhead is typically not a big issue.
however n eongoby is also designed to detect alias analysis errors that manifest on real world programs and large overhead may disturb the executions of these programs such as triggering excessive timeouts.
moreover different users may have different resource budgets and coverage goals when testing their alias analyses.
since users can best decide what overhead is reasonable n eongoby should provide them the flexibility to make their own tradeoffs between bugs and overhead.
neongoby addresses these challenges using three ideas.
first it provides two checking modes enabling a user to select the mode best suited for her alias analysis test program and workload.
intheoffline mode n eongoby logs pointer definitions to disk when running a test program and checks the log after the test run finishes.
since checking does not slow down the test run n eongoby affords to check more thoroughly it checks alias queries on pointers potentially in different functions or interprocedural queries .
however the logging overhead in the offline mode may be high so neongoby offers another mode to reduce overhead.
in the online mode n eongoby checks alias queries on pointers only in the same function or intraprocedural queries 3with efficient inlined assertions but it may miss some bugs the offline mode catches.
second n eongoby further reduces performance overhead without losing bugs using an optimization we call delta checking .
this optimization assumes a correct baseline alias analysis such as llvm s basicaa often simple enough to have few bugs.
n eongoby then checks only the pointer pairs that may alias according to the baseline but not the checked alias analysis.
by reducing the pointer pairs to check n eongoby reduces overhead.
third n eongoby employs a practical selection of techniques to reduce false positives.
for instance n eongoby considers that two addresses do not alias even if they are one byte apart avoiding false positives on a field sensitive alias analysis.
in addition it versions memory so if a piece of memory is reused the addresses before and after the reuse get different versions.
we implemented n eongoby within the llvm compiler and checked three popular llvm alias analyses including the aforementioned basicaa llvm s default alias analysis the aforementioned anders aa later used as the basis for two alias analyses and ds aa a context sensitive field sensitive algorithm with full heap cloning later used by .
to check these analyses we selected two real world programs mysql andapache and the workloads their developers use.
n eongoby found bugs in anders aa andds aa including previously unknown bugs with only false positives and reasonable overhead.
we have reported five bugs to ds aa developers one of which has been patched .
hopefully ds aa developers will have more time working on the fixes after the pldi deadline.
this paper makes four main contributions our formulation of an approach that dynamically checks general alias analysis with the invariant didalias p q !mayalias p q n eongoby a long overdue system toward improving advanced alias analyses into production quality and widening their adoption a practical selection of techniques to reduce false positives and overhead and our evaluation results including real bugs found in two llvm alias analyses and our proposed patches.
our key inspiration is our anecdotal struggles with some existing alias analyses in our research so we hope that alias analysis builders can start applying n eongoby to improve their alias analyses into productionquality analyses today.
as such we have released it open source at along with our error detection results and proposed patches.
.
an example and overview figure shows an example test program.
it has three pointers p andqin function main and rinbar.
among these pointers only qandralias.
suppose buggyaa a buggy alias analysis misses this only alias pair and reports no alias for all pointers.
to check buggyaa with this test program using the offline mode of n eongoby a user first compiles the code into example.bc in llvm s intermediate representation ir and runs the following three commands neongoby offline instrument example.bc .
example.inst neongoby check example.bc example.log buggyaa 3intraprocedural queries can still be answered by interprocedural analyses.void bar int r f r g raliases q intmain f int p int malloc sizeof int free p int q int malloc sizeof int memory reuse bar q free q return g figure example test program.
the first command instruments the program for checking it transforms the program to avoid false positives caused by memory reuse off bound pointers and undefined values and it inserts a logging operation after each pointer definition or memory allocation to log information for offline checking.
the second command runs the instrumented program example.inst to generate a log of pointer definitions and memory allocations.
the third command checks this log against buggyaa for errors.
it first computes didalias for all three pairs of pointers including pointers not in the same function.
it excludes pair p q and pair p r from didalias even if the two malloc calls return the same address because the versions of the address are different.
it includes pair q rindidalias because qandrshare the same address and version.
n eongoby then checks didalias against buggyaa emitting an error report because mayalias q r returns false.
to diagnose this error the user can run n eongoby to dump log records or slice the log for records explaining why qandrdid alias.
to check buggyaa with this test program using the online mode of n eongoby a user runs the following commands neongoby online example.bc buggyaa .
example.ck the first command iterates through each function in example.bc queries buggyaa on each pair of pointers in the function and if mayalias on the two pointers returns false embeds an assertion that the two pointers never alias at runtime.
in this example n eongoby embeds an assertion assert p!
q p null after the second malloc .
the online mode prevents the two memory allocations from returning the same address using a simple trick of deferring memory deallocation.
the second command runs the instrumented program example.ck to check whether this assertion may be triggered which never happens.
each mode of n eongoby has pros and cons.
the offline mode checks more thoroughly whereas the online mode checks only intraprocedural queries missing the bug in buggyaa .
the offline mode can reuse one log to check multiple alias analyses amortizing the cost of running the tests whereas the online mode can check only one alias analysis at a time.
however the offline mode has to log information to disk because the log may grow larger than the ram for some real world programs and workloads and on disk logging can be costly.
in contrast the inlined assertions the online mode embeds are much faster to check.
by providing two modes of operations n eongoby enables a user to select the mode that suits her purpose.
.
offline mode this section describes how n eongoby operates in the offline mode.
figure shows the offline mode architecture.
it has three components the instrumenter logger and offline detector .
given a program in llvm s intermediate representation ir the instrumenter transforms the program to avoid false positives and inserts logging operations to collect runtime information.
when a user runs the instrumented program the logger records pointer definiofflinedetectorinstrumenterprogramaliasanalysisbugreportspointer loginstrumentedprogramloggerworkloadfigure architecture of the offline mode.
tions and memory allocations to disk.
since the logger runs within a test program we explicitly designed it to be simple and stateless reducing runtime overhead and avoiding perturbing the execution of the test program.
after the run finishes the offline detector checks the log against an alias analysis and emits error reports.
since the logger is much simpler than the other components we focus on describing the instrumenter x3.
and offline detector x3.
and give a brief discussion at the end of this section x3.
.
.
instrumenter the instrumentor does five main transformations the first to ensure that the logger and the offline detector can consistently refer to the pointer variables in a program the second to collect pointer addresses and the last three to reduce false positives caused by memory reuse off bound pointers and undefined values.
we describe the five transformations below and highlight some of the differences between n eongoby and bounds checkers.
assigning ids to pointers.
the logger and offline detector run in different phases so they need a consistent way to refer to the pointers in a program.
to identify the pointers the instrumentor traverses the program s control flow graph and assigns to the nth visited static pointer variable a numeric id of n. to keep ids consistent the offline detector uses the same deterministic algorithm depth first traversal in our implementation to assign ids to pointers.
bounds checkers need not assign ids to pointers because they cannot defer checking to offline.
instrumenting pointer definitions.
to catch errors caused by all different types of pointers n eongoby instruments all pointer definitions which assign addresses to pointers.
function pointers and global pointers are particularly crucial they are widely used in real world programs such as mysql andapache yet they are often mishandled by alias analyses.
our experiments found bugs caused by mishandled function and global pointers x8.
.
.
neongoby logs the following four types of pointer definitions pointer assignment p addr pointer load p addr function argument passing and global variable initialization.
neongoby instruments a pointer assignment or load by inserting logptr ptr addr right after the definition where ptrisp s statically assigned id addr is the address assigned and logptr is a logging operation that when executed appends the id and the assigned address to the current on disk log.
n eongoby adds calls to logptr similarly for function arguments at function entries and for global variables at the entry of the main function.
bounds checkers must also track these pointer definitions to propagate pointer base and bound information.instrumenting memory allocations.
as discussed inx1 n eongoby cannot use only addresses to compute didalias because the same address may point to different objects if memory is reused.
to enable the offline detector to handle memory reuse neongoby instruments all memory allocations including the allocations of heap stack and global variables.
although global memory cannot be reused n eongoby also instruments it to handle all memory allocations uniformly.
for each allocation it inserts logalloc addr size to record the allocation address and size.
for stack variables n eongoby inserts logalloc at the function entry.
for global variables n eongoby inserts logalloc at the entry of main .
for heap variables n eongoby inserts logalloc after a call to one of the following functions .
c memory allocation functions malloc calloc valloc realloc and memalign .
c new mangled names znwj znwm znaj and znam .
other library functions strdup strdup and getline .
users can easily add more heap allocation functions.
one tricky point is that a memory allocation such as p malloc ... is also a pointer definition and n eongoby must insert logalloc before logptrfor the offline detector to correctly handle memory reuse x3.
.
another point is that llvm shares memory between two constant strings for space if one is the suffix of the other to avoid these false aliases n eongoby disables this optimization.
to reduce logging overhead n eongoby does not instrument memory deallocations such as free calls and relies on the offline detector to lazily discover when memory is freed.
thus a corner case such as free q p q may cause n eongoby to emit a false positive on a flow sensitive alias analysis that understands free although pandqhave the same address they technically point to nothing.
however such a case almost never occurs in real programs.
no false positives of this type occurred in our experiments on real world programs x8.
.
.
bounds checkers in contrast must handle memory deallocations if they want to catch use after free errors.
handling off bound pointers.
pointers may be assigned offbound addresses that accidentally alias other pointers causing false positives.
fortunately most programs use off bound pointers only to mark the ends of arrays and these pointers are off by only one byte.
this type of off bound pointer is also the only type allowed by the ansi c standard.
to eliminate false positives caused by off byone pointers n eongoby transforms a program to add one extra byte for each memory allocation a technique borrowed from .
neongoby currently does not handle other off bound pointers because they occur very rarely and we experienced no false positives caused by these pointers in our experiments x8.
.
.
bounds checkers in contrast may have to handle these pointers because their false positives are fatal and abort executions.
handling undefined values.
variables may be uninitialized and have undefined pointer values that accidentally look like addresses of other pointers these values may further propagate through assignments such as assignments of a struct with an uninitialized pointer field to another struct causing n eongoby to log bogus addresses and emit false positives.
n eongoby handles undefined pointer values by setting them to null because null aliases nothing.
it does so for global variable initializations and llvm ssa s instructions4because these constructs frequently contain undefined values.
to reduce performance overhead n eongoby does not reset stack and heap variables undefined values which rarely occur in assignments.
bounds checkers in contrast may have to handle all undefined pointer values to avoid fatal false positives.
4an llvm instruction uses an undefined value to indicate that the variable is not initialized along an incoming edge to the basic block.
.
offline detector given a log of pointer definitions and memory allocations n eongoby s offline detector finds alias analysis errors in two steps.
first it scans the log to compute the didalias results.
second it checks didalias against an alias analysis and emits error reports.
from a high level n eongoby computes didalias results as follows.
it maintains two maps a conceptual map vfrom an address to a version number for handling memory reuse and a mappfrom a pointer s unique id to an address and version for tracking where pointers point to.
we use a location to refer to an address version pair.
given a log n eongoby scans the records sequentially from the beginning.
upon a memory allocation record neongoby updatesvto assign a new version number for the addresses within the allocated range so the same addresses get different versions before and after this allocation.
upon a pointer definition record lwith pointer ptrand addressaddr neongoby searchesvforl addr s current version and updates pto make l ptr point to locationhl addr v i. it then searches pfor pointers that point to the same location for each such pointer p it addshl ptr piandhp l ptritodidalias .
note thathl ptr l ptri is indidalias because a pointer aliases itself.
as discussed inx1 n eongoby must be very precise when computing didalias to avoid false positives.
the algorithm described above is field sensitive because it considers that two pointers did alias only when their locations are identical which requires their addresses to be identical.
it is flow sensitive because its pointer map pmaintains only the current location of a pointer.
this technique also makes it largely context sensitive because palmost always contains consistent pointer to location mappings from the latest call of a function.
in rare cases pmay contain mappings from different calls of a function causing false positives.
fixing these false positives is easy simply log function calls and returns.
however based on our evaluation x8.
.
these false positives hardly occurs so we opted not to log function calls or returns to reduce logging overhead.
once n eongoby computes the didalias results it checks an alias analysis as follows.
it iterates through each pointer pair indidalias and checks that the pair is also in mayalias .
it emits an error report otherwise.
since the didalias results do not depend on the alias analysis checked n eongoby can reuse them to check multiple alias analyses amortizing the cost of logging and computing didalias .
our actual algorithm to detect errors offline shown in algorithm does two optimizations for space and speed.
the first optimization implements the address to version map vwith an interval tree whose key is an address range and value the version number of the entire address range lines and .
an interval tree is much more space efficient than a version number per address.
upon a memory allocation record n eongoby removesv s existing address ranges that overlap with the allocated range because these ranges must have been freed increments a global version number and inserts the new range and version tov.
second instead of scanning the pointer map pfor pointers that point to the same location n eongoby maintains a reverse mapqfrom a location back to pointers lines and .
with these optimizations the space complexity of our algorithm iso jpj jmj jdidaliasj and the time complexity is o jlj logjmj logjpj nlogjdidaliasj wherejmjis the number of memory allocations in the log and nis the maximum size ofq .
in our experiments nnever exceeds jmj is typically ofjlj and the size of didalias is less than .
.
discussion some of the problems n eongoby addresses such as tracking pointer definitions and handling memory reuse off bound point algorithm offline detection algorithm input program prog alias analysis a and logl 1offlinedetection prog a l 2p hnull 0i pointer to location map 3q location to pointers map 4v address to version map 5vg global version number didalias pointer pairs that did alias foreach recordl2ldo iflismemallocrecord then vg vg v vg else iflispointerrecord then ifp hnull 0ithen q q nl ptr p hnull 0i ifl addr is not nullthen letlocation hl addr v iin p location q q l ptr foreach pointerp2q do didalias didalias hl ptr pi didalias didalias hp l ptri foreach pointer pairhp qi2didalias do ifnota.mayalias p q then mayalias uses prog reporterror hp qi bounds n eongoby online only yes no use alias analysis maybe no pointer definition yes yes pointer metadata yes no pointer dereference yes no allocation yes yes deallocation yes no off bound pointer yes only off by one undefined value yes only global init instruction table different techniques in bounds checkers and neongoby.
ers and undefined values overlap with what bounds checkers must handle.
however n eongoby has very different assumptions and goals than bounds checkers it assumes a test program is largely correct and uses the program to detect errors in alias analyses whereas bounds checkers prevent buffer overflow attacks to a program.
false negatives in bounds checkers may lead to exploits and false positives wrongly abort executions.
in contrast the effects of neongoby s false positives and negatives are much less serious.
because of these differences it is an overkill for n eongoby to borrow complex bounds checking techniques.
table summarizes the different techniques in typical bounds checkers and n eongoby.
bounds checkers must check buffer overflows online to stop exploits whereas n eongoby can defer costly detection completely offline.
bounds checkers may assume a correct alias analysis and other static analyses and use them to remove unnecessary checks whereas n eongoby is intended to detect errors in alias analyses.
bounds checkers need to maintain pointer base and bound information with fat pointers maps or trees which break backward compatibility or have high overhead.
in contrast n eongoby maintains no pointer metadata.
bounds checkers check pointer dereferences and track memory deallocations to catch bugs whereas n eongoby doesalgorithm online mode input program prog and alias analysis a 1onlineinstrumentation prog a foreach functionf2prog do foreach pointer definition pair hp qi2fdo ifpreachesqandnota.mayalias p q then insert assert p6 qorpisnull afterq foreach external function call cfreeing a heap object do replacecwith call deferred free neither.
bounds checkers may need to accurately handle pointers off by more than one bytes and undefined values in stack and heap variables to avoid wrongly aborting executions whereas n eongoby ignores these cases.
.
online mode neongoby s offline mode checks interprocedural alias queries to find more bugs but its logging may be costly.
thus n eongoby provides an online mode to reduce performance overhead.
this section describes how n eongoby operates in the online mode.
the online mode focuses on checking intraprocedural queries because they are often considered more crucial than interprocedural queries.
for instance compiler optimizations tend to issue mostly intraprocedural queries.
to check intraprocedural queries neongoby embeds the alias analysis checks as regular program assertions into a test program.
n eongoby reports an alias analysis bug if one of the assertions fails when a user runs the test program.
these assertions are much cheaper than costly on disk logging at runtime as shown in our experiments x8.
.
algorithm shows the algorithm to embed the checks.
it iterates through each pair of point definitions pandqof a function line and inserts an assertion assert p!
q p null line if mayalias p q returns false line .
one issue is that the inserted assertion requires that both pandqare defined.
n eongoby solves this issue with a standard control flow reachability analysis line and inserts the assertion only if p s definition reaches q. if pointer pis undefined along some incoming edges to q s basic block n eongoby creates a new instruction using llvm s ssa transformation not shown in algorithm .
to avoid false positives caused by memory reuse off bound pointers and undefined values the online mode borrows the techniques from the offline mode with one refinement it no longer versions memory.
the insight is that n eongoby checks only intraprocedural queries in the online mode so it need handle only heap memory reuse which can be handled in a much simpler way.
specifically it defers heap memory deallocations so the allocations almost always return different addresses.
to do so it replaces functions that free heap memory including c s free and c s delete mangled names zdlpv and zdapv with a function that queues the free request without actually freeing memory.
when the queue is full n eongoby processes half of the queued requests ensuring that heap memory reuse occurs after at least n 2free operations wherenis the queue capacity.
by default nis 20k large enough that no false positives of this type occurred in our experiments.
one additional advantage of the online mode is that the embedded assertions explicitly inform us what to check enabling neongoby to leverage symbolic execution tools such as klee and woodpecker to generate inputs that cause the assertions to fail.
we leave this for future work.
if a function has an extremely large number denoted n of pointers that do not alias each other the online mode need insert o n2 assertions which may run slower than the o n logging operations inserted by the offline mode.
to avoid high overheadcaused by such pathological cases n eongoby bounds the number of assertions it inserts to 106for each function and switches to the offline mode for the function otherwise.
in our experiments we did encounter one such case a yacc generated function called mysqlparse inmysql needs much more than 106assertions so neongoby always checks this function offline x8.
.
.
delta checking neongoby provides an optimization called delta checking to speed up both online and offline modes without losing any error.
the insight is that not all pointer pairs are equally hard to handle by an alias analysis so n eongoby can focus on checking the hard to handle pairs and skip the easy ones.
to compute what pairs are easy n eongoby takes a user specified baseline alias analysis assumed to be simple enough to be correct.
it then skips checking all pointer pairs pandqon which the baseline s mayalias p q returns false.
intuitively if an imprecise baseline alias analysis can infer that two pointers do not alias then most likely they never alias in any execution so didalias would return false and n eongoby would not find any error on the pointers.
we envision two ways this optimization can be used.
first a user specifies an alias analysis she trusts such as basicaa which computes very conservative alias results then enjoys speedup without losing errors when applying n eongoby to check an advanced alias analysis.
second an alias analysis builder incrementally checks each precision improvement she makes to her alias analysis.
for instance if her alias analysis reports pointer pairs that each do not alias prior to the improvement and pairs after she can use n eongoby to check this difference of pairs each indeed never alias on some test programs and workloads.
to implement delta checking for the offline mode we simply change line in algorithm to ifb.mayalias p q andnota.mayalias p q wherebis the baseline alias analysis.
to implement delta checking for the online mode we simply change line in algorithm to ifpreachesqandb.mayalias p q andnota.mayalias p q our results using basicaa as baseline show delta checking reduces compilation time offline detection time and runtime overhead.
.
implementation we implemented n eongoby in llvm.
it works with version .
and above.
it consists of lines of c code with for the instrumenter for the logger for the offline detector for the online mode and the remaining for common utilities.
in the remaining of this section we describe three additional techniques within n eongoby the first to further reduce overhead x6.
the second to help users diagnose error reports x6.
and the third to support multiprocess or multithreaded programs x6.
.
.
detecting errors using dereferenced pointers only dereferenced pointers are presumably more crucial than the ones not dereferenced so are the alias results on dereferenced pointers.
thus n eongoby provides users an option to detect alias analysis errors using only dereferenced pointers including the pointers used in load and store instructions and those passed to external functions because n eongoby conservatively assumes that these functions dereference their pointer arguments.
although n eongoby with this option may lose some alias analysis errors it enjoys two benefits.
first the error reports are of higher quality because they are on the more crucial pointers.
second n eongoby runs faster when checking fewer pointer pairs in both offline and online modes.
we evaluate this bugs v.s.
overhead tradeoff in x8.
.
.
simplifying error diagnosis when n eongoby reports an error it emits two pointers that did alias yet are not marked as aliases by the checked alias analysis.
to diagnose such a report it may be time consuming to manually inspect all records in the log so n eongoby provides a diagnosis tool to slice the log into a small subset of records that explains why two pointers did alias.
the core idea is to trace data dependencies of the two pointers back to a common parent pointer from which both pointers are derived.
n eongoby traces only direct data dependencies on pointers.
for instance given p q x where pandq are both pointers n eongoby only traces p s dependency on q notx.
similarly given p q n eongoby only traces p s dependency on the previous instruction that stores to the address of q and ignores p s dependency on q. neongoby stops tracing back when it finds the common parent pointer or it cannot trace the dependencies further due to for example external functions whose source is not available to n eongoby.
to use this tool on an error report a user needs to re run n eongoby s logger x3 to log more operations than pointer definitions and memory allocations including store instructions that store pointer values and call and return instructions of functions that return pointers.
.
supporting multiprocess and multithreaded programs as discussed inx1 n eongoby is explicitly designed to detect alias analysis bugs that manifest on real world programs such as apache andmysql .
these programs often use multiple threads and processes for performance and ease of programming so n eongoby must handle threads and processes.
it needs to do so only in the offline mode because the online mode checks intraprocedural queries.
specifically n eongoby shares one log over all threads in a process and protects the log using a mutex.
it assigns one log to each process.
when a process forks n eongoby creates a new log for the child process.
n eongoby can then check each log in isolation.
n eongoby assumes race freedom as most compilers do and data races in the worst case may cause some false positives.
fortunately data races occur so rarely that no false positives of this type occurred in our experiments x8.
.
.
.
limitation false positives.
neongoby assumes that test programs are largely correct and may emit false positives on buggy test programs.
for instance n eongoby may emit false positives on pointers off bound by many bytes x3.
.
moreover n eongoby works within a compiler so external functions may cause false positives.
for instance if an external function frees and reallocates heap memory n eongoby would miss this memory reuse.
false negatives.
neongoby is a dynamic tool and detects only alias analysis errors that manifest on the executions it checks.
moreover we explicitly designed n eongoby to be general to check many alias analyses with low false positives but this generality comes at a cost n eongoby cannot easily find bugs that violate a specific precision guarantee intended by an alias analysis.
in our future work we plan to specialize n eongoby s checking toward specific precision guarantees by varying the precision of its didalias .
in addition although n eongoby checks thatdidalias p q !mayalias p q it cannot dynamically check that if mayalias p q then there exists an execution s.t.
didalias p q for the following reasons mayalias may conservatively return true even if the two pointers never alias in any execution and even if the pointers do alias in some execution the given program and workload may not trigger this execution.
.
evaluation we evaluated n eongoby on three popular llvm alias analyses aa file description ds aa topdownclosure.cpp incomplete call graph traversal in the top down analysis stage ds aa stdlibpass.cpp matched formal argument nto actual argument n ds aa n a symptom missed aliases between actual parameters and the return value of an indirect call ds aa local.cpp mishandled variable length arguments ds aa local.cpp mishandled inttoptr andptrtoint instructions ds aa stdlibpass.cpp did not handle errno pointers returned from errno may alias ds aa stdlibpass.cpp did not handle getpwuid randgetpwnam r whose argument and return value alias ds aa stdlibpass.cpp did not handle gmtime r like functions whose return value and the 2nd argument alias ds aa stdlibpass.cpp did not handle realpath whose value and the 2nd argument alias ds aa stdlibpass.cpp did not handle getenv whose return value aliases for the same environmental variable ds aa stdlibpass.cpp did not handle tzname an external global variable ds aa stdlibpass.cpp did not handle getservbyname whose return values may alias ds aa stdlibpass.cpp did not handle pthread getspecific and pthread setspecific the value stored via pthread setspecific aliases that loaded via pthread getspecific with the same key ds aa stdlibpass.cpp did not handle strtoll the dereference of the 2nd argument may alias the 1st argument ds aa stdlibpass.cpp did not handle the ctype family of functions the return value of ctype bloc like function may alias ds aa stdlibpass.cpp did not handle freopen whose return value may alias stdin stdout orstderr anders aa andersens.cpp huvalnum incorrectly marked a pointer as pointing to nothing.
anders aa andersens.cpp mishandled indirect call arguments points to edge to argument nmay be attached to argument n anders aa andersens.cpp points to nodes representing indirect calls are swapped but argument info is not updated accordingly anders aa andersens.cpp queries on a function pointer and a function always return no alias even though they do alias anders aa andersens.cpp did not handle inttoptr andptrtoint instrucitons anders aa andersens.cpp did not handle extractvalue andinsertvalue instructions anders aa andersens.cpp incorrect summary for freopen whose return value may alias the 3rd argument anders aa andersens.cpp did not handle cxaatexit anders aa andersens.cpp mishandled variable length arguments anders aa andersens.cpp did not handle pthread create anders aa andersens.cpp did not handle pthread getspecific andpthread setspecific anders aa andersens.cpp did not handle strcpy stpcpy andstrcat whose return value aliases the 1st arguments anders aa andersens.cpp did not handle getcwd andrealpath table descriptions of the bugs found.
starred bugs were either already reported by others or mentioned in the comments of the code.
fileindicates the file and the line if there is a clear place to add the fix containing the bug.
.basicaa llvm s default alias analysis an intraprocedural flow insensitive analysis that collapses all address taken variables.
we chose the version of basicaa in llvm .
.
.ds aa a context sensitive field sensitive alias analysis with full heap cloning actively maintained by llvm developers.ds aa is used by .
we chose revision from ds aa s svn repo .
.anders aa an interprocedural andersen s alias analysis with three constraint optimizations hash based value numbering hu and hybrid cycle detection .
we ported the version of anders aa in llvm .
to llvm .
.
both anders aa andds aa have much better quality than typical research grade analyses ds aa in particular is used by many researchers regularly tested and actively maintained.
our test programs are mysql andapache two widespread server programs.
our workloads are benchmarks used by the server developers themselves sysbench for mysql which randomly selects updates deletes and inserts database records and apachebench for apache which repeatedly downloads a webpage.
we compiled these programs and benchmarks with clang .
and o3.
since mysql andapache are server programs we quantified n eongoby s overhead on them by measuring throughput.
5anders aa was maintained up to llvm .
so we ported it to llvm .
with a patch that removes lines and adds .
this patch is included in our release of n eongoby.
it does not change anders aa s functionality it merely fixes compatibility issues between llvm .
and .
it replaces debug output dout with dbgs migrates anders aa s handling of an allocation instruction because llvm .
replaces this instruction with other instructions adds code to handle a new type of constant constantdatasequential and changes the alias query interface to include sizes.
for each bug found in our port we verified that the bug also exists in the original anders aa .our evaluation machine is a .
ghz intel dual cpu core machine with gb memory running bit linux .
.
.
we made both sysbench andapachebench cpu bound by fitting the database or web contents in memory we ran both the client and the server on the same machine to avoid masking n eongoby s overhead with network delay we used four threads for the server and client and split the total eight threads on different cores to avoid cpu contention.
the remainder of this section focuses on three questions x8.
can n eongoby detect many bugs with low false positives?
x8.
what is n eongoby s overhead?
x8.
what are the bugs v.s.
overhead tradeoffs with different n eongoby techniques?
.
bug detection results this subsection shows the bugs x8.
.
and false positives x8.
.
neongoby found.
.
.
bugs found neongoby found total bugs in ds aa and in anders aa .
of the bugs are previously unknown and one ds aa bug has been fixed by the developers .
table shows all bugs.
of the bugs seven and are logical bugs three and mishandle llvm instructions the remaining nineteen mishandle external functions or global variables.
we pinpointed the root causes of all bugs in table to the source except bug .
since anders aa is relatively simple we fixed all its detected bugs.
bug causes ds aa to miss aliases between certain indirect calls actual parameters and return values when they indeed alias.
we reproduced it with a line c testcase and sent the testcase to ds aa developers .
our testcase differs only by one line from the running example in the paper describing ds aa .
basicaa anders aa fixed anders aa apache .
.
.
mysql .
.
.
table alias analysis precision.
percentages are no alias ratios.
next we elaborate on two most interesting bugs bug in ds aa and bug in anders aa both cause the points to graphs to miss edges and they require tricky fixes.
bug is caused by an incomplete call graph traversal in ds aa .
ds aa constructs its point to graph in three stages constructing a local point to graph for each function a bottom up analysis to clone each callee s point to graph into the caller and a top down analysis to merge each caller s point to graph into the callees.
the bottomup stage computes an unsound call graph gb and the top down stage computes a sound graph gtbased ongbby merging nodes and adding missing edges.
suppose the top down stage merges nodeaandbofgbinto nodecofgt.
when the top down stage traverses gt it needs to traverse both aandbwithin node c. however the code incorrectly traverses only one of them.
we reported this bug to ds aa developers and they have fixed this bug.
bug is caused by an incomplete depth first search dfs of the constraint graph in anders aa s implementation of the hu algorithm.
anders aa answers alias queries by collecting and solving load store assignment and address of constraints.
it organizes these constraints in a constraint graph.
it runs hu to identify the points to sets of pointers and unify the pointers with the same points to sets.
to do so it runs a dfs over all nodes.
it keeps a visited flag per node node2visited and sets the flag to true when it first reaches the node.
as an optimization when visiting a node representing p if the points to set of the node representing pis already determined to be empty anders aa simply sets the points to set of pto be empty.
the bug lies in anders aa s logic to determine when the points to set of pis already determined it wrongly believes the set is determined when p s visited flag is true even though it has not finished exploring p s descendants or even initialized p s points to set.
we fixed this bug by adding a new flag per node to indicate when dfs has finished exploring the node.
how bugs affect precision.
as discussed inx1 alias analysis bugs may cause tools to mistakenly believe that pointers do not alias when they indeed do invalidating research findings and compromising safety.
to illustrate we measured how bugs affect alias analysis precision using llvm s aliasanalysisevaluator which statically queries an alias analysis with all intraprocedural pointer pairs and computes statistics of the results.
we define precision as the percentage of queries with no alias results over all queries.
table shows the precision of basicaa anders aa and the anders aa after we fixed all its detected bugs.
although anders aa appears more precise than basicaa on both mysql and apache the fixed anders aa is actually lessprecise than the supposedly very imprecise basicaa .
this results illustrates that buggy alias results can indeed invalidate evaluation numbers.
.
.
false positives to evaluate n eongoby s false positive rate we ran it in the most thorough way the offline mode without any optimization this configuration ensures that n eongoby finds the most number of bugs and false positives.
x8.
shows how the number of bugs or false positives varies with different modes and optimizations.
we classified n eongoby s reports into true and false positives as follows.
for anders aa neongoby emitted many reports.
fortunately one bug typically causes thousands of reports so we classified the reports as follows.
we diagnosed one report produced a patch re ran n eongoby on the patched anders aa to regenerate reports classified the reports that disappeared as true posi ds aa anders aa mysql apache mysql apache true false bugs table true positives false positives and bugs.
the last row shows the number of bugs found from the true positive reports.
the numbers of ds aa bugs may be significantly larger than those shown in the table starred because we did not count a true positive report as a bug if we could not pinpoint its root cause in the source or reproduce it with a simple testcase.
tives and repeated.
after about iterations n eongoby emitted no more reports.
for ds aa neongoby emitted a relatively small number of reports so we manually inspected each report.
some reports are fairly simple to diagnose such as incorrect external function summaries.
for more complex ones we created small testcases to reproduce the problems or applied our diagnosis tool x6.
to compute a slice of relevant log records to simplify diagnosis.
we confirmed all ds aa reports into true or false positives and pinpointed the root causes in ds aa s code for about half of the reports.
we could not pinpoint the other reports or reproduce them with small testcases so we conservatively excluded them from our bug count.
thus the actual number of ds aa bugs found may be significantly larger than what we report.
we released our classification results together with n eongoby.
table shows the results on ds aa andanders aa with our test programs and workloads.
we did not include basicaa because n eongoby emitted no reports on it.
for ds aa neongoby emitted true positives on mysql and on apache .
for anders aa neongoby emitted true positives on mysql and on apache .
neongoby emitted only two false positives both of which occurred when checking ds aa onmysql .
these false positives are caused by the same specific code pattern shown in figure .
ds aa is context sensitive so it distinguishes foo s two calls and computes that pandqdo not alias.
however when running this code n eongoby logs four pointer definitions p addr0 q addr1 p addr1 q addr0 .
since n eongoby does not log function calls or returns its offline detection algorithm does not know that the 2nd and 3rd definitions are from different calls and adds them to didalias .
neongoby could have logged calls or returns to avoid these false positives but the additional logging overhead is not worthwhile given how rarely this specific pattern occurs and that n eongoby emitted only two false positives on ds aa with real world programs and workloads.
the last row of table shows the number of bugs found.
neongoby found at least ds aa bugs with mysql and with apache .
interestingly these two sets of bugs only overlap by one bug illustrating n eongoby s benefit of using real world programs with diverse programming constructs as testing programs.
neongoby found anders aa bugs with mysql and with apache and the apache bugs are a subset of the mysql ones.
.
overhead to quantify n eongoby s overhead we ran it in the most optimized way the online mode with all optimizations.
x8.
shows how the overhead varies with different modes and optimizations.
table shows the results on basicaa anders aa the fixed void foo int p int q f .
.
.
pand qdo not alias g foo addr0 addr1 foo addr1 addr0 figure a simplified example causing neongoby to emit a false positive.mysql apache basicaa anders aa fixed anders aa ds aa basicaa anders aa fixed anders aa ds aa compile .
.
.
.
.
.
.
.
aa .
.
.
.
.
.
.
.
insert .
.
.
.
.
.
.
.
codegen .
.
.
.
.
.
.
.
tput .
.
.
.
.
.
.
.
detect .
.
.
.
n a n a n a n a table n eongoby s overhead.
compile shows the total compilation time including the time to query the checked alias analysis aa insert alias checks insert and generate the executable from the transformed bitcode codegen .tput shows the relative throughput with n eongoby over without.
detect shows the offline detection time for function mysqlparse neongoby checks it offline because this yacc generated function has too many pointers x4 .
all times are in seconds.
anders aa and ds aa .
the compilation time of apache for every checked alias analysis is within 50s.
the compilation time of mysql is relatively longer mostly because anders aa andds aa are slower on mysql .
the throughput highly depends on the precision of the alias analysis.
for instance the throughput for ds aa is smaller than that for basicaa because ds aa is more precise.
interestingly the bugs in anders aa made it appear very precise so its throughput is also small.
however after we fixed all its bugs its throughput almost doubled.
n eongoby checks functionmysqlparse offline x4 so we also measured this time.
since neongoby logged only operations from mysqlparse the log was very small and most of the offline detection time was spent on querying the checked alias analysis.
.
bugs and overhead tradeoffs neongoby provides both the offline and online modes and several optimizations to enable users to flexibly trade bugs for low overhead.
this subsection evaluates these tradeoffs using anders aa because we have understood and fixed all its bugs.
we chose apache as the test program.
table shows the results.
offline v.s.
online.
columns base show that the online mode trades compilation time and a few bugs for significantly increased throughput and reduced detection time.
with less than 230s complication time the online mode improves the throughput of apache by about three times and eliminates the offline detection time of about 1400s.
it emits fewer true positives all reports are true positives but misses only one bug.
a bug often triggers many reports so n eongoby can still catch a bug as long as some of its reports are emitted.
delta checking.
this optimization improves performance for both the offline and online modes without losing bugs x5 .
we chose basicaa as the baseline.
columns delta show that delta checking reduces the detection time by .
in the offline mode it reduces compilation time by .
and increases the throughput by .
in the online mode.
the improvements would be even larger if a user incrementally checks her refinements to her alias analysis.
offline online base delta delta deref base delta delta deref compile .
.
.
.
.
.
tput .
.
.
.
.
.
detect .
.
.
n a n a n a true bugs table bugs and overhead tradeoffs.
the base columns represent the baseline of the offline and online modes delta with delta checking x5 delta deref with both delta checking and using dereferenced pointers only x6.
.
the row titles match table and table .
there is no false row because n eongoby emitted no false positives on anders aa .
to collect all true positive reports in the online mode we changed the online mode to emit a report upon an error instead of aborting the current execution.detecting errors using dereferenced pointers only.
this optimization improves the performance of both modes but may lose bugs x6.
.
columns delta deref show that this optimization reduces the compilation time by .
for the online mode it increases the throughput for both offline and online modes by .
and .
respectively it reduces the offline detection time by .
and it misses out of bugs in the offline mode and out of in the online mode.
.
related work previous sections have discussed how n eongoby is related to bounds checkers or general memory safety tools this section discusses other related work.
alias analysis.
a plethora of work has been devoted to creating faster more precise alias analyses .
this previous work is complimentary to ours because our goal is to effectively detect errors in alias analysis implementations.
there have been several studies on alias analyses though their focus is on precision and overhead not correctness.
specifically llvm s aliasanalysisevaluator collects statistics about an alias analysis such as how many pointer pairs do not alias and how many may alias.
hind and pioli implemented six context insensitive alias analysis algorithms and compared their precision and time and memory consumption on programs up to k lines of code.
jablin et al.
compared the performance of their system using different alias analyses and found that the combination of research grade alias analyses sometimes performs worse than the production quality alias analysis in llvm.
software error detection.
a plethora of work has also been devoted to software error detection or verification e.g.
.
most of these systems target general programs whereas n eongoby targets alias analyses.
these analyses take programs as inputs do complex computations and compute abstract results with difficult to specify guarantees.
thus prior systems are not directly applicable to detect alias analysis errors.
testing and verifying compilers has also been an important topic for programming language researchers though to the best of our knowledge we are not aware of any prior system for effectively detecting alias analysis errors.
.
conclusion we have presented n eongoby a system for effectively finding alias analysis bugs.
n eongoby dynamically observes pointer addresses and emits errors if the addresses contradict an alias analysis.
our key inspiration of this work is our anecdotal struggles with some existing alias analyses so we hope that n eongoby can help improve advanced alias analyses into production quality analyses and vastly widen their adoption.
as such we have released it open source at along with our error detection results and proposed patches.