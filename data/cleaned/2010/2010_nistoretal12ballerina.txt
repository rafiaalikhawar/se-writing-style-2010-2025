ballerina automaticgeneration and clustering of efficie nt random unit tests formultithreaded code adriannistor1 qingzhouluo1 michaelpradel2 thomasr.gross2 darkomarinov1 1department of computer science university of ill inois at urbana champa ign usa 2department of computer science eth zurich sw itzerland nistor1 qluo2 marinov illinois.edu michael binaervarianz.de thomas .gross inf.ethz.ch abstract testing multithreaded code is hard and expens ive.
a multithreaded unit t est creates two or mor e threads each executing one or more methods on shared obj ects of the class under test.
such unit t ests can be generated at random but basic random generatio n produces tests that ar e either slow or do not trigger concurre ncy bugs.
worse such t ests have many false alarms which req uire human effort to fil ter out.
we present b allerina a novel technique for automated random generation of efficient multithreaded tests that effectively trigger concu rrency bugs.
b allerina makes tests efficient by having only two threads each exec uting a single randomly selected meth od.
ballerina increases chances that such simple parallel co de finds bugs by appen ding it to more complex randomly gen erated sequential code.
we also propose a clustering technique t o reduce the manual eff ort in inspecting failures of automatical ly generated multithre aded tests.
we evaluate b allerina on real world bugs from six popular codebases groovy jd k jfreechart apache log4j apache lucene and apache p ool.
the experiments s how that tests generated by b allerina find bugs on average 2x 10x faster than basic random gen eration and our cluste ring technique reduces the number of inspected failures on a verage 4x 8x.
using b allerina we found three previo usly unknown bugs two of which were alre ady confirmed and fixe d. i. introduction general purpose proces sors manufactured toda y have multiple cores and the projections are that the number of cores will be increa sing.
to harness these cores for speedinguptheirapplica tions developersnowwr iteparallel code typically using a m ultithreaded shared mem ory programming style.
howev er writing multithreaded software isnotoriouslydifficult a sthesamecodecanhav edifferent behaviorfordifferentthre adinterleavings.addition ally testing multithreaded softwa re is expensive because it requires writingappropriatete stcode exploring ma ny thread interleavings of this test code while checking ora cles and inspectingoraclevio lations.
most research on testin g multithreaded softwar e has focused on imp roving approaches for s tep exploringthreadinterleav ingsandcheckinggeneri coracles.
these approaches typica lly do not generate test code but only explore the given test code for various th read interleavings and apply gene ric oracles checking for bugs such asdataraces atomicityv iolations non determinis m ornon linearizability .
if an interleaving vi olates an oracle a potential bug i s reported to the develo per.
these approacheshaveshowna lotofpromiseinfinding realbugs.
however theyrequireto begiventestcodeasinpu t andthey canproducealotoffals ealarms.
automaticallygenerating unittestcodeformultith readed softwarecouldgreatlyea setestingofsuchsoftwa re.while many techniques have b een proposed for autom ated generation of test code for sequential software e.g.
random generation of unit tests for object oriented softw are they do not directl y apply to multithreaded software.
namely test code for m ultithreaded object orien ted software needs to create on e or more objects that a reshared among multiple threads and to invoke methods on these objects putting arbitrary test code for sequential software intomultiplethreadsrare lycreatesenoughsharing totrigger concurrencybugs.
abasicrandomgenerationofmultithreadedtests can achievesharingbyfirstc reatinganobjectsequent iallyusing arandomlyselectedconstructorandtheninvokinginseveral parallel threadsrandomly selected meth ods on this object.
unfortunately thisgenera tionhastwomajorproble ms.first it can take a lot of mac hine time to explore the generated test code because the to tal number of thread int erleavings growsexponentiallywith thenumberofthreadsan dsharing amongthreads.second i tcantakealotofdevelop ertimeto inspectthereportsgenera tedbyviolationsofgener icoracles formultithreadedtests b ecausesuchoraclescanc reatealot offalsealarms e.g.
on theorderoftenfalseala rmstoone truebugreport asshown insectionv .
thispapermakesthreec ontributions.
a novel technique fo r generating efficient multithreaded tests that are effective at triggering concurrency bugs we propose b allerina a novel technique forautomatedrandomge nerationofefficientmult ithreaded unit test code.
b allerinatakes as input a class u nder test and a set of its m ethods and generates a s output multithreaded tests that arebothefficient and effective a t triggering concurrency b ugs.
the key idea is to minimize parallel execution to red uce the time needed for exploring it without sacrificing th e bug triggering capabil ities.
the minimal possible configu ration for multithreaded unit tests ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
istwothreadsthateachex ecuteasinglemethodun dertest.
combining this minimal configuration with basic random generation would miss m any real world concurren cy bugs.
instead ballerinaprepends the minimalparallel suffix with a more complexsequential prefixthat grows the object s under test cre ating the conditions nec essary to triggerbugsintheparall elsuffix.
ballerinafocuses on bugs that ca n be triggered by two threads.
this suffice s for almost all real wor ld concurrency bugs a recent stud y of concurrency bugs in large c c application s mysql apache mo zilla and openoffice foundthato nlytwobugsrequireatl eastthree threads inotherwords 4outof96bugscanbere produced withonlytwothreads.
after ballerinageneratesmultithreaded tests itneeds to explore and check th em.
exploration is orth ogonal to generation so b allerinacould use stress testing randomizedthreadinterle avings and ors ystematic exploration .
our ballerinaimplementation uses java pathfinder jp f .
for checking ou r implementation useslinearizability which intuit ively reportsaviolationwhene verathreadinterleaving produces a behavior that cannot b e produced in any linea rized test execution where all meth ods execute atomically.
w e chose linearizabilitybecauseit canfindrealconcurrency bugs .
clustering oracle viol ations for faster insp ection whilesomelinearizabili tyviolationsshowtrue b ugs other violations are false alarm s. for example the apa che pool can throwconcurrentmodificat ionexceptionin some concurrent scenarios but does not throw this exc eption in a corresponding sequent ial execution.
this beha vior is a linearizabilityviolation b utitisclearlyspecifiedin thepool documentation so it is a benign violation not a t rue bug.
ideally aperfectoracle wouldnotreportthisbeh avior but allknowngenericoracle sformultithreadedsoftw arecreate falsealarms e.g.
of reporteddataracesarebe nign .
ballerinaalleviatestheproblemof falsealarmsusing clustering.
we build on the idea of clustering failures for sequentialcode first reportsaresplitint oclusters with similar failures tha t are likely to be either all false alarms or all true bugs then rather than insp ecting the reportsinanarbitraryor der thedevelopercanin spectthem by selecting from differe nt clusters.
b allerinaperforms clustering based on conc urrently executing metho ds under testandthetypeoffailu re.
evaluation we evaluate b allerinaon14 real world bugsfromsixpopularcodeba ses groovy jdk jfreec hart apachelog4j apachel ucene andapachepool.
wecompare ballerinawith basic random gene ration of multithreadedtestsofsixdiffe rentsizes basedonthen umberof threadsandmethods .we considerfourdifferentex ploration approaches chess like preemptionbounding exhaustivestatefulsearchusedi njpf statelesssearch and parallelizedtestexecution andmeasurethecostof exploring1classgenericobjectpoolextendsbaseobjpoolimplementsobjpool 2genericobjectpool poo lableobjectfactory fact ory intmaxactive ... 3objectborrowobject ... 4voidreturnobject object ob j ... 5voidaddobject ... 6voidinvalidateobject objec tobj ... 7voidclear ... 8voidevict ... 9voidclose ... 10voidsetmaxactive intmaxactive ... 11intgetmaxactive ... ... figure1.
apiforthegenericobjectpoolclassfromapachepool generated tests to find a bug.
compared to basic random generation of minimal t ests two threads each with one method b allerinafindsmorebugs 13vs.
.compared to basic random genera tion of larger tests two or more threads each with two or more methods tests generated byballerinatrigger the bugs substan tially faster 2x10xonaverage.
weevaluatetheeffective nessofourclusteringtec hnique forboth b allerinaandthebasicrandomge neration.for some cases there are n o false alarms i.e.
all reported violations are true bugs .
for some other cases there can be a large number of fa lse alarms.
without clus tering the developer would need t o sift through a large n umber of reports e.g.
dozens to find a true bug.our clustering reduces inspection time the developer needs to inspect a smallnumberofreports e.g.
tofindatrue bug.
using ballerina we foundthree previously unknow n bugsin the widely used apa che log4j and apache pool.
twobugswereconfirmed andfixed and thethird isstillunderinvestigatio n .
ii.
example to illustrate how b allerinaworks we use the exam ple of testing a class fr om the apache pool lib rary.
the library provides several classes that implement p ools i.e.
collections of objects th at can be shared amon g several threads.
figure shows declarations of several methods fromthegenericobjectpoolclass.theconstructorta kes afactorythat creates objects for the pool and sets the maxactivenumber of objects in th is pool.
clients of this classfirstobtainanobje ctfromthepool borrowobject then work with this ob ject and finally return it back to the pool returnobject .
the methodsclearandevict remove from the pool a ll idle objects i.e.
thos e not currentlyborrowed andall objectsthatsatisfycertai ncriteria respectively.theclassal sohasalargenumberof getterand settermethods butwes howonlythoseformaxactive.
thegenericobjectpoolclass is highly concu rrent.
because a number of clients can be invoking the pool methodsfromdifferentt hreads genericobjectpooldoes notgloballylocktheent irepoolforeachmethod butratheruses fine grained lockin g so that a number of methods proceedconcurrently.
suppose that we want to test howgenericobjectpool behaves when clients c all various methods fro m multiple threads.
it is easy to apply b allerinato generate multithreaded unit test c ode forgenericobjectpool.
we instruct b allerinato test this class and its methods listed in figure .
we a lso provide a simple fac tory class becausepoolableobjectfacto ryisaninterface andany testwouldneedtoprovi deaconcreteclass.
generating tests with ballerina ballerinarandomlygeneratestests ea chofwhichconsistsof twoparts.
thesequential prefixcreates anobject under test out inourexampleagenericobjectpoolobject andinvokes severalmethodsonthato bject.theparametervalu esforthe methods are randomly g enerated by creating oth er helper objectsasnecessary.theparallel suffixcreatestwothreads that each execute only one of the given metho ds on the outcreatedintheseque ntialprefix.thetestexec utionwill exploremultipleinterleav ingsofthesetwothreads .
figure2showsanexamp letestgeneratedbyb allerina.
the out isvar4.
its constructor setsmaxactiveto1.
aftervar4iscreated addobjectisinvokedonit.bothth e parameter value and the method call addobject are requiredtobringvar4inastatewhereabugis triggeredby theparallelsuffix.inthe parallelsuffix thethread st1and t2invokeborrowobjectandevict respectively onvar4.
we also showvar2generated by b allerina although it isnotnecessarytotrigge rthebuginthiscase.
executing the b allerina tests ballerinauses knowntechniquestoexpl oredifferentthreadinterl eavingsof generatedtests andtocheckforpote ntialbugs usinglinearizability .f orexample exploringthe testfrom figure with chess li ke exploration preempti on bound of two finds a non linearizability violation executing borrowobjectandevictatomicallysucceedsbut executing them concurrently d eadlocks.
b allerinapresents to theuserareportwithth istestanditsinterleavin g. real unknown bug our inspection of t his example indeed revealed a previously unknown bug in genericobjectpool whichthepooldevelope rsconfirmed and fixed after we had i nformed them.
the analy sis shows thattriggeringthisbugre quiresaparticular non tr ivialpool state and execution con dition as described by the pool developers wheneve rmaxactiveisabouttob eattained byaborrowobjectwitho neidleinstanceinthepo ol ifone thread does a borrow w hile the evictor is visitin g the idle instance theborrowingt hreadwillstalluntilanot herthread doesaborroworreturn.
.suchstatecannotb ecreated withatrivialsequential prefix andhavingamor ecomplex parallel suffix would inc rease the exploration tim e to find thebug.
comparison with basic random generation exploring many thread interle avings for a given test is expen 1voidtest sequential prefix obje ct under test out var4 3finalsimplefactory var0 newsimplefactory 4finalgenericobjectpoolvar newgenericobjectpool var 5finalgenericobjectpoolvar newgenericobjectpool var 6var4.addobject parallelsuffix 8threadt1 newthread public voidrun var4.borrowobject 10threadt2 newthread public voidrun var4.evict 12t1.start t2.start 13t1.join t2.join figure2.
atestgenerat edbyballerinathattriggeredanunknow nbug sive .
the cost is increasing with the n umber of threadsandthenumbero fsharedmemoryaccesse sineach thread.
ballerinaminimizes this cost by g enerating the minimal possible parall el section two threads with one method each.
in contras t consider basic random tests that wouldhavethreeormor ethreadsand orexecute morethan onemethodperthread.t hesetestswouldhavemo rethread interleavingsandwouldb eslowertoexplorewhen theytriggernobug.however iti snotclearapriorithatth eywould take more time to trigg er the bug because tes ting more methods at once could increase the chance to t rigger the bug .inourexampleofgenericobjectpool experimental results section v show that ballerinatests trigger the bugabout5xfasterthan basicrandomtestswithtw othreads andtwomethodseach w hileotherconfigurations withmore threadsormethodsaree venslower.
report clustering to reduce the time fo r inspecting reports ballerinaintroduces a novel repo rt clustering basedonthemethodsun dertestthatexecuteatth epointof failure and the type of f ailure.
the intuition is th at similar reports are likely to be either all false alarms o r all true bugs.ourevaluationsho wsthat forgenericobjectpool both ballerinaand basic random tests can generate up to hundreds of false alarms for each true bu g which would require that the d eveloper inspects a larg e number of false alarm reports t o find a true bug rend ering the toolimpractical.withou rclusteringtechnique ho wever the developer needs to inspe ct only three or four fal se alarms beforefindingatruebug report.
iii.
generatingtests we next describe how ballerinagenerates multithreadedunittestsfora givenclassundertest c ut anda setofmethods.eachtest consistsoftwoparts asequential prefixthat creates anobject under test out with a cut constructorandpotential lycallssomemethodson theout sequentially andaparallel suffixthatcallstwomethodso n theoutconcurrently.
a. generating sequentia l prefix ballerinamodifiestherandoopalg orithm togeneratetheoutintheseq uentialprefix.ingeneral randooptakes as input a set of classes under test and generates sequentialteststhathave randomsequencesofme thodcalls totheseclasses.randoopbroadlybutsparselycoversstates of objects from these cl asses.
even when given only one cut randoopsparselyc oversstatesofobjectsof thatclass e.g.
calling methods on many objects but not ne cessarily calling many methods o n one object.
in contrast we want ballerinatomore denselycoverstatesofobjectsf orthe onegivencut.tothate nd wemodifiedrandoo ptofocus thegenerationononeoutforeachsequenceandto grow suchobjectsacrossvario ussequences.
figure3showsthepseud o codefortherelevantpa rtofthe randoopalgorithm adap tedfrom andtheb allerina addition highlighted lin es .
the algorithm maintains a collection o f method sequences.
fo r each sequence that can create one or more objects of the cut ballerinatagsexactly oneout.somesequences create no objects of the cut but only objects of othe r classes such assimplefactoryin the example from fi gure .
in that case there is no o ut but such sequences are still useful becausetheycan beusedasparametersfo rmethods insequencesthatdohav eanout.
in lines and rando op randomly chooses a method m whoseparametershave types i somesequencesseqs that can create method p arameters and expressio nse ifor these parameters e.g.
a variable such asvar0 ornullif no object of a type is a vailable or constants fo r primitive types .inline9 randoop generatesanewrandoms equence newseqbyappendingsequences forparametersandaddin g anewcallnewv ar m e .
.
.
e n itthenchecksthatthe newsequencedoesnotf ailwithuncaughtexcept ions.
ballerinaadditionallyselectsand o rupdatestheout.
inline8 ifthereceiverh asthecuttype thenb allerina does not randomly selec t the expression for that parameter butselects the out from t he appropriate sequence.
thus theoutfromtheseque nceseqs isenhancedbycalling themethodm .
.
.
n onit andthesameobje ctbecomes the out for the newly created sequencenewseqin line .
in line b allerinacreates a new out whe nm is a cut constructor or a static method returnin g objects ofthecuttype.ifam ethodbothreturnsanob jectofthe cut and has the receive r of the cut type then the out isthereceiver.effectivel y thisfavorsenhancingt hestateof out asopposedtocrea tinganewout.
while ballerinaaims to create diversity of states for objectsofthecut italso avoidsredundantstatesth atwould only increase testing tim e but not the chance to find bugs.
inline13 b allerinachecksifthenewoutw asalready generatedbyanotherseq uence.randoophasasim ilarcheck but for the objects produ ced by the last method c all in the newsequence while b allerinafocusesontheout.
to illustrate recall figu re and consider the se quence that consists of the firs t three constructor cal ls call it s. assume thatvar4is the out forsand further1algorithmrandomlygeneratemeth odsequences 2input classundertest cut methodsundertest 3output collectionofnon error methodsequences 4nonerrorseqs emptycollection 5while timelimitnotreached 6m .
.
.
n randomlyselectonemeth od methodsundert est seqs e .
.
.
e n randomseqsandexprs nonerrorseqs .
.
.
n 8if cut e seqs .out 9newseq newv ar append seqs m e .
.
.
e n 10if executingnewseqfails continue 11if cut newseq.out e 12else if returntype m cut newseq.out newseq.newvar 13if s nonerrorseqs s.t.
s.out.equals newseq.out continue 14nonerrorseqs nonerrorseqs newseq figure3.
integratingb allerina sgenerationofsequenti alprefixinthe randoopalgorithm.
b allerinacodeishighlighted.
that ballerinarandomlyselectstheme thodaddobject.
the only parameter i. e. the receiver is of the type genericobjectpool which is the cut.
if ballerina selectsthesequencesforthattype itthensele ctstheout var4 ratherthanvar2 astheexpressionfortha tparameter.
b. generating parallel s uffix after generating a collec tion of sequences b allerina usesthemtogeneratemu ltithreadedtestsbyaddin gcodefor thethreads.foraparalle lsuffix ballerinafirstrandomly selectstwomethodsfrom thegivenset.theselecti onisnot uniform but based on th e number of method par ameters of the cut type.
we call these parameterscut parameters.
a method that has two or more cut parameter s is twice as likely to be selected t han a method that has o ne or zero cut parameters.theint uitionforthisbiasistha tmethods withmorecut paramete rshavemoreinteractions between the objects of the cut and are thus more likely to trigger concurrency bugs.
of th e methods in figure none has morethanonecut para meter sotheyareallequ allylikely to be selected for the e xample in figure b allerina selectedborrowobjectandevict.
after selecting two meth ods ballerinarandomly selects parameters for thes e methods.
b allerinafirst randomlyselectsfromtheco llectiononeortwoseque nceswith an out to use in the s equential prefix.
b allerinauses two sequences if any of the two selected method s has two or more cut parameters otherwise it uses one sequence.
we call these sequencesselected sequences.
for our runningexamplewithborrowobjectandevict thereisone selectedsequence which endswithvar4.addobject.
ballerinanext selects the expres sions for the parameters of the two me thods.
if a parameter ty pe is the cut ballerinarandomly selects the ou t from one of the selected sequences.
otherwise b allerinarandomly selects an object of the appropriate type from th e selected sequences because those sequences can have othe r objects besidestheout or ifth ereisnosuchobject b allerina selectsasequencefromth eentirecollection.inour example each receiver paramete rforborrowobjectandevictisfromthecut andthusb allerinaselectsvar4 resulting inthetestshowninfigu re2.
iv.
reportclustering ballerinauses linearizability as a generic oracle and may report f alse alarms.
to alleviate the problem of inspecting failure reports ballerinacan cluster test failures based on th eir similarity.
each failu re report contains several pieces of information the test that was executed including the methods called from the test ballerinagenerates only two me thods per test but the basic random genera tion can generate a large r number of methods per test the thread interleaving that was executeduptothefailure thestacktraceforea chthread including theexecuting methods i.e.
the methods unde r test that were executing at the point of the failu re and thetype of failure deadlock or an excepti on including the class of the exceptio n e.g.
nullpointerexceptio n orconcurrentmodificat ionexception .
in general all thesepiecescouldbeus edtodeterminefailures imilarity.
ballerinausesonlytheexecutingm ethodsandthetype offailuretodeterminesim ilarity.ourexperimentss howthat these two pieces of info rmation already provide excellent resultsforclusteringfailu resofautomaticallygene ratedmultithreaded unit tests.
mo re specifically b allerinasplits thefailuresintoclusters suchthatallfailuresino necluster have thesamesetof executingmethodsunder test i.e.
the allocation of method s to threads does not m atter and thesametypeoffail ure.notethatseveralrep ortsfrom the same test can end u p in different clusters a nd reports fromdifferenttestscane ndupinthesamecluste r.indeed while deterministic se quential tests can have only one outcome passorfail am ultithreadedtestcanhave different outcomes for different th read interleavings some of which maybefalsealarmswhi leothersaretruebugs.
splitting reports into cl usters is the first step i n using clustering the next step is determining thesampling strategy for inspectin g reports from the clust ers.
a commonsamplingstrateg y whichweal souse is to randomly order cluste rs and visit them in a ro und robin fashion randomly select ing one report for inspec tion from eachcluster.anotherstr ategy specifictothemu ltithreaded code wouldbetoinspect thefailuresinaclusterin theorder inwhichthetestexplora tionproducedthem.we foundthat the latter strategy does not provide better result s than the formerbecausetwocons ecutivefailureshavesim ilarthread interleavingsandthusare likelytobeeitherbothfal sealarms orbothtruebugs.
v. evaluation we evaluate b allerinaon14 real world bugsfrom six popular codebases g roovy jdk jfreechart apache log4j apache lucene and apache pool.
figur e shows the following informatio n about each bug the a pplicationname the bug id that w e will use in the rest of the paper theissueidfromtheapp lication sissue trackings ystem the number of lines of code in the application the cl ass under test itsnumberoflineso fcode thenumberofme thodswe giveballerinatotest andthetypeofb ug.wechosethe methods to test among the more complex meth ods in the cut simulating how an expert developer of mult ithreaded codewoulduseherintui tiontofocustheb allerinatool.
ourevaluationaddresses thesethreeresearchques tions rq1 do tests generated by ballerinafind more bugs and orfindbugsfasterth antestsgeneratedbybas icrandom generation?abasicrand omtesthastthreads eachexecutingmmethods under test it is not obvious whicht m configurationworkstheb est soweevaluatesix and3 .forbasicrandom the sequential prefix randomly chooses a constructor and its p arameter objects fortheout wh ileballerinaalsohasuptothree methodcallsontheout bothpotentiallyhavemor emethod callsfortheotherobject susedasparameters.
rq2 does the speedup provi ded by ballerinavary for different exploration app roaches?
we consider ch ess like preemptionbounding exhaustivestatefulsear chusedin jpf statelesssearch andparallelizedtest execution.
thereasonforconsideri ngmultipleexplorationa pproaches isthatthereisnoestabli shedbestapproach.
rq3 doesourclusteringtech niquereducetheefforto finspectingviolationsreport edbyexplorationoftests generated by ballerinaandbasicrandomgenera tion?
to compare the explora tion cost of tests we u se the number of transitions ex ecuted by stateful jpf w hile exploring the state space a nd the number of execu tion paths for the stateless explorat ion based on re executio n. this is consistent with previous studies on exploration c osts .
we do not u se the actual real time from jpf because we conducted the experiments on a c omputing clusterthathasmachines withdifferenthardware.
notethat we compare cost toexplore not to generatetests because generationcostisaboutt hesameforvarioustechn iquesand oftenmuchsmallerthan explorationcost.
both ballerinaandbasicrandomgenera tetestsusing randomselection.toche ckhowtheresultsvaryfo rdifferent random seeds we eval uate both b allerinaand basic randomusing200seeds.
a. answering rq1 figure shows the cos t that chess like preem ptionbounded exploration incurs to find a true bug for tests generated by b allerinaand basic random.
for e ach bug we show seven box plot s one for b allerina blr and sixforconfigurationsof basicrandomgeneration.
eachbox plot shows five values th at summarize the explor ation cost over random seeds median upper and lowe r quartile values andthemaxandm invaluesnotoutsidethe .5interquartile range.
all the va lues are normalized to .
for theapplication bugidissueidtotalloc classundertest cut cutloc methods error groovy 872memoryawareconcurren treadmap 5deadlock jdk 335stringbuffer 9deadlock jdk 555logger 11exception jdk 550logger 9deadlock jfreechart 027numberaxis 7exception log4j 273fileappender 13exception log4j 770category 9exception log4j 098asyncappender 12deadlock log4j 875asyncappender 12deadlock log4j 033writerappender 12exception lucene 347phrasequery 7deadlock pool 615generickeyedobjectpool 10deadlock pool 337genericobjectpool 9deadlock pool 880genericobjectpool 9starvation figure4.
basicstatistic saboutthetestedcodea ndbugs.issueidisfrom therespectivebugdataba se.
ballerinamedian for the respectiv e bug.
for example for pool a new bug we found in pool the m edian of is about which me ans it is about 5xslower not faster thanthemedianofbl r.notethatsomevalue sare out of bound in which case we showthe smallestof the five values that is out of bound.
for example for pool and the next value that is missing is upper quartil e and it is .
in some c ases a technique does no t find the bug which is marked w ith not found but we still show the exploration cost for the generated tests .
for example forpool thetestsgen eratedby2 1donotfindthebug.
the tests generated by miss eleven out b ugs while tests generated by miss five out of bugs.
in contrast b allerinaand all other configurati ons miss only one out of bu gs jdk .
triggering this bug requires that the object state has a special strin g format that is unlikely to be c reated by any random g eneration.
more specifically trigg ering the bug requires a call to thereadconfiguration i nputstream ins method the insparameter can come fro m a string but it needs to be inthejava.util.propertie sformat asspecifiedbyt he readconfigurationdocumentation.thus us ingarandom string like hi!
does not suffice and r andoop does not randomlygeneratestring slike x.level fine .
tests generated byb allerinacan find more bugs thantestsgeneratedbys implebasicrandomconfi gurations and .
wenextturntocomparin gthecostsforthebasicr andom configurations that find the same bugs as b allerina.
figure5showsthedistri butionofcostsoverrand omseeds.
we can see that the co st for ballerinais often lower thanthecostforbasicran dom althoughtherearei ndividual scenarios when basic ra ndom is faster than b allerina e.g.
for pool the m in whisker of is close to whereas the max whiske r of ballerinais close to .
to summarize the comparis on into one number we compute thearithmeticmeancostacrossrandomseed s whereasbox plotsshowmedianvalues .figure shows the mea n exploration cost for a ll bugs and compared configura tions.
for now we discu ss the left halfofthetable forche ss likepreemptionboun ding.we tabulate the mean numbe r of transitions that expl oration of tests generated by b allerinatake to find the bug an d theslowdownofbasicra ndomconfigurations com putedas the ratio of their mean over the mean for b allerina .
thelastrowshowsthea verageslowdown compu tedasthe geometricmean.thecellsmarkedwith n f representcases whenaconfigurationdoe snotfindabug.
for the basic random te sts with two threads th e configuration that finds the bugs fastest on average is andnot2 as one might expect.
t he reason is that executes six methods pe r test whereas executes only four and while explorat ion of a given test is faster than a given test has a higher chance of finding a bug.
the individual slowdown of these con figurations over ballerinaranges from .3x for j dk and to .1x for jdk an d .
for two cases groo vy and log4j and even find a bug faster than or as fast as b allerina and their speedup is re flected as slowdowns oflessthan orequalto1.
.triggeri ngthese bugsdoesnotrequirecom plexobjectstate justpara llelcalls tothebuggypairofmeth ods.infact thesearetwo bugsthat even2 1canfind becausethey aresosimpletotrigger.
thebasicrandomtestsw iththreethreadsarequit eslow with average slowdown of over 8x compared to ballerina.consideringthelargec ostoftestswiththreeth reads andtherecentstudy whichfoundthatonly twoofthe 96real worldconcurrenc ybugsinlargec c ap plications require at least three th reads to trigger we be lieve that focusing b allerinaon two threads is the rig ht trade off.
iftheprogrammerwants tolookforbugswiththre eormore threads she would first run fast tests with two th reads and onlylaterruntheslower testswiththreethreads.
testsgeneratedbyb allerinafindbugsfasterthan tests generated by basic random configurations w hich find the same bugs on a verage .6x .4x.
blr 2x1 2x2 x3 3x1 3x2 3x groovy blr 2x1 2x2 x3 3x1 3x2 3x jdk blr 2x1 2x2 x3 3x1 3x2 3x jdk 3not found blr 2x1 2x2 x3 3x1 3x2 3x jdk 4not foundnot found not foundnot foundnot foundnot found not found blr 2x1 2x2 x3 3x1 3x2 3x jfreechart 5not found blr 2x1 2x2 x3 3x1 3x2 3x log4j blr 2x1 2x2 x3 3x1 3x2 3x log4j 7not found blr 2x1 2x2 x3 3x1 3x2 3x log4j 8not found blr 2x1 2x2 x3 3x1 3x2 3x log4j 9not found not found blr 2x1 2x2 x3 3x1 3x2 3x log4j 10not found not found blr 2x1 2x2 x3 3x1 3x2 3x lucene 11not found not found blr 2x1 2x2 x3 3x1 3x2 3x pool 12not found blr 2x1 2x2 x3 3x1 3x2 3x pool 13not found not found blr 2x1 2x2 x3 3x1 3x2 3x pool 14not found smallest of the five numbers below that exceeds the bound medianupper quartile plus .
times interquartile rang e lower quartile minus .
times interquartile rang eupper quartile lower quartile figure5.
numberoftr ansitionstothefirstexec utionforagivenbugsce nariopreemption boundedexp loration exhaustivejpfexplorati on bugblr slowdownrelativetobl r blr slowdownrelativetobl r absolute 2x12x22x33x13x23x3 absolute 2x12x22x33x13x23x3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
n f11.
.
.
.
.
n f20.
.
.
.
.
n fn fn fn fn fn fn f n fn fn fn fn fn fn f 024n f4.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
196n f3.
.
.
.
.
263n f12.
.
.
.
.
n f3.
.
.
.
.
n f3.
.
.
.
.
n f4.
.1n f14.
.
n f3.
.3n f4.
.
920n f4.
.6n f3.
.
n f1.
.8n f0.
.
958n f6.
.8n f35.
.
516n f8.
.5n f224.
.
n f2.
.
.
.
.
n f7.
.
.
.
.
n f3.
.0n f44.
.
n fn fn fn fn fn f11.
n f4.
.
.
.
.
n f10.
.
.
.
.
slow .
.
.
.
.
.
.
.
.
.
.
.
figure6.
statefulexplo ration meannumberof transitionstothebugsce nario.thelastrowshow sthegeometric meanofslowdowns.
numberofpaths numberoftransitions bugblr slowdownrelativetobl r blr slowdownrelativetobl r absolute 2x12x22x33x13x23x3 absolute 2x12x22x33x13x23x3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
n f12.
.
.
.
.
n f21.
.
.
.
.
842n f3.
.
.
.
.
n f4.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
890n f1.
.
.
.
.
n f2.
.
.
.
.
n f3.
.
.
.
.
n f5.
.
.
.
.
n f3.
.7n f15.
.
n f1.
.7n f13.
.
950n f4.
.4n f6.
.
n f1.
.1n f4.
.
338n f4.
.5n f30.
.
109n f6.
.7n f65.
.
n f0.
.0n f7.
.
n f0.
.1n f7.
.
n f1.
.
.
.
.
n f0.
.
.
.
.
slow .
.
.
.
.
.
.
.
.
.
.
.
figure7.
statelessexp loration meanexploratio ncosttothebugscenari o.thelastrowshowsth egeometric meanofslowdowns.
b. answering rq2 we now look at how s table the b allerinaspeedups are over basic random fo r various types of explor ation.
so far we have considered chess like preemption bounded exploration .
we con sider three additional se ttings exhaustivestatefulsearchw ithpartial orderreduction usedby default in jpf state less search and pa rallelized testexecutionwherethe testsareexecutedonsev eralcores at once.
we chose these settings as they are repre sentative of what currently availa ble tools like jpf or c hess do.
for parallelized test exe cution we simulate wha t happens with four and eight cor es because these are th e typical configurationsforthecu rrentinteli7processors.
forspace reasons weshowonlyth emeanvalues notfullboxplot s. figure6showstheresult sforchess likeandexh austive jpfexplorations.wehav ediscussedtheresultsfo rchesslikeexploration.theres ultsforexhaustivejpf e xploration are similar.
the absolute number of transitions re quired to find the bug is higher than for chess like ex ploration but ballerinastillmaintainsitsrelative speedupoverall basic random configurati ons.
the average speedu p is even somewhat larger e.g.
.3x vs. .0x for .
note thatthe pool bug is fou nd by preemption bound ed exploration but not by exhau stive jpf exploration.
t his is due to the interaction of jp f s partial order reducti on por andlinearizabilitychecki ng.becausejpf sporc ouldalso affectthechess likeex ploration weturnoffpo rforthis exploration turningpor offfortheexhaustiveex ploration would result in excessive ly high jpf runtime.
we reported this behavior to jpf de velopers and to the be st of our knowledge itdidnotaff ectanyotherexperiment .
figure7showstheresul tsforstatelessexploratio nbased on re execution.
while j pf checkpoints and resto res states to explore thread interle avings stateless case co nsiders an explorationthatwouldre executethetesttoexplo revarious thread interleavings e.g .
chess or reex tools do so.
the left half of the table shows the ex ploration cost as the number of p aths that the tool would need to executeforvarioustests tofindthebug whilethe righthalf shows the exploration co st as the number of tran sitions on thesepaths.thesemeasu resarecommonlyusedto compare stateless techniques .
again exploring tests generated by ballerinais faster than exploring tests generated by basic random but the av erage speedup is smaller than for statefulexplorations.not ethatstatelessexploratio nbyitselfbugblr rel.to1 core bug4 core slowdownrelati vetoblr4 core core slowdownrelati vetoblr8 core core8 core 2x12x22x33x13x23x32x12x22x33x13x23x3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3n f11.
.
.
.
.8n f11.
.
.
.
.
.
.
5n f3.
.
.
.
.0n f4.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7n f3.
.
.
.
.0n f3.
.
.
.
.
.
.
8n f3.
.
.
.
.3n f2.
.
.
.
.
.
.
9n f5.
.8n f16.
.2n f5.
.3n f16.
.
.
.
10n f9.
.7n f5.
.3n f15.
.1n f8.
.
.
.
11n f6.
.7n f39.
.4n f5.
.1n f38.
.
.
.
12n f3.
.
.
.
.7n f3.
.
.
.
.
.
.
13n f3.
.6n f43.
.7n f3.
.0n f45.
.
.
.
14n f5.
.
.
.
.7n f5.
.
.
.
.
speed .
.3slow .
.
.
.
.
.
.
.
.
.
.
.
figure8.
parallelizedt estexecution meanexpl orationcosttothebugs cenario.
bugblr 2x2 2x3 3x2 fa tb c irno cfa tb c irno cfa tb c irno cfa tb c irno c abs rel abs rel abs rel abs rel .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
slow .
.
.
.
figure9.
ratiooffalse alarmsandtruebugs ofclusters ofreportsi nspectedwithclustering improvementovernoclu stering.
isslowerthanstatefulfor ourexperiments andpoo l 12does notevenfinishinareaso nabletimeforstateless.
figure shows the resu lts for exploring the ge nerated tests in parallel on four and eight cores.
note th at we do not parallelize exploratio n of one test at a timebut rather exploreinparallelsevera ltestsatonce.eachtestisexplored withachess likepreem ptionboundingasinfigu re5.the firstpartofthetableshow sthespeedupthatthispa rallelized testexecutionachieveso verexecutionononecor efortests generated by b allerina.
the average speedup i s superlinear .4x on cores and .3x on eight cores .
this is notsurprisingforsearch problems becauset hesearch finishesassoonasoneco refindsthebug.theseco ndpartof thetableshowstheslowd ownofthetestsgenerated bybasic random compared to th e tests generated by b allerina when run onthe same number of c ores.
comparing the average slowdown to th e case for one core f igure we find that b allerinaperforms even better tha n basic random when test execu tion is parallelized e.g.
for theslowdownis2.6xon onecore .0xonfourc ores and .4x on eight cores .
t his is important as the a vailability of multi core processors means that test executio ns in the futurearelikelytobepa rallelized.testsgeneratedbyb allerinafindbugsfasterthan tests generated by basic random configurations f or a variety of different explo ration approaches.
c. answering rq3 since reports of lineari zability violations can b e false alarmsortruebugs deve lopersneedtoinspectan umberof reports before finding a true bug.
figure show s how our clustering helps with red ucing the number of ins pections.
for each bug and seve ral test generation confi gurations the results are similar f or the configurations no t shown we tabulate the ratio of false alarms to true bug s before clustering fa tb the number of clusters that our technique computes the exp ected number of inspect ions with clustering computed as the arithmetic mean of random orderingsofreports and theratiooftheexpectedn umberof inspectionswithoutclustering over the expe cted number of inspectionswithclustering.effectively th elatterratioshows the benefit that our clus tering provides over the base case with no clustering and the last row shows thegeometric meanaverageofthisbenefit.the improvement range s from .
when there are no falsealarmsandhenceth enumberofinspections isexactly one both with and with out clustering up to .0x for pool 13and3 .notethatthenumber ofinspectionswith clustering is never wors e than the number of in spections withoutclusteringfortes tsgeneratedby b allerina.
our clustering technique reduces the number of i nspectedreportsfortestsg eneratedbybothb allerina and basic random gener ation on average 4x 8x .
d. threats to validity internal threats we conducted our exp eriments with the default settings of j pf version .
.
as ex plained in section v b we encoun tered an incompatibility of jpf s por and linearizability checking for pool b ut to the bestofourknowledge it didnotaffectanyotherex periment.
however changingother jpfsettingscouldaffect theresults thatweobtained.
external threats the code under test and bugsthat we use are from a variety of sources and diverse in terms of the statistics shown in figure .
however w e cannot guaranteethattheyform arepresentativesampleo fbugsin multithreadedjavacode.
tomitigatethelimitation ofusing one particular exploratio n we evaluated b allerinawith fourdifferentexploration s. construct threats wemeasureexploration costwiththe numberoftransitions an dpathsforre execution insteadof real time.
this is commo n in previous related stu dies .
we measure inspe ction effort with the n umber of reports which is a proxy for human time.
this is common inpreviousrelatedstudie s .
conclusion threats the number of random seeds for generation and fo r clustering that we use d may not be sufficient to accurate ly characterize real distr ibution of theserandomprocesses.
vi.
related work there is a rich body of work on random test gen eration forsequentialcode includin gcombinations withstaticanalysis symbolicexecution and search based techniques .
our b allerina technique utilizes rando op and modifies it to more densely cover states of o bjects for the given cut .
related to this techniques based on adaptive random testi ng use various measur es for object distance to generate more divergent test inpu ts.
however unlike thos e projects ballerinageneratestestsformultithreaded code.
for finding bug triggerin ginterleavingsin multithreaded code numerous techniqu es have been proposed including static anddynamica pproaches andtheir combination .randomiz edthreadschedulingand statistical faultlocalizationhaveals oshownpromiseintestin gparallelcode .
howeve r all those techniques as sume that thetestcodeisprovided andonlyexploreprovidedtests.in contrast b allerinaautomaticallygeneratesmultithreaded teststhatcanexposebugs.b allerinaalsoemployssearch forlinearizabilityviolatio ns inspiredbyline up .
environmentgeneration formultithreadedcodeis related to generation of test c ode.
for example tka chuk and rajan automat ically generate driver an d stub for the system under test ba sed on formal specificati on of the system properties.
b allerinadoes not require the us er to explicitly provide form al specifications but uses random testingtogeneratedriver codeanduseslinearizabi lityasan implicitspecificationfor thecut.b allerinaalsoclusters failurestoreducethenum berofinspectionsoffals ealarms.
researchers have propos ed different techniques f or clustering failing runs.
mos t previous work cluster s failures basedonexecutionprofilesfrommonitoredruns.po dgurski etal.usefeatureselectio ntotrainclustersbased onexecution profiles which are u sed to group similar fail ures .jonesetal.combine fault localizationinforma tionwith profiles to cluster failing tests .
yoo et al.
inc orporate human expert knowledg e into clustering .
zheng et al.
use statistical metho ds to find super bug pre dictors in multiple faults setting .
different from the previous work ourclusteringtech niquefocusesongroupin gfailures ofmultithreaded testsbased on the methods executing in parallelandthetypeoff ailure.
vii.
conclusions testing multithreaded co de is becoming more im portant but remains challenging and costly.
automated te sting can help to reduce the cos ts but most research f ocuses on automated exploration of thread interleavings for m anually written test code.
we ha ve presented b allerina a novel technique that automates generation of multithrea ded unit testcode.wehavealsop resentedatechniquefor clustering failuresofautomatically generatedmultithreaded tests.the experimentswith14bugs showthatb allerinacantrigger bugssubstantiallyfaster thanbasicrandomgener ation and that our clustering can greatly reduce the numb er of test failures that need to be inspected to find a true bug.
our experimentsexposedthre epreviouslyunknownbu gs twoof whichwerealreadyfixed .whilerandomgeneratio nshowed promising results it wo uld be useful to conside r a more guidedsearchfortestge neration.
acknowledgment s wethankvilasjagannath forextensivediscussions about this work.
this materi al is based upon work partially supported by the us n ational science foundat ion under grant nos.
ccf cns ccf and ccf by i ntel under the illinois in tel parallelism center i2pc an d by the swiss nationa l science foundationundergrantn umber200021 .