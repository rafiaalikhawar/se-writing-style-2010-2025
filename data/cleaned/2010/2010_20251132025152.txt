path exploration based on symbolic output dawei qi hoang d.t .
nguyen abhik roychoudhury school of computing national university of singapore dawei nguyend1 abhik comp.nus.edu.sg abstract efficient program path exploration is important for many software engineering activities such as testing debugging and verification.however enumerating all paths of a program is prohibitively expensive.
in this paper we develop a partitioning of program paths based on the program output.
two program paths are placed inthe same partition if they derive the output similarly that is thesymbolic expression connecting the output with the inputs is thesame in both paths.
our grouping of paths is gradually created by a smart path exploration.
our experiments show the benefits of the proposed path exploration in test suite construction.
our path partitioning produces a semantic signature of a program describing all the different symbolic expressions that the output can assume along different program paths.
to reason about changes between program versions we can therefore analyze their semanticsignatures.
in particular we demonstrate the applications of ourpath partitioning in debugging of software regressions.
categories and subject descriptors d. .
testing and debugging testingtools symbolic execution general terms experimentation performance reliability keywords path exploration relevant slice condition symbolic execution .
introduction programs follow paths.
indeed a program path constitutes a unit of program behavior in many software engineering activi ties notably in software testing and debugging.
use of program paths to capture underlying program behavior is evidenced in techniques such as directed automated random testing or dart which try to achieve path coverage in test suite construction.
why do we attempt to cover more paths in software testing?
the implicit assumption here is that by covering more paths we are permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.
int x y z input variables int out output variable3 int a i n tb scanf d d d x y z i f x y b1 a x else a y 0i f x y b21 b a if z z b3 printf square z n else printf square z n out b slicing criteria figure sample program likely to cover more of the possible behaviors that can be exhibited by a program.
however as is well known path enumeration is ex tremely expensive.
hence any method which covers various possi ble behaviors of a given program while avoiding path enumeration can be extremely useful for software testing.
we note that software testing typically involves checking the program output for a given input whether the observed output is same as the expected output.
hence instead of enumerating individual program paths we could focus on all the different ways in which the program output is computed from the program inputs.
in otherwords we can define an output as a symbolic expression in termsof the program inputs.
thus given a program p we seek to enumerate all the different possible symbolic expressions which describe how the output will be computed in terms of the inputs.
of course the symbolic expression defining the output in terms of theinputs will be different along different program paths.
however we expect that the number of such symbolic expressions to be substantially lower than the number of program paths.
in other words a large number of paths can be considered equivalent since thesymbolic expressions describing the output are the same.
to illustrate our observation let us consider the program in figure .
the output variable out can be summarized as follows.
ifx y 0andx y thenout x ifx y 0andx y thenout y ifx y thenout the summary given in the preceding forms a semantic signature of the program as far as the output variable out is concerned.
note that there are only three cases in the semantic signature whereas there are eight paths in the program.
thus such a semantic signature can be much more concise than an enumeration of all paths.
in this paper we develop a method to compute such a semantic signature for a given program.
our semantic signature is computed via dynamic path exploration.
while exploring the paths of a pro gram we establish a natural partitioning of paths on the fly based on program dependencies such that only one path in a partitionis explored.
thus for the example program in figure only threeexecution traces corresponding to the three cases will be explored.for test suite construction we can then construct only three tests corresponding to the three cases in the semantic signature.
how do we partition paths?
the answer to this question lies in the computation of the output variable.
we consider two program paths to be equivalent if they have the same relevant slice with respect to the program output.
a relevant slice is the transitive closure of dynamic data control and potential dependencies.
data and control dependencies capture statements which affect the output bygetting executed on the other hand potential dependencies capturestatements which affect the program output by not getting executed.
in figure even if line is not executed the output statement inline is potentially dependent on the branch in line .
this is tocapture the fact that if line is evaluated differently the assign ment in line will be executed leading different values flowing tothe output out.
we base our path partitioning on relevant slices to capture all possible flows into the output variable whether by theexecution of certain statements or their non execution.
the contributions of this paper can be summarized as follows.
we present a mechanism to partition program paths based on the program output.
the grouping of paths is done by efficient dynamic path exploration where paths sharing the same relevant slice natu rally get grouped together.
we show that our smart path explorationis much more time efficient as opposed to full path exploration viapath enumeration.
our efficient path exploration method has immediate benefits in software testing.
since our path exploration naturally groups several paths together it is much more efficientthan the full path exploration as in directed automated randomtesting or dart as evidenced by experiments.
moreover since several paths are grouped as equivalent in our method meaning that these paths compute the output similarly the test suite gener ated from our path exploration will also be concise.
secondly we show the application of our path partitioning method in reasoning about program versions in particular for debugging the root cause of software regressions.
while trying to introduce new features to a program existing functionality often breaks thisis commonly called as software regression.
given two program ver sionsp p and a test twhich passes in pwhile failing in p w e seek to find a bug report explaining the root cause of the failure of t inp .
in an earlier work we presented the darwin approach for root causing software regressions.
the darwin approach con structs and composes the path conditions of test tin program versionsp p in trying to come up with a bug report explaining an observed regression.
in this work we show that computing andcomposing the logical condition over a relevant slice also calledrelevant slice condition throughout the paper produces more pinpointed bug reports in a shorter time as opposed to computing and composing path conditions.
the reason for obtaining shorter bug reports in lesser time comes from the path conditions contain ing irrelevant information which are filtered out in relevant slice conditions.
hence relevant slice conditions are smaller formulae which are constructed and solved via satisfiability modulo theory solvers more efficiently.
.
overview we begin with a few definitions.
definition p a th condition .given a program pand a test input t let be the execution trace of tinp.
the path condition of saypc is a quantifier free first order logic formula which is satisfied by exactly the set of inputs executing in program p. clearly t pc .
the path condition is computed through symbolic execution.
during symbolic execution we interpret each statement and update thesymbolic state to represent the effects of the statements such as assignments on program variables.
at every conditional branch we compute a branch constraint which is a formula over the program sinput variables which must be satisfied for the branch to be evalu ated in the same direction as the concrete execution.
the result of symbolic execution is a path condition which is a conjunction of constraints corresponding to all branches along the path.
any in put that satisfies the path condition generated by executing an inputtis guaranteed to follow the same path as t. we take the following example to show that the effect of assignments is also considered in path conditions.
the path condition for input x is x that is the effect of the assignment in line is considered.
int x input variable 2i n ta scanf d x 4x x 5i f x a 7o u t a figure example to show path condition and relevant slice condition computation we now define slice conditions which are path conditions computed over slices.
d efinition d ynamic slice condition .given a programp a test input tand a slicing criteria c let be the execution trace of tinp.
let cdenote the projection of w.r .t.
the dynamic slice of cin .
in other words a statement instance sin is included in the projection cif and only if sis in the backward dynamic slice of con .
the dynamic slice condition of cin is the path condition computed over the projected trace c. slice conditions are weaker than path conditions that is pc dsc c wheredsc c is the dynamic slice condition of any slicing criteria cin see our technical report for a simple proof of this claim .
we now refine dynamic slice condition to relevantslice condition the central concept behind our path partitioning.
but first let us recall the notion of potential dependencies and relevant slices .
definition p otential dependence .
given an execution trace l e tsbe a statement instance and brbe a branch instance that is before sin .
we say that sis potentially dependent onbriff.
there exists a variable vused inssuch that i v is not defined between brandsin trace but there exists another path frombrtosalong which vis defined and ii evaluating br differently may cause this untraversed path to be executed.
an example of potential for the program in figure is shown in figure .
we now introduce the notion of a relevant slice and relevantslice condition a logical formula computed over a relevant slice.
figure example of potential dependence.
the solid arrows denote the execution path.
according to definition i the variablebis not defined between line and line but there exists a path though line along which bis defined and ii evaluating the branch at line differently may cause the path through line tobe executed.
therefore line is potentially dependent on line .
d efinition r elev ant slice .given an execution trace and a slicing criteria cin the relevant slice in w.r .t.ccontains a statement instance sin iff.c swhere denotes the transitive closure of dynamic data control and potential depen dence.
note that our definition of relevant slice is slightly different from the standard definition of relevant slice .
in standard relevantslicing algorithm if a statement instance ais included only by potential dependence the statement instances that are only control dependent by aare not included in the relevant slice.
we have removed this restriction to simplify the definition of relevant slice it is simply the transitive closure of three kinds of program dependen cies dynamic data dependencies dynamic control dependencies and potential dependencies.
in the rest of the paper all appearances of relevant slice and relevant slice condition refer to this simplified definition of relevant slice.
d efinition r elev ant slice condition .given an execution trace and a slicing criteria cin the relevant slice condition in w.r .t.
criterion cis the path condition computed over the statement instances of which are included in the relevant slice ofcin .
we take the example program in figure to show that the effect of assignments is also considered in relevant slice condition computation just as assignments are considered in path condition computation .
let the slicing criteria be the value of out in line .
the relevant slice for input x is and the corresponding relevant slice condition is x .
that is the effect of the assignment in line is considered.
we use the simple program in figure to illustrate the advantage of using relevant slice condition in dynamic path exploration.
the slicing criteria is the variable out at line .
since each statement is executed once we do not distinguish between different execution instances of the same statement in this example.
we use the executed branch sequence annotated with directions to represent an execution trace.
for example the trace for input x y z of the program in figure is denoted as b1 t b2f b3t .
let us take the input x y z to see the differences between path condition dynamic slice condition and relevant slice condition.
given the trace corresponding to input x y z the path condition along this execution is x y x y z z .
for the execution path of x y z the dynamic backward slice result w.r.t.
the slicing criteria at line is it contains no branches.
the path condition computed over thestatements in the dynamic slice or the dynamic slice condition issimply the formula true.
different from dynamic backward slicing relevant slicing also includes the statement instances that could potentially affect theslicing criteria.
for example if evaluating a branch differentlycould affect the slicing criteria such a branch is included inthe relevant slice even though it is not contained in the dynamic backward slice.
in the example program the branch at line can potentially affect the value of out in the slicing criteria.
this is because if the branch in line is evaluated differently to true the variable bis re defined in line which affects the output variableout.
hence the relevant slice contains line .
the entire relevant slice is and the relevant slice condition on it is x y .
any input tsatisfying the relevant slice condition x y has the same symbolic expression for the output out which in this case turns out be the constant value .
as mentioned earlier program paths can be partitioned based on the input output relation.
relevant slice condition perfectly serves this purpose.
if two paths have the same relevant slice with outputbeing the slicing criteria then they have the same input output re lation.
the path partitions of the program in figure are shown in figure .
the grey nodes in figure are the statements that are contained in the relevant slice w.r.t.
to the unique slicing criteriaat line in figure .
as we can see from figure based on therelevant slice we can group the eight program paths into three path partitions.
just like the dart approach uses path conditions to dynamically explore paths in a program relevant slice condition can be used to explore the possible symbolic expressions that the program output can be assigned to.
how would such an exploration proceed?
suppose we simply use relevant slice condition to replace path condition in dart s path exploration.
given a relevant slice condition 1 2 ... k k we construct ksub formulae of the form of 1 2... i i where i k. the path exploration is done by solving these formulae to get new inputsand iteratively applying this process to the new inputs.
note that each sub formula shares a common prefix with the relevant slice condition.
now we examine the effectiveness of this simple solu tion on the program in figure .
depth first exploration strategy is used and path exploration terminates when no new sub formulae are generated.
let the initial input be x y z the path for this input is b1 t b2f b3t .
the entire path exploration process is shown in table .
the from column of table can beunderstood as follows.
if the from column contains .
it means that the current input is generated by negating the th branch constraint of the relevant slice condition in the th row.
recall from section that we expect the following three symbolic expressions for out to be explored.
x y x y out x x y x y out y x y out as we can see from table no path having relevant slice condition x y x y is explored.
therefore this feasible relevant slice condition is missed by the exploration process.
in addition the relevant slice condition x y is explored figure path partitions of the example in figure several times.
thus we cannot simply replace path condition with relevant slice condition in dart s path exploration.
let us examine closely what went wrong in the path exploration of table .
in particular the input in the third row is generated bynegating the second branch condition of the relevant slice condition in second row in table .
that is when we solve x y x y we get an input x y z whose relevant slice condition is x y .
the branch condition x y disappears in the new relevant slice condition because the corresponding branch is not contained in the relevant slice any more.
in contrast dart follows certain path prefixing properties i f 2... i iis the prefix of a path condition for some program input the path condition of any input satisfying 2... i iwill have 1 2... i ias a prefix.
such a property does not hold for relevant slice condition.
hence simply replacing path condition with relevant slice condition in dart not only causes redundant path exploration but also makes the exploration incomplete in terms of possible symbolicexpressions that the output variable may assume .
we have developed a path exploration method which avoids the aforementioned problems.
while exploring groups of paths basedonrelevant slice condition our method re orders the constraints in the relevant slice condition.
the path exploration is based on reordered relevant slice condition.
a reordered relevant slice condition satisfies the following property which also holds for path conditions if 2... i iis a prefix of a reordered relevantslice condition the reordered relevant slice condition of any input satisfying 1 2... i ihas 1 2... i i as a prefix.
.
our approach in this section we give our path exploration algorithm based onrelevant slice condition .
we then give theorems on the completeness of our path exploration algorithm.
throughout the paper we assume that the slicing criteria is in a basic block that post dominates the entry of the program.
first we introduce the following notations.
notations.
we usecto denote the unique slicing criteria.
when used in a dynamic context crefers to the last executed instance of the slicing criteria.
given a test case t we use t to denotethe execution path of t. we use rs sc to denote the relevant slice on path w.r.t.
slicing criteria sc.
we use rsc sc to denote the relevant slice condition on path w.r.t.
slicing criteria sc.
we usereordered rsc sc to denote the reordered sequence ofrsc sc .w e u s e br to denote the branch instance of a branch condition .
.
path exploration algorithm we now present our path exploration method which operates on a given program p. all relevant slices and relevant slice conditions are calculated on the same program pwith respect to a slicing criteriac which refers to the program output .
we group paths based on relevant slice condition.
as explained in the last section a dart like search based on relevant slice conditions is incomplete that is not all possible symbolic expressions that the output may assume will be covered.
for this reason wereorder the relevant slice conditions.
our path exploration algorithm is shown in algorithm .
the core of the algorithm is the reorder procedure which reorders the relevant slice conditions.
when we compute the relevant slice condition we get a sequence of branch conditions ordered accordingto the sequence in which they are traversed.
we use the reorder function to reorder the branch conditions after which the path ex ploration will be performed based on the reordered sequence ofbranch conditions.
thereorder procedure is given in algorithm .
the reordering works in a quick sort like fashion.
in each call to reorder we split the to be reordered sequence into two sub sequences.
suppose thelast branch condition in the sequence is from branch instance b k. thenbkis used as the pivot in the splitting process.
if a branch instancebis in the backward relevant slice of bk then the branch condition of bis placed before the branch condition of bk.
otherwise the branch condition of bis placed after the branch condition ofbk.
then we recursively call the reorder procedure to reorder the two sub sequences.
we show the reorder procedure in action in figure .
note that our reordering is done on branch conditions in a relevant slice condition.
since there is a unique branch condition for each branch in stance in the execution trace the example in figure is on branchinstances for simplicity.
on the left of figure the dependencies among all the branch instances are provided.
if there is an arrow 281no.
from input path rsc x y .
x y x y .
x y .
x y table path exploration based on relevant slice conditions for example in figure no.
from input path rsc reordered rsc x y x y .
x y x y x y x y .
x y x y x y x y table path exploration with reordered relevant slice conditions for example in figure algorithm path exploration using relevant slice condition input p the program to test t an initial test case for p c a slicing criterion output t a test suite for p stack null the stack of partial rsc to be explored execute t whilestack is not empty do let f j pop stack iffis satisfiable then let be one input that satisfies f put intot execute j end if end while returnt procedure execute t n execute tinpand compute relevant slice condition rsc w.r.t.c let rsc 1 2 ... m m let rsc reorder rsc suppose rsc ... m m for all i from n to m do let h ... i i push h i intostack end for return end procedure procedure reorder seq if seq 0then returnseq end if let seq be 1 2 ... k k seq1 true seq2 true for all i from to k do ifbr i is in relevant slice of br k then seq1 seq1 i else seq2 seq2 i end if end for returnreorder seq1 k reorder seq2 end procedureb1 b2 b3 b4 b5 b6 b1 b3 b6 b5 b4 b2b1 b3b2 b4 b5 b5 b4 b2b2 b4 b4 b2b1 b2 b3 b4 b5 b6 b1 b3 b6 b2 b4 b5 b1 b3b5 b2 b4 figure reorder algorithm in action frombjtobi thenbiis in the relevant slice of bj.
the pivot in each reorder step is marked in dark the other branches are reordered w.r.t to the pivot .
for example initially b6 is the pivot and we reorder b1 ...b5 depending on whether they are in the relevant slice of b6.
in algorithm we use a stack to maintain the to be explored partial relevant slice conditions.
the main algorithm keeps on processing the formulae in the stack when it is not empty.
in eachiteration the algorithm pops out one partial relevant slice condition from the stack and checks whether it is satisfiable or not.
if it is satisfiable we get a new input by solving the formula.
the new input could lead to some unexplored relevant slice condition.
the relevant slice condition for the execution trace of input is then explored as shown by the procedure execute in algorithm .
given the execution trace of the relevant slice condition over this trace w.r.t.
the slicing criteria cis first computed.
the relevant slice condition is reordered using the reorder procedure and the to be explored partial relevant slice conditions are pushed into the stack.
the second parameter of execute is used to avoid redundancy in path search.
when execute is called with parameters tandn let the reordered relevant slice condition reordered rsc c t be ... m m. for any partial relevant slice condition i ... i i i n m we know that ihas been pushed into the stack a priori.
so the for loop in the execute procedure starts from n 1to avoid these explored partial relevant slice conditions.
282the path exploration of algorithm when employed on the program in figure leads to the relevant slice conditions shown in table .
if the from column of table contains .
it means that the current input is generated by negating the th branch constraint of the reordered relevant slice condition in the th row.
the path exploration based the reordered relevant slice condition explores all possible relevant slice conditions of the program.
.
theorems due to space limit the proofs of the theorems are omitted in this paper.
the readers can refer to our technical report for the proofs.
assumptions.
we assume that the smt solver used to solve relevant slice conditions is sound and complete.
as mentioned earlier we assume that the slicing criteria is in a basic block that postdominates the entry of the program this is the location of the program output.
if the program contains multiple outputs the slicing criteria can simply be a set of of primitive criteria of the form output variable output location note that slicing can be performed on such a criteria which is a set without any change to our method.
theorem .
.
if the relevant slice conditions of two paths 1 and 2w.r .t.care the same then the variables used in the slicing criteriachave the same symbolic values in 1and 2. in theorem .
we show that the relevant slice condition determines the symbolic values of variables used in the slicing cri teria if the relevant slice conditions of two paths are the same the variables in the slicing criteria have the same symbolic values.symbolic value can be computed by dynamic symbolic execution.each symbolic value is an expression in terms of the program in puts.
let sbe a statement instance in the path of input t andvbe a variable used in s. the symbolic value of vinsis an expression in terms of input variables.
if the symbolic value of vis concretized witht it must be the same as the value of vinswhen the program is run concretely with input t. t heorem .
.
given a program pand an execution trace t for inputtinp algorithm must explore an execution trace t for some input t such that t and t share the same relevantslice condition irrespective of the initial test input with which al gorithm is started provided the total number of relevant sliceconditions in pis bounded.
in theorem .
given any feasible path we show that our path exploration algorithm is guaranteed to explore a path that shares the same relevant slice condition with .
this establishes the completeness of our path search.
.
implementation in this section we discuss our combined infra structure for symbolic execution and dependency analysis of java programs.
our implementation is based on jslice .
jslice is an opensource dynamic slicing tool on java bytecode.
we have extendedjslice to compute relevant slice conditions.
the architecture of our extended jslice is shown in figure .
jslice keeps the collected trace in a compressed form to achieve scalability.
the compression is online as the trace is gener ated it is simultaneously compressed and then slicing is done on criteria input relevant slice conditioncustomized kaffe jvmstatic analysis relevant slicing update operstackupdate pathcond tree complete pathcond treecfg cdgjava class file relevant slicing symbolic executionbytecode slicecompressed trace figure architecture of relevant slice condition computation the compressed trace.
the slicing algorithm works directly on thecompressed trace.
we design our extension of jslice to retain thisfeature of analyzing compressed traces without decompression .
in figure relevant slicing and symbolic execution are separated for ease of understanding.
however we do not need the entire relevant slicing result to start computing relevant slice condition in the implementation.
the process of constructing the relevantslice condition is done along with the backward relevant slicing to achieve efficiency.
since the relevant slicing process is backward we also compute the relevant slice condition via a backward symbolic execution which starts from the slicing criteria and stops atthe beginning of the trace.
for backward symbolic execution we keep a set of symbolic values which need to be explained.
the symbolic value of a variablevis explained by either an assignment to vor by program input tov.
let us take the sample program in figure to show our backward symbolic execution on a relevant slice.
note that although we show this example at the source code level our implementation is at the java bytecode level.
suppose the input is x y z .
the relevant slice for the execution trace of this input is .
backward symbolic execution along this trace is shown in table .
to construct the relevant slice conditions we need to precisely represent the semantics of each bytecode type in the generated for mula.
there are more than different bytecode types in the javavirtual machine instruction set and all of them are handled in ourimplementation.
our implementation also handles native method calls more details in the next paragraph .
however due to the jslice version that our implementation is based on currently wecannot handle programs with multi threading and reflection.
in the original implementation of jslice the concrete operand values of most executed instructions are not stored in the compressed trace as they are not needed in the slicing process.
how283relevant slice symbolic to be explained relevant slice condition values variables out b out b b true 1b a out a b a a true if x y out a b a x y x y 7a x out x b x a x x y x y if x y out x b x a x x y x y x y scanf d d d x y z out x b x a x x y x y x y table backward symbolic execution example ever these values are needed when the semantics of some operations cannot be precisely modelled.
in such cases we have to under approximate the generated path condition relevant slice condition by concretizing certain symbolic values in the relevant slice condition.
for example java allows a program to use libraries writ ten in other languages through native method call.
since the native calls cannot be traced in java virtual machine the symbolic return values from native calls cannot be precisely modelled.
in this case we simply concretize the symbolic return value from a native callusing the concrete return value of the native call therefore the con crete return value of native calls are traced in our implementation .
in our implementation we use the concept of execution index to uniquely identify a statement instance across different paths.two statement instances in different paths are the same iff.
theyhave exactly the same execution index .
in its simplest form we can use the path from root to a statement instance sin the dynamic control dependence graph of path as the execution index of statement instance sin path .
as mentioned in section we need to reorder the branch conditions in a relevant slice condition in our path exploration process.
letrs c be the relevant slice on trace w.r.t.
the slicing criteriac.
letrsc c be the relevant slice condition computed onrs c .
to reorder the branch conditions in rsc c using the reorder procedure shown in algorithm we need to compute a relevant slice using each branch instance in rs c as the slicing criteria.
suppose there are mbranch instances in rs c our implementation traverses the trace formtimes to compute themrelevant slices.
in future we plan to speed up this process by computing all mrelevant slices at the same time of computing rs c .
we also observe that there are a lot similarities among the slices w.r.t.
different branch instances used as slicing criteria in the same trace.
for example if a branch instance b iis in the relevant slice of branch instance bj then the relevant slice w.r.t.
bi is a subset of the relevant slice w.r.t.
bj.
in future we could exploit the similarities among these slices to further reduce the cost of ourreorder procedure.
our execution engine is a combined infra structure for dynamic dependency analysis and dynamic symbolic execution.
thus apart from computing relevant slice conditions we can simply disable the dependency analysis in our engine to compute path conditions.
the path conditions and relevant slice conditions generated from our tool are in the format of smt2 which can be solved by various satisfiability modulo theory or smt solvers.
in our imple mentation we choose z3 3as the smt solver for our tool.
.
experiments in the following we first compare our relevant slice condition based path exploration method with directed automated random projects z3 testing dart .
we then present an application of relevant slice conditions in the debugging of evolving programs.
.
path exploration we compare our path exploration algorithm with dart.
the subject programs shown in table are from sir repository.the lines of code loc in each program are also shown.
recall that our path search is complete as supported by theorem .
.
however the completeness is difficult to achieve in practice for several reasons.
two of the main reasons are the limited power of current smt solvers and imprecise modelling of program seman tics.
because of these reasons our technique may miss a certainrelevant slice condition rsc iwhen dart can explore a path whose relevant slice condition isrsci.
the example below explains how imprecise modelling of array can cause our implementation to benot as complete as dart in terms of relevant slice condition coverage.
int x y input int out output int a scanf d d x y if x printf x is greater than zero n if a if y o u t else out else out printf d n out slicing criteria in our current implementation we concretize symbolic array index using the value observed at execution time.
suppose the initial in put for our method and dart are both x y .
due to the concretization of symbolic array index the branch at line cannot contribute a branch condition to either path condition or relevantslice condition.
the path condition and relevant slice condition for x y are x andtrue respectively.
since the relevant slice condition for the initial input x y is true containing no branch condition our technique terminates.
however some relevant slice conditions are missed by our technique.
in particular the relevant slice conditions of paths that evaluate branch at line to false are missed.
in contrast dart could explore all feasible paths hence all relevant slice conditions of the above program.
although the branch at line cannot directly affectthe computation of out it can help dart to negate the branch at line due to the correlation between the two branches.
if arrays aremodelled precisely this problem will disappear.
the completeness column in table measures how much incompleteness in relevant slice condition coverage is introduced 284subject prog.
size loc completeness time testcases avg.
formula size solver calls rsc dart rsc dart rsc dart rsc dart tcas .3s .1s binarysearchtree .1s .6s ordset .1s .4s schedule .3s .4s disjointset .8s .8s table experiments in full program exploration time seconds algorithm dart a tcas0 time seconds algorithm dart b binarysearchtree0 time seconds algorithm dart c ordset time seconds algorithm dart d schedule0 time seconds algorithm dart e disjointset figure relevant slice condition coverage comparison by the imprecise modelling of program semantics in our implementation.
the numbers in the completeness column are computed as follows.
let the program being explored be p. we employ dart on pto explore program paths and construct a testsuitetdart all which contains the set of all paths in pcovered by dart.
for each test case tintdart all we compute the relevant slice condition on the execution trace of tand put this relevant slice condition into a set sdart all .
similarly we generate a test suite trsc for program pusing our path exploration method.
for each test case tintrsc we compute the relevantslice condition on the execution trace of tand put this relevantslice condition into a set srsc .
then the completeness column in table is srsc sdart all .
as shown in table our method cannot always achieve percent relevant slice coverage as compared to dart due to the imprecise modelling of program semantics in our implementation.
note that this does not affect the validity of the completeness claim in theorem .
the incompleteness is onlyin the implementation.
in columns of table we compare the time number of generated test cases formula size and number of solver calls be tween our method and dart.
the formula size is measured bythe number of bytes in the smt2 formula file.
for getting thesenumbers both our method rsc and the dart method are run to completion and the running time is recorded.
note that the time reported in table includes the time taken in every steps of ourmethod and dart.
for example the time taken by our method includes the time for program execution relevant slicing relevantslice condition computation branch condition reordering formula solving etc.
as shown in table our technique takes much lesstime than dart.
the efficiency comes from several sources.
first since we use relevant slice condition instead of path condition the formula size of our approach is much smaller than that of dart.
this reduces the time taken by the solver.
second the number of different relevant slice conditions is considerably smaller than the number of path conditions.
this reduces both the number of exe cutions and the number of solver calls.
figure compares the relevant slice condition coverage of our algorithm with directed automated random testing dart under the same time limit.
note that dart intends to achieve pathcoverage.
however as we have observed several paths may havethe same input output relationship and testing is always done by checking outputs.
we check the number of relevant slice conditions that are covered by the paths explored in dart search.
as shown in figure our technique gets higher relevant slice condition coverage then dart when the given time is short.
.
debugging of evolving programs the obvious application of relevant slice conditions is in software testing it groups program paths and can be used to efficiently generate a concise test suite.
we now show another application of relevant slice conditions namely in the debugging of evolving pro285subject prog.
stable version buggy version diff time debugging results pc rsc pc rsc jlex .
.
loc .
.
loc loc min min loc loc jtopas .
loc .
loc loc min min loc loc table darwin debugging results loc stands for lines of code grams.
as a program evolves functionality which worked earlier breaks.
this is commonly known as software regressions.
for any large scale software development debugging the root case of re gressions is an extremely time consuming activity.
we applied our relevant slice conditions on the darwin method for debugging evolving programs .
given two program ver sionspandp and a test case twhich passes in pbut fails in p the work in tries to find the root cause of the failure of t inp .
the debugging proceeds by computing and composing the path conditions of tinpandp as follows.
first the path conditions fandf oftinpandp are computed.
we then compute the formula f f as follows.
suppose f is f 1 2 ... m where iare primitive constraints.
the following mformulae i i m are then solved where idef f 1 ... i i .
we invoke a satisfiability modulo theory or smt solver to solve the mformulae i i m .
finally for every iwhich is satisfiable we can find a single line in the source code which is a potential error root cause the branchcorresponding to i which is negated in i .
we observe that the path conditions fandf in the above method can be replaced by relevant slice conditions.
path condition is not goal directed it contains the constraints of branches which are not related to the observable error.
in particular a path condition will typically contain constraints for branches which are not in the dynamic or relevant slice of the observable error.
consider thefollowing example program ... input inp1 inp2 if inp1 x i n p else x i n p if inp2 y i n p else y i n p ... output x y suppose the observed value of xis unexpected for inp1 inp2 because of a bug in line say the condition should beinp1 .
the path condition is inp1 inp2 .
clearly the constraint inp2 corresponding the the branch in line is unrelated to the observable error unexpected value of x .
indeed line is not in the dynamic slice or relevant slice of the slicing criterion corresponding to the output value of x in line .
thus due to the inherent parallelism in sequential programs path conditions contain constraints for branches which are not inthe slice of the observed error.
composing these path conditions for debugging then allows for such unrelated branches to be incorporated into the bug report which is output by the debuggingmethod .
indeed including these unrelated branch constraints in creases the burden on the smt solvers invoked by the darwin method both in terms of the size of the formulae and the number of the formulae to solve.
in addition these unrelated branchconstraints also introduce some false positives into the bug reportproduced by the darwin method.
replacing path condition with relevant slice condition in the darwin method resolves these issues.
thus given a test case tthatpasses in the old version program pbut fails in the new version programp we now compute gandg the relevant slice condition oftinpandp respectively.
we then solve g g in a manner similar to the solving of f f in darwin where f f were the path conditions of tin programs p p .
we compare the debugging result of darwin using relevantslice conditions with the original darwin method which uses path conditions in table .
both methods are fully automated.
we did not use the same sir programs as used in section .
because debugging regression er rors for sir programs are usually trivial.
this is because the difference between two sir program versions is usually small.
the first subject program being used is jlex .jlex is a lexical analyzer generator written in java.
we use version .
.
of jlex as the stable version and version .
.
as the buggy version.
there are and lines of code in version .
.
and version .
.
respectively.
the changes across version .
.
and version .
.
consistof lines of code.
in particular the version .
.
of jlex cannot recognize r as the newline symbol while in version .
.
thisbug is fixed.
we use an input file manifesting this bug.
the experimental results from darwin using relevant slice conditions vs. the original darwin method appears in table .
the original darwin method which uses path conditions takes 543minutes or hours to perform the debugging.
the result of darwin is a bug report containing lines of code which are highlighted to the programmer as potential root causes of the observ able error.
in contrast darwin using relevant slice condition takes only minutes.
the result is a bug report containing only3 lines of code potential root causes of the observed error.
indeed the actual error root cause lies in one of these three lines of code.
thus by using relevant slice conditions inside our darwin debugging method we could avoid false positives among thepotential error causes which are reported to the programmer.
moreover there is a huge savings in the debugging time minutes vs hours which comes from the relevant slice conditions being much smaller than path conditions.
we also conducted experiments using jtopas 5as the subject program.
jtopas is a java library for parsing arbitrary text data.
we use version .
of jtopas as the stable version and version .
as the buggy version.
there are and lines ofcode in version .
and version .
respectively.
jtopas allows users to customize whitespace characters i.e.
characters that are considered as whitespace characters by using function setwhitespaces.
jtopas also uses a boolean field defaultwhitespaces to control whether the default whitespace characters are used or the user customized whitespace characters are used.
to use the cus tomized whitespace characters defaultwhitespaces has to be set tofalse.
unfortunately the buggy jtopas .
does not reset the member defaultwhitespaces leading to the default whitespace characters still being used instead of the customized ones althoughthe user has specified the custom whitespace characters.
in our experiment we customize whitespace characters to r t n r t by default and use an input file manifesting 286the aforementioned bug.
the debugging results of darwin using path condition and darwin using relevant slice condition are shown in table .
the results from the original darwin method using path condition and darwin using relevant slice condition are both four lines of code.
they both contain the location where n is treated differently between the two versions.
the pin pointed location shows that the stable version does not consider n as a whitespace.
in contrast the buggy version still treats n as a whitespace because defaultwhitespaces istrue even though whitespace characters have already been customized .
from thisclue the programmer could easily infer that the member defaultwhitespaces was not assigned to the correct value.
although using relevant slice condition does not eliminate any false positives in the debugging result it does reduce the time taken by darwin from81 minutes to minutes.
.
threats to v alidity our path exploration does not try to cover all paths.
instead we try to group paths based on symbolic outputs.
this is done with the goal of test suite construction where testing will expose possible failures in the program.
however failure of a test case doesnot only come from unexpected outputs it can also come fromprogram crashes.
thus for the paths which we do not explore if they contain program crashes these will not be exposed by the test suite computed by our technique.
realistically our test suiteconstruction could be supplemented by techniques to statically de tect possible program crashes such as memory error detection .
due to the conservative nature of static analysis used in computing relevant slice our technique may under approximate relevantslice conditions in some situations.
in that case we may explore more than one paths that have the same relevant slice condition.
consider the following program if x p.num out q.num suppose pandqnever alias to each other.
if the static analysis cannot determine the non alias between pandq line is potential dependent on line when the branch at line is evaluated to false.
therefore the branch at line is included in relevant slice and our technique will try to explore both directions of the branch atline which is unnecessary.
note that this under approximationofrelevant slice condition only causes duplicated exploration of some relevant slice conditions it does not affect the completeness claim of our technique.
although our technique considerably improves the efficiency of the path exploration the path explosion problem still exist.
in theworst case the number of relevant slice conditions grows exponentially with the size of the program.
.
related work the technique proposed in this paper is based on dynamic path exploration and relevant slicing .
our techniqueimproves existing dynamic path exploration techniques by group ing several paths together using relevant slice condition.
existing dynamic path exploration tries to achieve path coverage.
in con trast our technique only selects one path from each relevant slice condition to explore.
there are several works which focus on improving the efficiency of dynamic path exploration.
in function summaries are generated and exploited.
in the grammar of the input is used toavoid generating large percentage of invalid inputs.
our approach is orthogonal to these approaches therefore our approach can becombined together with any of these approaches to further improvethe efficiency of the path search.
in a program is statically decomposed into several path families where each path family contains several paths that sharesimilar behavior.
instead of analyzing each path individually a pro gram can be analyzed at the granularity of path family.
the authors of also compute a path family condition for each path family which could characterize that path family.
the path partitionbased on relevant slice condition is different from the notion of path family in in the sense that path family is more gen eral.
for example all program paths in figure can be grouped into one path family but they are grouped into three partitions by our technique.
at the same time path family condition doesnot guarantee the same input output relationship whereas relevantslice condition does.
the main difference between our work and lies in the static vs. dynamic nature of the two techniques.
thework in statically computes their path family conditions whilewe dynamically explore the relevant slice conditions.
because of the dynamic nature of our method we can under approximate therelevant slice conditions while over approximates their path family conditions if needed.
clearly the dynamic nature of ourmethod makes it more suitable for test generation.
note that theeffect of program statements written in real life programming lan guages are hard to precisely model as symbolic formulae.
in such a situation under approximation is a practical simplification since it amounts to concretizing parts of the formula.
other researches have also used the notion of path equivalence to alleviate the path explosion problem.
however what paths areconsidered equivalent are different between our work and earlier works.
the difference in the definition of path equivalence originates from the different goals of our work and earlier works.
in the goal is to explore all possible program states.
based on thisgoal two paths are equivalent if the symbolic states of all live variables are the same.
in contrast we only consider the variables that can affect the output two paths are equivalent if they have thesame symbolic expression for the output.
in the goal is toreach some critical locations in a program.
therefore two pathsare equivalent if they cannot reach any critical locations for the same reason blocked by the same condition .
apart from the application of relevant slice condition in debugging mentioned in section there are many other path condition based techniques that could benefit from relevant slice condition.
our relevant slice condition can be used to minimize an existing test suite .
if a test suite contains two test cases that havethe same relevant slice condition these two test cases compute the output in the same way.
therefore we can choose to eliminate oneof them to make the test suite smaller.
the work in explores paths to generate program invariants.
for each path explored the path condition serves as a pre conditionand the symbolic program output is treated as a post condition.thus each explored path produces a program invariant which is defined as such a pre condition post condition pair.
similar approaches are used in to generate method summaries.
in stead of using path condition we can generate such program in variants using relevant slice conditions the relevant slice condition is the pre condition and for each relevant slice condition explored there is a unique symbolic output which serves as the post condition.
moreover the invariants generated using relevant slice conditions will be simpler as relevant slice conditions are smaller than path conditions and fewer since a single relevant slice condition groups more paths .
.
discussion in this paper we have presented a novel path exploration method based on symbolic program outputs.
our path exploration dynamically groups paths on the fly where two paths that have the samesymbolic output are grouped together.
given such a path partition ing we can generate a test case from each partition.
this enables usto efficiently obtain a concise test suite which stresses all possibleinput output relationships in the program.
our path exploration method is complete that is it covers all possible symbolic outputs in a given program.
we also experimentally compare the efficiency and coverage of our method with respect to directed automated random testing another path searchmethod based on symbolic execution.
apart from testing the path partitioning computed by our method can be exploited in other software engineering activities.
we haveshown its use in the debugging of errors introduced by programchanges that is in root causing observable software regressions.by comparing the path partitioning in two program versions weinfer the semantic differences across the versions leading to precise root cause identification.