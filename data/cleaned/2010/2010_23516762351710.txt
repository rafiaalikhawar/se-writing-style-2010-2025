supporting operating system kernel data disambiguation using points to analysis amani s. ibrahim j ohn grundy james hamlyn harris and mohamed almorsy centre for computing and engineering software systems swinburne university of technology melbourne aus tralia swin.edu.au abstract generic pointers scattered around operating system os kernel s make the kernel data layout ambiguous.
this limit s current kernel integrity checking research to covering a small fra ction of kernel data.
hence there is a great need to obtain an accurate kernel data definition that resolves generic pointer ambiguities in order to formulate a set of constraints between structures to support precise integrity checking.
in this paper w e present kdd a new tool for systematically generating a sound kernel data definition fo r any c based os e.g.
windows and linux without any prior knowledge of the kernel data layout .
kdd performs static points to analysis on the kernel s source code to i nfer the appropriate candidate types for generic pointers .
we implemented a prototype of kdd and evaluated it to prove its scalabilit y and effectiveness .
categories and subject descriptors d2.
program analysis d4.
security kernels .
general terms performance security languages .
keywords systematic kernel data integrity checking points to analysis.
.
introduction it is a very challenging task to verify the integrity of os kernel data.
an os kernel has thousands of data structures that have direct and indire ct relations between each other with no explicit integrity constraints.
in windows and l inux oses from our analysis nearly of the structure relations are pointer based relations indirect r elations and of these pointer based relations are generic pointers e.g.
null pointers that do not have values and void pointers that do not have associated type declarations in the source code .
such generic poi nters get their values and thus types only at runtime according to the calling context .
this makes kernel data a rich target for malware that exploit s the pointer relations between data structures to compromise the kernel .
current kernel data integrity checking research is limited in solving those problems .
this is because they depend on their prior knowledge of the kernel data layout to manually resolve the ambiguous pointer based relations and thus they only cover a small fraction of kernel data structures that relate to well known obje cts e.g.
processes and threads .
this results in limited protection and inabil ity to detect zero day threats raising the need to get an accurate kernel data definition that resolves the generic pointers ambiguities.
in this paper we introduce kdd kernel data disambiguator a new static analysis tool that can generate a sound kernel data definition for any c based os e.g.
windows and linux without any prior knowledge of the os kernel data layout .
kdd disambiguate s the pointer relations including generic pointers to infer their candidate t ypes values by performing static points to analysis on th e kernel s source code.
kdd is able to scale to the enormous size of kernel code unlike many other points to analysis tools.
in kdd precision is an important factor we want the most precise points to sets to be computed.
as the analysis is done offline and just once for each kernel version performance is not such an im portant factor.
to meet our requirements we designed and implemented a new points to analysis algorithm that has the ability to pr ovide interprocedural context and fieldsensitive and inclusion based points to analysis for large programs that contain millions lines of code e.g.
os kernel .
.
background c based oses use c structures heavily to model objects.
they also use pointers extensi vely to emulate object oriented dispatch avoid expensive copying of large objects implement complex data structures.
moreover objects can be cast to multiple types during their lifetime and a pointer deposited in a field under one object may be read fr om a field under another object.
this makes the analysis of kernel s data structures a non trivial task.
to get a concrete idea of the generic pointers problem figure shows exemplar c code implementing pointers of the sort found in a typical os.
we discuss in it the context of three problems.
first void pointers the problem with void is that the target object type s can only be identified at runtime.
from our example uniqueprocessid is void .
however if we analyse the code we find that it indirectly p oints to another structure .
the wide use of void pointers hinders performing systematic integrity checks on kernel data where there are no type constraints for void .
second null pointers null pointers are used heavily to implement linked lists .
the c definition makes a linked list points to itself but actually during system runtime it points to a specific object type according to the calling context .
procedure updatelinks from our example is used to upd ate the objects list structured in list entry doubly linked list .
however t he objects structured in this list can be recognized only during runtime.
identifying type of the object that a linked list may hold at the offline analysis phase helps signifi cantly in identifying a set of constraints on the runtime objects to detect invalid pointer dereferencing.
third casting casting induce s relationships permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
between objects that may appear to be unrelated enabling hackers to exploit data structures layout in physical memory.
debugport from our code is declared as an integer however it is being cast to be a pointer to a data structure .
typedef struct list entry struct list entry flink struct list entry blink list entry plist entry restricted p ointer typedef struct eprocess void uniqueprocessid list entry activeprocesslinks eprocess peprocess typedef struct exhandle int handle exhandl list entry psactiveprocesshead peprocess activeprocess peprocess allocateprmemory return peprocess malloc sizeof eprocess void createprocess peprocess p ptr p ptr peprocess allocateprmemory activeprocess p ptr p ptr uniqueprocessid exhandler activeprocess updatelinks ptr activeprocesslinks psactiveproce sshead ... void exhandler exhandle temphandle temphandle.handle createhandler ... return temphandle.handle void updatelinks plist entry src plist entry tgt src flink tgt flink tgt blink src blink ... figure .
example reflecting use of generic pointers.
pointer analysis algorithms for c programs have been studied intensively over the last two decades.
their use has predominantly been for compiler optimizations and their main goal has thus been performance.
some work has attempted performing field and context sensitivity analysis on large programs .
however none has been shown to scale to large programs e.g.
os s kernel code with a high precision rate.
kernel data integrity checking has been studied intensively .
however all of these approaches depend on os expert knowledge to extract some value invariants that cover specific semantics for a very small number of kernel data structures.
osck and siggraph provides a more systematic approach to cover system data however they do no not solve generic pointers problem .
.
our approch kdd takes an os kernel s sou rce code as input and outputs a type graph that summarizes the different data types located in the kernel along wit h their connectivity patterns and reflects the inclusion based relation between kernel data struct ures for both direct and indirect relations to generate constraint sets between data structures .
to facilitate the analysis we use abstract syntax tree ast as a high level intermediate representation for the source code.
the ast captures essential s tructure of the code that reflects its semantic structure while omitting unnecessary syntactic details.
kdd proceeds by first generating the ast for the kernel s source code.
then two main phases of the analysis are used to build the type graph discussed below.
.
direct inclusion based relations this phase of analysis is straightforward and its objective is reflecting the direct inclusion based relations between data structures that have clear type definitions.
kdd performs a compiler pass approach to extr act the data structure type definitions by looking for typedef aliases and extract their fields with the corresponding type definition.
nodes are data structures and edges are data members inclusion relations of the structures .
indirect inclusion based r elations indirect relations generic pointer dereferencing cannot be computed from the ast directly.
we have developed a new points to analysis algorithm to statically a nalyse the kernel s source code to get an approximation for every generic pointer dereferencing based on anderson s approach .
we co nsider all forms of assignments and function calls .
data structures are flattened to a scalar field.
type casting is handled by inferring locations accessed by the pointer being cast.
kernel objects are represented by their allocation site according to the calling context .
the target graph of this step is g n e where n is the set of nodes representing global and local variables field s array elements procedure argument s parameters and function return .
e is a set of directed edges across nodes representing assignments and function calls.
the graph no des have four types and edges also have four types.
nodes a node is one of i variable node represents variables including parameters .
ii field reference node represents structure s fields.
each field reference node has an associated parent node.
iii function call node represents a function name and an index index if the node represents a function return otherwise index i where i is the index of formal in argument i.e.
given a function call g arg1 arg2 in this case we will have two nodes g and g representing passed arguments arg1 and arg2 respectively.
iv cast node represents explicit casting where the type of the node is the typecast and the name is the casted variable or function.
edges an edge may be i points to edge represents points to relations between two nodes according to the edge direction.
ii inlist edge represents a points to relation between two nodes but on a local scope thus if node a has inlist edge to node b then b pts a where pts a means the points to set of a. iii outlist edge is not a relation edge but represents a directed path between two nodes that are used to achieve the points to analysis.
iv parent child edge represents re lation between parent and child i.e.
relation between structure and fields or array and elements.
the type graph of the indirect relations is created and refined by our points to analysis algorithm in a three step process intraprocedu ral analysis interprocedural analysis and context sensitive points to analysis .
these steps are discussed below.
.
.
intraprocedural analysis the goal of this phase is to compute a local type graph without information about caller or callee.
kdd takes the as t file as input and outputs an initial graph a s follows i variables create a node for each variable declaration and check the function scope to find out if it is a local or global variable.
ii procedure declaration create a node for each formal in parameter iii call create node for each formal in argument if not already created in addition to a dummy node for each formal in argument represented by its index in the procedure.
these dummy nodes will be used in the interprocedural analysis phas e to create an implicit assignment relation between the formal in arguments and formal in parameters.
iv assignments create nodes for the left and right hand sides if not already created.
iv returns create two nodes one for the return statement its elf and the other for the returned value inside the called procedure.
235kdd then builds the initial edges at this step by computing a transfer function tf for each procedure procedure call assignment and return statement as described in table .
tf is a formal description for the relation between the nodes created for each of the previous entities .
in our motivating example from section consider the call to the function updatelinks where the formal in parameters are src tgt and the actual passed arguments are activeprocesslinks psactiveprocesshead .
updatelinks also contains explicit assignment statements src flink tgt flink tgt blink src blink .
kdd computes the transfer function tf for those statements as shown in figure a and figure b respectively .
for the return node given this fragment of code uniquethreadid exhandler the computed tf is shown in figure c .
table .
transfer function description.
local points to sets pts constraints between nodes and edges a directed inlist edge between two nodes a directed outlist edge .
code local pts constraints edges procedure description relation between parameters and the dummy nodes that hold the indexes of the parameters.
edges inlist edge between each formal in parameter node and its relevant dummy node and outlist edge from the dummy node to its relevant formal in parameter node.
proc p pts proc pts p proc p proc p proc p assignment description relation between left and right hand sides hss of the assignment statement.
edges inlist edge from left hs to right hs and outlist edge from the right hs to left hs.
p q loc q pts p p p q p q p q pts p pts q p q p q p q p q v pts q pts p pts v p q p q v p q v p q v pts p pts v pts q p q v p q v p q call description relation between the formal in arguments nodes and dummy nodes.
edges inlist edge between each argument node and its relevant dumm y node.
proc q pts q pts proc q proc q proc return description relation among left hs the procedure return node and the returned value node.
edges inlist edge between the left hs and the return node inlist edge between the return no de and retuned value node and outlist edge between the return node and the left hs.
p fn return q pts p pts q p q p q activeprocesslinks updatelinks srcpsactiveprocesshead updatelinks tgt a src flink tgt flinkpoints to edge outlist edgeuniqueprocessid exhandler handle b c figure .
intraprocedural analysis graph solid arrows inlist edges and dashed outlist edges dashed ovals dummy nodes.
.
.
interprocedural analysis in this phase we perform an inter procedur al analysis that enables us to perform points to analysis across different files to perform a whole program analysis .
we refine the initial type graph by incorporating inter procedural information from the calle es of each procedure.
the result of this phase is a graph that computes the calling effects returns arguments and parameters but without any calling context information yet.
this is done by propagating the local points to sets inlist edges computed at the intraprocedural analysis step to their u se sites consistently with argument index in the call site as shown in figure .
thus we can map between the procedure arguments and parameters .
.
.
context sensitive points to analysis the key in achieving context sensitivity is to obtain the return of procedures according to the given arguments combined with the call site .
points to analysis is performed in three sub steps points to analysis a well known complication in this analysis is the order of which nodes will be analysed first where this can greatly affect performance.
a good choice is to analyse nodes in a topological order by building a procedure dependency graph pdg .
this graph enhances the analysis by providing the appropriate analysis sequence that result in precise points to analysis.
we start with the top node that does not ha ve any dependencies and thus we g uarantee that each node has its inlist nodes already analysed before proceeding with the node itself.
we expand the local dereferencing of the pointers to get the points to relations between the caller and callee.
we propa gate the points to set of each node into its successors accumulating to the bottom node.
for acyclic points to relations pointers are analysed iteratively until points to sets are fully traversed.
for recursions we analyse pointers in each recursion cycl e individually.
psactiveprocesshead updatelinks tgtx figure .
interprocedural analysis result.
graph unification consider the following piece of code from the motivating example updatelinks ptr activeprocesslinks psactivep rocesshead .
we pass an object data structure to the procedure however the procedure updatelinks manipulates the fields of the passed object e.g.
flink and blink .
to solve this problem we apply a unification algorithm to the type graph as follows given node a with points to set s and t s if t has child relation edge with f we copy f to a create a child relation edge between f and a and also create points to edge from a.f to t.f as shown in figure .
context sensitivity to achieve context sensitivity we use the transfer function for each procedure call and apply its calling contexts to bind the output of the procedure call according to the calling site.
the points to edge here is a tuple n v c representing that a pointer n points to variable v at context c where the context is defined by a sequence of functions and their call sites to find out valid call paths between nodes.
performing context sensitive analysis solves two problems the calling con text and the indirect relations between nodes.
these indirect relations are calculated for each of the two nodes that are in the same function scope but not included in one points to set.
such that two nodes v and n where v pts n and v and n has different function scope check the function scope of n and x where x pts v if the function scope is the same then create a points to edge between n and x. figure shows the context sensitive analysis for updatelinks .
note an indirect points to relation from psactiveprocesshead to activeprocesslinks .
finally we write the graph by replacing each v ariable node with its type and for fields and array elements we add the declared parent type.
236table .
soundness and precision results running kdd on a suite of benchmark c programs .
loc lines of code.
pointer inst number of pointer instructions.
proc number of procedure definitions.
struct number of c stru cts ast t time consumed to generate ast files ast m memory usage and ast c cpu usage.
tg t time consumed to build the type graph tg m memory usage tg c cpu usage.
benchmark loc pointer inst proc struct ast t sec ast m mb ast c tg t sec tg m mb tg c p s art .
.
.
.
.
.
mcf .
.
.
gzip .
.
.
.
.
.
.
parser .
.
.
.
.
.
.
vpr .
.
.
.
.
na gcc .
.
.
na sendmail .
.
.
.
.
na bzip2 .
.
.
.
.
.
.
psactiveprocesshead activeprocesslinks src tgt flink blink flink blinkflink blink flink blink figure .
graph unification h ighlighted nodes are the newly copied children nodes.
red arrow shows child relation edge.
psactiveprocesshead activeprocesslinks src tgt flink blink flink blinkflink blink flink blink figure .
context sensitive analysis .
.
evaluation to demonstrate kdd s scalability and effectiveness we first measured the soundness and precision of kdd using different sets of c programs from the spec200 and spec2006 benchmark suites and other ope n source programs.
our results show n in table show that we achieve a high level of precision .
and of soundness.
for significantly sized c programs kdd is able to process the application code with very acceptable cpu time and memory usage.
second w e analyzed the linux kernel v3.
.
million loc and wrk .
million loc .
kdd scales to the very large size of such oses .
kdd needed around hours to analyze the wrk and around hours to analysis the linux kernel.
as our points to an alysis is performed offline and just once or each kernel version performance overhead of analyzing kernels is acceptable and does not present a problem for any security application that wants to make use of kdd s generated type graph.
to evaluate the effe ctiveness of kdd s results we performed a comparison between the pointer relations inferred by kdd and the manual efforts of os experts to solve these indirect relations in both kernels .
kdd successfully deduced the candidate target type value of the se members with soundness.
we could not measure the precision for nearly of the members as there is no clear description for these members from any existing manual analysis.
we measured precision for the well known object types and precision was around .
thus kdd is able to scale to produce a detailed highly accurate type graph for a large scale c program such as an os kernel.
a key to achieve this scalability and high performance was by using ast as the basis for points to analysis .
the compact an d syntax free ast improves time and memory usage efficiency of the analysi s. to the best of our knowledge there is no similar research in the area of systematically defining the kernel data structure with the exception of kop .
however kop is limited in that the points to sets of kop are not highly precise analysis performance overhead is very high and kop uses a medium level intermediate representation which complicates the analysis and results in improper points to sets.
.
sum mary the wide existence of generic pointers in os kernels makes kernel data ambiguous and thus hinders current kernel data integrity research from providing the preemptive protection.
kdd is a new tool that has the ability to generate a sound kernel data structure definition for any c based operating system without any prior knowledge of the os.
our experiments have shown that the kdd generated type graph is accurate and solves the generic pointer problem with high rate of soundness and precision.
to the best of our knowledge kdd is the only tool that can scale to produce a detailed highly accurate type graph for c based oses .
.