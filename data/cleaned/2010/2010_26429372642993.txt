symcrash selective recording for reproducing crashes yu cao hongyu zhang and sun ding tsinghua university beijing china cyrainfish gmail.com microsoft research beijing china honzhang microsoft.com nanyang technological university singapore ding0037 ntu.edu.sg abstract so ftware often crashes despite tremendous effort on software quality assurance.
once developers receive a crash report they need to reproduce the crash in order to understand the problem and locate the fault.
however limited information from crash reports often makes crash reproduction difficult.
m any captureand replay techniques have been proposed to automatically capture program execution data from the failing code and help developers replay the crash scenarios based on the captured data.
however such techniques often suffer from heavy overhead and introduce privacy concerns.
recently methods such as bugredux were proposed to generate test input that leads to crash through symbolic execution.
however such methods have inherent limitations because they rely on conventional symbolic execution techniques.
in this paper we propose a dynamic symbolic execution method called symcon which addresses the limitation of conventional symbolic execution by selecting functions that are hard to be resolved by a constraint solver and using their concrete runtime values to replace the symbols.
we then propose symcrash a selective recording approach that only instruments and monitors the hard to solve functions.
symcrash can generate test input for crashes through symcon.
we have applied our approach to successfully reproduce failures of real world programs.
our results confirm that the proposed approach is suitable for reproducing crashes in terms of effectiveness overhead and privacy.
it also outperforms the related methods.
categories and subject descriptors d. .
testing and debuggingdebugging aids general terms reliability experimentation keywords crash reproduction program instrumentation symbolic execution error handling capture and replay .
introduction although software project teams spend much resource and effort on software quality assurance before releasing products in reality released software still contains bugs.
some bugs manifest themselves as crashes which are often considered as severe problems and are typically assigned a high priority for fixing.
once software crashes in the field developers should reproduce and fix the problem.
however it is difficult to reproduce field failures that occur in user environment which is often different from developer s testing environment.
even the users write a bug report the reproduction of crash could be still difficult due to complex environmental settings sources of non determinism and poor bug report quality .
to help debug field failures many crash reporting systems such as windows error reporting apple crash reporter and mozilla crash reporter have been proposed and deployed.
when a crash happens in field these system collect crash related information especially call stack trace and send these information back to the developers upon user permission.
although the stack information is shown to be useful it is often too limited for effective failure reproduction.
in recent years automated tools have been developed to help developer reproduce field crashes.
many of these tools are based on the concept of capture and replay they capture relevant information from the failing code and reproduce the crashes by replaying the recorded information.
for example chroniclerj captures all the non deterministic inputs to reproduce bugs.
however it is difficult to emulate all nondeterministic inputs.
furthermore recording user input incurs serious privacy concerns.
bugredux uses different execution data obtained by different level of instrumentations and reproduces the crashes by performing symbolic execution over the synthesized traces.
conventional symbolic execution can infer program inputs by solving constraints along the paths.
however conventional symbolic execution often fails to solve certain path constraints due to various hard to resolve functions such as overly complex functions and nonlinear math functions .
therefore the effectiveness of bugredux can be further improved.
in our work we propose symcon a dynamic symbolic technique which replaces hard to resolve functions with concrete runtime values and then performs symbolic execution.
in this way symcon can solve more path constraints and improves the effectiveness of conventional symbolic execution.
based on symcon we present symcrash an automated capture and replay technique.
symcrash only selects hard to resolve functions to instrument and monitor.
when a crash happens symcrash performs symcon using the recorded data and generates test cases that can reproduce the crash.
we also develop a tool symcrashj which implements symcrash for java programs.
we evaluate symcrashj using failures of real world programs.
symcrashj can successfully reproduce out of crashes.
we also evaluate the runtime performance and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
privacy impact of symcrashj.
our results confirm that the proposed approach can achieve lower overhead and better privacy when compared with the related approaches bugredux and chronicler .
this paper provides the following novel contributions g121 we propose symcon a dynamic symbolic execution technique that improves the effectiveness of symbolic execution by replacing the hard to resolve functions with their concrete values obtained at program runtime.
g121 we propose symcrash which performs selective recording of hard to resolve functions and reproduces crashes using symcon.
g121 we develop symcrashj a tool that implements symcrash for java programs.
we also evaluate the effectiveness overhead and privacy of symcrashj using real programs.
the remainder of this paper is organized as follows.
section describes the background of crash reproduction and gives a motivating example.
section introduces the background of symbolic execution and presents symcon.
we describe the symcrash approach and the implementation details in section .
section describes our experimental evaluation and discusses the results.
section surveys related work followed by section that concludes the paper.
.
background and motivation before discussing our approach we briefly provide some necessary background information on general crash reproducing methods and give a motivating example.
.
capture and replay methods in recent year researches have proposed many crash reproduction methods.
these methods share the similar process first they capture the program execution information in the field at the time of crash they then help developers reproduce the crash by replaying the recorded information in the lab.
figure shows an overall structure of such a capture replay framework.
hsor hg lq wkh ilhog ssolfdwlrq qvwuxphq wdwlrq 5hsod rj dwd7hvw dwd figure .
an overview of a crash reproduction we briefly introduce some of the main methods here recrash generates multiple unit tests that reproduce a given program failure.
it instruments a program to store partial copies of method arguments in memory and deploys the instrumented program in the field.
if the program crashes recrash uses the saved information to create unit tests reproducing the crash.
recrash can introduce high performance overhead because it captures the states of all objects .
such a high overhead makes recrash difficult to be applied in practice.
chronicler captures all the non deterministic inputs such as file i o shared memory etc.
during program execution and uses the collected data to reproduce the crashes in the lab.
unlike recrash chronicler performs a lighter recording while still supporting a complete reply.
however the number of nondeterministic methods chronicler instruments could be overwhelming.
also recording all non deterministic inputs including the user s inputs could bring serious privacy concerns in practice.
bugredux collects program execution traces such as call stacks method call sequences complete execution traces obtained by different level of instrumentations.
it can use the collected traces to mimic the observed field failures and to reproduce the crashing faults.
based on the program execution traces bugredux utilizes conventional symbolic execution to generate test inputs that can exercise the traces.
their experimental results showed that the method call sequence data are more efficient for crash reproduction.
bugredux may not always return results due to the limitations of conventional symbolic execution which will be described in section .
.
a motivating example we adapt the wu ftpd example described in as a motivating example.
the wu ftpd program implements a file transfer server and has a known format string vulnerability.
the original program of wu ftpd is written in c. we modify the original c program version .
.
and port it into a java program as shown in figure .
the site exec function allows uses to execute commands remotely.
the parameter cmd contains the user specified command such as usr bin helloworld l .c .
this program throws an exception when the length of the command string exceeds .
for example when the input cmd is !
!!!!!!!!!!!!!!!!!!!
the program crashes.
.
public static void site exec string cmd .
string path home ftp bin .
int sp cmd.indexof .
double dsp java.lang.math.log sp .
int j string result .
if dsp .
j cmd.lastindexof .
if j .
result cmd.substring j .
else .
result cmd .
else .
j cmd.lastindexof sp .
result cmd.substring j .
.
if result.length path.length .
throw new runtimeexception buffer overflow .
.
string buf path result .
execute buf .
figure .
the site exec function of the wu ftpd program to reproduce the crash chroniclerj requires to record user input which can reproduce the crash but could violate user privacy.
bugredux uses symbolic execution to generate test input and can thus avoid the privacy concerns.
however bugredux has limitations in handling certain functions due to the inherent limitations of conventional symbolic execution.
for example to symbolically execute the path along the lines an smt constraint solver needs to solve the path constraints containing the return value of math.log function.
this function is a nonlinear function and takes a variable as a parameter.
its value cannot be easily determined by an smt 792constraint solver during symbolic execution.
therefore bugredux cannot reproduce this crash.
in this work we propose a new capture and replay technique which only instruments the selected hard to solve functions and enables symbolic execution to continue by utilizing their runtime values.
test input that reproduces the crashes can be generated from symbolic execution.
our approach can mitigate the privacy and overhead concerns and in the meantime improve the effectiveness of crash reproduction.
.
symcon symbolic execution with concrete values .
symbolic execution symbolic execution is a program analysis technique which can infer the program inputs through analyzing the program.
during symbolic execution an analyzer uses symbolic values instead of actual concrete values.
the inputs are obtained by solving path conditions pcs which are conjunctions of constraints over symbolic expressions.
the solutions to a pc are the inputs that drive the program through an execution path.
a pc can be submitted to an off the shelf smt constraint solver such as z3 and yices which returns a satisfying assignment for all variables appearing in formulas that can be proven satisfiable.
if a path is infeasible the solver returns unsatisfiable and no solution will be given.
if the smt solver cannot solve a path constraint it returns unknown.
in our work we implement symbolic execution using the symbolic path finder spf tool which is a symbolic extension of java path finder .
spf combines symbolic execution and model checking techniques to explore different program paths and to automatically generate test inputs.
it also provides advanced features such as partial orders and symmetry reductions to handle the problem of state explosion.
although symbolic execution is effective in generating test inputs it has limitations too.
for example it has problems in handling complex math operations and external library calls .
these limitations are due to the path explosions and the inherent incompleteness in decision procedures.
in this paper we identify a set of functions that are hard to be solved by conventional symbolic execution tools and propose a technique that can address the limitations of symbolic execution by utilizing the runtime values.
.
hard to resolve functions conventional symbolic execution adopts path based program analysis which models program behaviour as a path constraint along each execution path.
the path constraint is later evaluated against a constraint solver.
path based analysis offers high precision and is therefore widely adopted in program optimization and test case generation.
however in general symbolic execution based on path constraint solving faces many intractable problems including g120 limited support for the number of predicates along a path.
existing constraint solvers can only support a limited number of predicates in a path.
submitting overly complex path constraints to a solver could lead to state explosion.
to address this problem many tools such as spf introduce an upper bound to limit the number of predicates along a path .
g120 limit support for the number of paths in a control flow graph cfg .
in symbolic execution the program branches function calls and loops are exhaustively visited in a depthfirst manner.
the symbolic execution terminates when the number paths it processes exceeds an upper bound.
therefore many paths in a cfg may be failed to verify.
to address this problem many tools such as cute and pex introduce an upper bound to limit the number paths for symbolic execution.
g120 limited support for loops recursions.
to overcome the state explosion issue caused by complex program structures like loops or recursive function calls several advanced program analysis techniques are proposed such as program abstraction and loop summarizations .
the abstraction techniques can map a program with a large number of states into an abstracted model with limited states.
later symbolic execution can be applied to the abstracted model to reduce search cost.
loop summarization techniques treat a loop as a block and summarize the loop s data dependency impact as inferred invariants .
however not all the loop and recursive structures could be accurately abstracted or summarized.
for example the work in summarizes loops by expressing certain important variables with loop counts but it cannot handle cases where variables are not linearly updated with the corresponding loop count.
although many other techniques such as search strategy using search guiding heuristics to guide path exploration have been proposed to address the loop problems the problems still exist .
g120 limited support for complex string operations.
modern smt solvers are capable of solving string constraints by expressing the constraints in terms of bitvectors.
therefore they support symbolic string analysis.
however these tools still cannot support all complex string operations due to possible state explosion.
redelinghuys compared the ability of different symbolic string analysis tools including spf and pex and pointed out their limitations in supporting various string operations.
he found that some string operations such as contains or startwith are fully supported by all the tools.
while other functions such as split and valueof only receive partial support.
g120 limited support for native functions and external library calls.
symbolic execution may fail due to inherent complexity of native functions and external library calls .
spf addresses these limitations by using the model java interface mji mechanism which can model external libraries.
however traditional symbolic execution tools still cannot handle some of the native functions such as nonlinear math functions.
this is because most of decision procedures and constraint solvers cannot fully support non linear arithmetic operations.
in our work we heuristically identify the functions that could lead to the intractable problems.
we treat them as hard to solve functions which are hard to be resolved by a conventional smt solver and can block a symbolic execution.
the syntactical characteristics of these hard to resolve functions are as follows g120 deeply nested predicates if a function contains deeply nested predicates the number of paths and the number of predicates in a path may be large.
therefore it is more likely to cause the state explosion problem.
existing symbolic 793execution techniques impose a bound on the size of the search depth.
following the design of spf we heuristically consider a set of nested predicates with nested level deeper than a hard to solve characteristic.
g120 loops recursions a program with loops may cause the number of paths to grow exponentially and may cause symbolic execution to run out of resources.
if a variable is no t linearly updated within each iteration it cannot be symbolically expressed by the loop count the number of times the loop has executed .
therefore we consider a loop containing the following characteristics a hard to solve one a it updates a variable v that is referenced by a path constraint b there is an inner loop that also updates v or there are conditional branches within the loop along which the variable v is updated c the number of loop iterations depends on external input.
furthermore we consider rec ursive functions as hard to resolve functions.
g120 complex string operations i n our work we identify string operations that are not supported or partially supported by spf and treat them as hard to resolve ones.
examples include the replace split and valueof functions.
g120 native functions and external library calls we consider the native math functions whose parameters are dependent on external inputs as hard to resolve functions.
we also consider third party external library calls whose source code is not available as hard to resolve functions.
the hard to resolve functions can be identified through relatively simple program analysis.
note that our approach also allows users to manually update the hard to resolve function list so that they have flexibility in supporting their specific constraint solvers.
.
symcon in this work we propose a dynamic symbolic execution method called symcon which can address the limitations of conventional symbolic execution by utilizing the concrete runtime values of the hard to resolve functions.
the concrete values can be obtained through program instrumentation and are used in constraint solving together with the symbolic values.
more specifically in symcon if a function m is a hard to resolve function we use its return value at runtime instead of treating it as a symbol.
for example the function math.log is a hard toresolve function because it implements nonlinear arithmetic operation.
we obtain its return value at runtime via program instrumentation and use this value in follow up symbolic execution.
if a function is not a hard to resolve function we treat it as a symbol and perform usual symbolic execution.
we use the program in figure as an example to illustrative symcon.
in this program the string related functions such as indexof lastindexof length can be supported by a modern smt solver therefore we treat their return values symbolically.
line contains a hard to resolve function math.log .
suppose we can obtain the concrete value of the math.log function at runtime we can use this value to perform symcon.
for example to symbolically execute the path along the lines the path condition to be resolved are as follows sp cmd.
indexof dsp math.log sp dsp !
j cmd.lastindexof sp result cmd.substring j result.length path.length path.length th is pc cannot be solved by an smt constraint solver such as z3 due to the existence of a non linear function math.log sp .
through program instrumentation we know the latest return value of this function at the time of crash.
so we use this concrete value to replace the math.log sp item in the pc therefore enabling symbolic execution to continue.
finally the solver returns testtest testtest which satisfies the constraints and reproduces the crash.
note that the proposed symcon is different from the mixed concrete symbolic solving used in spf .
spf identifies simplepc which contains solvable constraints and complexpc which contains constraints that cannot be solved directly .
spf then forces the solver to generate solutions for the simplepcs and use the solutions to solve complexpcs.
symcon is also different from existing dynamic symbolic execution techniques such as dart which use randomly generated inputs to enable symbolic executions to continue.
symcon uses the monitored runtime values of hard to resolve functions therefore it can obtain more accurate values for crash reproduction.
.
reproducing crashes based on selective recording we propose symcrash an approach that reproduces crashes based on symcon.
symcrash instruments the applications to monitor the return values of hard to resolve functions in the field.
using the recorded data symcrash can generate test input for the crashes by performing symcon.
figure shows an overall process of our approach.
symcrash mainly consists of three parts.
the first part is instrumenter which instruments the original application to collect program execution information.
the second part is logging which monitors the program execution in the field and collects necessary log data.
the third part is reexecution which reproduces crash via symcon in the lab.
during the reexecution phase symcrash replaces the symbolic values of hard to resolve functions with the concrete values that are recorded in the log data.
in this way more symbolic executions can be completed and test data that leads to crashes can be generated.
we have implemented a tool called symcrashj which is a realization of symcrash for java programs.
note that our approach can be applied to programs written in other languages as well.
fi gure .
an overview of symcrash logging instrumenter reexecution program instrumentation identify hard toresolve functions instrumented version monitor methods record values and objects generate logs log file writing to disk symcon generate test input crash stack trace .
instrumentation and logging symcrashj first identifies the hard to solve functions which exhibit the characteristics described in section .
and can be hardly supported by conventional symbolic execution.
it then instruments these functions to record the function return values and necessary program execution information.
the instrumentation is implemented using the asm bytecode framework .
the instrumented version is deployed in the field which collects the runtime values of hard to resolve functions generates specific logs according to the method sequence and writes the log data to disk.
algorithm ree xecution input cg call graph of program p goal list methods in stack trace g g1 ... g n log data log data method list a list of hard to resolve functions output input test the test input begin cur goal g0 state set p entry initial symbolic values g true while true do cur state null while cur state null do cur state findnextstate state set cg cur goal if cur state null then if cur goal g then return else cur goal previous goal in goal list continue end end end if cur state.m cur goal then if cur goal gn then cur goal next goal in goal list cur state.m cur goal else input test solver.solve cur state.pc if input test is found then return input test else remove cur state state set end end end updatesymcon cur state state set method list end end figure .
the reexecution algorithm there are several issues associated with log data.
the first issue is about data type.
for immutable types such as integer double float byte character long string symcrashj simply saves them as pointer