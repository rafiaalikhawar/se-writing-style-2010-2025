structured merge with auto tuning balancing precision and performance sven apel olaf le enich and christian lengauer university of passau germany apel lessenic lengauer fim.uni passau.de abstract software merging techniques face the challenge of finding a balance between precision and performance.
in practice developers use unstructured merge i.e.
line based tools which are fast but imprecise.
in academia many approaches incorporate information on the structure of the artifacts being merged.
while this increases precision in conflict detection and resolution it can induce severe performance penalties.
striving for a proper balance between precision and performance we propose a structured merge approach with auto tuning .
in a nutshell we tune the merge process on line by switching between unstructured and structured merge depending on the presence of conflicts.
we implemented a corresponding merge tool for java called jdime .
our experiments with real world java projects involving merge scenarios with over million lines of code demonstrate that our approach indeed hits a sweet spot while largely maintaining a precision that is superior to the one of unstructured merge structured merge with auto tuning is up to times faster than purely structured merge times on average.
categories and subject descriptors d. .
distribution maintenance and enhancement version control d. .
management software configuration management general terms management measurement experimentation keywords version control software merging structured merge jdime .
introduction software merging techniques are gaining momentum in the practice and theory of software engineering.
they are permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.important tools for programmers and software engineers not only in version control systems but also in product line and model driven engineering.
contemporary software merging techniques can be classified into syntactic approaches and semantic approaches.
the former include a unstructured approaches that treat software artifacts as sequences of text lines and b structured approaches that are based on the artifacts syntactic structure.
in our attempt to push back the limits of practical software merging we concentrate on syntactic approaches semantic approaches are promising but still too immature to be used in real world software projects.
the state of the art is that the most widely used softwaremerging tools are unstructured popular examples include the tools diff andmerge ofunix used in version control systems such as cvs subversion and git.
unstructured merge is very simple and general every software artifact that can be represented as text i.e.
as sequences of text lines can be processed.
so a single tool that treats all software artifacts equally suffices.
however the downside is that unstructured merge is rather weak when it comes to expressing differences and handling merge conflicts the basic unit is the line all structure all knowledge of the artifacts involved is lost .
previous work has shown that an exploitation of the syntactic structure of the artifacts involved improves the merge process in that differences between artifacts can be expressed in terms of their structure which also opens new opportunities for detecting and resolving merge conflicts one of the key problems in this field .
unfortunately no practical structured merge tools for mainstream programming languages are available.
why?
a first problem is certainly that when developing a structured tool one must commit to a particular artifact language and as a consequence develop and use a different tool per language .
a second problem is that algorithms that take the structure of the artifacts involved into account are typically at least cubic if not even np complete a major obstacle to their practical application .
while the first problem has been addressed for example by the technique of semistructured merge parts of the artifacts are treated as syntax trees and parts as plain text see sec.
we strive here for a solution to the second problem.
can we develop a merge approach that takes the structure of artifacts fully into account and that is efficient enough to be useful in realworld software projects?
we report on the development and application of a merge approach that is based on tree matching and amalgamation.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
it is more precise in calculating differences and merges than an unstructured lined based approach as it has more information about the artifacts at its disposal.
to cope with the complexity of the tree based merging operations involved we use an auto tuning approach .
the basic idea is that the tool adjusts the precision of the merge operations from unstructured lined based to structured tree based guided by the conflicts detected in a software project.
as long as no conflicts are detected the tool uses unstructured merge which is cheap in terms of performance.
once conflicts are detected the tool switches to structured merge to increase the precision.
so the basic idea is simple use the expensive technique only when necessary which is in line with mens statement on the future of software merge techniques an interesting avenue of research would be to find out how to combine the virtues of different merge techniques.
for example one could combine textual merging with more formal syntactic and semantic approaches in order to detect and resolve merge conflicts up to the level of detail required for each particular situation .
while an auto tuning approach is not as precise as a purely structured merge the unstructured merge involved may miss conflicts or may not be able to resolve certain conflicts it is likely faster and thus more practical in real world software engineering especially if one believes mens conjecture that unstructured merge suffices in of all merge scenarios .
in fact we strive for a solution that improves the state of practice namely getting away from the exclusive use of unstructured merge tools.
to demonstrate the practicality of our approach we have implemented a tool for java called jdime that performs structured merge optionally with auto tuning.
we used jdime in merge scenarios of software projects involving over million lines of code.
specifically we compared the performance and the ability to resolve conflicts of unstructured and structured merge with and without autotuning .
we found that purely structured merge is more precise than unstructured merge it is able to resolve many more conflicts than unstructured merge but reveals also conflicts not noticed by unstructured merge.
however as expected structured merge is slower by an order of magnitude which is due to the more complex differencing and merge technique.
remarkably the auto tuning approach diverges only minimally from purely structured merge in terms of conflict detection but it is up to times faster than purely structured merge times on average.
in summary we make the following contributions we present a structured merge approach that is based on tree matching and amalgamation and that uses auto tuning to improve performance while largely maintaining precision.
we provide a practical implementation called jdime of our approach for java.
we apply our tool to a substantial set of merge scenarios and compare its performance and conflict detection capability with and without auto tuning to that of unstructured merge.
jdime as well as the sources of the merge scenarios and the collected data of all experiments are available at a supplementary web site .version base class bag int values bag int v values v version right class bag int values bag int v values v intsize return values.length version left class bag int values bag int v values v int get return values unstructured merge class bag int values bag int v values v left int get return values intsize return values.length right structured merge class bag int values bag int v values v int get return values intsize return values.length derive merge figure conflict resolved with structured merge but not with unstructured merge .
software merge in his seminal survey mens provides a comprehensive overview of the field of software merge techniques .
here we concentrate on the popular scenario of a three way merge which is used in every practical version control system.
a three way merge aims at joining two independently developed versions based on their common ancestor e.g.
the version from which both have been derived by locating their differences and selecting and applying corresponding changes to the merged version.
however the merge may encounter conflicts when changes of the two versions are inconsistent e.g.
two versions apply mutually exclusive changes at the same position .
a major goal is to empower merge tools to detect and resolve conflicts automatically.
as software projects grow merge techniques have to scale.
in the remaining section we discuss the principal properties of unstructured and structure merge with regard to conflict detection and resolution as well as performance.
.
unstructured merge for illustration we use a simple example an implementation of a bag data structure that can store integer values.
in figure top we show the basic version called base which contains a java class with a field and a constructor.
based on version base two versions have been derived independently middle of figure version left adds a method sizeand version right adds a method get.
merging leftandright based on their common ancestor base using unstructured merge results in a conflict as shown in figure bottom left .
the conflict cannot be resolved automatically by any unstructured merge tool and thus requires manual intervention.
the reason is that an unstructured merge tool is not able to recognize that the text is actually java code and that the versions can be merged safely the declarations of the methods getand sizecan be included in any order because method declarations can be permuted safely in java as illustrated in figure bottom right .
in practice most unstructured merge tools compare and merge versions based on largest common subsequences of text lines.
this is not without benefits.
the unstructured approach is applicable to a wide range of different software artifacts and it is fast quadratic in the length of the artifacts involved.
mens conjectures that of all merge scenarios require only unstructured merge the other require more sophisticated solutions such as structured merge a fraction that is likely to grow with the popularity of decentralized version control systems .
.
structured merge structured merge aims at alleviating the problems of unstructured merge with regard to conflict detection and resolution by exploiting the artifacts structure.
westfechtel and buffenbarger pioneered this field by using structural information such as the context free and context sensitive syntax during the merge process .
subsequently researchers proposed a wide variety of structural comparison and merge tools including tools for java and c see sec.
.
the idea underlying structured merge tools is to represent the artifacts as trees or graphs and to merge them by tree or graph matching and amalgamation.
additionally the merge process has all kinds of information on the language at its disposal including information on which program elements can be permuted safely which has been proved very useful in software merge .
this way it is almost trivial to merge the two versions of figure bottom right .
structured merge is not only superior in that certain conflicts can be resolved automatically.
there are situations in which unstructured merge misses conflicts that are detected by structured merge.
in figure we show again the basic version of the bag example top but two other versions have been derived independently left and right both of which add a method getstring middle .
interestingly unstructured merge bottom left does not report any conflict but results in a broken program that contains two methods getstring one before the declaration of array values and constructor bag as in version right and one after as in version left .
in contrast structured merge notices two versions of method getstring and their difference in the initialization of the local variable sep which results in a conflict reported to the user bottom right .
note that conflicting code may be even well typed and still misbehave.
on the downside structured merge relies on information on the syntax of the artifacts to be merged.
in practice this means that one has to create one merge tool per artifact type or language.
although the creation of a merge tool can be automated to some extent still manual effort is necessary to provide the specific information of the particular kind of artifact being processed .
nevertheless for languages that are widely used such as java it is certainly useful to spend the effort and to create and use a dedicated merge tool.
a more severe problem of structured merge which we want to address here is the run time complexity of theversion base class bag int values bag int v values v version right class bag string getstring string res string sep for intv values res v sep return res int values bag int v values v version left class bag int values bag int v values v string getstring string res string sep for intv values res v sep return res unstructured merge class bag string getstring string res string sep for intv values res v sep return res int values bag int v values v string getstring string res string sep for intv values res v sep return res structured merge class bag int values bag int v values v string getstring string res string sep left right for intv values res v sep return res derive merge figure conflict detected with structured merge but not with unstructured merge internal merge algorithm.
typically it relies on trees or graphs and corresponding matching and merging operations.
although there is the possibility of adjusting the complexity by considering only parts of the artifacts structure e.g.
context free syntax only or by using a less precise matching even these compromises result in at least cubic or even exponential time complexity.
this inherent complexity seems to be a major obstacle to a practical application.
in the next section we present an approach based on tree matching and amalgamation paired with an auto tuning approach to push back the limits of structured merge in this respect.
.
our approach our approach has three ingredients we represent artifacts as context free syntax trees including information on which program elements can be permuted safely.
we use two tailored tree matching algorithms one for unordered and one for ordered child nodes the former for program elements that can be permuted safely the latter for those that must not be permuted the rules for merge and conflict resolution are language specific.
we use the full power of structured merge only in situations in which unstructured merge reports conflicts.
.
artifact representation we represent artifacts by terms of trees that reflect their context free syntax.
an alternative would be to model also the context sensitive syntax which would result in graphs rather than trees .
of course the matching and merging operations would be even more precise in this case but also computationally even more complex.
the problems illustrated in figure inability to resolve a conflict and figure inability to detect a conflict arise from the fact that unstructured merge tools have no information on which program elements can be permuted safely.
we include this information in our structured merge approach.
for every type of program element e.g.
class declaration method declaration statement the tool knows whether the corresponding elements can be permuted and it uses this information during the matching and merge operations.
.
algorithms the overall merge process involves three phases calculating a matching between the trees of the input versions amalgamating the trees based on the calculated matching and resolving conflicts during the merge operation.
next we discuss all three phases in detail.
tree matching.
tree matching takes two trees computes thelargest common subtree and adds matching information to them.
matching of nodes depends on their syntactic category e.g.
two field declarations are considered equal if their types and names match .
tree matching distinguishes between ordered nodes which must not be permuted and unordered nodes which can be permuted safely .
for ordered nodes we use a variation of yang s algorithm we compute for all pairs ai b j recursively the number of matches w and the maximum matching m as shown in algorithm .
note the recursive call invokes treematching which calls orderedtreematching or unorderedtreematching algorithm depending on whether the nodes at this level are ordered or unordered.
the problem of finding the largest common subtree of ordered trees is quadratic in the number of nodes .
algorithm ordered tree matching function orderedtreematching node a node b ifa negationslash bthen return nodes do not match end if m number of children of a n number of children of b matrix m m n initialize auxiliary matrix fori ..mdo forj ..ndo w treematching ai bj matching for children m max m m m w end for end for return m return maximum number of matches end functionfor unordered nodes we solve the problem using a linearprogramming approach as shown in algorithm .
again we compute for all pairs ai b j the number of matches recursively.
finding the highest number of matches in the resulting matrix mis equivalent to computing the maximum number of matches in a weighted bipartite graph which can be solved in cubic time .
we express the problem as a linear program and solve it using a linear program solver which proved to be fast in our experiments.
in algorithm solvelp creates the constraint matrix the input matrix invokes the solver and returns the maximum number of matches of which we can compute the actual matching.
algorithm unordered tree matching function unorderedtreematching node a node b ifa negationslash bthen return nodes do not match end if m number of children of a n number of children of b matrix m m n initialize auxiliary matrix fori ..mdo forj ..ndo m treematching ai bj matching for children end for end for sum solvelp m prepare and invoke lp solver return sum return maximum number of matches end function overall we perform tree matching on each pair of trees left base right base left right .
as a result the nodes of each tree are tagged with information on the nodes of the other versions that they match.
note that tree matching based on computing the largest common subtree compares the input trees level wise.
algorithms that compare trees across levels are more precise but also more complex as we discuss in section .
we provide more details on the two matching algorithms elsewhere .
tree amalgamation.
tree amalgamation takes the three trees enriched with matching information base left and right tree and creates a merged tree as result.
to this end it distinguishes three kinds of nodes unchanged nodes that are contained in all three trees.
consistently changed or added nodes that are contained in the left and the right tree but not in the base tree.
independently changed or added nodes that are contained either in the left orthe right tree and not in the base tree.
based on this distinction the algorithm fills the merged tree in three steps as shown in algorithm .
algorithm tree amalgamation merge function merge node left node base node right merged empty tree unchanged n n base n left n right insert unchanged merged consistent n n base n left n right insert consistent merged lchanges n n left n merged n right n base rchanges n n right n merged n left n base detectconflicts lchanges rchanges mergechanges merged lchanges mergechanges merged rchanges end function123merging unchanged and consistently changed or added nodes is rather simple because the left and the right version are not in conflict.
to perform two way merges the first step the insertion of unchanged nodes is omitted.
the challenge is to apply changes introduced by only one version.
finding such independent changes is easy using matching information attached to the nodes.
but before we can apply the independent changes to the merge tree we have to check whether they conflict with changes of the other respective version.
to this end a list of all independent changes of the left and right version is passed to the phase of conflict detection and resolution.
conflict detection and resolution.
to detect possible conflicts between two versions left and right each change of a version is checked against each of the other version.
for brevity we explain here only insertion conflicts others such as deletion insertion conflicts are handled similarly .
an insertion conflict occurs potentially when two nodes are inserted concurrently at the same parent node in the merge tree.
here again the algorithm has to distinguish between ordered and unordered nodes.
for ordered nodes the insertion positions are decisive if they overlap the nodes are flagged as conflicting.
for example including a statement s1 in a block at the first position does not conflict with another statement s2included later in the block only if s1ands2 are added to the same position they are in conflict.
whether unordered nodes are in conflict depends on their type.
some nodes must be unique in the scope of their parent.
so two nodes added with the same name may be in conflict even though added in different positions.
for example a class declaration must not contain multiple field declarations with the same name two independently added fields with the same name raise a conflict.
but a field does not conflict with a method.
at this point it becomes again apparent that structured merge is not language independent.
beside information on which program elements can be permuted safely conflict detection depends highly on the language specifics.
due to this fact and the sheer size we cannot show algorithm detectconflicts .
its implementation is available on the supplementary web site.
after conflict detection the changes of both versions are inserted into the merge tree as we show in algorithm .
nodes not marked as conflicting are inserted straightforwardly.
a node flagged as conflicting contains a list of conflicting changes that belong to the other version and a list of related changes that belong to its own version.
technically we use dummy nodes to store conflicting nodes the pretty printer displays conflicts according to this information.
algorithm merge changes function mergechanges tree merged list changes for all node ninchanges do ifisconflict n isprocessed n then node c new dummy node c.lvariant own n store own changes c.rvariant other n store other changes insert c merged for all node minown n other n do markprocessed m end for else insert n merged end if end for end function3.
auto tuning the algorithms presented in section .
are computationally complex.
in particular computing the largest common subtree is cubic in the number of unordered program elements .
this is a limitation of structured merge compared to the quadratic time algorithm of unstructured merge.
but we do not want to abandon structured merge entirely.
instead we strive for a balance between employing syntactic information to detect and resolve conflicts and attaining acceptable performance.
the idea is simple.
we use unstructured merge as long as no conflicts are detected.
the rationale is that in software merge usually only few parts of a program are changed and even fewer participate in conflicts as postulated by mens rule .
so for most parts of a program we can save the computation time for an expensive tree matching.
however this way we may also miss conflicts due to the imprecision of unstructured merge.
this is the price we pay for improving performance but our experiments suggest that the price is acceptable as we discuss in section .
once unstructured merge detects conflicts we use structured merge selectively on a per file basis i.e.
for triples of file versions instead.
this way we take advantage of the capabilities of structure merge to detect and resolve conflicts.
.
evaluation to evaluate our approach especially the balance between precision and performance that we strive for with autotuning we implemented a prototype of a structured merge tool called jdime and we conducted a series of experiments based on real world software projects.
the tool as well as all merge scenarios and experimental data are available at the supplementary web site.
.
implementation we have implemented jdime on top of the jastaddj compiler framework.1the implementation was straightforward because jastaddj provides excellent extension capabilities.
the foundation for our artifact representation are the abstract syntax trees generated by jastaddj.
for technical reasons we had to build our own tree representation on top of it.
we implemented the matching and merging algorithms straightforwardly by means of visitors and aspects.
for unordered tree matching we used the glpk solver.
information on which program elements can be reordered safely was included based on the java language specification.
we also took care of the fact that java code usually comes with comments they are extracted during parsing and put back in after the merge.
.
hypotheses and research questions to make our expectations precise we pose four hypotheses and a research question h1the conflicts reported by unstructured merge differ from the ones reported by structured merge in terms of frequency size and kind.
h2unstructured merge is substantially faster than structured merge.
h3auto tuning does not miss many conflicts detected by purely structured merge.
overview of the sample projects all from project domain merge lines scenarios of code drjava development environment k freecol turn based strategy game k genealogyj editor for genealogic data k itext pdf library k jedit programmer s text editor k jmol molecule viewer k pmd bug finder k squirrelsql graphical sql client k h4auto tuning is substantially faster than purely structured merge.
r1what fraction of a merge scenario in terms of files can be handled by unstructured merge in that no conflicts are reported?
in other words can we confirm mens postulate that of merge scenarios can be handled properly with unstructured merge?
.
sample projects we selected open source java projects that we have used in the past to assess and compare merge approaches .
the projects are of reasonable but varying sizes from different domains and have a substantial version history.
for each project there are multiple merge scenarios that give rise to conflicts .
technically a merge scenario is a triple consisting of a base a left and a right version whereby the base version is the common ancestor of the other two.
in table we list information on the sample projects including name domain number of merge scenarios and number of lines of code.
each of the projects comes with to merge scenarios.
all merge scenarios together consist of more than million lines of java code.
they are available and documented at the supplementary web site.
.
methodology our method of evaluation was twofold.
first we compared unstructured and structured merge with and without auto tuning with regard to conflict detection and performance.
second we analyzed a subset of conflicts manually in order to learn more about the capabilities of unstructured and structured merge.
overall we applied our merge tool to each of the merge scenarios thrice using unstructured merge purely structured merge and structured merge with auto tuning.
for each merge pass we measured the execution time times and computed the median and we counted the number of reported conflicts and conflicting lines of code.
we conducted all measurements on a desktop machine amd phenom ii x6 1090t with cores .
ghz and gb ram with gentoo linux kernel .
.
and oracle java hotspot bit server vm .
.
.
.
results in figure we depict the average number of conflicts for each project as reported by unstructured merge purely structured merge and structured merge with auto tuning.
3we had to exclude projects and merge scenarios due to technical problems with the jastaddj implementation the problems are not related to our approach.
drjava freecol genealogyj itext jedit jmol pmd squirrelsqlnumber of conflicts log scale 500unstructured purely structured auto tuningfigure number of reported conflicts drjava freecol genealogyj itext jedit jmol pmd squirrelsqlnumber of conflicting lines log scale 10000unstructured purely structured auto tuning figure number of conflicting lines of code drjava freecol genealogyj itext jedit jmol pmd squirrelsqltime in milliseconds log scale unstructured purely structured auto tuning figure merging time in seconds similarly in figure we depict the respective numbers of lines of code involved in conflicts.
finally in figure we depict the times consumed by three merge approaches.
table shows the experimental data for all merge scenarios.
all raw data on a per file scenario basis are available at the supplementary web site.
at a glance the numbers and sizes of conflicts reported by unstructured merge differ significantly from the ones reported by structured merge.
in almost all projects structured merge reports fewer and smaller conflicts.
interestingly purely structured merge and structured merge with auto tuning report almost similar numbers of conflicts which means that only few conflicts are missed due to the selective use of unstructured merge apart from the fact that the reported sets of conflicts are equal .
with regard to performance structured merge is substantially slower than unstructured merge unstructured merge is up to times125faster times on average.
but structured merge with autotuning is up to times faster than purely structured merge times on average.
.
discussion hypotheses research questions.
based on the results we can confirm hypothesis h1 the conflicts reported by unstructured merge differ significantly in terms of number size and kind from the ones reported by structured merge.
in all projects but itext structured merge is able to resolve more merge conflicts than unstructured merge.
on average structured merge reports of the number of conflicts and of the number of conflicting lines of unstructured merge.
analyzing a random subset of conflicts we found that these numbers are mainly due to ordering conflicts that cannot be handled properly in unstructured merge.
project itext is an outlier in that structured merge reports significantly more conflicts.
a manual inspection revealed that this is due to a renaming in the directory structure in the project.
this leads the three way merge to miss a version in the triple which results in one conflict per file with unstructured merge and many conflicts at the syntactic level with structured merge.
a similar problem occurs in freecol although less serious.
interestingly our experiments support hypothesis h3 the conflicts reported by purely structured merge are largely the same as the ones reported by using the auto tuning approach.
that is the strategy to use unstructured merge as long as no conflicts are detected and to switch upon detection of a conflict to structured merge seems to suffice.
not many conflicts are being missed up to in freecol and on average.
considering the performance gains and the state of the art this seems acceptable.
furthermore our experiments confirm hypothesis h2 in all projects structured merge is substantially slower than unstructured merge.
unstructured merge is up to times faster than structured merge times on average.
this result does not need much interpretation.
although we could optimize jdime further we cannot escape the complexity of the algorithms involved in the structured merge process.
also we can confirm hypothesis h4 structured merge with auto tuning is faster than purely structured merge in almost all projects up to times and times on average.
in the projects genealogyj jedit pmd and squirrelsql it is even in the order of the time of using unstructured merge.
so auto tuning seems to be at least promising to hit a sweet spot between precision and performance.
in jmol anditext very large files diminish the relative benefit of auto tuning up to nodes per file and nodes per level .
finally as for research question r1 we found that of the changed files cannot be merged with unstructured merge twice as many files as predicted by mens.
with structured merge this fraction can be decreased to .
so we cannot confirm that of merge scenarios can be handled properly with unstructured merge.
runtime complexity.
in figure we compare the file size in terms of lines of code mean number of lines of code of the file versions involved in a merge and the time needed for the merge of the file versions in question using unstructured and purely structured merge.
apart from two groups file size in number of lines of codemerge time in millisecondsunstructured three way structured three way unstructured two way structured two way figure file size in number of lines of code versus merge time in milliseconds average number of nodes per syntax tree levelmerge time in millisecondsunstructured three way structured three way unstructured two way structured two way figure average number of nodes per syntax tree level versus merge time in milliseconds of outliers at files sizes of and of lines of code the merge time grows smoothly with the file size.
while the group at can be explained with the cubic runtime complexity of the algorithms involved we were curious as to why there are so many outliers around file sizes of lines of code.
an analysis revealed that these outliers stem from merges that are actually two way mainly due to a renaming in project itext see above .
so two way merges are substantially more expensive than three way merges and the corresponding merge time grows more quickly than for three way merges.
note that in the color version of the paper data points related to two way merges are displayed with alternative colors.
in our quest of understanding the merits of structured merge we computed a number of further statistics such as the average number of nodes depths and widths of the syntax trees involved in a merge.
we found that the number of nodes per syntax tree level is a more accurate measure than lines of code the merge time grows smoothly polynomially with the number of nodes per syntax tree level as displayed in figure .
notice that the outlier group of figure moved to the right which demonstrates that small files may be more complex to merge than large files when there are many nodes per level in the syntax trees .
furthermore we were interested in the role of conflicts for the time needed for merging.
our analysis revealed that almost all outliers of merge times milliseconds stem from structured merges that reported conflicts.
so the insight is that structured merge is able to resolve many conflicts that unstructured merge is not able to handle and126that structured merge is able to do so in acceptable time.
but if structured merge encounters conflicts it cannot resolve its time consumption increases substantially.
further observations.
to learn more about the capabilities of structure merge we inspected a subset of the conflicts manually.
next we report the most interesting observations.
tree matching is at the heart of structured merge.
its precision is much higher than that of unstructured merge but it is not perfect.
we found situations in which structured merge was not able to resolve a conflict even though it could be resolved manually.
the reason is that algorithms based on computing largest common subtrees consider only corresponding tree levels.
to establish a matching across different levels e.g.
to detect shifted code one can use algorithms that compute largest common embedded subtrees but they are generallyapx hard .4it will be an interesting avenue of further research to incorporate even such complex algorithms during auto tuning including approximations.
furthermore we found that most conflicts raised by unstructured merge are related to the order of program elements.
these conflicts can be handled by structured merge be it in terms of automatic conflict resolution as in figure or in terms of uncovering hidden conflicts as in figure .
we also found that conflicts reported by structured merge are typically fine grained and align with the syntactic program structure.
with unstructured merge the conflicts are typically larger and often crosscut the syntactic program structure which makes them harder to track and understand.
project itext is an extreme case due to a renaming in the project s directory structure often one component of the merge triple is missing.
in such cases the three way merge becomes actually a two way merge.
for unstructured merge we get a large conflict per file for structured merge we get many small conflicts.
so two way merges challenge structured merge which shall be an avenue of further research.
.
threats to validity in empirical research a threat to internal validity is that the data gathered may be influenced by hidden variables in our case variables other than the kind of merge.
due to the simplicity of our setting we can largely rule out such confounding variables.
we applied unstructured and structured merge to the same set of merge scenarios and counted the number of conflicts and lines of conflicting code that occurred in the merged code.
we performed all performance measurements repeatedly in order to minimize measurement bias.
furthermore we used a comparatively large sample to rule out confounding variables such as programming experience and style.
a common issue is whether we can generalize our conclusions to other projects of other domains and written in other languages.
to increase external validity we collected a substantial number of projects and merge scenarios.
we argue that the simplicity of our setting as well as the randomized sample allow us to draw conclusions beyond the projects we looked at.
our findings should even apply to languages that are similar to java e.g.
c .
4the set ofapx problems is a subset of np optimization problems for which polynomial time approximation algorithms can be found.
.
related work structured merge.
after the seminal work of westfechtel and buffenbarger many proposals of structuredmerge techniques have been made.
on the one hand there are proposals for structured merge tools that are specific to mainstream programming languages such as java and c .
on the other hand there are many proposals of structured two way and three way merge techniques for modeling artifacts a comprehensive