cross checking oracles from intrinsic software redundancy antonio carzaniga university of lugano switzerland antonio.carzaniga usi.chalberto goffi university of lugano switzerland alberto.goffi usi.ch alessandra gorla saarland university germany gorla st.cs.unisaarland.deandrea mattavelli university of lugano switzerland andrea.mattavelli usi.chmauro pezz university of lugano switzerland university of milano bicocca italy mauro.pezze usi.ch abstract despite the recent advances in automatic test generation testers must still write test oracles manually.
if formal specications are available it might be possible to use decision procedures derived from those speci cations.
we present a technique that is based on a form of speci cation but also leverages more information from the system under test.
we assume that the system under test is somewhat redundant in the sense that some operations are designed to behave like others but their executions are di erent.
our experience in this and previous work indicates that this redundancy exists and is easily documented.
we then generate oracles by cross checking the execution of a test with the same test in which we replace some operations with redundant ones.
we develop this notion of cross checking oracles into a generic technique to automatically insert oracles into unit tests.
an experimental evaluation shows that cross checking oracles used in combination with automatic test generation techniques can be very e ective in revealing faults and that they can even improve good hand written test suites.
categories and subject descriptors d. .
software program veri cation d. .
testing and debugging general terms veri cation keywords redundancy test oracles oracle generation permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction test oracles discriminate successful from failing executions of test cases.
good oracles combine simplicity generality and accuracy.
oracles should be simple to write and straightforward to check otherwise we would transform the problem of testing the software system into the problem of testing the oracles.
they should also be generally applicable to the widest possible range of test cases in particular so that they can be used within automatically generated test suites.
and crucially they should be accurate in revealing all the faulty behaviors completeness no false negatives and only the faulty ones soundness no false positives .
test oracles are often written manually on a case by case basis commonly in the form of assertions for example junit assertions.1such input speci c oracles are usually simple and e ective but they lack generality.
writing such oracles for large test suites and maintaining them through the evolution of the system can be expensive.
writing and maintaining such oracles for large automatically generated test suites may be practically impossible.
it is possible to also generate oracles automatically even though research on test automation has focused mostly on supporting the testing process creating sca olding managing regression test suites and generating and executing test cases but much less on generating oracles .
most of the work on the automatic generation of oracles is based on some form of speci cation or model.
such oracles are very generic since they simply check that the behavior of the system is consistent with the prescribed model.
however their applicability and quality depend on the availability and completeness of the models.
for example speci cationbased oracles are extremely e ective in the presence of precise speci cations such as protocol speci cations but they are not easily applicable to many other systems that come with informal and often incomplete speci cations.
another classic approach to obtain generic oracles is to use what weyuker calls a pseudo oracle that is another program intended to behave exactly as the original.
the actual oracle requires the execution of the two programs with the same input followed by a comparison between the results of the two executions.
the production of an to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
alternative version of the program makes this technique completely generic but it also makes it quite expensive.
there are also interesting solutions somewhere in between model based oracles and pseudo oracles.
for example astoot symmetric testing and metamorphic testing do not require complete behavioral models and instead exploit symmetries and equivalences in the speci cation.
astoot derives tests and corresponding pseudooracles from algebraic speci cations in the form of pairs of equivalent and non equivalent sequences of operations.
in a similar way metamorphic and symmetric testing use the commutativity of some operations or the symmetric behavior of an operation with di erent inputs to identify di erent sets of inputs that should produce the same result.
the testing methods proposed with these techniques are interesting alternatives to both input speci c and completely generic oracles.
di erently from input speci c oracles they are not limited to a xed set of inputs.
and di erently from generic oracles they do not attempt to compute or verify a result using an alternative program but instead use the system as both the original and the alternative program e ectively making the system test itself.
we propose a similar method that is also rooted in the idea of a pseudo oracle.
speci cally we exploit the intrinsic redundancy of software systems to generate what we call cross checking oracles .
unlike other approaches we use speci cations that are closer to the code and therefore arguably simpler to obtain.
we also decouple the generation of the oracle from the test input obtaining a more versatile method to generate oracles and therefore a more e ective testing process.
in very simple terms we build oracles by having the system under test cross check itself.
these cross checks exploit the intrinsic redundancy of the system under test.
this is a property of various systems that we have studied and characterized and that we have used to implement a self healing mechanism for web applications and for general purpose systems .
in this paper we describe a method to exploit this intrinsic redundancy to generate oracles and enhance the e cacy of test suites.
as summarized in the next section the intrinsic redundancy of software systems has various sources from design for adaptability and generality to reusability and backward compatibility.
also such redundancy manifests itself at di erent levels from single statements to method calls subsystems and entire libraries.
the technique we propose uses redundancy at the method level and in particular generates oracles localized around the invocations of methods in the test driver that admit to redundant alternative code which then leads to potentially fault revealing cross checks.
the technique is opportunistic in nature a cross check may exercise the right functions and such functions may be redundant enough to reveal a fault.
however cross checking oracles are not intended to be complete.
on the other hand cross checking oracles can be generated and embedded in a test suite completely automatically at practically no cost to the developers and testers.
we develop a technique to generate and activate oracles through an aspect oriented programming mechanism.
notice that such oracles lead to intermediate checks as well as checks on the nal result and such intermediate checks may reveal faults whose e ects may be masked during the complete execution of the test.
we then report the results of an initialexperimental evaluation that demonstrates that this method can indeed lead to e cient and e ective oracles.
in summary we make the following contributions we introduce the notion of cross checking oracles obtained by exploiting the intrinsic redundancy of software systems and realized through the embedding and coordinated execution of fragments of cross checking code.
we develop a speci c concrete technique that makes cross checking oracles practical and accurate.
we report the results of an experimental evaluation that shows that cross checking oracles can be e ective especially in conjunction with automatic test generation.
the paper is organized as follows.
section introduces the concept of intrinsic redundancy for software summarizes the origins and scope of the phenomenon and shows some cases of intrinsic redundancy in libraries at the method level.
section details a technique to generate and deploy crosschecking oracles obtained from speci cations of redundancies in the system under test.
section presents the experimental evaluation of this technique and in particular shows that cross checking oracles complement state of the art test case generation tools such as randoop.
section surveys the main approaches to the generation of oracles with a special focus on those that are most related to this work.
section summarizes the contributions of the paper and describes ongoing research work.
.
software redundancy we obtain cross checking oracles by exploiting the intrinsic redundancy of software systems.
in this section we introduce the concept of intrinsic redundancy informally and discuss some manifestations of this redundancy.
the interested reader can nd more details about software redundancy and some of its uses elsewhere .
informally a system is redundant when it can perform the same actions through di erent executions either with di erent code or with the same code but with di erent input parameters or in di erent contexts.
this happens for example in systems that use di erent algorithms for the same functionality.
for instance the gnu standard c library implements its basic stable sorting function using insertion sort for small sequences and merge sort for the general case.
the same redundancy arises in libraries that provide specialized implementations of functionalities already available in other components of the system.
for instance thetrove4j library implements collections specialized for primitive types that overlap with the standard java library.
redundancy can occur in various forms and at di erent levels of abstractions in a system from statements to services to entire subsystems.
the de ning elements of this software redundancy are what is considered di erent in two executions and what is considered equivalent in their outcome.
for the purpose of this paper we consider di erences in the code of a test that amount to di erent sequences of method calls of the system under test that then induce di erent executions of the same test.
and for the outcome of those di erent executions we consider functional properties and therefore we build our technique on a notion of observational equivalence .9321public boolean put k key v value f collection v collection map.get key 3if collection null f collection createcollection key if collection.add value f totalsize map.put key collection return true mutation return false 9gelsef throw new assertionerror spec violated 11g 12gelse if collection.add value f totalsize return true 15gelsef return false 17g 18g1public boolean putall k key iterable ?extends v values f 2if !values.iterator .hasnext f return false 4g collection v collection getorcreatecollection key 6intoldsize collection.size 7boolean changed false 8if values instanceof collection f collection ?extends v c collections2.cast values changed collection.addall c 11gelsef for v value values f changedj collection.add value 14g 15g totalsize collection.size oldsize return changed 18g figure methods putand putall of the abstractmultimap k v class from the guava library we say that two executions of a system are equivalent functionally if their outcome can not be distinguished by probing the system through its public interfaces.
in particular two di erent sequences of method calls on an object may leave the object in two di erent internal states.
however if those two states cannot be distinguished through any sequence of methods of the public interface of the object then we say that the two sequences are equivalent.
notice that this is an ideal notion of equivalence.
in section we discuss the necessary assumptions and limitations we pose for the actual implementation of the equivalence checks.
having de ned at least informally the notion of redundancy that we plan to exploit to obtain oracles we now argue again informally that such redundancy is indeed present in modern software systems.
we start from an example and then provide more evidence based on prior analyses and other observations.
consider the methods put k key v value and putall k key iterable ?
extends v values of the abstractmultimap k v class of the popular google guava library.2the putand putall methods associate a given key with a given value and collection of values respectively.
this suggests that put k v would be equivalent to putall k c with the same key kand a singleton collection ccontaining value v. the putand putall methods of the guava library are implemented with di erent code.
figure reproduces the code of the two methods with only minor formatting changes.
the executions of the two methods may in turn invoke the same code for example line of putand line of putall depending on dynamic binding .
still one fault in the put method could be detected by a test that runs that method and by an oracle that compares the result with an equivalent execution of the putall method.
for example consider a simple mutation of line of method putthat causes putto return false instead of true.
such a faulty mutation would be detected by a simple test that calls putto insert one key value mapping and by an oracle that does the same through putall .
in this case the equivalence check is trivial since the two executions themselves return di erent values and therefore are immediately deemed observationally nonequivalent without the need for any additional probing calls.
e ectiveness of test oracles built from related methods such as putand putall depends on the independence of their code.
when related methods share some or most of their code they may produce the same wrong result and thus may not be able to detect a failure.
and indeed related methods often share code and sometimes are almost completely identical as is the case when a method simply wraps a call to the other with a few minor initialization or termination steps.
still our past experience indicates that software systems contain many equivalent methods or sequences of methods that are independent enough and therefore usable for their redundancy .
the experiments presented in section also o er further evidence that software is intrinsically redundant and that such redundancy is usable.
having observed that intrinsic redundancy exists it is natural to ask how and where this redundancy might arise.
without wanting to explore these questions in great depth we simply mention some potential sources of useful intrinsic redundancy with some examples.
there are plausible and general reasons to assume that modern software systems especially modular components are intrinsically redundant.
this is redundancy that is not deliberately introduced by the designers as in n version programming and therefore that does not incur additional development costs.
design for reusability is a source of intrinsic redundancy.
reusable libraries typically o er di erent ways of executing the same functionalities.
for example google s guava library o ers several methods to create immutable collections copyof builder of etc.
these methods di er in the interface usage but they are essentially equivalent in terms of the nal results.
performance optimization and context speci c optimization are another source of redundancy.
as we already mention above a sorting function may be implemented through multiple di erent and therefore redundant algorithms and similarly one library such as the trove4j library may provide an optimized version of the functionality already provided by another library in this case the standard java library .
backward compatibility is another source of redundancy.
for example the java standard library contains classes and methods that are deprecated and that overlap with the functionality of newer classes and methods.933there are also various studies that demonstrate that a considerable amount of intrinsic redundancy exists in software systems at various abstraction levels in di erent application domains and in various forms.
gabel et al.
reported more than semantic clones in the linux kernel and jiang and su studied the linux kernel at a di erent granularity level and found more than semantically equivalent code fragments where semantic clones and semantically equivalent code refer to code fragments that produce the same results without sharing the whole code.
in previous work some of these authors identi ed more than semantically equivalent sequences of method calls in popular javascript web apis such as youtube google maps and jquery and more than semantic equivalences in java applications and libraries of non trivial size and complexity including apache ant google guava jodatime and eclipse swt.
the same previous work also shows that this redundancy can be put to a good use in particular to implement a self healing mechanism based on automatic workarounds .
for the experiments reported in this paper we identi ed a total of equivalences over methods.
we did that manually starting from the javadoc speci cations of the considered libraries with an e ort of about person hours by phd students with some familiarity with the libraries.
both our group and the group of martin monperrus at the university of lille are investigating the possibility of identifying redundant methods automatically with dynamic analysis.
the results obtained so far indicate that we can identify redundant methods automatically with negligible e ort.
.
cross checking oracles we now describe in detail the technique we have developed to generate test oracles that exploit the intrinsic redundancy of software systems.
the technique exploits the redundancy present at the level of method calls.
more speci cally we consider systems in which a method call possibly a static method can be replaced by one or more other calls plus possibly some glue code.
this redundancy can be expressed through equivalences of the form class method type1param1 fcode using target of type class and param 1of type type .
.
.g class static method type1param1 fcode using param 1of type type .
.
.g the right hand side of the equivalences is in principle arbitrary code but in practice amounts to little more than one or a few alternative calls.
below are two examples abstractmultimap.put string key object value f list list new arraylist list.add value target .putall key list g abstractmultimap.clear ffor string key target .keyset f target .removeall key gg the rst example expresses the equivalence between the putand putall methods of the abstractmultimap class of the 3martin monperrus private communication .guava library.
the second example expresses an analogous equivalence for two other methods of the same class.
the technique we propose takes equivalence speci cations and produces oracles that can be automatically deployed within any existing test suite.
the technique is based on an instrumentation of the code of the test that for every call corresponding to the left hand side of an equivalence speci cation performs a cross check that executes both the original call and the equivalent code speci ed in the righthand side and then checks that the two executions were indeed equivalent.
thus the main ingredients of the technique are automatic deployment a mechanism to deploy an oracle for every call corresponding to the left hand side of an equivalence.
cross check execution a mechanism to correctly execute both the original call and the corresponding equivalent code and then to compare their outcomes.
equivalence check a decision procedure to verify that the outcomes of the two executions are indeed equivalent.
notice that for the technique to be truly automatic in general all the above mechanisms must be independent of the test and of the system under test which is one of the essential technical di culties of implementing our technique.
another technical di culty is to avoid spurious di erences between the executions of the original call and the equivalent code.
this is where we see the most signi cant limitations of our technique.
for example such di erences may be caused by interference between the two executions.
one form of interference that our current implementation does not handle well is through the use of multiple threads in the original or in the equivalent code.
other problematic forms of interference are through les and other input output operations.
yet other spurious di erences might arise from non determinism such as the simple use of the system clock which may return di erent results if the two executions are shifted in time.
we now describe our approach to implement each technical aspect of cross checking oracles.
.
automatic deployment we translate each equivalence into an advice that we then implement and deploy into test programs using the aspectj system.4see figure for an example.
an equivalence ede nes an advice class ae.
the left hand side of the equivalence de nes the join points for the advice which is where the body of the advice is executed and that corresponds to the speci ed method invocations.
then the left hand side and the right hand side of the equivalence translate directly into an originalcall and an equivalentcode method of the advice class ae respectively.
the execution of an oracle derived from an equivalence e proceeds as follows the advice implemented in ae advice is invoked right before a call corresponding to the left hand side of e ae advice saves the target object and the parameters of the call in speci cally declared member variables of the aeclass ae advice calls the crosscheck method of its base class that implements a generic cross check procedure described in the next section at some point the oracle1 extends basicoraclef 2private string key 3private object value around call put string object target map args key value 6public void advice abstractmultimap m string k object v f target m key k value v return crosscheck calls basicoracle.crosscheck 11g boolean originalcall f return target.put key value 15g boolean equivalentcode f list list new arraylist list.add value return target.putall key list 21g 22g1abstract class basicoraclef 2protected object target 4abstract object originalcall 5abstract object equivalentcode 7protected boolean crosscheck f object target orig target object target copy copy target object orig res originalcall target target copy object copy res equivalentcode assert equivalence orig res copy res assert equivalence target orig target copy 17g 18g figure oracle implementation and deployment through advice classes crosscheck method calls the originalcall and equivalentcode methods that invoke the implementations de ned in ae which can then refer to the target and parameters of the original call saved by ae advice the crosscheck method calls a generic equivalence check to compare the results and the state of the target object after the executions of originalcall and equivalentcode if the comparison detects an inconsistency then the oracle signals a failure otherwise the execution of the test continues with the result of the originalcall .
.
cross check execution cross checking oracles compare the outcome of the execution of an original method call and an equivalent code on a target object.
we now describe the mechanism that supports these two executions on the same object within a test.
a fundamental requirement is that the execution of the equivalent code should not a ect the execution of the original call and vice versa and since a test may contain multiple oracles it should also not a ect the remainder of the test.
in other words the execution of the equivalent code should be invisible and yet its outcome must be well visible to the comparison procedure to obtain an accurate cross check.
thus the challenge in implementing cross checks is to obtain two independent executions whose outcomes can be later compared accurately and with only one of them continuing beyond the cross check as if the other one never existed and to do all that e ciently.
to solve this challenge we tried a number of cross check patterns striving to make the cross check as accurate as possible.
we rst explored a solution in which the cross check forks the execution of the test into a completely separate virtual machine .
however this solution proved problematic because it is complex and ine cient but more importantly because it requires an equivalence check based on the serialization of the state of the target object which incurs a high rate of false positives.
we therefore turned to a solution in which the original call and the equivalent code as well as the comparison procedure execute in the same virtual machine.
in this case withoutthe isolation guaranteed by the platform the main problem is to maintain the state of the execution consistent with an execution of the original test without cross checks.
we tried two approaches one using a checkpoint mechanism and one using a copy of the target object.
with the checkpoint mechanism we obtain separation by un the e ects of the equivalent code by reverting to the prior state of the test.
first we create a checkpoint of the state of the test then execute the equivalent code save the state of the target object restore the state of the test to the checkpoint but retaining the saved state of the target object and then execute the original call.
at this point the equivalence check compares the state of the target object after the execution of the original call with the state of an object created from the previously saved state of the target object after the execution of the equivalent code .
unfortunately this solution also incurs false positives because similar to forking a separate virtual machine it must perform an equivalence check on a de serialized object.
and again this yields too many false positives.
we then focused on a solution in which the cross check would execute the equivalent code on a copy of the target object the cross check starts by creating a copy of the target object then it executes the original call on the original target and the equivalent code on the copy and then it checks the equivalence of the two executions by comparing the original target with the copy as well as the results of the execution.
this solution is perhaps simple but with a number of re nements it also proved to be the most e ective one.
we used a generic deep copy library5that we had to tweak in order to reduce the occurrence of false positives.
in particular we changed the copy procedure to avoid making copies of singleton objects for example those declared as static nal whose