an analysis of the variability in forty preprocessor based software product lines j rg liebig sven apel and christian lengauer university of passau joliebig apel lengauer fim.unipassau.dechristian k stner and michael schulze university of magdeburg ckaestne mschulze ovgu.de abstract over years ago the preprocessor cpp was developed to extend the programming language c by lightweight metaprogramming capabilities.
despite its error proneness and low abstraction level the preprocessor is still widely used in present day software projects to implement variable software.
however not much is known about how cpp is employed to implement variability.
to address this issue we have analyzed forty open source software projects written in c. speci cally we answer the following questions how does program size in uence variability?
how complex are extensions made via cpp s variability mechanisms?
at which level of granularity are extensions applied?
which types of extension occur?
these questions revive earlier discussions on program comprehension and refactoring in the context of the preprocessor.
to provide answers we introduce several metrics measuring the variability complexity granularity and types of extension applied by preprocessor directives.
based on the collected data we suggest alternative implementation techniques.
our data set is a rich source for rethinking language design and tool support.
categories and subject descriptors d. .
coding tools and techniques d. .
metrics d. .
processors preprocessors general terms empirical study keywords software product lines c preprocessor .
introduction the c preprocessor cpp is a popular tool for implementing variable software.
it has been developed to enhance c by permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.lightweight metaprogramming capabilities and is commonly used to merge les make arbitrary textual substitutions and de ne conditional code fragments a.k.a.
conditional inclusion .
as the cpp tool is line based it can be used with any text artifact including other programming languages such as java or c .
in the past it has been observed that the use of cpp causes various problems the occurrence of syntactic and semantic errors during the generation of software products code pollution due to scattered and tangled ifdefs a.k.a.
ifdef hell a decrease in maintainability and in ability to evolve .
the implementation of variable software is also a major goal of software product line engineering.
a software product line spl is a set of software intensive systems sharing a common managed set of features that satisfy the speci c needs of a particular market segment or mission and that have been developed from a common set of core assets in a prescribed way .
software product line engineering aims at managing variability among the di erent software products a.k.a.
variants of a product line and facilitating reuse in that the products of the product line share as many common core assets as possible such as source code artifacts .
it is widely assumed that the variability mechanism of the cpp tool is used quite frequently in the implementation of spls .
we believe this assumption to be true and contribute to the discussions on the connection between preprocessors and spls started in prior work with a substantial set of case studies.
we answer the following questions how does program size in uence variability of spls?
how complex are the extensions applied by features via cpp s variability mechanisms?
at which level of granularity are extensions applied?
which types of extension occur?
we argue that insights into the implementation problems of features solved with cpp help to judge whether cpp usage causes problems with regard to code pollution error proneness and reduced maintainability and ability to evolve.
an analysis of cpp usage also allows developers to estimate the e ort and bene ts of migrating to other more well founded implementation techniques for spl engineering such as aspects or various avors of feature modules .
to answer the questions above we analyzed forty opensource software systems of di erent sizes thousands to millions lines of code taken from di erent domains including operating systems database systems and compilers.
we propose a set of metrics that allow us to infer and classify cpp usage patterns and to map the patterns to common spl implementation concepts.
our analysis reveals that cpp is used to a large extent to implement and control variability 1in spl code bases on the average of each case study s code base is variable .
in general the preprocessor can be used at every level of granularity but we found that most extensions occur at a high level of granularity e.g.
adding a whole function .
the patterns of cpp usage which we have identi ed indicate that alternative more systematic spl implementation techniques are feasible and can improve code quality and reduce error proneness.
the degree of detail of the usage patterns even enables us to suggest speci c techniques e.g.
aspects and feature modules that match the properties of the implementation problems found in the software projects analyzed.
our greater goal is to raise the awareness of the problems of implementing variability with ad hoc mechanisms like preprocessor directives and to initiate a discussion on the feasibility of well founded spl implementation techniques.
to summarize we make the following contributions we discuss patterns for implementing variability using cpp.
we propose a set of metrics for identifying and classifying cpp usage patterns that map to well known concepts in spl engineering.
we present data collected with our tool suite cppstats on forty open source software systems of di erent sizes and from di erent domains.
based on the data obtained we analyze correlations between the size of a software system and the variability issues stated earlier.
we discuss the feasibility and bene ts of using alternative spl implementation techniques.
.
background before we begin with the variability analysis and the evaluation of the collected data we introduce spls the preprocessor cpp and cpp s role in spl development.
.
software product lines an important concept in spl engineering is that of a feature.
a feature represents an optional or incremental unit of functionality .
di erent programs called variants can be generated by selecting di erent features.
for example features can be optional or can form a group of alternative features.
usually a feature s implementation extends a program in one or more places called extension points .
if a feature extends multiple points and is not modular its code is scattered across the software system code scattering .
the code of features is often tangled with the base code and possibly with code of other features code tangling .
extensions made by a feature can be classi ed into homogeneous and heterogeneous extensions .
a homogeneous extension adds the same piece of code at di erent extension points and a heterogeneous extension adds di erent pieces of code at di erent extension points.
previous studies indicate that scattered and tangled feature code as well as homogeneous and heterogeneous extensions occur frequently in spls .
.
the c preprocessor cpp the preprocessor cpp is a stand alone tool for text processing which enhances c by lightweight metaprogramming capabilities .
although initially invented for c the preprocessor is not limited to a speci c language and can beused for arbitrary text and source code transformations .
the cpp tool works on the basis of directives a.k.a.
macros that control syntactic program transformations.
the directives supported by the cpp tool can be divided into four classes le inclusion macro de nition macro substitution and conditional inclusion.
in cpp based spl development macro de nitions de ne and conditional inclusions ifdef2 are most important.
.
spl development with cpp in order to illustrate how to implement variability with cpp we use a simple example of a list data structure with di erent features such as sortalgo sorting algorithms sortorder ascending or descending order and dlinked doubly linked list shown in figure .
common source code of the spl is represented using the capabilities of the programming language c in terms of data abstraction data types e.g.
struct t node on line and procedural abstraction functions e.g.
insert on line .
to implement variable source code using the cpp tool two things are necessary the de nition of a feature constant that can be referred to in the source code and the inclusion of additional source code representing the incremental functionality feature code .
a programmer uses the macro de ne to set a feature constant e.g.
dlinked on line .
feature constants can also be de ned externally in make les in con guration les or during the compiler invocation.
the cpp tool provides logical operators e.g.
and bit operators e.g.
to combine multiple feature constants to complex feature expressions .
a feature expression represents the condition that controls the inclusion or exclusion of feature code.
that is based on the evaluation of a feature expression all subsequent lines of source code up to the next ifdef are included or excluded depending on whether the expression evaluates to true or false e.g.
line is included if feature dlinked is selected .
we call the use of ifdef alsosource code annotation .
based on the de nition of feature constants the programmer is able to in uence the evaluation of the feature expression and consequently the presence or absence of feature code.
furthermore ifdef macros can be nested and the evaluation of a nested ifdef depends on the evaluation of the enclosing ifdefs .
technically every source code fragment that is enclosed by ifdef is an optional feature.
the speci cation of alternative features relies either on multiple ifdefs e.g.
feature sortalgo on line with the mutually exclusive options nosort insertionsort and bubblesort or the if elif else combination for specifying alternative source code e.g.
feature sortorder on lines and .
the code which implements a feature is often scattered across the spl s code base.
examples are the implementations of the features dlinked e.g.
line and and sortalgo e.g.
line and .
since the introduction of their feature constants and the annotation of their feature code are simple both features are easy to implement.
source code tangling arises from the mix of source code of 1cpp works on lines of text and is oblivious to the underlying language.
cpp directives may break existing tool support for languages such as java or c but can be used nonetheless for conditional compilation.
2for simplicity we refer to the various conditional inclusion macros such as ifdef ifndef and if summarily as ifdef .
3beside feature constants feature expressions may also contain numbers.
de ne nosort de ne insertionsort de ne bubblesort de ne dlinked de ne sortalgo bubblesort if sortalgo !
nosort de ne sortorder endif ... 11typedef struct t node int item struct t node next if dlinked struct t node prev endif node 19node first null if dlinked 21node last null endif 24void insert node elem if sortalgo bubblesort sortalgo insertionsort node a null node b null endif if sortalgo bubblesort node c null node e null node tmp null endif if null first first elem else if sortalgo insertionsort a first b first next if first item if sortorder else endif ... if sortalgo bubblesort ... endif figure a variable list implementation with cpp several features at one extension point.
a programmer species this mixture using the operator or nested ifdefs .
one example of tangling is feature sortorder on line that tangles with feature sortorder from line .
.
methodology before we present and discuss the results of our analysis let us have a closer look at the questions stated in the introduction regarding variability.
let us explain why these questions are important and describe how we obtain answers to them.
.
research questions our analysis lays the ground for answering a wide spectrum of questions regarding several areas in spl engineering.
we concentrate on four questions covering two areas program comprehension and refactoring.
the rst area contributes to discussions on program understanding whereas the latter refers to the applicability of alternative spl implementation techniques.
prior case studies on the preprocessor with respect to comprehension and refactoring either focused oncpp s variability mechanisms at a theoretical level or aimed already at refactorings of individual applications .
in contrast to these case studies we are interested in the general picture of the practical use of cpp s variability mechanisms.
comprehension .
how does program size in uence variability?
usually a large software system provides more features than a small software system.
a large code base increases the potential of variability.
we are interested in how many feature constants occur in the source code because they mark possible con guration parameters and de ne the con guration space of an spl.
furthermore we are interested in the amount of feature code because it represents variability at the source code level at which the programmer operates.
a high variability increases signi cantly the chances that the problems stated previously e.g.
syntactic and semantic errors or code pollution occur.
we argue that ad hoc variability mechanisms are only manageable up to a certain scale.
.
how complex are extensions made via cpp s variability mechanisms?
this question addresses the presence of scattered and tangled feature code.
we are interested in whether a higher number of features increases the degrees of scattering and tangling.
furthermore we are interested in the number of nested ifdefs a special case of source code tangling.
it is reasonable to expect that a high degree of scattering tangling and nested ifdefs impair comprehension.
refactoring .
at which level of granularity are extensions applied?
this question is motivated directly by prior discussions on the granularity of extensions in spls .
these discussions address the necessity of modularization techniques applied at a ne grain such as statement and expression extensions or function signature changes.
although the cpp tool allows a programmer to annotate code even at the nest level of granularity not much is known about the necessity to make such ne grained extensions.
further discussions on the modularization of features also motivate this question because most modular spl implementation techniques either lack the ability to make negrained extensions or require workarounds .
to this end we are interested in the level of and extent to which features cause ne grained extensions.
a high number of ne grained extensions incur the necessity of modularization techniques whereas a small number may not.
.
which types of extension occur?
this question targets the strengths and weaknesses of alternative spl implementation techniques.
for example homogeneous extensions can be implemented easily with aspect oriented language extensions of c because they provide a quanti cation mechanism for extending multiple places in the source code at a time.
heterogeneous extensions can be speci ed by simpler mechanisms such as mixins or feature modules .
furthermore this question is motivated by a prior case study on the use of aspectj in which it has been observed that most extensions in aspectj source code are heterogeneous we want to nd out whether this observation also applies to cpp based spl implementations.
.
metrics we cannot measure cpp usage in terms of comprehension and refactoring directly.
hence we introduce a set of metrics 3that represent these objectives.
we measure each metric after normalizing the source code of each software system i.e.
removing comments and so on .
next we explain each metric how we measure it and why it is useful for our evaluation and for subsequent discussions.
lines of code loc .
the loc metric represents the size of a software system.
we measure it by counting the number of newlines of every normalized source code le and use it later to discuss the in uence of program size on the remaining metrics.
comprehension number of features constants nofc .
the nofc metric re ects directly the con guration dimension of an spl and to this end provides insights into the variability and complexity of the spl.
we measure this metric by extracting feature constants from feature expressions in the source code and sum them per project.
our list spl figure contains six feature constants insertionsort bubblesort dlinked sortalgo and sortorder .
lines of feature code lof .
the lof metric is the number lines of feature code that are linked to feature expressions.
it tells us whether a small or a large fraction of the code base is variable.
we extract this metric by counting the number of lines between two ifdefs in source code les and sum them per project.
scattering degree sd and tangling degree td .
the sd metric is the number of the occurrences of feature constants in di erent feature expressions.
we measure this metric by extracting feature constants from feature expressions and calculate the average and standard deviation per project of all occuring feature constants.
this metrics tells us about the complexity of feature implementations.
a widely scattered feature that extends a software system in several les and at multiple extension points is more complex e.g.
for maintenance tasks than a feature that makes only a few extensions in a single le.
the td metric is the number of di erent feature constants that occur in a feature expression.
a low td is preferable because a high number of tangled feature constants in feature expressions may impair program comprehension.
average nesting depth of ifdefs and .
the and metric re ects the average nesting depth of ifdefs .
we calculate the average and the standard deviation of all ifdefs in a le and compute based on these values the average and standard deviation for a project.
since nested ifdefs form feature expressions this metric is useful for discussions on program comprehension.
4we do not count all macros as feature constants.
for example feature nosort is not a feature constant in our example because it is not used by an ifdef .
5we omit lines of code that are enclosed by include guards.
an include guard is a common preprocessor pattern that frames the entire content of a le with ifdef to avoid duplicate de nitions due to the multiple inclusion of les .
it does not represent an increment in functionality.
6the term tangling has a non standard meaning here.
usually tangling refers to the mixture of several features with each other side by side and or with the base code.refactoring granularity gran .
since cpp can be used with di erent host languages arbitrary changes such as coarse and negrained extensions are possible.
coarse grained extensions add new functions or data structures whereas ne grained extensions add source code pieces such as statement and expression extensions or function signature changes .
to this end we introduce the gran metric which is the number of ifdefs that occur at particular levels in the source code.
based on prior work and on the capabilities of alternative spl implementation techniques we measure the gran metric at six granularity levels of interest the global level gl e.g.
adding a structure or function figure line function or type level fl e.g.
adding an if block or statement inside a function or a eld to a structure figure line block level bl e.g.
adding a block figure line statement level sl e.g.
varying the type of a local variable expression level el e.g.
changing an expression figure line or function signature level ml e.g.
adding a parameter to a function .
the metric provides insight into the granularity of cpp based spls and is used in the discussion section to evaluate alternative spl implementation techniques.
we measure the metric by counting the number of occurrences of ifdefs at each gran level and sum them up for each project.
type type .
the programmer labels several parts in the source code as feature code either with distinct extensions heterogeneous or with the same extension using code duplicates homogeneous .
the type metric is the number of occurrences of particular extensions in the source code.
we distinguish three types homogeneous extension hom heterogeneous extension het and their combination heho by comparing subsequent lines of source code that belong to the same feature expression using exact string comparison we discuss this threat to validity later .
we use this metric to discuss possible refactorings.
.
analysis we analyzed forty di erent open source software systems written in c. we limited our analysis to c because it is used widely in software development and the range of public available open source projects varies from small kloc to very large kloc .
this section describes the selected software systems the setup of our analysis and the collected data.
we list the selected software systems in table .
our selection covers a variety of di erent domains such as operating systems and application software to give as complete an overview of cpp usage as possible.
we consider these software systems spls because all of them contain several optional and alternative features such as support for di erent platforms and application speci c con guration options.
to make the data of the di erent software systems comparable we applied rst some syntactic source code adjustments to the system s code base we deleted blank lines and comments and formatted the code uniformly.
furthermore we used the tool src2srcml7to generate an xml representation of the source code for measuring the granularity of extensions made with cpp.
the xml representation has all information of the basic language c in the form of an abstract syntax tree ast with additional information on the pre7 4software system version domain apache12.
.
web server berkeley db14.
.
database system cherokee10.
.
web server clamav10.
.
antivirus program dia10.
.
diagramming software emacs122.
text editor freebsd17.
operating system gcc14.
.
compiler framework ghostscript18.
.
postscript interpreter gimp12.
.
graphics editor glibc12.
programming library gnumeric11.
.
spreadsheet appl.
gnuplot14.
.
plotting tool irssi10.
.
irc client libxml .
.
xml library lighttpd11.
.
web server linux12.
.
.
operating system lynx12.
.
web browser minix13.
.
operating system mplayer11.0rc2 media player mpsolve22.
mathematical software openldap12.
.
ldap directory service opensolaris3 operating system openvpn12.
.
security application parrot10.
.
virtual machine php15.
.
program interpreter pidgin12.
.
instant messenger postgresql1 database system privoxy13.
.
proxy server python12.
.
program interpreter sendmail18.
.
mail transfer agent sqlite13.
.
database system subversion11.
.
revision control system sylpheed12.
.
e mail client tcl18.
.
program interpreter vim17.
text editor x g13.
.
vector graphics editor xine lib11.
.
.
media library xorg server41.
.
x server xterm12.
.
terminal emulator cluster pages mpsolve development versions of software systems are marked with the date of download in brackets.
table analyzed software systems processor statements.
the two levels of programming the metalevel of cpp and the source code level of c have separate namespaces in xml which gave us the opportunity to conduct a coherent and separate analysis of the source code.
we measured the metrics introduced in the section .
on the xml representation.
basically the analysis rests on the traversal of the xml annotated source code using our self written tool cppstats.
this tool and the comprehensive data for each system are available at our project s web site.8table on page depicts the condensed data of all forty software systems analyzed with our tool cppstats.
.
interpretation discussion the collected data provide answers to various research questions.
here we focus on program comprehension and during the refactoring discussion we concentrate on two alternative spl implementation techniques aspects and feature modules .
we limit our discussion to these two because in our view they have been receiving most attention from the academic community regarding implementation of variability in recent years.
subsequent to the data interpretation and refactoring discussion we discuss possible threats to validity.
the percentages given in this section are the average and the standard deviation a s .
all plots illustrate one of the metrics loc and nofc compared with some other metric.
additionally we calculated the correlation coe cient between the metrics being compared using the method of kendal because all input data are not normally distributed.
comprehension .
how does program size in uence variability?
the data reveal that the variability of a software system increases with its size figure a .
this is con rmed by the correlations between the metrics loc and nofc as well as loc and lof which correlate highly.
we can explain this correlation with the observation that larger software systems usually exhibit more con guration parameters and consequently are more variable.
the amount of variable source code lof metric in each project correlates with its size and is on the average figure b .
the lof metric reveals two interesting issues.
first we found that in some mid size software systems such as libxml2 openvpn sqlite and vim the amount of feature code exceeds of the code base.
second the four largest software systems freebsd gcc linux and opensolaris contain a smaller percentage of variable source code compared to the average.
a reason for both issues may be that the speci cation of con gurable features is more complex in larger systems than in smaller ones.
the higher complexity aligns with possibly more scattered and tangled features a correlation which we address next.
.
how complex are extensions via cpp s variability mechanisms?
the complexity of cpp based spl implementations increases with the increasing use of feature constants in feature expressions and of ifdef nesting sd td and and metric .
we observed that the size of a software system either correlates only at a very low level sd and td metric or does not correlate with the number of features and metric .
all data points are widely scattered and each correlation coe cient is close to zero.
that is we argue that there is no relationship between the number of features in a software system and the complexity in terms of feature constants.
initially we expected that in software systems with a high number of feature constants the complexity of feature expressions more feature constants are involved to be higher than in smaller software systems but the complexity stays the same.
notably the standard deviation of the scattering degree is in most systems quite high e.g.
emacs freebsd lynx and python .
that is a signi cant number of feature constants incur a high scattering degree and the respective implementation scatters possibly across the entire system.
however we cannot infer from the scattering degree the places at which feature constants occur in the source code.
the scattered feature constant may only appear in a subsystem e.g.
a group of les .
in the future this should be investigated in more detail.
the mean and the standard deviation of the tangling degree are quite small in most systems to on average and a loc correlation coefficient .
nofc 10k100k 1m10m b loc correlation coefficient .
lof in 10k100k 1m10m10 c nofc correlation coefficient .
lof 10k 500kfigure a plot loc nofc b plot loc lof with the average of variable source code in all software systems c plot nofc lof consequently the complexity of feature expressions is low.
a lower complexity is preferable because feature expressions that consist of a high number of feature constants impair program comprehension.
in addition to the scattering and tangling degree we measured the average depth of nested ifdefs figure c and metric .
notably in all software systems the average and is approx.
which means that nesting is used moderately i.e.
the number of nested ifdefs does not grow with the number of feature constants nofc metric .
a lower and is preferable because the programmer has to be aware of outer ifdefs when reasoning about inner code.
we also determined the maximum number of nested ifdefs in a le.
two projects freebsd and gcc reached a maximum number of .
the rest of the systems remained at to .
we argue that high numbers of nested ifdefs are not manageable impair program comprehension and increase the potential for errors.
furthermore a high and may reduce the potential for refactorings.
since a nested ifdef depends on the enclosing one the dependency between both ifdefs has to be taken into consideration when a refactoring should be applied.
refactoring .
at which level of granularity are extensions applied?
the data reveal that programmers use ne grained extensions e.g.
statement or expression extensions infrequently.9the overall occurrence of these extensions is .
.
on the average.
two projects use them slightly more frequently lighttpd with statement extensions and vim with expression extensions.
although speci c modularization techniques have been proposed for implementing ne grained extensions their usefulness seems to be limited.
most extensions occur at the global level gl metric enclosing functions type declarations de nitions 9less than of the extensions did not match the patterns of our gran metric.or re de nitions of feature constants.
these extensions can be realized by spl implementation techniques such as aspects or feature modules in which the introduction of functions or types is supported .
beneath the global level the second largest set of extensions occur at the function and block level fl and bl metric and enclosings e.g.
an if block or a statement inside a function.
both extension types are harder to apply because extensions can appear at every point of a function and not all proposed techniques provide particular patterns for matching them.
the most promising spl implementation technique is the aspect which enables extensions beneath the function or type level by addressing particular extension points.
however the data do not reveal whether an implementation technique is applicable and workarounds for refactorings using either feature modules or aspects may be necessary .
.
which types of the extension occur?
our data reveal that of the extensions are heterogeneous het metric .
homogeneous extensions hom metric add up to and the combination of both extension types heho metric makes up to .
aspects are well known for their ability to implement homogeneous extensions .
we observed that of the extensions would bene t from aspects would su ce with simpler mechanisms such as mixins or feature modules for the rest of the extensions a combination of aspects and feature modules would be pro table .
the data coincide with an analysis conducted by apel which revealed that most extensions are heterogeneous.
apel analyzed the use of aspectj rather than cpp but the results are similar.
threats to validity limitation to a single language.
programming languages provide di erent mechanisms for the implementation of spls.
for example c provides template metaprogramming which can replace most cpp macros for spl implementations .
we limit our analysis to c to make the results of the analyzed software systems comparable.
a nofc correlation coefficient .
sd b nofc correlation coefficient .
td .
.
.
c nofc correlation coefficient .
andfigure a plot nofc sd b plot nofc td c plot nofc and selection of the software systems.
a major problem with case studies is the selection of the objects of study because a biased selection can render the results useless.
we are aware of this problem to minimize it we selected a large number of software systems of di erent domains for our analysis.
source code.
di erent coding conventions used in software systems may lead to wrong conclusions.
for this reason we preprocessed the analyzed software systems by eliminating comments empty lines and include guards and by applying source code pretty printing.
feature detection.
our analysis is limited to the source code and to ifdefs .
but the representation selection and implementation of features is not limited to ifdefs .
additional con guration layers like con guration scripts or tools are also used in spl engineering.
a comprehensive analysis of these con guration layers is out of scope.
our focus on the source code coincides with the programmer s point of view in feature implementation.
we expect the amount of con gurable source code to increase when we include the additional con guration layers.
this traces back to the selection of les modules etc.
high level and low level features.
an automated analysis of the source code cannot distinguish well between highand low level features.
high level features represent requirements of stakeholders whereas low level features re ect design decisions made by programmers e.g.
tracing or portability issues like di erent types of signed integers for di erent compilers or platforms which are not of interest to most stakeholders .
making this distinction is not possible without additional expertise regarding the software systems and the domains.
here we are not interested in it because we are only looking at the usage of cpp s variability mechanisms at the implementation level.
feature expression equality.
we use string comparison to check the equality of di erent feature expressions to determine which code fragments belong to the same expression.
our analysis misses the semantic equivalence of feature expressions like a b and b a .
however we found that these occur rarely in the spls analyzed.
in a random inspection of smaller spls we found the error for notconsidering the equivalence to be below .
.
heterogeneous and homogeneous extensions.
the classi cation of extensions into heterogeneous and homogeneous is common in the software engineering literature .
our tool distinguishes heterogeneous from homogeneous source code fragments by string comparison.
thus character based syntactic changes in the source code are not classi ed correctly.
the additional information we gather on the ast does not help here because semantically equivalent source code fragments can di er in syntax and are thus not recognized by a comparison of subtrees of the ast.
the problem is even more serious because arbitrary extensions that destroy the source code structure are possible with the preprocessor.
generally the problem is related to the determination of code clones .
however to our knowledge there is no code clone detection tool capable of comparing arbitrary source code fragments for equality.
a combination of our analysis tool with code clone detection tools may lead to more precise results.
we expect a higher number of homogeneous extensions.
our measurement marks a lower bound of homogeneous extensions.
mapping of ifdefs to ast elements.
for creating an ast and mapping ifdefs to ast elements we rely on the tool src2srcml.
especially the gran and type metrics rely heavily on the correctness of this mapping.
the authors of src2srcml use an extensive test suite to verify the relation of ifdefs and source code in the xml representation.
.
perspective our analysis provides a substantial amount of data that is valuable for further research on language design and tool support.
the data are a basis for discussions on the feasibility of implementation techniques for implementing 10the problem arises from checking the equality of predicates a problem which is in the class of np problems.
we used the tool maple to check the equivalence of feature expressions in some smaller spl.
the equality check takes hours even for a small software system and the equivalence check of a large software system such as the linux kernel would take an estimated time of years.
7spls and valuable input for language designers and tool writers.
nevertheless while performing the analysis several issues came up which we plan to address in further research.
although we selected a large number of software systems covering a variety of domains we cannot infer valuable information on cpp usage regarding a speci c domain because the number of systems for each domain is too small.
however we believe that the usage of cpp s variability mechanisms is not just a question of program size but also of the domain.
for example the variability of operating systems e.g.
driver implementations to support di erent hardware platforms may be di erent than in a web server.
our results reveal that the web servers analyzed are more variable in terms of con guration parameters nofc metric and source code lof metric than the operating systems analyzed but the sample is too small to draw a general conclusion.
we plan to investigate particular domains in isolation in terms of comprehension and refactoring and to look for di erences and similarities to the case study presented here.
our analysis covers only one speci c release of each software system.
we believe that gathering data of a software system over time reveals interesting insights into its adaptation and evolution.
these may involve the support of a new platform a new functionality or the adaptation to structural changes.
to this end we plan to apply cppstats also to consecutive versions of a software system to contribute to the ndings of previous work .
finally based on the granularity and homogeneous heterogeneous metrics we plan to explore the possibility of automated refactorings of ifdefs .
to this end we look for patterns of cpp based extensions and map them to alternative spl implementation techniques.
our goal is to provide tool support to programmers with suggestions on possible refactorings in legacy applications .
.
related work the cpp tool has been the subject of several papers in the past.
we group them according to program comprehension and refactoring and discuss the relation to our work.
comprehension the most comprehensive analysis of the cpp tool was conducted by ernst et al.
.
the authors presented results of an analysis covering mainly the facilities and possible pitfalls of macro expansion.
we complement their case study with detailed information about variability implementation.
krone and snelting proposed a tool that extracts ifdefs from software systems to compute the con guration structure .
the tool covers only the coupling of feature constants it neglects the implementation part feature code in terms of homogeneity and granularity.
favre covered cpp usage in software development from a general point of view without looking at it empirically .
refactoring adams et al.
proposed a set of patterns for refactorings of ifdefs into aspects .
the authors tested their approach on one software system.
other researchers also addressed the use of aspects for refactoring .
our metrics enable a discussion of di erent spl implementation techniques for refactorings.
furthermore we provide data obtained from several software systems which provides a more realistic view of cpp s usage.k astner et al.
raised questions of granularity at a theoretical level .
the authors could not draw conclusions on the necessity of certain implementation techniques.
our work contributes to this discussion.
there is a signi cant amount of work on cpp aware refactorings .
this work aims at refactorings within c programs.
in contrast our analysis provides data for discussions on the applicability of other spl implementation techniques such as aspects or feature modules to replace ifdefs .
.
conclusion we presented a comprehensive analysis of variability mechanisms usage of conditional inclusion ifdefs of the preprocessor cpp.
we highlighted the connection between the capabilities of cpp and the concepts of spl engineering.
to this end we formulated four research questions regarding the variability of software systems in general the complexity granularity and types of extension.
we proposed a set of metrics for answering these questions and analyzed forty publically available open source software systems with more than thirty million lines of code.
we found that cpp s mechanisms are used frequently for implementing source code that is optional or incremental as it occurs in spls on the average of the code base in a project is variable .
furthermore we observed that the complexity of these extensions is independent of the size of the software system.
another result is that most extensions occur at a high level of granularity programmers use ifdefs mostly to enframe functions or entire blocks such as ifstatements or for loops .
this is promising especially when considering refactorings using alternative spl implementation techniques such as aspects or feature modules that provide similar mechanisms for implementing such variabilities.
finally we found that most extensions are heterogeneous and consequently that the quanti cation mechanisms of aspect oriented languages are not needed frequently.
the data we have collected can serve as input for the research area on language design and tool support and may permit answers to further questions on spl engineering.