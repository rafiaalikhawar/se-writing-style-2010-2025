drag and drop refactoring intuitive and efficient program transformation yun young lee nicholas chen ralph e. johnson university of illinois at urbana champaign urbana il usa flee467 nchen rjohnson g illinois.edu abstract refactoring is a disciplined technique for restructuring code to improve its readability and maintainability.
almost all modern integrated development environments ides offer builtin support for automated refactoring tools.
however the user interface for refactoring tools has remained largely unchanged from the menu and dialog approach introduced in the smalltalk refactoring browser the first automated refactoring tool more than a decade ago.
as the number of supported refactorings and their options increase invoking and configuring these tools through the traditional methods have become increasingly unintuitive and inefficient .
the contribution of this paper is a novel approach that eliminates the use of menus and dialogs altogether.
we streamline the invocation and configuration process through direct manipulation of program elements via drag and drop.
we implemented and evaluated this approach in our tool dragand drop refactoring dndrefactoring which supports up to of refactorings in the eclipse ide.
empirical evaluation through surveys and controlled user studies demonstrates that our approach is intuitive more efficient and less error prone compared to traditional methods available in ides today.
our results bolster the need for researchers and tool developers to rethink the design of future refactoring tools.
i. i ntroduction refactoring is a disciplined technique for restructuring an existing body of code altering its internal structure without changing its external behavior .
the concept of refactoring has been studied and improved since it was first introduced by opdyke and johnson in and is now a wellaccepted programming practice.
almost all popular ides such as eclipse intellij netbeans visual studio and xcode include support for automated refactoring tools.
though no ide supports all refactorings that fowler cataloged in his book the number of refactorings that ides support has only been increasing.
for example eclipse as of supported refactorings but the most recent version of eclipse version .
contains refactorings for java.
the current version of netbeans supports refactorings and intellij supports more than refactorings.
as automated refactoring tools become more mainstream there has been much research analyzing their usage patterns.
murphy hill et al.
analyzed eclipse refactoring tool usage and concluded that almost of refactorings are performed manually without the help of the tool .
our prior work concluded that programmers on average are aware of only eight refactorings in eclipse .
these numbers are discouraging and suggest that refactoring tools are used infrequently.
oneof the main causes behind their disuse is that the current tools suffer from deep usability problems.
prior research identified at least three dominant usability problems when using automated refactoring tools .
first programmers have trouble identifying opportunities for using the tool.
second programmers have difficulty invoking the right refactoring from a lengthy menu of available refactorings.
programmers often find the names and the position of the refactorings in the menu confusing.
third programmers find configuring the refactoring dialog complicated.
configuration dialogs disrupt the programming workflow and impose an overhead by requiring the programmer to understand the options.
our prior work estimates that programmers frequently spend up to eight seconds on the dialogs .
we term the second and third problems the invocation and configuration problems respectively section ii a .
indeed in our own user study we have observed multiple instances where programmers struggle with these very problems confirming their prevalence and severity section v b2 .
we argue that the invocation and configuration problems stem from the overreliance on menus and dialogs in current refactoring tools.
consider the following scenario.
once a programmer decides on a refactoring to perform she still has to complete two steps.
first to invoke the tool she has to navigate through a lengthy and confusing menu recall that eclipse netbeans and intellij support at least refactorings and select the appropriate refactoring.
she could memorize an elaborate keyboard shortcut but unless it is a refactoring that she frequently uses she is unlikely to do so only out of participants in our controlled user study used keyboard shortcuts .
second to configure it she has to interact with a dialog containing many detailed options that she might not require and only serve to distract her from her goals of users do not modify the default settings .
thus there exists a gapbetween what she wants to accomplish and how she needs to do it through the current user interface.
to bridge this gap we allow the programmer to directly manipulate program elements e.g.
variables expressions statements methods etc.
in the ide eliminating the need for menus or dialogs.
the programmer only needs to identify a program element to serve as the drag source and another program element to serve as the drop target .
for instance to perform an extract method refactoring the programmer would drag the selected expression source and drop it into the a before b before a after b afterfig.
.
drag and drop gestures in a java editor for extract method refactoring and b package explorer for extract type to new file refactoring.
enclosing class target figure 1a .
similarly to perform the move type to new file refactoring she would drag the inner class source and drop it into the desired package target figure 1b .
using drag and drop has two advantages.
first it eliminates the need to navigate through lengthy menus of refactorings.
second it eliminates the need for a separate configuration step.
through a single movement of selecting the appropriate source and target elements the programmer is able to both invoke and configure the desired refactoring.
our approach works for all move and extract based refactorings and our tool supports up to of the refactorings available in eclipse.
these also happen to be some of the most commonly invoked refactoring tools in eclipse .
our work makes the following contributions for improving the state of refactoring tools .
approach we introduce a novel refactoring invocation and configuration approach that relies on drag and drop of program elements.
this technique leverages the drag source and thedrop target of program elements to invoke and configure the refactoring in a single step.
the approach is generalizable to different refactorings and different programming languages.
.
mappings for our approach to work we needed to come up with a suitable set of mappings for drag sources and drop targets.
to make it more intuitive we derived the mappings based on the survey responses of participants.
tables i and ii detail the drag sources and drop targets for the supported refactorings.
the mappings serve as useful reference for future researchers and tool developers.
.
tool we implemented our approach using the mappings in our open source tool dndrefactoring for the eclipse ide.
dndrefactoring is supported i within a java editor or ii within and between package explorer and outline views.
the package explorer and outline views show a java element hierarchy tree of the java projects and source files.
we encourage readers to watch a demo of the tool in action at .
.
evaluation we evaluated our tool for its efficiency and usability.
to evaluate the efficiency and usability we con ducted a within group controlled user study where we asked participants to perform a non trivial refactoring task using both the existing eclipse tools and dndrefactoring.
our results show that dndrefactoring is not only intuitive but also increases invocation efficiency in terms of decreased configuration time and error rates compared to traditional refactoring tools which may in turn invite programmers to use the automated refactoring tools more frequently.
ii.
dndr efactoring a. design rationale the driving principle behind the design of dndrefactoring is to streamline the invocation and configuration mechanisms.
the current mechanisms as implemented in modern ides suffer from two problems .
invocation inconsistencies the dominant mechanism of invoking automated refactorings relies on identifying a refactoring by name and selecting it from a lengthy menu.
this mechanism has two shortcomings.
first the names are non standard .
for instance eclipse adheres to fowler s naming scheme for extract method whereas netbeans calls it introduce method.
second the grouping of refactorings in the menu is unpredictable both within an ide and across ides.
for instance eclipse places the rename and move refactoring in the same category although they are not closely related.
furthermore while eclipse groups extract superclass and together with pull up because they operate on class hierarchies intellij groups extract superclass with the other extract based refactorings and pull up in another category.
both these inconsistencies lead to a hunt and peck style of invoking a refactoring where the programmer has to spend time searching through the menu.
this problem was evident in our user study section v b2 and also corroborated by murphy hill et al.
.
.
configuration overload the dominant mechanism for configuration relies on dialogs.
this is a remnant from the design of the first automated refactoring tool for smalltalk .
as more complex refactorings were introduced more complicated configuration options were also made available.
how table i refactorings with drag and drop within a java editor .
drag source drop target refactoring local variable declaring type promote local variable to field ile1 expression inside methodsame method extract temp variable ile between argument brackets of current method signature introduce parameter declaring type extract method ile statements in method declaring type extract method ile non static methodfield variable in declaring type move instance method to field type argument type in current method signature move instance method to argument type static method of fieldanother type in current editor move member to target type field variable in declaring type move member to field type local variable type in declaring type move member to local variable type anonymous class declaring type convert anonymous to nested type 1ile in line edit allowed after refactoring is completed.
ever of refactoring tool users do not modify the default configuration .
thus these extra options serve only to confuse and prolong the configuration of refactorings since the user is tempted to read all the options.
moreover we have evidence from our controlled user study section v b1 that some of the options could be erroneously selected by the programmer and could lead to undesired changes to the code.
dndrefactoring solves both these problems.
because there isn t a universal naming and grouping of refactorings that everyone can agree upon we dispense with names altogether the drag source and drop target determines the refactoring to invoke and we do not burden the user with remembering names.
similarly we do not need dialogs because the drag source and drop target already serve as configuration options to the refactoring tool and we rely on sensible defaults where necessary.
our controlled user study suggests that these options are sufficient the participants are able to complete the tasks without using more complicated configuration options.
eclipse already provides a workaround for the configuration overload issue with quick assist which performs local refactorings with default values and then allows programmers to make changes.
our implementation of dndrefactoring in eclipse leverages the quick assist paradigm whenever possible relying on sensible default configurations.
one could argue that the dialog boxes provide more functionality than just configuration and that eliminating them could be problematic.
for instance the dialog boxes also offer a preview feature that shows the code changes to be performed.
however our prior work report that programmers use the preview feature infrequently and prefer to perform the refactoring and view the code changes directly in the editor.
if the user is unsatisfied with the changes she uses the undo feature to revert the refactoring.
b. tool features our implementation of dndrefactoring in eclipse allows programmers to invoke existing refactorings by drag and dropping program elements i within the java editor or ii within and between the package explorer and outline view.
the drag source is the highlighted selection either a text selection within a java editor or a tree node in the package explorer or outline view.
the drop target is identified by the position of the cursor when the drag source is dropped.
for example within a java editor a cursor located in a whitespace anywhere inside a class but outside any method and not in any field declaration will identify the target as the class figure 1a .
a refactoring is invoked based on the program element types of the drag source and drop target.
if no suitable refactoring is found the drag and drop gesture defaults to textual cut and paste.
tables i and ii list all the drag and drop refactorings that we have implemented for the eclipse ide.
to the best of our knowledge the mappings in the tables are newand serve as the first canonical set of drag and drop gestures for refactorings.
other mappings for the stated refactorings are possible but the current mappings were determined based on the survey responses section iv .
in addition to providing a new method of invocation and configuration dndrefactoring also supports two new and useful features that can only be accomplished through dragand drop gestures.
.
collated refactorings a single drag and drop gesture can effectively collate several refactorings together.
consider dragging a nested class and dropping it in the current package.
this gesture can be translated into move type to new file refactoring in eclipse.
what happens if the nested class was dropped in a different package?
naturally the extended gesture can be interpreted as move type to new file refactoring followed by move type to target package refactoring.
this collated refactoring is supported intuitively and effortlessly in a single drag and drop gesture using dndrefactoring.
such a simple collated refactoring is impossible to invoke using the existing invocation and configuration mechanisms in eclipse.
programmers using the traditional invocation mechanisms aretable ii refactorings with drag and drop within and between package explorer and outline view.
drag source drop target refactoring non static methodtype of field variable in declaring type move instance method to target field type type pull up push down or move method to target type nested type package move nested type to new file move type to target package anonymous typetype convert anonymous to nested type package convert anonymous to nested type move nested type to new file move type to target package field type pull up push down or move field to target type static membersanother type declared in current editor move members to target type type of field variable in declaring type move members to target field type type of local variable in declaring type move members to local variable type non static fields package extract data class move type to target package non static methods package extract interface static non static methods package extract super class forced to perform two separate refactorings in succession.
collated refactorings are annotated with in table ii.
.
precise control another advantage of drag and drop is the ability to precisely choose where a drag source is dropped.
for example extract method refactoring in eclipse always creates a new method below the method from which the expression or statements were extracted.
however with dndrefactoring programmers natural expectation would be to see the extracted method appear exactly where the expression was dropped figure 1a .
dndrefactoring supports such precise control and allows programmers to decide where to move or extract program elements.
c. supporting floss refactoring murphy hill and black introduced the term floss refactoring to describe refactorings that occur frequently in small steps intermingled with other kinds of program changes .
they also proposed five principles to characterize a tool that supports floss refactoring.
they suggest that such tools should let the programmer .
choose the desired refactoring quickly .
switch seamlessly between program editing and refactoring .
view and navigate the program code while using the tool .
avoid providing explicit configuration information and .
access all the other tools normally available in the development environment while using the refactoring tool.
current refactoring tool in eclipse violates all five principles .
the tools by murphy hill et al.
help programmers code selection process i with syntactic highlights ii by visualizing nested statements as a series of nested boxes and iii with control and data flow annotations .
while the tools were proven to help reduce time and errors during refactoring they violate principles and because the tools do not assist programmers with refactoring selection or configuration.
the same limitation applies to tools that alert programmers of code smells and opportunities for refactorings .
murphy hill et al.
introduced other tools that help with refactoring selection by mapping directional gestures to refactorings .
the tool displays a radial menu with four quadrants and maps directional gestures up down left or right quadrants to refactorings.
the tool adheres to principles and because the radial menu displays a more concise set of applicable refactorings and performs the selected refactoring without requiring explicit configuration from programmers.
however the radial menu is a modal window menu that covers up part of the java editor and thus violates principles and .
in contrast we claim that dndrefactoring satisfies all five principles.
dndrefactoring eliminates the need for programmers to browse through a long list of refactoring menu items and decode refactoring names that aren t always obvious therefore principle is satisfied.
in addition because programmers choose source and target program elements in the editors and views that they are currently working on principles and are satisfied.
dndrefactoring does not show modal windows during refactoring so it also adheres to principles .
lastly dndrefactoring also adheres to principle because it does not interrupt refactoring processes with pop up prompts but uses default values to complete the refactoring and then invites programmers to make in line changes.
iii.
e valuation methodology to measure the utility of dndrefactoring we ask and answer the following research questions rq1 how intuitive are the drag and drop gestures for users?
given that there is a large set of possible drag sources and drop targets that can be used to invoke each refactoring the main challenge is to build a set of mappings that is intuitive to most users.
to answer whether drag and drop gestures are intuitive we conducted a survey that asked participants unfamiliar with the drag and drop approach to suggest drag and drop gestures for randomly selected move and extract based refactorings public class foo public void bar ... system.out.println hello world!
system.out.println ... srcbazfoo.javafoo method1 void method2 void method3 voidpublic class foo private bar b new bar public void method1 ... a mapping from drag and drop to refactoring what refactoring would you expect to invoke with the following drag and drop gesture?
b mapping from refactoring to drag and drop how would you move foo.method1 to bar class?c mapping from refactoring to drag and drop how would you extract an interface to baz package with method1 and method2?fig.
.
examples of survey questions and to select refactorings given drag and drop gestures.
if the majority of users agree on the drag sources and drop targets for each refactoring it would strongly suggest that there is a set of drag and drop gestures that is universally applicable to all users section iv .
rq2 how efficient is it to invoke and configure drag and drop refactoring?
one of the main challenges of automated refactoring tools is the burden of invocation and configuration.
to answer whether drag and drop refactoring is efficient we implemented dndrefactoring an eclipse plug in that supports the set of gestures that we determined from rq1.
we then conducted a controlled user study comparing dndrefactoring to the default eclipse invocation and configuration mechanisms baseline .
participants were asked to complete a non trivial refactoring task using eclipse with and without dndrefactoring.
we recorded videos of these user study sessions and analyzed them to measure and compare the time taken to invoke and configure both tools.
if the results show that dndrefactoring is more efficient then it indicates that dndrefactoring could be compelling and complementary addition to the existing tools section v .
in addition we analyzed the physical effort involved in using the refactoring tools in terms of number of keyboard and mouse actions.
the paper omits this data for brevity but it is available at .
rq3 how usable is drag and drop refactoring?
a tool can be very efficient to invoke and configure and yet have very little users because of the difficulties involved in using the tool.
we wanted to identify the main challenges of using drag and drop refactoring compared to the default eclipse refactoring tools.
to answer this question we i asked the participants to provide feedback on dndrefactoring and ii analyzed the videos of the controlled user study that we captured as part of rq2 to identified obstacles each participant encountered when using both tools.
we then coded and merged those obstacles into key categories following the standard data analysis procedure for open ended survey responses .
by comparing the categories of obstacles identified in each tool we can objectively discuss the advantages and disadvantages of each tool and suggest room for improvement section v .
all survey and study materials and results are available at .iv.
e valuating intuitiveness a. survey design we conducted a survey asking participants to suggest dragand drop gestures for refactorings.
the survey contained five questions asking participants to suggest a refactoring given a drag and drop gesture and five questions asking the reverse mapping.
figure shows actual samples of the questions asked.
participants were given a minute summary of the study and were asked to complete the survey in minutes.
the survey was conducted in a graduate level software engineering class.
at least of the students have taken a prerequisite course in previous semesters that familiarizes them with java eclipse and refactoring.
all participants were new to the drag and drop approach.
the survey was completely voluntary and anonymous.
b. results and observations we collected survey responses in total.
of those participants participants indicated that they have more than years of java experience and participants have more than years of experience with eclipse.
also .
.
and .
participants regarded themselves as novice intermediate and expert users of the automated refactoring tools in eclipse respectively.
we manually coded the responses for each question into two main categories the majority the most common response and minority table iii .
on average of the responses formed the majority.
more specifically on average and of refactoring novice intermediate and expert users of eclipse refactoring tool agreed on a mapping respectively.
this result strongly suggests that there is a set of universal drag and drop gestures that is applicable for all users.
we analyzed all the responses in the majority category and found all of them to be feasible gestures for drag and drop.
we used these gestures to implement our tool dndrefactoring1.
to better understand the range of responses we divided the minority category into three sub categories alternate 1we implemented gestures for refactorings overall.
were based on the survey responses and the remaining two refactorings were conceived by the authors after the survey.table iii survey results by category .
each column name corresponds to the particular refactoring asked in the survey .
extract fieldmove nested to new fileextract methodextract temp variableintroduce parameterconvert anonymous to nestedpush downpull upmove methodextract interface majority .
.
.
.
.
.
.
.
.
alternate .
.
.
.
.
infeasible .
.
.
.
.
.
.
.
.
.
empty .
.
.
.
.
.
.
.
.
.
infeasible and empty.
the alternate category contains different but reasonable alternative refactorings that could be interpreted from the drag and drop gesture.
for example for a question depicting extract method refactoring by dragging a set of statements from inside a method and dropping it just above the method declaration figure 2a and table iii a surveyee answered static method for class foo .
these responses in the alternate group may be supported in future versions of dndrefactoring.
the infeasible category includes responses that either conflict with existing refactorings in eclipse are not refactorings or involve infeasible drag sources and drop targets.
lastly the empty category contains blank responses.
v. e valuating efficiency and usability a. controlled user study design we conducted a controlled user study with participants to evaluate the efficiency and usability of dndrefactoring on several refactoring tasks.
each participant carried out the refactoring tasks twice once using the default tools in eclipse and once using dndrefactoring.
the order of the tools was randomized to mitigate the learning effect.
each user study session was recorded in its entirety using either a screencasting software or a video camera.
to minimize unfamiliarity with different machines each participant used their own computer or laptop for the user study.
all participants were computer science graduate students majoring in various sub disciplines including software engineering and software testing.
all participants had at least years of experience in java participants had more than years of java experience.
the majority of participants had from to years of experience in eclipse.
and participants regarded themselves as novice intermediate and expert users of the eclipse refactoring tool respectively.
after the user study each participant was asked to complete a post study qualitative survey to evaluate their experience with dndrefactoring.
participation was strictly voluntary with no rewards offered and invitations to the study was sent through individual emails and departmental mailing lists.
the refactoring tasks given to the participants are based on the refactoring lab session exercise developed at lore .
the exercise involves multiple refactorings for a local area network simulation program.
the individual refactorings are small and independent thus are more like floss refactoring than root canal refactoring.
we made minor modificationsto the refactoring tasks in order to remove some duplicated refactorings and include a wider variety of refactorings.
prior to their individual user study sessions all participants were given a group tutorial on dndrefactoring and the official reference on eclipse s refactoring tool .
the dndrefactoring tutorial showed a short video demonstrating three refactorings none of which were repeated in the user study.
participants were encouraged to ask questions and to try using both tools on their own code.
we collected data for two metrics the configurations times quantitative and the obstacles encountered qualitative .
all measurements were done post user study from the video recordings so as not to affect the participant s performance on the tasks.
for eclipse s existing refactoring tool the configuration time starts from pressing the refactor menu item either in the tool bar or the mouse button menu and ends with pressing the finish button in pop up modal windows.
for quick assist we counted time from the moment the small options window showing to selecting one option.
lastly for drag and drop for dndrefactoring or existing simple refactoring support in eclipse the time was counted from when the programmer starts her selection to dropping the selection.
we define obstacles as programmers actions that are incorrect or unnecessary for invoking desired refactorings for example when a programmer selects a wrong refactoring cancels a refactoring invokes a refactoring with an irrelevant program element or when results do not match programmers expectations.
b. controlled user study results and observations efficiency table iv shows each participant s configuration times.
there was an outlying case where participant introduced a fault when using eclipse that caused a unit test to fail.
she attempted to fix the fault both manually and by using the refactoring tool and thus skewed the results.
we felt that while this case may give an insight to the complexity of current refactoring invocation mechanisms in eclipse it is not a fair representation of them.
therefore the data from participant was dropped from our following analysis.
overall dndrefactoring reduced the time spent on configuration by up to times.
on average participants performed the refactorings times faster with dndrefactoring compared to eclipse.
to validate that this result is statistically significant table iv results of the controlled user study1 configuration time in seconds .
refactoring extract methodmove method 12move method 22move method 32move method 42anon.
class to nestedmove type to new filemove class3extract classtotal partic 1eclipse .
.
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
miss .
2eclipse .
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
.
3eclipse .
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
.
4eclipse .
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
.
5eclipse .
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
6eclipse .
.
.
.
.
.
.
dndr .
.
.
.
.
7eclipse .
.
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
8eclipse .
.
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
9eclipse .
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
.
averageeclipse .
.
.
.
.
.
.
.
.
.
dndr .
.
.
.
.
.
.
.
ave. time save41.
.
.
.
.
.
.
.
1participant introduced a bug while refactoring with eclipse thus her data is not included in our analysis.
2not all participants performed these refactorings in the same order.
3time recorded for dndr is a collated time of anon.
class to nested move type to new file move class refactoring.
4calculated by dividing eclipse average by dndr average per refactoring.
we used the wilcoxon signed rank test wsrt to do a pairwise comparison between the configuration times for eclipse and dndrefactoring.
we used wsrt to i compare the total times for the entire study and ii compare the configuration times for each refactoring.
wsrt was used instead of the ttest because we cannot assume that the data configuration time is normally distributed.
participant did not complete the extract class refactoring so her data was excluded from the calculation of total time and extract class refactoring.
configuration times for all four move method refactorings were combined for simplicity and anonymous class to nested class move type to new file and move class refactorings for eclipse were also collated because the three refactorings can be performed as one refactoring with dndrefactoring.
the p values are reported in the following table all except extract method show statistical significance p .
.
total timeextract methodmove methodscollated refactoringsextract class p .
.
.
.
.004the results suggest that dndrefactoring is more efficient compared to eclipse except for extract method.
there are two possible explanations for the inefficiency with extract method refactoring.
first the method from which subjects were asked to drag an expression was particularly long and some found it difficult to drag the expression out of the method while having to scroll the editor.
second extract method is one of the most popular refactorings and as such many of the subjects may be familiar and efficient enough with its configuration details.
the error case of participant provided an insightful opportunity to observe how programmers may introduce bugs while interacting with eclipse s refactoring interfaces.
we were able to retrace and replay her refactoring actions by using eclipse s refactoring history and interviewing her after the user study.
the bug was introduced while she was moving a method from one class to another and when one of the