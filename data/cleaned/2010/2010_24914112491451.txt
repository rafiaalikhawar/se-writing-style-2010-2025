distributed program tracing diptikalyansaha ibmresearch india diptsaha ibm.in.compankajdhoolia ibmresearch india pdhoolia ibm.in.comgaurabpaul iitkharagpur india gpaul.tech gmail.com abstract dynamicprogramanalysistechniquesdependonaccurateprogram traces.
program instrumentation is commonly used to collect these traces which causes overhead to the program execution.
various techniqueshaveaddressedthisproblembyminimizingthenumber ofprobes witnessesusedtocollecttraces.
inthispaper wepresent a novel distributed trace collection framework wherein a program is executed multiple times with the same input for different sets of witnesses.
the partial traces such obtained are then merged to create the whole program trace.
such divide and conquer strategy enables parallel collection of partial traces thereby reducing the total time of collection.
the problem is particularly challenging as arbitrary distribution of witnesses cannot guarantee correct formation of traces.
we provide and prove a necessary and sufficient condition for distributing the witnesses which ensures correct formation of trace.
moreover we describe witness distribution strategies that are suitable for parallel collection.
we use the framework to collect traces of field sap abap programs using breakpoints as witnesses as instrumentation cannot be performed due to practicalconstraints.
tooptimizesuchcollection weextendball larus optimal edge based profiling algorithm to an optimal node based algorithm.
we demonstrate the effectiveness of the framework for collecting traces of sap abap programs.
categories and subject descriptors d. .
tracing f. .
semantics of programming languages program analysis general terms algorithms performance keywords parallel distributed programtracing pathcollection divideand conquer permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bearthisnoticeandthe fullcitationonthefirstpage.
tocopyotherwise to republish topostonserversortoredistributetolists requirespriorspecific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction in recent times many efficient and accurate path based analysis have been developed in the application areas of program comprehension debugging bug reproduction test case generation fault localization verification and more recently fault repair.
many analysis such as path differencing concolic evaluation dynamic tainting and dynamic slicing require exact program path whereas many compiler optimizations require path profiles.
because of its widespread usage partial and full trace collection problem is widelystudiedandefficientalgorithmshavebeendevelopedtoaddress the overhead of trace collection.
essentially there are three kinds of techniques for trace collection.instrumentationapproaches insert logging instructions in the source byte code binary representation of the program.kernel os level tracingtechniques store a log of kernel level events.in situ debuggingtechniques attach a separate debugger program to the target program and then allow interactive governance of the target program s execution by stepping through instructionbyinstruction orusingbreakpoints.
alltheseapproaches essentially inspect a subset of program s run time behaviors.
following ball larus we use the termwitnessto denote the set of entities in the static programs that are used to monitor their runtime behavior.
each such witness1can occur multiple times in the execution trace.
addition of witnesses to monitor program s run time behavior results into run time overhead during the execution of the targeted software.
for example liblit et al.
report an overhead ranging from to on various benchmarks profiling assertion invocations and in a study diep et al.
reported an overhead of to capture call chains .
lowering such overhead is particularlyimportantforprofilingsoftwareinthefieldwhereitcanhave a direct impact on the user.
existing works on trace collection present algorithms for optimizing the cost of trace collection by reducing the amount of witnesses or placing the witnesses in lower execution frequency code regions to reduce the overhead of collection.
in this context balllarus in their seminal work presented algorithms for minimalcost tracing problem.
their solution improved over the existing solutions of placing witnesses in all basic blocks and witnesses in conditional targets.
they provided an edge based solution which identifiesanoptimalsetofcontrolflowgraphedgestobewitnessed for trace collection.
an approach to reduce the overhead of profiling software is to leverage multiple variants of the same software running at several 1in the literature various terms such as logging instruction probe monitor and witness have been used to describe the static entities whoseoccurrencesareinspectedatrun timetoderivefullorpartial tracespermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
sites where each variant contains a subset of witnesses and where thesubsetsizecanbeboundedtomeettheoverheadtolerancelimits .
diep et al.
have considered the problem of distribution of witnesses across variants that maximizes the likelihood of capturingarepresentativepartoftheprogrambehaviorexercisedin the field.
these techniques have been used to obtain profile information that are order independent on various runs of the software.
for examples these techniques are not adequate to obtain a completeexecutionpathofaprogram whichcanbeusedindebugging field failures.
in this paper we introduce a novel framework for distributed trace collection which creates multiple sets of witnesses.
for each set of witnesses the program is executed with same input and partial trace is collected.
all partial traces are merged together to produce the trace of the program.
such a framework enables faster trace collection using parallelism as partial traces can be collected in parallel.
to our knowledge this is the first approach for parallel trace collection.
this work also addresses the problem of overhead of trace collection in the field production systems which do not allow instrumentation for trace collection.
instrumentation by a user agent to the production software can change the intended functionality of the software e.g.
heisenbugs or log sensitive information.
in these cases only a system provided utility may be permitted to debug the code.
the debugger may be used to automatically obtain the trace by setting breakpoints as witnesses and controlling logging the debugger events like breakpoint stops.
however automated breakpoint based collection is slow.
such a slow debuggerbased collection is seen in sap erp system for collecting abap program traces .
effective application of our framework for breakpointbasedtracecollectioninsap abapsystemrequiredto extend the ball larus s optimal edge based profiling algorithm to node based profiling.
thedistributedtracecollectionframeworkusesadivideandconquer strategy to collect the entire execution path.
the program is run multiple times each with a different set of witnesses.
we call thesetofwitnesses aprofile andthesetofalltheprofiles aprofile distribution.
for each profile an execution of the program generates a partial path.
we call a profile distributionrealizableif it is possible to reconstruct the execution path for all possible inputs by merging all the partial paths.
thechallengeofeffectivedistributedpathcollectionistwofold.
first an arbitrary distribution of witnesses into profiles does not guaranteeformationoftheexecutiontracebymergingpartialpaths.
therefore anecessaryandsufficientconditionforarealizableprofile distribution needs to be formulated.
second the objective of minimizing the collection time for entire execution path depends onoptimizingtheprofiledistributionfortheavailablemachinesfor parallel collection.
the techniques presented in this paper address the challenges discussed above.
the contributions of this paper are summarized below.
we introduce a novel distributed trace collection framework where the trace of a terminating program is collected using a divide and conquer strategy.
this is applicable for both instrumentation and debugger based trace collections.
we show that arbitrary distribution of witnesses edgebasedornode based doesnotguaranteerealizabledistribution section2 .
tosolvethisproblemweprovide anecessaryandsufficientconditionforarealizabledistribution.
this is in fact the basis of our framework section .
.b1 b2 b3 b4 b5entry exit22entry b1 b2 b5 b3 exit b4 b5 b1 b2 b5b2b1 b1entry b4 b3 exit figure example control flow graph with witness based on basic blockstrategyandpartialpaths.
bolddotsrepresentwitnesses.
we prove that optimal parallel distribution is an npcomplete problem by reducing the problem of multiprocessor scheduling problem.
we further discuss several strategies of forming profile distributions and provide a generic algorithm for profile distribution section4.
.
wealsoconsidertheprofiledistributionwhen each profile size is bounded.
we provide an algorithm to reconstruct an execution trace from the partial paths section .
.
we extend the ball larus solution for optimal edge based tracing problem to optimal node based tracing.
such a solution is particularly useful for breakpoint based path collection section .
we demonstrate the effectiveness of our solution for breakpoint based collection of traces for sap abap programs.
parallel trace collection reduces the entire collection time by3foldsincomparisontonon distributedtechniques section .
.
motivating examples we now illustrate the challenges of realizable and effective distributed trace collection with the help of some examples.
consideradistributionofthebasicblockprofile allbasicblocks contain witnesses of the control flow graph shown in figure .
theoverallsetofwitnesses entry b1 b2 b3 b4 b5 exit issufficient to observe the execution path.
now assume that a particular profile distribution is entry b1 b2 b5 b3 exit b4 and the respective partial paths observed for each execution are as shown in the figure.
in this execution the loop has executed twice and each time it has taken a different target of the conditionalb2.
however looking at the partial path traces it is not possible to determine the execution order ofb3andb4.
this example illustrates that arbitrary distribution of witnesses is not sufficient for whole path reconstruction.
notethattheproblemwitharbitrarydistributionillustratedinthe exampleoffigure1isnotduetothechoiceoftheinitialsetofwitnesses to distribute.
if instead of distributing the basic block based set of witnesses an optimized set of witnesses b3 b4 was distributed into two different profiles b3 b4 the partial traces would have been as shown in figure .
obviously in this case as well it is not possible to infer the execution order ofb3andb4by looking at the partial traces.
also note that another naive distribution strategy such as clubbingwitnessesbyfunctions togetherintoaprofile willalsoleadto181b1 b2 b3 b4 b5entry exit22b4 b3 b3 b4 figure example control flow with optimal witness profile and partial paths b2 b3 b4 b5b1entry exit22b4 c1 b4 c1entry exit2 c1 r1foo bar c12 22figure example icfg and partial paths the same problem.
in figure a functionbaris called at location c1infooand is returned atr1.
the two profiles in a distribution c1 b4 aresufficienttodisambiguatepathsconsideredatthe level of each function in isolation.
however the partial paths may not be merged to infer the execution order of theb3andb4while constructing the entire execution path.
in section we present the necessary and sufficient condition for realizable distribution.
a simple manifestation of such condition called function wise grouping strategy.
in this strategy each function is assigned to a profile.
the profile contains a set of witnesses that can determine all paths through the function.
this will prohibit intra procedural problems described in figures and .
additionally functionsthatcanbecalledmultipletimes haveextra witnesses in its profile to have at least one witness in each execution path from entry to exit.
for example in figure the function barcanhaveanotherwitnessatanynodeinadditiontob4tocover thepathfromentrytoexitthroughb3.
presenceofsuchawitness in the same witness set asb4guarantees to resolve the relative order ofb3andb4in inter procedural calls to functionbaras in the example of figure .
eventhoughtheabovestrategysolvestherealizabledistribution problem itmaynotbeeffectiveinallcasesforreducingtheoverall tracecollectiontime.
thetimeforparalleltracecollectiondepends on the maximum time taken by any machine.
the trace collection time in any machine is proportional to the number of witnesses hit intheactualrun.
thenumberofhitsdependsonthewitnesschoice and actual execution path for the run.
optimal tracing algorithms like ball larus approximate the behavior of the run by assigning frequencies or weights to edges or vertices of control flow graph.
such weightings can be obtained either by empirical measurement profiling or by estimation.
such profiling helps to put witnessesinlowerexecutionfrequencyarea.
thus inanymachine witnesses are chosen to minimize the sum of weights of the witnesses.
ball larus present an optimal edge witness based algorithm to minimize the total witness weight for each function discussed in detail in section .
the function wise grouping strategy is effective for optimizing the total witness weights for each function.
however for effective distribution across machines the total witness weight of all functions have to distributedevenly.
say if total witnessweightsoffunctionf1ismuchgreaterthanthatoffunction f2 the expected time for trace collection in the above strategy of function wise witness set formation will be dominated by the machine containing the witnesses of functionf1.
a more optimized strategy will distribute witnesses of both the functions across machines evenly without compromising realizability.
the necessary and sufficient realizability condition enables us to devise such a fine grained distribution strategy.
.
background .
notations we first present some useful notations and terms.
an interproceduralcontrolflowgraphicfg cfgs calle rete correspondingtoaprogramconsistsofasetofcontrolflowgraphs cfgs asetofinter proceduralcall calle edges andasetof return edges rete .
each control flow graph cfg incfgs corresponding to a single function is represented by a directed graphg v e entry exit wherevis the set of nodes that corresponds to the basic blocks in the function eis the set of directed edges between the nodes andentryandexitare two distinguished nodes inv.
a subset ofvarecallnodes.
each call node denotes a basic block with a call statement at the end.
an interprocedural call edge calle flows from a call node to the entry node of the called function and a return edge flows from exit node of the called function to the node containing the return location return node in the caller.
a distinguished cfg in cfgs corresponds to the cfg formain the starting function of the program.
in figure 3foo.c1is the call node foo.r1is the return node c1 bar.entry calle and bar.exit r1 rete.
we denotev wfor v w e calle reteand use v wto denote its transitive closure.
we assume that there exists at most one edge between two nodes.
we denotesucc u v u v and anodeuis aconditional predicate if succ u this denotes a basic block ending with a conditional statement .
we denote succ u 1ascond u true.
for a conditional nodeu each node insucc u is called the target or the successor of the conditional predicateu.
in figure b1andb2are conditional nodes.
we use the notationicfg.eto denote union of all the edges in cfgs inicfgand inter procedural call and return edges.
we useicfg.vto denote union of all nodes in cfgs of icfg.
aweightingwofanicfgassignsanon negativeintegervalues to every edge oficfg.esubject to kirchoff s flow law for each node exceptentryandexitof main and not called functions v the sum of the weights of the incoming edges is equal to thesumoftheweightsoftheoutgoingedges.
theweightofanode denoted aswt v icfg w is the sum of the weights of all its incomingedges.
thecostofasetofnodesisthesumofallweights of the nodes in the set.
a weighting is called abasic weightingif for each conditional all outgoing edges from the conditional have the same weight.
weight in an edge signify the expected number of times relative to other edges the edge is going to be executed.
typically such weighting is available from profiling.
the use of such weighting for optimal profiling is described in .182b1 b2 b3 b4 b6b7b5 b8 b9 b10 b11 exitentryb1 b2 b3 b4 b6b7b5 b8 b9 b10 b11 exitentryb1 b2 b3 b4 b6b7b5 b8 b9 b10 b11 exitentry a b c figure4 a allbasicblockprofile b conditiontargetprofile c optimal edge profile for basic weighting bold dots represent witnesses a pathp unless stated it is undirected can be denoted as a sequence of a nodes v ... vi vi ...vn such that for every verticesv i vi vi 1orvi vi.
a path is a cycle undirected ifv vn.
a cycle issimpleif all nodes in the cycle are distinct.
a path or cycle isdirectedif for everyv i vi vi .
a directed path is anexecutionof a function whenv 1is theentryof the function andv nis theexitof the function.
letu v wbe three consecutiveverticesinacycle.
thereisaforkatvifu v w ajoinatvifu v wandpipe u v woru v w otherwise.
a cycle ispipedif it contains atleast a pipe.
a piped cycle is adiamondif it has more than two distinct edges and containsexactlyoneforkandonejoin.
adiamondisnotnecessarilya simple cycle.
for example in the example shown in figure there are diamonds b2 b3 b5 b4 b2 b5 b6 b11 b10 b8 b7 b5 b5 b6 b11 b10 b9 b7 b5 b7 b8 b10 b9 b7 and cycles in the cfg.
a node based profile is a set of nodesvwit icfg.v.
similarly an edge based profile is a set of edgesewit icfg.e.
aprofile denoted aspr is either node based or edge based.
a collectionscorrespondingtoaprofileprandanexecutionpofa functioncanbedenotedbyasequenceofnodess b ... b n such that eachb j pris in the execution pathp andsis a subsequence ofp.
a profileprisrealizableiff it is possible to infer any pathpfrom a collectionscorresponding toprandp.
we call such an inference procedure as path reconstruction.
given a weightingwof anicfg the cost of a profile is defined as the cost of the set of elements either node edges in the profile.
.
realizable profiles node based realizable profiles.in the first simple strategy to obtain a realizable profile one breakpoint per basic block is set in the program i.e.vwit v and in the path reconstruction phase p s the collection itself.
a more efficient method to create a realizable profile is to include only targets of conditionals in the profile .
both the profiles corresponding to a single cfg are shown in figure a and b .
the black dots on nodes or edges represent the elements in the profile.
edge based realizable profiles.belowwedescribetheball larus solution to find optimal realizable edge based profile.
a path in cfggiswitness freewithrespecttoasetofedgesewitiffnoedge traversed in the path is inewit.
given an edgep qwherepis a conditional node in the cfggandqis its target thewitness set2 2weusetheterm witness set forabranchtargetwhereas witness set for set of witnesses.forconditionalptonodeqisasetofedgesewitness g ewit p q p q p q ewit x y x y ewit witness free pathp q ... x eof witness free pathp q ... exit .
a set of edges ewitis a realizable profile iff for each predicate panditssuccessorsq ... q n forallpairsq i qjwherei j the ewitness g ewit p q i ewitness g ewit p q j .
wecalltheabovetheorem thenecessaryandsufficientpathconditionfor a realizable edge profile.
intuitively each edge in ewitness g ewit p q can potentially be the first witness edge visited on a path fromp q ... exit.
if two successors have disjointwitnesssetsthenexistenceofawitnessintracefromeitherset determines which successor was taken after execution of the conditional.
the necessary and sufficient condition presented above is equivalent to the statement given below .
ewit is realizable iffe ewit contains no diamonds or directed cycles.
we call the above condition as necessary and sufficientcfg conditionfor edge based realizable profile.
although the above twoconditionsareequivalent thepath basedconditionisusefulin forming the path reconstruction algorithm whereas the cfg condition is essential in creating the witness profile.
informally the above realizability condition ensures thatewit breaksalldiamondsanddirectedcycles.
intuitively aprofilebreaks adiamondoradirectedcycleifitcontainssufficientwitnessessuch that it is possible to identify the path taken in the diamond or directed cycle.ewit breaksa diamond or directed cycle ifewit contains an edge in the diamond or in the directed cycle .
figure c shows an optimal edge profile for basic weighting.
all four diamonds and six directed cycles are broken by the given ewit.
optimally breaking the diamonds and directed cycles is an npcomplete problem .
however a spanning tree can break all the cycles diamonds and directed cycles are cycles in undirected sense in polynomial time.
edges not in such spanning tree of the cfg comprise realizableewitand moreover produces an optimal solution for a large class of cfgs.
.
distributed tracing in this section we first present a necessary and sufficient condition for realizable witness distribution.
then we discuss the algorithms for effective parallel distribution.
finally we present the trace reconstruction algorithm which forms the execution trace by merging the partial traces.
a profile distribution witd is a set of profiles.
based on the type of its constituent profiles a profile distribution can either be edge based ewitd or node based vwitd .
each constituent profile of a distribution is denoted bywitd i. given a profile distribution we refer to the trace collection corresponding to each one of its constituent profiles as apartial path.
our task is to construct the entire execution trace by merging all the partial paths.
a profile distribution is realizable if itis possibleto reconstructthe trace from the partial paths corresponding to its constituent profiles.
.
necessaryandsufficientconditionforrealizable distribution we first present the intuition for deriving the necessary and sufficientconditionforrealizablewitnessdistribution.
consideragain the example shown in figure .
the problem with this distribution is that it was not possible to associate the branchesb3andb4with theloopiterations.
wenoticethatsuchassociationofloopiteration 3in section it is shown that a node based profile will break a diamond if it contains a non fork non join node of the diamond.183withthebrancheshappensinarealizableprofile thatbreaksallcycles and diamonds in cfgs .
consider an alternative non disjoint breakpoint distribution b3 b2 b4 b2 .
in this distribution eachprofile breaksthe directedcycles andthe diamond and therefore realizable.
hence from this example we arrive at a conclusion that a distribution is realizable if all its constituent profiles break all diamonds and directed cycles.
next wediscusswhetherthisisanecessarycondition i.e.whether the above example imply that each profile of a realizable distribution needs to break all the diamonds and directed cycles?
to answer this question let us consider the example in figure with the distribution b3 b4 b5 b6 b8 b10 .
this distribution is realizable and each profile in the distribution individually breaks at least one diamond b5 b6 breaks two and all the directed cycles passing through it but not necessarily all the diamonds and cycles.
thus the answer to the above question is negative.
informally we derive that if a profile breaks a diamond then it hastobreakallthedirectedcyclespassing through it.
collectively all the profiles need to break all diamonds and all directed cycles.
based on the intuition built from the examples above we now formally present a cfg based necessary and sufficient condition for a realizable distribution.
theorem .a distribution is realizable iff the following conditions hold foreachdiamond thereexistsat leastoneprofilethatbreaks the diamond and breaks all the directed cycles if any that pass through the fork and branch targets of the diamond.
all diamonds are broken collectively by all the profiles.
all directed cycles are broken collectively by all the profiles.
the proof of this theorem is provided in .
we say a profile coversa diamond if the first condition is met by the profile.
the following theorem presents a path based necessary and sufficient condition for a realizable distribution which is equivalent to the cfg based condition presented above.
it does not matter whether the profile being distributed is edge based or node based.
fornode basedprofilesthedefinitionofwitness setcanbedefined in similar way as described in section .
a path in cfggis witness freewith respect to a set of nodesvwitiff no nodes traversed in the path is invwit.
given an edgep qwherepis a conditional node in the cfg thewitness setfor conditionalp to nodeqisvwitness g vwit p q q q vwit y y vwit witness freepathp q ... y eof witness freepath p q ... exit .
we use the notationwitness icfg wit p q togeneralizeewitnessandvwitness.
givenadistributionwitd a cfgg and an edgep qwherepis a conditional the set of all witnessesallwitness icfg witd p q forthedistribution is defined as the union of witnesseswitness icfg witd k p q of all the profiles in the distribution.
theorem .abreakpointdistributionisrealizableiffforeach predicatepand its targetsq ... q n for all pairs q i qj i j ifqi pandq j p then there must exists a profile witd msuch that the following conditions are met witness icfg witd m p qi witness icfg witd m p qj allwitness icfg witd p q i witness icfg witd m p qi allwitness icfg witd p q j witness icfg witd m p qj else allwitness icfg witd p q i allwitness icfg witd p q j note that for the predicatep when its targets can loop back to theconditional theabovetheoremassertsthatinsomeprofiletheir entirewitness setsmustexistandtheyaredisjoint.
thedisjointednesscriteriauniquelydetermineswhichconditionaltargetbetween qiandqjis taken after conditional.
the existence of their entire witness sets in one profile determines the association of the occurrence of the targets with the loop iterations.
if such condition is notmetthentherecanpotentiallybeacasewheretwopartial paths have two witnesses one each from the witness set of each target which occur in two different instances of a loop.
in this case it is not possible to associate which iteration executes which target a case seen in figure .
however for conditional target pairs where bothofthemdonotloopbacktotheconditional witnessesintheir disjointwitness setscanbedistributedacrossprofiles.
asanexample consider the predicateb1corresponding to the loop condition in figure .exitandb2are its two successors.
the successorexit doesn t have a path back tob2.
the witness sets for these may be distributed across profiles.
during path reconstructionb2should get precedence overexit as if it does occur it can only occur beforeexit.
.
effective parallel distribution satisfying the necessary and sufficient condition presented before many possible realizable profile distributions can be generated.
in this sub section various parallel distribution strategies are discussed.
moreover twocasesareconsidereddependingonwhether or not each constituent profile is bounded by a profile size.
our model of parallel distribution consists ofmidentical machines each having a static queue which can contain multiple profiles.
alltheprofilesaredistributedtothemachinesbeforeanyexecutionstarts.
eachcollectionisrunonthesameinput.
whenever a collection is complete in one machine a profile can be removed from its queue and run for collection in that machine.
the process stops when all the collections are done.
since collections in each machine is done sequentially the time taken by a machine is the sum of the times of all the collections performed in the machine.
thetracecollectiontime orcostofacollection isthemaximum of total times taken by each machine for its collections.
note that the collection time of a profile depends on the number of witness hits by the actual run.
the profile distribution algorithm approximates the number of witness hits in a profile by the total weight of the witnesses in the profile.
thuscost of a distributionis defined as the maximum of cost of distribution for each machine where costofdistributinginamachineisdefinedasthesumoftheprofile weightsinthemachine.
theprofileweightisdefinedasthesumof witness weights in the profile.
theoveralltimeofcollectionwillbeoptimizedifthemaximum time across all machines is minimized.
this suggests even distribution of witness weights across all machines for optimal parallel distribution.
however we found that such distribution is an npcomplete problem as stated in the below theorem theorem .the optimal parallel distribution problem is npcomplete.
theproofofthetheoremisavailablein .
followingthisresult profiledistributionalgorithmsusegreedyapproximationalgorithm presented in figure .
our second observation is informally stated as follows when there is no bound on the profile size then it is possible to combine all the profiles of one machine into a single profile such that the184total weight of the witnesses in the resultant single profile is no greater than the total weight of the witnesses of all the profiles.
weillustratethisusingtheexampleshowninfigure6.
arealizable distribution contains three profiles b3 b4 b6 b7 b9 b10 where each profile covers a distinct diamond.
if there aretwomachines i.e.m thenthedistributioncanbe b3 b4 b6 b7 and b9 b10 .
however the first machine can break the two diamonds by a single profile viz.
b3 b4 b6 with lesser costthanthetwoprofiles.
wecallsuchpairofdiamondsaswitnessoptimizablewhosecoveringbyasingleprofilerequireslesserweight witnesses than covering each diamond by individual profiles.
we summarize the important findings before describing the various distribution strategies.
foreffectivetimeforcollection eachmachinecontainsonly a single profile if the size of profile is unbounded.
combiningmultiplediamondsinthesameprofilecanreduce the total witness weights to cover the diamonds.
fine grained weight distribution facilitates even distribution of total weights across machines.
for example say units withweights1 and6aretobeoptimallydistributed to two machines.
if six jobs are formed each having a single unit then the chance of optimal distribution increases compared to the case where jobs are formed combining one or more than one units say for example forming three jobs likethis andthentryingtodistribute optimally between two machines.
we describe three strategies to distribute covering of all diamondsanddirectedcyclesofaprogramtomultiplemachines.
the threestrategiesessentiallydifferinformationofjob asreferredin figure .
a job is a set of diamonds and directed cycles withoutdiamonds which are definitely covered in the same machine.
theinterestingnatureofthisdistributionproblemisthatforming job by combining diamonds and directed cycles may form the job whose cost of optimal realizable profile is lesser than the sum of the profile weights to break the constituent diamond or directed cycle.
thus combination of multiple diamonds and directed cycles to cover in a single machine can be beneficial to reduce the job weight.
on the other hand increase in profile cost by combining jobs may pose as deterrent to even distribution of jobs across the machines.
in all three strategies diamonds and directed cycles from program s icfg are determined in the following way.
first all functions that can be potentially called multiple times are identified.
a functioncanpotentiallybecalledmultipletimesifthefunctionhas multiplecall sitesorcalledinsideacycle orcalledfromafunction which can be potentially called multiple times.
for these functions algorithm assignjobstomachine m j input a set of identical machines m m ... m m a set of jobsj j ... jn .
greedy m approximation for i to n do assign job ji to the machine with least current load update load of the machine that receives job j .
mk find least current load m assignjob m k ji figure algorithm greedy solution to multiprocessor scheduling problemb1 exitentry b5b2 b8 b11b3 b4 b7 b6 b9 b101 exitentry b1 b2b3 b4 b5 b6 b7 a b figure example cfgs for parallel distribution an edge is added between exit to entry to preserve realizability for their call sites an edge is added between call location to return location.
then for all functions diamonds and cycles are identified based on an undirected cycle detection algorithm for details refer to .
this strategy however cannot identify potentially witness optimizablediamondsbetweencallerandcalledfunctions.
such a case can arise if there exists a diamond at noder1in figure in which case it is not possible to cover the diamonds in two functions.
thefirststrategy calledfine graineddistributionstrategy forms each job as a single diamond or cycle without diamond.
thus preferring effectiveness of distribution over reducing weights through finding witness optimizable diamonds.
the second strategy mentioned in section asfunction wise grouping strategy forms each job by combining all diamonds and directed cycles without diamondofasinglefunction therebymaking sure that all witness optimizable diamonds in the function are covered in a single machine.
however this strategy even though fairly simple can have other diamonds in the same job which are not witness optimizable.
thethirdstrategyiscalledoptimized groupingwhichusesheuristics to find potentially witness optimizable diamonds and forms jobs by combining only such diamonds.
it follows the principle thattwodiamondsarepotentiallywitness optimizableiftheyshare the same cycle or if they share an edge between them.
the former case is illustrated in the example shown in figure a .
for the later case consider the cfg in figure b which has three diamonds b1 b2 b7 b6 b5 b3 b1 b1 b2 b7 b6 b4 b3 b1 and b3 b5 b6 b5 b3 whichshareedgesbetweenthem.
althoughbreaking of each diamond will require at least one witness but in the same profile all the three diamonds can be broken using two witnesses.
theoverallalgorithmforprofiledistributionforun boundedprofile size and edge witnesses is shown in figure .
in the first step jobs are identified based on one of the three grouping strategies.
using the greedy approximation algorithm each job is assigned to to the machine with least current load.
the assignment procedure re calculates the load of the assigned machine.
once a job is assigned to a machine recall that in unbounded case there is only one profile in the machine denoted bym k.profile it is possible to determine the optimal set of witnessesm k.profile.witnesses to cover all the diamonds and directed cycles without diamond by runningtheball larus optimaledge profilingalgorithmfromscratch.
such from scratch evaluation is not scalable when the number of jobs are large a case seen with the fine grained distribution strategy.
instead we devise an incremental algorithm to repeatedly re 185input icfgig weightingw a set ofm machines m m ... mm output m i wit algorithm step find all diamonds and directed cycles and create jobs based on strategies d find all diamonds inig c find all directed cycles inigthat do not pass through any diamonds ind j grouping strategy d c set of jobsj i initialize profile in machine for each machinem k mk.profile.witness m k.profile.ce ig.e assignjobstomachine m j assignjob m k ji if not bounded edgebasedincrementaladd2machine j i mk.profile mk.
load m k.profile.cost else .. edgebasedincrementaladd2machine j i p for each diamondd j i remove fromp.ceall edges ofd for each directed cyclec j i remove fromp.ceall edges ofc spanning graph computation add edges top.cet i l l no more cycle is created p.witnesses ig.e p.ce p.costis the sum of cost of edge weights in p.witnesses figure algorithm edge witness un bounded parallel distribution calculatewitnesssetswhileassigningjobstomachines.
withevery profilepwe keep a set of edgesp.cethat are the complement of witnesses edges in the profile.
we explain the algorithm using the exampleinfigure6 a .
inthefirststep threejobs eachcontaining a diamond is identified which need to be distributed to two machinesm 1andm .
profile.ce for each machine is initialized with all the edges in the cfg.
when a diamond with fork b2 is added tom1all edges of the diamond are removed fromm .profile.ce.
then edges are added till no more cycles are formed.
in this case it will add the edgesb2 b3andb2 b4.
the edges that are not added inm .profile.ce b3 b5 b4 b5 constitute its realizablewitnesssetwhichbreaksthediamond.
asimilarprocess runs when diamond with forkb5is added tom .
after that diamond with forkb8is added tom .
all its four edges are removed fromm .profile.ce.
thenthreeedgesofthediamondwithhigher weights b8 b9 b9 b11 andb8 b10 are added back to cewithout introducing any cycle to thece.
the complement edges ofce b3 b5 b4 b5 andb10 b11 form the witness for m1.profile.
the above three strategies can also be applied with modification in cases when profile size is bounded.
in this case each machine can have multiple profiles to run where the size of each profile is bounded by a limit.
we refer to this as the bounded parallel distribution problem.
we show that optimal bounded parallel distribution problem is np complete and then generalize it for all bounds .
the algorithm can be modified in function assignjobto divide the job into multiple profiles taking into consideration the latest profile in the machine with bounded size beforeaddingtoamachine.
theempiricalcomparisonofthethree strategies is described in section .input icfgg set of stackstconsisting of partial pathst i a mapm pc q i qj witd ksuch that cond pc true witdksatisfies the necessary and sufficient condition forq i qj pc output execution e algorithm pc entry g.main e pc do if notcond pc then newpc succ pc else if qm succ pc st. t i.peek witness g witd i pc qm q qm for eachq i succ pc q i qm qi pc witdk m pc q i q iftk.peek witness g witd k pc qi q qi else q succ pc s.t.
t i.ti.peek witness g witd i pc q qm pcdoes not exist newpc q for allt ks.t.t k.peek q tk.pop pc newpc e pc untilpc exit figure algorithm path reconstruction for realizable distribution b3entry b4b2 b1b0 exitb1 b3 b1 b2 b2 b3 exit b1 b2exit exit exit exitb3 b2b3 b1 b1 b2 b2 b1 b2 b2figure example cfg with partial paths at different stages of path reconstruction .
path reconstruction from partial paths wenowpresentanalgorithmtomergemultiplepartial pathscorresponding to a realizable distribution to derive the full execution path.
the algorithm is presented in figure .
the intuition of the algorithmfollowsfromthepathbasednecessaryandsufficientcondition for realizable distribution.
the illustration of the algorithm for an example is given in figure .
the actual execution path is entry b0 b3 b4 b0 b1 b4 b0 b2 b4 b0 exit .
the addition of nodesentryandb0is straightforward.
after this we try to find out which node occurred afterb0amongb1 b2andb3.
we first getqm b3 then compare againstb1.
the mapmrefers to the profile which is used to break the diamond with branch targetsq i andqjand forkpc.
the first partial path in the figure shows that b3is at the top thusb3definitely occurred beforeb1.
we proceed with the second comparison withb2.
the third partial path shows thatb3occurred beforeb2.
thus the next node executed isb3.
the partial paths are now adjusted by removingb3from the top.
the rest of the execution reconstruction is similar to this and omitted.
a 1entry exit2 2b2 b3 b41 1entry exit2 2b2 b3 b41 1entry exit2 b3b2 b c b1 b1 b1 figure examples where a source b target c source and target of optimal edge based profile do not yield realizable profile.
bold edges constitute optimal edge based profile.
bold nodes constitute the node based profile.
the algorithms described in this section are general to edgebased or node based distribution making it easily applicable towards breakpoint based and instrumentation based collection.
.
tracecollectionforabapprograms sap abap program are compiled into low level code and run byavirtualmachineinsidesapsystem.
sapsystemdoesnotprovide direct access to the low level code for instrumentation to the user programmer.
moreover sap abap practice does not allow programmer induced instrumentation of code in production systems.
itssafetyisnotconsideredatparwithtrustedstandardagents like sap compiler or debugger.
in general most production systems do not allow low level code instrumentation induced by user but do permit remote debugging.
here we present a technique for trace collection using code breakpoints inserted by sap debugger.
consider the necessary and sufficient condition for realizable profile distribution and parallel distribution strategies presented in theprevioussection.
thestrategiesdistributecoveringofdiamonds andbreakingofdirected cycles without diamondsintomultipleprofiles essentially breaking cycles and diamonds.
however there are many possible profiles that can break a given set of diamonds and cycles.
for example node based profiles like basic block and conditional targets described in section can be used.
for edgebasedprofiles ball larus solution alsodescribedinsection3 canbeusedtogetanoptimalprofiletobreakthediamondsandcycles.
however no such optimal algorithm exists for node based profiling.
breakpoint based solution requires such optimal nodebased profiles.
converting an optimal edge based realizable profile to an optimal node based profile is not straightforward.
it can be easily seen that for each edge in the edge based profile selecting any one of the source or target node of the edge or even selecting both the source and target may not in general lead to a realizable profile see figure .
below we present the realizability condition for node based profile theorem .vwit is a realizable nodes based profile iff vwit breaks all diamonds and directed cycles where a diamond is broken by vwit when there exists a node in vwit which is neither its fork nor join and a directed cycle is broken by vwit if it contains a node in vwit.
the proof of this theorem is available at .
the algorithm for optimal node based profile is shown in figure .
the optimal node based profiling algorithm has to consider the case of theget optimal profile input a job j output optimal realizable vwit algorithm step1 identification of fork join pairs msct for each diamonddinjwith forkfand joinj if f j add f j tomcst step2.
same as optimal ewit computation perform maximum spanning tree by adding edges tomcst.
ewit e mcstwhereeis all the edges inj step3 identification ofvwit for each edge src tgt ewit ifsrcis a fork node addtgttovwit elseiftgtis a join node addsrctovwit elseifsrc tgtare neither fork nor join add the node with minimum weight tovwit figure algorithm optimal vwit computation bench stmt basic block diamonds cycles s c h s c h s c h s c h order iinv imat inap r013 rls rv54 tcbl tccm wip zrep zrotc figure benchmark and test characteristics s is the number of entities in the program c is the total number of such entities covered by the trace and h is the number of hits of the entity specialdiamonds showninfigure10 c wherechoosingasource or target or both from an optimal edge based profile won t generate a realizable node based profile.
to break such diamonds the algorithm inserts its fork join edges in the tree in step prior to maximum spanning tree computation step such that these fork join edges do not belong to the resulting edge based profile complement ofmcst .
the step selects appropriate nodesbased profile from the edge based profile.
the optimality follows from the optimality of ball larus algorithm and minimum weight of source target nodes chosen in step .
.
experimental results in this section we compare the effectiveness of various distribution strategies of parallel trace collection for a set of abap programs.
the characteristics of the benchmark abap programs are shown in figure .
all these programs are real abap report programs in sap.
for each benchmark program a trace is collected.
the implementation of the algorithms is done in java and experiments are conducted on a laptop running windows xp and with dual core .53ghz cpu and 4gb ram.
for each program and its corresponding trace we find a profile and take an intersection of the path with the profile to determine the total number of hits.
of non distributed no.
of machinesorder iinv imat inap r013 rls rv54 tcbl tccm wip zrep zrotc figure reduction in cost of collection vs. machines 6fine grained function optimized 6fine grained function optimized a b 6fine grained function optimized 6fine grained function optimized c d figure cost of collection vs. machines for trace profile a inap b order and bl profile c zrotc d iinv thetracecollectiontimeisproportionaltothetotalnumberofhits with an average of .
seconds hit due to slow interaction between sapgui and server.
we use ball larus profiling algorithm referred to as blprofile for assigning weights to the nodes and edges.
we also consider a case where the profile weights are taken based on exact execution trace hereafter referred to as trace profile .
ourfirstexperimentstudieshowtheeffectivenessofparalleldistributionwithun boundedprofilesizevarieswiththeavailablemachinecountforthethreealgorithmsfordistributingjobsusingblprofile similar results for trace profile is available at .
figure shows the results.
each data point in the format a b is a pair consisting of cost of distribution a and the cost of collection b refer to section .
where both costs are defined as the maximum cost across all machines.
here is the summary of our observations.
cost of collection vs. machine.
in figure we present the variation of cost of collection with respect to number of machines.
for each benchmark we first obtain the cost of collection in one machine non distribution .
for each number of machine we take the minimumcostofcollection forvariousstrategies andtakeitsper bench order iinv imat inap r013 rls tcbl tccm rv54 wip zrep zrotc figure parallel distribution with bounded profile size cost of collection centage over non distributed cost of collection.
for benchmarks rls and inap the reductions are very small and for zrep there is absolutely no reduction.
in all these three cases the even distribution based on static information is not representative of trace hit distribution.
in all these benchmarks the traces hit the witnesses predominantly in one machine.
leaving these benchmarks the average percentage of hits are and for to machines respectively.
thus using machines the trace collection time reduces to less than .
comparisonof distributionstrategies.
tocomparethethreegrouping strategies we consider the profiling algorithms separately.
for the trace profile the profile cost distribution accurately reflects the hit distribution as well.
in this case we notice that optimized strategyisalwaysbetterthanthefunction wisegroupingstrategy however fine grained distribution generates minimum profile cost in half of the cases.
we show two cases where each strategy emerges as a winner in figure a and b .
in general we found that for benchmarkswithlessnumberoffunctionsshowbetterresultswith fine grained distribution.
this case is particularly noticeable in traceprofileswherefunctionsarenotexecutedandsothediamonds and directed cycles in those function have zero weights in effect thenumberofnon zeroweightfunctionsaresmaller.
thisisnotthe caseforbl profileastheassignmentofweightsaredonenotbased ontheactualtrace.
inbl profilecaseweseemorenumberofwinners for function wise grouping strategies and optimized grouping strategy.
the four winners of fine grained distribution strategy are rls r013 zrep and zrotc.
interesting to note that in all these case the benchmarks do not have any cycles see figure .
note that grouping strategies are more effective in reducing weights of profiles when multiple diamonds are in cycles as in figure a .
absenceofthecyclesmakesfine grainedstrategymoreeffectivethan thetwogrouping strategiesinthosefour cases.
weshow representative cases in figure c and d .
effect of bounded profile size.the figure shows the effectiveness of parallel distribution in terms of cost of collection with variation in the limit of witnesses in each profile.
the results are taken with three machines and with function wise grouping distribution strategy.
the aim of this experiment is to see how witnessoptimizable diamonds are distributed with increase in limit.
even though we show the result for various limits sap abap debugger limits the number of breakpoints in a debugging session to .
sincefunction wisegroupingstrategyisbettersuitableforkeeping potentialwitness optimizablediamondstogether theexperimentis done with this selection strategy.
we notice that with increase in limit in most cases the cost decreases with an exception in few cases.
we investigate these cases.
in these cases the diamonds in each cfg are not witness optimizable thus combining them increases the profile size and cost.188bench non distr.
fine grained function wise optimized order iinv imat inap r013 rls rv54 tcbl tccm wip zrep zrotc figure effectiveness of distribution strategies in form of cost of distribution cost of collection for bl profile .
related work path collection.program path collection has been an area of activeresearchinthesoftwareengineeringcommunityforquitelong particularly due to its importance in a wide variety of applications.
the theory of program tracing thus dates back to four decades.
rammoorthy et al.
gave a necessary and sufficient condition for edge based realizable profile for tracing single procedure programs.
they wanted to find a minimal size solution minimum number of edges to the tracing problem which was proven to be np complete .
incontrast ball larus intheirseminalwork presented an algorithm to solve minimal cost solution.
they reformulatedtheconditionpresentedbyrammoorthyetal.
andextendedittomulti procedurecase.
theirprogramtracingalgorithm provides an optimal edge based placement.
however this solution is applicable only for instrumentation based tracing as breakpoint based solution requires witnessing nodes and not edges.
breakpointbasedcollection.toourknowledge fewotherworks use breakpoints to gather path information.
in debugging time breakpoints set by the users not automatic are used to find whetherastatementisexecuted nottodeterminecompletepathas here .
thisinformationisusedtorefinestaticslices.
in breakpoints are put in the start of all basic blocks to obtain path.
all the other techniques use the instrumentation based approach.
one program many collections.techniques such as haveusedmultipletracesofthesameprogramtolocalizethebugs.
however theyuseddifferentfaultyandcorrectinputsforthesame program thereby collecting multiple different traces.
closest to our work is by palankar et al.
where order of data access is determined by merging multiple executions of the same program with the same input.
the division of executions were performed due to limited number of hardware assisted databreakpoints to watch data accesses.
however they do not try to obtain the exact order of data access and use heuristics like using information in the instruction counter to arrive at a solution whichisclosetoaccurate.
recentwork performsamergeoperation on partial calling context obtained using lightweight profiling.
however themergeoperationperformedthereisapproximate whichaimstocapturethecallingcontexttreewithhighprobability.
diep et al.
performed distribution of probes to multiple programvariants whereeachvariantcontainsasubsetofprobes where the subset size can be bounded to meet the overhead requirements.
theiraimwastoprofileasetofevents andnotgeneratingorderof events for a particular input.
softwaretomography splitsmonitoringtasksacrossmanyinstancesofthesoftware sothatpartialinformationmaybecollected fromusersbymeansoflight weightinstrumentationandmergedtogather the overall monitoring information.
even though the framework sounds similar it has been applied for merging profiling information and not for constructing any information which require respecting order of events.
boddenetal.
reducestheinstrumentationoverheadformatching tracematch policies regular expression with variables at runtimebydistributingwitnessesacrossseveralusercopies.
asmergingofinformationisnotrequiredacrosspartialtraces thedistribution only preserves the data flow required for sound but not complete satisfaction of the policy.
this is a different distribution criteria than ours.
.
conclusion inthispaperwehavepresentedanoveldivide and conquerbased trace collection technique in which partial traces may be collected andsubsequentlymergedtoproducethecompletetrace.
weshowed thatsuchadivisionoftracecollectionisanon trivialproblem and presented a necessary and sufficient condition to guarantee the recoveryofthewholepathbymergingthepartialtraces.
sincepartial collections may be done in parallel using a hadoop based framework the total time of trace collection is governed by the maximum total time of collection across machines.
this required even distribution of witnesses across machines.
we show the optimal distribution is an np complete problem and use the existing approximationsolutionstoeffectivelydistributethewitnesses.
toapply such a technique for breakpoint based collection we extended ball larus optimal edge based profile algorithm to a node based profile algorithm.
our work opens up other possibilities of parallel collection of elements where order of elements are of importance.
applying these techniques for obtaining call trace and order of data access can be fruitful.
we are investigating other uses of this framework such as multithreaded application using uniparallelism approach distributedruntimeverificationofpolicies andevaluating more dynamic scheduling strategies for parallel collection.
.