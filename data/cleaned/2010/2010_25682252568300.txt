exploring variability aware execution for testing plugin based web applications hung viet nguyen ecpe department iowa state university usachristian k stner school of computer science carnegie mellon university usatien n. nguyen ecpe department iowa state university usa abstract in plugin based systems plugin conflicts may occur when two or more plugins interfere with one another changing their expected behaviors.
it is highly challenging to detect plugin conflicts due to the exponential explosion of the combinations of plugins i.e.
configurations .
in this paper we address the challenge of executing a test case over many configurations.
leveraging the fact that many executions of a test are similar our variability aware execution runs common code once.
only when encountering values that are different depending on specific configurations will the execution split to run for each of them.
to evaluate the scalability of variability aware execution on a large real world setting we built a prototype php interpreter called varex and ran it on the popular wordpress blogging web application.
the results show that while plugin interactions exist there is a significant amount of sharing that allows variabilityaware execution to scale to 250configurations within seven minutes of running time.
during our study with varex we were able to detect two plugin conflicts one was recently reported on wordpress forum and another one was not previously discovered.
categories and subject descriptors d. .
testing and debugging general terms algorithms experimentation measurement keywords variability aware execution testing configurable code pluginbased web applications software product lines .
introduction a plugin is a software component that contributes functionality and adds features to an existing software application.
plugin based applications offer a variety of benefits such as allowing third party developers to extend an application and supporting easy addition and configuration of new features for different needs.
for these reasons permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
program with optional plugins with variability result for one plugin configurationresult for all plugin configurationsprogram with one concrete selection of pluginsconfigure program variability aware executionnormal execution extract results aggregate resultsfigure variability aware vs. brute force execution plugin based systems are becoming increasingly popular.
examples include the mozilla add ons framework for the firefox browser the add in extension mechanisms used in microsoft office the plugin architecture of the eclipse platform and the wordpress web blogging software .
plugin conflicts in such plugin based systems are not uncommon.
plugin conflicts arise in the cases where one plugin interferes with another plugin s behavior when they are used together even though both work as expected in isolation also known as the featureinteraction problem .
importantly one plugin may accidentally violate another plugin s assumptions or override or bypass its behavior by modifying shared state.
in fact the developers of wordpress have stated that plugin incompatibility is the top reason that people feel unwilling to upgrade to wordpress latest version .
plugin conflicts are notoriously hard to detect upfront.
plugin behavior is rarely fully or even formally specified making the approaches based on formal methods or requirements engineering used for detecting feature interactions in telecommunication systems rather hard to apply on large scale plugin based software like wordpress.
the developers could write test cases and execute them on individual plugin configurations to detect conflicts.
however executing the test cases for plugins is challenging due to the combinatorial explosion of the number of plugin configurations which in practice is often compensated only by manual and ad hoc approaches as reported for the eclipse project .
in this paper we tackle the challenge of executing a test case exhaustively over all configurations of a software product i.e.
all combinations of a set of plugins .
the key observation that allows us to scale such execution despite the exponential explosion is that many executions of a test are similar.
with a variability aware interpreter we execute common code only once and only when encountering a configuration option execute multiple branches with the respective configurations after which we continue to execute the rest again only once if possible.
conceptually we run a test case in all configurations without configuring the program first.
the result is equivalent to configuring the program in all configurations running the configurations in isolation and aggregating the results figure .permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm a wordpress source code simplified initialize wordpress include load.php ... load plugins plugins wp getactive plugins foreach plugins as plugin include plugin ... print scripts foreach wp scripts as script echo script type text javascript src script ... print content content wp getcontent foreach wp content lters as func content call user func array func content echo content b the smiley plugin wp enqueue script wp scripts jquery .
.js ... function convert smileys content f return content.
replace get smiley 4g wp content lters convert smileys c the weather plugin wp enqueue script wp scripts jquery .
.js ... function insert weather widget content f return content.
replace get weather widget 4g wp content lters insert weather widget figure simplified wordpress and two plugins the efficiency of variability aware interpretation depends on how variability is used in the application.
if plugins have local effects and do not interact it can be very efficient.
a few interactions slow down the execution since we need to compute with alternative values for some variables but still much sharing remains so that far fewer alternatives need to be explored than the brute force approach.
thus the feasibility of variability aware interpretation is mainly an empirical question prior work though promising has only investigated small or artificial cases see related work section .
we evaluate the feasibility of variability aware interpretation in a large scale practical setting executing a test case over wordpress with optional plugins.
we build varex a prototype variability aware interpreter for php to evaluate how variability from plugin activation affects test execution in wordpress and how plugins interact.
in our empirical study on real world plugins we found that nearly of executed statements and of variables values are shared among all plugin configurations.
we found plugins in wordpress are in fact mostly orthogonal or interact mostly in disciplined ways rendering our approach practical.
due to low interaction among plugins varex was able to cover 250possible configurations within seven minutes.
with these promising results we hope that in the long run variability aware execution will establish a scalable testing and analysis mechanism for configurable systems of different kinds.
the key contributions of this paper include a variability aware execution technique for running php plugin based web applications varex a prototype variability aware php interpreter and an empirical study showing the scalability of variability aware execution for testing configurable systems in a large real world scenario.
.
motiv ating example in this section by means of an example we illustrate potential conflicts in a plugin based system the challenges in detecting such plugin conflicts and the opportunities of sharing that we can exploit for variability aware execution.
a output with weather activated and smiley deactivated script type text javascript src jquery .
.js ... weather forecast div ...temperature f... div b output with both weather andsmiley activated script type text javascript src jquery .
.js ... weather forecast weather img src smile.gif figure conflict between weather andsmiley we selected the popular open source php based blog software wordpress as the subject of our study since it represents a typical plugin architecture with over available plugins and is broadly used on over million websites from basic blogs to largescale portals and enterprise websites .
it is well known for being prone to plugin conflicts .
it exhibits common plugin conflict characteristics as studied in other plugin systems .
wordpress is implemented as a classic framework to which plugins can contribute additional functionality by registering callback functions to various events following the observer and strategy design patterns or modifying shared global state.
for illustration we show a strongly simplified core of wordpress and two plugins in figure .
after initializing its own running environment line wordpress retrieves plugins in alphabetical order from a database line and initializes them by calling the php include function for every plugin lines .
plugins can register required javascript libraries through shared states wp scripts which are printed on lines as html script tags.
finally wordpress receives a blog post from the database and prints it after applying filters that plugins may have registered lines .
plugin conflicts.
plugin conflicts can arise when two or more plugins interfere with one another s behavior.
while some conflicts such as conflicting function names lead directly to crashes others manifest themselves silently and cause the page to display incorrectly.
in our simplified wordpress example in figure the plugins smiley andweather conflict the smiley plugin converts smiley codes within a blog post e.g.
into images whereas the weather plugin injects a weather widget in the post in addition both plugins use different versions of the same jquery library.
both plugins work well in isolation but produce unexpected results when combined as shown in figure .
as the first conflict plugin smiley replaces string in the tag before plugin weather can act resulting in unexpected output.
plugin smiley also includes a version of the jquery library older than needed by plugin weather resulting in runtime javascript errors.
in this example the plugin that is initialized first affects the behavior of the plugin that follows however in general a plugin can also invalidate the effects of the plugins that run before it.
worse platforms such as wordpress operate under an open world assumption where third parties can contribute plugins and not all plugins and contributors may be known.
that is plugin conflicts may occur late when a user actually combines two or more plugins possibly from different sources in the same environment.
it is unrealistic for developers to anticipate all interactions with other plugins.
challenges in testing for plugin conflicts.
plugin conflicts are notoriously hard to detect upfront.
they typically arise from incompatible assumptions inconsistent requirements conflicting goals overlapping preconditions e.g.
both plugins replace overlapping strings as in figure or conflicting postconditions e.g.
both expect different library versions .
beyond opportunistic and ad hoc testing of individual configurations developers could write simple test cases validating908all all all all s or w smiley context weather context weather context smiley context2 56smiley weather 1213smiley weather smiley weather smiley weather14 smiley weather smiley weather5 8load pluginsprint scriptsprint content init plugin config smiley inactive weather inactive smiley active weather inactive smiley inactive weather active smiley active weather active variability aware execution on all configs 2figure shared statements among the execution of different plugin configurations a test case for the weather plugin function testweather output runwebpage index.php execute the web page perform assertions on the output assertcontains output.getelementbyxpath html body div temperature assertequalsornewer output.get ... byxpath string script src jquery .
.js b expected test results assertion failed at testweather l4 if smiley weather.
assertion failed at testweather l5 if smiley weather.
figure example test case for the weather plugin their assumptions.
how to write such test cases is well established and common practice .
as an illustration in figure 4a we show a test case for the weather plugin querying the main page and checking whether the tag has been replaced correctly and whether the jquery library has an up to date version.
such a test can identify a plugin conflict when executed on a configuration with both the weather and the smiley plugins.
to detect conflicts with test cases early however the test cases need to be executed on individual plugin configurations.
every wordpress user can install and execute any combination of plugins in their system.
as more and more plugins are added the number of possible combinations of plugins grows exponentially .
with plugins the number already runs into the millions with more plugins brute force quickly becomes entirely infeasible.
therefore executing the tests on many configurations in the development phase is expensive.
sampling strategies e.g.
pairwise sampling can help to reduce the test effort but are intrinsically incomplete.
shipping test cases with the plugins delays test execution until a user actually combines plugins delays the detection and resolution of conflicts and shifts responsibilities to the users.
approach overview.
we tackle the challenge of executing a test case exhaustively over all configurations of a software product i.e.
all combinations of a closed set of plugins from a repository .
the key observation that allows us to scale such execution despite the exponential explosion is that many executions of a test are very similar.
for example independent of the configurations the entire framework initialization line in figure for our motivating example and the retrieval of the posts line is always the same.
plugins typically have local effects and rarely interact some plugins may not even affect the executed test case at all.
to highlight sharing in our example we illustrate the shared statements among the execution in four configurations in figure .for each configuration a sequence of boxes shows the line numbers of the statements in the main wordpress program figure that are executed.
the statements in the plugins source code are grouped together and denoted by smiley andweather respectively.
the boxes across different configurations are aligned vertically to reveal the shared code among them.
several statements marked with a dark background are shared among all four configurations.
the amount of shared code in the actual wordpress system would be even higher e.g.
the initialization step would include far more statements than just the statement on line .
leveraging such code sharing on the execution paths for different plugin configurations instead of running each configuration separately we develop a variability aware interpreter that executes the code for all configurations in a single run.
the variability aware interpreter executes common code only once and when encountering a configuration option it executes multiple branches with the respective configurations.
our interpreter is able to operate on a data representation capable of capturing alternative values of variables during executing all configurations.
as an illustration the single execution trace of the variability aware execution is shown at the bottom part of figure .
for each statement the interpreter keeps track of a variability context which describes which part of the configuration space it is executing.
for instance statements and are executed under the context that either smiley orweather is activated while statements and are executed for all configurations.
our variability aware interpreter executes all configurations once and yields results equivalent to brute force runs figure .
importantly since variables can have alternative values in different configurations the test case may fail in only parts of the configuration space pinpointing plugin conflicts to the problematic configurations.
for example the srcproperty of tag script in the example s output is jquery .
.js ifsmiley is activated and jquery .
.js otherwise.
thus the assertion on line of figure 4a would fail if and only if both smiley andweather were activated figure 4b .
.
v ariability a ware execution informally a regular execution for one program configuration can be viewed as a sequence of computations on data.
in contrast variability aware execution is a sequence of computations on multivalue data whose values may differ between configurations.
we introduce varex a php variability aware interpreter that performs computations on multi value data.
let us present its data representation and computations.
.
variability aware data representation let us first formulate important concepts.
then we explain varex s data representation and how its variability aware computation works.
foo plugincon goption foo plugincon goption x yields bar plugincon goption bar true i x is activated if foo content running else content welcome content str replace plugin foo content status if foo jj bar status plugins on echo content .
status figure a php program with variability definition c onfiguration option .a plugin configuration option for a plugin pis a boolean variable that assumes true if p is activated and false otherwise.
definition c onfiguration .aconfiguration is a specific assignment of boolean values to configuration options that specifies which plugins are activated.
definition p lugin based application .apluginbased application is a family of programs defined by the activation of plugins.
a configuration corresponds to a specific program.
definition c onfiguration space .aconfiguration space is the set of all possible configurations.
a configuration space for n plugins has 2nconfigurations.
definition v ariability context .a variability context is a subset of the configuration space.
we describe it with a propositional formula over configuration options which yields true for all configurations belonging to the variability context and false otherwise.
the formula representing a variability context is satisfiable iff the variability context contains at least one configuration.
for example variability context true contains all configurations variability context false contains none and the context foo bar describes the possibly very large set of configurations in which pluginfoois activated and plugin baris not activated while all other plugins can either be activated or not .
the concepts can be extended for non boolean configuration options with a finite domain.
in designing our variability aware data representation we aim to achieve two goals the representation should be able to represent a concrete value for every variable in every configuration and the representation should be so compact that the same value in multiple configurations are represented once instead of several times.
thus we partition the configuration space with variability contexts.
for all configurations inside a context a variable shares the same value.
to illustrate the sharing we show a simple php program with two plugins in figure .
the new example is simpler than the previous one for readability while still containing important php constructs that will be used to explain our ideas.
as shown in figure instead of keeping the values of content for all four configurations we partition the configuration space into two parts with contexts foo and foo and maintain one distinct value for each context.
specifically we manage data variability with an abstract data type called multivalue with two concrete subtypes .concretevalue aconcretevalue represents a concrete php value that does not depend on any configurations.
.choice achoice models two alternative multi values depending on a variability context.
choice f x y denotes that the value is xfor all configurations in the variability context fandyotherwise.plugin config value of content before line figure foo false bar false welcome foo true bar false running foo false bar true welcome foo true bar true running variability aware execution choice foo running welcome on all configs figure variability aware data representation to hierarchically partition the configuration space choices can be nested.
our representation roughly follows the choice calculus .
in our example we represent the two string values as choice foo concretevalue running concretevalue welcome last row in figure .
for readability we omit the concretevalue construct in the rest of the paper.
.
variability aware computation varex s computation is realized with the following ideas .
shared data.
varex aims to represent differences between configurations compactly.
it uses choices only for those variables whose values actually differ.
a choice between two equivalent values can be simplified choice f x x !x and a choice of similar objects can be compacted as one object with common values of the objects fields being factored out.
.
shared execution.
varex performs execution on shared code just once and splits the current variability context only when variability occurs in values e.g.
a read variable has multiple values or in the control flow e.g.
the condition of an ifstatement evaluates to different values .
varex shares execution as long as possible called late splitting see section .
.
.
after a split the next statements are executed in restricted variability contexts similar to path conditions in symbolic execution .
then the results from the computations in those variability contexts are aggregated again into one compact value and used for the next shared computations early merging .
the goal is to execute each statement under the largest possible variability context.
.
.
store and load operations on shared data as introduced above the value of variables may depend on the variability context.
by representing sharing with multivalue we can manage variables values compactly via a map from each variable s name to its corresponding multivalue line figure .
during execution varex maintains a current variability context f which can change as the execution explores different parts of the configuration space.
the two key operations storing and loading variables values are performed under a variability context fas follows.
first storing a value vto a variable lines figure means that the variable will have its assigned value vin context fand retain its previous value in other configurations.
therefore its new value is represented by a choice of the assigned value and its existing value line .
if a variable does not have a previous value we use a special unset symbol as in a regular php interpreter to indicate that the variable is uninitialized in some configurations.
helper function createchoice performs some simplifications of the representation lines .
second loading a variable s value in a given context f lines is done by finding values in the variable s multivalue that satisfy context fvia function extract lines .
it recursively extracts values from the two branches of a choice by eliminating branches unsatisfiable to f. compacting compound structures.
in php web applications the use of compound data structures such as objects and arrays is common.
while such data structures can be large differences often lie9101 map map maps variables names to values void storevariable string name multivalue value context f f oldvalue map.contains name ?
map unset newvalue createchoice f value oldvalue map newvalue 6g multivalue loadvariable string name context f f value map return extract value f g multivalue createchoice context f multivalue x multivalue y f if !satis able f return x if !satis able f return y if x y return x if x is object y is object compact choice of objects obj new object for f in x. elds y. elds do obj.
addfield f createchoice f x y return obj ... arrays are handled similarly to objects else return choice f x y g multivalue extract multivalue v context f f if v is choice w x y x extract x f w y extract y f w if !satis able f w return x else if !satis able f w return y else return createchoice w x y else return v g figure storing and loading variables only in individual fields.
thus instead of representing choices between objects we compactly represent a single object with choices in its fields.
for an object s fields we use the same storage representation used for variables.
when storing a value varex performs this compression recursively in the helper function createchoice lines figure .
the result is a compact representation of the original objects as illustrated below.
original value choice foo object x y object x y compacted value object x y choice foo since php arrays are also associative maps from keys to values similarly to the handling of objects varex compacts a choice of arrays as an array of choice elements.
.
.
splitting and merging of variability contexts in a regular program the result of a computation is always a concrete value.
for example the evaluation of the condition at an ifstatement returns either true orfalse deciding which branch to be run next.
in a variability aware execution however the result can be a multi value i.e.
its concrete value may depend on the configuration.
thus a variability aware computation may need to be executed on data under specific variability contexts e.g.
both branches of an ifstatement can be run under different contexts in which the condition evaluates to true andfalse respectively .
specifically when a computation encounters multi values the current variability context is split into subcontexts and the execution continues in those subcontexts .
the execution is sequential from one context to another.
since the subcontexts can in turn split in subcomputations splitting can take place multiple times before the original statement is entirely executed and the execution can proceed with the original context i.e.
the subcontexts are merged to form the original context .
splitting occurs on a control statement with a multi value condition resulting in execution in different branches or a computation e.g.
expression on multi values e.g.
a b multivalue execute ifstatement ifstmt context f f multivalue condvalue eval ifstmt .condexpr f context w whentrue condvalue if satis able f w execute ifstmt .thenbranch f w if ifstmt .haselsebranch and satis able f w execute ifstmt .elsebranch f w 8g context whentrue multivalue v f match v case concretevalue val if val return true else return false case choice f x y return f whentrue x f whentrue y g figure context splitting on a control statement causing the same computation to be executed multiple times in different variability contexts.
context splitting on a control statement.
since the value of the condition of a control statement e.g.
ifandwhile can be a multivalue varex first needs to determine the variability context win which the value is true using function whentrue in figure and the context in which the value is false w .
for an ifstatement given the current variability context f varex then runs the then and elsebranches in restricted variability contexts f wandf w respectively lines .
note that in an empty context i.e.
if the corresponding formula is not satisfiable the corresponding branch does not need to be executed.
after running both branches the execution continues with the original context f. figure demonstrates the execution with the splitting and merging of variability contexts for our running example of figure .
the boxes show snapshots of the variables values at different points in the execution unchanged values are abbreviated with .
executed statements the transitions between snapshots are annotated with line numbers and their corresponding variability contexts in brackets .
the graph on the right visualizes the splitting and merging of those contexts.
the execution is sequential from one context to another yet variable accesses take effect in only their respective contexts as explained in section .
.
.
the splitting at an ifstatement is illustrated by the first split from l3 tol7 .
other control statements e.g.
while are handled similarly to an ifstatement if the condition returns a multi value in which the true value exists in some context the loop will continue in that restricted context.
the body of a while may be repeatedly run in increasingly smaller variability contexts until the loop terminates also in the last configuration i.e.
the variability context is empty .
note that the loop bound is concrete but may depend on the configuration.
context splitting on a computation.
if values involved in a computation e.g.
the operands in expressions are multi values varex will execute the computation multiple times for individual concrete values represented by the multi values in their corresponding variability contexts.
in essence for unary operations we perform a map over all concrete values of a multi value.
for binary operations we map over all combinations of concrete values with their corresponding intersected variability contexts .
we sketch our algorithm in figure .
note that we compress the resulting value into a compact one with the createchoice function.
nevertheless binary operations may lead to a combinatorial explosion of concrete values with small variability contexts in the worst case.
finally n ary operations and function calls with multiple arguments can be handled similarly.
importantly although any computation with multi values can always be done by mapping over all alternative values varex defers this splitting if the computation itself can support multi values late splitting .
specifically for non native computations such as a call to a user defined function the execution continues without splitting911execution flow memory snapshots foo choice foo true false bar choice bar true false l3 if foo foo bar content choice foo running null l4 content running foo bar content choice foo running welcome l6 content welcome foo bar content retval choice foo running plugin foo null foo bar content retval choice foo running plugin foo welcome foo bar content status l8 status l7 str replace ... content l9 if foo bar foo bar content status choice foo bar plugins on l10 status plugins on l11 echo content .
status foo bar content status output concat choice foo running plugin foo welcome choice foo bar plugins on foo bar content choice foo running plugin foo welcome variability context l1 foo pluginconfigoption foo l2 bar pluginconfigoption bar l7 content str replace plugin foo content l7 str replace ... content l7 content str replace ... l1 l2 l3 l4 l6 l7 l7 l7 l7 l8 l9 l10 l11 split merge split merge no op figure variability aware execution for the code in figure at the call site since variability can be handled later inside the function s body.
for native php operations such as addition or logical conjunction and calls to native php functions e.g.
strpos we either extend the interpreter to enable the native construct itself to handle multi values or by default let the execution split the context using the algorithm in figure .
the splitting at a call to a native php function strreplace is illustrated at the upper l7 statement in figure .
.
.
evaluation rules let us summarize our evaluation rules for common php program constructs in table .
the current context fis initialized with the entire configuration space true .
r1 r6 .
variable reading writing and control statements are handled as explained in sections .
.
and .
.
.
r7.
rule r7handles control flow breaking statements e.g.
return break continue and exceptions.
within a block of statements when such instructions are encountered a controlflag variable will get a non nullvalue indicating that the remaining statements will not be executed.
in the case of an exception varex reports the current context fwhere the exception occurs.
since controlflag can be a multi value we use helper function whennull analogous to whentrue and continue the execution only in configurations with anullcontrol flag.
if a control flag is activated in all configurations i.e.
the remaining variability context is empty the execution stops for that block of statements.
execute a unary operation on a multi value multivalue execute op op multivalue v context f f match v case concretevalue val return executeconcrete op val f case choice w x y val1 execute op x f w val2 execute op y f w return createchoice w val1 val2 g execute a binary operation on two multi values multivalue execute op op multivalue a multivalue b context f f if a is choice a a1 a2 return createchoice a execute op a1 b f a execute op a2 b f a else if b is choice b b1 b2 return createchoice b execute op a b1 f b execute op a b2 f b else if a is concretevalue a and b is concretevalue b return executeconcrete op a b f g figure context splitting on a computation r8 r10 .
expressions and native function calls with potential multi values are handled as explained in section .
.
.
r11 r12 .
to make string concatenations with possible multivalues at echo print statements efficient varex uses a data type called concat which represents a concatenation of string values or multi values.
in r12 output is used for the output string.
for example the output value of the code in figure is shown in the snapshot box after l11in figure .
r13.
rule r13 supports testing of web applications using assert statements.
since the value of an asserted expression can be a multivalue varex collects all the contexts in which that value evaluates tofalse and reports those contexts.
.
.
implementation with the main goal of exploring the feasibility of variabilityaware execution in a large scale practical setting we extended the open source full scale php interpreter quercus written in java .
for specifying variability contexts and checking satisfiability we use typechef s library for propositional formulas with a javabdd backend .
we extended quercus type system to support multi values such that concrete values occurring in a regular execution still behave as expected.
however the interpreter now needs to handle operations involving multi values.
since rewriting all existing operations on regular values into variability aware operations on multi values at once is a daunting task we implemented them incrementally.
during execution we dynamically logged the code locations where operations on multi values were attempted but not yet supported.
we implemented variability aware alternatives for those operations until no further unsupported operations were logged.
limitations.
currently our interpreter implements variability in all operations needed in our evaluation but not for all of php s large api.
for instance we did not implement a variability aware version of function count determining the length of an array yet because it was never called on arrays of variable length in our system.
generally varex is limited regarding side effects outside the control of the interpreter e.g.
if a plugin writes to a file or makes a state changing request to a web server.
varex may execute the corresponding code multiple times under different variability contexts changing the behavior compared to brute force execution.
we did not address this issue yet because it was not relevant for our experiments.
there are many strategies to explore such as an abstraction layer for a variability aware file system or a mechanism to avoid joining after potentially uncontrolled side effects .912table evaluation rules php syntax evaluation rule in satisfiable context f eval e f r1.
v e storevariable v eval e f f r2.
v loadvariable v f r3.
v k e v loadvariable v f map getkeysvals v or v e map.storevariable k eval e f f r4.
v k v loadvariable v f map getkeysvals v or v map.loadvariable k f r5.
if e s w whentrue eval e f else s if sat f w execute s f w if sat f w execute s f w r6.
while e while true s f f whentrue eval e f if sat f execute s f else break r7.
s ... s n for i to n do controlflag execute s i f if controlflag is exception report f f f whennull controlflag if !sat f break r8.
e execute eval e f f r9.
e e2 execute eval e f eval e f f r10.
native func e i execute native func eval e i f r11.
e .
e2 concat eval e f eval e f r12.
echo e eval output output .
e f r13.
assert e c whentrue eval e f report f c correctness.
to ensure that our implementation is correct we compared varex s results with those of the execution of individual configurations following the schema in figure .
specifically we automated comparing the html output and all values in the heap at the end of the execution except for nondeterministic values such as the current time .
for plugins we performed this comparison against all configurations brute force .
for additional plugins we sampled the configuration space.
we executed the comparison for the test described in section and obtained equivalent results which gives us confidence in the correctness of varex.
.
testing framework with its variability aware execution technique varex provides a framework to run a test case in all possible plugin configurations.
the process consists of three steps .
initializing optional plugins.
in wordpress the activated plugins are stored in an array in which each value points to an activated plugin s path.
to make plugin activation optional we instrument that code and create an array in which all entries are optional each of them is guarded by its corresponding configuration option if plugincon goption smiley plugins smiley path if plugincon goption weather plugins weather path ... note that plugincon goption p yields choice p true false .
executing a test on a web page.
in general test cases can be written according to common practice for testing web applications without any further consideration for variability figure 4a .
varex then runs the test case.
in contrast to a regular execution in which the output is a concrete string value varex s variability aware execution typically returns a multi value representing the output values for all possible plugin configurations.
.
performing assertions and reporting test results.
assertions in the test case are checked against the possibly multi value output and may throw an exception only in specific variability contexts.
thus varex can report that the test succeeds for all configurations or pinpoint failed assertions to specific variability contexts out of which sample configurations can be generated with a sat solver .table excerpt of tested wordpress plugins contribution plugin name version files loc chars stmts jetpack .
.
types .
.
.
google analyticator .
.
.
wp photo album plus .
.
my calendar .
.
wp slimstat .
.
r. simple captcha .
wp facebox .
.
lazy load .
total size of plugins size of wordpress .
.
for example varex reports that the two assertions in figure 4a failed in variability context smiley weather as shown in figure 4b thereby indicating a conflict between smiley andweather plugins.
.
empirical study in this case study we want to assess the feasibility of variabilityaware execution in a large real world scenario.
specifically we aim at answering the following questions.
rq1 sharing and interaction among plugins.
the key idea that allows the variability aware execution technique to scale is to take advantage of the sharing among plugins.
thus we study the sharing and interactions among plugins from three different aspects the output computations and values of variables.
for each aspect we ask how many characters computations values are shared among all plugin configurations?
how many of them depend on one or more configuration options?
how often do plugins interact?
in addition we report all detected plugin conflicts.
rq2 scalability of variability aware execution.
how much time does it take to run varex in a large configuration space?
experiment setup .
to address our research questions we installed the wordpress system with a set of plugins of various domains and sizes.
we selected the most popular plugins as listed on wordpress website and plugins that are reported to have had conflicts with some other plugins to bias our selection slightly toward hard and interacting plugins .
table shows the sizes of the largest and smallest plugins in our set together with the size of wordpress shown in the last row.
the complete list of plugins is available on our website .
next we created a test case that generated the home page of wordpress with a single blog post and initialized optional plugins as described in section .
we then ran the test case with varex and collected data.
.
sharing and interactions of plugins rq1 .
.
sharing and interactions observed in output since the main purpose of a web application is to generate an html output we first report how plugin interactions manifest in this output.
in the multi value output produced by the execution we can derive a variability context ffor each character indicating the configurations in which it appears.
if the character is produced in variability context true it is shared by all configurations if it depends on two or more plugin configuration options appearing inf it indicates that the character has been produced through an interaction among the corresponding plugins.
we counted the distinct configuration options in each character s variability context and reported the aggregated numbers.
figure shows that around characters are shared by all configurations column and nearly characters depend on9138 50number of characters number of configuration options contributions of plugins my calendarwp photo album plusfigure variability in the program s output 50number of staetments number of configuration options contributions of plugins my calendar figure variability in computations exactly one configuration option column .
that is of the output either is common among all configurations or is contributed by plugins independently.
the pie chart and table detail the contribution exclusive to each plugin.
it shows that plugins my calendar andwp photo album plus contribute the most to the output they display a calendar widget and a photo slide show in the test web page.
some plugins out of plugins do not contribute to the main page s output at all.
a few fragments in the output are produced only if multiple plugins are combined with a maximum of plugins columns .
we found that most of those fragments are related to interactions in declaring javascript libraries since several different plugins register the same javascript libraries with wordpress as demonstrated in section .
for example plugin cardoza car will print a jquery script if plugins wp facebox fac and wp photo album plus wpp have not already done so.
therefore the following html fragment is displayed under variability context car fac wpp script ...jquery.js?ver .
.
script .
.
.
sharing and interactions in computations after studying the output we are interested in variability of internal computations.
we counted each executed statement and analyzed the corresponding variability context and aggregating results as for the output.
figure reports the sharing and interactions among executed statements.
as seen of the executed statements are shared among all configurations.
of them are specific to one plugin as further detailed in the pie chart and table .
all plugins are executed with my calendar contributing the most to the execution.
interactions among multiple plugins account for of the executed statements and involve a maximum of plugins.
the highest interaction involves plugins accessing the same wordpress filters to register callback functions.
another common interaction of plugins occurs in function getlocale of wordpress l28 function get locale f... l31 if isset locale l32 return apply lters locale locale among others plugins with ids adv all bet dis andgoo2 attempt to retrieve the locale of the system via getlocale in which the global variable locale is set if it was not set earlier.
thus when plugin google analytics for wordpress goo2 calls getlocale line is executed when goo2 is activated and locale is set i.e.
allnumber of variables depth0 option option options options optionsfigure variability in values logarithmic scale one of the other plugins is activated .
thus the variability context at line is goo2 adv all bet dis .
note that if we executed wordpress in a brute force fashion for all 250configurations we would execute statements in columns and each 250and249times respectively.
in contrast in a variabilityaware execution those statements are executed only once reducing execution effort significantly.
we also measured how often a computation in a statement is split into two or more subcomputations due to context splitting .
out of executed statements there are only such cases.
in of those cases the context is split into only two subcontexts.
in the following worst case the context is split into subcontexts wordpress .
.
wp includes post template.php l166 content apply lters the content content l167 content str replace gt content here the blog post content variable content is modified by different plugins that registered to contribute to the wordpress thecontent filter line .
unless some values can be merged the number of values of content doubles with every optional filter reaching alternative unique values in our case.
subsequently at line since strreplace is a native function call varex splits the current context into subcontexts and executes the call multiple times for concrete values of content .
conceptually the combinatorial explosion can be avoided by providing a variability aware implementation of strreplace that can handle multi value strings.
.
.
sharing and interactions in values to see plugin interactions in variables values we counted the number of configuration options that the value of a variable depends on.
a variable can be a compound structure object or array whose fields keys can in turn be other compound structures.
thus when measuring plugin interactions we take the nesting levels or depths of values into account.
specifically top level variables are at depth fields keys of a compound structure at depth kare treated as variables of depth k .
since a variable s value may change during the execution we take snapshots of variables values throughout the execution every executed statements and at the end totaling snapshots .
we record the maximum number of configuration options that each variable s value depends on during the execution.
figure shows that at all different depths with a maximum depth of most variables depend on zero or one configuration option.
overall .
of variables share the same value in all configurations and .
of them have values depending on only one configuration option column all .
we found that high degree interactions involving plugins are mostly associated with the variables named wp lter id which are incremented each time a plugin registers a wordpress filter.
since all plugins are optional its value varies depending on many configuration options.
sharing inside compound structures depth is beneficial if large objects differ only in individual fields.
to study the impact of the compact algorithm that enables this inner sharing section .
.
we additionally explored the size of the heap without this inner sharing.
for out of top level objects we would need to9140100200300400500 50execution time in seconds number of plugins va execution pairwise sampling wise s. wise s.figure running time with standard deviation store instead of fields whereas we could not even compute the size of top level objects without inner sharing due to a combinatorial explosion we waited more than an hour and stopped at about fields .
these results show that the compact algorithm significantly reduces the size of compound structures by exploiting the sharing inside them.
summary.
overall the data of our experiment shows that there exist some high degree plugin interactions which are hard to catch with random or combinatorial testing.
however we found that the interactions among plugins did not result in severe exponential explosions and that the interactions remain mostly local.
importantly there exists a significant amount of sharing in terms of computations and data values that motivates variability execution testing.
.
scalability rq2 to evaluate varex s scalability we measured the time for running variability aware execution with different numbers of plugins wallclock time .
for each number of plugins we selected random subsets from the set of plugins except for sets of size and which have only one possible selection.
we then ran varex on these subsets and reported average and standard deviation for sets of size and we ran it times each.
the experiment was carried out on a computer with intel core i5 .
ghz cpu and .
gb ram running windows bit and jvm bit with .
gb heap size.
we did not even attempt to measure brute force execution of configurations but can extrapolate a runtime of million years.
the results are plotted in figure .
the standard deviation is high due to the large differences in plugin size and complexity and the random selection of plugins.
as seen performance degrades with additional plugins due to additional code and interactions but there is no obvious exponential explosion.
the overhead for sat solving is negligible.
varex executes plugins in about one minute and all plugins covering 250configurations in less than seven minutes.
in comparison executing wordpress with the standard quercus interpreter took .
second without any plugins and .
seconds with all plugins activated excluding one conflicting plugin causing a crash which we discuss next .
in figure we additionally plot performance for combinatorial testing and brute force execution extrapolated based on theoretical bounds .
pairwise testing suffices with small sampling sets that can be executed very quickly.
larger sampling sets are expensive to compute but can still outperform variability aware execution to some degree.
however in contrast to variability aware execution all sampling strategies are necessarily incomplete.
computing n way samples for large n such as n as would be needed to guarantee covering all interactions that we detected approaches brute force effort as the sample will have to include at least 2nconfigurations.
.
anecdotal evidence of plugin conflicts although we did not explicitly search for plugin conflicts e.g.
by writing test cases as outlined in sections and we found twoplugin conflicts that provide anecdotal evidence of the potential of variability aware execution for testing.
case .
undefined function error caused by plugins contact form con and really simple captcha rea .
at the end of the variability aware execution on all plugins varex reported an exception occurring in the variability context con rea via rule r7in table indicating that a crash occurs at a call to an undefined function win iswritable in the cleanup function of rea when both plugins are activated.
examining the error we found that when con is also activated it is the only plugin that calls the cleanup function of rea.
this interaction causes rea to invoke the function win iswritable which leads to the crash because wordpress at version .
.
does not yet support it.
this error is also confirmed on wordpress website .
plugin rea really simple captcha really simple captcha.php line function cleanup ... f line ... win iswritable dir is writable dir ... plugin con contact form modules captcha.php line return wpcf7 captcha cleanup case .
accidental url overwriting between my calendar cal and wp to twitter wpt .
after executing all plugins and examining the program s multi value output we found that the text displaying an image url provided by the cal plugin is not a concrete value as expected instead it is achoice between two values depending on configuration optionwpt choice wpt ...plugins my calendar ...event.png ...plugins my calendar ...event.png .
that is the url does not have its expected value when wpt is activated together with cal.
this error occurred since the plugins accidentally used the same variable name wp plugin url.
when activated the wpt plugin overwrote a different value to the value that was assigned earlier by the cal plugin.
this error can be detected by running varex on a test case as in figure .
plugin cal my calendar my calendar.php line wp plugin url plugin dirurl file plugin wpt wp to twitter wp to twitter.php line wp plugin url plugins url .
threats to validity we focused engineering effort to support a single but large scale and real world system because we expect more insights into characteristics of real world systems than using diverse but smaller or synthetic benchmarks.
although we selected a broadly used system with a typical framework architecture and selected a relatively large set of difficult plugins popular plugins and plugins that are known to be conflicting our study was on only the main page of one system with a set of plugins written in php thus limiting external validity.
to cope with the large traces we had to rely on proxy metrics measuring statements as computations sampling snapshots of variable values which may threaten construct validity.
we counted distinct configuration options in formulas as proxy characterizing interactions most formulas do not contain disjunctions but for those that do we may report slightly higher numbers than interaction degree metrics used in combinatorial testing .
performance measurements are influenced by jit compilation and caching effects of the used sat solver as a consequence we reported only startup performance by restarting the jvm between every run.
.
related work variability aware execution was proposed at least three times independently in the last year.
we proposed variability aware915execution in a previous paper and experimented with a handwritten interpreter for the while language and toy examples and experienced the potential for orders of magnitude performance improvements over exhaustive brute force execution.
kim et al.
independently extended the interpreter of java pathfinder into a variability aware interpreter for java named shared execution .
they experimented with small academic product lines up to configurations and reported a possible speedup of up to compared to exhaustive brute force execution.
austin and flanagan s proposal of multiple facets use a form of variability aware execution for accurate dynamic information flow analysis instead of configuration options they consider different access rights as a reason for tracking alternative values .
they extended a metacircular javascript interpreter.
on a lines md5 encryption algorithm with up to configuration options they demonstrated significant speedups over a sequential brute force strategy.
although there are several technical differences among the approaches e.g.
whether to represent variability contexts with propositional formulas or sets whether and when to merge alternative values conceptually with regard to the strategies explained in section and implementation wise they are all similar.
all prior implementations changed a nonstandard interpreter which introduced significant interpretative overhead compared to the typical optimized execution environment and demonstrated speedups only on small examples.
the feasibility of these approaches depends on the characteristics of the executed program.
an important open question which we now addressed is whether such approach scales to alarge real world scenario .
our results show that testing pluginbased systems is a promising application that justifies a full fledged variability aware execution environment.
indelta execution tucek et al.
experimented with forking and merging two variants of an instrumented c program differing in a small patch.
however it is limited to differences between two program variants.
while they could gain moderate performance improvements variability aware execution excels in scenarios with many configurations.
symbolic execution .
variability aware execution is similar to dynamic symbolic execution and model checking but has both conceptual and technical differences.
the key conceptual difference is that varex operates on conditional concrete values instead of symbolic values.
in varex a variable may have different values in different configurations but all values are concrete .
configuration options can be viewed as symbolic but they are used only to map between concrete values and configurations.
in contrast to symbolic execution concrete values never intermix with symbolic ones and we have a clear notion of executing statements conditionally in a variability context.
notice how our plugincon goption in figures and assigns the concrete values trueand false depending on a configuration option v choice f true false .
in symbolic execution and model checking scalability to largescale systems remains a challenge .
reisner et al.
have used dynamic symbolic execution to entirely explore the configuration space of mid size java systems .
symbolic execution was expensive in their case requiring machine weeks for tests in three 10k line applications with less than configuration options each.
they do not exploit sharing beyond a common prefix of execution traces.
variability aware analysis .
variability aware execution has been inspired by recent work on static analysis of product lines .
a community of researchers has investigated how to perform type checking model checking data flow analysis and other analyses on multiple compile time configurations of a system at a time.
thiscommunity has explored how to represent and reason about partial but finite configuration spaces compactly with bdds or sat solvers as used in our variability contexts how to represent choices of structures and in complex structures .
for an overview of the field see a recent survey .
recently several empirical studies have shown that static analysis of product lines can scale to systems of the size of linux kernel over configuration options in million locs and can outperform some sampling strategies due to the high sharing among the configurations .
while these results are encouraging it was unclear whether they also translate to variability aware execution as due to control and data dependencies we expect more nonlocal effects and interactions among configurations than in type checking or data flow analysis.
our results confirm this expectation but also indicate that there is still significant sharing to exploit.
other testing strategies .
in product line testing and framework testing it is a common strategy to unit test components or plug ins in isolation while integration tests are often neglected or performed only for specific configurations.
testing product lines is still considered a rather immature area .
greiler et al.
suggest shipping test cases with plug ins and running them in the configured client system .
in essence this is a strategy that postpones tests of configurations until the configuration is actually used.
moreover combinatorial testing allows to compute a set of configurations that cover all combinations among all n sized sets of configuration options .
pairwise combinatorial testing is efficient to detect all interactions among all pairs of options but the sample size and effort to compute the sample quickly grows with larger n sample sets for n 5are challenging to compute our example would require n 16to guarantee full coverage of all actual interactions.
sampling does not need specialized execution environments and can be much faster as shown in figure but by its nature may miss configuration related paths.
other methods aim to reduce test cases or configurations via impact analysis .
kim et al.
and shi et al.
have explored static and dynamic analyses to avoid reexecutions of configurations that have exactly the same execution path .
they demonstrated in only one large industrial application and mostly small examples for unit tests with few configuration options.
in wordpress scenario however all plugins always influence the execution even if only because each plugin is initialized i.e.
such analysis could not exclude any configuration resulting in a brute force approach.
in several scenarios multiple program variants are executed in parallel for security reasons .
executions are synchronized but similarities among variants are not exploited.
.
conclusions variability aware execution has been proposed recently to improve performance over brute force execution for testing configurable systems however it has been demonstrated on only small examples.
in this paper we addressed the question of whether such an approach can scale to large real world scenarios.
running our variability aware php interpreter varex on the wordpress web application with 250configurations we found that there exists a significant amount of sharing across plugin configurations which allows varex to scale.
the results showed that developing variability aware execution environments for testing is a promising direction.
.