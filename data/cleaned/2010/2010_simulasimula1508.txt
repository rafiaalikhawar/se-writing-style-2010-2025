exploring the impact of inter smell relations on software maintainability an empirical study aiko yamashita simula research laboratory lysaker norway aiko simula.noleon moonen simula research laboratory lysaker norway leon.moonen computer.org abstract code smells are indicators of issues with source code quality that may hinder evolution.
while previous studies mainly focused on the effects of individual code smells on maintainability we conjecture that not only the individual code smells but also the interactions between code smells affect maintenance.
we empirically investigate the interactions amongst code smells and analyze how those interactions relate to maintenance problems.
professional developers were hired for a period of four weeks to implement change requests on four medium sized java systems with known smells.
on a daily basis we recorded what specific problems they faced and which artifacts were associated with them.
code smells were automatically detected in the premaintenance versions of the systems and analyzed using principal component analysis pca to identify patterns of co located code smells .
analysis of these factors with the observed maintenance problems revealed how smells that were co located in the same artifact interacted with each other and affected maintainability.
moreover we found that code smell interactions occurred across coupled artifacts with comparable negative effects as sameartifact co location.
we argue that future studies into the effects of code smells on maintainability should integrate dependency analysis in their process so that they can obtain a more complete understanding by including such coupled interactions .
index terms code smells bad smells inter smell relations smell interaction software maintenance software quality.
i. i ntroduction the presence of code smells indicates that there are issues with code quality such as understandability and changeability.
this can lead to a variety of maintenance problems including the introduction of faults .
beck and fowler described code smells and associated each of them with refactoring strategies that can be applied to counteract the potentially negative consequences of having these smells present in your source code .
however code smells are only indicators of potentially problematic code.
not all smells are equally harmful and some of them may not even be harmful in particular contexts.
in addition applying refactoring strategies implies a certain cost and risk e.g.
any changes made to the code may introduce unwanted side effects and could trigger faults in the system.
therefore we need to better understand the relationship between code smells and maintenance problems.
when analyzing the relation between individual code smells and maintainability we observed that several code smells tended to be present in the same artifact.
based on these observations we conjectured that interaction effects between co located smells i.e.
smells located in the same artifact canintensify problems caused by individual code smells or lead to additional unforeseen maintenance issues .
the notion of inter smell relations has only been brought to attention recently but the concept seems promising for understanding the nature and effects of code smells.
inter smell relations were introduced by pietrzak and walter to support more accurate detection of code smells.
an example inter smell relation they propose is plain support which is defined as follows ...smell b is supported by smell a if the existence of a implies with sufficiently high certainty the existence of b. b is then a companion smell of a and the program entities classes methods expressions etc.
burdened with a also suffer from b... while pietrzak et al.
introduced inter smell relations in the context of code smell detection we argue that this notion can also help to better understand how code smell interaction effects can cause problems for developers.
this paper reports on an empirical study that investigates interactions among twelve different code smells and how these interactions can lead to maintenance problems.
it is based on an industrial case study in which six professional software engineers were hired to maintain four medium sized java systems with equivalent functionality but dissimilar designs for a period of up to four weeks.
during that time they were asked to implement a number of change requests.
via interviews and think aloud sessions we recorded on a daily basis detailed reports about the maintenance problems that were faced and which artifacts were associated with them.
afterwards we used tools to automatically detect the code smells that were present in the original pre maintenance versions of the systems and applied principal component analysis pca to find out how code smells were co located i.e.
find clusters of smells present in the same artifact .
the reported problems were analyzed in detail to investigate how co located smells interacted with each other and how this interaction related to the problems experienced during maintenance.
in addition we found that interaction occurred between code smells distributed across coupled artifacts coupled smells hereafter and analyzed how this affected maintenance.
the remainder of this paper is structured as follows section presents the background and related work.
section describes the study design the systems under analysis and the maintenance tasks.
section presents and discusses the results.
section concludes and presents future work.
c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.682ii.
t heoretical background and related work a code smell is a suboptimal design choice that can degrade different aspects of code quality such as understandability and changeability and may also lead to the introduction of faults .
beck and fowler informally described code smells and associated them with refactoring strategies to improve the design.
in the last decade code smells have become an established concept for patterns or aspects of software design that may cause problems for further development and maintenance of these systems .
code smell analysis allows people to integrate both assessment and improvement into the software evolution process itself.
van emden and moonen provided the first formalization of code smell detection and developed an automated code smell detection tool for java.
m antyl a and wake proposed two initial taxonomies for code smells.
m antyl a investigated how developers identify and interpret code smells and how these methods compare to results from automatic detection tools.
examples of recent approaches for code smell detection can be found in .
automated detection has been implemented in commercial tools such as borland together1and incode2.
previous studies have empirically investigated the effects of individual code smells on different aspects related with maintainability such as defects effort and changes .
from these earlier empirical studies only the study by abbes et al.
has brought up the notion of interactions between code smells.
they conducted an experiment in which students and professionals were asked questions about the code in six open source systems oss .
the authors concluded that classes and methods identified as god classes and god methods had no effect on effort or quality of responses in isolation but when they appeared together they led to a statistically significant increase in response effort and a statistically significant decrease in the percentage of correct answers.
we believe that the explanatory and predictive power of code smells can be improved by considering and investigating inter related code smells rather than only focusing on the study of individual code smells.
this study attempted first to identify patterns of co located code smells via pca and subsequently explored the effects of interactions between code smells on the incidence of maintenance problems.
iii.
t heempirical study a. systems under analysis in simula research laboratory s software engineering department sent out a tender for the development of a webbased information system to keep track of their empirical studies and resulting scientific publications.
based on the submitted bids four norwegian consulting companies were hired to independently develop a version of the system using the same requirements and specifications.
more details on i size of the systems analyzed loc system a b c d loc no.
java files the original development projects can be found in .
the four development projects led to the creation of four systems with the same functionality.
we will refer to them as system a system b system c and system d. the systems were primarily developed in java and they all have similar threelayered architectures.
although the systems exhibit nearly identical functionality there were substantial differences in how they were designed and coded.
an overview of their size in lines of code loc and number of java files is shown in table i. the systems were all deployed over simula research laboratory s content management system cms which at that time was based on php and a relational database system.
the systems had to connect to the database in the cms to access data related to the research at simula research laboratory as well as information on the publications.
b. the maintenance tasks and the developers in simula research laboratory introduced a new cms called plone3 which interfered with the operation of the systems.
consequently it was necessary to modify the systems so they could operate in the new environment i.e.
an adaptive maintenance task was required .
in addition it was required to extend the systems with additional functionality.
two eastern european software companies were hired to do the maintenance tasks between september and december at a total cost of euros.
the maintenance tasks are briefly described in table ii and were completed by six different developers.
the developers were recruited from a pool of participants of a previously completed study on programming skill .
additional information about the skill scores used for this purpose can be found in .
the developers were evaluated to ensure they had sufficient english skills for the purpose of our study and they were explicitly asked if they were willing to take part in the planned study.
as part of the study all developers individually completed each of the three tasks in the order specified in table ii on two different systems.
these developers first performed all tasks on one system and then repeated the tasks on the second system.
the systems were randomly assigned to developers with controls in place for equal representation.
clearly there is a learning effect from repeating the same tasks on a second system.
however this effect is not considered a threat to the validity of this particular study since i it reflects realistic situations where developers have relevant experience for performing similar tasks ii the speed with which developers perform their tasks ii maintenance tasks task description .
adapting the system to the new simula cms in the past systems had to retrieve information through a direct connection to a relational database within simula s domain mainly information concerning the researchers at simula and publications associated or derived from the different studies .
currently simula uses a cms based on the plone platform which uses an object oriented database called zodb .
in addition the simula cms database previously contained unique identifiers for employees and publications that were based on integer type.
now a char type is used as a unique identifier for both employees and publications.
task consisted of modifying the data retrieval procedure by consuming a set of web services provided by the new simula cms to access all the information associated with employees and publications.
.
authenticating via web services under the previous cms authentication was done through a connection to a remote database and this process used the authentication mechanisms available at that time for the simula website.
task consisted of replacing the existing authentication procedures by calling a web service for this purpose.
.
adding new reporting functionality a new functionality consisted of introducing a set of options for configuring personalized reports.
in these reports the user should be able to choose the type of information related to a study to be included in the report set as inclusion criteria a list of the people responsible for the study sort the resulting studies according to when the study was finalized and group the results according to the type of study.
the configuration of the report must be stored in the systems database and should be editable only by the owner of the report configuration.
is of no importance and iii repeating the same tasks actually helps developers to contrast maintainability across the systems.
c. study design the process first the developers were given an overview of the tasks e.g.
the motivation for the maintenance tasks and the expected activities .
then they were provided with the specification of the maintenance tasks.
when needed they could discuss the maintenance tasks with a researcher one was always present at the site during the entire duration of the project.
we had daily meetings with the developers where we tracked their progress and the problems they encountered.
think aloud sessions were conducted every other day at a random point during the day and they lasted for minutes.
acceptance tests and individual open interviews which had a duration of minutes were conducted once all three tasks were completed.
in the open ended interviews the developers were asked about their opinions of the system e.g.
about their experiences when maintaining it.
eclipse was used as a development tool along with mysql4 and apache tomcat5.
defects were registered in trac6 and subversion7was used as the versioning system.
a plug in for eclipse called mimec was installed on each developer s computer to log all the user actions performed at the graphical user interface gui level with millisecond precision.
code smells analyzed twelve code smells were automatically identified in the original pre maintenance versions of the systems using borland together and incode.
table iii presents descriptions of the code smells that were detected based on .
the detection strategies used in the tools are on see the appendix in our technical report for more details on the detection parameters .
even though it is not part of the smells defined by fowler and beck the design principle violation called interface segregation principle violation isp violation was included because it constitutes an anti pattern that is believed to have negative effects on maintainability and therefore can be considered a code smell.
borland together is able to detect violations of this design principle.
identification of problems and problematic artifacts the aim of the study was to explore situations where maintenance problems occurred due to the interaction of several code smells.
therefore we needed to identify the artifacts that caused problems during maintenance and to record the nature of the problems caused by these artifacts.
in the context of this study we defined a maintenance related problem as any struggle hindrance or problem developers encountered while they performed their maintenance tasks that was observed by us through daily interviews and think aloud sessions.
the daily interviews with each developer allowed us to record the problems encountered during maintenance while they were still fresh in the developers minds.
the following is an example comment of a developer who complained about the complexity of a piece of code it took me three hours to understand this method... we tagged such comments as partial evidence for maintainability understandability problems in the artifact that included this method.
during the think aloud sessions the developers screens were recorded with a zd soft screen recorder.8sometimes the maintenance problems were derived from more than one data source e.g.
by a combination of direct observation iii code smells and their descriptions based on code smell id description data class dc classes with fields and getters and setters that do not implement any function in particular.
data clump cl clumps of data items that are always found together whether within classes or between classes.
duplicated code in conditional branches dup the same or similar code structure repeated within the branches of a conditional statement.
feature envy fe a method that seems more interested in another class other than the one it actually is in.
fowler recommends putting a method in the class that contains most of the data required by the method.
god class gc a class that takes too many responsibilities relative to the classes with which it is coupled.
the god class centralizes the system functionality in one class which contradicts decomposition design principles.
god method gm a class has the god method smell if at least one of its methods is very large compared to the other methods in the same class.
the god method centralizes the class functionality in one method.
misplaced class mc a class that needs the classes from other packages more than those from its own package.
refused bequest rb subclasses do not want or need everything they inherit.
shotgun surgery ss a change in a class results in the need to make a lot of little changes in several classes.
temporary variable used for several purposes tmp temporary variables used in different contexts implying that they are not consistently used.
these types of variables can lead to confusion and the introduction of faults.
use interface instead of implementation imp castings to implementation classes should be avoided and an interface should be defined and implemented instead.
interface segregation principle violation ispv the dependency of one class upon another one should depend on the smallest possible interface.
even if there are objects that require non cohesive interfaces clients should see abstract base classes that are cohesive.
clients should not be forced to depend on methods they do not use since this creates coupling.
the developers statements on a given topic element and the time effort spent on an activity .
when it was possible to map the identified maintenance problems to an artifact we categorized the artifact as problematic.
while the assessment of problematic artifacts can be subjective to some extent we perceived the connections between problems and code in this study to be quite direct i.e.
asserting a connection did not require much judgment that could introduce a bias.
the researcher that was on site during the study kept a logbook during the interviews and think aloud sessions where the maintenance problems were documented in detail.
for each identified maintenance problem the following information was recorded the developer and the system the statements provided by the developers related to the maintenance problem the source of the problem e.g.
infrastructure developer source code external web services artifacts such as classes or interfaces and possibly methods related to the problem in short the categorization of the problematic artifacts was based on either the direct observation of the developers behavior during the think aloud sessions or on the comments made by the developers during the daily interviews.
a detailed account on the identification of problems and problematic artifacts can be found in .
analysis technique to observe patterns of co located code smells a principal component analysis pca using orthogonal rotation varimax was conducted on the set of artifacts that was modified inspected by at least one of thedevelopers during maintenance.
subsequently a follow up qualitative analysis based on the data from the interviews and the think aloud sessions was performed.
this analysis is based on the explanation building technique and aims to determine the extent to which the presence of a single code smell or several code smells contributed to the problems experienced by the developers during maintenance.
an essential input to the qualitative analysis was the analysis of java files that were modified or inspected during the maintenance work.
these files were identified using the logs generated by mimec .
this plug in recorded not only the type of action performed by the developer in the ide but also the java element if any that was the subject of the interaction such as the name of the file selected or the name of the class method being edited.
for more details on the analysis of the mimec logs we refer to .
iv.
r esults a. exploration of the maintenance problems most of the maintenance problems that we identified were related to one of the following introduction of defects as result of changes time consuming changes and troublesome program comprehension and information searching .
table iv provides a description of each type of problem.
the remaining problems manifested at much lower scale and include cumbersome configuration and debugging .
in total different maintenance problems were identified.
out the total number of maintenance problems related to java source code.
the remaining constituted problems that were not directly related685table iv description of the three main types of problem identified no.
type of problem description .
introduction of defects undesired behavior or unavailability of functionality in the system i.e.
defects that manifested after modifying different components of the system.
this problem introduced delays in the work and forced the developers perform lengthy debugging or to roll back initial strategies for solving the tasks.
.
time consuming or costly changestime consuming or costly changes were associated with situations with one of the following i a high number of components in the system required changes in order to accomplish a task and ii cognitively demanding tasks due to the nature of the problem to be solved or due to the system s intricate design visualization or information distribution.
.
troublesome program comprehension and information searchingthis problem type comprised three situations i the developers struggled to get an overview of the system or to obtain high level understanding of the system s behavior ii the developers became confused during low level understanding of the code because they found inconsistent or contradictory evidence in different components of the system and iii the developers faced time consuming or troublesome information or task context searches e.g.
finding the appropriate place to make the changes finding the data needed to perform a task .
to code e.g.
a lack of adequate technical infrastructure developer coding habits external services run time environment and defects initially present in the system .
the high percentage of non source code related problems suggests that problems identifiable via current definitions of code smells may only cover a smaller part in this case of the total problems identified during maintenance.
in total artifacts i.e.
java files across all four systems were modified or inspected by at least one developer during maintenance from a total of artifacts.
this indicates that nearly of the artifacts across all four systems were modified inspected.
out of those artifacts that were modified inspected of them were reported as problematic during maintenance by at least one developer.
table v presents the numbers and proportions of problematic and non problematic artifacts across the four systems and the percentage of the total number of files that were modified inspected in each system.
b. the factor analysis a principal component analysis pca was conducted on the data points using orthogonal rotation varimax .
the kaiser meyer olkin kmo measure was used to verify the sampling adequacy for the analysis as recommended by field .
with kmo .
and all kmo values for individual items being the sample meets the minimum acceptance criterion defined by kaiser .
in addition bartlett s test of sphericity with andp indicates table v distribution and percentage of problematic vs .
non problematic artifacts system problematic non problematic total a b c d total that the correlations between the items are sufficiently large for a satisfactory application of pca.
an initial analysis was run to obtain eigenvalues for each component in the data.
five components had eigenvalues over kaiser s criterion of and in combination explained .
of the variance.
table vi shows the factor loadings after rotation.
c. relations between factors and problems in total five factors were identified as shown in table vi.
below we discuss for each factor what code smells contributed to them the code smells role in them and the observed effects of those smells on maintenance problems.
factor in table vi the code smells god method and god class are the closest in this factor followed by the code smells temporal variable used for several purposes duplicated code in conditional branches and feature envy.
given that the detection strategies of the first two code smells are based on size measures see appendix in it is natural that they would appear together.
in addition large classes often use many different variables which increase the chances of the same temporary variable being used for several different purposes .
code smells in factor may consequently be considered to relate to the size of the code.
the great majority of these classes contained many methods that accessed data methods from different areas of the system i.e.
methods displaying feature envy .
this characteristic forced the developers to examine all the artifacts called by these methods in order to first understand the behavior of the class and then to identify the task context.
faults occurred in those artifacts because developers missed areas of the code that needed to be consistently changed after changes were done on the methods displaying feature envy.
the qualitative data pointed out that artifacts with feature envy and god method were associated with time consuming changes because they involved highly complex changes in terms of the number of changes required to complete the task and also regarding the number of elements to be considered simultaneously to complete the task.
this last case comprised a cognitively demanding task.
686one or two classes in each system hoarded the business logic functionality of the system i.e.
studydatabase db and studydao as described in .
they were extremely large in comparison to the rest of the artifacts of the systems and developers frequently will commit slips or mistakes due to the size of these classes mainly because it is hard to navigate across the class and keep track of the changes within the class .
some of these hoarders also contained temporal variables used in different contexts.
these inconsistencies in the use of different variables made the developers unsure about the purpose of the variables and the behavior of the method class containing them.
this uncertainty triggered mistakes that lead to several faults particularly in system c. developers would change a variable expecting that it would be used in the same way across the class.
instead unexpected behavior would manifest and demand debugging and refactoring.
factor isp violation and shotgun surgery belong together in a separate factor factor .
this distinction indicates that they may represent to some extent the same construct e.g.
related to wide spread afferent coupling .
also they did not seem to relate much to the size of the code factor .
one critical example of program comprehension in artifacts containing isp violation relates to the presence of inconsistent design manifested in the class studysortbean in system a see .
a major reason why the developers found system a difficult to understand was due to inconsistent and incoherent data and functionality allocation which was considered not logical by the developers.
two developers actually stated that the design did not make sense.
the class studysortbean was initially employed as a bean9to sort a given list of empirical studies and present them in a report to the user.
9in j2ee environments it is common to use bean files as data transfer objects.
their counterparts the action files which in turn contain the business logic access the bean files.
table vi factor loadings after rotation component gm .
gc .
tmp .
dup .
fe .
ss .
ispv .
dc .
cl .
imp .
rb .
mc .
eigenvalues .
.
.
.
.
of variance .
.
.
.
.607sometime during the initial development phase i.e.
not the maintenance phase the studysortbean class started to acquire more responsibilities that did not correspond to its class and it turned into an action file.
this instance is a good example of what martin calls the wider spectrum of dissimilar clients .
as a result an artifact initially containing a data class acquired an isp violation.
both the data and the functionality were called from many different classes many of them unrelated.
since the allocation of the data and functionality seemed rather arbitrary to the developers they became confused about the rationale of such a design.
this case is very interesting because the isp violation was not the actual cause of the problem the real problem was the inadequate allocation of data and functionality.
nonetheless the definition of an isp violation and its detection strategy could identify this particular situation.
we also observed that when the developers introduced faults into artifacts displaying an isp violation the consequences of these faults manifested themselves across different components that depended on them.
this situation caused much of the systems functionality to stop working after changes and in some cases lead to unmanageable error propagation.
additionally when changes were introduced into the aforementioned artifacts we observed that adaptations or amendments were needed in other artifacts depending on the isp violators.
this requirement resulted in time consuming change propagation and also caused the introduction of defects as developers sometimes would miss parts of the code that needed amendments resulting in a timeconsuming and an error prone process.
factor data class and data clump are together in one factor factor .
although most artifacts displaying data class also displayed data clump very few of the artifacts displaying both smells were deemed to be problematic during maintenance.
the difficult artifacts with data class in turn seemed to display more affinity with isp violation which was described in the previous section.
most of the problems in the data class were related to task where the types for the identifiers needed to be changed from integer to string.
these errors were caused when developers would forget to update some of the data classes introducing defects into the systems.
one observation from artifacts constituting data classes is that the great majority of them displayed incoming dependencies from feature envy methods.
data were located on the artifacts displaying data class and those were accessed by methods in the artifacts that contained most of the functionality in the systems i.e.
feature envious methods .
this code smell relationship was mentioned earlier by pietrzak et.
al.
and by lanza et.
al.
.
factor implementation instead of interface represented factor .
this code smell appeared very seldom in our data set and did not relate to any of the other code smells.
out of all the problematic artifacts only two contained this smell and one of them was problematic only because it displayed the combination of smells described in factor .
consequently in this study this factor could not be associated with any serious maintainability problems.687table vii tendencies and characteristics of inter smell relations identified in the study relation nickname factor major characteristics characteristic code smells hoarders indicators of high internal complexity and large size where the functionality for the element has grown out of proportion.
these elements are difficult to understand and change and are prone to defects due to slips.
god method god class and feature envy confounders these smells indicate that there are two or more ambiguous contexts which can easily mislead developers in what is actually happening in a particular piece of code.
as a result they are mostly associated with defects and program comprehension issues and are often located in the same classes where the hoarders are.temporal variable used for several purposes and duplicated code in conditional branches wide interfaces indicators of afferent coupling dispersion.
if the maintenance task requires any modification in classes displaying these smells these changes will entail unexpected side effects due to the functional coupling dispersion.
sometimes they are found in the same class as data containers or hoarders.shotgun surgery and isp violation data containers indicators of elements only containing data.
feature envy methods often have dependencies on artifacts displaying these classes.
sometimes they are found in the same class as wide interfaces when the allocation of data functionality is not optimal.data class and data clump unknowns and not enough data from the study very few instances were found and most of them were not associated with maintenance problems.implementation instead of interface misplaced class and refused bequest factor refused bequest and misplaced class constituted the last factor where misplaced class displayed a negative loading in the pca.
this distinction indicated that misplaced class tended to be negatively associated with this factor.
positive and negative loadings can be related with the same factor.
for example in surveys negative loadings are caused by questions that are negatively oriented to a factor.
a combination of positive and negative questions is normally used to minimize an automatic response bias by the respondents .
after analyzing the types of problems in each of the artifacts we concluded that none of the maintenance problems observed in our study could be associated with the presence of refused bequest or the absence of misplaced class.
d. identified trends and inter smell relations the results from our pca analysis of the problematic artifacts and the nature of the maintenance problems caused by them all support our position that inter smell relations should be analyzed alongside the individual effects of code smells.
to enable a more systematic treatment we propose a set of four inter smell relations based on our observations and analysis.
table vii gives an overview of these relations their associated factors from our pca analysis and a description of their major characteristics.
the fact that the two inter smell relations hoarders andconfounders were grouped in the same factor is not surprising if we consider the fact that artifacts which exhibit hoarders often also exhibit the confounders so the pca would naturally put them together.
as mentioned before some aspects of the inter smell re lations presented in table vii were already conjectured in earlier work by pietrzak and walter and by lanza and marinescu .
in addition to the summary in table vii we present a graphical overview of the relationships in figure which complements these earlier results based on concrete empirical findings from our study.
in addition to inter smell relations we also observed interactions between the isp violation code smell and other nonsmell types of code characteristics.
moreover we identified a critical case where interactions were observed between code smells that were distributed across coupled artifacts.
we refer to these as coupled smells to distinguish them from the colocated smells discussed above.
these cases are discussed in more detail in the next two subsections.
e. interaction between smells and other characteristics the first case was observed in system b and it was related to time consuming changes and the introduction of defects after a developer s initial changes.
all developers who worked on system b reported the exact same problem in order to complete task which consisted of modifying the functionality that accesses external data the developers wanted to replace two interfaces persistable and persistentobject10 with one new interface to support a string id type.
the external data employs string type identifiers as opposed to the integer types used in the system.
replacing the interfaces was not possible 10these artifacts constituted implementations of the persistence framework.
persistence framework is used as a part of java technology for managing relational data more specifically data entities .688hoardersfeature envygod classgod methoddata containersdata clumpdata classwide interfacesisp violationshotgun surgeryconfounderstemporal variable used for several purposesduplicated code in conditional branceshavedependencieson couldbecomeare often found together withcouldbecomefig.
.
diagram displaying code smell relationships based on the observations in the study since the entire logic flow was based on primitive types instead of domain entities.
both interfaces were restrictive and were made under the assumption that the identifiers for objects would always be integers and thus accessor methods getid and setid with a parameter of integer type were defined.
notice that these interfaces did not display any code smells.
the maintenance problems occurred because several critical classes in the system implemented these two interfaces.
many of the classes that used these interfaces exhibited isp violation smells which resulted in extensive ripple effects when modifying the interfaces.
after the developers modified the interfaces an extremely high number of compilation errors were found.
these errors induced the developers to rollback the initial changes in those artifacts i.e.
keep the interfaces untouched and instead use explicit forced type casting wherever a string type identifier was required.
most developers used a considerable amount of time trying to replace the interface and they were required to rollback and perform the explicit casting.
this case is an example of how the presence of a code smell may intensify or spread the effects of bad limited design choices throughout the system.
since classes with wide afferent coupling and therefore exhibiting the isp violation smell depended on these suboptimal interfaces any change to the interfaces resulted in a considerable ripple effect effectively negating the abstraction benefits of using an interface.
f .
smell interaction across coupled artifacts the second case relates to the observation that all systems except for system b contained one single class that hoarded most of the logic and functionality in those systems.
these classes were very large in comparison to other classes in the system displayed a wide spread of both afferent and efferent coupling and demanded high amounts of changes.
all three hoarders exhibited isp violation because they displayed many incoming dependencies from different segments of the system.
because of their high level of efferentcoupling they also contained feature envy.
these hoarders also exhibited the god method smell which is commonly present in big complex classes.
changes in these hoarders were essential given the maintenance tasks and they were time consuming since the developers first had to understand the logic they contained.
the developers reported that they found it difficult to foresee the consequences of changes given the combination of their internal complexity and the high number of dependent classes.
moreover after the changes were made errors would manifest in different areas of the system causing further delays to the project.
an interesting observation was that in system b the combination of code smells present in the hoarders of systems a c and d was not located in one artifact but instead they were distributed across several problematic artifacts.
the artifacts studysearch.java and memorycachingsimula.java were internally complex and objectstatementimpl.java and simula.java displayed the highest incoming dependencies.
both pairs of artifacts were strongly coupled i.e.
studysearch.java had dependencies on objectstatementimpl.java while memorycachingsimula.java was dependent on simula.java .
we found that the interactions between such coupled smells had similar effects as when code smells were co located in the same artifact.
table viii gives an overview of these coupled smells the smell abbreviations used are explained in table iii .
g. implications for research and practice in this study we have discovered how code smells that appear together in the same artifact can interact with each other causing various types of maintenance problems.
practitioners could use the descriptions of the factors identified in our study to identify critical artifacts that may need to be prioritized for refactoring.
from a research perspective we know only of one empirical study by abbes et al.
that reports on the interaction effects between two concrete code smells i.e.
between god class and god method and we believe that689table viii overview of the hoarders in system band the distribution of the individual smells across two coupled artifacts filename individual code smells coupled smells studysearch.java gc gm fefe gm ispv gc ssobjectstatementimpl.java ispv ss memorycachingsimula.java gc tmpispv gc ss tmpsimula.java ispv ss the results from our study both extends and aligns with their findings.
in addition our findings provide concrete empirical evidence for some of the smell relations conjectured earlier by pietrzak and walter and by lanza and marinescu .
based on our findings we argue that studies into the effects of inter smell relations are a topic that deserves more attention.
this position is further supported by the observation that in some large classes the maintenance problems were not so much caused by the complexity that followed from the actual size of the class but rather were a result of interaction effects between different code smells that appeared together in that class.
this distinction implies that the currently common approach for code smell detection and analysis which is based on analyzing individual smells and not the effects of smell combinations severely limits the capability to explain or predict maintenance problems.
another limitation of the current approaches for code smell analysis is that the coupling between code elements that contain code smells is not considered in the analysis.
however the results from our study indicate that from a practical perspective interaction effects between code smells that are distributed across coupled artifacts have the same consequences as interaction effects between code smells that are co located in the same artifact.
this finding has considerable implications for further studies on code smells since it means that to get a more complete understanding of the role of code smells in software maintenance dependency analysis should be included in the code smell analysis process.
h. threats to validity we consider threats to the validity of our study from three perspectives construct validity the definition of a maintenance problem may have been interpreted differently amongst different developers and the researcher who conducted the data collection the first author of the paper .
the code smells were automatically identified via tools to avoid subjective bias.
nevertheless the implicit choice for the detection strategies implemented in these tools could be a potential threat to validity.
other code smell detection tools could employ different detection strategies than the ones used in this study which in turn might lead to variation in the smells that are detected in the given subject systems.
internal validity it is possible that some developers were more open about the problems they faced than others andthat some developers did not disclose all problems they experienced.
in addition developers may have worked more mindfully because of the interaction with researchers hawthorne effect .
these are common threats whenever qualitative data is used in empirical studies.
we have addressed these threats by using three independent collection methods interviews direct observation and think aloud sessions and triangulating the data.11the detection of smells on pre maintenance versions of the code was delayed until after maintenance to avoid influence and bias by the researcher collecting the data.
the design of the study allowed for observation of several cases where different developers worked on the same system.
this enabled an iterative explanation building process where we could revise confirm or reject observations based on several cases involving the same systems.
together with a clear chain of evidence and a well defined protocol this reduced the threats typically associated with using explanation building such as losing of focus from the original goals .
external validity our results are contingent on the contextual properties of the study and are mainly valid for maintenance projects in contexts similar to ours.
the maintenance work involved medium sized java based web applications and the programmers completed the tasks individually i.e.
not in teams or using pair programming.
this last characteristic can affect the applicability of the results in highly collaborative environments.
given the size of the tasks and the week maintenance period covered in our study we cannot claim that our results fully represent long term maintenance projects with large tasks.
however the tasks involved do resemble for example backlog items in a single sprint or iteration in the context of agile development.
in this study we closely observed the entire maintenance process for a period of four full working weeks.
we are unaware of other work that reports on experimental studies of code smells in in vivo maintenance tasks that lasted longer than minutes.
v. c onclusions and future work this paper reports on an empirical study that investigated intersmell relations and their effects on the incidence of maintenance problems.
by analyzing how professional developers conducted tasks on four different systems we found empirical evidence that certain inter smell relations were associated with problems during maintenance and also that some inter smell 11the term triangulation or cross examination means that multiple sources of evidence were used to validate the consistency and reliability of the results .690relations manifested across coupled artifacts.
our study constitutes a realistic maintenance project and we believe that the maintenance problems that were observed are representative of those experienced in an industrial setting.
therefore our results provide empirical evidence to guide the focus on design aspects that can be used for detecting and avoiding maintenance problems.
further studies on the basis of our findings and experiences should include the following i an analysis of inter smell relations in larger systems involving different maintenance scenarios ii an analysis of the interaction effects between smells and other design properties and iii an inter smell analysis incorporating a dependency analysis to consider coupled smells.