a field study of refactoring challenges and benefits miryung kim miryung ece.utexas.eduthomas zimmermann tzimmer microsoft.comnachiappan nagappan nachin microsoft.com the university of texas at austin tx usa microsoft research redmond wa usa abstract it is widely believed that refactoring improves software quality and developer productivity.
however few empirical studies quantitatively assess refactoring benefits or investigate developers perception towards these benefits.
this paper presents a field study of refactoring benefits and challenges at microsoft through three complementary study methods a survey semi structured interviews with professional software engineers and quantitative analysis of version history data.
our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semanticspreserving code transformations and that developers perceive that refactoring involves substantial cost and risks.
we also report on interviews with a designated refactoring team that has led a multi year centralized effort on refactoring windows.
the quantitative analysis of windows version history finds that the binary modules refactored by this team experienced significant reduction in the number of inter module dependencies and post release defects indicating a visible benefit of refactoring.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring general terms measurement experimentation keywords refactoring empirical study software evolution component dependencies defects churn.
.
introduction it is widely believed that refactoring improves software quality and developer productivity by making it easier to maintain and understand software systems .
many believe that a lack of refactoring incurs technical debt to be repaid in the form of increased maintenance cost .
for example extreme programming claims that refactoring saves development cost and advocates the rule of refactor mercilessly throughout the entire project life cycles.
on the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november raleigh nc usa copyright acm ... .
.other hand there exists a conventional wisdom that software engineers often avoid refactoring when they are constrained by a lack of resources e.g.
right before major software releases .
some also believe that refactoring does not provide immediate benefit unlike new features or bug fixes.
recent empirical studies show contradicting evidence on the benefit of refactoring as well.
ratzinger et al.
found that if the number of refactoring edits increases in the preceding time period the number of defects decreases.
on the other hand wei gerber and diehl found that a high ratio of refactoring edits is often followed by an increasing ratio of bug reports and that incomplete or incorrect refactorings cause bugs .
in our previous study we found similar evidence that refactoring edits have a strong temporal and spatial correlation with bug fixes .
these contradicting findings motivated us to conduct a field study of refactoring definition benefits and challenges in a large software development organization and investigate whether there is a visible benefit of refactoring a large system.
in this paper we address the following research questions what is the definition of refactoring from developers perspectives?
by refactoring do developers indeed mean behavior preserving code transformations or changes to a program structure ?
what is the developers perception about refactoring benefits and risks and in which contexts do developers refactor code?
as claimed in the literature are there visible refactoring benefits such as reduction in the number of bugs reduction in the average size of code changes after refactoring and reduction in the number of component dependencies?
to investigate the definition of refactoring in practice and the value perception toward refactoring we conducted a survey with over three hundred engineers whose check in comments included a keyword refactor in the last two years.
from our survey participants we also came to know about a multi year refactoring effort on windows.
because windows is one of the largest long surviving software systems within microsoft and a designated team led an intentional effort of system wide refactoring we focused on the case study of windows.
we interviewed the refactoring team and then assessed the impact of the team s refactoring on reduction of inter module dependencies and post release defects using windows version history.
our field study found the following results the refactoring definition in practice seems to differ from a rigorous academic definition of behavior preserving program transformations .
our survey participants perceived that refactoring involves substantialcost and risks and they needed various types of tool support beyond automated refactoring within ides.
the interviews with a designated windows refactoring team provide insights into how system wide refactoring was carried out in a large organization.
the team led a centralized refactoring effort by conducting an analysis of a de facto dependency structure and by developing custom refactoring support tools and processes.
the binary modules refactored by the refactoring team had significant reduction in the number of inter module dependencies and the number of post release defects.
when comparing the top of most frequently refactored binaries against the top of most frequently modified binaries there is a statistically significant difference in changes to the total number of dependencies.
further the top of frequently refactored binaries reduced the number of post release defects .
more than other modified binaries on average.
while there are many anecdotes about the benefit of refactoring few empirical studies quantitatively assess refactoring benefit.
to the best of our knowledge our study is the first to quantitatively assess the impact of multi year system wide refactoring on inter module dependencies and post release defects in a large organization.
our study provides evidence that refactoring change is likely to be more safe and reliable than regular change in a large system .
our survey is also the first large scale investigation into the refactoring definition in practice and the value perception about refactoring from developers perspectives.
based on our study we propose future research directions on refactoring we need to provide various types of tool support beyond automated refactorings in ides such as refactoringaware code reviews refactoring cost and benefit estimation and automated validation of program correctness after refactoring edits.
.
related work refactoring definition.
while refactoring is defined as behavior preserving code transformations in the academic literature the de facto definition of refactoring in practice seems to be very different from such rigorous definition.
fowler catalogs types of structural changes in object oriented programs but these transformations do not necessarily guarantee behavior preservation .
in fact fowler recommends developers to write test code first before since these refactorings may change a program s behavior.
murphy hill et al.
analyzed refactoring logs and found that developers often interleave refactorings with other behavior modifying transformations indicating that pure refactoring revisions are rare.
johnson s refactoring definition is aligned with these findings refactoring improves behavior in some aspects but does not necessarily preserve behavior in all aspects .
our survey in section also finds that refactoring is not confined to low level semantics preserving transformations from developers perspectives.
quantitative assessment of refactoring benefits.
while several prior research efforts have conceptually advanced our understanding of the benefit of refactoring through metaphors few empirical studies assess refactoring benefits quantitatively.
sullivan et al.
first linked software modularity withoption theories .
a module provides an option to substitute it with a better one without symmetric obligations and investing in refactoring activities can be seen as purchasing options for future adaptability which will produce benefits when changes happen and the module can be replaced easily.
baldwin and clark argued that the modularization of a system can generate tremendous value in an industry given that this strategy creates valuable options for module improvement.
ward cunningham drew the comparison between debt and a lack of refactoring a quick and dirty implementation leaves technical debt that incur penalties in terms of increased maintenance costs .
while these projects advanced conceptual understanding of refactoring impact they do not quantify the benefits of refactoring.
xing and stroulia found that of structural changes in eclipse s evolution history are due to refactorings and existing ides lack support for complex refactorings .
dig et al.
studied the role of refactorings in api evolution and found that of the changes that break client applications are api level refactorings .
while these studies focused on the frequency and types of refactorings they did not focus on how refactoring impacts inter module dependencies and defects.
maccormack et al.
defined modularity metrics and used these metrics to study evolution of mozilla and linux.
they found that the redesign of mozilla resulted in an architecture that was significantly more modular than that of its predecessor.
however unlike our study on windows their study merely monitored design structure changes in terms of modularity metrics without identifying the modules where refactoring changes are made.
conflicting evidence on refactoring benefit.
kataoka et al.
proposed a refactoring evaluation method that compares software before and after refactoring in terms of coupling metrics.
kolb et al.
performed a case study on the design and implementation of existing software and found that refactoring improves software with respect to maintainability and reusability.
moser et al.
conducted a case study in an industrial agile environment and found that refactoring enhances quality and reusability related metrics.
carriere et al.
s case study found the average time taken to resolve tickets decreases after re architecting the system .
ratzinger et al.
developed defect prediction models based on software evolution attributes and found that refactoring related features and defects have an inverse correlation if the number of refactoring edits increases in the preceding time period the number of defects decreases.
these studies indicated that refactoring positively affects productivity or quality measurements.
on the other hand several research efforts found contradicting evidence that refactoring may affect software quality negatively.
wei gerber and diehl found that refactoring edits often occur together with other types of changes and that refactoring edits are followed by an increasing number of bugs .
kim et al.
found that the number of bug fixes increases after api refactorings .
nagappan and ball found that code churn the number of added deleted and modified lines of code is correlated with defect density since refactoring often introduces a large amount of structural changes to the system some question the benefit of refactoring.
g org and wei gerber detected errors caused by incomplete refactorings by relating api level refactorings to the corresponding class hierarchy .because manual refactoring is often tedious and errorprone modern ides provide features that automate the application of refactorings .
however recent research found several limitations of tool assisted refactorings as well.
daniel et al.
found dozens of bugs in the refactoring tools in popular ides .
murphy hill et al.
found that refactoring tools do a poor job of communicating errors and programmers do not leverage them as effectively as they could .
vakilian et al.
and murphy et al.
found that programmers do not use some automated refactorings despite their awareness of the availability of automated refactorings.
these contradicting findings on refactoring benefits motivate our survey on the value perception about refactoring.
they also motivate our analysis on the relationship between refactoring and inter module dependencies and defects.
refactoring change identification.
a number of existing techniques address the problem of automatically inferring refactorings from two program versions.
these techniques compare code elements in terms of their name and structure similarity to identify move and rename refactorings .
prete et al.
encode fowler s refactoring types in template logic rules and use a logic query approach to automatically find complex refactorings from two program versions .
a survey of existing refactoring reconstruction techniques is described elsewhere .
kim et al.
use the results of api level refactoring reconstruction to study the correlation between api level refactorings and bug fixes .
while it is certainly possible to identify refactorings using refactoring reconstruction techniques in our windows analysis we identify the branches that a designated refactoring team created to apply and maintain refactorings exclusively and isolate changes from those branches.
we believe that our method of identifying refactorings is reliable as a designated team confirmed all refactoring branches manually and reached a consensus about the role of those refactoring branches within the team.
empirical studies on windows.
prior studies on windows focused on primarily defect prediction.
nagappan and ball investigated the impact of code churn on defect density and found that relative code churn measures were very effective indicators of code quality .
zimmermann and nagappan built a system wide dependency graph of windows server .
by computing network centrality measures they observed that network measures based on dependency structure were more effective in defect prediction compared to complexity metrics .
more recently bird et al.
observed that socio technical network measures combined with dependency measures were stronger indicators of failures than dependency measures alone .
our current study is significantly different from these prior studies by distinguishing refactoring changes from non refactoring changes and by focusing on the impact of refactoring on inter module dependencies and defects.
.
a survey of refactoring practices in order to understand refactoring practices at microsoft we sent a survey to engineers whose change comments included the keyword refactor in the last years in five microsoft products windows phone exchange windows office communication and services ocs and office.
wepurposely targeted the engineers who are already familiar with the terms refactor refactoring refactored etc.
because our goal is to understand their own refactoring definition and their perception about the value of refactoring.
the survey consisted of multiple choice and free form questions which were designed to understand the participant s own refactoring definition when and how they refactor code including refactoring tool usage developers perception toward the benefits risks and challenges of refactoring.
table shows a summary of the survey questions the full list is available as a technical report .
we analyzed the survey responses by identifying the topics and keywords and by tagging individual responses with the identified topics.
in total engineers participated in the survey.
of them were developers of them were test engineers .
of them were build engineers and .
of them were program managers.
the participants had .
years of experience at microsoft and .
years of experience in software industry on average with a familiarity with c c and c .
.
what is a refactoring definition in practice?
when we asked how do you define refactoring?
we found that developers do not necessarily consider that refactoring is confined to behavior preserving transformations .
define refactoring as code transformation that improves some aspects of program behavior such as readability maintainability or performance.
of developers did not mention preservation of behavior semantics or functionality in their refactoring definition at all.
this observation is consistent with johnson s argument that while refactoring preserves some behavior it does not preserve behavior in all aspects.
the following shows a few examples of refactoring definitions by developers.
rewriting code to make it better in some way.
changing code to make it easier to maintain.
strictly speaking refactoring means that behavior does not change but realistically speaking it usually is done while adding features or fixing bugs.
when we asked how does the abstraction level of martin fowler s refactorings or refactoring types supported by visual studio match the kinds of refactoring that you perform?
said these basic refactorings are often a part of larger higherlevel effort to improve existing software.
of developers agree that refactorings supported by automated tools differ from the kind of refactorings they perform manually.
in particular one developer said the refactorings listed in table form the minimum granular unit of any refactoring effort but none are worthy of being called refactoring in and of themselves.
the refactorings she performs are larger efforts aimed at interfaces and contracts to reduce software complexity which may utilize any of the listed low level refactoring types but have a larger idea behind them.
as another example a participant said these fowler s refactoring types or refactoring types supported by visual studio are the small code transformation tasks often performed but they are unlikely to be performed alone.
there s usually a bigger architectural change behind them.
1in the following each italicized indented paragraph corresponds to a quote from answers to our survey section or interviews section .table summary of survey questions the full list is available as a technical report background what is your role in your team i.e.
developer tester program manager team lead dev manager etc.
?
which best describes your primary work area?
how many years have you worked in software industry?
which programming languages are you familiar with?
definition how do you define refactoring ?
which keywords do you use or have you seen being used to mark refactoring activities in change commit messages?
how does the abstraction level of fowler s refactorings such as extract method match the kinds of refactorings that you often perform?
context how many hours per month roughly do you spend on refactoring?
how often do you perform refactoring?
in which situations do you perform refactorings?
value what benefits have you observed from refactoring?
perception what are the challenges associated with performing refactorings?
based on your own experience what are the risks involved in refactoring?
how strongly do you agree or disagree with each of the following statements?
refactoring improves program readability refactoring introduces subtle bugs refactoring breaks other people s code refactoring improves performance refactoring makes it easier to fix bugs .
.
.
tools what tools do you use during refactoring?
what percentage of your refactoring is done manually as opposed to using automated refactoring tools?
the following lists some of the types of refactorings.
please indicate whether you know these refactorings or used them before.
multiple choices usually do this both manually and using automated tools usually do this manually usually do this using automated tools know this refactoring type but don t use it don t know this refactoring type.
rename extract method encapsulate field extract interface remove parameters .
.
.
these refactoring types were selected from fowler s catalog.
how strongly do you agree or disagree with each of the following statements?
i interleave refactorings with other types of changes that modify external program behavior.
refactorings supported by a tool differ from the kind of refactorings i perform manually.
refactorings that i apply are higher level changes than the ones supported by tools.
how do you ensure program correctness after refactoring?
.
.
.
only a few statements are shown in this paper for presentation purposes.
these remarks indicate that the scope and types of code transformations supported by refactoring engines are often too low level and do not directly match the kinds of refactoring that developer want to make.
.
what are the challenges associated with refactoring?
when we asked developers what are the challenges associated with refactorings at microsoft?
of developers pointed out inherent challenges such as working on large code bases a large amount of inter component dependencies the needs for coordination with other developers and teams and the difficulty of ensuring program correctness after refactoring.
of developers also mentioned a lack of tool support for refactoring change integration code review tools targeting refactoring edits and sophisticated refactoring engines in which a user can easily define new refactoring types.
the difficulty of merging and integration after refactoring often discourages people from refactoring.
version control systems that they use are sensitive to rename and move refactoring and it makes it hard for developers to understand code change history after refactorings.
the following quotes describe the challenges of refactoring change integration and code reviews after refactoring cross branch integration was the biggest problem.
we have this sort of problem every time we fix any bug or refactor anything although in this case it was particularly painful because refactoring moved files which prevented cross branch integration patches from being applicable.
it refactoring typically increases the number of lines files involved in a check in.
that burdens code reviewers and increases the odds that your change will collide with someone else s change.
many participants also mentioned that when a regression test suite is inadequate there is no safety net for checking the correctness of refactoring.
thus it often prevents from developers to initiate refactoring effort.
if there are extensive unit tests then it s great one would need to refactor the unit tests and run them and do some sanity testing on scenarios as well.
if there are no tests then one need to go from known scenarios and make sure they all work.
if there is insufficient documentation for scenarios refactoring should not be done.
in addition to these inherent and technical challenges of refactoring reported by the participants maintaining backward compatibility often discourages them from initiating refactoring effort.
according to self reported data developers do most refactoring manually and they do not use refactoring tools despite their awareness of refactoring types supported by the tools.
when we asked what percentage of your refactoring is done manually as opposed to using automated refactoring tools?
developers said they do of refactoring manually on average.
surprisingly of developers do all of their refactoring manually.
figure shows the percentages of developers who usually apply individual refactoring types manually despite the awareness and availability of automated refactoring tool support.
considering that of these de !
!
!
!
!
!
.
!
.
.
.
!
.
.
.
?
.
a?
b .
!
.
figure the percentage of survey participants who know individual refactoring types but do those refactorings manually !
!
!
!
!
!
!
!
.
.
!
!
!
.
!
!
.
figure the risk factors associated with refactoring velopers reported that they have automated refactoring engines available in their development environments this lack of usage of automated refactoring engines is very surprising.
with an exception of rename refactoring more than a half of the participants said that they apply those refactorings manually despite their awareness of the refactoring types and availability of automated tool support.
this result is aligned with vakilian et al.
.
our survey responses indicate that the investment in tool support for refactoring must go beyond automated code transformation for example tool support for change integration code reviews after refactoring validation of program correctness estimation of refactoring cost and benefit etc.
i d love a tool that could estimate the benefits of refactoring.
also it d be awesome to have better tools to help figure out who knows a lot about the existing code to have somebody to talk to and how it has evolved to understand why the code was written the way it was which helps avoid the same mistakes.
i hope this research leads to improved code understanding tools.
i don t feel a great need for automated refactoring tools but i would like code understanding and visualization tools to help me make sure that my manual refactorings are valid.
what we need is a better validation tool that checks correctness of refactoring not a better refactoring tool.
.
what are the risks and benefits of refactoring?
when we asked developers based on your experience what are the risks involved in refactorings?
they reported regres !
!
!
!
!
!
!
!
!
!.
!
!.!
!
!
.
!
!.!
!
!
.
!
figure various types of refactoring benefits that developers experienced sion bugs code churns merge conflicts time taken from other tasks the difficulty of code reviews after refactoring and the risk of over engineering.
figure summarizes the percentage of developers who mentioned each particular risk factor.
note that the total sum is over as one developer could mention more than one risk factor.
of the participants consider that refactoring comes with a risk of introducing subtle bugs and functionality regression say that code merging is hard after refactoring and mention increased testing cost.
the primary risk is regression mostly from misunderstanding subtle corner cases in the original code and not accounting for them in the refactored code.
over engineering you may create an unnecessary architecture that is not needed by any feature but all code chunks have to adapt to it.
the value of refactoring is difficult to measure.
how do you measure the value of a bug that never existed or the time saved on a later undetermined feature?
how does this value bubble up to management?
because there s no way to place immediate value on the practice of refactoring it makes it difficult to justify to management.
when we asked what benefits have you observed from refactoring?
developers reported improved maintainability improved readability fewer bugs improved performance reduction of code size reduction of duplicate code improved testability improved extensibility easier to add new feature improved modularity reduced time to market etc as shown in figure .
when we asked in which situations do you perform refactorings?
developers reported the symptoms of code that help them decide on refactoring see figure .
mentioned poor readability mentioned poor maintainability mentioned the difficulty of repurposing existing code for different scenarios and anticipated features mentioned the difficulty of testing code without refactoring mentioned code duplication mentioned slow performance mentioned dependencies to other teams binaries and mentioned old legacy code that they need to work on.
of developers said they do refactoring in the context of bug fixes and feature additions and of the responses indicate that refactoring is driven by immediate concrete visible needs of changes that they must implement in a short term rather than potentially uncertain benefits!
!
!
!
.
!
.
.
?
.
figure the symptoms of code that help developers initiate refactoring of long term maintainability.
in addition more than of developers do refactoring across all milestones and not only in mq milestones a period designated to fix bugs and clean up code without the responsibility to add new features.
this indicates the pervasiveness of refactoring effort.
according to self reported data developers spend about hours per month working on refactoring which is close to of their work assuming developers work about hours per month.
.
a case study of windows refactoring in order to examine how the survey respondents perception matches reality in terms of refactoring and to investigate whether there are visible benefits of refactoring we decided to conduct follow up interviews with a subset of the survey participants and to analyze the version history data.
in terms of a subject program we decided to focus on windows because it is the largest long surviving software system within microsoft and because we learned from our survey that a designated refactoring team has led an intentional system wide refactoring effort for many years.
section .
describes the results of semi structured interviews with six key members of the windows refactoring team and section .
describes quantitative assessment of refactoring benefits using the windows version history.
.
interviews in this section we investigate a multi year refactoring effort made by a designated refactoring team in windows.
to understand the goal of this refactoring project and how the refactoring project was carried out we conducted oneon one interviews with six key members of this team.
the following describes the role of interview participants.
the interviews with the participants were audio recorded and transcribed later for analysis.
the first author of this paper led all interviews.
architect minutes architect development manager minutes development team lead minutes development team lead minutes developer minutes researcher minutes the interview study results are organized by the questions raised during the interviews.
what motivated your team to lead this refactoring effort?
the refactoring effort was initiated by a few architects who recognized that a large number of dependencies at the binary module level could be reduced and optimized to make modular reasoning of the system more efficient.
the goal of refactoring was to maximize parallel development efficiency to avoid unwanted parallel change interference and make it easier to selectively rebuild and retest subsystems effectively.
when we started looking at the system as a whole there were so many dependencies.
two different teams working on completely different features could cause a build to break if they do not watch out dependencies during our change integration across branches if x percent of the binaries are at a strongly connected component and you touch one of those things and you have to retest x percent of the binaries again.
.
.
what are the goals of windows refactoring?
the refactoring effort was driven by foresights to repurpose the existing system to target different execution environments at a much faster pace than before.
thus the refactoring effort had a business value of its own.
this refactoring also involved breaking inter module dependencies by moving a set of related functionality apis from one binary to another binary or new binaries .
so without taking all of stack they can take just the pieces that they want.
so ideally this low layer piece we could release at a much faster cadence right?
the reason we re the refactoring is considered as an important reason as the feature itself.
how did you carry out system wide refactorings on a very large system?
the refactoring team made significant effort to analyze the de facto binary level dependency structure before making refactoring decisions.
after the initial analysis of binary level dependencies the team came up with a layered architecture where individual binaries were assigned with layer numbers so that the partial ordering dependency relationships among binaries could be documented and enforced.
to help with the analysis of de facto dependency structure the team used a new tool called max .
max not only computes binary level dependencies but also can distinguish benign dependency cycles within a layer from undesirable dependencies that go from low level layers to the layers above.
furthermore the refactoring team consulted other teams about how to decompose existing functionality into a set of logical sub groupings layers .
our goal was actually a to understand the system and to develop a layered model of the system and b to protect the model programmatically and automatically.
so by developing a mathematical model of the entire system that is based on layer numbers and associating binaries with a layer number we could enforce a partial ordering that s what we call it the layer map.
the refactoring team led centralized architecting effort while preventing architectural degradation by other teams.
the team introduced new quality gate checks which prevented developers from committing code changes that violate the layer architecture constraints to the version control system.
furthermore the refactoring team educated otherteams about how to use new apis to be compliant with the layered architecture constraints.
the refactoring team then refactored the existing system by splitting existing binaries into sub component binaries or by replacing existing binaries with new binaries.
it turns out that if you do centrally you can do a lot of this stuff for other teams.
we give them the code and they have a test team and their test team evaluates what they need to retest when they take the code.
so we do the integration for them.
.
.
we have this completely automated so when you add a dependency to something it goes through this entire quality gate process where the binaries get analyzed using whole program analysis techniques.
in addition the refactoring team created two custom software engineering tools to ease migration of existing binary modules to new binary modules.
similar to how java allows creation of abstract classes which later can be bound to concrete subclasses the team created a technology that allows other teams to import an empty header binary for each logical group of api family which can be later bound to a concrete binary implementation depending on the system configuration.
then a customized loader technology loads an appropriate target binary implementation instead of the empty header binary during the binary loading time.
this technology emulates dynamic dispatching in object oriented programming style and has two benefits.
it separates api contracts from api implementations thus avoiding inclusion of unnecessary binaries in a different execution environment where only a minimal functionality instead of a full functionality is desired.
it enables product line development variant products are built by composing different binary implementations.
the above technology takes care of switching between two different api implementations during load time but does not take care of cases where the execution of two different api implementations must be weaved carefully during runtime.
to handle such cases the team systematically inserted program changes to existing code.
such code changes followed a special coding style guideline for better readability and were partially automated by stub code generation functionality.
in summary we found that the refactoring effort had the following distinctive characteristics the refactoring effort was driven by foresights to repurpose the existing system to target different execution environments.
thus the refactoring had a business value of its own.
the team s refactoring decisions were made after substantial analysis of a de facto dependency structure.
the refactoring effort was centralized and top down the designated team made software changes systematically integrated the changes to a main source tree and educated others on how to use new apis while preventing architectural degradation by others.
the refactoring was enabled and facilitated by development of custom refactoring support tools and processes such as max and quality gate check .
.
quantitative analysis of windows version history to examine whether the refactoring done by this team had a visible benefit we analyzed windows version history data.
we examined the impact of refactoring on two specific software measures dependencies anddefects .
because the primary goal of the windows refactoring team was to reduce undesirable dependencies between binary modules as mentioned in section .
we measured reduction in intermodule dependencies to check whether the refactoring team indeed achieved their goal of dependency reduction.
we then focused on the relationship between refactoring and defects because many of our survey participants perceived that refactoring comes with a risk of introducing defects and regression bugs.
we identified the branches that the designated refactoring team created to apply and maintain refactoring changes exclusively and isolated changes from those branches.
in windows all changes are made to specific branches and later merged to the main trunk.
we believe that our method of identifying refactorings is reliable as a designated team confirmed all refactoring branches manually and reached a consensus about the role of those refactoring branches within the team.
during windows development .
of changes were changes made to the refactoring branches owned by the refactoring team .
of changes were made to non refactoring branches.
the number of committers who worked on the refactoring branches was .
while the number of committers on non refactoring branches was .
.
note that the sum of the two is greater than because some committers work both on refactoring branches and non refactoring branches.
.
of binaries were affected by at least one change from the refactoring branches and .
of binaries were affected by at least one change from non refactoring branches.
in our study refactored binaries are binaries where at least one change from the refactoring branches is compiled into.
for example if the refactoring team made edits on the refactoring branches to split a single vista binary into three binaries in windows we call the three binaries as refactored binaries in windows .
.
.
data collection for our study we used a binary module level analysis as this unit is typically used for program analysis within microsoft and the smallest units to which defects are accurately mapped.
here a binary refers to an executable file com exe etc.
or a dynamic link library file dll shipped with windows.
binaries are assembled from several source files and typically form a logical unit e.g.
user32.dll may provide programs with functionality to implement graphical user interfaces.
a software dependency is a directed relation between two pieces of code such as expressions or methods.
there exist different kinds of dependencies data dependencies between the definition and use of values and call dependencies between the declaration of functions and the sites where they are called.
microsoft has an automated tool called max that tracks dependency information at the function level including calls imports exports rpc com and registry access.
max generates a system wide dependency graph from both native x86 and .net managed binaries.
max is used for change impact analysis and for integration testing .
for our analysis we generateda system wide dependency graph with max at the function level.
since binaries are the lowest level of granularity to which defects can be accurately mapped back to we lifted this graph up to the binary level in a separate postprocessing step.
microsoft records all problems that are reported for windows in a database.
in this study we measured the changes in the number of post release defects defects leading to failures that occurred in the field within six months after the initial releases of windows vista or windows .
we collected all problem reports classified as non trivial in contrast to enhancement requests and for which the problem was fixed in a later product update.
the location of the fix is used as the location of the post release defect.
to understand the impact of windows refactoring we compared the number of dependencies and the number of post release defects at the binary level between windows vista and windows .
.
.
where was the refactoring effort focused on?
figure shows the cumulative ratio for three windows vista dependency related measures for refactored binaries ranked in descending order by the number of refactorings the cumulative number of outgoing dependencies i.e.
outgoing dependencies the cumulative number of the sum of incoming and outgoing dependencies i.e.
total dependencies and the cumulative number of neighbor binaries connected via dependencies i.e.
neighbors .
between two binaries multiple dependencies could exist but they are counted only once as neighbors.
the cumulative ratio for each measure is computed as the relative cumulative sum for its values up to the x th most frequently refactored binary normalized by the total sum of the values for all n binaries see the equation below .
y p i x v alue p i n v alue the arrow in figure indicates that the top most refactored binaries cover .
of all neighbor relationships in vista for modified binaries.
top most refactored binaries cover .
of all neighbor relationships in vista for modified binaries.
the percentages are similar for total number of dependencies .
for top and .
for top and outgoing dependencies .
for top and .
for top .
these results indicate that the refactoring effort was focused on binaries with a large number of dependencies in vista.
this is consistent with what the refactoring team said in the interviews their goal is to break a large number of unwanted dependencies between certain modules.
.
.
did refactoring reduce binary level dependencies?
while the total of number of binary level dependencies among modified binaries increased from windows vista to windows most frequently refactored components contributed to reduction of dependencies.
consider the plot in figure in which the delta neighbors refactored dll line shows the cumulative ratio of the differences in the number of dependency neighbors for the top x percent of most frequently refactored binaries.
the delta neighbors all changed dlls line shows the cumulative ratio of the differences in the number of dependency neighbors for the top figure the cumulative ratio of vista dependencies vs. ratio refactored binaries.
figure the cumulative ratio of the changes in the number of inter module dependencies between vista and windows vs. ratio refactored binaries.
x percent of most frequently modified binaries.
along thex axis the refactored binaries are ranked in descending order by the number of refactorings.
in other words the difference between the delta neighbors all changed dlls line and the delta neighbors refactored dlls line is that binaries are ordered by the number of refactoring commits as opposed to the number of regular commits along the x axis.
the delta neighbors refactored dlls line remains below zero until .
meaning that the top of most frequently refactored binaries did not increase the total number of dependencies.
note that in the left bottom corner thedelta neighbors all changed dlls line stays above the delta neighbors all refactored dlls line implying that the group of most frequently modified binaries increase the total number of neighbor dependencies more than the group of most refactored binaries.
figure shows a bar chart that compares the changes to the total number of neighbor dependencies per binary from windows vista to windows for the top top to top to andfigure changes to the total number of neighbors per binary figure the cumulative ratio of defects in windows for modified binaries vs. refactored binaries top to of most refactored binaries dark gray and most modified binaries light gray the values are normalized to the total increase for all modified binaries.
for example if the total number of neighbors per binary increased by on average for modified binaries the total number of neighbors increased only by .
per binary for the top of most frequently refactored binaries while the corresponding top of most frequently modified binaries increased by .
on average.
the increase is statistically significant at p .
paired wilcoxon test .
the bar chart indicates that the increase in the number of binarylevel dependencies is relatively lower for most frequently refactored binaries than most frequently modified binaries.
.
.
are refactored binaries more likely defect prone than non refactored binaries?
figure shows the cumulative ratio for post release defects in windows for the binaries with most refactorings gray line and most churn black line the churn is computed in terms of the number of regular commits.
while the number of windows post release defects is slightly correlated with the number of refactorings the correlation is figure changes to the total number of postrelease defects per binary weaker than for churn spearman correlation of .
vs. .
also indicated by orange line below red line .
this implies that refactoring changes are less likely to lead to post release defects than regular changes .
in other words while a previous study of defect prediction in windows by nagappan and ball found code churn to be highly correlated with defects and is a good predictor of bugs refactoring churn is likely to be relatively more safe and reliable than regular churn.
the top of most frequently refactored binaries are responsible for .
of windows post release defects while the top of most modified binaries are responsible for .
.
the top of most frequently refactored binaries are responsible for .
of windows post release defects while the top of most modified binaries are responsible for .
.
.
.
did refactoring reduce post release defects more?
most binaries that were released in windows vista have fewer post release defects in windows .
figure shows that the top of refactored binaries have percent more reduction in post release defects compared to all modified binaries.
the spearman correlation between the amount of refactoring and change in post release defects is .
and statistically significant at p .
the more refactoring changes the higher the decrease in post release defects.
we also computed the cumulative ratio of vista defects vs. ratio of refactored binaries that are ranked in descending order by the number of refactorings.
the linear increase in the cumulative number of defects shows that the modules refactored by the refactoring team did not necessarily focus on the modules with a large number of defects in vista.
yet looking at figure we see that these refactored modules experienced significant reduction in the number of defects in windows compared to vista.
these results indicate that windows refactoring is correlated with reduction in the number of defects.
.
threats to validity internal validity.
our findings in section indicate only correlation between the refactoring effort and reduction the number of inter module dependencies and post release defects notcausation there are other confounding factors such as the expertise level of developers that we did notexamine.
it is possible that the changes to the number of binary dependencies and post release defects in windows are caused by factors other than refactoring such as the types of features added in windows .
construct validity.
construct validity issues arise when there are errors in measurement.
this is negated to an extent by the fact that the entire data collection process of failures and vcs is automated.
when selecting target participants for refactoring we searched all check ins with the keyword refactor based on the assumption that people who used the word know at least approximately what it means.
the definition of refactoring from developers perspectives is broader than behavior preserving transformations and the granularity of refactorings also varies among the participants.
for example some survey participants refer to fowler s refactorings while a large number of the participants consider that refactorings are often a part of larger higher level effort to improve existing software.
in our windows case study we focused on systemwide refactoring because such refactoring granularity seems to be aligned with the refactoring granularity mentioned by a large number of the survey participants.
external validity.
in our case we came to know about a multi year refactoring effort in windows from several survey participants and to leverage this best possible scenario where intentional refactoring was performed we focused on the case study of windows.
as opposed to formal experiments that often have a narrow focus and an emphasis on controlling context variables case studies test theories and collect data through observation in an unmodified setting.
while we acknowledge that our case study on windows may not generalize to other systems most development practices are similar to those outside of microsoft.
furthermore developers at microsoft are highly representative of software developers all over the world as they come from diverse educational and cultural backgrounds.2we believe that lifting the veil on the windows refactoring process and quantifying the correlation between refactoring and defect and dependency reduction could be valuable to other development organizations.
to facilitate replication our study outside microsoft we published the full survey questions as a technical report .
.
conclusions and future work this paper presents a three pronged view of refactoring in a large software development organization through a survey interviews and version history data analysis.
to investigate a de facto definition and the value perception about refactoring in practice we conducted a survey with over three hundred professional software engineers.
then to examine whether the survey respondents perception matches reality and whether there are visible benefits of refactoring we interviewed a subset of engineers who led the windows refactoring effort and analyzed windows version history data.
our study finds the definition of refactoring in practice is broader than behavior preserving program transformations .
developers perceive that refactoring involves substantial cost and risks and they need various types of refactoring support beyond automated refactoring within ides.
our case study of windows shows how system wide refactoring was carried 2global diversity and inclusion come about diversity en us default.aspxout in a very large organization.
the quantitative analysis of windows version history shows refactored modules experienced higher reduction in the number of inter module dependencies and post release defects than other changed modules.
our study is one of the first to show that refactoring changes are likely to be relatively more reliable than regular changes in a large system.
based on our study we propose future research directions such as tool support for refactoring aware code reviews refactoring cost and benefit estimation etc.