effective dynamic detection of alias analysis errors jingyue wu gang hu y ang tang junfeng y ang columbia university united states jingyue ganghu ty junfeng cs.columbia.edu abstract alias analysis is perhaps one of the most crucial and widely used analyses and has attracted tremendous research efforts over the years.
yet advanced alias analyses are extremely difficult to get right and the bugs in these analyses are one key reason that they have not been adopted to production compilers.
this paper presents neongoby a system for effectively detecting errors in alias analysis implementations improving their correctness and hopefully widening their adoption.
n eongoby detects the worst type of bugs where the alias analysis claims that two pointers never alias but they actually alias at runtime.
n eongoby works by dynamically observing pointer addresses during the execution of a test program and then checking these addresses against an alias analysis for errors.
it is explicitly designed to be agnostic to the alias analysis it checks for maximum applicability and ease of use and detect alias analysis errors that manifest on real world programs and workloads.
it emits no false positives as long as test programs do not have undefined behavior per ansi c specification or call external functions that interfere with our detection algorithm.
it reduces performance overhead using a practical selection of techniques.
evaluation on three popular alias analyses and real world programs apache andmysql shows that n eongoby effectively finds alias analysis bugs with zero false positives and reasonable overhead the most serious four bugs have been patched by the developers.
to enable alias analysis builders to start using n eongoby today we have released it open source at along with our error detection results and proposed patches.
categories and subject descriptors d. .
software program verification d. .
testing and debugging f. .
semantics of programming languages general terms algorithms design reliability experimentation keywords error detection alias analysis dynamic analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
copyright acm ... .
.
.
introduction alias analysis answers queries such as whether pointers pandq may point to the same object.
it is perhaps one of the most crucial and widely used analyses and the foundation for many advanced tools such as compiler optimizers bounds checkers and verifiers .
unsurprisingly a plethora of research over the last several decades has been devoted to improve the precision and speed of alias analysis and pldi and popl alone have accepted over alias analysis papers since .
most citation lists in this paragraph are seriously incomplete for space.
unfortunately despite our reliance on alias analysis and the tremendous efforts to improve it today s production compilers still use the most rudimentary and imprecise alias analyses.
for instance the default alias analysis in llvm for code generation basicaa simply collapses all address taken variables into one abstract location the default alias analysis in gcc is type based and marks all variables of compatible types aliases.
these imprecise analyses may cause compilers to generate inefficient code .
we believe one key reason hindering the adoption of advanced alias analyses is that they are extremely difficult to get right.
advanced alias analyses tend to require complex implementations to provide features such as flow sensitivity context sensitivity and field sensitivity and to handle corner cases such as c unions external functions function pointers and wild void andintcasts.
as usual complexity leads to bugs.
buggy alias results at the very least cause research prototypes to yield misleading evaluation numbers.
for instance our evaluation shows that llvm s anders aa implementing an interprocedural andersens s algorithm appeared more precise than basicaa but is actually lessprecise than basicaa .
.
after we fixed anders aa bugs.
worse buggy alias results cause optimizers to generate incorrect code commonly believed to be among the worst possible bugs to diagnose.
moreover they compromise the safety of bounds checkers and verifiers yet this safety is crucial because these tools often have high compilation runtime or manual overhead and are applied only when safety is paramount.
this paper presents n eongoby 1a system for effectively detecting errors in alias analysis implementations improving their correctness and hopefully vastly widening their adoption.
n eongoby detects the worst type of bugs where the alias analysis claims that two pointers never alias but they actually alias at runtime.
we explicitly designed n eongoby to be agnostic to the alias analysis it checks the only requirement is a standard mayalias p q api that returns true if pandqmay alias and false otherwise.2this minimum requirement ensures maximum applicability and ease of use.
to check an alias analysis with n eongoby a user additionally chooses a test program and workload at her will.
for instance 1we name our system after the neon goby fish which helps other fish by cleaning external parasites off them.
2neongoby can be easily extended to check must alias but few alias analyses implement a more than shallow must alias analysis.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
esec fse august saint petersburg russia acm she can choose a large program such as apache andmysql and a stressful workload that together exercise many diverse program constructs such as the corner cases listed in the previous paragraph.
this flexibility enables n eongoby to catch alias analysis bugs that manifest on real world programs and workloads.
neongoby works as follows.
given a test program n eongoby instruments the program s pointer definitions to track pointer addresses.
to increase checking coverage n eongoby instruments all pointer definitions including intermediate results e.g.
pointer arithmetics.
the user then runs the instrumented program on the workload and n eongoby dynamically observes pointer addresses henceforth referred to as addresses and checks them against the alias analysis.
it emits bug reports if the addresses contradict the alias results i.e.
the pointers did alias during the test run but the alias analysis states that the two pointers never alias.
we use didalias p q to refer to n eongoby s algorithm for determining whether pointers pandqdid alias.
the invariant neongoby checks is thus didalias p q !mayalias p q .
to ease discussion we use didalias mayalias to refer to both the corresponding algorithm and the set of pointer pairs on which didalias mayalias returns true.
although the idea of dynamically checking alias analysis enjoys conceptual simplicity implementing it faces two major challenges performance overhead and false positives.
performance overhead.
neongoby must have low performance overhead for two reasons.
first n eongoby is designed to detect alias analysis errors that manifest on real world programs and large overhead may disturb the executions of these programs such as triggering excessive timeouts.
second different users may have different resource budgets and coverage goals when testing their alias analyses.
since users can best decide what overhead is reasonable n eongoby should provide them the flexibility to make their own tradeoffs between bugs and overhead.
neongoby addresses this challenge using two ideas.
first neongoby provides two checking mode enabling a user to select the mode best suited for her alias analysis test program and workload.
in the offline mode n eongoby logs pointer definitions to disk when running the test program and checks the log offline after the test run finishes.
since checking does not slow down the test run n eongoby affords to check more thoroughly it checks alias queries on pointers potentially in different functions or interprocedural queries .
however the logging overhead in the offline mode may be high so n eongoby offers another mode to reduce overhead.
in the online mode n eongoby checks alias queries on pointers only in the same function or intraprocedural queries with efficient inlined assertions but it may miss some bugs the offline mode catches.
second n eongoby further reduces performance overhead without losing bugs using an optimization we call delta checking .
this optimization assumes a correct baseline alias analysis such as llvm s basicaa often simple enough to have few bugs.
n eongoby then checks only the pointer pairs that may alias according to the baseline but not the checked alias analysis.
by reducing the pointer pairs to check n eongoby reduces overhead.
false positives.
another challenge n eongoby faces is how to reduce false positives or fps a major factor limiting the usefulness and adoption of error detection tools .
recall that n eongoby checks the invariant didalias p q !mayalias p q .
therefore n eongoby may emit fps if the didalias set it computes incorrectly includes pointer pairs that did not alias.
didalias may 3intraprocedural queries can still be answered by interprocedural analyses.
no alias if field sensitive struct char f1 char f2 s p s f1 q s f2 no alias if flow sensitive for i i i p addr q addr p s address is addr no alias if context sensitive void foo int p int q .
.
.
p and q do not alias foo addr0 addr1 foo addr1 addr0 figure fp examples caused by sensitivities.
be incorrect for two main reasons first a na ve didalias algorithm may not account for all sensitivities that a checked alias analysis offers.
figure shows three examples on which a na ve didalias may cause fps.
specifically if a na ve didalias considers pointers with one byte apart as aliases because they likely point to the same object it may cause a fp for a field sensitive alias analysis on the first example.
if it considers pointers ever assigned the same address as aliases it may cause a fp for a flow sensitive alias analysis on the second example or for a context sensitive alias analysis on the third example.
if it does not distinguish the same variable in two different invocations of foo it may cause a fp for a context sensitive alias analysis on the third example.
to reduce such fps while remaining agnostic to the alias analysis checked n eongoby must provide a didalias that accounts for all sensitivities that a checked alias analysis may offer.
second the same observed address of a pointer is not always intended to refer to the same object due to spatial memory layout or temporal memory reuse.
spatially pointers may have invalid addresses e.g.
go off bound or are uninitialized .
for instance an off by one pointer for marking the end of an array may accidentally have the same address as a pointer to the next object.
off byone pointers are allowed by ansi c specification as long as they are not dereferenced.
therefore n eongoby must handle them to avoid fps.
temporally the same piece of memory may be reused for different objects.
for instance two heap memory allocations may return the same address if the first allocation is freed before the second allocation.
thus n eongoby cannot simply claim that two pointers did alias if their addresses are identical instead it may need to track whether a pointer is valid and if so what object it points to.
this problem appears familiar to the problem bounds checkers solve but it is actually very different n eongoby assumes that a test program is largely correct and runs it to detect alias analysis errors whereas bounds checkers are for preventing buffer overflow attacks.
thus it is an overkill for n eongoby to borrow complex bounds checking techniques such as tracking base and bounds for each pointer.
neongoby addresses this challenge using two ideas.
first when computing didalias neongoby considers two pointers alias only when they have the same address simultaneously at a point in an execution.
this idea makes didalias field sensitive flow sensitive and context sensitive.
for instance in the first example in figure n eongoby considers pandqdo not alias because their addresses are different.
in the second example n eongoby considers pandqdo not alias even if ppoints to addr in the first iteration.
in the third example although qin the first invocation and pin the second invocation point to the same ad 280void bar int r r raliases q intmain int p int malloc sizeof int free p int q int malloc sizeof int memory reuse bar q free q return figure example test program.
dress n eongoby does not report pandqalias because these two pointer definitions belong to different invocations.
second n eongoby bridges the gap between an address and an object using a practical selection of techniques.
for instance n eongoby versions memory so if a piece of memory is reused the addresses before and after the reuse get different versions it also pads memory allocation to tolerate off bound pointers.
these two ideas enables n eongoby to avoid all fps for test programs that do not have undefined behavior per ansi c specification e.g.
using pointers off bound by many bytes or call external functions unknown to n eongoby that return reused memory addresses .
.
we implemented n eongoby within the llvm compiler and checked three popular llvm alias analyses including the aforementioned basicaa llvm s default alias analysis the aforementioned anders aa later used as the basis for two alias analyses and ds aa a context sensitive field sensitive algorithm with full heap cloning later used by .
to check these analyses we selected two real world programs mysql andapache and the workloads their developers use.
n eongoby found bugs in anders aa andds aa including previously unknown bugs with zero fps and reasonable overhead.
we have reported eight bugs to ds aa developers and four most serious ones have been patched .
this paper makes four main contributions our formulation of an approach that dynamically checks general alias analysis with the invariant didalias p q !mayalias p q n eongoby a long overdue system toward improving advanced alias analyses into production quality and widening their adoption a practical selection of techniques to reduce overhead and fps and our evaluation results including real bugs found in two llvm alias analyses and our proposed patches.
our key inspiration is our anecdotal struggles with some existing alias analyses in our research so we hope that alias analysis builders can start applying n eongoby to improve their alias analyses into productionquality analyses today.
as such we have released it open source at along with our error detection results and proposed patches.
.
an example and overview figure shows an example test program.
it has three pointers p andqin function main and rinbar.
among these pointers only qandralias.
suppose buggyaa a buggy alias analysis misses this only alias pair and reports no alias for all pointers.
to check buggyaa with this test program using the offline mode of n eongoby a user first compiles the code into example.bc in llvm s intermediate representation ir and runs the following three commands neongoby offline instrument example.bc .
example.inst neongoby check example.bc example.log buggyaathe first command instruments the program for checking it transforms the program to avoid fps caused by memory reuse offbound pointers and undefined values and it inserts a logging operation at each pointer definition memory allocation function entry and exit to log information for offline checking.
the second command runs the instrumented program example.inst to generate a log of pointer definitions memory allocations and function calls and returns.
the third command checks this log against buggyaa for errors.
it first computes didalias for all three pairs of pointers including pointers not in the same function.
it excludes pair p q and pair p r from didalias even if the two malloc calls return the same address because the versions of the address are different.
it includes pair q r indidalias because qandrshare the same address and version.
n eongoby then checks didalias against buggyaa emitting an error report because mayalias q r returns false.
to diagnose this error the user can run n eongoby to dump log records or slice the log for records explaining why qandrdid alias .
.
to check buggyaa with this test program using the online mode of n eongoby a user runs the following commands neongoby online example.bc buggyaa .
example.ck the first command iterates through each function in example.bc queries buggyaa on each pair of pointers in the function and if mayalias on the two pointers returns false embeds an assertion that the two pointers never alias at runtime.
in this example n eongoby embeds an assertion assert p!
q p null after the second malloc .
the online mode prevents the two memory allocations from returning the same address using a simple trick of deferring memory deallocation.
the second command runs the instrumented program example.ck to check whether this assertion may be triggered which never happens.
each mode of n eongoby has pros and cons.
the offline mode checks more thoroughly whereas the online mode checks only intraprocedural queries missing the bug in buggyaa .
the offline mode can reuse one log to check multiple alias analyses amortizing the cost of running the tests whereas the online mode can check only one alias analysis at a time.
however the offline mode has to log information to disk because the log may grow larger than the ram for some real world programs and workloads and on disk logging can be costly.
in contrast the inlined assertions the online mode embeds are much faster to check.
by providing two modes of operations n eongoby enables a user to select the mode that suits her purpose.
.
offline mode this section describes how n eongoby operates in the offline mode.
figure shows the offline mode architecture.
it has three components the instrumenter logger and offline detector .
given a program in llvm s intermediate representation ir a more lowlevel representation of the program than source code the instrumenter transforms the program to avoid fps and inserts logging operations to collect runtime information.
when a user runs the instrumented program the logger records pointer definitions memory allocations function entries and exits to disk.
since the logger runs within a test program we explicitly designed it to be simple and stateless reducing runtime overhead and avoiding perturbing the execution of the test program.
after the run finishes the offline detector checks the log against an alias analysis and emits error reports.
since the logger is much simpler than the other components we focus on describing the instrumenter .
and offline detector .
and give a brief discussion .
.281offlinedetectorinstrumenterprogramaliasanalysisbugreportspointer loginstrumentedprogramloggerworkloadfigure architecture of the offline mode.
.
instrumenter the instrumenter does six main transformations the first to ensure that the logger and the offline detector can consistently refer to the pointer variables in a program the second to collect pointer addresses and the last three to reduce fps caused by memory reuse off bound pointers and undefined values.
we describe the six transformations below and highlight some of the differences between neongoby and bounds checkers.
assigning ids to pointers.
the logger and offline detector run in different phases so they need a consistent way to refer to the pointers in a program.
to identify the pointers the instrumenter traverses the program s control flow graph and assigns to the nth visited static pointer variable a numeric id of n. to keep ids consistent the offline detector uses the same deterministic algorithm depth first traversal in our implementation to assign ids to pointers.
bounds checkers need not assign ids to pointers because they cannot defer checking to offline.
to check alias analyses more thoroughly n eongoby identifies not only the pointer variables in the source code but also intermediate pointers in the llvm ir.
instrumenting pointer definitions.
to catch errors caused by all different types of pointers n eongoby instruments all pointer definitions which assign addresses to pointers.
function pointers and global pointers are particularly crucial they are widely used in realworld programs such as mysql andapache yet they are often mishandled by alias analyses.
our experiments found bugs caused by mishandled function and global pointers .
.
.
neongoby logs four types of pointer definitions pointer assignment p addr where addr can be a pointer arithmetic pointer load p addr function argument passing and global variable initialization.
n eongoby instruments all pointer definitions in the llvm ir including intermediate results.
for instance llvm translates c source code p o f into two ir instructions o offset of f p load and n eongoby instruments the definitions of both 1and p. neongoby instruments a pointer assignment or load by inserting log ptr ptr addr right after the definition where ptr isp s statically assigned id addr is the address assigned and log ptr is a logging operation that when executed appends the id and the assigned address to the current on disk log.
n eongoby adds calls to log ptr similarly for function arguments at function entries and for global variables at the entry of the main function.
bounds checkers must also track these pointer definitions to propagate pointer base and bound information.
instrumenting memory allocations.
as discussed in n eongoby cannot use only addresses to compute didalias becausethe same address may point to different objects if memory is reused.
to enable the offline detector to handle memory reuse n eongoby instruments all memory allocations including the allocations of heap stack and global variables.
although global memory cannot be reused n eongoby also instruments it to handle all memory allocations uniformly.
for each allocation it inserts log alloc addr size to record the allocation address and size.
for stack variables n eongoby inserts log alloc at the function entry.
for global variables n eongoby inserts log alloc at the entry of main .
for heap variables n eongoby inserts log alloc after a call to one of the following functions .
c memory allocation functions malloc calloc valloc realloc and memalign .
c new mangled names znwj znwm znaj and znam .
other library functions strdup strdup and getline .
users can easily add more heap allocation functions.
one tricky point is that a memory allocation such as p malloc ... is also a pointer definition and n eongoby must insert log alloc before log ptr for the offline detector to correctly handle memory reuse .
.
another point is that llvm shares memory between two constant strings for space if one is the suffix of the other to avoid these false aliases n eongoby disables this optimization.
to reduce logging overhead n eongoby does not instrument memory deallocations such as free calls and relies on the offline detector to lazily discover when memory is freed.
thus a corner case such as free q p q may cause n eongoby to emit fps on a flow sensitive alias analysis that understands free although pandqhave the same address they technically point to nothing.
however use after free behavior is undefined per ansi c standard.
therefore as long as the test program is correct n eongoby emits no fps of this type.
bounds checkers in contrast must handle memory deallocations if they want to catch use after free errors.
instrumenting function entries and returns.
neongoby needs to distinguish the same variable in different invocations of a function to reduce fps on a context sensitive alias analysis.
to track function invocations for each function n eongoby inserts log entry func at the entry and log ret func before each return where func is the id of the function.
handling off bound pointers.
pointers may be assigned offbound addresses that accidentally alias other pointers causing fps.
fortunately most programs use off bound pointers only to mark the ends of arrays and these pointers are off by only one byte.
this type of off bound pointer is also the only type allowed by the ansi c standard.
to eliminate fps caused by off by one pointers n eongoby transforms a program to add one extra byte for each memory allocation a technique borrowed from .
n eongoby currently does not handle other off bound pointers because they occur very rarely and we experienced no fps caused by these pointers in our experiments .
.
.
bounds checkers in contrast may have to handle these pointers because their fps are fatal and abort executions.
handling undefined values.
variables may be uninitialized and have undefined pointer values that accidentally look like addresses of other pointers.
these values may further propagate through assignments such as assignments of a struct with an uninitialized pointer field to another struct causing n eongoby to log bogus addresses and emit fps.
n eongoby handles undefined pointer values by setting them to null because null aliases nothing.
resetting undefined pointer values eliminates fps caused by undefined values as long as the test program is correct because ansi c specification disallows using an uninitialized variables e.g.
pointer arithmetics or wild void andintcasts.
.
offline detector given a log of pointer definitions and memory allocations neongoby s offline detector finds alias analysis errors in two steps it scans the log to compute the didalias results and then checks didalias against an alias analysis and emits error reports.
from a high level n eongoby computes didalias results as follows.
to distinguish a pointer in different function invocations neongoby assigns a unique context number to each invocation and maintains a call stack csof context numbers.
it also maintains two maps a conceptual map vfrom an address to a version number for handling memory reuse and a map pfrom a pointer s unique id and its context number to an address and version for tracking where pointers point to.
we use definition to refer to a pointer context pair and location to refer to an address version pair.
given a log n eongoby scans the records sequentially from the beginning.
upon a memory allocation record n eongoby updatesvto assign a new version number for the addresses within the allocated range so the same addresses get different versions before and after this allocation.
upon a function entry record n eongoby generates a new context number for this invocation and pushes it to the call stack.
correspondingly upon a function return record neongoby pops the call stack so that the caller s context number will be on top.
upon a pointer definition record lwith pointer ptrand address addr neongoby searchesvforl addr s current version and updates pto makehl ptr top cs ipoint to locationhl addr v i. it then searches pfor pointer definitions that point to the same location for each such pointer definition d it addshl ptr d ptriandhd ptr l ptritodidalias unlessd ptr andl ptr are in the same function and their contexts are different.
note thathl ptr l ptriis in didalias because a pointer aliases itself.
as discussed in n eongoby must be very precise when computing didalias to avoid fps.
the algorithm described above is field sensitive because it considers that two pointers did alias only when their locations are identical which requires their addresses to be identical.
it is context sensitive because each invocation gets a unique context number and two pointers in the same function did alias only when they point to the same location in the same context.
it is flow sensitive because the ssa form of llvm ir guarantees each pointer is statically defined only once which provides some flow sensitivity already and map pmaintains only the latest location of a pointer definition.
once n eongoby computes the didalias results it checks an alias analysis as follows.
it iterates through each pointer pair in didalias and checks that the pair is also in mayalias .
it emits an error report otherwise.
since the didalias results do not depend on the alias analysis checked n eongoby can reuse them to check multiple alias analyses amortizing the cost of logging and computing didalias .
our actual algorithm to detect errors offline shown in algorithm does three optimizations for space and speed.
the first optimization implements the address to version map vwith an interval tree whose key is an address range and value the version number of the entire address range lines and .
an interval tree is much more space efficient than a version number per address.
upon a memory allocation record n eongoby removesv s existing address ranges that overlap with the allocated range because these ranges must have been freed increments a global version number and inserts the new range and version to v. second instead of scanning the pointer map pfor pointers that point to the same location n eongoby maintains a reverse mapqfrom a location back to pointers lines and .
third when entering a function n eongoby removes fromalgorithm offline detection algorithm input program prog alias analysis a and logl 1offlinedetection prog a l 2p hnull 0i definition to location map 3q location to definitions map 4v address to version map 5vg global version number 6cg global context number 7cs call stack didalias pointer pairs that did alias ap active pointers foreach recordl2ldo iflis memallocrecord then vg vg v vg else iflis entryrecord then foreach contextcofl callee s.t.c 2csdo foreach p2ap do def hp ci q q ndef p hnull 0i ap cg cg push cs cg push cgonto cs else iflis returnrecord then pop cs else iflis pointerrecord then c ifcs6 then c top cs def hl ptr ci ifp hnull 0ithen q q ndef p hnull 0i ifl addr is null then continue loc hl addr v i p loc q q def ap ap def ptr foreach definitiond2q do parent p returnsp s containing function ifparent d ptr parent def ptr or d context def context then didalias didalias hdef ptr d ptri didalias didalias hd ptr def ptri foreachhp qi2didalias do ifnota.mayalias p q then reporterror hp qi palloutdated pointer definitions in this function lines .
neongoby considers a pointer definition outdated if its context number is no longer on the call stack.
without removing outdated definitions jpjcould be very large because a pointer can be defined in many function invocations.
to efficiently implement this optimization we use another mapping ap to maintain all active i.e.
non outdated pointer definitions indexed by context numbers.
with these optimizations the space complexity of our algorithm iso jpj jmj jdidaliasj and the time complexity is o jlj logjmj logjpj nlogjdidaliasj wherejmjis the number of memory allocations in the log and nis the maximum283table different techniques in bounds checkers and n eon goby.
bounds n eongoby online only yes no use alias analysis maybe no pointer definition yes yes pointer metadata yes no pointer dereference yes no allocation yes yes deallocation yes no off bound pointer yes only off by one undefined value yes only pointer size ofq .
in our experiments nnever exceeds jmj is typically ofjlj and the size of didalias is less than .
.
discussion some of the problems n eongoby addresses such as tracking pointer definitions and handling memory reuse off bound pointers and undefined values overlap with what bounds checkers must handle.
however n eongoby has very different assumptions and goals than bounds checkers it assumes a test program is largely correct and uses the program to detect errors in alias analyses whereas bounds checkers prevent buffer overflow attacks to a program.
false negatives in bounds checkers may lead to exploits and fps wrongly abort executions.
in contrast the effects of n eongoby s fps and negatives are much less serious.
because of these differences it is an overkill for n eongoby to borrow complex bounds checking techniques.
table summarizes the different techniques in typical bounds checkers and n eongoby.
bounds checkers must check buffer overflows online to stop exploits whereas n eongoby can defer costly detection completely offline.
bounds checkers may assume a correct alias analysis and other static analyses and use them to remove unnecessary checks whereas n eongoby is intended to detect errors in alias analyses.
bounds checkers need to maintain pointer base and bound information with fat pointers maps or trees which break backward compatibility or have high overhead.
in contrast n eongoby maintains no pointer metadata.
bounds checkers check pointer dereferences and track memory deallocations to catch bugs whereas n eongoby does neither.
bounds checkers may need to accurately handle pointers off by more than one bytes and undefined integer values to avoid wrongly aborting executions whereas n eongoby ignores these cases.
.
online mode neongoby s offline mode checks interprocedural alias queries to find more bugs but its logging may be costly.
thus n eongoby provides an online mode to reduce performance overhead.
this section describes how n eongoby operates in the online mode.
algorithm online mode input program prog and alias analysis a 1onlineinstrumentation prog a foreach functionf2prog do foreach pointer definition pair hp qi2fdo ifpreachesqandnota.mayalias p q then insert assert p6 qorpisnull afterq foreach external function call cfreeing a heap object do replacecwith call deferred free the online mode focuses on checking intraprocedural queries because they are often considered more crucial than interprocedural queries.
for instance compiler optimizations tend to issuemostly intraprocedural queries.
to check intraprocedural queries neongoby embeds the alias analysis checks as regular program assertions into a test program.
n eongoby reports an alias analysis bug if one of the assertions fails when a user runs the test program.
these assertions are much cheaper than costly on disk logging at runtime as shown in our experiments .
.
algorithm shows the algorithm to embed the checks.
it iterates through each pair of point definitions pandqof a function line and inserts an assertion assert p!
q p null line ifmayalias p q returns false line .
one issue is that the inserted assertion requires that both pandqare defined.
n eongoby solves this issue with a standard control flow reachability analysis line and inserts the assertion only if p s definition reaches q. if pointer pis undefined along some incoming edges to q s basic block n eongoby creates a new instruction using llvm s ssa transformation not shown in algorithm .
similar to the offline mode didalias computed in the online mode is very precise.
it is field sensitive because an assertion fails only when p q it is flow sensitive because an assertion uses the latest addresses of the pointers it is context sensitive because it focuses on intraprocedural queries.
to avoid fps caused by memory reuse off bound pointers and undefined values the online mode borrows the techniques from the offline mode with one refinement it no longer versions memory.
the insight is that n eongoby checks only intraprocedural queries in the online mode so it need handle only heap memory reuse which can be handled in a much simpler way.
specifically it defers heap memory deallocations so the allocations almost always return different addresses.
to do so it replaces functions that free heap memory including c s free and c s delete mangled names zdlpv and zdapv with a function that queues the free request without actually freeing memory.
when the queue is full n eongoby processes half of the queued requests ensuring that heap memory reuse occurs after at least n 2free operations where nis the queue capacity.
by default nis 20k large enough that no fps of this type occurred in our experiments.
one additional advantage of the online mode is that the embedded assertions explicitly inform us what to check enabling n eongoby to leverage symbolic execution tools such as klee and woodpecker to generate inputs that cause the assertions to fail.
we leave this for future work.
if a function has an extremely large number denoted n of pointers that do not alias each other the online mode need insert o n2 assertions which may run slower than the o n logging operations inserted by the offline mode.
to avoid high overhead caused by such pathological cases n eongoby bounds the number of assertions it inserts to 106for each function and switches to the offline mode for the function otherwise.
in our experiments we did encounter one such case a yacc generated function called mysqlparse inmysql needs much more than 106assertions so neongoby always checks this function offline .
.
.
delta checking neongoby provides an optimization called delta checking to speed up both online and offline modes without losing any error.
the insight is that not all pointer pairs are equally hard to handle by an alias analysis so n eongoby can focus on checking the hard to handle pairs and skip the easy ones.
to compute what pairs are easy n eongoby takes a user specified baseline alias analysis assumed to be simple enough to be correct.
it then skips checking all pointer pairs pandqon which the baseline s mayalias p q returns false.
intuitively if an imprecise baseline alias analysis can infer that two pointers do not alias then most likely they never alias284in any execution so didalias would return false and n eongoby would not find any error on the pointers.
we envision two ways this optimization can be used.
first a user specifies an alias analysis she trusts such as basicaa which computes very conservative alias results then enjoys speedup without losing errors when applying n eongoby to check an advanced alias analysis.
second an alias analysis builder incrementally checks each precision improvement she makes to her alias analysis.
for instance if her alias analysis reports pointer pairs that each do not alias prior to the improvement and pairs after she can use n eongoby to check this difference of pairs each indeed never alias on some test programs and workloads.
to implement delta checking for the offline mode we simply change line in algorithm to ifb.mayalias p q andnota.mayalias p q wherebis the baseline alias analysis.
to implement delta checking for the online mode we simply change line in algorithm to ifpreachesqandb.mayalias p q andnota.mayalias p q our results using basicaa as baseline show delta checking reduces compilation time offline detection time and runtime overhead.
.
implementation we implemented n eongoby in llvm.
it works with version .
and above.
it consists of lines of c code with for the instrumenter for the logger for the offline detector for the online mode and the remaining for common utilities.
in the remainder of this section we describe three additional techniques within n eongoby the first to further reduce overhead .
the second to help users diagnose error reports .
and the third to support multiprocess or multithreaded programs .
.
.
detecting errors using dereferenced pointers only dereferenced pointers are presumably more crucial than the ones not dereferenced so are the alias results on dereferenced pointers.
thus n eongoby provides users an option to detect alias analysis errors using only dereferenced pointers including the pointers used in load and store instructions and those passed to external functions because n eongoby conservatively assumes that these functions dereference their pointer arguments.
although n eongoby with this option may lose some alias analysis errors it enjoys two benefits.
first the error reports are of higher quality because they are on the more crucial pointers.
second n eongoby runs faster when checking fewer pointer pairs in both offline and online modes.
we evaluate this bugs v.s.
overhead tradeoff in .
.
.
simplifying error diagnosis when n eongoby reports an error it emits two pointers that did alias yet are not marked as aliases by the checked alias analysis.
to diagnose such a report it may be time consuming to manually inspect all records in the log so n eongoby provides a diagnosis tool to slice the log into a small subset of records that explains why two pointers did alias.
the core idea is to trace data dependencies of the two pointers back to a common parent pointer from which both pointers are derived.
n eongoby traces only direct data dependencies on pointers.
for instance given p q x where pandq are both pointers n eongoby only traces p s dependency on q notx.
similarly given p q n eongoby only traces p s dependency on the previous instruction that stores to the address of q and ignores p s dependency on q. neongoby stops tracing back when it finds the common parent pointer or it cannot trace the de pendencies further due to for example external functions whose source is not available to n eongoby.
to use this tool on an error report a user needs to re run n eongoby s logger to log more operations than pointer definitions and memory allocations including store instructions that store pointer values and call and return instructions of functions that return pointers.
.
supporting parallel programs as discussed in n eongoby is explicitly designed to detect alias analysis bugs that manifest on real world programs such as apache andmysql .
these programs often use multiple threads and processes for performance and ease of programming so n eongoby must handle threads and processes.
it needs to do so only in the offline mode because the online mode checks intraprocedural queries.
specifically n eongoby shares one log over all threads in a process and protects the log using a mutex.
it assigns one log to each process.
when a process forks n eongoby creates a new log for the child process.
n eongoby can then check each log in isolation.
the only modification to algorithm is maintaining a call stack for each thread.
n eongoby assumes race freedom as most compilers do and data races in the worst case may cause some fps.
fortunately data races occur so rarely that no fps of this type occurred in our experiments .
.
.
.
limitation false positives.
neongoby assumes that test programs do not have undefined behavior per ansi c specification and may emit fps on buggy test programs.
for instance n eongoby may emit fps on pointers off bound by many bytes .
which are disallowed by ansi c specification.
moreover n eongoby works within a compiler so external functions that return reused addresses and are not treated as memory allocation functions by n eongoby .
may cause fps.
for instance if an external function my realloc frees and reallocates heap memory and returns the reallocated memory address n eongoby would miss this memory reuse and emit fps.
however in practice external functions seldom cause issues for two reasons external functions not treated by neongoby as memory allocation functions seldom return reused addresses without function summaries alias analyses cannot characterize the address reusing behavior of those functions either.
false negatives.
neongoby is a dynamic tool and detects only alias analysis errors that manifest on the executions it checks.
moreover we explicitly designed n eongoby to be general to check many alias analyses with low false positives but this generality comes at a cost n eongoby cannot easily find bugs that violate a specific precision guarantee intended by an alias analysis.
in our future work we plan to specialize n eongoby s checking toward specific precision guarantees by varying the precision of its didalias .
in addition although n eongoby checks thatdidalias p q !mayalias p q it cannot dynamically check that if mayalias p q then there exists an execution s.t.
didalias p q for the following reasons mayalias may conservatively return true even if the two pointers never alias in any execution and even if the pointers do alias in some execution the given program and workload may not trigger this execution.
.
ev aluation we evaluated n eongoby on three popular alias analyses .basicaa llvm s default alias analysis an intraprocedural flow insensitive analysis that collapses all address taken variables.
we chose the version of basicaa in llvm .
.285table descriptions of the bugs found.
starred bugs were either already reported by others or mentioned in the comments of the code.
file indicates the file and the line if there is a clear place to add the fix containing the bug.
aa file description ds aa topdownclosure.cpp incomplete call graph traversal in the top down analysis stage ds aa stdlibpass.cpp matched formal argument nto actual argument n ds aa topdownclosure.cpp symptom missed aliases between actual parameters and the return value of an indirect call ds aa local.cpp mishandled variable length arguments ds aa local.cpp mishandled inttoptr andptrtoint instructions ds aa stdlibpass.cpp did not handle errno pointers returned from errno may alias ds aa stdlibpass.cpp did not handle getpwuid r andgetpwnam r whose argument and return value alias ds aa stdlibpass.cpp did not handle gmtime r like functions whose return value and the 2nd argument alias ds aa stdlibpass.cpp did not handle realpath whose value and the 2nd argument alias ds aa stdlibpass.cpp did not handle getenv whose return value aliases for the same environmental variable ds aa stdlibpass.cpp did not handle tzname an external global variable ds aa stdlibpass.cpp did not handle getservbyname whose return values may alias ds aa stdlibpass.cpp did not handle pthread getspecific and pthread setspecific the value stored via pthread setspecific aliases that loaded via pthread getspecific with the same key ds aa stdlibpass.cpp did not handle strtoll the dereference of the 2nd argument may alias the 1st argument ds aa stdlibpass.cpp did not handle the ctype function family the return value of ctype b loc like function may alias ds aa stdlibpass.cpp did not handle freopen whose return value may alias stdin stdout orstderr anders aa andersens.cpp huvalnum incorrectly marked a pointer as pointing to nothing.
anders aa andersens.cpp mishandled indirect call arguments points to edge to argument nmay be attached to argument n anders aa andersens.cpp points to nodes representing indirect calls are swapped but argument info is not updated accordingly anders aa andersens.cpp queries on a function pointer and a function always return no alias even though they do alias anders aa andersens.cpp did not handle inttoptr andptrtoint instrucitons anders aa andersens.cpp did not handle extractvalue andinsertvalue instructions anders aa andersens.cpp incorrect summary for freopen whose return value may alias the 3rd argument anders aa andersens.cpp did not handle cxa atexit anders aa andersens.cpp mishandled variable length arguments anders aa andersens.cpp did not handle pthread create anders aa andersens.cpp did not handle pthread getspecific andpthread setspecific anders aa andersens.cpp did not handle strcpy stpcpy andstrcat whose return value aliases the 1st arguments anders aa andersens.cpp did not handle getcwd andrealpath .ds aa a context sensitive field sensitive alias analysis with full heap cloning actively maintained by llvm developers.ds aa is used by .
we chose revision from ds aa s svn repo .
.anders aa an interprocedural andersen s alias analysis with three constraint optimizations hash based value numbering hu and hybrid cycle detection .
we ported the version of anders aa in llvm .
to llvm .
.
both anders aa andds aa have much better quality than typical research grade analyses ds aa in particular is used by many researchers regularly tested and actively maintained.
our test programs are mysql and apache two widespread server programs.
our workloads are benchmarks used by the server developers themselves sysbench for mysql which randomly selects updates deletes and inserts database records and apachebench for apache which repeatedly downloads a webpage.
we compiled these programs and benchmarks with clang .
and o3.
since mysql andapache are server programs we quantified n eongoby s overhead on them by measuring throughput.
our evaluation machine is a .
ghz intel dual cpu core machine with gb memory running bit linux .
.
.
we made both sysbench andapachebench cpu bound by fitting the database or web contents in memory we ran both the client and the 4anders aa was maintained up to llvm .
so we ported it to llvm .
with a patch that removes lines and adds .
this patch is included in our release of n eongoby.
it does not change anders aa s functionality it merely fixes compatibility issues between llvm .
and .
it replaces debug outputdout with dbgs migrates anders aa s handling of an allocation instruction because llvm .
replaces this instruction with other instructions adds code to handle a new type of constant constantdatasequential and changes the alias query interface to include sizes.
for each bug found in our port we verified that the bug also exists in the original anders aa .server on the same machine to avoid masking n eongoby s overhead with network delay we used four threads for the server and client and split the total eight threads on different cores to avoid cpu contention.
the remainder of this section focuses on three questions .
can n eongoby detect many bugs with zero fp?
.
what is n eongoby s overhead?
.
what are the bugs v.s.
overhead tradeoffs with different n eongoby techniques?
.
bug detection results this subsection shows the bugs .
.
we found using n eongoby and how we detected them .
.
.
.
.
bugs found neongoby found total bugs in ds aa and in anders aa .
of the bugs are previously unknown and four ds aa bugs have been fixed by the developers .
table shows all bugs.
of the bugs nine are logical bugs two do not handle certain llvm instructions the remaining eighteen mishandle external functions or global variables because of analysis incompleteness.
although adding summaries for external functions and global variables can alleviate analysis incompleteness systematically handling unknown external functions and global variables remains challenging.
researchers and developers strive to make their analyses complete to adopt them into production.
for instance one novel feature of ds aa is completeness tracking technique to support unknown external functions anders aa also strives to handle the incompleteness of external functions see function addconstraintsforcall .
we pinpointed the root causes of all bugs in table to locations in the source code.
since anders aa is relatively simple we fixed all bugs n eongoby detected in this alias analysis.286table alias analysis precision.
percentages are no alias ratios.
basicaa anders aa fixed anders aa apache .
.
.
mysql .
.
.
next we elaborate on two most interesting bugs bug in ds aa and bug in anders aa .
both cause the points to graphs to miss edges and require tricky fixes.
bug is caused by an incomplete call graph traversal in ds aa .
ds aa constructs its point to graph in three stages constructing a local point to graph for each function a bottom up analysis to clone each callee s point to graph into the caller and a top down analysis to merge each caller s point to graph into the callees.
the bottom up stage computes an unsound call graph gb and the topdown stage computes a sound graph gtbased ongbby merging nodes and adding missing edges.
suppose the top down stage merges node aandbofgbinto nodecofgt.
when the topdown stage traverses gt it needs to traverse both aandbwithin nodec.
however the code incorrectly traverses only one of them.
we reported this bug to ds aa developers and they have fixed this bug.
bug is caused by an incomplete depth first search dfs of the constraint graph in anders aa s implementation of the hu algorithm.
anders aa answers alias queries by collecting and solving load store assignment and address of constraints.
it organizes these constraints in a constraint graph.
it runs hu to identify the points to sets of pointers and unify the pointers with the same points to sets.
to do so it runs a dfs over all nodes.
it keeps a visited flag per node node2visited and sets the flag to true when it first reaches the node.
as an optimization when visiting a node representing p if the points to set of the node representing pis already determined to be empty anders aa simply sets the points to set of pto be empty.
the bug lies in anders aa s logic to determine when the points to set of pis already determined it wrongly believes the set is determined when p s visited flag is true even though it has not finished exploring p s descendants or even initialized p s points to set.
we fixed this bug by adding a new flag per node to indicate when dfs has finished exploring the node.
how bugs affect precision.
as discussed in alias analysis bugs may cause tools to mistakenly believe that pointers do not alias when they indeed do invalidating research findings and compromising safety.
to illustrate we measured how bugs affect alias analysis precision using llvm s aliasanalysisevaluator which statically queries an alias analysis with all intraprocedural pointer pairs and computes statistics of the results.
we define precision as the percentage of queries with no alias results over all queries.
table shows the precision of basicaa anders aa and the anders aa after we fixed all its detected bugs.
although anders aa appears more precise than basicaa on both mysql and apache the fixed anders aa is actually lessprecise than the supposedly very imprecise basicaa .
this results illustrates that buggy alias results can indeed invalidate evaluation numbers.
.
.
bug detection methodology to detect as many bugs as possible we ran n eongoby in the most thorough way the offline mode without any optimization.
.
shows how the number of bugs varies with different modes and optimizations.
our results show n eongoby emits no fps on the three alias analyses and the two applications we checked.
we verified all n eongoby s reports are true positives as follows.
for anders aa neongoby emitted many reports.
fortunately onetable bug reports and bugs.
the second row shows the number of bugs found from the reports.
the numbers of ds aa bugs may be significantly larger than those shown in the table starred because we did not count a report as a bug if we could not pinpoint its root cause in the source or reproduce it with a simple testcase.
ds aa anders aa mysql apache mysql apache bug reports bugs bug typically causes thousands of reports so we verified the reports as follows.
we diagnosed one report produced a patch reran n eongoby on the patched anders aa to regenerate reports marked the reports that disappeared as true positives and repeated.
after about iterations n eongoby emitted no more reports.
for ds aa neongoby emitted a relatively small number of reports so we manually inspected each report.
some reports are fairly simple to diagnose such as incorrect external function summaries.
for more complex ones we created small testcases to reproduce the problems or applied our diagnosis tool .
to compute a slice of relevant log records to simplify diagnosis.
we confirmed all ds aa reports as true positives and pinpointed the root causes in ds aa s code for about half of the reports.
we could not pinpoint the other reports or reproduce them with small testcases so we conservatively excluded them from our bug count.
thus the actual number ofds aa bugs found may be significantly larger than what we report.
we released our bug reports together with n eongoby.
table shows the results on ds aa andanders aa with our test programs and workloads.
we did not include basicaa because neongoby emitted no reports on it.
for ds aa neongoby emitted reports on mysql and on apache .
for anders aa neongoby emitted on mysql and on apache .
the second row of table shows the number of bugs found.
neongoby found at least ds aa bugs with mysql and with apache .
interestingly these two sets of bugs only overlap by one bug illustrating n eongoby s benefit of using real world programs with diverse programming constructs as testing programs.
neongoby found anders aa bugs with mysql and with apache and the apache bugs are a subset of the mysql ones.
.
overhead to quantify n eongoby s overhead we ran it in the most optimized way the online mode with all optimizations.
.
shows how the overhead varies with different modes and optimizations.
table shows the results on basicaa anders aa the fixed anders aa and ds aa .
the compilation time of apache for every checked alias analysis is within 50s.
the compilation time of mysql is relatively longer mostly because anders aa andds aa are slower on mysql .
the throughput highly depends on the precision of the alias analysis.
for instance the throughput for ds aa is smaller than that for basicaa because ds aa is more precise.
interestingly the bugs in anders aa made it appear very precise so its throughput is also small.
however after we fixed all its bugs its throughput almost doubled.
n eongoby checks functionmysqlparse offline so we also measured this time.
since neongoby logged only operations from mysqlparse the log was very small and most of the offline detection time was spent on querying the checked alias analysis.
.
bugs and overhead tradeoffs neongoby provides both the offline and online modes and several optimizations to enable users to flexibly trade bugs for low overhead.
this subsection evaluates these tradeoffs using287table n eon goby s overhead.
compile shows the total compilation time including the time to query the checked alias analysis aa insert alias checks insert and generate the executable from the transformed bitcode codegen .tput shows the relative throughput with n eongoby over without.
detect shows the offline detection time for function mysqlparse neongoby checks it offline because this yacc generated function has too many pointers .
all times are in seconds.
mysql apache basicaa anders aa fixed anders aa ds aa basicaa anders aa fixed anders aa ds aa compile .
.
.
.
.
.
.
.
aa .
.
.
.
.
.
.
.
insert .
.
.
.
.
.
.
.
codegen .
.
.
.
.
.
.
.
tput .
.
.
.
.
.
.
.
detect .
.
.
.
n a n a n a n a table bugs and overhead tradeoffs.
the base columns represent the baseline of the offline and online modes delta with delta checking delta deref with both delta checking and using dereferenced pointers only .
.
the row titles match table and table .
to collect all reports in the online mode we changed the online mode to emit a report upon an error instead of aborting the current execution.
offline online base delta delta deref base delta delta deref compile .
.
.
.
.
.
tput .
.
.
.
.
.
detect .
.
.
n a n a n a reports bugs anders aa because we have understood and fixed all its bugs.
we chose apache as the test program.
table shows the results.
offline v.s.
online.
columns base show that the online mode trades compilation time and a few bugs for significantly increased throughput and reduced detection time.
with less than 230s complication time the online mode improves the throughput of apache by about three times and eliminates the offline detection time of about 1500s.
it emits fewer reports but misses only one bug.
a bug often triggers many reports so n eongoby can still catch a bug as long as some of its reports are emitted.
delta checking.
this optimization improves performance for both the offline and online modes without losing bugs .
we chose basicaa as the baseline.
columns delta show that delta checking reduces the detection time by .
in the offline mode it reduces compilation time by .
and increases the throughput by .
in the online mode.
the improvements would be even larger if a user incrementally checks her refinements to her alias analysis.
detecting errors using dereferenced pointers only.
this optimization improves the performance of both modes but may lose bugs .
.
columns delta deref show that this optimization reduces the compilation time by .
for the online mode it increases the throughput for both offline and online modes by .
and .
respectively it reduces the offline detection time by .
and it misses out of bugs in the offline mode and out of in the online mode.
.
related work previous sections have discussed how n eongoby is related to bounds checkers or general memory safety tools this section discusses other related work.
alias analysis.
a plethora of work has been devoted to creating faster more precise alias analyses .
this previous work is complimentary to ours because our goal is to effectively detect errors in alias analysis implementations.
there have been several studies on alias analyses though their focus is on precision and overhead not correctness.
specifically mock et al.
measures the precision of static pointer analyses by comparing their re sults with dynamic points to sets.
however the dynamic points to sets they computed are not precise enough for error detection e.g.
the points to sets are not context sensitive and they did not handle address reusing.
llvm s aliasanalysisevaluator collects statistics about an alias analysis such as how many pointer pairs do not alias and how many may alias.
hind and pioli implemented six context insensitive alias analysis algorithms and compared their precision time and memory consumption on programs up to k lines of code.
jablin et al.
compared the performance of their system using different alias analyses and found that the combination of research grade alias analyses sometimes performs worse than the production quality alias analysis in llvm.
software error detection.
a plethora of work has also been devoted to software error detection or verification e.g.
.
most of these systems target general programs whereas n eongoby targets alias analyses.
these analyses take programs as inputs do complex computations and compute abstract results with difficult to specify guarantees.
thus prior systems are not directly applicable to detect alias analysis errors.
testing and verifying compilers has also been an important topic for programming language researchers though to the best of our knowledge we are not aware of any prior system for effectively detecting alias analysis errors.
.
conclusion we have presented n eongoby a system for effectively finding alias analysis bugs.
n eongoby dynamically observes pointer addresses and emits errors if the addresses contradict an alias analysis.
our results show that n eongoby can effectively detect many bugs in popular alias analyses with zero fps and reasonable overhead.
our key inspiration of this work is our anecdotal struggles with some existing alias analyses so we hope that n eongoby can help improve advanced alias analyses into production quality analyses and vastly widen their adoption.
as such we have released it open source at along with our error detection results and proposed patches.
.