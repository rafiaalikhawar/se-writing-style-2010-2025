acomment mining annotations from comments and code to detect interrupt related concurrency bugs lin tan university of waterloo university avenue west waterloo on n2l3g1 canada lintan uwaterloo.cayuanyuan zhou university of california san diego gilman drive la jolla ca usa yyzhou cs.ucsd.eduy oann padioleau facebook inc. california avenue palo alto ca usa yoann.padioleau facebook.com abstract concurrency bugs in an operating system os are detrimental as they can cause the os to fail and affect all applications running on top of the os.
detecting os concurrency bugs is challenging due to the complexity of the os synchronization particularly with the presence of the os specific interrupt context.
existing dynamic concurrency bug detection techniques are designed for user level applications and cannot be applied to operating systems.
to detect os concurrency bugs we proposed a new type of annotations interrupt related annotations and generated such annotations for the linux kernel with little manual effort.
these annotations have been used to automatically detect real os concurrency bugs of which were previously unknown .
two of the key techniques that make the above contributions possible are using a hybrid approach to extract annotations from both code and comments written in natural language to achieve better coverage and accuracy in annotation extraction and bug detection and automatically propagating annotations to caller functions to improve annotating and bug detection.
these two techniques are general and can be applied to non os code code written in other programming languages such as java and for extracting other types of specifications.
categories and subject descriptors d. .
testing and debugging debugging aids d. .
process management concurrency deadlock general terms documentation experimentation languages reliability keywords concurrency bug detection annotation languages interrupts operating systems static analysis .
introduction concurrency bugs are inevitable in multi threaded programs as concurrency is inherently complex and programmers are trained to permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.think sequentially when coding.
concurrency bugs not only cause severe damage but also are hard to detect due to their non deterministic nature.
the severity of the concurrency bugs increases as the popularity of multicore hardware makes multithreaded programs more pervasive.
concurrency bugs in an operating system os are particularly detrimental because os failures caused by concurrency bugs e.g.
hangs and crashes can bring down all software running on top of the os.
as operating systems inherently have to deal with concurrent activities and shared resources they have a much higher percentage of concurrency bugs than application software .
a recent study shows that of os driver bugs are concurrency bugs .
detecting concurrency bugs in an operating system is not well addressed and is particularly challenging mainly for two reasons the os specific interrupt context makes os concurrency extremely complex and it has challenged the os community for decades .
figure shows that a thread tholding lock lis interrupted by an interrupt handler th referred to as in interrupt context which needs to acquire the same lock.
since the handlerthhas preempted the thread t twould not be rescheduled until the interrupt handler thfinishes .
the interrupt handlerthcannot finish its execution because it waits for the lock lthat the thread tholds.
such a real deadlock bug has been found in the linux kernel .
.
in the function do entint inarch alpha kernel irq alpha.c the developers forgot to call local irq disable to disable interrupts to prevent an interrupt handler from contending with other threads on the same lock more details appear in figure and section .
.
lin tan 1thread t interrupt handler thread th deadlock!
lfailed lock acquisitionlock acquisitionll linterrupted by th figure a deadlock.
since the interrupt handler thinterrupted the thread t thread tcannot be scheduled until thfinishes thcannot finish because it is waiting for tto release the lock l. it is difficult for developers to avoid such interrupt related bugs.
typically an os has tens of thousands of device drivers and interrupt handlers written by thousands of developers across several decades with new interrupt handlers being added constantly.
additionally interrupts can happen anytime duringlinux kernel time tick oneshot.c .
.
.
c a l l e d w i t h i n t e r r u p t s d i s a b l e d .
i n t t i c k i n i t h i g h r e s void .
.
.
.
.
.
c a l l e d w i t h i n t e r r u p t s d i s a b l e d .
i n t irq x t i c k i n i t h i g h r e s void .
.
.
a the original version b the annotated version figure converting a comment in the linux kernel into an annotation the execution of a thread creating numerous possible interleaving combinations.
therefore it is difficult for a kernel developer to reason about the numerous possible interleaving combinations between a thread and the large amount of evolving interrupt handlers.
further as interrupts are uncommon events anomalies they are likely to be neglected by developers because developers are less good at enumerating and correctly implementing all possible anomalies than making the normal main flow correct.
the complexity of an operating system the difficulty of instrumenting an os and the large amount of drivers make bug detection for operating systems particularly difficult and cumbersome.
existing concurrency bug detection tools are mainly built for user level applications and have not demonstrated their effectiveness of detecting concurrency bugs in operating system code.
the complexity and sheer size of an operating system can incur a prohibitively high run time overhead and instrumentation difficulties on dynamic approaches which is undesirable.
.
state of art in order to detect concurrency bugs many techniques have been proposed .
there are two main limitations of these techniques these tools do not consider the interaction with the os specific interrupt handlers thus missing the opportunity to detect related bugs and most of the effective concurrency bug detection tools are dynamic tools that are designed for user level applications.
detailed comparison with prior concurrency bug detection work is discussed in section .
.
to address the two limitations above static approaches with interrupts in mind would be a great solution for tackling operating system concurrency bugs.
toward using static approaches many annotation languages are proposed to allow programmers to formally express their intentions and assumptions e.g.
where a lock is needed etc.
these annotations not only can be checked against code to detect software bugs but also can prevent developers from introducing new bugs by making the intentions and assumptions explicit.
these annotation languages have made significant impact.
for example microsoft s sal annotations helped to detect more than potential security vulnerabilities in windows code .
seeing the success of sal microsoft recently proposed new annotations including concurrency related annotations .
in addition several other annotation languages including sparse from the linux kernel community sun s lock lint and sharc express concurrency related concerns.
however none of the annotation languages above fully express the concurrency assumptions that an os needs e.g.
interrupt related assumptions.
ideally we want to know the preconditions andpostconditions regarding interrupts of every function.
in other words we want to know whether interrupts should be disabled or enabled upon entry of a function and whether the interrupts should be disabled or enabled upon exit of the function .
considering that software can contain hundreds of thousands of functions it is tedious and time consuming to manually annotate all ofthese functions.
the significant amount of effort involved in annotating programs can greatly limit the impact of annotation languages .
therefore while we should definitely encourage developers to write annotations it would be desirable to provide support for annotating new and legacy code .
.
idea and contributions fortunately it is feasible to extract interrupt related preconditions and postconditions from both source code and comments written in natural language.
we will use examples to explain how we extract postconditions and preconditions in this section.
the detailed extraction techniques are described in section .
.
for postconditions if we know that local irq disable disables interrupts we can infer that all functions that call local irq disable but not any interrupt enabling function also disable interrupts.
preconditions can be inferred in multiple ways.
it has been a common practice for programmers to write comments to directly express their intentions and assumptions .
for example the comment in figure a states that interrupts must be disabled before calling tick init highres .
this comment can potentially be expressed as annotation irq x where 0indicates that interrupts must be disabled before calling the function andxindicates that interrupts can be either disabled or enabled upon exit of this function figure b .
section .
describes how the postcondition x can be refined during the annotation propagation process.
additionally programmers often write code assertions such as bug on !irqs disabled to print an error message if interrupts are not disabled indicating that they assume that interrupts must be disabled already.
the function run posix cpu timers for instance starts with bug on !irqs disabled indicating that this function must be called with interrupts disabled.
although such dynamic assertions can help detect bugs they are limited because they require bugs to manifest in order to detect them which is difficult for os concurrency bugs and these assertions incur high runtime overhead therefore are often disabled for production runs for better performance.
if we could convert such assertions into annotations and check the annotations statically such a static approach can complement dynamic assertions to detect more bugs with no run time overhead.
for example we add annotation irq x to function run posix cpu timers which enables us to detect the linux kernel bug discussed earlier.
furthermore we may infer interrupt related preconditions from source code by using statistical approaches similar to prior work .
we propose converting programmers intentions inferred from the comments and code they write into formal annotations and use these annotations to detect interrupt related os concurrency bugs.
two key techniques helped us generate annotations for all functions for effective bug detection hybrid annotation extraction from both comments and code andannotation propagation .
first we infer annotations solely from comments.
we then infer annotations from code only e.g.
from code assertions such as bug on .
finally we combine the annotations inferred from both comments and code to detect bugs.
we also demonstrate that the annotations inferred fromcomments and code complement each other.
by combining them we achieve better coverage and accuracy in annotation extraction which help us detect more bugs more accurately.
for effective bug detection we also automatically propagate annotations from callee functions to caller functions when necessary.
although this paper focuses on generating interrupt related annotations and detecting os concurrency bugs the hybrid approach of extracting specifications from both comments and code can be applied to non os code code written in other programming languages such as java and for extracting other types of specifications .
while this paper focuses on leveraging the extracted annotations to detect bugs the annotations can be used for many other purposes such as helping developers avoid bugs.
in total we generate interrupt related annotations from the linux kernel which are automatically propagated from a total of seed annotations.
these seed annotations are inferred directly from comments and code assertions with little manual effort of which are from comments and of which are from code assertions .
only of the seed annotations can be extracted from both comments and code assertions meaning that the majority from comments and from code assertions can only be extracted from one source.
the result indicates that it is beneficial to infer annotations from both sources.
we have used these annotations to detect real bugs of which were previously unknown which are more than we could have detected by using annotations extracted from code alone or using annotations extracted from comments alone.
this work acomment makes the following contributions proposed a new type of annotations interrupt related annotations and generated such annotations for the linux kernel with little manual effort.
leveraged the new annotations to automatically detect bugs caused by the complex os synchronization related to interrupt context.
applied a general hybrid approach to extract specifications from both code and comments.
note that our prior work icomment only extracts rules from comments a background of icomment and a detailed comparison with icomment appear in section .
.
used the interrupt related annotations to compare the coverage of code and comments regarding annotation extraction and bug detection.
.
design of acomment to help prevent and detect software bugs our ideal goal is to annotate all functions with interrupt related annotations and use these annotations to check for bugs.
however this process is tedious and time consuming acomment automates this process.
there are three steps in annotating all functions and using them for bug detection designing expressive and easy to use annotation languages converting comments and code into formal annotations including propagating annotations to the callers of a function when necessary and verifying that these annotations are followed by the code.
section .
presents the three major challenges of acomment and an overview of our solutions.
section .
.
describe how we perform the three steps described above respectively and how we address the three major challenges.
.
challenges and an overview of our solutions this section discusses the three major challenges in annotating all functions and using the annotations for bug detection.converting comments and code into annotations.
although it is promising to extract annotations from comments and code it is quite challenging.
first comments are ambiguous and written in free form developers can express the same meaning using different words phrases sentence structures etc.
it is difficult to automatically and precisely analyze comments to extract the correct annotations from them.
furthermore we want the annotations generated by our acomment tool to be accurate as these annotations are intended to be added back to the source code to help developers better understand the program to prevent them from introducing new bugs.
to address the challenges above we improve our comment parser used in icomment design new heuristics for extracting annotations and manually verify all generated annotations.
for each generated annotation our analyzer shows the original comment and the surrounding code to allow a user to either accept reject or modify the extracted annotations e.g.
flip the annotation change the function name etc.
.
the manually verified correct annotations can help us detect bugs as well as guide the developers to prevent the introduction of new bugs.
to extract annotations from code assertions briefly described earlier in section .
and elaborated later in this section we built a scalable static analysis tool.
dealing with scarceness of annotations.
since not all functions have comments or code assertions stating their preconditions and postconditions one cannot annotate all functions in a piece of software simply by extracting annotations from comments and code assertions.
to annotate all functions we need to have the ability to propagate annotations of a function to the function s callers.
for example if we know that function local irq enable enables all local interrupts and that a direct caller of it does not disable interrupts we can infer that the postcondition of its caller assumes that interrupts are enabled.
it is tedious and time consuming to manually perform this analysis as software contains tens of thousands of functions and their interaction is complex.
it is challenging to make this process efficient and scalable.
we propose a bottom up summary based annotation propagation technique to automate this process which avoids analyzing a function repetitively details in section .
.
handling interrupt restoring functions.
it is insufficient for acomment to consider only interrupt disabling functions e.g.
local irq disabled and interrupt enabling functions e.g.
local irq enable as some functions called interrupt restoring functions e.g.
local irq restore restore a previously saved interrupt state.
we cannot treat such restoring functions as a simple interrupt disabling function or an interrupt enabling function.
thus they have to be specially treated.
.
annotation language design as we are concerned with the os synchronization in the special interrupt context we design annotations in the following format irq precondition postcondition where precondition andpostcondition can have one of the values i.e.
xand p. the meanings of each of the values are shown in table a .
value pindicates that a function e.g.
local irq restore restores the saved interrupt state.
we use x p to indicate functions that restore a saved interrupt state and all other annotations that contain a value pis not accepted.
therefore although there are possible annotations only of them are accepted by acomment as shown in table b and the rest of the should not appear in acomment.value meaning interrupts are disabled.
interrupts are enabled.
x don t care interrupts are either disabled or enabled.
p interrupts are restored to the saved interrupt state.
irq pre post meaning irq interrupts are disabled on entry and remain disabled on exit.
irq interrupts are disabled on entry but are enabled on exit.
irq interrupts are enabled on entry but are disabled on exit.
irq interrupts are enabled on entry and remain enabled on exit.
irq x x either irq or irq irq x don t care on entry and interrupts are disabled on exit.
irq x don t care on entry and interrupts are enabled on exit.
irq x interrupts are disabled on entry and don t care on exit.
irq x interrupts are enabled on entry and don t care on exit.
irq x p don t care on entry and interrupts are restored to the saved state on exit.
a the meaning of the annotation values b all valid annotations.
pre stands for preconditions and post denotes postconditions.
table proposed annotations.
software sentence irqsent linux freebsd netbsd opensolaris total table extracting annotations from comments is challenging.
sentence is the total number of comment sentences.
irqsent is the total number of comment sentences that contain the keyword interrupt case insensitive .
typically there are two ways to incorporate annotations in software adding annotations in comments so that they are backward compatible or introducing new language keywords which can ensure that the annotations evolve with code but is not backward compatible.
either would work for acomment.
we choose the first approach for backward compatibility.
.
annotation extraction this section describes how we extract preconditions from the comments and source code more specifically code assertions .
we call these directly extracted annotations seed annotations .
section .
presents how to propagation these seed annotations to their caller functions when necessary and postconditions are determined during this propagation process.
extracting annotations from comments.
annotation extraction from comments consists of two steps comment extraction extracting annotation containing comments which are comments that contain interrupt related preconditions defined in section .
and annotation generation converting these comments into annotations.
postconditions are inferred during the propagation process which is presented later in section .
.
comment extraction we improve the comment parser from icomment use it to extract all comments from a given program and break these comments into sentences.
what does not work?
we extracted comment sentences that contain word interrupt regardless of cases.
table shows that there are on the order of such comments.
a cursory examination found that less than of the comments contain the kind of annotations we want to extract defined in section .
which is consistent with our comment characteristics study results .
therefore it is inefficient to manually read all of these comments to extract seed annotations.
our prior work icomment used machine learning techniques to automatically analyze several thousands of lock related comments to extract programming rules.
however we cannot directly apply the techniques used in icomment id heuristic call with interrupt ordered before disable enable interrupt orderless assume disable enable interrupt orderless table main heuristics used to extract annotations from comments.
names in are variables defined in table which can expand into multiple words and their variants.
the first heuristic requires the three variables to appear in the specified order while the other two do not.
because around of the thousands of lock related comments contain rules but less than of the over interrupt related comments contain rules annotations.
the same techniques used in icomment would produce much less accurate results for interrupt related comments.
additionally acomment requires higher analysis accuracy as the extracted annotations are intended to be added back to the source code to improve program comprehension and prevent the introduction of new bugs.
we do not want to add wrong annotations to mislead developers.
therefore we combine simple program analysis with effective heuristics to extract annotations and manually verified all of the annotations.
the heuristics are shown in table where each variable can be expanded into multiple words and their variants as shown in table .
we tried our best to include as many paraphrases and variants.
for example in addition to disable we used turn off block lock out and their variants such as disables disabling disabled turning off turned off turns off etc.
in the future we can leverage advanced natural language processing techniques to automatically discover paraphrases.
additionally we filter out comments that contain words such as may and might .
furthermore as acomment only extracts function preconditions and postconditions we only consider comments that are before a function body a function declaration or a function call.
as we aim for high precision i.e.
more extracted annotations are accurate and correct the heuristics above are biased to find more comments that are likely to contain annotations at the cost of missing some annotation containing comments.
annotation generation after acomment extracts the comments that contain the interrupt related preconditions acomment needs to decide if the precondition is 0or1and extract the name of the function associated with the annotation.
acomment obtains the information above using simple program analysis and heuristics is the precondition 0or1?by identifying the verbs e.g.
disable and enable and negation words e.g.
not we can determine the precondition.
for example disable is mapped to and a negation word not flips the precondition once to .
what is the function name?
given an annotation containing comment acomment can extract the function name by analyzing thevariable definition call word call its variants such as calls called and calling before caller before on entry upon entry and their variants disable enable disable enable turn on turn off block lock out and their variants interrupt interrupt irq and their variants table definitions of the variables in table linux kernel posix cpu timers.c 1static void vmi timer set mode enum clock event mode mode struct clock event device evt cycle t now cycles per hz bug on !irqs disabled ... figure code assertion example code segment below the comment e.g.
a function definition or a function call statement.
for each generated annotation our analyzer shows the original comment and the surrounding code to allow a user to either accept reject or modify the annotation e.g.
flip the annotation change the function name etc.
.
as shown later in table the heuristics are effective in dramatically reducing the number of comments we need to verify.
we only needed to read of the comments to verify a total of accurate seed annotations from the four operating system code bases.
these manually verified accurate interrupt related annotations can not only help detect bugs but also help developers prevent the introduction of bugs.
extracting annotations from code.
as many functions do not have comments explaining their preconditions and postconditions we need to extract more seed annotations by learning from the source code.
we observed that source code typically contains assertions to indicate that a function must be called with interrupts disabled or enabled.
for example figure shows that function vmi timer set mode calls assertion code bug on !irqs disabled as its first statement to indicate that interrupts should have already been disabled before callingvmi timer set mode .
at runtime if interrupts are not disabled before calling vmi timer set mode error messages will be printed by the kernel.
while such assertions can help detect bugs to some extent they are limited as mentioned in section .
debugging macros such as bug on are disabled by default mainly due to the high runtime overhead and such a dynamic approach can only detect manifested bugs and the manifestation of concurrency bugs in an os is extremely difficult.
if we can convert such assertions into annotations and check if the code conforms to the annotations statically we could detect bugs that cannot be detected by these dynamic assertions.
therefore we use simple static analysis to extract annotations from these assertion macros.
we analyze the direct callers of bug on !irqs disabled andbug on irqs disabled to see if these functions are intended to be called with interrupt disabled or enabled.
.
annotation propagation our goal is to annotate all functions based on the seed annotations extracted from comments and code.
if we know the annotations of all the callee functions of function foo then we can track the interrupt related state to automatically generate the annotationlinux kernel timer.c 1void update process times intuser tick struct task struct p current calls get current intcpu smp processor id not a function call account process tick p user tick run local timers if rcu pending cpu rcu check callbacks cpu user tick scheduler tick run posix cpu timers p x x x x x x figure the above annotation propagation example for the linux kernel illustrates that we can infer that the annotation for function update process times is irq based on its callee functions annotations shown on the right .
for function foo.
taking the code in figure as an example we can infer that the annotation for function update process times is irq .
specifically we start with the precondition of the first callee function line which is x. when we see line we can infer that the interrupts must be disabled after line .
as the annotation for line is x x recall that this means either or we know the interrupt state before line is which is the precondition of update process times .
similarly we can infer that the interrupts should remain disabled on exit of function update process times .
therefore both the precondition and postcondition of function update process times must be0.
note that we cannot update the annotation of the callee functionget current from x x to because it is possible that when called from a different location the states before and after calling get current are both interrupts are enabled meaning that its annotation can be either or .
the next question is how to obtain the annotations of all the callee functions in the first place.
this task is performed in a bottom up fashion in two steps so that all the callee functions are annotated before their callers.
in the first step the initialization step we assign the seed annotations to their corresponding functions called seed functions .
in the second step the propagation step we propagate the seed annotations from the seed functions to their callers repeatedly in a bottom up manner.
step i initialization we add the seed annotations extracted from comments and assertions to their corresponding functions.
in addition we annotate functions that directly disable enable or restore interrupts e.g.
local irq disable for the linux kernel called irq functions .
a kernel usually has a very small number of irq functions.
for example we only need to annotate irq functions for the linux kernel section .
we annotate these irq functions with x if they disable interrupts with x if they enable interrupts and with x p if they restore a saved interrupt state.
we then find all unannotated functions that do not have any callees and annotate them with x x meaning thatlin tan irq irq linux arch alpha kernel irq alpha.casmlinkage irq void do entint ... ... smp percpu timer interrupt ... ... 1linux kernel posix cpu timers.c void irq run posix cpu timers ... ... bug on !irqs disabled ... void irq smp percpu timer interrupt ... callviolation!forgot to call local irq disable a real bug in the linux kernelcallfigure this is a real bug in the linux kernel .
.
which is described in introduction.
a call arrow denotes a direct call or an indirect call of a function.
these functions can be called with interrupts disabled or enabled but the postconditions should be the same as their preconditions.
the reason that we use x instead of as the annotation for an interrupt disabling function is that these interrupt disabling functions simply clear the interrupt state and do not assume interrupts enabled on entry.
therefore interrupt disabling functions can be nested e.g.
it is legitimate to call local irq disable twice consecutively.
the same is true for interrupt enabling functions.
if a user of acomment wants to flag such nested usage as a warning he or she can set the annotations for interrupt disabling functions as instead.
our tool supports both options.
without losing generality we will use x for explanation and results presentation in the rest of this paper.
step ii propagation our propagation analysis starts from the bottom of a call graph to find all functions whose callee functions are all annotated and automatically infers the annotations for them.
this propagation process is repeated until all functions are annotated.
if a call graph contains no cycles it is guaranteed that all functions in the call graph will be annotated.
in case of a cycle i.e.
recursive function calls we follow the cycle until the annotations stabilize.
if an interrupt restoring function is encountered we simply restore the state to x. a more precise analysis would restore to the saved interrupt state i.e.
a parameter of the interrupt restoring function .
however this is more expensive as it requires context sensitivity.
because developers choose to save the interrupt state it generally indicates that the saved state can be 0or1 therefore xis a better choice than either 0or1.
let us still use the example in figure to explain the propagation process.
after several rounds of propagation from the bottom of the call graphs all of function update process times s callees are annotated as figure shows.
therefore we can infer that the annotation for update process times is .
.
annotation checking and bug detection bugs are detected during the propagation process described above.
there are two types of violations i.e.
root function violations and unsatisfiable violations .
if a root function s precondition is not x it is considered a root function violation where a root function is a function that does not have a caller e.g.
in the kernel .
a function may not have any caller in the kernel because the function is intended to be called by user level functions.
as root functions software loc sentence linux .2m freebsd .4m netbsd .3m opensolaris .7m table operating systems evaluated by acomment.
loc is the total number lines of code including comments with blank lines excluded.
sentence is the total number of comment sentences.
callers are outside the kernel if the precondition is 0or1 it can not be guaranteed indicating a bug.
therefore although acomment did not analyze the user level code acomment can detect bugs caused by the interaction between the user level code and the kernel code.
take the bug described in the introduction as an example figure our acomment tool reports a violation when it propagates annotation from function run posix cpu times to function smp percpu timer interrupt and eventually to the root function do entint .
this is a real bug as confirmed by the linux kernel developers.
the function local irq disable should be called before calling smp percpu timer interrupt to disable interrupts to ensure the precondition 0of function smp percpu timer interrupt .
section shows more bugs detected by our acomment tool.
if preconditions and postconditions conflict with each other our acomment tool reports them as unsatisfiable violations .
for example if function a with annotation x is invoked immediately before function b with annotation we know it is not satisfiable because the interrupts are enabled after calling a but they should be disabled before calling b. the reported bugs are ranked according to their confidence scores which are affected by several factors including seed annotation confidence andviolation confidence .
as code is generally more reliable than comments seed annotations extracted from code assertions are considered more accurate than seed annotations inferred from comments.
therefore bugs violating seed annotations extracted from code assertions are given higher confidence scores.
unsatisfiable violations are given higher confidence scores than root function violations because acomment may miss some of the callers of the root functions due to static analysis imprecision details in section .
.
if the confidence score of a bug is lower than an adjustable threshold the bug is not reported to the user.
the user of acomment can always set the threshold to be to retrieve all the potential bugs.
.
static analysis as the used static analysis techniques are not our major contribution we only briefly describe them.
we extend our static analysis tool from icomment to extract annotations from assertions propagate annotations and detect os concurrency bugs.
the analysis is inter procedural flow insensitive and summary based.
.
experimental methods our acomment tool automatically propagates annotations starting from a few irq annotations i.e.
annotations for functions that directly disable enable or restore interrupts.
for the linux kernel we manually identified interrupt disabling functions interrupt enabling functions and interrupt restoring functions.
acomment takes the irq annotations as input and automatically propagates them to all other functions a total of annotations.
one can update these irq annotations easily if the code changes or if we want to analyze a different code base.source seed seedchecked truebugs falsepositives comment assertion total table acomment generated annotations for the linux kernel and detected true bugs.
the total row is not the sum of the two rows above because seed annotatios extracted from assertions overlap with seed annotations extracted from comments causing the detected bugs to overlap as well.
evaluated software.
we evaluated our acomment tool on the latest versions of the linux kernel.
in addition we extracted annotations from the comments of three other large kernel code bases i.e.
freebsd netbsd and opensolaris .
all of the four oss are written in the c programming language which is the dominant programming language for writing operating systems.
however our hybrid annotation extraction annotation propagation and bug detection techniques are general and can be applied to code written in other programming languages such as java.
.
results .
overall results table shows the overall annotation extraction annotation propagation and bug detection results of acomment.
the total row is not the sum of the two rows above because seed annotations extracted from assertions overlaps with seed annotations extracted from comments causing the detected bugs to overlap as well.
acomment generates interrupt related annotations by analyzing comments and code from the linux kernel.
in total seed annotations are inferred from comments and code assertions of which are from comments and of which are from code assertions.
only of them can be extracted from both comments and code assertions meaning that the majority from comments and from code assertions can only be extracted from one of the two sources.
this result indicates that it is beneficial to infer annotations from both sources.
our hybrid approach greatly increases the number of annotations that can be extracted which helps detect more bugs table column truebugs more accurately.
all the seed annotations are manually verified as correct.
using the annotations our checker reports bugs of which are true bugs of which were previously unknown from the latest versions of the linux kernel.
these bugs are not only important they are in the core kernel modules they can crash hang or corrupt the os and they can affect all applications running on top of the os but also hard to detect due to their non deterministic nature and the complex interaction with interrupts .
table presents the annotation distribution in the linux kernel which shows that functions annotations are not simply x x it would be tedious and time consuming to manually specify them all.
the result demonstrates that our propagation and extraction techniques are effective in annotating all functions from a handful of irq annotations.
table also shows that only a portion of the inferred seed annotations were used for bug detection because we used a typical x86 linux kernel compilation meaning that some of kernel code was not compiled and cannot be analyzed.
some of the kernel code was not compiled because it depends on a particular architecture or a particular driver.
to actively compile a maximum amount of code remains as our future work.annotation no.
x x x x x p x x total table distribution of linux annotations .
lin tan static void ssb pcmcia write16 ... ... spin lock irqsave ... err select core and segment ... ... 1call irq x irq linux arch x86 mm pageattr.c static void irq cpa flush array ... ... bug on irqs disabled ... static int irq select core and segment ... ... call violation!a real bug in the linux kernel irq x irq figure a real bug detected by acomment in the linux kernel.
a call arrow denotes a direct call or an indirect call of a function.
false positives are mostly caused by the inaccuracy of our static analysis.
first our static analysis tool cannot know if certain statements are not reachable.
for example acomment mistakenly considered that the function call local irq disable in the code segment while local irq disable was executed therefore it inferred the wrong interrupt state and reported a false bug.
such false positives can be removed by eliminating obviously not executed code segments.
additionally function pointers are frequently used in the kernel code but our static analysis tool cannot adequately discover their aliases causing false positives.
a more advanced pointer aliasing analysis can reduce these false positives.
detected bug examples.
in addition to the bugs shown earlier we show another bug automatically detected by our acomment tool in figure .
the precondition in annotation irq is extracted directly from the assertion in cpa flush array shown at the bottom of figure while the postcondition is obtained during propagation.
the annotation is propagated to select core and segment which is not satisfiable because the interrupts were disabled right before calling function select core and segment .
in addition several other caller functions of select core and segment disable interrupts right before calling select core and segment .
however we count them as one bug because they were all solved by one bug fix by the kernel developers making select core and segment no longer call cpa flush array .software sentence irqsent heusent annot linux freebsd netbsd opensolaris total table annotations extracted from comments.
sentence is the total number of comment sentences.
irqsent denotes the number of comment sentences that contain the keyword interrupt case insensitive .
heusent is the number of comment sentences extracted using our heuristics.
annot is the number of annotations that are manually verified to be correct.
.
annotation extraction results comments versus code.
in total seed annotations are inferred from the linux kernel comments and code assertions of which are from comments and of which are from code assertions.
a majority of the annotations from comments and from code assertions can only be extracted from one of the sources.
this result indicates that comments and code complement each other for annotation extraction.
our hybrid approach increases the number of annotations that can be extracted which helps detect more bugs more accurately.
annotation extraction in other oss.
table shows the number of interrupt related annotations extracted from the four popular operating systems comments.
it demonstrates that our heuristics dramatically reduced the number of comments that we need to read manually to verify the annotations we only need to manually read of the comments to find a total of accurate seed annotations from the four operating systems.
the annotation extraction precision is the number of verified annotations divided by the total number of extracted annotation containing comments which is .
.
we can significantly improve this precision by focusing on function header comments which are more likely to contain preconditions and postconditions.
we calculate the annotation generation accuracy as the number of verified annotations whose preconditions and function names are generated correctly of the total number of verified annotations.
the annotation generation accuracy for the four oss is .
.
.
section .
demonstrates that acomment is effective in leveraging the extracted annotations in the linux kernel to detect bugs.
the annotations in the other three oss should help us detect more bugs which remains as our future work.
.
time overhead on a server with two .
ghz intel processors it took acomment minutes to analyze comments to extract seed annotations.
the annotation propagation and bug detection process finished within minutes.
therefore our acomment tool is practical to be used for real world large software.
.
discussions and limitations alternative solutions.
to avoid the bug in figure one solution is to have hardware disable interrupts before entering an interrupt handler as x86 does .
however this can cause problems as it is hardware architecture dependent.
in the alpha architecture the hardware does not disable interrupts before entering an interrupt handler which caused thisbug.
in addition it does not solve the general os concurrency problem.
for example it does not help when interrupts need to be disabled before a function that is not an interrupt handler.
limitations.
acomment is effective in extracting and inferring annotations for all functions in large software however it has limitations.
we only considered annotations that require all interrupts to be disabled and enabled.
some functions may assume that a particular interrupt is disabled or enabled on entry or exit which is out of the scope of acomment.
in the future we can extend our work to extract and analyze these more detailed assumptions.
we assumed that functions have unconditional interrupt related preconditions and postconditions.
in other words if a function must be called with interrupts disabled in some contexts and must be called with interrupts enabled in other contexts we simply consider that the precondition is x i.e.
don t care .
while it is possible to model conditional preconditions it is a bad practice for developers to implement functions with conditional preconditions.
as software evolves comments can become outdated which may cause some annotations extracted from comments to be obsolete.
our manual verification of the extracted comments did not reveal any wrong annotations caused by this reason.
in the future we would like to send the annotations to the developers to verify the correctness of the annotations.
in practice developers often update comments to keep them in sync with source code and we believe that important comments are less likely to be outdated because developers may be more motivated to keep them in sync.
.
related work .
annotation languages many annotation languages have been proposed to extend the c type system to specify locking requirements to annotate function interfaces or to mark control flows .
storey et.
al studied how programmers use todo comments for task annotation purpose.
none of these annotation languages can express the complex synchronization assumptions that are intertwined with interrupts in operating system code.
moreover these studies rely on manually written annotations while we advance the state of art by semi automatically annotating code.
.
concurrency bug detection many dynamic concurrency bug detection techniques were proposed.
race detectors detect data races a few studies are conducted to detect avoid or prevent deadlocks and other work detects atomicity violations.
several static concurrency bug detection or verification techniques were proposed .
the work mentioned above does not handle the complex interaction with interrupts or leverage the preconditions and postconditions embedded in comments for concurrency bug detection missing the opportunities to detect more os concurrency bugs.
in addition none of them demonstrated their effectiveness on operating system code which is extremely challenging due to the amount of drivers state explosion bug manifestation run time overhead and or scalability problems.
further this paper explicitly generates and propagates annotations to prevent the introduction of new bugs.
some work demonstrated the ability to check os code.
for example recent work used symbolic execution to test device driver binaries which detected several interrupt relatedrace conditions.
acomment complements their work in the following ways.
acomment infers programming rules interrupts must be disabled on entry and exit in the form of annotations in addition to bug detection.
the inferred annotations may be used by other detection and verification tools to detect bugs.
they can also be used to help developers avoid bugs.
further acomment detects violations to the inferred programming rules while they detect data races.
as quite often a race is not a bug acomment addresses this limitation by detecting violations to programmers intentions which directly indicate bugs.
additionally the previous work did not leverage comments for bug detection or annotation extraction.
a heuristic based dynamic bug detection tool lockdep was developed by the kernel developers specifically for the linux kernel .
lockdep uses several heuristics to detect lock related bugs e.g.
if two locks are acquired in different orders at different places and if there are dependencies between a lock that is ever held in interrupt context and a lock that is every held with interrupt enabled.
being a dynamic approach lockdep requires massive amount of runtime checking while acomment incurs no runtime overhead for using a static approach.
in addition acomment infers fine grained specific to a function annotations to detect violations to developers intentions and assumptions.
.
icomment our previous work icomment is the first to automatically analyze comments written in natural language to extract implicit program rules and use these rules to automatically detect inconsistencies between comments and source code indicating either bugs or bad comments.
icomment has demonstrated its effectiveness by automatically analyzing several thousands of lock related and callrelated comments to detect new bugs and bad comments in the linux kernel mozilla apache and wine.
this work is different from icomment in several aspects as this work proposed and generated a new type of annotations and used these annotations to detect bugs caused by the complex synchronization related to interrupt context automatically propagated annotations to caller functions to improve annotating and bug detection and used a hybrid approach to extract annotations from both code and comments while icomment only extracted rules from comments.
.
rule and pattern extraction previous work extracted programming rules or models from source code or execution traces for bug detection or other purposes.
although source code and execution traces have been very useful for rule and model extraction certain important information is documented in comments but are not available in source code or are extremely difficult to extract from source code.
without utilizing information in comments previous work missed the opportunities to extract more information detect more bugs or the chance to improve their bug detection accuracy.
concurrent to or after our prior work icomment a few studies extracted rules or specifications from documents in natural language or the semantics of program identifies.
this paper extracts a different type of rules os interrupt related annotations which has its unique challenges and requires different techniques.
in addition we applied a hybrid approach to extract annotations from both code and natural language text comments .
.
automatic documentation generation literate programming by knuth proposes embedding code inside documentation to produce literature instead of embeddingcomments and documentation in the code.
ghostdoc generates xml formatted comments from code identifiers that follow a good naming convention.
javadoc let programmers use special tags to document functions or data structures.
those tags are later processed by a tool to automatically produce hypertext documentation.
while these tools help developers write better documents they did not address the os concurrency bug detection problem.
.
transactional memory recently transactional memory is proposed to ease the implementation of concurrent programs.
while they can reduce concurrency bugs they cannot entirely eliminate such bugs.
our approaches could still help find bugs in programs using transactional memory.
in addition it is quite challenging to provide transactional memory support for operating systems.
.
conclusions and future work to detect operating system concurrency bugs related to interrupts we design a new type of annotations interrupt related annotations and generate such annotations for the linux kernel with little manual effort.
these annotations help us automatically detect real bugs in the latest versions of the linux kernel.
many of the annotations are seed annotations which are directly inferred from comments and code assertions.
we automatically propagate these seed annotations from the callee functions to the caller functions to generate annotations for all of the functions.
by extracting seed annotations from both comments and code we are able to extract more annotations than using a single source as only a small number of the annotations can be extracted from both sources.
in the future we plan to extend the analysis to generate annotations for a specific kind of interrupts and distinguish the different interrupt contexts e.g.
bottom halves top halves softirqs etc.
the hybrid approach of extracting specifications from both comments and code can be applied to non os code code written in other programming languages such as java and for extracting other types of specifications.
.