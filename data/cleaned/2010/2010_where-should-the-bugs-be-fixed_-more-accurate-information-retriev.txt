singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems wher e should the bugs be fix ed?
mor e accur ate information wher e should the bugs be fix ed?
mor e accur ate information retrie val based bug localization based on bug r epor ts retrie val based bug localization based on bug r epor ts jian zhou tsinghua univ ersity hongyu zh ang tsinghua univ ersity david l o singapor e management univ ersity davidlo smu.edu.sg follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the information security commons and the softwar e engineering commons citation citation zhou jian zh ang hongyu and l o david.
wher e should the bugs be fix ed?
mor e accur ate information retrie val based bug localization based on bug r epor ts.
.
icse 34th international conf erence on softwar e engineering z urich june .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
where should the bugs be fixed?
more accurate information retrieval based bug localizatio n based on bug reports jian zhou hongyu zhang and david lo 1school of software tsinghua university beijing china tsinghua national laboratory for information scienc e and technology tnlist zhoujian1286 yahoo.com.cn hongyu tsinghua.edu.cn 2school of information systems singapore management university singapore davidlo smu.edu.sg abstract for a large and evolving software system the project team could receive a large number of bug repo rts.
locating the source code files that need to be chang ed in order to fix the bugs is a challenging task.
once a bug r eport is received it is desirable to automatically point ou t to the files that developers should change in order to fix the b ug.
in this paper we propose buglocator an information retrie val based method for locating the relevant files for fixing a bug.
buglocator ranks all files based on the textual sim ilarity between the initial bug report and the source code usi ng a revised vector space model rvsm taking into consi deration information about similar bugs that have been fixed before.
we perform large scale experiments on four open sourc e projects to localize more than bugs.
the resu lts show that buglocator can effectively locate the files where t he bugs should be fixed.
for example relevant buggy files for .
eclipse .
bugs are ranked in the top ten among files.
our experiments also show that buglocator outperform s existing state of the art bug localization methods.
keywords bug localization information retrieval feature location bug reports i. introduction software quality is vital for the success of a soft ware project.
although many software quality assurance a ctivities such as testing inspection static checking etc have been proposed to improve software quality in reality so ftware systems are often shipped with defects bugs .
for a large and evolving software system the project team could receive a large number of bug reports over a long period of time.
for example around bugs were reported for the ecl ipse project in .
once a bug report is received and confirmed the pr oject team should locate the source code files that need to be changed in order to fix the bug.
however it is oft en costly to manually locate the files to be changed based on th e initial bug reports especially when the numbers of files a nd reports are large.
for a large project consisting of hundre ds or even thousands of files manual bug localization is a pa instaking and time consuming activity.
as a result the bug f ix time is corresponding author often prolonged maintenance cost is increased and customer satisfaction rate is hampered.
in recent years some researchers have applied information retrieval techniques to automatically s earch for relevant files based on bug reports .
they treat an initial bug report as a query and rank the source code files by their relevance to the query.
the developers can then examine the returned files and fix the bug.
these m ethods are information retrieval based bug localization methods.
unlike spectrum based fault localization techniques information retrieval ir based bug l ocalization does not require program execution information suc h as passing and failing traces .
they locate the bug re levant files based on initial bug reports.
many of the existing ir based bug localization meth ods are proposed in the context of feature concept loca tion using a small number of selected bug reports .
for example poshyvanyk et al.
proposed a feature locat ion method called promesir which utilizes an informati onretrieval technique latent semantic indexing and a probabilistic ranking technique .
they applied their method to locate bugs in eclipse and bugs in mo zilla.
gay et al.
proposed an approach to augment ir based concept location via an explicit relevance feedback rf mechanism .
they applied their bug localization approach on bug reports.
recently lukins et al.
performed a study on applying lda latent dirichlet allocatio n to search for bug related methods and files .
they used bugs across versions of three projects eclipse mozilla and rhino for the evaluation.
in each version onl y a small number of bugs were selected less than on avera ge .
besides the problem of small scale evaluations the performance of the existing bug localization method s can be further improved too.
for example using latent dir ichlet allocation lda only buggy files for of eclip se .
bug reports are ranked in the top .
more det ailed discussions about the current methods and their lim itations are given in the next section.
in this paper we propose buglocator a new method that can automatically search for relevant buggy files b ased on initial bug reports.
we propose a revised vector sp ace model rvsm to rank all source code files based on an initial bug report.
in rvsm we take the document l ength into .
c ieee icse zurich switzerland consideration which could optimize the classic vsm model for bug localization.
we also adjust the obtained r anks by using information of the similar bugs that have bee n fixed before.
we have evaluated buglocator on four open s ource projects eclipse aspectj swt and zxing of diffe rent sizes with a total of more than bugs.
the ev aluation results show that buglocator is effective.
for exam ple buggy files for .
of eclipse .
bugs are ranke d in top .
on average the percentages of bugs whose relev ant files are ranked in top top and top are above and respectively confirming the effectiveness of the proposed approach.
our experiments also show that buglocator outperforms existing bug localization me thods using vector space model vsm latent dirichl et allocation lda latent semantic indexing lsi and smoothed unigram model sum .
the contributions of our work are as follows g120 we propose buglocator a new bug localization method that can perform better than the existing methods.
in buglocator we design a new vsm method that can effectively retrieve relevant buggy files given a query bug report.
our method also utilizes information about similar bugs that have been fixed before to improve the ranking performance.
g120 we perform a large scale evaluation of the bug localization techniques.
we have run buglocator on more than bugs in total which is much larger than the scale of experiments conducted in prior st udies.
we believe our method can help project teams locate files where the bugs should be fixed.
automating bu g localization work can help reduce maintenance cost and improve customer satisfaction.
the organization of the paper is as follows.
in sec tion ii we describe the background of this work.
in section iii we describe the proposed buglocator approach.
section iv describes our experimental design and section v sh ows and discusses the experimental results.
section vi give s the threats to validity.
we discuss the related work in section vii and conclude the paper in section viii.
ii.
background a. bug localization example in this section we present an example to illustrat e information retrieval based bug localization approa ch.
figure shows a real bug report id for eclipse .
.
once this report is received the developer needs t o locate relevant files among more than ten thousands eclips e source files in order to fix this bug.
we find that the bu g report including bug summary and description contains ma ny words such as pin pinned console view display etc.
therefore this bug is related to features about co nsole view.
in eclipse .
there is a source code file called consoleview.java which also contains many occurrences of the similar words.
figure shows a good match bet ween the bug report and the source code.
ltiple id we can treat the bug report and the source code fil es as text documents and compute the textual similarity between them.
for a corpus of files we can rank the files based on each file s textual similarity to the bug report.
d evelopers can then investigate the files one by one from the beginning of the ranked list until relevant buggy files are f ound.
in this way files relevant to the bug report can be quickl y located.
clearly the goal of bug localization is to rank th e buggy files as high as possible in the list.
figure .
a bug report and its relevant source code file b. general bug localization process before presenting our approach we describe a commo n bug localization process which consists of four st eps corpus creation indexing query construction and retriev al ranking.
corpus creation this step performs lexical analysis for each source code file and creates a vector of lexic al tokens.
some tokens such as keywords e.g.
int double c har etc separators operators are common to all programs an d are removed.
english stop words e.g.
a the et c. are also removed.
many variables defined in a program are a ctually a concatenation of words.
for example the variable typedeclaration contains two words type and declaration .
the variable iscommitable is composed of two words is and commitable .
these composite t okens are split into individual tokens.
many tokens have the same root form.
for example delegating delegate an d delegation share the same root delegat .
the por ter stemming algorithm is applied to reduce a word to its root.
indexing after the corpus is created all the files in the corpus are indexed.
by using these indexes one can locate files containing the words in a given query and the n rank these files by their relevance.
bug id summary pinned console does not remain on top description open two console views ... pin one console.
launch another program that produces output.
both consoles display the last launch.
the pinned console should remain pinned.
source code file consoleview.java public class consoleview extends pagebook view implements i consoleview i console listener ... public void display i console console if f pinned factive console !
null return ... public void pin i console console if console null set pinned false else if is pinned set pinned false display console set pinned true query construction bug localization considers a bug report as a query and uses it to search for releva nt files in the indexed source code corpus.
it extracts tokens from the bug title and description removes stop words stems ea ch word and forms the query.
retrieval and ranking retrieval and ranking of relevant buggy files is based on the textual simila rity between the query and each of the files in the corp us.
various approaches can be used to compute a relevan ce score for each file in the corpus given an input bu g report.
c. information retrieval models used in exisiting bug localization methods many bug localization approaches have been proposed .
these approaches mainly differ in the retrieval and ranking of the results.
there are many retrieval and rankin g models that have been used in prior studies on ir based bu g localization.
due to space constraint we just brie fly describe some important ones here sum smoothed unigram model sum is a statistical model that fits a single multinomial distribution t o the frequencies of words in each file in the corpus .
the unigram model um derived directly from the word frequency counts may have some problems especially when confronted with words that have not explicitly been seen before the probabilities of that unseen words are zero.
sum smoothes the probability distributions by assigning non zero probabilities to the unseen words .
sum was used for bug localization by rao and kak and was found to be the best performing model.
lda latent dirichlet allocation lda is a generative probabilistic model for collections of discrete dat a such as text corpora .
it is a bayesian model which ex tracts latent topics from a collection of documents.
each topic is a collection of tokens with attached probabilities.
e ach document is represented by a probabilistic mixture of topics.
it was used by lukins et al.
for bug localizat ion.
lsi latent semantic indexing lsi also called latent semantic analysis lsa is an indexing and retrieval method that can identify the relationship between t he terms and concepts contained in an unstructured collectio n of text by using mathematical techniques such as singular v alue decomposition svd .
this method was used by poshyvanyk et al.
for bug localization .
vsm in vector space model vsm each document is expressed as a vector of token weights typically co mputed as a product of token frequency and inverse document frequency of each token .
cosine similarity is widely used to determine how close the two vectors are.
ra o and kak evaluated the performance of vsm model in bug localization and found that it is worse than sum bu t better than other models including lda and lsi .
the existing methods have the following common limitations g120 low accuracy the performance of existing bug localization methods can be further improved.
for example using lda relevant files of only ecli pse .
bugs are ranked in the top .
g120 small scale experiments many of the existing static bug localization methods only used a small number o f selected bug reports in their evaluation.
iii.
the proposed approach a. analysis of bug localization problem to improve bug localization performance we leverag e the following observations source code files a project s source code repository contains source code files.
as illustrated in figur e source code files may contain words that are similar to th ose occurring in the bug reports.
therefore analyzing source code files can help determine the location where th e bug has impact on i.e.
the buggy files.
similar bugs once a new bug report is received we can examine similar bugs that were reported and fix ed before.
the information on locations where past sim ilar bugs were fixed could help us locate the relevant f iles for the new bug.
software size when two source files have similar scores we need to determine which one should be ra nked higher.
from our experiences in software defect pre diction and from other people s work on quantitative a nalysis of fault distributions we know that stati stically larger files are more likely to contain bugs.
there fore for bug localization we need to assign higher scores to larger files.
the source code file information has been used by existing bug localization methods .
however to our best knowledge the information about simila r bugs and software sizes has not been well utilized.
duri ng the design of our approach we take these information i nto consideration.
figure .
the overall structure of buglocator b. the overall structure of buglocator figure shows the overall structure of the propose d bug localization approach buglocator.
when a new bug r eport is received we treat it as a query and apply a rev ised vector space model rvsm to search the source code reposi tory.
a rank of relevant files is returned from the query o n source code files.
for the new bug report we also collect the similar final ranked files finalrank index file size new bug report ranked files rvsmrank previously fixed bug reports ranked files simirank query construction indexing query source code files analyzing past similar bugs retrieval ranking with rvsm bugs that have been fixed before and rank the rele vant files by analyzing past similar bugs and their fixes.
fin ally we combine the ranks obtained from the query on source code files and from the analysis of past similar bugs a nd return the users the combined ranks.
the users can then ex amine the returned files in descending order to locate th e bug.
we describe the detailed procedures in the following s ubsections.
c. ranking based on source code files we consider source code files as a text corpus and the initial bug report as a query.
we can then apply in formation retrieval techniques to create a model for searchin g source code files based on the bug report.
the similarity between each file and the bug report is computed.
the files are then ranked by the similarity values and returned as out put.
we propose a revised vector space model rvsm to index and rank the source code files.
in a classic vsm the relevance score between a document d and a query q is computed as the cosine similarity between their corresponding vector representations cos q d q d v v similarity q d q d v v g120 g32 g32 g41 g41 g38 g41 g41 g38 g41 g41 g38 g41 g41 g38 where dv g41 g41 g38 and qv g41 g41 g38 are a vector of term weights for the document d and query q respectively.
q d v v g120 g41 g41 g38 g41 g41 g38 represents the inner product of the two vectors.
the term weight w is computed based on the term frequency tf and the inverse document frequency idf .
the basic idea is that the weight of a term in a document is increasing with its occurre nce frequency in this specific document and decreasing with its occurrence frequency in other documents.
in classic vsm tf and idf are defined as follows log td tf docs tf t d idf t terms n g32 g32 where ftd refers to the number of occurrences of a term t in document d nt refers to the number of documents that contain the term t terms represents the total number of terms in document d and docs represents the total number of documents in the corpus.
over the years many va riants of tf t d have been proposed to improve the performance of th e vsm model .
these include logarithm augmented and boolean variants of the classic vsm.
it is observed that the logarithm variant can lead to better performance log td tf t d f g32 g14 in rvsm we use equation to define tf .
thus in equation each term weight w in the document vector dv g41 g41 g38 and its norm dv g41 g41 g38 are calculated as follows log log log log t d td t td t d td t d tdocs w tf idf f n docs v f n g143 g143 g32 g117 g32 g14 g117 g32 g14 g117 g166 g41 g41 g38 in the similar way we obtain the vector of term we ights for the query qv g41 g41 g38 and its norm qv g41 g41 g38 .
classical vsm favours small documents during rankin g. long documents are often poorly represented because they have poor similarity values .
according to prev ious studies larger source code files tend to have higher probability of containing a bug.
therefore w e should rank larger files higher in the case of bug localiz ation.
we thus define a function g equation to model the document length in rvsm 1n terms g terms e g16 g32 g14 equation is a logistic function i.e.
an inver se logit function that ensures that larger documents are gi ven higher scores during ranking.
we use equation to compu te the length value for each source file according to the number of terms the file contains.
in equation we use the normalized value of te rms as the input to the exponential function xe g16.
the normalization function is defined as follows suppose that x is a set of data xmax and xmin are the maximum and minimum data in x the normalization value of any x in x is min max min x x n x x x g16 g32 g16 combining the above analysis we thus propose a new scoring algorithm for rvsm as follows cos log log log log log log log n terms tq t q t td t d t tq td t q d trvsmscore q d g term q d e docs fn docs fn docs f f n g16 g143 g143 g143 g136 g32 g117 g32 g117 g14 g14 g117 g117 g14 g117 g167 g183 g117 g14 g117 g14 g117 g168 g184 g169 g185 g166 g166 g166 given a bug report we use equation to determin e the relevance scores rvsmscore between each source code file and the bug report.
a ranked list rvsmrank can be obtained according to the scores the first returne d result has the highest score .
d. ranking based on similar bugs for a new bug report we also examine similar bugs that have been fixed before in order to adjust the ranki ngs of the relevant files.
the assumption here is that similar bugs tend to fix similar files.
we propose a method for ranki ng relevant files based on similar bugs as follows we first construct a three layer heterogeneous grap h as shown in figure .
the top layer layer contains one node representing a newly reported bug b. the second layer contains nodes representing previously fixed bugs s that are similar to b. in our approach we do not enforce a similarity threshold.
a link between b and a bug in layer indicates that there is a non zero similarity value between t heir bug reports.
the third layer contains nodes representin g all source code files f. if a bug in layer is fixed in a file in layer a link between them is established indica ting that the bug has impact on the file.
figure .
heterogeneous bug file graph the weight of each node in layer si represents the degree of similarity between si and the newly reported bug b. this similarity is computed by equation .
the weight of each node in layer fj represents the degree of relevance between a source code file and the bug b which is computed as follows all that connect to i ji i s fsimiscore similarity b s n g32 g166 where si is a node in layer that connects to fj ni is the total number of connections to layer si has i.e.
the number of files that are modified to fix the bug si .
after computing the simiscore for each file using equation we then rank all files based on the simiscore values and obtain a ranking of relevant files simirank .
e. combining ranks having computed the scores obtained from querying source code files rvsmscore and from similar bug analysis simiscore we then combine these two scores for each file as follows finalscore n rvsmscore n simiscore g68 g68 g32 g16 g117 g14 g117 where g68is a weighting factor and i g68i 1.the finalscore is a weighted sum of rvsmscore and simiscore .
the source code files ranked by finalscore in descending order are returned to users finalrank .
files that are ranked higher are the more relevant ones i.e.
more likel y to contain the newly reported bug b. before we combine rvsmscore and simiscore we normalize them to the range of to using the normalization function defined in equation .
the parameter g68adjusts the weights of the two rankings.
the value of g68can be set empirically our experience shows when g68 is between .
and .
the proposed method performs the best.
iv.
experimental setup a. subject systems to evaluate the effectiveness of buglocator we use four open source projects as shown in table i. all proje cts have complete bug database and change history and have different numbers of bugs and source code files.
we choose eclipse in our evaluation because it is a well known large scale open source system and it is widely used in e mpirical software engineering research.
the aspectj project is a part of the ibugs public dataset provided by the univers ity of saarland .
it is also the subject used for evaluatin g various ir models for bug localization .
both e clipse and aspectj use the bugzilla bug tracking system an d the cvs svn version control system.
we also investigate the swt component of eclipse to evaluate the bug performance at the subproject level.
to further eva luate the generality of our approach we choose an android pr oject zxing which is maintained by google s bug tracking system and version control system.
b. data collection for each subject system we collect its initial bug reports from the bug tracking system such as bugzilla .
to evaluate the bug localization performance we only collect t he bug reports of fixed bugs.
to establish the links between bug reports and sour ce code files we adopt the traditional heuristics pro posed by bachmann and bernstein scan through the change logs for bug ids in a gi ven format e.g.
issue bug and so on .
exclude all false positive bug numbers e.g.
r4 and so on .
check if there are other potential bug number fo rmats or false positive number formats add the new forma ts and scan the change logs iteratively.
check if potential bug numbers exist in the bugtracking database with their status marked as fixed .
based on these heuristics we mine the source code repository such as cvs and svn for links between source code files and bug reports.
table i. the studied projects project description study period fixed bugs source files eclipse v3.
an open development platform for java oct mar swt v3.
an open source widget toolkit for java oct apr aspectj an aspect oriented extension to the java programming language jul oct zxing a barcode image processing library for android applications mar 2010sep http b a bug to be located a link represents the similarity between si and b s all similar bugs of b a link indicates the impact of a bug on a file f source code files layer layer layer c. research questions our experiments are designed to address the following research questions rq1 how many bugs can be successfully located by buglocator?
to answer this question we run buglocator on the f our subject systems as described in section iv.a.
for e ach bug report we first obtain the relevant files that hav e been modified to fix the bug using the method described in section iv.b.
we then check the ranks of these file s in the query results returned by buglocator.
if the files are ranked in top top or top we consider the report h as been effectively localized.
we perform the experiment fo r all bug reports and calculate the percentage of bugs that h ave been successfully located.
we also compute the mean aver age precision map and mean reciprocal rank mrr measures described in section iv.d to further eva luate bug localization performance.
rq2 does the revised vector space model rvsm improv e the bug localization performance?
in section iii we propose rvsm a revised vector space model equation for retrieving relevant files fr om source code repository.
rvsm adjusts the ranks of large fi les and incorporates a more effective term frequency varian t. to evaluate the effectiveness of rvsm we perform bug localization on the subject systems using classic a nd revised vsm and compare the results.
rq3 does the consideration of similar bugs improve th e bug localization performance?
in section iii we propose to use similar bugs to a djust the ranks obtained by rvsm.
to evaluate the usefuln ess of the proposed similar bug analysis we perform bug localization on the four subject systems with witho ut the rankings learned from past similar bugs.
furthermor e according to equation the parameter g68adjusts the weights of the two rankings.
when g68 the final rank is only dependent on the queries of source code files.
when the value of g68is between and the final rank is a combination of two ranking results.
in our experime nts we also evaluate the effect of different g68values.
rq4 can buglocator outperform other bug localization methods?
bug localization has attracted much research intere st in recent years.
in our experiments we compare bugloc ator to the bug localization methods implemented using the following ir techniques g120 lda which was used by lukins et al.
for bug localization.
following their lda configuration in our experiment for aspectj swt and zxing we set k the number of topics to g68 the hyper parameter for the per document topic distribution to .
t his is the default value computed by the standard formula k and the hyper parameter for the per topic word distribution to .
for eclipse as it is a large system consisting of many files we set k to g68 to .
and to .
which can lead to a better performance.
we use jgibblda an open source tool written in java to implement the lda model.
g120 sum which was used by rao and kak for bug localization.
in their study sum is shown to be th e best ir model for bug localization outperforming sophisticated models like lda and lsi.
g120 vsm which was also used by rao and kak for bug localization.
in their study vsm was the secon d best ir approach for bug localization.
g120 lsi which was used by poshyvanyk et al.
f or bug localization.
previous experiments sho w that the performance of sum vsm or lda is better than lsi.
following rao and kak we use kl divergence to compute the similarity measures for lda and sum.
we use the cosine similarity measure for vsm and lsi.
d. evaluation metrics to measure the effectiveness of the proposed bug localization method we use the following metrics g120 top n rank which is the number of bugs whose associated files are ranked in the top n n of the returned results.
given a bug report if the to p n query results contain at least one file at which th e bug should be fixed we consider the bug located.
the higher the metric value the better the bug localiz ation performance.
g120 mrr mean reciprocal rank which is a statistic fo r evaluating a process that produces a list of possib le responses to a query .
the reciprocal rank of a query is the multiplicative inverse of the rank of the first correct answer.
the mean reciprocal rank is t he average of the reciprocal ranks of results of a set of queries q q i imrr q rank g32 g32 g166 the higher the mrr value the better the bug localization performance.
g120 map mean average precision which provides a single figure measure of quality of information retrieval when a query may have multiple relevant documents.
the average precision of a sing le query avgp is the average of the precision values obtained for the query which is computed as follo ws number of positive instances 1m p j pos j avgp ii g117 g32 g166 g32 where j is the rank m is the number of instances retrieved pos j indicates whether the instance in the rank j is relevant or not.
p j is the precision at the given cut off rank j and is defined as follows number of positive instances in top j positions p j j g32 then the map for a set of queries is the mean of th e average precision values for all queries.
in bug localization a bug may be relevant to multiple fil es.
we use map to measure the average performance of buglocator for locating all relevant files.
the hig her the map value the better the bug localization performance.
v. experimental results a. experimental results for research questions rq1 how many bugs can be successfully located by buglocator?
table ii shows the best bug localization results ac hieved by buglocator for all subject systems.
for ecli pse bugs .
buglocator successfully locates the relev ant buggy source code files and ranks them as the top among the returned results.
for eclipse bugs .
buglocator ranks their relevant files within the to p of the returned results.
for eclipse bugs .
t he relevant files can be found within the top resul ts.
table ii.
the performance of bug locator system g68 top top top mrr map zxing .
.
.
swt .
.
.
.
.
.
aspectj .
.
.
.
.
.
eclipse .
.
.
.
.
.
for aspectj there are total java source code files and bugs.
for .
of the bugs i.e.
bug s the first relevant file is returned in the top and for .
of the bugs i.e.
bugs the first relevant file i s returned in the top .
the results indicate that our approach i s effective in localizing bugs in aspectj.
aspectj was also the subject program investigated i n .
in the authors compared various information r etrieval methods for bug localization and found that sum per forms the best in terms of the percentage of bugs being successfully located and map .
we compare the resul ts of buglocator with the sum results given in and find that buglocator outperforms sum figure .
for example using sum the relevant files of .
bugs are re turned as the top while using buglocator we can locate .
bugs in the top returned file.
the map values for sum and buglocator are .
and .
respectively.
in general buglocator improves the performance of sum by .
for swt table ii shows that for .
of the bugs buglocator ranks their relevant java source file as top for .
of the bugs buglocator ranks their relevant files within top for .
of the bugs buglocator ra nks their relevant files within top .
these ratios are high er than those of aspectj and eclipse.
for zxing buglocator achieves similar good performance.
the percentages of bugs whose relevant files are ranked top top and top are a nd respectively.
in summary the experimental results show that buglocator can help locate a large percentage of bu gs by examining a small number of source files.
figure .
the comparison between the results of buglocator an d the sum results given in on aspectj dataset rq2 does the revised vector space model rvsm improve the bug localization performance?
table iii shows the results of bug localization usi ng the classic vsm and the proposed revised vsm methods.
f or fair comparisons for the revised vsm we do not con sider similar bugs i.e the weight g68 is set to .
the experimental results show that the proposed vsm method outperfor ms the standard vsm.
for example for eclipse .
bug s .
whose relevant source file are returned as top using the proposed vsm method.
in classic vsm this number is only .
.
when measuring the performance in terms of map and mrr the proposed v sm method can lead to mrr value .
and map value .
which are better than the values achieved by the st andard vsm mrr .
and map .
.
similar results are observed for other projects as well.
table iii.
the performance of bug localization with classic and revised vsm models system vsm method top top top mrr map zxing classic .
.
revised .
.
swt classic .
.
.
.
.
revised .
.
.
.
.
aspectj classic .
.
.
.
.
revised .
.
.
.
.
eclipse classic .
.
.
.
.
revised .
.
.
.
.
top top top map percentage buglocator sum rq3 does the consideration of similar bugs improve the bug localization performance?
table iv below shows the experimental results of bu g localization without using information from similar bugs i.e.
the weighting factor g68 is .
comparing table ii and table iv we can see that the information of similar bugs can indeed improve the bug localization performance.
fo r example for the eclipse project utilizing similar bugs we can locate relevant source files at top for b ugs .
within top for bugs .
.
the mrr and map values are .
and .
respectively.
wit hout considering similar bugs only bugs .
ha ve their relevant files ranked as the top and bugs .
have their relevant files ranked within top .
the mrr and map values are only .
and .
respectively.
si milar results are observed for other projects as well.
table iv.
the performance of bug localization without using similar bugs system top top top mrr map zxing .
.
swt .
.
.
.
.
aspectj .
.
.
.
.
eclipse .
.
.
.
.
we also evaluate the impact of similar bug informat ion on bug localization performance with different g68values.
we find that at beginning the bug localization per formance increases when the g68value increases.
however after a certain point further increase of the g68 value will decrease the performance.
as an example figure below show s the bug localization performance measured in terms of map and mrr for the eclipse project.
when the g68 value increases from to .
both map and mrr values increases.
increasing g68 value further from .
to .
however leads to lower performance.
when g68is between .
and .
we obtain the best bug localization perfor mance.
rq4 can buglocator outperform other bug localization methods?
we implement bug localization methods using vsm lda sum and lsi models and perform experiments on all subject systems.
we then compare the performance of buglocator with the related methods.
figure shows the percentage of bugs that can be located in top and top returned files.
clearly buglocator outperforms all other methods.
for example using buglocator we can locat e .
eclipse bugs in the first returned top f iles while using vsm lda sum and lsi models we can only loc ate .
.
.
and .
eclipse bugs in the fi rst returned files respectively.
buglocator also outpe rforms other models when the performance is measured in te rms of map and mrr.
for example for zxing the map and mrr values are .
and .
respectively which ar e much higher than the second best model i.e.
sum whos e map and mrr values are .
and .
respectively.
det ailed results are omitted due to space constraints.
the t tests at confidence level confirm that our method statis tical significantly outperforms the others.
b. discussions of the results why does the proposed rvsm method work?
our experimental results described in the previous section show that the proposed rvsm performs better than the classical vsm when used for bug localization.
i n this section we discuss why the proposed rvsm can achie ve better performance.
the differences between rvsm and vsm are in the equations and .
equation uses the logari thm of the original tf value.
this is because terms with high frequency may have negative impact on information retrieval performance.
it is often not the case that the term importance is proportional to its occurrence frequency.
the lo garithm variant of tf can help smooth the impact of the high frequent terms .
equation adjusts the ranking results based on f ile sizes.
this is based on the findings of our earlier study that the larger files tend to be more defect prone than the smaller files.
figure .
the impact of on bug localization performance map and mrr .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mrr eclipse aspectj swt zxing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
map eclipse aspectj swt zxing figure .
the comparisons between different bug localization methods table v. the comparisons of different length functions length function g expression map mrr logistic 1xf x e g16 g32 g14 .
.
exponential .
xf x e g32 g16 .
.
square root f x x g32 g16 .
.
linear .
2xf x g32 g14 .
.
in we found that a small number of largest fi les account for a large proportion of the defects.
for example in eclipse .
of the largest files are responsib le for .
pre release defects and .
post release defects.
similar phenomenon is also observed by many others include ostrand et al.
.
they studied the rank ing ability of loc for two industrial systems and found that of largest files contain and of the bugs for t he two systems.
in summary the empirical studies confirm that by ranking larger files higher we can locate more bugs .
equation uses a logistic function g to adjust the ranking results.
we also experiment with other leng th functions including linear square root and exponen tial functions table v .
these functions weight files o f different sizes differently.
our experiment results table v show that the logistic function achieves the best overall map and mrr values outperforming other length functions.
why can similar bugs help improve bug localization performance?
we also explore why similar bugs can improve the bu g localization.
we find out that for many bugs the a ssociated files have overlaps with the associated files of th eir similar bugs.
for example in eclipse .
bugs ha ve at least one relevant file that is common to the files of their top most similar bugs.
for .
bugs all the ir relevant files are covered by their top most sim ilar bugs.
these results suggest that similar bugs can improve the bug localization performance.
the analysis of similar bugs becomes more important when the textual similarity between bug reports and source code is low.
as an example for the eclipse bug that is reported on march it was fixed in the file bindingcomparator.java .
using rvsm the relevant file bindingcomparator.java is only ranked because the textual similarity between source code and the bug report is low.
however the analysis on similar bugs found th at this bug is actually similar to previous fixed bugs and which all introduced bug fixing changes to the file bindingcomparator.java .
therefore buglocator combines the scores obtained from rsvm and similar bug analysis based on equation and the final rank of the file bindingcomparator.java becomes .
the percentage of code to be examined for bug localization our experimental results reported in the previous s ections only evaluate the performance of bug localization i n terms of the number of relevant files retrieved.
in practice s developers are also interested in the actual lines of code need to be examined in order to locate a bug.
this is of particular concern as the proposed rvsm model ranks larger sou rce files higher via the length function defined in equ ation .
we perform further experiments to evaluate how many lines of code are required to be examined in order to locate the bugs.
for each bug we count the number of file s to be examined before locating the bug and compute the l ines of code for each file.
the results show that buglocato r is still effective when its performance is measured in terms of lines of code to be examined.
for example by examining lines of code buglocator can locate nearly bugs in e clipse and bugs in aspectj.
buglocator can also locate more bugs than sum when the same number of lines of code is examined.
for eclipse using buglocator we can locate more than bugs b y examining of code while using sum the best performing method described in we can only lo cate eclipse aspectj swt zxing percentage top buglocator vsm lda sum lsi eclipse aspectj swt zxing percentage top buglocator vsm lda sum lsi about bugs by examining the same amount of code .
for the other systems we obtain similar results.
vi.
threats to validity there are potential threats to the validity of our work g120 all datasets used in our experiments are collected from open source projects.
the nature of the data in ope n source projects may be different from those in proj ects developed by well managed software organizations.
we need to evaluate if our solution can be directly applied to commercial projects.
we leave this as a future work.
g120 a limitation of our approach is that we rely on goo d programming practices in naming variables methods and classes.
if a developer uses non meaningful nam es the performance of bug localization would be affect ed.
however in our experiments we notice that in most well managed projects developers generally follow good naming conventions.
g120 bug reports provide crucial information for develope rs to fix the bugs.
a bad bug report could cause a d elay in bug fixing.
our approach also relies on the qual ity of bug reports.
if a bug report does not provide enoug h information or provides misleading information th e performance of buglocator is adversely affected.
vii.
related work bug fixing is an important but still costly activit y in software development.
spectrum based fault localiza tion techniques can help developers locate faults by examining a small portion of code.
these techniques usually contrast the program spectra inf ormation such as execution statistics between passed and f ailed executions to compute the fault suspiciousness of i ndividual program elements such as statements branches and predicates and rank these program elements by the ir fault suspiciousness.
developers may then locate faults b y examining a list of program elements sorted by thei r suspiciousness.
examples of spectrum based fault localization techniques include tarantula jaccard and ochiai .
the spectrum based fault localizati on techniques require program runtime execution traces .
our approach is based on the query of bug reports again st the source code repository which does not require the collection of the passing and failing execution traces.
there are also other techniques that help developers automatically locate bugs such as delta debugging and dynamic slic ing .
unlike these techniques our approach is a static a pproach which does not require the execution of the program s. in recent years many information retrieval based b ug localization methods have been proposed .
as described in the previous sections buglocator perf orms better than the related methods because of the util ization of rvsm and similar bug information.
this area of work is also closely related to feature concept location which is about identifying the parts of the source code that correspond to a specific functionality.
the results can be used as starting points in change impact analysis.
the problem of locating bug related code could be also treated as a feature concept location problem.
poshyvanyk et a l. presented a feature location method called promesir which combines results from both dynamic analysis a nd information retrieval.
they applied promesir to loc ate bugs in mozilla and eclipse systems.
gay et al.
also proposed a concept location approach that augments information retrieval based concept location via an explicit relevance feedback mechanism.
they evaluated their approach using eclipse bug reports.
our approach is dedicated to bug localization.
we perform large sca le evaluations using more than bug reports from f our different systems.
unlike the work described in and we do not require program execution or user i nteraction.
our work is also related to research on mining soft ware repository.
the existence of large amount of data s tored in bug tracking systems provides many opportunities fo r automated software quality analysis and improvement .
many researchers mine bug report information to solve so ftware engineering problems such as duplicate bug detectio n automatic bug triage bug report qualit y analysis and defect prediction .
because of the large number of bugs such problems cannot be effectively solved by manual efforts.
in our approach we utilize bug report information to automatically locate buggy files.
viii.
conclusions once a new bug report comes developers need to kno w which files should be modified to fix the bug.
for a large software project they may need to examine a large number of source code files in order to locate the bug wh ich could be a tedious and costly work.
in this paper we hav e proposed an ir based method named buglocator for locating relevant source code files based on initia l bug reports.
buglocator utilizes a revised vector space model rvsm as well as similar bug information.
the eval uation results on four real world open source projects sho w that buglocator can perform bug localization effectively .
the results also show that buglocator outperforms exist ing methods such as those based on vsm lda lsi and s um.
in future we will explore if program execution information can be integrated into our approach to help further improve bug localization performance.
we wi ll also apply buglocator to industrial projects to evaluate its effectiveness in practice.
our tool and the experimental data are available at acknowledgment this work is supported by nsfc grant and tsinghua university project 2010thz0.
we thank rong xin wu and aihui zhou for helping with data collection.