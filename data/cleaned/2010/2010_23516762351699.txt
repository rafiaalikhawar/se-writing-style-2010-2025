runtime monitoring of software energy hotspots adel noureddine1 aurelien bourdon1 romain rouvoy1 and lionel seinturier1 1inria lille nord europe project team adam france 2university lille lifl cnrs umr france 3institut universitaire de france france firstname.lastname inria.fr abstract greenit has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption.
in this domain most of the state of the art solutions concentrate on coarse grained approaches to monitor the energy consumption of a device or a process.
however none of the existing solutions addresses in process energy monitoring to provide in depth analysis of a process energy consumption.
in this paper we therefore report on a fine grained runtime energy monitoring framework we developed to help developers to diagnose energy hotspots with a better accuracy than the state of the art.
concretely our approach adopts a layer architecture including os level and process level energy monitoring.
oslevel energy monitoring estimates the energy consumption of processes according to different hardware devices cpu network card .
process level energy monitoring focuses on java based applications and builds on os level energy monitoring to provide an estimation of energy consumption at the granularity of classes and methods.
we argue that this permethod analysis of energy consumption provides better insights to the application in order to identify potential energy hotspots.
in particular our preliminary validation demonstrates that we can monitor energy hotspots of jetty web servers and monitor their variations under stress scenarios.
categories and subject descriptors d. .
metrics general terms performance measurement experimentation keywords power model power monitoring profiling bytecode instrumentation ase september 3 7 essen germany1.
introduction energy aware software solutions are becoming broadly available as energy concerns is becoming mainstream.
the increasing usage of computers and other electronic devices e.g.
smartphones sensors is continuously impacting our overall energy consumption.
information and communications techonology ict accounted for of global carbon emissions in or mtco 2e1 and is expected to grow to mtco 2ein .
ict also consumed up to of global power consumption or gigawatt gw in .
this number is predicted to grow and double to gw in or more than .
of worldwide power consumption .
these values illustrate the opportunities for efficient ict solutions to reduce carbon emissions and energy consumption.
rising energy costs in computers and mobile devices requires the optimization and the adaptation of computer systems.
in this domain research in greenit already proposes various approaches aiming at achieving energy savings in computers and software.
however most of the state of the art approaches either focus only the hardware or only offer coarse grained energy estimation feedback of software .
in this paper we therefore propose to gather fine grained applications power feedback information at runtime and with similar accuracy as hardware monitoring while using only a software approach.
our approach called e surgeon consists of a system monitoring library at the operating system level called powerapi and a software monitoring agent called jalen .e surgeon estimates the power consumption of applications source code methods in real time based on raw information collected from hardware devices e.g.
cpu network card through the operating system for powerapi and from raw information collected from software cpu time bytes transmitted through network through bytecode instrumentation for jalen .
we use both stateof the art power models and propose new models for estimating the power consumption of software at a finer grain.
as a first implementation we target java based applications and we validate our approach using standard application servers such as the jetty web server2.
our preliminary results demonstrate that we can diagnose power hotspots of java based applications at runtime offering opportunities to reduce their power consumption.
1metric tonne carbon dioxide equivalent to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
the remainder of this paper is organized as follows.
in section we describe our motivations and the main challenges we tackle.
section describes our approach the design of our proposed architecture and our power models.
section details the implementation of our prototype.
in section we report on the preliminary results we obtained and we validate them using a stress benchmark for the jetty web server in section .
related work is discussed in section while we conclude in section .
.
motiv ation and challenges .
motivation nowadays power management of software and hardware is achieved either through runtime coarse grained monitoring or through analyzing dump files of the application s resources utilization .
although these approaches allow power management of software they do not allow runtime and fine grained monitoring of the applications.
finegrained monitoring and visualization have many advantages i diagnose at a detailed level the power consumption and detect power hotspots at the threads and methods level ii provide detailed power information to be used for runtime power aware software adaptation and iii helps in providing insights to developers for producing power efficient code.
the green challenge for usi has identified that profiling applications to detect cpu hotspots is a winning strategy for limiting the power consumption of applications.
therefore we argue that a fine grained approach for proposing power aware information is a keystone for future poweraware systems and software.
.
challenges hardware monitoring is usually achieved through additional hardware measurement equipments such as multimeters or specialized integrated circuits cf.
section .
this approach offers a precise and accurate measurement of the power consumption of hardware components but at a cost of an additional investment.
however it can neither monitor the power consumption of software components nor go into the details of software classes and methods usages.
we rather believe that a scalable approach can be better obtained through a software centric approach.
monitoring the power consumption of software has to yield many challenges in order to build an accurate software centric approach.
we outline some of the main difficulties that software monitoring has to cope with if accurate monitoring is to be offered accuracy.
the biggest problem that software monitoring tools face is providing accurate estimations of power consumption based on various collected information.
unlike hardware measurement software approaches use power models in order to provide an estimation of the power consumption of software components.
however these estimations tend to have different degrees of accuracy and overhead.
overhead.
as software approaches monitor the executing software and calculate a power estimation of their consumption an overhead is therefore always observed.
the latter depends both on the degree of accuracy needed and on the size of the monitoring tooland the monitored application.
this leads to a tradeoff between the accuracy requirements and the cost of the software monitoring tool.
fine grained.
many of the current approaches cf.
section stop their power consumption estimation at the process level.
some of these approaches provide limited fine grained but still raw values such as execution time of methods or active time of threads .
however providing fine grained estimation of the power consumption of software components is not as intuitive as mixing raw values and power models.
the question arises to know which raw values is needed.
how can we collect them?
which power models can we use and in which context?
power models.
models to estimate the power consumption have already been proposed cf.
section .
however most of these models are coarse grained and hardware related such as providing general formulae for power consumption of the hardware components e.g.
cpu network card .
models therefore need to be optimized for our context of fine grained power consumption computation.
laying these challenges we propose in the next section an approach named e surgeon for monitoring and profiling applications at runtime.
.
e surgeon design and approach in this section we present our power monitoring approach called e surgeon .
we first present e surgeon general architecture then we describe the power models we integrated.
.
architecture e surgeon architecture is composed from two distinct but complementary parts a system level power monitoring environment called powerapi and a software level application profiling environment called jalen .
these two parts work along each other in order to provide accurate runtime energy information at the application level threads and methods levels .
figure depicts the overall architecture of our approach.
figure e surgeon reference architecture.
.
.
powerapi powerapi architecture is a modular architecture built for agile software programming.
the core of the architecture are power modules .powerapi is developed as separate modules that can be started or stopped at runtime upon needs.
a set of os dependent sensor modules e.g.
scpu snetwork collect raw information about hardware resource utilization either directly from the devices or through the operating system.
these information are then exposed to another set of os independent formula modules that uses our power models cf.
section .
to compute the power consumption of each hardware component e.g.
fcpu fnetwork .
these modules also compute the power consumption of running processes and applications per hardware resource.
a local database db in figure is also used to store static information about the hardware resources and used to automatically calibrate powerapi depending on the environment.
finally all these modules are managed through a life cycle module.
the latter allows to start stop add remove or modify modules depending on monitoring needs and commands sent by applications.
figure powerapi reference architecture.
.
.
jalen jalen is a software level profiling architecture.
it is responsible for profiling running applications and estimating their energy consumption at a finer grain i.e.
at threads or methods level.
several profiling techniques can be used such as bytecode instrumentation or sampling the application.
each of these methods have benefits and drawbacks.
the former does not modify the code of the application and provides an overview of the application s energy consumption.
however it is less accurate than code instrumentation.
the latter injects profiling code into the application s code or bytecode therefore allowing the profiler to capture all the necessary events related to energy consumption.
on the other hand instrumentation adds an overhead for running the additional code.
our approach however does not specify a single method of profiling.
we prefer to keep this as a technical choice during implementation and to use dedicated apis to communicate with the profiler and the lowlevel monitoring environment are to be respected.
the profiling part introspects the application at runtime collecting statistics about its resources utilization.
information such as methods durations cpu time or the number of bytes transferred through the network card are collected and classified at a finer grain e.g.
for each method of the application.
next a correlation phase takes place to correlate the application specific statistics with the processlevel power information.
details on our power model for the correlation are presented in section .
.
finally theper method or per thread power consumption information is displayed to the user and can be exposed as a service to be used for example in an application s autonomous adaptation cycle .
.
power models we propose a comprehensive power model using our proposed formulae as well as formulae taken from the state ofthe art.
in the energy cost of a software is computed based on the following formula esoftware ecomp ecom einfra where ecomp is the computational cost i.e.
cpu processing memory access i o operations ecomis the cost of exchanging data over the network and einfra is the additional cost incurred by the os and runtime platform e.g.
java vm .
we base our model on a similar principle taking into account the modular aspect of the power calculation e.g.
the sum of the power consumption of different hardware components .
infrastructure power einfra is included in the computational cost of our power models and in our prototype.
power in watt is computed as the energy consumption in joule per unit of time one second .
from this we can abstract our global power formula to the following psoftware pcomp pcom at this stage we defined two models one for cpu computational costs and one for network communication costs.
pcomp is therefore equal to the cpu power consumed by software and pcomis equal to the power consumed by the network card for transmitting software s data.
next we detail the cpu and network power models we use in powerapi and the cpu and network power models we use in jalen .
.
.
powerapi power models cpu model.
the cpu power consumed by a specific application in our case we use process pids can be represented by the following formula ppid cpu d pcpu d upid cpu d where ppid cpu d is the cpu power consumed by the specific process pid during a given duration d pcpu d is the overall cpu power during dandupid cpu d represents the process cpu usage during d. thus our approach is to estimate the power required by the cpu to execute the process pid.
this is achieved by computing the cpu percentage usage of the pid by the overall cpu power during a given duration d. next we detail our model in order to compute pcpu d the global cpu power and upid cpu d the process cpu usage.
overall cpu power.
the overall power consumption for the majority of modern processors cmos3 follows the standard equation pf v cpu c f v2 3complementary metal oxide semiconductor162where fis the frequency vthe voltage and ca constant value depending on the hardware materials such as the capacitance and the activity factor .
thanks to this relation we note that power consumption is not always linearly dependent to the percentage of cpu utilization.
this is due to dvfs dynamic voltage and frequency scaling and also to the fact that power depends on the voltage and subsequently the frequency of the processor.
for example a process at cpu utilization will not necessarily consume more power than a process running at cpu utilization but with a higher voltage.
therefore a simple cpu utilization profiler is not enough in order to monitor power consumption.
our power model takes into consideration these aspects of the cpu and allows accurate power consumption monitoring.
according to formula computing the overall cpu power for a given time is equal to computing a static part the constant c and a dynamic part the frequency fand its associated voltage v .
for the static part the cconstant is a set of data describing the physical cpu e.g.
capacitance activity factor .
manufacturers may provide this constant but in most cases this value is missing.
to alleviate this problem we use the existing relation between the overall power of a processor and its thermal design power tdp value.
tdp represents the power the cooling system of a computer is required to dissipate the heat produced by the processor.
therefore the overall cpu power can be associated with the tdp as described in the following formula pftdp vtdp cpu similarequal0.
tdp where ftdp andvtdp represent respectively the frequency and the voltage of the processor within the tdp state .
the benefit of using this formula is that tdp is a value provided by most manufacturers.
in our architecture tdp is stored inpowerapi s local database.
for the dynamic part the frequency fis associated to a specific voltage v. for a given voltage one or more frequencies are associated.
thus lowering the voltage results in changing frequency.
the other way around is also valid although in some cases a single voltage can support more than one frenquency.
frequencies used by a processor are provided by the operating system apis while voltages are given by manufacturers.
process cpu usage.
in order to compute the cpu usage for a given process identified by its pid we propose to calculate the ratio between the cpu time for this pid and the global cpu time the time the processor is active for all processes during a duration d upid cpu d tpid cpu tcpu d our approach is inspired by well known tools such as the top linux program4.
thus the cpu power consumption in a duration dand for a given frequency f pf comp is equal to pf comp .
tdp ftdp v2 tdp f v2 tpid cpu tcpu d the cpu power consumption for a process pcomp of formula is equal to the average of the cpu power of each frequency balanced by the cpu time of all frequencies pcomp summationtext f frequenciespf comp tf cpu summationtext f frequenciestf cpu .
.
network model the network power of a process is calculated using a formula similar to the cpu power formula.
we base our model on available information whether they are collected at runtime or provided by manufacturers documentations.
as a first step we focus on ethernet network cards.
a similar model using a linear equation can be applied for wireless network cards but we did not investigate wireless cards yet.
we obtain from manufacturers documentations the power consumed in watt for transmitting bytes for a certain duration typically one second according to a given throughput mode of the network card e.g.
mb mb .
our network power model is therefore defined as powernetwork process summationtext i statesti pi d ttotal where pstate is the power consumed by the network card in the state i provided by manufacturers dis the duration of the monitoring cycle and ttotal is the total time spent in transmitting data using the network card.
in the next section we detail the cpu and network power models in jalen .
.
jalen power models .
.
cpu model using the information collected from profiling applications and the monitored system we are able to calculate a reasonable estimation of the cpu time per method.
and we use this information to compute the cpu power consumed per method and thread.
as application code is generally executed inside threads i.e.
java we first calculate the power consumed per thread.
for that we apply the following formula powercpu thread timecpu thread powercpu process duration cycle where timecpu thread is the cpu time of the thread in the last monitoring cycle obtained from the environment such as the os or the jvm powercpu process is the power consumed by the application process in the last monitoring cycle obtained from powerapi and duration cycle is the duration of the monitoring cycle.
we then filter the methods to get the list of methods running in the last monitoring cycle whether they are still running or not .
for each thread we get the methods that it invoked from the list a thread usually has its own execution stack which is made of frames.
a frame represents a method invocation .
furthermore we estimate with a good accuracy the cpu time for each method using the following formula timecpu method duration method timecpu thread summationtext m methodsduration m 163where duration method is the execution time of the method in the last monitoring cycle and summationtextduration methods is the sum of the execution time of all methods in the last monitoring cycle.
finally we calculate the power consumed per method using this formula powercpu method timecpu method powercpu thread duration cycle .
.
network model we calculate the network power using the number of bytes transmitted by the application.
we first calculate the number of bytes read written in the last monitoring cycle.
then we collect the network power consumed by the application process from our system library powerapi .
the network power consumed per method is therefore powernetwork method bytes method powernetwork process bytes process where bytes method is the number of bytes read and written by the method powernetwork process is the power consumed by the application and byte process is the number of bytes read and written by all methods of the application.
the network power consumption per thread is therefore the sum of the network power of all methods running in the thread as shown in the following formula powernetwork thread summationdisplay powernetwork methods in the next section we describe the implementation e surgeon using our power models.
.
implementation the implementation of e surgeon includes a system level modular library powerapi and a java tool instrumenting bytecode at runtime jalen .
cpu and network modules as well as profiling functionalities are provided.
the source code of our e surgeon prototype is available at github5.
.
powerapi powerapi is implemented as a system level modular library.
we implemented so far the cpu and network modules and power models.
our system level library aims to provide power information per pid for each system component cpu network card etc.
.
the library is therefore based on a modular approach where each system component is represented as a power module .power modules operate independently from each other and are composed by two sub modules formula and sensor .
these sub modules communicate using the service oriented architecture soa paradigm and are contained in an osgi6container.
in particular we use service oriented framework sof to implement the various modules of powerapi in c .
the sensor sub module is responsible for gathering operating system related information for the module.
for example it gathers the number of bytes transmitted by the network 6formerly open service gateway initiative and the time spent by the cpu at each of the processor frequencies when dvfs is supported .
these data are basically given by the operating system giving to the sensor sub module of being os dependent.
in particular our implementation based on a gnu linux distribution exploits system information available in the procfs andsysfs file systems .
the formula sub module on the other hand is hardware independent.
indeed this sub module is responsible for estimating the power consumed for each process by using both information gathered by the sensor sub module and information based on hardware characteristics.
for instance in case of cpu energy consumption our model has to take into account the frequency and voltage ranges or thermal dissipation power.
we implemented sensor and formula sub modules for the cpu and nic on a gnu linux operating system.
additionally our library supports the lifecycle management of its power modules.
the latter can be started stopped and their parameters changed at runtime using a modules manager .
the benefit of this modular approach is to offer flexibility while monitoring the system and to control the overhead of the monitoring library.
we provide a modular library where only part of its components are platform dependent.
its modularity allows easy porting of the library while retaining most of its power modeling code.
although powerapi works as a standalone library it is used in addition to our application power monitoring component jalen .
.
jalen we also developed a runtime application power monitoring component called jalen as part of the e surgeon architecture.
jalen uses the per process power information provided by powerapi and correlates it with information collected from the application monitoring in order to provide per method power information.
jalen is designed as a twoparts architecture i a java programming language agent that instruments the bytecode of the application in order to inject our monitoring code and ii a jmx client computing and correlating the collected data.
this client extracts the per method power consumption values.
figure overviews the architecture of jalen .
figure the jalen architecture.
we use bytecode instrumentation technics8to inject our monitoring code into the methods of legacy applications.
in order to reduce the overhead introduced by the instrumentation we offload all the computations to a remote jmx client.
therefore our java agent only collects raw values such as for the cpu the start time end time running status executing thread identifier and callee method using a custom execution stack trace .
for the network we use a delegator to route calls from the class socketimpl9to a custom implementation.
we override the methods getinputstream and getoutputstream to monitor the number of bytes read and written to sockets.
this information is then correlated with the method names invoking the methodsgetinputstream orgetoutputstream in order to get the number of bytes read written by method.
all these collected information are then exposed in a mxbean10 interface.
in particular the agent performs calculations in order to determine the actual duration of the execution of the method during the last monitoring cycle.
this calculation takes into account all the calls to the methods executed in a same thread.
it also separates the calculations of these methods by thread.
for example method a is called twice from thread x and three times from thread y. the calculations generate two results one where the duration is the sum of the two calls in thread x and the second where the duration is for the sum of the three calls in thread y. we do not merge these numbers because we need to construct the call tree in order not to take into account the delta duration of the callee method when its children are being executed.
our prototype can handle this on a per thread basis thanks to this separation.
then we build a jmx client that not only displays the collected information but also does the computation and correlation in order to determine the cpu and network power consumed per method in each monitoring cycle.
the jmx client collects information exposed by the agent s mxbean .
using power models and metrics correlations cf.
section .
we estimate the cpu power and the network power consumed per method.
.
empirical v alidation we validate the accuracy and precision of our e surgeon prototype on a dell precision t3400 workstation with an intel core quad processor q6600 running ubuntu linux .
and java .
we first evaluate our powerapi library cf.
section .
and then evaluate our jalen java agent cf.
section .
.
based on these results we conduct an analysis of a stress benchmark on a jetty web server version .
.
.v20111024 in section .
.
powerapi validation .
.
cpu power we first assess the accuracy of the results provided by our system library.
we compared the power values provided by powerapi with the actual power consumption of the computer using a powermeter.
in our tests we use powerspy11 a bluetooth powermeter.
we compare the values of our library and the powermeter in a stress test on jetty web server using apache jmeter12 cf.
figure and using the linux stress command13 cf.
figure .
note that due net socketimpl.html management mxbean.html synchronization time lag between powerspy and our library values are shifted for a few seconds in the beginning of the monitoring.
these values are normalized in order to observe trends in the cpu power consumption.
we normalize these values by subtracting for each measured value of the powermeter the average of the differences between the values measured by the powermeter and provided by our library.
the results show minor variations between the values estimated by our library and the actual power consumption.
the margin of error is estimated to .
of the normalized and averaged values in the core stressing scenario.
the error grows to nearly in the jetty stress test.
we use the linux top program to compute the cpu utilization of monitoring one process by powerapi and estimate it at around .
.
therefore we can reasonably argue that using a software centric approach provides values that are accurate enough to be used by power management software.
figure stressing the processor cores with the stress command.
figure running stress tests on jetty using jmeter.
.
.
network power we run a network stress test using iperf14and measured the power consumption of iperf s cpu server on our host configuration.
we send two sets of tcp packets of 100mb each from a distributed client to our host server.
we used the default settings of iperf where also its cpu server executes following a periodically cycle every second .
our results show network consumption around .
watt compared to cpu consumption of iperf process around .
watt.
these numbers show that although cpu power is quite low average around .
watt and the network card uses all its capacity the consumed network power is largely negligible compared to the consumed cpu power on our test server.
this observation is in correlation with the literature .
therefore we mostly outline the results of our cpu experimentation.
figure cpu and network power consumption in iperf stress test.
.
jalen validation we calculate the cpu overhead of our jalen java agent using the start time and the time per request of apache tomcat .
.
application server15as a comparison metric.
this metric involves many of tomcat s classes and methods and is provided by default by tomcat .
the average start time of tomcat on our host configuration a macbook pro mid and java .
is around .
ms. with jalen java agent tomcat while having its methods instrumented took ms in average.
therefore our agent introduces an overhead of .
.
we also calculate the time per request using apachebenh .
.
on requests the mean time per request is at .
ms with jalen in comparison to .
ms without.
the time overhead per request is therefore at .
.
even though these numbers may appear to be high they should compared to the overhead of similar profilers.
we therefore compared our results of tomcat s start time with thejava interactive profiler jip .jipalso instruments bytecode but does not offer power related information.
with jip tomcat took .
ms to start or an overhead .
.
thus jalen have an overhead lower to similar method level bytecode instrumentation profilers such as jip.
figure summarizes these numbers.
figure time overhead of jalen with tomcat start time.
in the next section we present and discuss the results of our approach on monitoring and detecting energy hotspots of jetty web server.
.
energy hotspots of jetty the goal of our approach is to detect energy hotspots in applications.
jetty web server is an example of such complex applications counting source lines of code sloc in the version we used for our study version .
.
.v20111024 .
we run our e surgeon prototype system library and java agent plus a jmx client on an instance of jetty web server.
we use jmeter to stress jetty server using a benchmark scenario stressing the examples provided by default in jetty .
we run the experimentation for an average time of one minute with threads users in jmeter and a loop count of .
the results we gathered are presented in figure .
the graph portrays the top most powerconsuming methods in the x axis out of instrumented methods .
the right y axis thus the bars represents the power consumed during our execution in percentage of the total power consumed.
the left y axis thus the line represents the number of invocations of the method.
we run this experiment several times and although we had difference in the watt power values we notice that the global and proportional percentage is stable.
note also that the provided values are an aggregation of the execution of the methods on all threads.
figure cumulated power consumption of jetty methods under jmeter stresses top most powerconsuming methods .166the first observation is that the top methods consumes nearly half of the total power consumed by jetty during the stress benchmark .
.
more interestingly we observed that the method org eclipse jetty io bytearraybuffer.get consumes .
of the total power by its own with a similar number of invocations compared to other methods.
we also analyze the power consumption per method invocation of the top methods.
the results are presented in figure .
we observe that org eclipse jetty io abstractbuffer.putindex has a lower power per invocation in the top methods.
this method consumed .
of total power during the tests but was invoked times.
thus this method has a power per invocation of .
microwatts.
on the other hand org eclipse jetty io bytearraybuffer.get has a power per invocation of .
microwatts with invocations and .
of global power consumed.
figure power in watt per invocation of the top most power consuming methods lower is better .
the results for the most consuming classes out of are reported in figure .
we note that the aforementioned classes org eclipse jetty io abstractbuffer with .
andorg eclipse jetty io bytearraybuffer with .
consume alone more than of the total power .
.
io abstractbuffer is an averaged sized class in jetty of sloc where only of its methods has been invoked times while the latter is even smaller with sloc where of its methods have been invoked times.
these numbers show a strong relation between the energy consumption of methods and their number of invocation.
these results can be explained by our benchmark stress scenario.
the latter stresses jetty web server using http requests on servlets with simple executed jsp code.
therefore the highest power consumption in our tests is concentrated on classes which manage reads and writes of http requests e.g.
org eclipse jetty io abstractbuffer org eclipse jetty io bytearraybuffer .
this strengthen our initial validation of the accuracy of e surgeon .
we believe that this information can help the developers to investigate alternative implementations of the class org eclipse jetty io bytearraybuffer in order to reduce the power footprint of this method.
by keeping track of the figure cumulated power consumption of jetty classes under jmeter stresses.
power footprint of classes and methods we think that development tools e.g.
coding completion systems documentation debuggers etc.
could be extended to help developers build greener software.
.
limitations our results show that we can identify energy hotspots in applications and in jetty web server in particular.
however and even though we used a benchmark imitating a real case scenario we are aware that our results should not be generalized without further consideration.
first our aim was to observe trends in energy consumption which is the reason of using percentages when comparing methods and classes .
raw watt values are less relevant as direct measurements vary greatly between hardware i.e.
a given application consumes different amount of energy when running on two different machines such as a laptop or a server .
therefore we argue that our approach is useful in profiling applications in order to find the origin of energy leaks.
developers can then provide hotfixes for the application in order to reduce its energy footprint.
second and in comparison with our first point the overhead of our prototype is not negligible thus limiting its usage in production .
overhead for tomcat s individual requests cf.
section .
.
although it is comparable to similar bytecode profilers the overhead is penalizing to be used in production systems e.g.
tomcat jetty .
we also developed a lightweight version providing the energy consumption of running threads but not methods and classes .
this version does not use bytecode instrumentation therefore its overhead is negligible in jetty and tomcat and with a .
increase in time.
note also that the computation of the energy consumption of methods and threads is realized in a separate process and that powerapi runs also in a dedicated process thus limiting the impact on the execution of the monitored application.
we believe that the overhead of our power model and architecture is controlled and can be considered is acceptable with regards to the benefits of the computed energy indicators.
.
future directions our study aims at providing a representation of the energy consumption of cpu and network intensive software at different levels of granularity e.g.
application source code .
in the future we plan to extend ou approach to measure hardware components that contribute to a high percentage in energy consumption of applications which are in addition to the cpu the memory and the disk.
we are also planning to develop additional sensors for different hardware configurations and environments because energy consumption depends on the hardware environment e.g.
modules compatible with windows mac os and different hardware models .
developing sensors and modules for virtual machines allows our model to reduce its dependency on hardware parameters e.g.
dealing with the diversity of hardware is therefore left to the virtual machine and consider energy accounting issues in the context of green computing environments.
.
related work in this section we outline the relevant related works to energy modeling energy monitoring and metering powerrelated tools at the system level and application profiling tools in particular for java applications.
.
energy metering and modeling monitoring energy consumption of hardware components usually requires an hardware investment like a multimeter or a specialized integrated circuit.
for example in the energy management and preprocessing capabilities is integrated in a dedicated asic application specific integrated circuit .
it continuously monitors the energy levels and performs power scheduling for the platform.
however this method has the main drawback of being difficult to upgrade to newer and more precise monitoring and it requires that the hardware component be built with the dedicated asic thus making any evolution impossible without replacing the whole hardware.
on the other hand an external monitoring device provides the same accuracy as asic circuits and does not prohibit energy monitoring evolutions.
the previous monitoring approaches retrieve energy measures about hardware components only.
however knowing the energy consumption of software services and components requires an estimation of that consumption.
this estimation is based on calculation formulae as in and .
in the authors propose formulae to compute the energy cost of a software component as the sum of its computational and communication energy costs.
for a java application running in a virtual machine the authors take into account the cost of the virtual machine and eventually the cost of the called os routines.
our model is based on a similar principle although we abstract the cost of the infrastructure in our computational costs.
however the authors calculate the energy cost of components in terms of the cost of its interfaces i.e.
a method in most cases .
the latter is calculated as an estimation of the energy cost of executing java s bytes code types jvm s native methods and the cost of threads synchronization.
our computation model is based on runtime power consumption.
the cpu power consumed by a method is its percentage share of the power consumed by the application calculated using the actual cpu timeand utilization of the method.
on the other hand our network model is similar to theirs as both are based on the size of data transmitted send receive during the invocation of the program.
still we use runtime monitored values to calculate power consumption while they use estimations at construction time albeit refined at runtime.
in the authors take into account the cost of the wait andidlestates of the application e.g.
an application consumes energy when waiting for a message on the network .
we also take these states into account by only using the actual time spend running on a resource i.e.
cpu network card .
in the authors propose a tool powerscope for profiling energy usages of applications.
this tool uses a digital multimeter to sample the energy consumption and a separate computer to control the multimeter and to store the collected data.
powerscope can sample the energy usage by process.
this sampling is more accurate than energy estimation although it still needs a hardware investment.
.
system level tools ptop is a process level power profiling tool.
similar to the linux top program the tool provides the power consumption in joules of the running processes.
for each process it gives the power consumption of the cpu the network interface the computer memory and the hard disk.
the tool consists in a daemon running in the kernel space and continuously profiling resource utilization of each process.
it obtains these information by accessing the proc directory.
for the cpu it also uses tdp provided by constructors in the energy consumption calculations.
it then calculates the amount of energy consumed by each application in a tinterval of time.
it also consists of a display utility similar to the linux top utility.
our approach is more flexible and fine grained than ptop .
not only we offer process level power information but we also go deep into the application in order to profile and report thread and method level power consumptions.
furthermore the system level part of e surgeon offers better flexibility and on demand scaling of the tool.
monitoring modules can be shutdown or started depending on the context on limited resources devices modules such as the network or hard disk modules can be shutdown in order to monitor only the cpu.
when more resources become available these modules will be re started.
other situations are also possible such as situations where the user is only interested in monitoring the cpu or the network energy consumption.
powerapi also adapts to its monitored environment thanks to its auto calibration process in particular by using calibration data stored in its database.
our flexible and modular approach therefore offers these functionalities and extends them to not only os processes but also inside java based applications profiling.
in addition to ptop several utilities exist on linux for resource profiling.
for example cpufrequtils17 in particularcpufreq info to get kernel information about the cpu i.e.
frequency and cpufreq set to modify cpu settings such as the frequency.
iostat18that is used to get devices cpufrequtils.html partitions input output i o performance information as well as cpu statistics.
other utilities also exist with similar functionalities such as sar mpstat or the system monitoring applications available in gnome kde or windows.
however all of these utilities only offer raw data e.g.
cpu frequency utilized memory and do not offer power information.
.
application profiling tools several open source or commercial java profiling tools already propose some statistics of java applications.
tools such as visualvm19 java interactive profiler jip or the oktech profiler21 offer coarse grained information on the application and fine grained resource utilization statistics.
however they fail in providing power consumption information of the application at the granularity of threads or methods.
for example the profiler of visualvm only provides self wall time e.g.
time spend between the entry and exit of the method for its instrumented methods.
we rather provide runtime values for the duration of execution of methods in a monitoring cycle and give a good estimation of the cpu time of these methods.
these tools also lack of providing network related information such as the number of bytes transmitted by methods and thus the power consumed.
.
conclusion and future work in this paper we report on the e surgeon runtime energy monitoring solution.
it allows to gather and calculate the power consumption at processes and methods level.
its modular architecture allows runtime context based adaptations of the monitoring environment itself leveraging performance and accuracy at the wish of the application or the user.
we also propose power models to calculate the power consumption.
our models use and extend the state of the art models and formulae and port them to a fine grained context.
our initial results show the potential of our approach for diagnosing at runtime power hotspots of java based applications.
as for future work we plan to i propose more power models for other hardware resources in particular memory and disk ii as application servers are more and more running on virtual machines we plan to implement specific sensors to these environments and experiment our model and approach on them and iii usee surgeon and power aware information to adapt applications at runtime based on power concerns.
.