micro execution patrice godefroid microsoft research one microsoft way redmond wa usa pg microsoft.com abstract micro execution is the ability to execute any code fragment without a user provided test driver or input data.
the user simply identifies a function or code location in an exe or dll.
a runtime virtual machine vm customized for testing purposes then starts executing the code at that location catches all memory operations before they occur allocates memory on the fly in order to perform those read write memory operations and provides input values according to a customizable memory policy which defines what read memory accesses should be treated as inputs.
microx is a first prototype vm allowing micro execution of x86 binary code.
no test driver no input data no source code no debug symbols are required microx automatically discovers dynamically the input output interface of the code being run.
input values are provided as needed along the execution and can be generated in various ways e.g.
randomly or using some other test generation tool.
to our knowledge microx is the first vm designed for test isolation and generation purposes .
this paper introduces micro execution and discusses how to implement it strengths and limitations applications related work and long term goals.
categories and subject descriptors d. .
testing and debugging general terms testing verification keywords program execution testing virtual machine .
introduction among the various kinds of testing usually performed during software development unit testing applies to the individual components of a software system e.g.
see .
in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india.
copyright acm ... .
.theory unit testing plays an important role in ensuring overall software quality since its role is to detect errors in the component s logic check all corner cases and provide code coverage.
yet in practice unit testing is so hard and expensive to perform that it is rarely done properly especially for components of large complex legacy code bases.
indeed in order to be able to execute and test a component in isolation one needs to write test driver harness code to simulate the environment of the component.
more code is needed to test functional correctness for instance using assertions checking the component s outputs.
since writing all this testing code manually is expensive unit testing is often either performed poorly or skipped altogether.
in this paper we propose a radically new approach to unit testing whereby the user does not need to write any test driver harness code at all nor provide any input data.
the new key idea explored in this work is to discover dynamically the input output i o interface of the code being executed by means of a virtual machine vm modified for testing purposes.
the user simply identifies a function or code location an offset in an exe or dll.
a runtime vm then starts executing the code at that location catches all memory operations before they occur allocates memory on the fly in order to perform those read write memory operations and provides input values according to a customizable memory policy which defines what read memory accesses should be treated as inputs.
input values are provided as needed along the execution and can be generated in various ways e.g.
randomly or using another test generation tool.
we call micro execution the ability to execute any code fragment without a user provided test driver or input data.
microx is a first prototype vm allowing micro execution of x86 binary code.
no source code or debug symbols are required.
no test driver harness is required either microx automatically discovers dynamically the i o interface of the code being run.
to our knowledge microx is the first vm for testing purposes which replaces the functionality of a static test driver by a runtime environment for dynamically discovering the i o interface of the program under test with high precision and providing input values only when needed in a lazy manner.
our current microx prototype is a modification of the nirvana vm as well as of the idna truscan sage tool stack .
in particular the whitebox fuzzer sage can be used to guide micro executions of the code being tested using dynamic symbolic execution constraint generation and solving techniques.
microx significantly lowers the upfront cost of unit testingpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
by allowing automatic testing of arbitrary code fragments without writing any test driver code.
micro execution can reveal software bugs such as memory corruptions or buffer overflows due to incomplete input validation or erroneous manipulations of data structures that are local to the unit under test.
it is complementary and should be used in conjunction with runtime analysis tools like purify valgrind appverifier for checking standard program properties like buffer overflows memory leaks etc.
.
it can also check for application specific properties test oracles specified as assertions embedded in the code under test.
micro execution of a code fragment makes sense mostly if all its inputs are unconstrained i.e.
can take any value.
otherwise micro execution may trigger program behaviors and bugs that are uninteresting false positives because they cannot occur in a realistic environment for that program.
in that case input constraints preconditions or a modified memory policy are needed to restrict the set of possible initial states.
those can be provided by the user for instance in the form of a partial test driver or code contracts or by a whole program analysis tool like sage.
conversely micro execution may also fail to exercise some behaviors and miss bugs false negatives if its input set is too small or if the memory policy is too loose i.e.
microx recovers from memory corruptions that could happen in a realistic environment.
how to specify input preconditions initial states and output postconditions test oracle are long standing problems in both static program analysis and testing e.g.
.
micro execution can be viewed as lifting those fundamental problems from low level unit specific test driver code to higher level rule based memory policies but its goal is not to directly address avoid or solve those problems.
instead we identify in this paper see section several security motivated applications of micro execution which do not suffer from those limitations because the unit code fragment under test is specifically defined in each case to have no precondition all input values are possible and a memory policy which is as tight as possible for these application domains.
the paper is organized as follows.
in section we start by an overview of the functionality provided by micro execution and microx from a user s point of view.
in section we discuss how to modify an existing vm to perform micro execution.
in section we discuss in more details the limitations of micro execution mentioned above.
we then present in section several applications which do not suffer from those limitations.
in section we present experimental results obtained with our current microx prototype in the context of one of those applications namely api fuzzing.
section discusses related work and we conclude in section by summarizing the main contributions of this work.
.
overview we present in this section an overview of micro execution from a user s point of view.
.
what is micro execution?
the user selects a function or code location in any executable file such as an exe or a dll on a windows machine.
a special runtime virtual machine vm customized for testing purposes then starts executing the code at that location.
the vm hijacks all memory operations and provides inputvalues according to a customizable memory policy.
here is an example of default memory policy which is often adequate and sufficient when the micro execution starts at the beginning of a c function an input is defined as any value read from an uninitialized function argument or from a dereference of a previous input used as an address recursive definition .
note that under this memory policy values read from uninitialized global variables are not inputs.
other memory policies can be defined as will be discussed later.
imagine the user wants to micro execute the c function foobelow void foo char p p is a byte input char v p p is a byte input return let us assume that the user wants to micro execute this function under the previous default memory policy and that she selects the random test generation mode by which any input is simply generated randomly other modes will be discussed later .
in what follows such a user selected function is called the top level function of the micro execution.
micro execution of this code starts executing the first instruction of function foo.
the runtime vm detects that the execution wants to read a byte value for p assuming the program is run on a bit machine .
since pis an argument of function foo it is an input according to the above memory policy.
therefore a byte input value is randomly generated for pand is returned to the program.
how this is done is described in the next subsection.
next the vm detects that the byte value of pis used as an address pwhere the code wants to read one byte.
according to our memory policy a dereference pof a previous input p is also an input thus a byte value is randomly generated for pand returned to the program .
this value is then copied in local variable v. after the execution of the return statement the micro execution terminates.
in summary this micro execution detects dynamically inputs pwhich has a byte value on a bit machine and pwhich has a byte value.
micro execution means the ability to execute any code fragment without writing a test driver or input data.
the user does not need any test driver code for allocating and initializing memory for pand p and then invoking calling function foowith those arguments.
in fact the user does not need to know anything about how many arguments foo takes as inputs and what their types are.
she only needs to select a starting location a memory policy and a test input generation mode.
.
how is micro execution performed with microx?
microx is a first vm implementing micro execution for x86 binary code.
source code or debugging information i.e.
pdb files on windows is not required.
the c function fooabove is compiled with the c clcompiler included in microsoft visual studio on an intel 32bit machine running windows into the x86 assembly code shown in figure .
microx executes x86 instructions one by one and catches all memory operations.
in x86 ebp esp push ebp foo starts here mov ebp esp push ecx mov eax dword ptr p mov cl byte ptr p mov byte ptr cl v mov esp ebp pop ebp ret figure x86 assembly code for function foo.
eax ecx etc.
denote bit registers while the expression denotes accessing the memory address specified by the value of register ebp.
for the following discussion x86 instructions that perform memory operations are syntactically identified by the presence of an expression with square brackets as in .
note that x86 instructions involving only registers like mov ebp esp in line or the stack like push ebp in line do not perform memory operations for the following discussion.
for the example above the first memory operation executed during the micro execution of function foois at line .
microx detects that the bit address ebp isabove the current value of the stack pointer register esp which means that this address stores a function argument .
with our default memory policy the byte value dword at address ebp denoted by is thus an input.
however since function foowas not called with any argument by microx the number of arguments and their type is unknown when micro execution starts the address ebp has not been properly allocated and initialized yet.
microx therefore allocates a fresh byte buffer at a new address xin an external memory invisible to the program under test.
microx then maps the program visible address ebp with that programinvisible address x initializes the byte buffer at address x which represents argument pin the source code and then substitutes the address ebp by address xso that the new byte value stored at is returned and moved to register eaxin line .
in section we discuss in detail how the program binary is instrumented how addresses are substituted hijacked by others how inputs are initialized and how the external memory maps program visible addresses to invisible ones including in the presence of pointer arithmetic.
figure presents a report generated by microx with information about all the memory accesses it detected during micro execution of function foo.
in this micro execution the initial value of ebpis0x001ef988 in hexadecimal see line of figure .
the first memory access is detected for address 001ef990 line which is indeed ebp as expected.
using the random test input generation mode microx returned the byte random value line .
at this point microx does not know whether this byte value will be used as a pointer preventively it records this value in a list of known input addresses line .
this 4byte value is stored in a byte buffer located at address x line in this case.
from now on any access to the program visible address 001ef990 will be mapped to the program invisible address xin the microx controlled external memory.
address xis invisible to the program in the sense that the value of xnever appears in any of the program registers.
initeip is 72b51005 initebp is 001ef988 read mem access at address 001ef990 of bytes initializing input bytes adding to list of known addresses setguesteffectiveaddress returned read mem access at address of bytes initializing input bytes setguesteffectiveaddress returned 0020c490 write mem access at address 001ef987 of bytes setguesteffectiveaddress returned 001ef987 end exitprocess is called external memory stats number of mem accesses reads writes number of addresses total bytes number of inputs total bytes native memory stats number of module accesses reads writes number of other accesses reads writes general stats number of unique instructions after start number of warnings number of errors figure microx report on all the memory accesses detected during micro execution of function foo.
the micro execution then proceeds by executing line of figure where the previously returned byte input value which is in the current list of known input addresses is detected to be used as an address by the statement .
microx also detects this address is used as a pointer to a single byte byte ptr see line of the report in figure .
since a dereference of an input is also an input according to our default memory policy microx allocates a new buffer of size byte whose address is 0020c490 line initializes randomly a byte value which is in this case see line substitutes address by address 0020c490 and continues the micro execution.
next while executing line of figure another memory access is detected by microx but this time the address is 001ef987 see line of figure i.e.
ebp .
addresses on the stack below ebpare used for local variables and are notfunction arguments i.e.
are not inputs according to our memory policy.
moreover this is a write operation thus definitely not an input.
since microx knows this address is already stack allocated inside the code under test it does not interfere with it it is as if the address 001ef987 is mapped to itself which is reported in the third and last memory access entry of the report in lines and of figure .
the micro execution ends after the execution of line of figure .
in this micro execution only x86 instructions are executed see line of figure in a fraction of a second.
.
how is microx implemented?
.
program instrumentation starting execution jumping at an arbitrary code location typically crashes after a few instructions at the first access to unallocated memory like the access to pin the previous foo541example.
this is why a vm is needed to catch every memory access after its address has been computed but before the memory access is performed in order to prevent such crashes and continue the micro execution.
the microx runtime vm executes x86 instructions one by one and catches all memory operations before they occur in order to be able to re direct specific memory read write operations.
this is done by interpreting dynamically every single x86 instruction being executed and decomposing each of those into a sequence of micro operations e.g.
which decouple the computation of addresses from accessing those addresses.
for instance the x86 instruction mov eax means use the bit value of register ecxas an address get the bit byte value located at that address denoted and then copy that value in register eax.
this single x86 instruction is rewritten as a sequence of micro operations including additional instrumentation callbacks such as ... generateeffectiveaddress ... prememoryaccesscallback ... mov eax ... generateeffectiveaddress is an x86 macro which computes which address if any is accessed next by the current instruction.
that address is then stored in a variable named effectiveaddress implemented as a memory location or register in the pseudo code above.
next prememoryaccesscallback is a new microx callback which is executed after effectiveaddress is computed butbefore is accessed.
this callback executes new microx code which looks up the current memory policy to determine whether the current effectiveaddress should be either a untouched or b replaced by a new one.
for instance all in or out parameters of the user specified top level function like fooin the earlier example typically falls in the b category with the microx default memory policy microx automatically allocates memory for those in its external memory and keeps a map from effective addresses visible to the code under test to addresses in this external memory invisible to the code under test in that case the value of effectiveaddress is replaced by its corresponding address in the external memory which the code under test is never aware of.
next the x86 instruction mov eax is performed to simulate perfectly the execution of that instruction.
by perfect we mean that this simulation preserves the semantics of the original x86 instruction precisely to the bit level and including side effects to the eflags of the x86 processor.
we emphasize that the code being micro executed is never aware of the external memory.
for instance in the above example the value of register ecxisnotmodified to contain the value of an address in external memory.
indeed microx does not know what the program does later with the value of ecx.
modifying the value of register ecxcould have dangerous side effects later especially for stack allocated addresses1 int r heap address range default int r ebp ebp address range default int initebp initial value of ebp list of addr knowninputaddresses bool isinputaddress addr a if initebp a a initebp r ebp return true for any x in knowninputaddresses if x a x a r x a a x r return true return false addr prememoryaccesscallback addr a int size bool isread addr a externalmemory a if a is defined return a if !isinputaddress a return a add addr to externalmemory a externalmemory a if isread initialize the values at addr in externalmemory if size add the byte value at to knowninputaddresses return a figure external memory manager simplified .
and in the presence of pointer arithmetic for instance if ecx is compared to some other value later .
it is therefore important to fully hide the existence of the external memory to the code under test in order not to corrupt its behaviors in any way.
note that decomposing x86 instructions into sequences of micro operations is a standard technique for dynamic binary program instrumentation e.g.
see .
however the specific microx prememoryaccesscallback which occurs after effectiveaddress is computed but before is accessed is new to the best of our knowledge e.g.
compared to nirvana or pin .
.
external memory management the external memory manager maintains a mapping from program visible addresses to invisible external memory addresses.
this mapping is also used to ensure read write memory consistency when an input value vis first returned for an address a i.e.
written to address a subsequent reads at that address amust return the same value v. amemory policy defines the set of addresses which are to be mapped to an address in the external memory.
when the user selects a top level function as the start of the micro execution as in our running example with function foo these addresses are typically the addresses storing the input or output arguments of the top level function plus any input value used as an address as specified in the default memory policy defined in section .
if the first operation to542be performed at any such address is a read operation the address stores an input value otherwise the first operation is awrite operation and the address stores an output value .
figure illustrates how the external memory manager works.
whenever a prememoryaccesscallback is issued see section .
the function with that name in line of figure is called with as arguments the memory address abeing accessed the number size of bytes being accessed and whether this is a read operation or a write .
it returns either the original effectiveaddress a with which it is called or the address a mapped to ain the external memory if any.
the default memory policy is captured by the code in function isinputaddress in line which checks whether address ais either in the interval line i.e.
an argument to the top level function or in the interval lines where xis any address in the current list of known input addresses and ris a constant by default see line .
indeed as previously mentioned the external memory manager maintains a list set of known input addresses with all the bit byte input values returned by microx so far during the micro execution see lines .
later during the micro execution any memory access performed at any of such known input addresses xor in their neighborhood i.e.
at any address in the interval where ris a user customizable heap address range will be considered as an input according to the default microx memory policy discussed in section .
the range r allows input addresses ato point to data structures input buffers or structs of size up to r. addresses awhich are already mapped in the external memory are substituted by their new addresses a see line .
otherwise non input addresses are left untouched line .
in contrast for any input address a all addresses in the interval where size is the current number of bytes being accessed from address a are added to the mapping maintained by the external memory line .
if the current memory access is a read operation line then it is an input and the values of the bytes at addresses are initialized lines as will be discussed in the next sub section.
and if size is this new byte input value is added to the list of known input addresses line as previously explained.
figure depicts a simplified version of the actual external memory manager used in microx.
microx actually uses abyte precise memory model code not shown here every byte address is being tracked individually.
this means that whenever the program accesses nbytes at address amapped to a new address in external memory the read write status of every individual byte is being tracked as well as its value.
this way if the program wants to access later any n bytes at address a the external memory manager will behave consistently no matter what the overlap is between the interval andall previous intervals .
in our experience this level of precision is often necessary for dealing with low level parsing code including all kinds of pointer arithmetic such as accessing bytes at address afollowed by accessing bytes at address a or accessing byte at address a 1and byte at address a 2while later accessing nbytes at address asuch that a 1and a 2are included in the interval .
.
input value generation input values can be generated using different user controlledstrategies or even using other tools.
for instance our microx prototype currently supports several input modes including the following.
zero mode all input values are zeros useful for debugging .
random mode all input values are randomly generated.
for a bit value the bit value returned by a call tomalloc is used as the random input value.
this guarantees that if this bit input value were to be used as an address later in the micro execution this address would not conflict with a previously existing address in the stack in the heap or in a module of the live process .
file mode input values are read from a file in a sequential manner.
those values can be generated by the user or another tool or microx itself.
indeed for each micro execution with the random input generation mode microx also records all the input values in a file which can then be replayed later with the file mode in order to reproduce that specific micro execution.
process dump mode initial input values are read from a process dump stored in a .dmp file generated with the windbg debugger.
each input address in the live process is translated to the corresponding address in a process dump a stack address is mapped to the corresponding address relative to the value of register espin the dump a module .dll or .exe address is mapped to the corresponding address relative to the base address of the same module in the dump since module base addresses can vary due to address space layout randomization aslr in windows a heap allocated address is mapped by default to the same address in the dump.
if the address translation is successful an input value of the appropriate size is read from the dump at the translated address and returned as input value to the live process.
in this mode microx can be viewed as providing functionality similar to a partial fork as in unix where only the top part of the stack starting at the user specified toplevel function is partially re created while the part of the stack below the top level function calling context is not.
this mode is useful and even mandatory in the presence of some c idioms whenever heap allocated function pointers are being used to access methods associated with heapallocated objects since microx cannot guess what those function pointers are it must rely on a process dump to determine what code to execute next and carry on the micro execution.
sage mode the whitebox fuzzer sage can also be used to generate input values in order to steer the code under test systematically through all or many of its code paths.
this mode can be used in conjunction with one of the previous modes the very first time an input value is needed it is chosen using one of the previous modes e.g.
randomly then sage symbolically executes the code path taken by the given micro execution it generates a path constraint for that concrete micro execution it solves new alternate path constraints which when satisfiable generate new input values that will guide future concrete micro executions along new program paths.
see for a detailed presentation of sage.
different input modes may trigger different program behaviors.
for instance some may generate a same input address more than once like the zero mode while others may not like the random mode simulating different memory543 aliasing strategies which in turn may trigger different behaviors in the presence of pointer arithmetic in the code being micro executed.
the precise pointer reasoning algorithms implemented in sage cover all those cases systematically.
.
other implementation details our current microx prototype is implemented as a modification of the nirvana idna truscan sage tool stack.
about lines of additional code were required in total.
nirvana is a dynamic binary rewriting tool which can be used for dynamic binary instrumentation.
every native instruction is translated into a sequence of micro operations.
those also include callbacks for various events such as instruction loading instruction execution memory accesses stack operations function calls or returns etc.
we extended the set of nirvana callbacks to add prememoryaccesscallback read or write memory access callbacks in order to perform micro execution as discussed in section .
.
idna is a nirvana application that records binary execution traces.
all sources of nondeterminism in a program execution input values return values from kernel system calls thread scheduling information etc.
are recorded.
those high precision traces which can be large can then be replayed in a debugger like windbg and used for time travel debugging .
we extended idna to record input values driving micro executions performed under the control of microx.
this capability is key in practice to understand and replay micro executions which input values where provided to the code at what time what program paths were executed reproduce and debug bugs found etc.
truscan takes as input an idna trace and analyzes it for various properties such as checking for buffer overflows memory leaks uninitialized variables etc.
truscan itself was not modified in this work.
truscan includes a precise memory tracker which intercepts every call to functions like malloc and free in order to build a byteprecise memory model of the current program execution.
this memory model can detect accurately buffer overflows and other memory safety violations.
we can use truscan s memory tracker as a test oracle with microx in order to detect memory safety violations for data structures that are allocated and then wrongly accessed in the unit under test.
in contrast accesses to data structures allocated prior to the start of the micro execution cannot be checked as accurately since those are now handled with the external memory manager under the control of microx see section .
sage is an automatic test generation tool using dynamic symbolic execution and constraint solving and implemented as a truscan extension.
it is widely deployed inside microsoft and has found numerous new security vulnerabilities in various applications .
prior to this work sage had been used mostly for so called file fuzzing given an application reading an untrusted attacker controllable file sage attempts to generate file contents that trigger buffer overflows in the file parser embedded with the application.
sage uses one symbolic variable for each byte read from the input file.
as mentioned in section .
we modified sage so that every input value returned by microx can be treated as a symbolic input during symbolic execution.
sage can then be used to track the influence of those input values on the control flow path taken during micro execution then generate constraints and new input values todrive the code through other code paths.
microx opens up new application domains to sage beyond file fuzzing.
.
limitations of micro execution we revisit here in more details the limitations of micro execution mentioned in the introduction.
false positives too many behaviors unrealistic bugs .
micro execution of a code fragment makes sense mostly if all its inputs are unconstrained i.e.
can take any value.
otherwise micro execution may trigger program behaviors and bugs that are uninteresting false positives because they cannot occur in a realistic environment for that program.
we distinguish two possible causes for false positives .
the input set is too large too many inputs or .
the set of possible input values is too large too many input values .
if the input set is too large the default memory policy needs to be modified to restrict further the set of inputs.
when input parameters can only take specific values these input preconditions can be provided by the user for instance in the form of a partial test driver or code contracts or by a whole program analysis tool like sage.
either way the goal is to reduce the set of possible initial states.
false negatives too few behaviors missed bugs .
conversely micro execution may fail to exercise some program behaviors and miss bugs if the set of inputs or input values are too small.
if the input set is too small for instance because it does not include some global variables the default memory policy must be modified to include the missing input parameters.
in order to improve test coverage the input values fed to the program by microx can be generated by other tools specialized in test generation such as dynamic test generation tools like sage.
moreover if the memory policy is too loose microx recovers from memory corruptions that could happen in a realistic environment.
for instance consider again the function foo below void foo char p p is a byte input char v p p is a byte input return if the input pointer pisnull executing the statement p will always crash inside function fooin real life but not necessarily with microx if null is considered as a valid input address which microx would then map to some other address in its external memory .
whether or not null should be allowed as a valid input address may depend on the environment calling context of the code under test and can be adjusted by the user.
what kind of program bugs can micro execution detect?
roughly speaking micro execution can expose any memory corruption bugs due to erroneous manipulations of data structures that are local to the unit under test.
for instance micro execution can expose buffer overflows in buffers allocated by the unit.
in contrast it cannot in general detect memory corruption bugs due to input data structures such as buffer overflows in input buffers because those are handled by the external memory under the control of microx and for which crucial information such as buffer sizes is missing by default.
.
applications we now discuss several applications of micro execution for which the previous limitations can be largely avoided.
indeed the unit under test is defined in each case in such a way that there is no input precondition all input parameters can take any value and with a tight memory policy for the corresponding application domain.
the applications we describe are all security motivated and do not require application specific test oracles.
we present here a brief overview of each of these.
automated api fuzzing.
given a dll like user32.dll it is easy to extract automatically all its exported functions with the help of tools like dumpbin and then run microx and sage on each of these for a limited amount of time.
thousands of functions can be micro executed this way in a fully automatic manner with no user written test drivers or the need to identify statically the input and output parameter types of those functions.
micro execution provides an automatic way to provide a test suite for any api.
if the api is secured with strong input validation any bugs crashes found this way is an error of interest.
for other apis automatic test suite generation is useful for regression testing in order to automatically detect unintended api changes.
sample results of experiments with micro execution for api fuzzing are presented in the next section.
packet parser isolation and fuzzing.
security testing often called fuzzing of code parsing untrusted network packets is notoriously hard to perform thoroughly because it is hard thus expensive to set up testing properly for such stateful applications.
a standard approach consists of connecting multiple machines together generating traffic somehow monitoring network packets and then randomly fuzzing modifying specific packet segments and forwarding those to the destination machine with the hope that these corrupted packets will trigger interesting parsing bugs such as buffer overflows.
such a whole application testing set up is heavy complicated by hard to control os resources and timing issues is expensive and offers typically poor test control and coverage.
we are currently exploring an alternative approach using microx and sage by which each packet parser is fuzzed in isolation.
for a given a protocol implementation the user first identifies the set of functions that parse untrusted input bytes.
each of these functions typically has two types of inputs data structure s capturing the current protocol state and a pointer to a buffer containing the input bytes to be parsed.
given this information we can then micro execute such packet parsing functions one by one using microx and intelligently fuzz with sage the part of their input corresponding to untrusted input bytes with the goal of uncovering new buffer overflows while the part can possibly be initialized using a process dump see section .
taken with a breakpoint hitting the function.
targeted fuzzing.
when whitebox fuzzing complex file parsers embedded in large applications like microsoft excel each symbolic execution performed by sage takes a long time and there are many program paths to explore.
for instance a single symbolic execution of a large office application while parsing a kbytes input file takes about 1h in order to execute about .
billion x86 instructions generate about constraints after pruning and a few thousands new test input files see .
during symbolic execution and state space exploration sub parsers can be identified.for each sub parser one or several concrete symbolic calling contexts can be saved in a file.
using microx each subparser can be micro executed starting from a saved concrete calling context thanks to the process dump mode of section .
.
symbolic inputs can be limited to addresses which have symbolic values in the corresponding saved symbolic calling context and sage can then fuzz only those.
by using microx and sage this way fast sub searches focused on specific sub parsers can quickly be spawned in order to speed up the global search for bugs like buffer overflows .
unit verification.
similarly to targeted fuzzing components of large applications can be identified possibly with the help of the user and verified with microx and sage by using bit precise symbolic execution and exhaustive path exploration which are typically hopeless for complex whole programs but quite doable for small code components.
next such verification results for sub components can be packaged as component summaries which can be re used when verifying higher level components.
recently we were able to prove in such a compositional way that a specific windows image parser is memory safe i.e.
free of any buffer overflow security vulnerabilities modulo the soundness of our tools and a few additional assumptions including fixing a few buffer overflow bugs discovered during the course of this work .
malware detection.
when applications are submitted to app stores like the windows app store their code is being statically scanned to check for the presence of malware such as sending a packet to a rogue web site or performing a call to an illegal system call .
but malware code is often obfuscated and static code scanning is then ineffective.
each application is also being tested to a limited extent because testing has a cost but malicious behaviors are often triggered only after the user has entered some information or performed a few typical tasks with the application.
in such cases malicious behaviors are hard to detect dynamically with the limited automated testing performed at the time the application is submitted to the app store.
we are currently exploring the use of micro execution in a way similar to what rozzle did for detecting malware dynamically in javascript code using lightweight localized symbolic execution.
in the context of malware detection think of microx as an eval function for arbitrary x86 code fragments which can execute accurately even obfuscated code.
given an untrusted application submitted to an app store one could start a micro execution at every program location that is the target of a goto statement i.e.
each branch of conditional statements each loop body etc.
if for some calling context that microx and sage can come up with the resulting micro execution exhibits a malicious behavior like sending a packet to a rogue web site such behavior can be detected dynamically using existing runtime monitors and the application is clearly suspicious no false alarms .
we are currently exploring each of those applications and plan to report on those in more detail in the future.
.
experimental results to illustrate further the new possibilities enabled by micro execution we present in this section sample experimental results obtained with microx in the context of one of the applications discussed in section namely api fuzzing.
specifically we have developed a new simple tool for api545function name unique instructions inputs memory accesses tests crashes avg avg avg i64toa s snwscanf s splitpath s strnset s strset s ui64toa s ui64tow s ultoa s ultow s vsnprintf s i64tow s vsnwprintf s wcsnset s figure sample experimental results with exported functions part of ntdll.dll .
fuzzing which takes as input the name of a dll and a list of dll exported functions in that dll and then automatically runs microx and sage on each of those functions for a user specified amount of time.
for instance the library ntdll.dll on windows includes already about dll exported functions which can be called by other programs.
this single dll is typically located in the directory c windows system32 on a bit windows machine and this directory contains more than other dlls.
figure presents some experimental results for a random set of just dll exported functions which are part of ntdll.dll .
the names of those functions are given in the first column no particular order .
for each function our api fuzzing tool ran microx and sage for minute on a bit machine running windows .
the next to last column entitled tests gives the number of micro executions performed in the minute of time allocated to each function.
the last column entitled crashes is the number of micro executions ending in a crash among those.
thus in a total of minutes micro executions were performed among which ended in a crash.
the second column unique instructions shows the number of unique x86 instructions executed during micro execution of the corresponding function as reported on line of the sample microx report of figure .
the numbers shown are in order the average minimum and maximum number of unique instructions executed during the micro executions for that function.
for instance for the first function i64toa s micro executions were performed see column tests and the average minimum and maximum numbers of unique x86 instructions executed during each micro execution were and respectively.
we can see that these three numbers vary for nearly all functions except splitpath s which means that successive micro executions exercised different sets of unique instructions.
in all cases we see that the absolute numbers of unique instructions executed during micro execution are small ranging from tens to a few hundreds x86 instructions.
the third column inputs reports on the average min max number of inputs provided by microx during the micro executions of the corresponding function see line of the sample microx report of figure .
we can observe that some functions have a constant number of inputs like i64toa s while others can take varying number of inputs like strnset s and vsnprintf s .
the latter functions take strings as inputs and the varying number of inputs provided by microx correspond to different input string lengths.
the fourth column memory accesses shows the average min max number of memory accesses performed during the micro executions of the corresponding function see line of figure .
for all functions these three numbers vary and more widely.
since every input involves a read memory access the number of memory accesses is always larger than the number of inputs.
in our current microx prototype we enforce a maximum limit of memory accesses for each micro execution to force termination and avoid infinite loops and this limit is reached in one micro execution of the last function wcsnset s .
as can be seen from column tests the number of micro executions performed for each function in minute varies widely from for splitpath s to for wcsnset s .
every micro execution performed with microx is fast in absolute terms always less than second as it involves a roughly 10x slow down compared to uninstrumented native x86 execution see .
in contrast every symbolic execution performed by sage involves a roughly 1000x slow down compared to uninstrumented x86 execution see and also requires constraint solving and new test generation which can take seconds or sometimes tens of seconds in some of these experiments.
for instance for function splitpath s an analysis of the execution logs reveals that only one single symbolic execution was performed created constraints and new tests which took most of the single minute of time allocated to this function.
additional log data from this relatively long symbolic execution also reveals that it executed more than instructions even though they were only unique instructions executed see figure which means that the first micro execution driven by random inputs hit a program loop which took longer to be symbolically executed by sage.
similarly most of the runtime in each of those short minute api fuzzing experiments is typically spent in sage not in microx.
figure presents the number of unique instructions green middle line inputs yellow bottom line and memory accesses blue top line for each of the micro executions covered in figure .
these data points are presented one by one from left to right and for each of the functions in the order of figure i.e.
the leftmost entries on the546110100100010000100000 306sample micro execution statistics series1 series3 series2memory accesses inputs unique instr.figure detailed data about the micro executions summarized in figure .
horizontal axis are for the micro executions tests of the first function i64toa s and so on.
the bottom two lines with the number of unique instructions and inputs use the linear scale on the left of the figure while the top line with the number of memory accesses uses the logarithmic scale on the right of the figure with a maximum value of .
the purpose of this figure is to visualize possible correlations between the number of unique instructions inputs and memory accesses during micro execution.
as seen from the figure for most micro executions there is no correlation the number of inputs is sometimes flat while both the number of unique instructions and memory accesses vary widely and in a seemingly unrelated manner.
however a spike in the number of inputs usually corresponds to a spike in the number of memory accesses since by definition the latter must always be larger than the former as mentioned earlier in this section .
in particular the highest spike on the right near test corresponds to a micro execution of wcsnset s reaching the maximum limit of with inputs but only unique instructions.
all the function names selected in this sample have the secure ssuffix which means that they are supposed to include better input parameter validation and security features error reporting etc.
.
according to our preliminary experiments crashes in those are more rare than in their non secure counter parts data not shown here .
however crashes in such secure functions can still be found rather easily with microx and sage as can be seen in the last column of figure .
an analysis of those crashes reveals that for each of the functions with some crashing micro executions the last instruction before the crash is unique for that function i.e.
there is a single crashing instruction for each function.
for instance the crashes observed for vsnwprintf s are all due to a write access violation occurring in sub function write char called from woutput s called from swoutput s called by the top level function vsnwprintf s .
such crashes clearly point to some incompleteness in the input validation performed by such functions.however most apis like ntdll.dll are provided as is with no strong reliability or security guarantees an application using the api should not misuse an api by calling it with wrong input values.
the consequences of incomplete input validation vary widely depending on the application context.
for instance crashes or memory spikes like the one shown to the right of figure could perhaps be exploited for a denial of service dos attack of a server side application if untrusted data is allowed to flow as an input argument to a call to say function wcsnset s inside that application while crashes or memory spikes may have little security or performance impact for a client side desktop application.
another interesting problem is api diffing or how to detect unintended changes in visible api behavior like new return values or error codes which might break backward compatibility of existing applications relying on that api.
these topics related to e.g.
and the other applications of micro execution suggested in section should be explored in future work.
in contrast the purpose of this section was only to present some sample experimental results obtained with micro execution in order to illustrate the new possibilities it opens .
here are some specific high level takeaways.
the key new capability offered by micro execution is theability to test arbitrary code at a near zero cost .
micro execution is fastandautomatic .
when combined with intelligent test generation as implemented in sage micro execution can be used to generate test suites with good coverage in a fully automated way for many software components and interfaces e.g.
all functions of an api .
this unprecedented level of test automation can in turn be used to quickly generate huge amounts of test data of various kinds .
thanks to micro execution we can now envision for the first time an automated tool which could automatically fuzz all547the dll exported functions in all the dlls included in a version of windows i.e.
hundreds of thousands of functions for instance.
what data should be collected for what purposes and how to mine this data intelligently are other interesting challenges for future research.
.
related work we are not aware of any prior work on using custom virtual machines for dynamic test isolation and generation purposes.
however there is plenty of related work in various dimensions.
prior work on automatic test harness generation e.g.
uses static code analysis in order to discover the i o interface of the code under test and then generate a test harness and test inputs for that interface.
due to the use of static analysis these techniques are imprecise or assume specific api conventions they require userassistance to be usable in practice and have not been widely deployed to date.
frameworks for creating and managing unit tests e.g.
help the user setup a custom test harness but are not fully automatic.
they have been successfully adopted in some contexts mostly for code written in modern object oriented languages where unit testing is arguably easier java c etc.
.
but adoption of such tools has remain more elusive for system code c c etc.
and large systems like the windows and office code bases .
work on dynamic test generation e.g.
also uses dynamic program instrumentation techniques such as reflection in pex and dynamic binary instrumentation in sage for test generation.
however these tools require the user to identify syntactically which inputs should be treated as symbolic .
microx goes further by not requiring any syntactic definition for inputs inputs are defined indirectly by a broad rule based code independent memory policy and then detected dynamically.
this enables micro execution of code starting at complex program interfaces which would be hard to exercise with a syntactic test driver required to anticipate all subsequent reads and possibly some writes of the code under test.
work on automatic dynamic generation of mock objects function stubs or shims for skipping the execution of subcomponents during unit testing e.g.
requires the ability to execute the code being tested.
this work is orthogonal and complementary to micro execution.
static program analysis e.g.
can simulate the execution of code paths at a higher level of abstraction possibly interactively e.g.
and find program bugs.
such tools are typically efficient but imprecise.
this imprecision causes them to report false alarms spurious bugs .
in contrast micro execution does not involve any abstract interpretation and thus there is no imprecision due to abstraction microx is a concrete interpreter .
the only remaining possible imprecision with micro execution is exclusively due to the lack of environment assumptions see .
how to specify such environment assumptions at the implementation code level often referred to as input preconditions and output postconditions or code contracts has been the topic of much research e.g.
.
by replacing testharness code by general memory policies micro execution can be viewed as lifting those fundamental problems to a higher level of abstraction.
while this higher abstraction offers new possibilities to address those problems it neitheravoids nor solves them.
the applications discussed in section were chosen to largely avoid the need for custom preand post conditions.
whole process forking can be used for backtracking in software model checking test generation and inmemory fuzzing .
in contrast micro execution allows a partial form of forking especially with the process dump input mode of section .
.
this opens up new possibilities forpartial localized backtracking in dynamic program analysis like the targeted fuzzing and unit verification applications discussed in section which are inspired by similar techniques used for compositional static program analysis e.g.
.
virtual machines vms program simulators and emulators can execute a program or precisely bit level simulate its execution from one platform os architecture to another and or provide infrastructure for dynamic program instrumentation and analysis like nirvana or pin .
in particular java pathfinder is a software model checker and program analysis platform which uses a modified java vm for instrumentation purposes.
vms are also often used to test the portability of whole applications from one operating system to another.
however all such tools can only run programs that are fully defined compiled and with a proper test driver.
in contrast micro execution can execute any partial code fragment by discovering dynamically its inputs and outputs.
our microx prototype is built upon existing vm technology modified and extended in a different way in order to provide those new additional features.
microx can be viewed as a runtime vm modified for test isolation and generation purposes .
.
conclusion this paper introduces micro execution the ability to execute any code fragment without a test driver or input data.
micro execution can start and stop executions at any point and enables local fast precise dynamic analysis of small code fragments and executions.
the key to implement micro execution is a runtime environment which can intercept and redirect input output memory operations before they occur and can provide input values according to general rules.
we presented such an implementation named microx.
to our knowledge microx is the first vm specifically designed for testing isolation and generation purposes.
microx lowers the cost of test setup for testing in general and for unit testing is particular by not requiring userwritten test driver code or input data.
instead such a traditional test environment is replaced by a generic memory policy which is interpreted dynamically and can be refined by the user as needed.
we presented in section several applications for which default memory policies require no or little user modifications.
we are currently exploring each of those applications.
when combined with intelligent test generation as implemented in tools like sage micro execution can be viewed as combining the locality and efficiency of static program analysis with the precision of dynamic program analysis.
it allows for automatic unit testing of arbitrary code fragments which in turn opens up new possibilities for automatic program decomposition precise program analysis and compositional testing .
we view micro execution as a foundation for a new broad thrust of research on automated software testing.
.