evaluation of string constraint solvers in the context of symbolic execution scott kausler boise state university department of computer science boise id scottkausler u.boisestate.eduelena sherman boise state university department of computer science boise id elenasherman boisestate.edu abstract symbolic execution tools query constraint solvers for tasks such as determining the feasibility of program paths.
therefore the e ectiveness of such tools depends on their constraint solvers.
most modern constraint solvers for primitive types are efcient and accurate.
however research on constraint solvers for complex types such as strings is less converged.
in this paper we introduce two new solver adequacy criteria modeling cost and accuracy to help the user identify an adequate solver.
using these metrics and performance criterion we evaluate four distinct string constraint solvers in the context of symbolic execution.
our results show that depending on the needs of the user and composition of the program one solver might be more appropriate than another.
yet none of the solvers exhibit the best results for all programs.
hence if resources permit the user will bene t the most from executing all solvers in parallel and enabling communication between solvers.
categories and subject descriptors d. .
testing and debugging symbolic execution keywords constraint solver analysis string constraint solving symbolic execution .
introduction symbolic execution se is a path sensitive program analysis that traverses program paths using depthrst search and interprets program execution on symbolic input values instead of concrete values.
when interpreting a program se generates a set of constraints on the program s symbolic inputs.
the conjunction of those constraints which is called a path condition pc is used by se to avoid traversals of infeasible paths.
if the pc is unsatis able then the path is infeasible and feasible otherwise.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
se tools outsource pc evaluations to constraint solvers making solvers one of se s crucial components.
in fact through advances in constraint solvers se gained its wide spread applicability in software veri cation e.g.
testcase generation and property veri cation .
se tools heavily rely on the availability of adequate solvers i.e.
solvers that can reason about constraints of the required data types in a way that is best suited for a particular application of se.
with so many available and emerging solvers the users of se tools are faced with the problem of identifying the adequate one especially if the solvers were originally developed for di erent problems.
for example while analyzing available string constraint solvers to use in se of java programs a user might notice that some of them are used in a di erent analysis but for the same programming language e.g.
jsa in the same analysis but for a di erent language e.g.
z3 str in a di erent analysis and for a di erent language e.g.
stranger and even in di erent areas such as modeldriven software engineering e.g.
eclipse str .
currently the only information available for identifying an adequate solver is solvers performances.
in this paper we show that in addition to performance solvers vary in two factors that are important to a user modeling cost and the accuracy with which a solver evaluates pcs.
we de ne these two new adequacy criteria and use them with performance to evaluate four diverse string constraint solvers in the context of se i.e.
by traversing program paths.
modeling cost is associated with the observation that string solvers lack in one to one support for string operations and predicates i.e.
string methods of the target programming language.
if a solver was originally designed to process string constraints in another language e.g.
php instead of java then it would not have interfaces to support some java string methods.
or if the solver developers chose to implement a set of basic operations for the underlying symbolic string representation then the user must use the interface for the basic operations to implement more complex string methods.
for example a solver that uses automata to represent symbolic strings might implement basic regular language operations e.g.
concatenation union etc.
in either of those situations the user must model the string methods of its target language by using the interface provided by the solver i.e.
by extending the solver.
we found that the modeling cost varies substantially among the solvers.
in addition we learned that some of java s string methods inherently cannot be modeled precisely by solvers.
the level of precision varies from the complete inability to model a string method to an approximation of the method with some other method e.g.
the startswith a predicate can be over approximated with the contains a predicate.
in some cases such approximations are implicit i.e.
obscured from users.
moreover the user might unknowingly extend a solver so that the modeled method exhibits an overapproximating behavior.
all of the above scenarios of imprecise modeling may result in the loss of accuracy in the result obtained from the extended solver e.g.
a sat result of a pc where startwith is substituted with contains should be interpreted as sat over i.e.
an over approximating sat.
this silent over approximating behavior might cause the user s application to behave di erently e.g.
it might produce false positives which are interpreted as actual property violations.
therefore the user should be able to detect when a solver returns approximating results.
in this paper we introducea a set of accuracy measurements that empirically provide insights into the solvers relative accuracies i.e.
without an oracle.
in this work we extended four publicly available string constraint solvers jsa stranger z3 str and eclipsestr and evaluated them on string pcs dynamically collected from eight open source string processing applications.
we use our proposed metrics to assess the performance modeling cost and accuracy of those solvers.
we found that in the context of our experiments stranger achieves the highest ranking followed respectively by jsa z3 str and eclipse str.
however none of the solvers outperformed all others in all three categories.
for example we found that the automata based string constraint solvers which are jsa and stranger and their extensions perform well and are capable of representing more string methods than the other solvers but there are other string methods that the automata based solvers could not model as precisely.
thus z3 str has the highest ranking in modeling cost but the lowest one in performance.
moreover solvers received different rankings for each analyzed program which suggests that solvers should be selected based on the program prole.
this pro le includes the number and the type of string methods used in the program and the ability of a solver to precisely model them.
overall our empirical studies demonstrate that each of the solvers ranks higher than others in some evaluation criterion for some program.
this nding suggests that if resources permit then the execution of multiple solvers with diverse algorithmic techniques is the best alternative.
even though the set of string solvers and string pcs that we analyzed is by no means exhaustive we perceive the introduction of new decisive factors in selecting a constraint solver for complex symbolic types and insights on varied results of the solvers as the main contributions of this paper.
as se extends to more advanced data types such as symbolic collections or symbolic heaps the chances of precisely modeling their methods decreases.
therefore one can expect the same type of questions about accuracy in the evaluation of complex data type pcs.
in particular users should think about how their implementation should deal with approximating behavior of solvers for complex symbolic types.
the rest of our paper is organized as follows.
in the next section we explain how string constraint solvers work and discuss related work on those solvers.
then we give a mo tivating example.
in section we present two new criteria for string solver evaluation.
after that we present our evaluation approach and examine the results.
.
background and related work to illustrate how se generates string constraints consider the code snippet in figure .
on the entrance to method m string s1 string s2 se assigns symbolic values s1 ands2 to the rst and the second arguments respectively.
when se reads in the assignment statement with the substring string operation se updates the value of the s1 variable to s1 substring which means that the new symbolic value for s1 contains all strings that start at index of the original symbolic string s1 and extend to its end.
to explore the true branch of the conditional statement se generates the following constraint s1 substring equals s2 this constraint restricts the possible values of s1 to those whose substrings starting at index are the same as the values of s2.
to determine whether such values for s1 and s2 exist i.e.
whether the constraint is satis able se queries a string constraint solver.
however there are several solvers to choose from we have found about constraint solvers in literature.
while investigating these solvers we applied several selection criteria besides the necessary one public availability at the time of our experiments.
our rst criterion was the ability of a solver to model a majority of methods in java.lang.string java.lang.stringbuffer and java.lang.stringbuilder classes.
at a minimum it must handle concatenation and substring operations in addition to the equality predicate.
the second criterion was e ciency we only selected those solvers that were able to evaluate the majority our pcs within ve seconds.
for the past decade researchers developed a variety of automata based solvers targeted for a particular type of program analysis.
the programming language research group at aarhus university pioneered this research area by developing the java string analyzer tool jsa which performs dataow analysis on string expressions in java programs with automata as the abstract domain of string variables.
jsa relies on the nite state automata package developed by the same group to implement string transfer functions and merge operations.
the automata implementation uses the unicode alphabet for state transitions.
several tools have used jsa the automata package or both to implement their analyses by extending jsa for modeling string operations in their target language.1for example an experimental se tool haderach extends jsa to represent symbolic strings instead of an array of characters as other se tools that don t support symbolic strings as a separate type do.
while the authors of haderach omit the discussion of precision or modeling cost the developers of java string testing jst an automated test case generation tool based on se that also extends jsa s automata do mention that they re ned and added models of string operations because some are not implemented and others lack in precision.
at the time of our studies jst was not publicly available.
an alternative implementation of an automata based string solver was used in stranger a 1since it is common to refer to the automata package used in jsa as jsa we will do the same here.
260m string s1 string s2 f s1 s1 .
substr ing i f s1 .
equals s2 f .
.
.
g g figure code snippet example.s1 substring int targetargs2 equals object arg target figure dataow graph.solversubstring equals time loc precise loc precise s ejsa no8 no0.
ejsa maybe .
estranger maybe no .
ez3 str maybe maybe .
eeclipse str no maybe .
table variations in modeling cost accuracy and performance.
dataow analysis for php programs where as in jsa automata are used to represent possible values of string expressions.
stranger uses the mona automata package where transitions between states are represented as a multi terminal binary decision diagram.
even though the authors of stranger do mention jsa in their related work section they fail to compare these two distinct implementations of automata.
for brevity from this point on we use stranger to refer to the constraint solver used in this dataow analysis.
both jsa and stranger satised our selection criteria and we extend them for use in the context of se of java programs.
several other decision procedures such as dprle its unnamed successor and rex use di erent custom automata implementations.
since those solvers focus on a decidable fragment of string theory they support a limited number of string methods and thus do not satisfy our rst selection criterion.
an alternative representation of a symbolic string is a nite linked structure which imposes a bounded length on symbolic values.
for example hampi translates a string into an ordered list of bits i.e.
bit vectors and uses the operations available in bit vector theory to express string constraints.
the same approach to symbolic string representation is implemented in the string constraint solver kaluza which extends hampi but is used in the se based test generation framework kudzu .
a solver introduced by bj rner et al.
also represents symbolic strings as bitvectors.
on the other hand a bounded string solver based on the eclipse framework and used in model driven engineering represents a symbolic string as a list of concrete characters and symbolic variables.
this solver uses constraint logic programming and constraint handling rules to express string constraints.
in this paper we refer to the aforementioned solver as eclipse str.
pass is a string constraint solver that uses a parameterized array based model to represent symbolic strings.
in pass string constraints are expressed as quanti ed formulas for which the authors developed a custom quanti er elimination algorithm used in smt solving.
all of these bounded string solvers are used in di erent types of analyses and for di erent programming modeling languages.
among these only eclipse str satis ed our selection criteria.
unfortunately hampi timed out on all queries even on small string lengths and pass was not publicly available at that time.
to circumvent the length limitation imposed by traditional bit vector solvers z3 str employs smt solving to model symbolic strings of arbitrary length.
z3 str extends the z3 smt solver .
it de nes the string sort in z3 and uses the theory of interpreted functions and axioms to express string operations and predicates.
this string constraint solver has satis ed all our selection criteria and was used in our study.the work on comparison of di erent solvers is limited to mainly performance based evaluations.
hooimeijer et al.
compared their unnamed string constraint solver to dprle and hampi on a set of regular expressions and limited operations on string sets.
another paper by hooimeijer et al.
evaluated the performance of di erent automatabased constraint solvers on basic automata operations.
redelinghuys et al.
compared the performance of their custom implementations of bit vector constraint solvers and their custom extension of jsa in the context of symbolic java pathfinder .
the authors of axiom based string solver z3 str compared their tool with bit vector based kaluza .
the comparison is done both in terms of performance and correctness although the authors do not de ne the latter.
choi et al.
make a comparison with jsa based on performance and precision in .
in this case the authors use the generality of regular expressions to determine which solver is more precise.
finally the authors of compared pass with an automata approach and an approach similar to a bit vector one on performance and the number of solved cases.
to summarize for evaluation pcs of java programs in the context of se we have selected the following four solvers jsa stranger eclipse str and z3 str.
we extended each of these solvers and nameed to our extensions ejsa estranger ez3 str and eeclipse str respectively.
since we are impartial to the string solvers we used our best e ort to extend them including communications with their developers.
however the inapplicability of other string solvers to our problem indicates their focus on special sets of problems.
although each solver has contributed to noteworthy research the specialization of these solvers makes it di cult to apply them to other problems.
.
motivating example to demonstrate diversity in modeling cost accuracy and performance of the four string solvers consider table which shows how each of the extended solvers evaluates in each category for the constraint in formula .
the rst column contains di erent extensions of string solvers.
column two shows the number of lines of codes that it took for us to extend the solver to model the substring int method while column three tells whether the model might be precise or not.
columns four and ve provide a similar description for the equals object method.
the last column contains the average time in seconds that the string solvers required to process the two methods.
the average is calculated after querying the solvers ten times.
we label the precision of method implementation with maybe or no .
forequals object we considered precision of models of both the predicate and its negation.
when we cannot determine that the model of a method is certainly imprecise 261we label it with maybe but when we are certain that the model is not precise we label it with no .
in this example we have two versions of jsa extensions for the substring int method.
the rst ejsa uses the built in method which only requires a couple of lines of code to invoke.
jsa s native modeling of this method over approximates the result by allowing the resulting automaton to represent any post x of the original automaton.
for example if s1 in figure is the concrete string foo the symbolic string after the native modeling would represent concrete strings foo oo o and which is an over approximation of the correct substring o .
in order to improve accuracy we reimplemented the substring methods in ejsa using the algorithm developed for jst string solver .
since we cannot obtain the proof of correctness of this algorithm we mark it as maybe precise.
note that it required a substantial amount of e ort to implement a more accurate model of the substring methods and modeling cost involves the lines of code in addition to other e orts such as understanding the theory of automata.
unlike jsa stranger already provides an interface forsubstring with no obvious approximations.
therefore to achieve the same level of accuracy we spend less e ort to model this string operation.
however neither automatabased solver could model the equals predicate and its negation without introducing over approximation.
for ez3 str we found no obvious approximation for either of the two methods.
z3 str comes with a direct interface for the substring operation equals predicate and a negation quanti er.
therefore the substring operation in figure can be modeled using z3 str s built in operation interface along with z3 s symbolic integer type.
furthermore theequals predicate is modeled using z3 str s equals interface and the predicate s negation is modeled by applying the negation operator to the original predicate.
in eeclipse str we were unable to model the substring int method without introducing clear overapproximations.
eclipse str cannot model it precisely because its substring method must return a string of at least length one.
since the empty string is a feasible result a sound model must over approximate the method by disjoining the result with the empty string.
the time column clearly demonstrates the variations in the performance of all string solver extensions.
ez3 str takes the most time to process the constraint but at the same time models the string methods with better precision.
ejsa de nitely displays the best performance while maintaining the same precision as estranger.
eeclipse str comes in second in the performance category with a level of precision that is incomparable to that of the automata based solvers.
this example illustrates the coupling between modeling cost and precision i.e.
a higher modeling cost results in a higher precision which results in a more accurate solver and the coupling between precision and performance i.e.
the most precise solver took the longest time to execute.
also the example shows that solvers with the same level of precision do not necessarily exhibit the same performance i.e.
ejsa and estranger have similar precision but the former outperforms the latter.
moreover there are situations when the solvers precisions are not comparable.
hence the performance cannot be judged adequately in such circum stances.
in this example we illustrate the di erences and by no means make conclusions on these four solvers.
in the following section we describe in detail what metrics we used to perform the comparisons of the four string solvers.
.
criteria for solver evaluation as we previously discussed the majority of the comparisons between constraint solvers is based on performance.
this factor is important for constraint solver developers since solver competitions mainly focus on performance.
even though performance is important for users other factors can also play critical roles.
we speculate that two additional factors modeling cost and accuracy should be decisive in selecting an adequate solver.
we explain why they are important and how they can be measured below.
.
modeling cost we de ne modeling as the adaptation of a constraint solver to the context of the user s problem.
essentially modeling is the translation of the language of the problem to the language of the solver.
since di erent solvers have been developed to solve speci c problems we expect that the e ort required by a user to model a di erent problem i.e.
modeling cost should vary by solver.
in order to model a problem the user studies the solver s interface.
sometimes there is a direct match between a string method and the solver s interface e.g.
for the equals method and z3 str s interface as shown in table .
in other cases the user must invoke several calls to the solver s interface to model the method e.g.
modeling the equals method by ejsa as exempli ed in table .
more complicated extensions also require an understanding of relevant datastructures.
for example to extend ejsa the user should be familiar with automata theory.
in addition even when a solver claims to support a particular string method it might happen that the method is not supported adequately in the context of the problem.
for example z3 str supports a replace method but its support is limited and non applicable in the context of se of java programs.
obviously more e ort results in higher precision.
thus our extra e ort in implementing the substring operation in ejsa resulted in a more precise model of the operation compared to jsa s native one.
lack in e ort might result in both poor modeling and inappropriate use of the solver.
in our study we used the lines of codes required to extend a solver to model a method as the measure of modeling cost.
a more objective measure would be the amount of time we invested to extend each solver but we believe lines of code adequately describes our e ort.
.
accuracy when a solver can precisely model all string methods then such solver is both sound and complete i.e.
it never reports that a satis able constraint is unsatis able and that an unsatis able constraint is satis able.
if a solver is sound but incomplete we say that it over approximates i.e.
it might return sat for unsat and if a solver is complete but unsound then we say it under approximates i.e.
it might return unsat for sat.
the source of imprecise modeling can be internal to the solver e.g.
as in ejsa s modeling of substring .
it can also be the result of the solver s inability to precisely model a string method as we see in eeclipse str s model of sub262string int .
we have also encountered an inability to represent the full set of characters used in java.
thus z3 str has limited support of ascii characters so we had to map unsupported java characters to those that z3 str can support.
also stranger cannot support at least two utf16 characters one with the decimal value of i.e.
a null character and another with the decimal value of .
since neither the developers of the solvers prove that their implementations are precise nor we prove the precision of our extensions we evaluate the accuracy of the solvers empirically.
ideally we would do this by comparing the solver s set of solutions for a constraint to the accurate set of solutions.
however since the solution oracle cannot be obtained we propose three conservative measurements that can be used to conjecture about solvers accuracy in the context of se.
we have yet to reason about the accuracy of operations so these measurements are based on the accuracy of predicates.
in our measurements of accuracy we must assume that our extended solvers are sound.
this assumption is justied by two reasons.
first the authors of string constraint solvers often claim their solvers are sound without providing a formal proof.
second we empirically check for unsound results in our analysis using concrete valued gathered in our analysis.
measure disjoint branching points conceptually when a branching point is encountered opposing predicates should partition the set of values represented by a symbolic value occurring before the branching point as each value may only follow one branch in concrete execution.
this is shown in figure 3a where the original set represents the values before a branching point and the true and false sets disjointly represent the values in each branch.
the rst measure of accuracy deals with whether a solver can partition this domain of symbolic strings.
when a solver can partition the domain we refer to it a disjoint branching point.
otherwise we call it a non disjoint branching point as is shown in figure 3b.
in figure 3b the grey portion of the true set represents over approximated values present in both sets.
we say a solver 1is more accurate than a solver 2if the set of disjoint branching points produced by 1is a proper superset of s disjoint branching point set i.e.
disj .
a disjoint branching point does not imply the symbolic values involved are free from over approximation.
instead they indicate the current branch has been modeled accurately by the solver.
measure unsatis able branching points the second measure of accuracy is a special case of disjoint branching points based on the number of unsatis able constraints that a solver can detect.
if one solver 2evaluates a constraint as sat and another 1as unsat then we say that the latter is more accurate than the former i.e.
unsat .
we say this because we know an unsat result comes from an actual unsatis able pc since our solvers are sound.
the ability of a solver to detect unsatis able pcs is crucial for se since it prevents se from exploring infeasible paths.
we refer to branching points where a solver can detect that one of its outcomes is unsatis able as unsatis able.
one such branching point is shown in figure 3c where the true set is the empty set and the false set equals the original set.original false true a disjoint.original false true b not disjoint.
original false true c unsatis able.ffoogoriginal ffoogfalse true d singleton unsatis able.
figure conceptually illustrates measures of accuracy.
measure non singleton unsatis able branching points in order to assess the complexity of the pcs for unsatis able branching points we check if all symbolic strings involved in a branching point represent only a single concrete string value.
if this is not the case then evaluation of the constraint is non trivial and branching point is marked as anon singleton branching point and singleton otherwise.
a singleton unsatis able branching point is shown in figure 3d where the true set again represents the empty set and the false and original sets both contain only the string foo.
if a solver 1can detect an unsatis able pc at a non singleton branching point then 1has higher accuracy than a solver 2that can detect an unsatis able pc at a singleton branching point i.e.
unsat .
in the next section we describe how we conducted our study to evaluate the four string solvers using metrics introduced in this section.
.
evaluation we evaluate the string constraint solvers on a set of benchmarks comprised of actual string pcs obtained from real world java programs.
we limited our analysis to one language and leave evaluation of multiple languages to future work.
instead of employing a se tool such as spf we collect pcs by means of dynamic symbolic execution dse .
dse combines concrete execution with se i.e.
it performs se along a single concrete execution path.
by using dse instead of se we can record pcs of long execution paths with less e ort for diverse set of programs e.g.
no need to model programs libraries.
moreover additional information gathered during a dse run such as concrete values of string variables at certain program points and actual branch outcomes assisted us with the measurement of solvers accuracies.
.
collecting pcs we implemented our custom dse using a program instrumentation technique built on top of the instrumentation features of the java optimization framework soot .
we opted to create our own dse over using an existing tool for more complete capturing of strings dataows.
our collection tool instruments the subject program with additional method calls that enable inter procedural collection of string pcs.
in particular the instrumentation monitors the targets and arguments of string methods.
when an argument of a method is not a string type we use the argument s concrete value for that program execution run.
we exclude libraries 263name abr.
cl.
description tr.
op.
pred.
tos.
cov.
jericho html parser jhp library for html parsing.
.
.
.
jxml2sql jxm converts xml les to sql or html.
.
.
mathparser java mpj solves inputted math expressions.
.
.
.
mathquiz game mqg gui based math study tool.
.
natural cli ncl allows command line input based on a natural language.
.
.
beasties bea command line combat game.
.
.
htmlcleaner hcl converts dirty html to wellformed xml.
.
.
.
itext ite a java pdf library.
.
.
table program artifacts and constraint descriptions.
from monitoring and instead we assign a new symbolic value to each string value returned from a library.
instead of using constraint solvers during the dse run we record pcs in a le then parse the le to instantiate each pc and pass it to solvers.
during constraint collection we represent each pc in a dataow graph similar to one presented in figure for the code snippet on its left.
in each dataow graph the source vertices represent either symbolic string values or concrete values of some types used in a program execution.
thus in figure the sources represent symbolic values s1 and s2 of string variables s1 ands2 respectively as well as a concrete integer value that is the argument in the substring int method.
sink vertices represent either methods that take a string as an argument e.g.
a print statement or string predicates.
in figure equals object is one such sink vertex.
the rest of the vertices represent string operations i.e.
methods that return a string or modify the calling string as is the case with the mutable java.lang.stringbuilder or java.lang.stringbuffer classes.
in our example this is the vertex substring int .
edges represent the ow of data i.e.
they represent how string values are used by methods.
the edges are labeled either target i.e.
the target object of the method or arg i.e.
an argument to the method.
when a method takes more than one argument we record additional meta data for the proper argument order.
in figure the substring int vertex has two incoming edges one from s1 labeled target and one from labeled arg .
thus a substring int operation was performed on string symbolic value s1 with an argument that takes the concrete value .
to mimic the construction of a pc by se we record the time stamp for each node.
hence traversing the graph according to the time stamp reconstructs the original structure of the constraint.
in addition we perform a set of simpli cations to our graph e.g.
by removing nodes that do not contribute to a constraint.
at the end of the collecting phase the resulting graph is recorded in a le.
.
processing pcs the processing of a pc starts by reading the graph le and instantiating the graphical representation of the pc.
then the graph is traversed in a chronological order i.e.
by visiting vertices with the oldest time stamps rst.
when a predicate method s vertex is encountered e.g.
equals object the new constraint is generated and added to the pc.
then the extended pc is translated into the language of each solver and we query the solver for satis ability.
to accom plish this task we used java interfaces for the two automatabased solvers a le in a special input format for z3 str and a custom query for eclipse str.
as the pc is augmented by additional predicates ez3 str and eeclipse str re evaluate the whole pc while the automata based solvers incrementally evaluate it.
in addition we apply all length constraints in all solver extensions.
for bit vector based eeclipse str we set bounds of 10k on its string lengths.
we used a timeout of ve seconds in our experiments although ejsa and estranger never timed out.
if a solver was not able to decide a constraint within the allotted time frame then we safely over approximate the constraint by assuming that the pc is satis able and setting symbolic values to the set of all strings.
in addition when a solver cannot model a string operation e.g.
tolowercase the result of the operation is also safely over approximated with a symbolic value representing the set of all strings.
as we mentioned we put our best e ort to create an unbiased extension of each solver .
furthermore we aimed to model each string method uniformly across the solvers.
.
acquiring data for solvers evaluation .
.
modeling cost for modeling cost we report the lines of code that we used to extend each solver for each method.
for each string predicate we report the total lines of code for implementing the predicate and its negation.
.
.
performance we measure performance by timing the evaluations of two pcs for each branching point i.e.
one pc for the taken branch and another for the not taken branch.
we chose to record the time for both pcs because both pcs are used in our measures of accuracy e.g.
to detect disjoint branching points.
to make a fair comparison of performance between incremental and non incremental solvers we kept a total running time for each branching point and added the time required to process each additional constraint for the incremental solvers.
we also attempted to avoid including startup time in our performance evaluation.
for ejsa we ran the underlying solver with several string operations before evaluation to avoid loading times.
z3 str is run in a standalone program so we opted to use its self reported time which doesn t include startup time.
this might allow ez3 str to underreport its time as the tool is likely bias in its estimations but this does not appear to a ect any conclusions on per264formance.
stranger and eclipse str appear to be una ected by startup time as stranger is implemented in c and passes messages via jna2while eclipse str is initiated in its own thread.
at the end of processing we report the performance of each solver as the average of each branching point s performance.
when a solver times out on a taken branch we use the timeout value as the solver s processing time.
.
.
accuracy we evaluate extra constraints in addition to pcs gathered in dse and add tracking mechanisms to record the measures of accuracy proposed in the previous section.
to detect disjoint branching points we conjunct the pc of one outcome of the branching point with the pc of another outcome of the branching point and send this constraint to the solver.
if the solver returns unsat then we mark the branching point as disjoint.
in the case of the automatabased solvers the disjoint branching point is identi ed when the intersection of automata of opposite outcomes results in the automaton that recognizes the empty language .
at the end of pc processing we report all disjoint branching points per solver.
to detect unsatis able branching points we generate the pc with the negated predicate i.e.
for the not taken branch outcome in concrete execution for each predicate node in the graph.
if the constraint solver returns unsat i.e.
the pc evaluates to false then we mark that branching point as unsatis able.
in the end we report the unsatis able branching points for each solver.
in order to determine singleton branching points i.e.
ones whose pcs contain only concrete values we record concrete values of symbolic string variables at each branching point during the collection phase.
then we create a query that forces the solver to nd a solution other than the recorded concrete value.
such constraints can be created by conjoining the original satis able pc with the disequalities of symbolic values and their concrete values.
if the solver returns unsat then such branching point is marked as a singleton.
at the end of the execution the sets of singleton branching points are reported.
ideally all solvers will report that all singleton branching points are also unsatis able branching points since it is a trivial case.
.
artifacts table gives an overview of the program artifacts used to generate the benchmarks i.e.
the pcs.
the rst column describes the name of the artifact and its abbreviation which we use to refer to the program.
the second column shows the number of classes in each program.
column three provides a brief description of the program.
column tr.
displays the number of program executions or traces from which we collected pcs.
the op.
column lists the average number of string operations per trace from all pcs while pred.
does the same for string predicates.
we opted to collect our own inter procedural pcs instead of using available pcs for several reasons.
thus several existing pcs are not completely representative of a full program path because they are limited e.g in the length of input strings or constraints in the pc and taken from non java programs.
also existing pcs may represent paths are not likely to be traversed whereas our pcs represent paths from the test cases developed by the authors of the artifacts.
we disregard all branching points where a timeout occurs in the negated path from the one taken in dse as in this case we are unsure that a sat result is correct.
thus the tos column lists the average number of branching points excluded in each trace of that artifact due to timeouts.
finally the cov.
column lists the statement and branch coverage obtained by all traces of the artifact in the format statement branch.
our objective for the traces was to collect diverse string constraints not to achieve high coverages.
furthermore we only targeted a small part of large artifacts such as for program ite.
all the program artifacts are open source and available from sourceforge online code repository.
we selected those programs because of their extensive use of strings.
we used our dse tool to instrument the programs and executed them using the test suite supplied with the programs or generated our own using the category partition method .
in the next section we present the results that our experiments produced for these program traces.
all experiments were run on a machine with a .
ghz intel i7 processor running mac os x version .
.
with gb of memory.
we used soot version .
.
to instrument our programs.
we extended the solvers using java version .
.
.
eclipse str was run using the eclipse constraint logic programming environment version .
.
we used the rst release of z3 str and jsa version .
.
finally we obtained an unnamed release of the stranger sml library on december by contacting the developers3.
.
results we ranked our solvers in several categories for each program trace and we present the aggregated results in table .
this table separates the categories of comparisons into modeling cost performance and accuracy.
we label the categories no model for the count of methods a solver could not model lines for average lines of code required to model timeouts for the number of timeouts in negated branches time for the average time disjoint for the percentage of disjoint branching points unsat for the percentage of unsatis able branching points and nontrivial for the percentage of non singleton i.e.
non trivial unsatis able branching points.
within each category the s column denotes the statistic for a solver in each category e.g.
the count of unmodeled methods while the r column denotes the rank of each solver in that category.
the nal column describes the overall rank of each solver.
the results presented below discuss data from this table as well as rankings for each individual program.
.
modeling cost even though java s string types i.e.
java.lang.string java.lang.stringbuffer and java.lang.stringbuilder contain over methods among which are predicates we only present the modeling cost of those string methods that appeared in the programs pcs while excluding those that have no e ect on symbolic expressions such 3stranger is now available at 265modeling cost performance accuracy no model lines timeouts time disjoint unsat non trivial solver s r s r s r s r s r s r s r overall ejsa .
.
.
estranger .
.
.
ez3 str .
.
eeclipse str .
.
.
table overall ranking of our solvers in several categories.
append charat int length tolowerc ase equals object indexof trim equalsi gnorecase string startswith string substring int int substring int setlength int replace delete int int replaceal l string string endswith s tring contains chars equence isempty split string toupperc ase append char int int comparetoi gnorecase string lastindexo f string copyv al ueof char int int 30lines of codeejsa estranger ez3 str eeclipse str figure displays the modeling cost for each method and each extended solver.
as the tostring method.
the total number of methods used in the traces are from which only have unique names.
we represent all overloaded methods with the same names as a method with the wildcard character in methods signatures e.g.
replace denotes both replace char char and replace charsequence charsequence .
the modeling cost of those methods is the sum of lines of code of all aggregated methods.
figure displays the encountered string methods on its x axis.
the order of these methods is based on the on the frequency with which they appear in all program traces.
thus append methods were encountered more often than any other method.
the modeling cost for each string constraint is shown on the y axis of the bar graph in figure .
if a solver cannot model a method the corresponding bar is absent.
for example none of the solvers can model charat int and only ejsa and estranger can model tolowercase .
the graph shows that out of aggregated methods eight of them could not be modeled by any solver4.
the higher number of lines of code that is needed by ejsa to model equalsignorecase string substring int int substring int and delete int int as well as trim and equalsignorecase string by estranger re ect our custom implementation of the substring algorithm to increase the modeling precision.
even though ejsa and estranger required more lines of code to model methods we were able to model more methods due to their available interfaces.
so it is no surprise that many analysis tools adapt jsa in their constraint solvers.
this implies that users bene t from an extensive interface that can manipulate the solvers underlying representations.
the modeling cost and the importance of accurate modeling might vary by program since a program might use a subset of string operations.
by using data from figure and 4we did not model operations such as charat int because a comparison to a character is required to generate the corresponding constraint.
this can be handled by hybrid solvers which also operate on symbolic integers.
for example in the context of mixed constraints jst can model that method .recording each method present in each program we calculated that the average modeling costs for two programs could vary signi cantly depending on the solver.
thus ez3 str had the best modeling cost for programs jxm mqg ncl bea hcl and ite but eeclipse str had the best modeling cost for programs jhp and mpj.
overall we see in the lines columns of table that ez3 str performed the best in terms of modeling cost but couldn t model as many methods as ejsa or estranger as shown in the no model columns.
.
performance figure 5a displays the performance of the solvers.
the y axis of the graph depicts time in seconds while the x axis contains all traces grouped by the program.
dashed vertical lines indicate the boundaries of program traces.
the data shows that the performance not only varies among solvers for the same program e.g.
the data for bea program but that no single constraint solver outperforms all other solvers for all programs.
we also see that the performance of the solvers depends on the program and the pcs within it.
for example eeclipse str has the second best performance for program jxm but the worst performance for ncl.
in addition the data shows that when a solver has the worst or the best performance for a single program trace it tends to stay the same for the rest of the program traces for one program.
therefore by sampling pcs of a program the user can identify solvers that are more likely to perform well for that program.
we conjecture that this is due to the string method composition of pcs.
ez3 str has the worst performance overall since for each program it either demonstrates the worst performance or it is the close second to worst.
eeclipse str has the most variability in its performance.
for some programs such as ncl it has the worst performance due to timeouts while for other programs such as jxm its performance is comparable with automata based solvers.
for each program trace one of the automata based solvers always exhibits the best performance except for a handful of jhp jxm mpj mqg ncl bea hcl ite a y axis displays the average time per branching point in seconds.
jh p jx m m pj m qg n cl b ea h cl i te b the proportion of all disjoint branching points.
jh p jx m m pj m qg n cl b ea h cl i te c the proportion of unsatis able branching points.
jh p jx m m pj m qg n cl b ea h cl i teejsa estranger ez3 str eeclipse str total d the proportion of unsatis able branching points that are not singleton.
figure records accuracy in our test suite.
traces for program hcl where eeclipse str exhibits the best performance.
overall we see in the time columns of table that estranger has the best aggregated performance results although ejsa is a close second.
.
accuracy the set of graphs in figure excluding figure 5a depicts the accuracy data derived from the metrics of accuracy introduced in section .
as for the performance graph the x axis displays the program traces grouped by program.
in these graphs the order of traces is the same as in the performance graph.
the unit of the y axis is the percentage of the type of branching points e.g.
disjoint branching points to the total number of branching points analyzed in the trace.
the rst and the least measure of accuracy that we use is the number of disjoint branching points.
figure 5b s graph shows shows this metric.
interestingly ez3 str s result is far from disjoint branching points as solvers based on smt such as z3 str should always partition the domains of a predicate and its negation when it doesn t time out.
however several of these non disjoint branching points were introduced in our models of java predicates i.e.
they occur when z3 str does not have a direct mapping and we must provide an imprecise model.
furthermore recent work has revealed that z3 str is not always complete .
figure 5b shows some variation in the results.
for example estranger or ejsa record the most of these branching points for most traces of programs jhp jxm mqg bea and ite while ez3 str or eeclipse str often report the most disjoint branching points for traces of mpj ncl and hcl.
we see in the disjoint columns of table 3that in general estranger is best at detecting disjoint branching points.
the graph in figure 5c shows the percentage of unsatis able branching points that each solver is able to identify with the solid line representing the total number of unsatis able branching points found by all solvers.
the data indicates that no solver always reports the most unsatis able branching points although in the unsat columns of table we see that ejsa and estranger usually report the most.
we believe this is because the other solvers were forced to over approximate the results of operations such as tolowercase .
thus all solvers could gain from including an interface to model these methods.
since we want to examine how e ective string solvers are in identifying unsatis able branching points we want to remove all trivial cases when a pc contains no symbolic values.
earlier we identi ed the branching points whose pcs contain only concrete values as singleton branching points.
thus in order to identify non trivial cases of detecting unsatis able branching points we removed all singleton branching points from the unsatis able branching points.
the result of this operation is displayed in figure 5d.
the data implies that a majority of the unsatis able branching points were detected due to non symbolic constraints.
we believe this is purely due to the structure of the constraints and perhaps it is a common characteristic of string constraints.
hence solvers might bene t from implementing an additional layer for evaluating concrete constraints relieving users of the need to implement those checks as part of their analysis tool.
program ncl clearly has the most non singleton unsatis able branching points and we also see poor performance 267in eeclipse str and ez3 str for ncl.
this result supports our conjecture that these branching points are more di cult to solve.
figure 5d shows that ejsa and estranger were usually able to detect the most unsatis able branching points for non trivial pcs mainly in the traces of ncl and bea programs.
the overall results on these branching points in the non trivial columns of table shows that estranger reports the most of these branching points while ejsa is a close second.
.
discussion when we ranked the solvers in the categories shown in table for each artifact we found that ejsa had the best ranking for programs estranger for ez3 str for and eclipse str for as some solvers had the same ranking for the same programs.
based on that result and the overall column of table we conclude that estranger displayed the best overall results.
thus we recommend that if the user must choose one solver for se tasks with no knowledge of the java programs to be analyzed then he or she should select stranger.
however examinations of the structure of a program through a light weight static analysis may provide additional information for selecting an adequate solver.
in our experiments we encountered several cases when the composition of a pc a ected evaluation criteria.
for example we have noticed that non automata solvers ez3 str and eeclipse str have the best accuracy ranking only for program mpj.
when examining the pcs of mpj we observed that mpj contains several instances of equals object which automata based solver cannot handle very well and no instances of touppercase ortolowercase which non automata solvers fail to model.
if pcs contain string methods that are modeled uniformly by all solvers like in bea program then their accuracies are the same and hence the user might consider other factors for selection.
this observation also explains the correlation of the variation in solvers accuracy levels with the number of string methods in program pcs.
for example figure 5b shows the most variation in programs jhp ncl hcl and ite which have and aggregated methods correspondently.
thus in some pcs of a program methods that are modeled more precisely by one solver are present and in other pcs methods modeled better by another solver are present.
in some cases merely matching the set of methods in a pc to a solver that models them more precise might be inadequate and a more advance analysis of pcs should be considered.
for example even though ez3 str and eclipse str have the best model of startswith string method depending on the type of the argument passed to the method ejsa s less precise model of this method produces better accuracy results.
this is the case of jhp program.
we have noticed that for some jhp pcs ez3 str eclipsestr have better accuracy e.g.
in the number of disjoint branches while on other pcs they don t. we found that when the argument passed to startswith string was concrete ejsa had more disjoint branches while when the argument was symbolic ez3 str eclipse str determines more disjoint branches.
perhaps even more complex interaction of string methods in a pc might a ect the accuracy of a solver.
for example in ncl program eeclipse str has the worst accuracydue to timeouts in processing startswith string that involved more complex string method sequences than jhp.
finding such complex interactions of string methods in a pc is a challenging but rewarding task and would require ner accuracy measurements that for example use string model counting or account for imprecisions in the modeling of string operations.
as for the performance criterion we observed a strong positive correlation r between ez3 str s performance and the average number of predicates in each query.
we conjecture that this is due z3 str not being incremental since it cannot e ciently solve pcs containing multiple predicates.
thus we recommend the user not use z3 str to solve pcs containing several predicates and we hope future versions of z3 str and eclipse str support incremental solving.
.
conclusion and future work advances in constraint solvers and successful applications of se in software veri cation prompted researchers to extend se based techniques to incorporate in addition to primitive numerical data types such as integers advanced data types.
as a result the research in se has been targeting constraints over complex data types such as symbolic strings symbolic collections and symbolic heaps .
when selecting a solver for advanced data types one needs to be aware that solvers might vary greatly in the level of support they provide for the theories of their data type.
our exploratory study demonstrated this for the theory of strings.
as the number of operations and predicates increases the theory of a particular data type can become undecidable e.g.
the theory of strings is in general undecidable as presumably are a majority of theories of advanced data types.
to deal with undecidability solvers either over approximate or under approximate the problem usually without informing a user about it.
in this work we have introduced measurements of accuracy for string constraint solvers in the context of symbolic execution which can be used for other solvers of advanced data types.
our evaluations of four string constraints solvers revealed that stranger solver has the highest rank with jsa as a close second even though none of them were originally designed for se moreover stranger was even originally designed to support a di erent programming language.
yet the overall performance of the solvers vary both between programs and between pcs of the same program.
we conjuncture that if resources permit all solvers should be executed in parallel and exchange information between themselves.
for example an automata based solver might create a regular expression of accepting strings and a bitvector solver might create constraints from that regular expression.
furthermore passing learned information would allow for advanced accuracy comparisons.
for example we would be able to determine if the set of values represented by a symbolic value in ejsa is a subset of the set of values represented by a symbolic value in ez3 str.
another direction of future work is to identify and measure the accuracy of string operations and how it a ects the overall accuracy of a solver.
for example a disjoint branching point does not guarantee accurate values.
instead previous over approximation could a ect the overall accuracy of the solver.
we plan to track dependencies from potential sources of such approximation and present the results in our subsequent work.
.