automated unit test generation for classes with environment dependencies andrea arcuri certus software v v center simula research laboratory lysaker norwaygordon fraser university of sheffield dep.
of computer science sheffield ukjuan pablo galeotti saarland university computer science saarbr cken germany abstract automated test generation for object oriented software typically consists of producing sequences of calls aiming at high code coverage.
in practice the success of this process may be inhibited when classes interact with their environment such as the file system network user interactions etc.
this leads to two major problems first code that depends on the environment can sometimes not be fully covered simply by generating sequences of calls to a class under test for example when execution of a branch depends on the contents of a file.
second even if code that is environmentdependent can be covered the resulting tests may be unstable i.e.
they would pass when first generated but then may fail when executed in a different environment.
for example tests on classes that make use of the system time may have failing assertions if the tests are executed at a different time than when they were generated.
in this paper we apply bytecode instrumentation to automatically separate code from its environmental dependencies and extend the e vosuite java test generation tool such that it can explicitly set the state of the environment as part of the sequences of calls it generates.
using a prototype implementation which handles a wide range of environmental interactions such as the file system console inputs and many non deterministic functions of the java virtual machine jvm we performed experiments on java projects randomly selected from sourceforge the sf100 corpus .
the results show significantly improved code coverage in some cases even in the order of .
furthermore our techniques reduce the number of unstable tests by more than .
categories and subject descriptors.
d. .
testing and debugging testing tools keywords.
unit testing automated test generation environment .
introduction automated test generation techniques are usually applied to produce test suites with high code coverage e.g.
statement or branch coverage or to satisfy related criteria such as mutation testing or failure exceptions .
the simplest technique is perhaps random testing but more sophisticated techniques such as dynamic permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
.1public class envexample 3public boolean checkcontent throws exception 5scanner console new scanner system.in 6string filename console.nextline 7console.close 9file file new file filename if !file.exists return false scanner fromfile new scanner new fileinputstream file string filecontent fromfile.nextline fromfile.close string date dateformat.getdateinstance dateformat.
short .format new date if filecontent.equals date return true return false figure example class challenging automated test generation method checkcontent first reads a filename from the console then reads the first line of that file and finally compares it to the current date.
symbolic execution dse and search based software testing sbst have been developed and combined .
in the case of procedural code e.g.
programs written in the c language this task usually amounts to finding input data for the functions under test.
for object oriented software there is the extra challenge of first putting the classes under test cut and method parameters in the right internal state which is usually achieved with sequences of function calls.
however sequences of function calls on a cut and its parameter objects may not be sufficient in practice to achieve high code coverage.
for example consider the java class envexample in figure the method checkcontent has no input parameters in its signature.
to achieve full coverage a tester would first need to create a file that contains the current date on the first line and then input the name of that file on the console.
to the best of our knowledge there is no research tool in the literature that would do this automatically.
there is a further problem in that class to cover the branch in line the file would need to contain a string representation of the current date.
if the test is later executed on a different day the result of the string comparison would change and assertions that use the return value will lead to unstable tests that fail.
the reason for this is that the success of a test generation technique and the reproducibility of the results for a given cut may strongly depend on the class s environment.
1public class envexampleevosuitetest beforeclass 3public static void initevosuiteframework 4org.evosuite.properties.replace calls true 5org.evosuite.properties.virtual fs true 6org.evosuite.agent.instrumentingagent.initialize 7org.evosuite.runtime.runtime.getinstance .
resetruntime before 11public void inittestcase org.evosuite.runtime.runtime.getinstance .
resetruntime org.evosuite.agent.instrumentingagent.activate org.evosuite.utils.systeminutil.getinstance .
initfortestcase after 18public void donewithtestcase org.evosuite.agent.instrumentingagent.deactivate test 23public void test0 throws throwable systeminutil.addinputline zf evosuitefile evosuitefile0 new evosuitefile private tmp zf filesystemhandling.appendlinetofile evosuitefile0 envexample envexample0 new envexample boolean boolean1 envexample0.checkcontent assertequals true boolean1 test 33public void test1 throws throwable systeminutil.addinputline z envexample envexample0 new envexample boolean boolean0 envexample0.checkcontent assertequals false boolean0 test 41public void test2 throws throwable systeminutil.addinputline q evosuitefile evosuitefile0 new evosuitefile private tmp q filesystemhandling.appendstringtofile evosuitefile0 m envexample envexample0 new envexample boolean boolean1 envexample0.checkcontent assertequals false boolean1 figure a junit test suite automatically generated by evosuite that achieves full coverage on the class envexample defined in figure .
in this paper we extend the e vosuite unit test generation tool to handle environmental dependencies by a using bytecode instrumentation to control the environmental state and inputs during test generation b including the environmental state and inputs as part of the search space of e vosuite and c observing environmental interactions during the tests and restoring the environmental state after test execution.
this allows e vosuite to control not only function inputs and call sequences but also the state of the environment resulting in stable tests with higher code coverage.
figure shows a test suite for the envexample example class that achieves branch coverage test0 line creates a mocked file and sets its content to which is the default mocked date set by e vosuite .
when checkcontent is invoked the branch in line is thus true and the method returns true.
test test1 inputs the name of a file that does not exist thus covering the branch in line .
finally test test2 creates afile but does not set the required contents thus the false branch in line is covered.
the code between line and in the test suite serves to control the environment during subsequent test executions outside of e vosuite .
but how often do environment interactions happen in practice?
in previous work we ran experiments with the e vosuite unit test generation tool on java projects randomly selected from sourceforge i.e.
the sf100 corpus .
we observed an unexpectedly high number of environmental interactions and generally low code coverage leading to the conjecture that these two observations are linked.
we thus studied the effects on running test generation on the sf100 corpus.
in detail in this paper we provide the following contributions an instrumentation technique to isolate java code from the filesystem.
an instrumentation technique to isolate java code from the console input.
an instrumentation technique to isolate java code from the system state time properties etc.
an extension of the e vosuite test generation tool that includes the state of the environment e.g.
file contents console input etc.
as part of the input space.
an extension of the e vosuite test generation tool that efficiently handles changes to the environment performed by the tests e.g.
changes of the static state of classes .
experiments on selected classes demonstrate the power of this approach in terms of large coverage increases and large reductions of the number of unstable tests.
experiments on the full sf100 corpus of classes show improvement in both coverage and unstable tests but the overall improvements in coverage indicates that there are further obstacles to achieving high coverage.
although our main motivation and evaluation is on coverage and unstable tests the techniques introduced in this paper provide more general benefits first the use of a virtual file system is important for automated test generation as it prevents the real file system from being corrupted by.
second isolating test cases from their environment makes tests execute faster than when they rely on an actual file system and also makes them independent such that parallelisation becomes easy.
.
background .
the environment of a class in object oriented software development unit testing typically focuses on individual classes or the methods of a class.
such a class is embedded in a complex environment with a range of dependencies.
consider figure the class under test cut and its dependency classes have a state that depends on their class loader.
that is independently of the state of any instances of the cut the class itself can have a state in the context of its class loader this state is typically defined by static variables.
class loaders in turn are embedded in a virtual machine vm environment which itself has a complex state.
for example the state of a vm may be defined by system properties.
the vm in turn interacts with the operating system environment where the state depends on the system time memory state filesystems hardware configuration and many other factors.
the operating system is part of a machine which can interact with the user or other machines and services over a network.
interactions with the environment at the level of the jvm and beyond are performed via standard library calls provided with the host language e.g.
java .
interacting with the class loader specific environment happens without any specific calls it is simply reflected by the states of static variables.
80operating systemvirtual machineclassloaderclass under testdependency classes network filesystemuserfigure the environment of a class under test.
.
system test environment simulators when developing systems that interact with hardware components e.g.
sensors and actuators it is common practice in industry to build environment simulators.
these simulators can be used for system level testing and allow the tester to run the developed system without the need for real hardware e.g.
software in theloop testing .
this is particular useful for when the hardware is not available yet during the software development process and also for large scale testing when hardware is expensive.
there is a lot of research on how to best develop those environment simulators and how to use them for testing purposes.
for example arcuri et al.
developed a technique to define the environment as uml state machines and automatically generate environment code.
however even though the testing was automated there was still the initial manual effort of defining the uml models.
while such an approach is reasonable to simulate hardware in this paper we focus on unit level testing and not system level testing.
furthermore here we desire full automation for test generation there should be no need of manual intervention to write any models or test drivers.
ideally once e vosuite is installed the user should only need to specify which class project she wants to generate tests for e.g.
with a mouse click in ides like eclipse .
.
mocking at the unit level a common approach to isolate a class from its dependencies is bymocking.
in general mocking refers to the use of replacement classes during testing rather than real classes.
there are different related terms e.g.
a stub usually has a fixed default behavior whereas a mock typically has to be set up as part of a test and then can verify expected interactions.
other common terms are fakes dummies or test doubles.
in this paper we will use the term mocks to denote replacement classes where the behavior can be set up as part of the test.
the creation of mocks is often supported by mocking frameworks which are are widely used in industry when unit tests are manually written.
for java there are many tools like mockito1 easymock2and jmock3.
isolating a class using mocks and stubs is good from a testing point of view but may create a maintenance problem as the behavior of the mock classes needs to be kept in sync with the real behavior.
in this paper we do not mock user classes which in principle are under control of the program1 accessed march accessed march accessed march 2014mer.
rather we aim to bring the environment under control but to achieve this we do use an approach based on mocking.
the use of mocking in automated test case generation is less common albeit some promising techniques have been developed.
for example when there are cuts that take