lifting model transformations to product lines rick salay michalis famelis julia rubin alessio di sandro marsha chechik department of computer science university of toronto toronto canada rsalay famelis mjulia adisandro chechik cs.toronto.edu abstract software product lines and model transformations are two techniques used in industry for managing the development of highly complex software.
product line approaches simplify the handling of software variants while model transformations automate software manipulations such as refactoring optimization code generation etc.
while these techniques are well understood independently combining them to get the bene t of both poses a challenge because most model transformations apply to individual models while modellevel product lines represent sets of models.
in this paper we address this challenge by providing an approach for automatically lifting model transformations so that they can be applied to product lines.
we illustrate our approach using a case study and evaluate it through a set of experiments.
categories and subject descriptors d. .
design tools and techniques general terms theory management keywords software product lines model driven engineering model transformations .
introduction model driven engineering mde and software product line engineering sple are powerful techniques used in industry for managing the complexity of large scale software development.
mde helps manage complexity by using models to raise the level of abstraction at which developers create code.
in this context model transformations are the key enabling technology for automating the movement within and between levels of abstraction .
sple approaches help permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.manage complexity by treating large sets of similar software product variants as a single conceptual unit rather than a set of individual products explicitly capturing product line commonalities and variabilities .
both mde and sple are used by numerous industrial organizations and particularly in the automotive embedded systems domain.
however combining sple with model transformations is a challenging task most existing transformations such as model refactoring or code generation are developed for individual product models and do not take sple variability constructs into account.
as a consequence an organization that relies on sple to manage its product portfolio cannot reuse existing third party transformations.
instead it has to apply them to the individual products derived from the product line or redevelop the transformations in order to apply them to the entire product line.
the former approach is impractical because the transformations that need to be applied must be tracked along with the product line and kept up to date.
moreover it is often desired to apply the transformation on the level of the entire product line in order to enable analysis validation and evolution of the resultant product line.
liebig et al.
have shown that analysis applied to the product line outperforms approaches that sample individual products.
we give three examples of such techniques below.
.
classen et al.
developed a model checking technique for product lines expressed as transition systems .
using this technique for a product line of say uml statecharts is possible only if the product line is rst transformed into an equivalent transition system one.
while such a transformation already exists for individual statechart models it does not take variability constructs into account and hence cannot be applied to a product line as a whole.
.
consider a product line that must support multiple binding times stages of the lifecycle in which decisions about variability are made .
supporting both design and run time binding requires translating a design time product line of models into a run time product line of code.
such a translation can be obtained by lifting existing codegenerating transformations that are typically used in mde strategies to apply to the entire product line instead.
.
consider the case when a set of standard refactorings has to be performed on a model e.g.
if a new architectural policy requires all public methods in a class have accessor methods.
in that case an existing encapsulate variable refactoring transformation could be applied to all class diagrams in order to accomplish the task.
however if we want to apply such refactorings to a product line of class di permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
agrams the transformation would not be directly applicable and would have to be lifted instead.
while lifting a transformation is useful so manually is hard and error prone because the lifted transformation must correctly address sple constructs and consider all possible product variants derived from the product line model.
in this paper we propose an approach for lifting the transformations automatically i.e.
no manual changes to the transformation are required to enable it to apply to the entire product line.
speci cally we make the following contributions we de ne and prove correctness of a general lifting algorithm for graph rewriting based model transformations.
the algorithm is designed for the annotative product line approach typically used in practice.
we provide a prototype implementation of the algorithm integrated into an existing transformation engine .
we use this implementation with a benchmark case study for modeling techniques .
finally we empirically evaluate the scalability of the algorithm and its implementation.
the results suggest that the approach has good scaling behaviour.
note that the focus of our approach is not sple speci c transformations e.g.
adding a feature or refactoring a feature model but rather transformations applicable to individual products.
the rest of the paper is structured as follows.
in sec.
we motivate the problem and our solution using a simple product line of washing machine controllers.
sec.
provides the needed background on product lines and model transformations.
our approach is presented in sec.
.
in sec.
we describe the implementation of the lifting approach and present its application to the benchmark case study.
sec.
describes a set of experiments aimed to study the scalability of our approach.
we compare our approach with related work in sec.
and conclude the paper in sec.
.
.
motivating example fig.
shows a simple product line wfor washing machine controllers expressed using a uml state machine.
the feature model the top part of the gure allows for three optional features to be added to a basic washing machine heat adds the ability to have hot water washes dry adds an automatic dry following the wash and delay adds the ability to delay the start time of the wash. note that the heated wash and delayed wash features are mutually exclusive while drying can be added independently.
the excludes constraint between heat anddelay in the feature model indicates that at most one of these can be selected.
the domain model ofw the bottom of fig.
is a state machine which speci es that after initiating and locking the washer a basic wash begins or a waiting period is initiated either for heating the water or for a delayed wash. then the washing takes place followed optionally by drying.
finally if drying or heating was used the clothes are cooled and the washer is unlocked terminating the process.
depending on which of the features have been selected only some parts of this process may be available.
the propositional formulas in boxes throughout the controller indicate thepresence conditions for di erent model elements i.e.
the con gurations of features under which the element is present in a product.
for example the transition from state locking to state waiting is only present if either featureheat or feature delay is selected it is guarded by heatingenabled and has action heateron only when feadomain model locking waiting washing entry tempcheck dryingunlocking setdelay wash.start heateron heateroff wash.start quickcool quickcool feature model heat delay heat dry dryheat delay dryheated wash wash and drydelayed wash delaywashing machine controller product line heat heatheat delay heat delay heat delay heat dry drydelaywashexcludes heatfigure example washing machine controller product linew.
nac1 lhs rhsx entry a1 x1 x2 x3xnac2xx1 x2 a a x2x1x entry a figure the fold incoming actions rule rffor refactoring a state machine.
tureheat is selected while it is guarded by delayenabled only if feature delay is selected.
consider a simple state machine transformation.
fig.
shows a transformation rule rfthat implements the fold incoming actions 1refactoring transformation that moves common actions on incoming transitions to a state into the entry action for the state.
speci cally the rule is applied to a state machine by attempting to match it to the location where some state x has two incoming transitions with a common action a as depicted in the lhs of the rule in the middle of fig.
.
then the matched portion is replaced with the rhs of the rule on the right of the gure which deletes actionafrom the transitions and makes it the entry action of statex.
the negative application conditions nacs on the left of fig.
prevent the rule from being applied when statexalready has an entry action nac1 or when there are more than two incoming transitions to it nac2 .
the transformation is executed by applying the rule rfto the state machine until it can no longer be applied.
1based on a refactoring by the same name presented in .
2the general case allows moving the action if it is present in all incoming transitions but we limit it to two transitions for simplicity.118while the above description makes it clear how to apply this transformation to an arbitrary state machine the goal of this paper is to apply such a transformation to an entire product line of models rather than a single product.
thus we aim to apply the transformation rule rfto the product linew.
sincewrepresents a set of possible state machine variants we would expect that the application of rftow should act as ifrfwere applied to each variant separately.
however applying rfdirectly to the domain model of w does not achieve the desired result for several reasons .
it may miss valid applications of the rule.
for example the two incoming transitions to state washing have the same action wash start which would match the lhs of the rule but since state washing already has an entry action tempcheck the rule does not seem to be applicable because it matches the negative application condition nac1.
however if we consider the presence conditions of the features we see that the entry action tempcheck only exists for those products in which feature heat is selected.
thus the rule isapplicable for some products speci cally those in which the feature delay is selected.
.
it may cause inappropriate applications of the rule.
for example rfseems to be applicable to the two occurrences of action quickcool on the two incoming transitions to state unlocking .
however if quickcool were folded into unlocking it would be present in all products even those for which neither heat nordry are selected.
.
the presence conditions may be a ected by rule applications.
for example rfis applicable to the incoming transitions of state washing with action wash start when the feature delay is selected.
as a result the action should be deleted from these transitions and added as an entry action to state washing only when delay is selected.
this can only be accomplished by setting the presence conditions for these elements appropriately.
yet conventional transformation rules such as rfdo not manipulate presence conditions!
in the rest of this paper we describe an approach to address these complexities in a generic way in order to adapt rules such as rfto be correctly applicable to product lines.
.
background in this section we x the notation and provide the necessary background on product lines and model transformations.
.
product lines we follow the annotative product line approach formally de ned below.
definition product line .
a product line pconsists of the following parts a feature model that consists of a set of features and a propositional formula pde ned over these features to specify the relationships between them.
a domain model consisting of a set of model elements.
a mapping from the feature model to the domain model consisting of pairs he eimapping a domain model element eto a propositional formula eover features.
the formula eis referred to as the presence condition of the element e. for the example in fig.
the feature model of the product linewcontains four features wash heat delay and dry.
relationships between these features are de ned by the propositional formula w wash heat delay .in this example domain model elements are state machine constructs such as states transitions state entry and exit activities and transition actions.
the presence conditions are given in boxes next to the corresponding domain model elements e.g.
the state waiting in fig.
is annotated by the presence condition heat delay .
feature wash is mandatory and thus always occurs.
for simplicity of presentation we omit wash from the presence conditions.
we also do not annotate elements whose presence conditions are true e.g.
the state locking .
definition feature configuration .
avalid feature con guration of a product line pis a subset of its features that satis es p i.e.
pevaluates to true when each variable fof pis substituted by true whenf2 and byfalse otherwise.
the set of all valid con gurations in p is denoted by conf p .
definition product derivation .
a productm isderived from the product line punder the feature con guration ifmcontains those and only those elements from the domain model whose presence conditions are satis ed for the features in .
for the example in fig.
sets fwash heat dryg fwash drygandfwashgare some of the valid con gurations of the product line w. any set not containing the feature wash or containing both heat anddelay does not correspond to a valid con guration as it violates the formula wgiven above.
the product derived using only the feature wash will go through the states locking washing and unlocking while the product derived using the features wash anddry will go through the states locking washing drying and unlocking .
note that while our work is based on the above de nition of annotative product lines it can readily be adapted to other annotative approaches e.g.
cvl .
.
model transformations in this paper we focus on model transformations done via graph transformations .
a graph transformation consists of executing a set of graphical rules de ned as follows definition transformation rule .
atransformation ruleris a tupler hfnacg lhs rhsi where lhs and rhs are the typed graphs called the left hand and the right hand sides of the rule respectively and fnacgrepresents a potentially empty set of typed graphs called the negative application conditions .
fig.
depicts the nacs lhs and rhs of the rule rffrom fig.
as typed graphs using types from the uml metamodel .
for example nac1 consists of a state xwith an entry action a1that is a uml behaviour e.g.
a class operation .
the nacs lhs and rhs of a rule consist of di erent parts i.e.
sets of model elements which do not necessarily form proper graphs.
these parts play di erent roles during the rule application cr the set of model elements that are present both in the lhs and the rhs i.e.
remain una ected by the rule.
dr the set of elements in the lhs that are absent in the rhs i.e.
deleted by the rule.
ar the set of elements present in the rhs but absent in the lhs i.e.
added by the rule.119arnac1 lhs rhs x statex1 state a behaviourt1 transitionx2 state a1 behaviour t2 transitionx1 state x2 state a behaviourt2 transition x statet1 transition t2 transition x statet1 transitionx1 state x2 state t3 transitionx3 state targetsourceentry actionsource target actiontarget target entrysource source targetsource source targetsource targetx state nac2 drfigure rfrepresented as typed graphs.
table matching sites of rule rfin fig.
for the domain model in fig.
.
site n c d k1 washing tempcheckwashing locking waiting wash start lw lwlocking lwwashing ww wwwaiting wwwashinglwwash start wwwash start k2unlocking washing drying quickcool wu wuwashing wuunlocking du dudrying duunlockingwuquickcool duquickcool nr the set of elements present in any nac but not those present in cr.
for the example rule rffrom fig.
these parts are as follows crisfx x1 x2 a t1 t1x1 t1x t2 t2x2 t2xg dris the setft1a t2ag aris the setfxag nris set fa1 xa1 x3 t3 t3x3 t3xg.
to reduce clutter only drand arare explicitly indicated in the gure.
a rulerisapplied to a model mby nding a matching siteof its lhs in m definition matching site .
amatching site of a transformation rule rin a modelmis a tuplek hn c di where canddare matches of the parts cranddrof the lhs ofrinm and nis the set of all matches of nacs in mrelative to candd.
two matching sites for the rule rfin the washing machine controller in fig.
are shown in table two more matches isomorphic to k1andk2 are not shown for brevity .
in this table lwand wware the names of the transitions between states locking waiting and washing while wuand duare the names of the transitions between states washing drying and unlocking .
the table says for example that in part dof matching site k1 t1a lwwash start and t2a wwwash start .
in the above de nition ndenotes the set of all matches within model mof the nacs of rgiven the match of crand dr. if the same nac can match multiple ways then all of them are included in nas separate matches.
for example if state washing had another input transition that transitionalgorithm apply rule input ruler modelm matching site k hn c di output transformed model m0 m0 m ifn then let a be a set of fresh elements corresponding to the part arofr add atom0 remove dfromm0 returnm0 figure algorithm for applying a graph transformation rule.
would also appear in nfork1since it would match t3.
the set of matching sites de ne those places in the model where the rule can potentially be applied definition applicability condition .
given a transformation rule r a modelm and a matching site k hn c di risapplicable at ki nis empty3.
the above de nition ensures that the rule can only be applied at a given site if canddare matched and no nac is matched.
for rf the matching site k1given in table does not satisfy the applicability condition since n16 .
on the other hand no nacs hold in the second matching site k2.
the rule application algorithm is given in fig.
.
the applicability condition is checked in step and if it satis ed the rule is applied by adding the elements in a step and deleting the elements in d step .
for example applying rftok2requires the deletion of the action quickcool from the two transitions because it is contained in d and the addition of quickcool as an entry action for state unlocking according to ar.
we refer to rules such as the ones described above as classical to di erentiate them from their lifted counterparts which can be applied to product lines.
.
approach in this section we describe the process of lifting a transformation rule to apply to product lines.
when a classical 3the theory of graph transformation requires some additional formal preconditions most notably the gluing condition .
we so not discuss them here for brevity.120p m p m r rfigure the preservation of con gurations to be satis ed by lifting solid lines denote rule application and dashed lines denote product derivation.
ruleris adapted for product lines we say that it is lifted and denote it by r .
.
correctness criteria we begin by attempting to de ne the requirements for r i.e.
how it should act on a product line so that it preserves the e ect intended by r. a natural answer is that after applyingr the target product line should have the same set of products as it would if rwere applied separately to each product in the source product line.
furthermore we would expect that this would also preserve feature con gurations.
this is illustrated in fig.
for each con guration the result should be the same target product m0 regardless of whetherr is rst applied followed by the derivation from p0 or if is rst used to derive mand thenris applied.
we capture these criteria formally definition correctness of lifting .
let a rule rand a product line pbe given.r is a correct lifting ofri for all rule applications pr p0 conf p0 conf p and for all con gurations inconf p mr m0 wheremis derived from p andm0is derived from p0 under .
note that this de nition is silent on two points.
first it does not require that the target feature model be identical to the source feature model they just need to be equivalent i.e.
have the same set of valid con gurations.
however sinceris only de ned for the domain model i.e.
it does not manipulate features a reasonable expectation is that it should leave the feature model unchanged.
second the above de nition does not specify exactly how the domain model should change as long as the set of products is as required.
the same set of products can be represented by di erent domain models and presence condition .
a reasonable expectation here is that the domain model should change as little as possible.
these expectations are not part of the correctness condition since they are not required to preserve the semantics of r yet they are nice to have properties for an implementation of lifting see sec.
.
.
when applying a graph transformation rule to a model it is su cient to nd a graph match of the lhs of the rule and then check whether the nacs are applicable.
however our motivating example in sec.
illustrated that applying a rule to a product line is more complicated because not all domain model elements may appear in a given product and so the rule may apply to some products and not to others.
thus to satisfy the correctness criterion we must a ect only those products in which the lhs is present and the nacs are absent.
.
lifting algorithm we now de ne what it means to apply a lifted rule r to a product line in an analogous way to the de nition in sec.
.2algorithm apply lifted rule input product line pwith constraint p ruler matching site k hn c diin the domain model of p output transformed product line p0 p0 p apply wf and njn2ng and c and d if p apply is sat then fora2ardo add ato domain model of p0 a apply endfor ford2d do d d apply if p dis not sat then remove dfrom domain model of p0 endfor returnp0 figure algorithm to apply a lifted graph transformation rule.
of the application of rule rto a model.
lifting a rule is not accomplished via higher order transformation instead we change the execution semantics of rule application.
a matching site for r is a matching site for r see def.
in the domain model of p. applicability is de ned as follows.
definition lifted rule applicability condition .
given a product line pwith constraint p a transformation ruler hfnacg lhs rhsi and a matching site k hn c diin the domain model of p the lifted rule r isapplicable at ki p apply is satis able where apply wf and njn2ng and c and d here and cis the conjunction of the presence conditions for elements in c similarly for and nand and d. this de nition says thatr is applicable i the presence conditions guarantee that at this matching site the rule rmatches in at least one product of p. speci cally it checks that there exists a product such that all elements of canddare present and not all elements in any nac match are present.
the general algorithm of a rule application for a lifted rule is given in fig.
.
in this algorithm steps check the applicability condition steps handle elements added by r while steps handle elements deleted by r .
specifically step adds each new element to the domain model ofp0 and step sets its presence condition to apply since such elements are added only to those products where rwas applicable.
for deletion step sets the presence condition as d apply to guarantee that the element will be absent i.e.
it is deleted virtually in the products where r was applicable and that it remains intact in all other products where it occurred previously.
step checks whether the element is now present in any product and if not it deletes it actually by removing it from the domain model.
as with a classical rule system lifted rules continue to be applied until no rule is applicable.
.
illustration we illustrate the lifting algorithm by applying the lift r fof the rule in fig.
to the example product line in fig.
.
the result is shown in fig.
with shading indicating changed presence conditions.
recall that w wash 121unlocking dryingwaiting locking washing entry tempcheck wash.start heateron quickcool heateroff wash.start setdelay wash.start quickcool heat delay heat dry drydelaydelay heatheat delay heat delay heat delay heat dry dry delay delayheat heatfigure the result of applying the lifted rule r f from fig.
to the product line win fig.
.
heat delay from sec.
.
.
the two matching sites for the rule are shown in table .
for k1 apply delay after substituting the presence conditions from fig.
and simplifying.
thus the applicability condition w apply wash heat delay is satis ed only in those products that have wash delay andnotheat .
this is because when heat is selected the entry action tempcheck occurs and this triggers nac1 so the rule is not applicable.
the only element added in steps is the new entry action wash start for state washing with the presence condition delay .
step virtually deletes the action on the transition out of locking when delay is selected by changing its presence condition to delay while the one out of waiting becomes heat delay .
step which would really delete these actions is not triggered for either transition since there are still products that require the actions on these transitions i.e.
step yields sat for both .
for the matching site k2 apply dry dry heat which is inconsistent and hence unsatis able.
thus the algorithm does not proceed beyond step and the rule is not applied.
.
analysis in this section we discuss the correctness of the lifting algorithm in fig.
as well as the properties of termination and con uence for lifted rules.
these results apply to arbitrary graph transformations being lifted and are not dependent on other properties of the transformations such as their being injective endogenous exogenous and so on.
correctness.
here we show that a transformation lifted according to the algorithm in fig.
applied to product line pto produce p0satis es the correctness condition in def.
.
first note that the lifting algorithm does not manipulate the feature model and so the feature model of p0is identical to the one of p. thus conf p0 conf p and condition is satis ed.
we now show that condition is also satis ed i.e.
for any con guration inpthat derives a product m ifris applied tomto produce m0thenm0is the product derived fromp0under .
we focus our argument on a speci c matching site k hn c disince by transitivity if the rule is correct when applied to each site then the application to any sequence of sites is also correct.
we begin by showing the correctness of the applicability condition def.
of the lifted rule r ifris applicable for product mat sitek thenr is also applicable i.e.
r does not miss any relevant sites.
the condition in def.
says that p apply must be satis able forr to apply.
but since is a valid con guration it must satisfy pby def.
and since by assumption ris applicable in matk all of the elements in canddare present and no nac in nis present.
thus apply holds and p apply is satis able i.e.
the lifted rule applicability condition is correct.
we now argue that the algorithm for lifted rule application given in fig.
is correct i.e.
applying r at sitek has the same e ect on mas applying ratkinm.
we rst consider the e ect of ron adding elements and then its e ect on deleting elements.
applyingrto a product creates new elements according toar and these are the same in every product to which rapplies.
thus step adds these elements to the domain model.
by setting the presence condition for these elements to apply in step we guarantee that these will be present in all products including m whererwould have been applicable.
thus the addition of new elements is correct.
applyingrto a product deletes the elements in d. step ensures that the presence condition for these elements is further constrained so that they are absent in those products where apply holds.
thus the deletion of elements is correct.
note that up to this point the elements have been only deleted virtually by limiting their occurrence with presence conditions.
steps are an extra clean up these elements are deleted from the domain model if there are no products that contain these elements given that they now have more constrained presence conditions.
thus these steps do not a ect correctness.
since both the applicability condition and the e ect of rule application element addition and deletion are correct we conclude that r is correct w.r.t.
def.
.
termination.
to prove termination we show that if an application of a set of classical rules on an input model always terminates then so does the set of the corresponding lifted rules.
without loss of generality we restrict ourselves to a rule set containing a single classical rule rwhich we assume to be terminating.
since r is correct according to def.
repeatedly applying it to a product line phas the same effect as repeatedly applying rto each product of p. sincer is terminating it eventually no longer applies to any product ofp.
at this point apply which encodes the classical applicability is false and thus p apply is not satis able and by def.
r does not apply.
thus when the application ofrterminates the application of r terminates as well i.e.
if ris terminating so is r .
con uence.
repeatedly applying lifted rules to a product linephas the same e ect as repeatedly applying the corresponding classical rules to each product of p. if the classical rules are con uent and terminating the process over lifted rules reaches the same nal set of products regardless of the order in which rules are applied.
thus the lifted rule set is con uent up to equivalence .
that is it always produces product lines with the same set of products.
.
minimality while they do not a ect correctness issues of minimality of target product line may be relevant to the practical use of the lifting algorithm.
we brie y discuss them below.122domain model minimality.
the domain model is not minimal when it contains elements not found in any product.
the lifted rule algorithm only a ects the presence conditions of added or deleted elements.
steps of the algorithm ensure that virtually deleted elements that no longer occur in any product are deleted from the domain model.
added elements have the same presence condition as the rule applicability condition and so these must occur in the products where the rule is applicable.
thus we conclude that if the domain model was minimal initially then it will remain so after the lifted rule application.
feature model minimality.
a feature is super uous if selecting it does not a ect the derived products.
a feature model containing super uous features is not minimal.
note that the lifted rule application does not a ect the feature model part of a product line and so the source and the target feature models are identical.
this is a nice to have feature as discussed following def.
.
however the lifted rule application might make some features super uous.
for example if a transformation was applied to the washing machine controller product line in fig.
that deleted the transition from state washing tounlocking as well as state drying with all the transitions connected to it then the feature dry would become super uous.
minimality of presence conditions.
presence conditions are propositional formulae and our algorithm does not guarantee that after lifted rule application they will be in a minimal or normal form.
while this may a ect performance we do not expect a signi cant impact on the usability since modelers would rarely look at the presence conditions directly and instead would use tools to manipulate and reason with them.
.
tool support and application tool support.
we implemented the lifting algorithm as an extension to the graph transformation tool henshin using the z3 smt solver to do the sat checks algorithm steps and .
the tool integration platform used was the model management tool framework mmtf an eclipse based infrastructure for model management.
the key challenges we faced in the implementation were related to the growth in the number of presence conditions to be tracked at each new step of the lifting algorithm see steps and .
we tackled these using incremental sat solving techniques.
application.
we used the car crash management software product line case study referred to as bcms spl as a detailed application scenario for our transformation lifting approach.
our goal was to develop a better understanding of the feasibility of the approach in practical contexts by applying it to a larger more realistic example.
in addition we compared this example with the results of the scalability study given in sec.
.
bcms spl describes a software system for managing the identi cation tracking and resolution of car crashes within a community.
the system focuses on re and police as the emergency response providers and facilitates communications between the stakeholders including the victim s witnesses police o cers re persons emergency vehicles and coordination personnel.
in addition to the basic requirements for such a system variation points are also speci ed bcms non functional functionals smandatory feature optional feature and feature group or feature group xor feature group vehicles management no send reciveother psc send receivefsc send receivepsc fsc sendpsc receivevehicle management communication protocol soap sslcrisis multiplicity single multiple require requirerequireauthentication password based certificate basedbiometric based one time passwordchallenge response symmetric encryption mutual authorizationkerberosdata communication confidentiality encrypted not encryptedfigure a feature model showing the variation points the bcms spl case study.
shown as a feature model in fig.
.
these address different ways in which the system could be customized.
for example the feature crisismultiplicity selects between a system that can only address a single crash at a time and one that can handle multiple crashes in parallel.
overall the feature model de nes valid product variants.
we used a documented uml product line developed for the bcms spl requirements and focused on its structural part i.e.
the class diagram.
when all of the variants were merged and extended where incomplete this class diagram had classes associations attributes and operations.
of these had presence conditions i.e.
were not always present .
we applied the lifting to two transformations.
the rst a class diagram to relational database schema translation c2r is often used as a benchmark for prototyping and comparing transformation approaches .
c2r consists of transformation rules shown in fig.
of with the lhs parts ranging between and elements.
the result of applying the lifted c2r transformation is a product line with the same feature model as in fig.
but applied to an entity relational model.
thus the c2r transformation illustrates how a lifted transformation can be used to convert a product line for one type of domain model into a product line for another.
4adapted from the feature model in which models ve of the seven variation points in bcms spl.123table results of experiments with the bcms spl case study.
classical lifted transformation avg time per app ms avg of apps time per app ms slow down max chain of apps c2r .
.
.
.
addget .
.
.
.
the second transformation we consider is addget a restriction of the standard class diagram refactoring encapsulate variable used to add getter and setter methods to public data members i.e.
attributes of a class in order to control access to an object s state.
for simplicity addget is restricted to just getter methods.
results.
we conducted our experiments using our prototype implementation on an intel core i7 .40ghz cores logical computer with 8gb ram running ubuntu64 .
.
for each transformation we ran its lifted and classical versions on ve randomly generated products showing the averaged results in table .
the second and third columns show the average running time per rule application in ms and the average number of rule applications for the classical rules respectively these re ect the fact that c2r is a substantially more complex rule than addget.
the sixth column shows the maximum length of rule application chains for the lifted rule.
a chain occurs if the rhs of a rule application is subsequently matched as the lhs or nac of another rule application.
rule chaining is important since the presence conditions of rhs elements in a rule application are constructed from logical combinations of the presence conditions for lhs and nac elements see steps and of the lifting algorithm .
thus rule chains cause presence conditions to grow in size each time a chaining occurs.
the maximum length of the chains in both cases is small and so the growth of presence conditions is not a concern.
we use this observation to calibrate the scalability experiments in sec.
.
the seventh column shows the number of rule applications for the lifted rule.
this number is consistently larger than for the classical rule column three .
we expect the lifted rule to have more applications than the classical rule for two reasons.
first the lifting algorithm can delete an element virtually via presence conditions see step .
virtual deletion means that the element is still in the domain model and can get matched again in subsequent rule applications.
classical rules delete the element entirely.
second since the e ect of nacs cannot be determined without considering the presence conditions the transformation engine cannot use the occurrence of nacs in the domain model to eliminate potential rule applications.
thus this causes more matches than in the classical case.
yet we observed that the impact of these increases is relatively minor.
the fourth column lists the running time for the lifted versions of the rules and the fth the slow down factor.
thus the lifted version of c2r runs times slower than its classical counterpart whereas addget is times slower.
recall that applying the lifted rule is equivalent to applying its classical version to all of the products simultaneously!
thus we conclude that lifting the rules in the bcms spl case study leads to a orders of magnitude improvement in performance if compared to the classical application over all products.
.
evaluation in this section we describe an experimental study aimed to answer the research question how does our approach scale with respect to increasing the size of product lines and transformation rules?
to answer this question we tried to identify the bottlenecks in our approach and generate randomized inputs to stress test them.
.
methodology lifted rule application begins with nding a rule matching site which is a well studied subgraph isomorphism problem .
here our approach performs as well as the traditional graph transformations.
next the application algorithm in fig.
is applied.
steps of the algorithm can be completed in time linear in the size of the matching site k. we thus focus our examination to steps and since they require solving the satis ability problem which is npcomplete.
the former entails checking whether p apply def.
is sat and the latter if p d apply is unsat.
in this section we refer to these formulas as 1and respectively.
since 1and 2are similar in structure we use the same experimental design whereby we generate random but realistic inputs to a sat solver to measure the time required to check sat and unsat respectively.
to generate realistic inputs we simulated the execution of the algorithm in fig.
replacing matching with random element selection.
we varied input generation using two experimental variables a the feature model and b the transformation rule.
in addition based on pilot runs and the case study described in sec.
we calibrated random input generation to ensure that the generated formulas correspond to realistic scenarios.
we describe the details below.
varying the feature model.
each element in 1and 2is represented by its presence conditions which are expressed over the set of features.
moreover as described in sec.
.
the feature model of a product line pcan be encoded in the propositional formula pexpressed over the set of features pis a subformula of 1and .
thus the rst experimental variable is the choice of a feature model.
to get realistic values of this parameter we used the collection of real feature models available in the s.p.l.o.t repository .
at the time of experimentation the repository contained real feature models ranging from to features with an average of features each.
varying the transformation rule.
the subformula apply of 1and 2in def.
gets more complex for larger sizes of the rule s lhs and nacs.
thus our second experimental variable is the choice of the rule.
to vary it we use seven real graph transformation rules chosen from the literature and shown in table .
we speci cally chose those that represent variety of transformation use cases translation refactoring re nement etc.
and have lhs rhs and nacs of di erent sizes ranging from to .
5for more details about the experimental study see toronto.edu se research icse14.htm124table rules used in the experiments.
for each rule the values n c d a are the number of elements in the rule parts nr cr dr ar respectively.
rule category n c d a source 1relations stationwmale view generation fig.
2uml activity to petri net transition re nement fig.
3while reduction fig.
4encapsulate variable refactoring fig.
5fold incoming transitions refactoring fig.
6attr2fkeyr translation fig.
7assoc2fkeyr translation fig.
generating inputs.
in order to generate realistic inputs we simulate the rule application algorithm in fig.
.
at each simulation step r we produce a formula apply r that approximates the formula apply in 1and .
we resorted to simulating the algorithm due to the lack of readily available real examples of product line domain models.
we simulated the matching and transformation steps of the algorithm by generating expressions that represent elements with randomly generated presence conditions.
in each simulated rule application we constructed the new presence condition for added or deleted elements from randomly generated presence conditions for the lhs and nacs in the rule.
the initial presence conditions were randomly assigned either true or a single feature variable.
then as new presence conditions were constructed by simulated rule applications they were put into a pool for possible reuse in subsequent rule applications.
this was done to simulate the chaining of the rules see sec.
.
in subsequent rule applications elements were drawn from this pool with a chaining probability and assigned to lhs and nacs of the rule application.
the above process was repeated a preset number of times.
calibrating input generation.
the generation process described above requires calibration of a few additional experimental parameters.
rather than considering these as independent variables we chose to x their values based on pilot runs and observations of the case study in order to avoid the combinatoric explosion of possible experimental con gurations.
these parameters are the size of the original domain model xed at elements to simulate models of a reasonable size the probability that the initial presence condition is a feature rather than true xed at .
the maximum number of simulations for each model transformation rule pair xed at rule applications rule chain lengths limited to the maximum of .
.
results we implemented the experiment using mmtf as the integration platform and used the hardware setup described in sec.
.
each datapoint is obtained by averaging runs.
the results are shown in fig.
a .
the horizontal axis uses the logarithmic scale and plots the increase in size of the input feature model measured by the number of features.
the vertical axis plots the time required to check the generated formulas 1and 2in seconds.
each rule in table corresponds to a separate line.
the experiments show that the time required to check the satis ability of the formulas grows at most linearly for all models and logarithmically for small to medium sizedproduct lines.
such product lines formed the majority of the samples gathered from s.p.l.o.t.
for larger product lines with more than features the time increases more linearly.
the determining factor in the observed variation of runtimes is the number of calls to the solver that returned unsat a.k.a.
unsat calls for our examples these were faster than those returning sat.
fig.
b shows the number of unsat calls against increasing the product line size.
the inverse correlation between the solver runtime and the number of unsat calls is most dramatic for rule at the feature mark.
similarly we observe that the smaller rules rules in table have fewer unsat calls take relatively more time to complete and have less variation in processing time.
matching of the larger rules rules in table is more di cult due to their complex patterns and therefore yields more unsat calls.
our preliminary results allow us to conclude that our approach scales well as the size of the product line and the rules increases.
the complexity of the problem is likely related to the clause variable ratio of formulas in the sat calls and needs further investigation.
threats to validity.
the rst threat to validity is the choice of input models and the random generation of inputs.
we attempted to mitigate this by selecting real feature models from s.p.l.o.t and by adapting the random input generation algorithm to closely approximate the real observations from the case study.
the second threat is the calibration of the experimental parameters with xed values rather than varying them as independent variables.
to mitigate this we calibrated the parameters using values observed in our pilot runs and the case study.
.
related work we have studied the issue of transformation lifting for models with uncertainty .
such models contain annotations to indicate which elements may not exist and use a propositional formula to de ne sets of elements that can exist at the same time.
although the current paper has been inspired in part by this work there are substantial differences.
product lines and models with uncertainty both represent sets of models but do so in di erent ways the former contain feature models domain models and presence conditions while the latter contain only a single model and a single propositional formula i.e.
there is no concept that corresponds to the notion of a feature.
as a result of these distinctions the approach for lifting transformations for product lines does not require expensive propositional formula manipulations needed for models with uncertainty 100time seconds number of features logarithmic scale relations stationwmale uml activity to petri net transition while encapsulate variable fold incoming transitions attr2fkeyr assoc2fkeyr 100number of unsat results number of features logarithmic scale relations stationwmale uml activity to petri net transition while encapsulate variable fold incoming transitions attr2fkeyr assoc2fkeyr a b figure experimental results as product line size increases a time to check satis ability of 1and b number of unsat calls.
such as existential quanti cation making it quite di erent and substantially more e cient.
several works focus on making existing software engineering techniques variability aware so that they are applicable on the level of the whole product line rather than individual products see for a survey.
examples include model checking type checking and testing .
our approach shares the goal of lifting operations to the product line level but focuses speci cally on model transformations.
numerous product line level model transformations allow to derive individual products from a product line merge products and feature models re ne feature models and more.
borba et al.
organize these works formally de ning a theory of product line re nements as well as a catalog of commonly used re nements.
our work di ers from these as we focus on lifting existing transformations from the product to a product line level rather then handcrafting transformations for product line speci c purposes.
schulze et al.
propose a variant preserving refactoring approach for feature oriented product lines aimed to improve the structure of source code.
the authors show how to extend traditional approaches to product lines created using feature oriented programming.
instead we focus on annotative product line representations realized with models and is not limited to just structural improvement.several approaches consider the problem of managing the variability of a model transformation itself.
sijtema proposes a method for using a feature model to con gure the decisions made by a transformation as it converts an input model into an output model.
kavimandan et al.
promote reuse of model transformations through parameterization and specialization of transformation rules.
we do not focus on variability of the transformation but rather on applying transformations to assets that contain variability.
product line evolution approaches e.g.
and focus on studying and supporting scenarios such as splitting merging adding or removing features and their implementations.
several such approaches are based on providing templates of safe evolution which are to be applied manually.
our focus is rather on transformations that preserve the original set of features while modifying the structure and the abstraction level of their implementations and we do so automatically.
freeman et al.
describe an example of lifting selected features and their compositions from a product line with complex implementations to a product line with simpler ones.
this work relies on operators mapping higher level features and their compositions to their lower level counterparts.
despite a shared name our work is di erent we lift transformations rather then product lines.
.
conclusion mde and sple are key techniques used in modern large scale software development practice.
yet using these techniques together can pose signi cant challenges.
in particular classical model transformations designed for use with individual models cannot be reused with product lines of models without substantial modi cation.
in this paper we addressed this challenge by proposing an algorithm and an accompanying tool for automatically lifting classical model transformations expressed as graph transformations to corresponding transformations of product lines.
this allows transformations to be reused with no additional development e ort and maintains a clear separation of concerns between the transformation de nition and variability management.
the initial experiments with the technique showed that it scales well.
we believe that transformation lifting is a foundational technique required to address the mde sple integration problem and we hope that it will help improve the practice of complex software development.
in the future we plan to do more extensive evaluation of the lifting technique.
in addition we intend to extend it in several ways.
currently rules are assumed to be executable independently and in any order.
rule control ow mechanisms restrict such applications and we are interested in lifting rules which are subject to such mechanisms.
we are interested in lifting transformations written in other more programmer oriented languages such as atl .
we plan to explore ways to integrate transformation lifting with existing product line tools.
.