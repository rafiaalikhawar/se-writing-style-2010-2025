falcon fault localization in concurrent programs abstract concurrency fault are difficult to find because they usually occur under specific thread interleavings.
fault detection tools in this area find data access patterns among thread interleavings but they report benign patterns as well as actual faulty patterns.
traditional fault localization techniques have been successful in identifying faults in sequential deterministic programs but they cannot detect faulty data access patterns among threads.
this paper presents a new dynamic fault localization technique that can pinpoint faulty data access patterns in multi threaded concurrent programs.
the technique monitors memory access sequences among threads detects data access patterns associated with a program s pass fail results and reports dataaccess patterns with suspiciousness scores.
the paper also presents the description of a prototype implementation of the technique in java and the results of an empirical study we performed with the prototype on several java benchmarks.
the empirical study shows that the technique can effectively and efficiently localize the faults for our subjects.
categories and subject descriptors d. .
concurrent programming parallel programming d. .
testing and debugging debugging aids diagnostics monitors and tracing general terms algorithms reliability keywords concurrency debugging fault localization atomicity violation order violation .
introduction the widespread deployment of parallel systems based on multicore processors is already having a tangible impact patent pending.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or co mmercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.on development and testing for major software vendors.
for example a survey of concurrency usage among nearly developers and testers at microsoft revealed that concurrency is prevalent with nearly two thirds of respondents reporting that they have had to deal with concurrency issues and of these people over half have had to detect debug and or fix concurrency bugs1on at least a monthly basis.
not only were these bugs reported as being among themost difficult tofind reproduce and fix butover60 of these bugs took at least a few days to repair accounting for thousands of days of work in aggregate.
besides productivity loss the ultimate consequences of shipping concurrent software with defects can be devastating the oft cited northeastern u.s. electricity blackout which left million people without power has been attributed in part to a race condition in multi million line monitoring software .
testing and debugging concurrent software can be even more challenging than for sequential programs for at least two reasons .
first concurrent programs exhibit more nondeterministic behavior which can make it difficult to even reproduce the faults.
second concurrent faults typically involve changes in program state due to particular interleavings of multiple threads of execution making them difficult to find and understand.
these faults most frequently manifest as data races atomicity violations and order violations which are consistently ranked as the most common and difficult source of concurrency faults .
prior work.
numerous efforts have discovered principles and methods to pinpoint these most frequent concurrent faults.
the earliest work applies static and dynamic analysis to detect data races in which multiple threads perform unsynchronized accesses to shared data .
however benign data races are common and can yield high false positive rates .
more recent work has instead tried to identify and detect constructs that correspond directly to faults.
such constructsinclude atomicity violations i nw hi c hare g i o no fcode that should execute atomically does not and order violations in which an unintended sequence of operations among threads occurs.
early work in this area focused on atomicity violations relying on the developer to explicitly annotate atomic regions for subsequent static or dynamic verification by a tool .
to relieve this annotation burden a recent trend is to applydynamic pattern analysis .
thetechniquecharacterizes faults by likely interleaved sequences of operations 1we use fault and bug interchangeably.sangmin park richard w. vuduc and mary jean harrold college of computing georgia institute of technology e mail sangminp richie harrold cc.gatech.edu 245and then searches for these patterns in an execution.
a pattern based approach can in principle be applied to both atomicity and order violations although existing methods have thus far considered only atomicity .
furthermore current methods may report many patterns only some ofwhich might directly identify the fault.
these methods donotpresentlyhaveanywaytorankorprioritize thepatterns.
many existing effective ranking techniques for fault localization are based on code coverage.
examples include prior work on tarantula for sequential programs and recentwork for statement and expression predicate ranking forconcurrent programs .
these methods work by as sociating the number of occurrences of a target coverage criterion with passing and failing executions and use these data to compute suspiciousness scores.
however thus far this approach has not been applied to concurrency patterns.
approach and contributions.
weproposeanewpatternbased dynamic analysis technique for fault localization in concurrent programs that combines pattern identification with statistical rankings of suspiciousness of those patterns.
we apply our technique to both atomicity and order violations.
during testing our technique detects access patterns from actual program executions which either pass or fail.
for each pattern the technique uses the pass fail statistics to compute a measure of suspiciousness that is used to rankall occurring patterns in the spirit of tarantula in the sequential case .
we also describe falcon a prototype implementation of the technique in java that is designed to have reasonable storage and execution time overheads sothat it may be deployed in realistic testing environments.we used falcon to perform an empirical study on several java benchmarks.
the empirical study shows that the techniquecan effectively andefficiently localize thebuglocationsfor our subjects.
the technique has several advantages over existing tools.
first the technique captures not only order violations butalso atomicity violations existing tools focus only on either of the bugs.
second the technique reports the real violation patterns with high priority unlike other techniques that re port benign and real violations without priority.
third thetechniqueis more efficient than previous techniques in termsof time and space.
in short our approach provides the same benefitsof priordynamicpattern analysis methods andcontributes an explicit prioritized ranking of those patterns to guide the developer toward the most likely cause of a fault.
the main contributions of the paper are to the best of our knowledge our approach is the first to localize malicious interleaving patterns in concur rent programs.
the aim is to help the developer morequickly identify the source of a concurrency fault.
our technique detects both atomicity and order violations.
in particular we believe our work is the first to effectively identify order violations.
we have implemented this technique in a java basedtoolset called falcon which can be applied to any concurrent program with test cases.
we evaluate falcon experimentally and show that it is both effective and efficient in localizing concurrency faults in our subjects.
we compare falcon to the most closely related tools .table conflicting interleaving patterns.
interleaving description r1 w2 unexpected value is written.
w1 r2 unexpected value is read.
w1 w2 the result of remote write is lost.
table unserializable interleaving patterns.
interleaving description r1 w2 r1 two local reads expect to get the same value.
w1 w2 r1 a local read expects to get the resultof a local write.
w1 r2 w1 a temporary result between local writes in one thread is not supposed to be seen to other thread.
r1 w2 w1 the result of remote write is lost.
w1 w2 w1 the result of remote write is lost.
.
motivating example inthis section we defineourtarget concurrency violations and present an example that we use throughout the paper.
we then use this example to illustrate the limitations ofexisting techniques.
.
concurrency violations we begin by introducing our formal notation and then defining the key concurrency violations of interest in this paper atomicity violations and order violations.
notation.
we denote a memory access to a shared variable bybt s w h e r e bis the memory access type either read r or write w tis the thread that performs the access and s is the program statement containing s. for example r s2 indicates a read access to a s hared variable in statement s2 of thread .
we can often abbreviate this notation e.g.
by r1if the statement is understood from the context .
data race.
adata race occurs when two or more threads access a shared memory location where at least one of the accesses is a write and there is no locking to synchronizethe accesses.
for example any of the pairs r w2 w r2 w1 w2are in the absence of synchronization data races.
as is well known a data race does not always imply a fault.
for example barriers flag synchronization and producerconsumer queues are common concurrency constructs that are implemented with deliberate data races .
therefore we do not focus on data race detection in this paper thoughour method can include it.
order violation.
two sequential thread accesses to a shared memory location is a conflicting interleaving pattern if at least one of the accesses is a write as shown in table .
an order violation occurs when a conflicting interleaving pattern appears that leads to unintended program behavior.
the following is an example of this violation thread lock l a new myobject if a ... unlock l thread lock l x a.getvalue unlock l 246initially x y thread1 if x x if y y if x and y assert false thread2 if x x if y y thread3 if x x if y y a b trace trace trace trace simtrace sim statement x access y access plified x plified y r1 w1 r3 6w3 r2 r1 r1 w1 r3 7w3 r2 r1 w1 w3 6r2 r1 w1 w3 7r2 r1 r1 w1 r3 6w3 r2 r1 r1 w1 r2 5w2 r3 r1 w1 w3 6r2 r1 w1 w2 5r3 r1 r1 w1 r2 4w2 r3 r1 r1 w1 r3 7w3 r2 r1 w1 w2 4r3 r1 w1 w3 7r2 r1 r1 w1 r2 4w2 r3 r1 r1 w1 r2 5w2 r3 r1 w1 w2 4r3 r1 w1 w2 5r3 r1 c run1 run2 run3 run4 suspciousness pattern for x w w3 r1 pattern for x w w2 r1 .
pattern for y w w3 r1 pattern for y w w2 r1 .
result p p p f figure motivating example a a three threaded buggy program example b three passing and one failing executions of the program with different level of traces and c unserializable interleaving patternsassociated with suspiciousness scores computed by a statistical method.
the correct order of the execution is executing the code in thread and then thread .
however variable xgets an unexpected value when the code in thread is executed before thread .
here r s2 w1 s2is an order violation.
note that the example is synchronized by a lock l so it is neither a data race nor an atomicity violation see below .
atomicity violation.
anatomicmethodoracodeblockis a sequence of statements whose execution is not interrupted by the execution of statements in different threads.
atomicityis often referred to as serializability and is satisfied if the resulting state of data in a concurrent execution is the same as that of a serialized execution.
in table we show unserializable interleaving patterns .
for example r w2r1is an unserializable interleaving pattern where thread first reads a shared memory variable then another thread thread writes to the shared memory variable and finally thread reads the shared memory variable.
the pattern is unserializable because a serial execution r r1 w2has a d i ff e r e n tv a l u ef o rt h es e c o n dr e a da c c e s s .
anatomicity violation occurs when an unserializable interleaving pattern leads to unintended program behavior.
note that as with order violations an atomicity violation can occur without a data race .
we give an exampleof an atomicity violation in the following section.
.
a running example asourexample we usethethree threadedprogram shown in figure a .
the program has shared variables xand y which are initialized to .
thread sets the values of xand yto if their values are and checks whether the values of both xandyare2.
ifthevaluesof xandyare2 theprogram fails with an assertion violation.
thread and thread setthe values of xandyto and respectively if the values of xandyare1.
to raise theassertion violation two conditions forxand ymust be satisfied for x statements and consecutively executed without intervention of statement fory statements and consecutively executed without intervention of statement .
figure b shows the results of four executions.
the first column numbers each execution.
the second column shows statement traces for the four executions.
the third and fourth columns show the data accesses for variable xandythat occur during each execution.
the fifth and sixth columns show the simplified data accesses of variables xand yof the third and fourth columns.
the simplification will be discussed in section .
.
columns through use the notation of section .
.
figure c shows the ranking of identified unserializable interleaving patterns.
the second to the fifth rows show all four unserializable interleaving patterns identified from the four executions.
in this example we consider only un serializable interleaving patterns as opposed to conflictinginterleaving patterns because theprogram has atomicity vi olations that consists of two unserializable interleaving pat terns.
the second to the fifth columns show the four runs from figure b .
if a pattern appears in a run the overlapped cell is marked with .
for example w w3 r1pattern for x appears in runs and .
the sixth row shows the passing failing result of each run runs are passing and run is failing.
the sixth column shows the suspiciousness scores for the four patterns.
the suspiciousness scores of w1 w2 r1patterns for xand yare .
and suspiciousness scores for other two patterns are .
existingatomicity violationdetectorsfailtoprecisely identify the patterns that cause the fault.
most detectors will find all or some of the four distinct unserializable interleaving patterns shown in the first column of the table in figure b after four executions .
avio reports patterns that appear only in failing executions it fails to reportany pattern in our example because all four patterns appearin at least one passing execution.
only falcon reports the two w w2 r1patterns for xand y with the highest suspiciousness scores.
we discuss the technique in detail in section .
.
our technique our technique for identifying concurrency bugs in java threads consists of two main steps.
in step our technique monitors shared memory accesses online detecting and recording patterns of such accesses that correspond to unserializable and conflicting interleaving patterns.2step associates these patternswith test cases and pass fail results 2recall that these two classes of patterns are associated with atomicity violations and order violations respectively.
a xaccess r w1 r3 w3 r2 r1 b yaccess r w1 r2 w2 r3 r1 figure memory access and sliding windows a and b are shown in the trace of the second execu tion third row in figure b .
of the executions.
in step our techniqueapplies statistical analysis to the results of step to compute a suspiciousness valuefor each detected pattern as described in section .
.
using these suspiciousness values step ranks the patterns from most to least suspicious and presents this ordered list to the user.
the remainder of this section describes thesesteps in detail.
.
step online pattern identification step of the technique identifies unserializable and conflicting interleaving patterns described in section .
during the program s execution.
like other fault localization techniques our technique records program entities and subsequently associates them with passing and failing runs.
however ourtechniquediffersfrompriorfault localization work in two ways.
first instead of running the program with many test cases our technique runs the program manytimes i.e.
ktimes with the same test case.
the program is non deterministic thus different and possibly faulty interleavings of access to shared variables can occur in different executions of the same test cases.
we also apply random delays or irritators toincreasethelikelihood of differentinterleavings .
second instead of gathering coverage of simple entities such as statements branches or predicates our technique tracks patterns i.e.
sequences of shared variable