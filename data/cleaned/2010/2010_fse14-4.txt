discovering refactoring opportunities in cascading style sheets davood mazinanian nikolaos tsantalis computer science and software engineering concordia university montreal canada d mazina tsantalis cse.concordia.caali mesbah electrical and computer engineering university of british columbia vancouver canada amesbah ece.ubc.ca abstract cascading style sheets css is a language used for describing the look and formatting of html documents.
css has been widely adopted in web and mobile development practice since it enables a clean separation of content from presentation.
the language exhibits complex features such as inheritance cascading and speci city which make css code hard to maintain.
therefore it is important to nd ways to improve the maintainability of css code.
in this paper we propose an automated approach to remove duplication in css code.
more speci cally we have developed a technique that detects three types of css declaration duplication and recommends refactoring opportunities to eliminate those duplications.
our approach uses preconditions that ensure the application of a refactoring will preserve the original document styling.
we evaluate our technique on real world web systems and css les in total.
our ndings show that duplication in css code is widely prevalent.
additionally there is a signi cant number of presentation preserving refactoring opportunities that can reduce the size of the css les and increase the maintainability of the code.
categories and subject descriptors d. .
distribution maintenance and enhancement keywords cascading style sheets refactoring duplication .
introduction cascading style sheets css is a language for de ning the presentation semantics of web documents.
css is widely used in today s web development over of web developers use css in of the web sites .
css is also increasingly used in mobile app development through frameworks e.g.
phonegap ibm worklight that generate permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.hybrid mobile apps.
as a result css has become an important language with applications in many di erent domains.
while css has a relatively simple syntax some of its complex features such as inheritance cascading and speci city inherently make both the development and maintenance of css code cumbersome tasks for developers.
furthermore css development is far from a rigorous and disciplined process due to the lack of established design principles and e ective tool support .
one instance of undisciplined development is the de nition of new css rules by copying and modifying existing code instead of reusing already de ned ones.
there is empirical evidence that duplicated code in software systems developed with procedural or object oriented languages is associated with increased maintenance e ort higher error proneness and higher instability in terms of change frequency and recency.
we believe that the development and maintenance of css code is also subject to the same problems caused by code duplication.
moreover the problem of duplication might even be more intense in css code because the css language lacks many features available in other programming paradigms that could enable code reuse.
for instance there is no notion of variables and functions in css to build reusable blocks of code.
in addition css code has to be transferred over the network from a server to many clients.
extensive code duplication increases the size of the transferred data resulting in a large network load overhead.
once on the client side the css code has to be processed by the web browser.
extensive code duplication increases the size of the css code that has to be processed by the browser resulting in a computational overhead that might be signi cant taking into account the limited computation memory and power resources available in mobile devices.
previous studies have shown that the visual layout of web pages performed by analyzing the css code consumes of the average processing time of the browser.
in this paper we propose an automated technique to analyze and detect various types of css duplication and discover and recommend refactoring opportunities to eradicate duplicated css code.
this work makes the following main contributions .
we de ne various types of duplication in css code and propose a technique for the detection of duplication instances.
.
we present a recommendation technique for refactoring opportunities that can eliminate css code duplication.
additionally we provide a ranking mechanism based onthe size reduction that can be potentially achieved by each suggested refactoring to help css developers prioritize their maintenance e orts by focusing on the refactorings with higher impact.
.
we describe preconditions that preserve the css styling after the application of a refactoring.
.
we perform an empirical study to assess the e cacy of our approach using real world web sites making use of css les in total.
our results show that the extent of duplication in css code is indeed very intense ranging from to for the vast majority of the examined css les.
on average we found refactoring opportunities in the examined css les out of which could be applied by preserving the styling of the web pages.
finally the average size reduction achieved by applying only presentation preserving refactorings was while the highest reduction was .
.
the css language css was one of the rst standards approved by the world wide web consortium w3c along with the markup language html.
css enables separation of concerns by disconnecting styling code from markup.
consequently the same style sheet can be applied to di erent markups enabling the reuse of styling code.
in this paper we call the html pages on which the styles are applied as target documents .
style sheets can be written inside the target documents or in separate external css les which are linked to the target documents.
css les consist of a set of css rules with a syntax shown in figure .
selector property 1 value 1 property 2 value 2 ... property n value n figure css rules syntax.
the selector part in the css rule de nes the elements of the target document on which the style rules should be applied.
for example a pselector selects every paragraph element p in the document.
the property value pair is called a style declaration .
the declarations de ne style values for the speci ed properties of the element selected by the corresponding selector.
for example the declaration color blue will apply a blue color to the text of the selected element.
there may be multiple style declarations in every selector.
.
css selectors it is possible to set an id for elements in the target document using the id attribute.
for example the html tag div id toolbar corresponds to a divelement for which the id is equal to toolbar .
the toolbar css selector which is called an id selector can be used to select the element with this id.
also a group of declarations could be de ned as a class in css.
it is then possible to apply the same class to many di erent elements thus avoiding the duplication of declarations.
figure shows an example of a class selector.
there is also the possibility of grouping di erent selectors in css using the character.
for instance if we want to html css div class class1 content div span class class1 content span .class1 color red font 10pt tahoma figure class selectors.
apply the same styles to all h1and h2html elements we could use the h1 h2 declarations css rule.
we can also add attribute conditions to a selector.
if selector sselects a set of elements s a selector of the format s selects the subset elements of s for which in the target document attribute attr is de ned and set to a substring of value .
the operator de nes the condition for the substring .
for example a selects all a elements that have the target attribute set to any value and img selects all img elements that have the .png su x in their srcattribute value.
pseudo classes can be used to lter the elements selected by a given selector.
for example not div selects all elements except for divelements.
there are also structural pseudo classes such as tr nth child 2n which selects every odd row in every table of the target document.
pseudo elements create abstractions about elements in the target document beyond those speci ed by the html standards .
the p first line selector for example selects only the rst line of the text inside every p element.
finally we can combine various selectors to achieve more speci c selectors using di erent combinators .
assuming we have two selectors a and b we can combine them as follows a b descendant combinator selects all elements selected by b which are descendants of the elements selected by a. a b child combinator selects all elements selected by b which are direct children of the elements selected by a. a b general sibling combinator selects all elements selected by b which have an element selected by a as a sibling.
a b adjacent sibling combinator selects all elements selected by b which are directly preceded by a sibling element selected by a. .
inheritance cascading and specificity elements in the target document are organized in a hierarchical manner.
for some speci c element properties css supports inheritance in values by taking advantage of this hierarchical structure.
for example if we apply color blue to the body element all child elements of the body tag will be styled with the blue color.
it is possible to have di erent css rules that select the same html elements.
if these selectors assign values to the same properties the web browser can only apply one of the property values to the selected elements.
in such cases the web browser follows the cascading origin rules .
based on these rules the authored style rules i.e.
the rules written by the web application developer and linked to the target document will override the user style rules i.e.
the rules that the reader of a web site might have de ned in the browser .
similarly user style rules override the browser s default style rules .
in the case that the origin of theselectors is the same e.g.
the con icting selectors are in the same css le the speci city determines the winning selector i.e.
the more speci c selector has priority over the less speci c ones .
if the origin and the speci city is the same for two selectors the position of the selectors in the css le determines the winning selector i.e.
the last selector overrides the previous ones .
it is also possible to add the !important annotation at the end of a declaration to allow for a selector to bypass the speci city rules and be always applied.
.
duplication in css di erent types of duplication have been de ned for procedural and object oriented code based on the textual or the functional similarity of two code fragments.
the code duplication problem is expected to be more potent in css due to the lack of variables and functions that could be used to build reusable blocks of code.
as a result many common style declarations have to be repeated in multiple selectors.
.
duplication types in this work we focus on duplicated css declarations which can only be avoided by changing the css code.
additionally by eliminating this kind of duplication we can reduce the size of the css code that has to transferred over the network and be maintained in the future.
therefore we de ne three di erent types of duplication at the declaration level in this section.
type i declarations having lexically identical values for given properties .
an extreme example of type i duplication can be seen in figure which is taken from the main css le of gmail s inbox page.
in this le there are declarations that are repeated in three selectors.
figure shows only a subset of these declarations for two of the selectors.
.z b vn nnnn webkit box shadow n nnnnnnn0n1pxn0nrgba n0 n0 n. nnnnbox shadow n nnnnnnn0n1pxn0nrgba n0 n0 n. nnnnbackground color nffff nnnncolor nf404040 n nnnncursor ndefault nnnnfont size n11px nnnnfont weight nbold nnnntext align ncenter nnnnwhite space nnowrap nnnnborder n1pxnsolidntransparent nnnnborder radius n2px nnnn... .z b g n nnnn webkit box shadow n nnnnnnnn0n1pxn0nrgba n0 n0 n. nnnnbox shadow n nnnnnnnn0n1pxn0nrgba n0 n0 n. nnnnbackground color nffff nnnncolor nf404040 nnnncursor ndefault nnnnfont size n11px nnnnfont weight nbold nnnntext align ncenter nnnnwhite space nnowrap nnnnborder n1pxnsolidntransparent nnnnborder radius n2px nnnn... figure type i duplication in gmail s css.
note that the de nition of type i duplication considers only the equality of the property values and disregards the value order .
for instance consider the two border declarations in figure .
if one of them was de ned as border transparent solid 1px i.e.
same values in di erent order we would still consider them as an instance of type i duplication because based on the css speci cation the browser will interpret both declarations in the same way.
type ii declarations having equivalent values for given properties .
in css we may have the same values for properties withalternative representations.
font size color length angle and frequency values are representative cases.
for instance table shows alternative representations for the same color.
we consider all these di erent representation values as equivalent values.
table di erent representations for violet color.
representation value html named color violet hexadecimal ee82ee rgb rgb rgba rgba hsl hsl hsla hsla if two or more declarations have equivalent values for the same properties we consider them as an instance of type ii duplication.
in figure 5a we can see an example of type ii duplication in the css le of gmail s inbox page.
note that the declarations with color property are duplicated.
in addition there are some default values for certain properties which are applied when explicit values are missing.
for example based on the css speci cation the declaration padding 2px 4px 2px 4px can be also written in a shorter version as padding 2px 4px with the same e ect.
such cases are also considered as equivalent declarations and thus constitute instances of type ii duplication.
type iii a set of individual property declarations is equivalent with a shorthand property declaration .
some css properties such as margin padding and background are called shorthand properties .
with these properties we can de ne values for a set of properties in a single declaration .
for instance the margin shorthand property could be used in order to de ne values for margin top margin right margin bottom and margin left as shown in figure .
margin top 3px margin right 4px margin bottom 2px margin left 1px margin 3px 4px 2px 1px figure shorthand and individual declarations if a selector contains a set of individual declarations which is equivalent to a shorthand declaration of another selector we consider those declarations as an instance of type iii duplication.
figure 5b shows an example of type iii duplication in the css le of the gmail s inbox page.
.fj ... color white ... .ik ... color fff ... a type ii .sg0wif z zzzzborder bottom color z e5e5e5 zzzzborder bottom style zsolid zzzzborder bottom width z1px bodyz.azewnz z zzzz... zzzzborder bottom z1pxzsolidz e5e5e5 zzzz... b type iii figure declaration duplication in gmail s css3.
eliminating duplications the aforementioned types of duplication can be eliminated directly in css code without changing the target documents by extracting a grouping selector.
if a set dof declarations is duplicated in the form of type i ii iii duplication in a set of selectors s1 s2 s n we can create a new selector for the group s1 s2 s nand move dto this new selector.
for instance the css code snippet on the left side of figure could be refactored as shown on the right side of figure .
.jvq qqqqfont size q0 qqqqheight q100n qqqqleft q53px qqqqposition qabsolute qqqqright q35px qqqqtop q0 .qibgmf q qqqqfont size q0 qqqqheight q100n qqqqleft q53px qqqqposition qabsolute qqqqright q35px qqqqtop q0 qqqqwhite space qnowrap .jv q.qibgmf q qqqqfont size q0 qqqqheight q100n qqqqleft q53px qqqqposition qabsolute qqqqright q35px qqqqtop q0 .qibgmf q qqqqwhite space qnowrap newqselectorqformedqbyqgroupingqtwoq selectorsqusingqcomma non duplicatedqdeclarationqwillqremainqinqitsqoriginalq selector.qtheqw.jvwqselectorqisqremovedqsinceqallqitsq declarationsqareqnowqinqtheqnewqgroupingqselector.duplicated declarations areqgroupedbefore after figure grouping selectors to remove duplication.
another possible solution based again on grouping is to create a common class for the repeated declarations and assign that class to the target elements.
however this solution requires also to update the target documents so that they make use of the newly de ned class.
.
method our method for the detection of duplication in css and the extraction of refactoring opportunities is divided in four main steps discussed in the following subsections.
.
abstract model generation to look for duplications we rst need to parse all the css code of a given web application.
in order to support all available css standards we have adapted the w3c flute parser so that it conforms with css3 speci cations .
our method then analyzes the code and generates an instance of the abstract model shown in figure which represents a high level structure of the application s css code.
selector stylesheet baseselector simpleselector combinatormediumtype media3print1.. declaration text align 3center shorthanddeclaration margin 30px32pxgroupingselector p 3a 3h1 .s13.s2 .s13 .s2 .s13 .s2 .s13 .s2fid .class nth child 3n first letter not p .. .. .. .. .. figure css model as shown in figure every style sheet may be bound to some medium type .
this identi es the target presentationmedium for which the style sheet is de ned.
for instance one may distinguish styles for printing and displaying in a mobile device .
it is also possible to de ne the same selectors for di erent media types within a given style sheet.
in this model a baseselector represents selectors that do not perform grouping.
a simpleselector represents type selectors or the universal selector selector which selects every element .
the class simpleselector has special attributes for specifying properties like the element id class identi er pseudo class pseudo element and attribute conditions.
finally a combinator represents combinator selectors which can be formed by combining two baseselectors .
examples of each of these selectors can be seen in figure .
.
preprocessing the detection of type i duplications does not require any preprocessing.
however to facilitate the detection of type ii and iii duplication instances we perform three separate preprocessing steps.
normalization of property values.
in this step we replace values that can be expressed in di erent formats or units e.g.
colors and dimensions with a common reference format or unit.
for example every color in named hexadecimal or hsl format see table is replaced with its equivalentrgba value.
every dimension speci ed in centimeters inches or points is converted to its equivalent pixel value.
all applied conversions are based on the guidelines provided by the css speci cation .
replacing values with a common representation is known as normalization and has been used in traditional code clone detection techniques for nding clones with di erences in identi ers literals and types .
our motivation is to nd declarations using alternative formats or units for the same property value.
such cases constitute type ii duplication instances.
addition of missing default values.
as we discussed in section css developers sometimes omit values for some of the multi valued properties in order to have shorter declarations.
in this step we have some prede ned rules based on the css speci cation that add the implied missing values to the properties in the model.
for instance margin property should normally have values.
we enrich the declaration margin 2px 4px with the two missing implied values as margin 2px 4px 2px 4px .
this allows the comparison of declarations based on a complete set of explicit values enabling the detection of type ii duplication instances.
virtual shorthand declarations.
detecting type iii duplication instances requires the comparison between shorthand declarations in one selector and an equivalent set of individual declarations in another selector.
to facilitate this task we add virtual shorthand declarations to the model.
we examine the declarations of every selector to nd sets of individual declarations that can be expressed as equivalent shorthand declarations.
for every set of such individual declarations we generate the corresponding shorthand declaration and add it as a virtual declaration to the corresponding selector in the model.
these virtual shorthand declarations will be compared with real shorthand declarations to detect type iii duplication instances.
.
duplication detection duplication instances can be found by comparing every possible pair of declarations in the css model and checkingalgorithm detection of type i ii iii clones input a preprocessed style sheet stylesheet output allclones including type i ii iii clones mediumtypes all medium types in the stylesheet allclones ?
foreach m2mediumtypes do d all declarations in m clones m ?
fori 1tojdjdo clone di forj i 1tojdjdo ifidentical di dj equivalent di dj then clone clone dj end end ifjclonej 1then merged false foreach clone k2clones mdo ifclone k clone6 ?then clone k clone k clone merged true end end ifnot merged then clones m clones m clone end end end allclones allclones clones m end whether they are equal for type i or equivalent for type ii and iii .
the notions of equality and equivalence were discussed in section .
note that in our approach we consider the declarations present in the css model as they have been formed after the preprocessing steps to allow for the detection of type ii and iii duplication instances.
our detection approach is summarized in algorithm .
the algorithm receives as input a preprocessed css style sheet and returns a set of clones where each clone is a set of equal or equivalent declarations d fd1 d2 d ng and each declaration belongs to a selector si2s fs1 s2 s ng of the analyzed css style sheet.
figure depicts an example of a style sheet and the corresponding clones extracted from the application of algorithm .
the rst two clones contain instances of type ii duplication while the last clone contains an instance of type iii duplication.
.class1 3333color 3blue 3333font weight 3bold .class2 3333color 3y00f 3333font weight 3bold 3333border 3solid31px3yd3d3d3 .class3 3333font weight 3333border 3solid33px3red 3333float 3left .class4 3333border style 3solid 3333border color 3lightgray 3333border width 31px style sheet clones border style 3solid border color 3lightgray border width 31px font weight border color figure clones extracted from a style sheet4.
extracting refactoring opportunities aclone as de ned in subsection .
can be directly refactored by extracting a single declaration di2dto a new selector which groups all selectors in s and then removing all declarations in dfrom the original selectors they belong to.
the refactored version of the css code will containjdj less declarations but should have exactly the same e ect in terms of the styles applied to the selected elements.
as such the larger the clone i.e.
the cardinality ofd the more bene cial the corresponding refactoring is since a larger number of declarations will be eliminated by the application of the refactoring.
the detected clones constitute the building blocks for extracting more advanced and higher impact refactoring opportunities.
for instance there may exist selectors that have multiple declarations in common i.e.
selectors involved in multiple clones .
a set of common declarations shared among a group of selectors constitutes a clone set .
in that case all declarations in the clone set could be extracted into a single grouping selector or a class selector reducing signi cantly the repetition of declarations.
figure in subsection .
presents an example of such a case.
in general the more clones are common in a larger set of selectors the higher the impact of the corresponding refactoring opportunity in the reduction of repeated declarations.
in this work we use a data mining metaphor to extract clone sets as refactoring opportunities from the initially detected declaration level clones.
let us assume that the style sheet is a transactional dataset in which every selector si is a transaction and the clones corresponding to the declarations of siare the items of transaction si.
based on this mapping figure shows the resulting dataset for the style sheet of figure .
note that the clones are sorted according to their size i.e.
the number of duplication occurrences .
transactions selectors items corresponding clones .class2 .class3 .class4.class1 color font weight border color font weight font weight border figure dataset for the style sheet of figure in the data mining domain a set of items which is repeated in di erent transactions is called an itemset .
if an itemset is repeated in more than a certain number of transactions which is called the minimum support count the itemset is known to be frequent .
our goal is to extract all frequent itemsets with a minimum support equal to i.e.
the minimum size for a duplication instance because a frequent itemset in our case represents a clone set that is repeated in more than one selector.
therefore every frequent itemset is a potential grouping refactoring opportunity .
in our method we use the fp growth association rule mining algorithm which nds the frequent itemsets using a structure called frequent pattern tree fp tree .
the fp tree is essentially a compact representation of the dataset since every itemset association within the dataset is mapped onto a path in the fp tree.
figure displays the fp tree for the dataset of figure .
the fp tree has a header table which includes all distinct items that exist in the fp tree.
the items in this table are sorted in descending order based on their support count.
there is a link between every item in this table to the rst occurrence of that item in the fp tree rep header table border color font weight border font weight 3null color border 1figure fp tree for the dataset of figure resented as a dotted arrow from the header table to the nodes of the fp tree in figure .
to enhance the traversal of an item in the header table to all nodes containing that item nodes that contain the same item are also linked e.g.
the border nodes in the fp tree .
the number next to a node represents the number of transactions selectors in our case involved in the portion of the path from this node to the root of the tree.
for example the path from node color to the root represents that there are two selectors that contain both items color and font weight i.e.
selectors .class1 and .class2 .
the path from node border nested under node font weight to the root represents that there is only one selector that contains both items border and font weight i.e.
selector .class2 .
finally the path from node font weight to the root represents that there are three selectors that contain item font weight .
once the fp tree is constructed the fp growth algorithm generates all frequent itemsets with the minimum support speci ed as input.
figure shows all frequent itemsets i.e.
grouping refactoring opportunities generated with a minimum support value equal to .
frequent itemsets refactoring opportunitiesinvolved selectors .class1 .class2 .class1 .class2 .class1 .class2 .class3.class2 .class4 figure output of the fp growth algorithm for the style sheet of figure in the refactoring scheduling literature two refactorings are considered as con icting if they have a mutually exclusive relationship i.e.
the application of the rst refactoring disables the application of the second refactoring and vice versa.
within the context of css two refactoring opportunities are con icting if their application a ects a common subset of declarations.
for instance in figure if the last refactoring opportunity is applied the third one becomes infeasible and vice versa because these two refactoring opportunities a ect two common font weight declarations.
in the same manner the second and third refactoring opportunities are also con icting because they a ect two common color declarations.
however in that case the third refactoring opportunity subsumes the second one since the set of declarations a ected by the latter is a subset of the declarations a ected by the former.
our approach lters out subsumed refactoring opportunities if the ones subsuming them can be safely applied section .
.
for the problem of con icting refactoring opportunities we provide a ranking mechanism explained in section .
.
.
ranking refactoring opportunities although a refactoring operation a ects several quality aspects of the code such as understandability maintain ability and extensibility in this work we focus on the size of the css code because size is directly associated with the other aforementioned higher level quality attributes in general a code with small size can be more easily maintained .
hence in order to prioritize the refactoring opportunities and allow developers to focus on the most important ones we de ne a ranking formula based on the number of characters that can be removed from the css code by applying a given refactoring opportunity.
letrdrbe the set of duplicated declarations that will be removed from the style sheet by applying the refactoring opportunity r srbe the set of selectors that contain the duplicated declarations of set rdr i.e.
the selectors that will be grouped after applying r and adrbe the set of declarations that will be added to the new grouping selector.
it should be noted that adrcontains the declaration with the minimum number of characters for each set of equal equivalent declarations within rdr.
the size reduction sr achieved by refactoring opportunity ris calculated as follows sr r x d2rdrc d x s2src s x d2adrc d where the function ccounts the number of characters of the declaration or selector passed as an argument.
the higher thesr r value the higher the impact of rwill be on reducing the size of the css code.
a negative sr r value indicates that the size of the css code will increase after the application of r. a negative value is possible if the textual size of the selectors being grouped is larger than the textual size of the declarations being removed.
of course this would not be an issue if the duplicated declarations were placed under a newly de ned class however this solution would require to update the target documents to make use of the new class.
as mentioned before in this work we aim to avoid modi cations of the target document i.e.
all refactorings should be merely in the style sheets.
consequently when size reduction is the objective the refactoring opportunities should be applied in a descending order of sr value excluding those having a negative sr value.
based on equation the size reduction values for the four refactoring opportunities shown in figure are and characters respectively.
the second refactoring opportunity would actually increase the size of the css code if it was applied.
the rst refactoring opportunity corresponds to the highest size reduction and the css code resulting after its application is shown in figure 12b the new grouping selector is appended to the end of the le .
.
preserving order dependencies behavior preservation is a crucial property of refactoring .
the refactored program should have exactly the same functionality as the original program.
within the context of css the notion of behavior corresponds to the presentation of the target documents i.e.
the property values that are eventually applied to the target document elements .
therefore a refactoring can be considered as valid if its application preserves the presentation of the target documents.
let us assume that the css code of figure 12a is applied to the target document shown in figure 13a.
as we can observe from figure 13a the second divelement uses the style rules from both .class2 and .class3 .
as we can see from figure 12a the declaration of the border property in .class3 overrides the corresponding declaration in .class2.class1 3333color 3blue 3333font weight 3bold .class2 3333color 3y00f 3333font weight 3bold 3333border 3solid31px3yd3d3d3 .class3 3333font weight 3333border 3solid33px3red 3333float 3left .class4 3333border style 3solid 3333border color 3lightgray 3333border width 31px a .class1 x x xxxxcolor xblue x xxxxfont weight xbold x x .class2 x x xxxxcolor x 00f x xxxxfont weight xbold x .class3 x x xxxxfont weight x700 xxxxborder xsolidx3pxxred xx xxxxfloat xleft x x .class2 x.class4 x x xxxxborder xsolidx1pxx d3d3d3 x x1 b figure a order dependencies in the original css le b order dependencies after refactoring and as a result the second divelement is styled with a red color border as shown in figure 13b.
now let us assume that the rst refactoring opportunity shown in figure is applied to the css code of figure 12a resulting in the css code of figure 12b.
in the refactored css code the declaration of the border property in the extracted grouping selector .class2 .class4 overrides the corresponding declaration in .class3 .
as a result the second divelement is no longer styled with a red color border as shown in figure 13c which is a clear indication that the applied refactoring did not preserve the presentation of the target document.
this inconsistency is caused by the inversion of the originaloverriding relationship between selectors .class2 and .class3 after the application of the refactoring.
we de ne an order dependency from selector sicontaining declaration dkto selector sjcontaining declaration dldue to property p denoted ashsi dkip !hsj dli i a selectors siandsjselect at least one common element having property pin the target document b declarations dkanddlset a value to property pand have the same importance i.e.
both or none of the declarations use the !imporant rule c declaration dkprecedes dlin the style sheet d selectors siandsjhave the same speci city.
to ensure that the presentation of the target documents is preserved we de ne the following precondition the extraction of a grouping selector should preserve all order dependencies among the selectors of the style sheet.
the problem of nding an appropriate position for the extracted selector gin the style sheet can be expressed as a constraint satisfaction problem csp de ned as variables the positions of the selectors involved in order dependencies including g. domains the domain for each variable is the set of values f1 n 1g where nis the number of selectors in the original style sheet.
constraints assuming that gcontains declarations for the set of properties p an order constraint is created in the form of pos si pos sj for every order dependency hsi dkip !hsj dliwhere p2p.
... div class class1 class4 content1 div div class class2 class3 content2 div ... a content1 content2 b content1 content2 c figure a sample document b styling using the css code of figure 12a c styling using the css code of figure 12b in the example of figure 12a the order dependencies are h.class2 font weight boldifont weight !h .class3 font weight 700i h.class2 border solid 1px d3d3d3iborder !h .class3 border solid 3px redi and we extract the constraint pos .class2 pos .class3 .
based on this constraint the extracted grouping selector .class2 .class4 should be placed at any position before the selector .class3 i.e.
.class3 should be the last selector in the style sheet after refactoring in order to preserve the presentation of that target document in figure 13a.
if we assume that there is an additional order dependency from selector .class3 to.class4 due to property border then the csp would be unsatis able due to the new constraint pos .class3 pos .class4 .
in that case the extracted selector .class2 .class4 has to be placed before .class3 to satisfy the rst constraint and after .class3 to satisfy the second constraint and thus there is no solution satisfying both constraints.
refactoring opportunities leading to an unsatis able csp violate the de ned precondition and therefore are excluded as non presentation preserving.
.
ev aluation to assess the e cacy of our approach we conducted a case study addressing the following research questions rq1 what is the extent of declaration level duplication in css les?
rq2 what is the number of refactoring opportunities that can be potentially applied in css les and how many of them are actually presentation preserving?
rq3 what is the size reduction we can achieve by applying presentation preserving refactorings in css les?
our tool and empirical data are all available online.
.
experiment design selection of subjects.
in total our study contains subjects.
in order to select representative real world web applications we adopted the web systems included in the study conducted by mesbah and mirshokraie in which they investigated the presence of unused css code.
the list includes in total open source randomly selected and author selected online web applications.
we included subject systems from that list one of them is not available online anymore .
we extended the list with more subjects including web applications developed by companies considered leaders in web technologies such as facebook yahoo!
google and microsoft in addition to a subset of the top100 visited web sites based on alexa ranking.
the complete list of the selected systems is shown in table .
figure shows the size characteristics of the css code selectors and declarations of the subjects included in our study.
selected subjects id web app.
cssid web app.
css les les facebook pinteerst youtube reddit twitter tumblr.com yahoomail wordpress.org outlook.com vimeo.com gmail igloo github phormer amazon.ca beckerelectric ebay equus about.com protoolsexpress alibaba uniquevanities apple.ca icse12 bbc employeesolutions cnn synccreative craiglist globaltvbc imgur lenovo microsoft mountainequip msn staples paypal msnweather size kb md .
mean .
selectors10 md mean declarations10 md mean figure characteristics of the analyzed css les extraction of css styles and dom states.
css styles can be directly embedded in the web documents linked to web pages as external les or dynamically generated at runtime through javascript code.
for our experiments we focus on the external css les since the refactoring of the other sources of css code requires the modi cation of other web artifacts such as html documents which is not the focus of this paper.
we take advantage of the dynamic analysis features provided by crawljax and developed an external css le extractor plug in.
additionally we use crawljax to dynamically capture di erent dom tree instances i.e.
dom states from the examined web applications and use them for the extraction of order dependencies between the css selectors.
detection of presentation preserving refactorings.
in order to collect the set of presentation preserving refactorings that can be safely applied on a css le fstyling the set of dom states scollected from a web application we .
extract the order dependencies between the selectors of f by analyzing the dom states in s as described in section .
.
.
extract the set of refactoring opportunities rthat can be potentially applied to f. .
sort rbased on size reduction formula and remove the refactoring opportunities having a negative value.
.
iterate through the elements of rand apply the rst refactoring opportunity for which the csp de ned in section .
is satis able.
.
if step results in the application of a refactoring repeat steps with the refactored css le f0.
.
.
.
.
md .68mean .66figure percentage of duplicated declarations .
results extent of duplication in css declarations rq1 .
the results of our empirical study con rm the expectation that duplication is more extensive in css code compared to procedural and object oriented code with duplicated code .
figure displays a violin plot with the percentage of the declarations that are involved in at least one clone i.e.
they are at least once duplicated in the analyzed style sheets.
the median value for the percentage of duplicated declarations is while the average is .
the vast majority of the examined style sheets exhibits a duplication ranging from to .
note that in the reported results we have set the minimum support i.e.
the minimum number of selectors that should share a common declaration to the lowest possible value equal to setting a larger minimum support value would lead to lower duplication rates.
figure 16a shows the number of clones detected in the analyzed css les.
on average there are distinct declarations being repeated more than once in the examined style sheets that could be used as building blocks for extracting more advanced refactoring opportunities.
the venn diagram shown in figure 16b displays the percentage of the clones including di erent combinations of the duplication types de ned in section .
as it can be observed of the clones include only type i duplication instances while of the clones include a combination of type i and ii duplication instances.
furthermore the existence of type iii duplication instances within the clones is very rare.
md mean .
a total number of detected clones type i type ii type iii96.
.
.
.
.
b duplication types in the detected clones figure statistics for the detected clones refactoring opportunities in css rq2 .
figure shows on top a bean plot of the number of refactoring opportunities that were initially extracted from the original css les excluding refactoring opportunities being subsumed and or having a negative size reduction value.
on the bottom of figure we can see a bean plot of the number of presentation preserving refactorings which we actually applied on the css les.
as it can be observed our approach applied opportunities 10000md mean .
md mean .28figure initial refactoring opportunities vs. applied presentation preserving refactorings was able to detect on average refactoring opportunities in the original version of the examined css les while the average number of presentation preserving refactorings was .
additionally we found out that the examined css les had order dependencies on average between their selectors as shown in figure 18a.
md mean .
a order dependencies 40md .
mean .
b size reduction figure order dependencies and size reduction size reduction rq3 .
in figure 18b we have depicted a bean plot with the percentage of the size reduction achieved by applying only presentation preserving refactorings.
in the examined css les the average size reduction was while the maximum achieved value was .
overall in of the examined css les out of the size reduction was over while in out of the size reduction was over .
in order to determine the factors that in uence the applicability of refactorings in the examined css les we decided to build a statistical regression model.
regression models are mostly used for the purpose of prediction where the values of one or more predictor variables can be used to predict the value for the response variable .
however a multiple linear regression model can be also used to assess the impact of one predictor on the response variable while controlling the other predictors .
using regression we estimate a coe cient for each predictor which shows the magnitude and direction of the e ect of the predictor on the response variable.
we built a model with the number of applied refactorings as the response variable and size and number of order dependencies as predictors.
intuitively we expect a positive relationship between the number of applied refactorings and the size of the css les since larger les exhibit more duplication and thus o er more opportunities for refactoring.
on the other hand we expect a negative rela table statistical model s estimated parameters parameter estimate p value intercept .
2e size coe cient .149e 2e order dependencies coe cient .195e 2e the intercept is the constant term in the regression model which makes the residuals have a mean of zero.
tionship between the number of applied refactorings and the number of order dependencies detected for a given css le since a larger number of order dependencies implies a higher probability for a precondition violation and thus rejecting a candidate refactoring opportunity.
to this end we created a generalized linear model using the poisson distribution function .
as it is shown in table all estimated coe cients are statistically signi cant and as we expected the coe cient for the size of the css les is positive while the coe cient for the number of order dependencies is negative.
from this result we can conclude that for css les with a similar size the number of applicable refactorings decreases as the number of order dependencies increases.
additionally we can conclude that our approach is more e ective in terms of size reduction for large css les with a limited number of order dependencies.
.
discussion css duplication and refactoring opportunities.
our case study shows that css code duplication is prevalent in today s web systems.
the majority of the clones we found pertain to type i duplication instances and type ii and iii duplications are relatively less common.
this indicates that developers use the same representation for property values consistently throughout their style sheets.
additionally they make use of shorthand property declarations consistently within di erent selectors.
the results of our evaluation also show that our method is able to successfully detect many css refactoring opportunities that remove duplications and preserve the initial presentation of the target documents.
these refactorings when applied allow for a much cleaner css code and considerable size reduction.
size reduction.
in our method we focus on refactoring opportunities that extract the same set of equivalent declarations in a grouping selector.
an alternative approach would be to extract and group the declarations in a new class selector instead of a grouping selector.
by selecting an appropriate name for the class selector we can reduce even further the size of the css le i.e.
by replacing a set of selector names with a single class name and at the same time improve its understandability the class name could represent a common concept being extracted .
however this approach requires to make use of the new class in the dom elements of the target document.
from the refactoring point of view this approach should update the corresponding html documents for static web sites or even the source code that generates the html elements for dynamic web sites.
limitations.
in our current implementation we have only considered css les linked to the html documents.
in order to provide complete css refactoring support in the future we will also include in our analysis css styles embedded inside the style tags of the web pages as well asdynamically generated css styles through javascript.
threats to the validity.
a threat to the internal validity is that the dom states collected from each web application may be insu cient to extract all possible order dependencies between the selectors of the examined css les since for some dynamic web applications the number of dom states is practically in nite.
missing order dependencies from unvisited dom states could make some of the applied refactoring opportunities to be non presentation preserving for this particular set of unvisited dom states.
to avoid selection bias we selected subjects from the list of web sites analyzed in a related css study .
to mitigate threats to the external validity and make the results of the experiment as generalizable as possible we included additional web sites developed by leading companies in web technologies applying the current state of the art css development practices.
finally the developed tool and the collected data are all available online1to enable the replication of the experiment by other researchers.
.
related work despite the fact that css is widely used in practice it has not received much research attention.
mesbah and mirshokrae propose a technique to automatically detect unused and ine ective css code.
having a similar goal geneves et al.
use tree logics to detect unused css code.
keller and nussbaumer conclude that human written css code has a higher abstractness i.e.
higher reusability compared to generated code.
to the best of our knowledge our work is the rst to analyze css with respect to code duplication and provide refactoring opportunities.
several researchers have developed techniques for the detection of duplication in web artifacts.
most of the studies in this area have focused on the detection of duplicated content in web pages or nding web pages with similar structure .
boldyre et al.
replace the content of the web pages i.e.
the text inside di erent tags with hash values and compared them to nd duplicated content in web pages.
lanubile and mallardo propose a semi automatic approach to nd function clones in the source code of web applications.
their approach rst compares the names of the functions written in either javascript or vbscript.
if the names are the same they compute various size metrics and report the functions with similar metric values as candidate clones.
in their follow up work they evaluated this approach on four web applications and found out that the to of functions were duplicated and could be refactored .
de lucia et al.
use the levenshtein edit distance to quantify the structural similarity between di erent web pages.
rajapakse and jarzabek use ccfinder a clone detection tool which nds the clones by applying token to token comparison to nd code clones in the source code of web applications written in various languages.
they examined web applications and found out a duplication rate of to .
synytskyy et al.
use an island grammar in order to de ne smaller portions of the html syntax for elements such as forms and tables that might be cloned across di erent pages.
the grammar is used to extract those structures from web pages and examine whether their structure is repeated in other pages.
cordy et al.
propose an approach that is language independent and can detect exact and near miss clones using island grammar extraction pretty printing and textual di erencing of the clone candidates.
in their study they implemented this approach for html.
this work led to the introduction of nicad which is an exact and near miss clone detector.
later researchers used nicad to detect clones and to nd clone patterns in the php code of two industrial systems.
the extracted duplication information can be used to reengineer web applications i.e.
create dynamic pages from static ones generate more generalized dynamic web pages to minimize the duplication or nd similar functionalities across di erent web pages .
none of the aforementioned works investigated the existence of duplication in css code or developed a technique specialized on the detection of duplication in css code.
the most closely related work to this paper regarding the detection of duplication in css code is the approach proposed by mao et al.
on the automatic migration from table based structure to the style based structure for web pages.
in their work they used traditional clone detection approaches in order to nd the duplicated code across di erent css les and remove the duplications by creating a single css le which could be applied to di erent web pages.
although this kind of detection and analysis might be sufcient for nding type i duplications it cannot nd type ii and iii duplication instances as de ned in this work.
.
conclusions and future work in this work we developed a technique for the detection of refactoring opportunities that can eliminate duplicated css declarations safely i.e.
without side e ects in the styling of the web documents.
we performed an experiment on real web applications and found that code duplication is extensive in css les on average of the style declarations are repeated at least once there is a signi cant number of presentation preserving refactoring opportunities on average that is associated positively with the size of the css les and negatively with the number of order dependencies between the selectors of the css les and on average a reduction in the size of the examined css les can be achieved by applying the detected refactoring opportunities.
as future work we plan to investigate the refactoring of css code into css preprocessor code.
css preprocessors such as sass2and less3 allow the de nition of variables and functions to build reusable and parameterizable blocks of code adding essentially features of procedural programming languages.
eventually the preprocessor code is processed to generate pure css code.
the research goal is to nd repeated css styles and refactor them into functions by parameterizing possible di erences in property values.
.