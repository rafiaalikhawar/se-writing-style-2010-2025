retrofitting concurrency for android applications through refactoring yu lin university of illinois yulin2 illinois.educosmin ra of illinois cos illinois.edudanny dig oregon state university digd eecs.oregonstate.edu abstract running compute intensive or blocking i o operations in the ui event thread of smartphone apps can severely degrade responsiveness.
despite the fact that android supports writing concurrent code via asynctask we know little about how developers use asynctask to improve responsiveness.
to understand how asynctask is used underused misused in practice we rst conduct a formative study using a corpus of open source android apps comprising .34m sloc.
our study shows that even though half of the apps use asynctask there are hundreds of places where they missed opportunities to encapsulate long running operations in asynctask .
second of the usages are manually refactored.
however the refactored code contains concurrency bugs such as data races and performance bugs concurrent code still executes sequentially .
inspired by these ndings we designed developed and evaluated asynchronizer an automated refactoring tool that enables developers to extract long running operations into asynctask .asynchronizer uses a points to static analysis to determine the safety of the transformation.
our empirical evaluation shows that asynchronizer is i highly applicable ii accurate iii safer than manual refactoring iv it saves development e ort v its results have been accepted by the open source developers.
this shows that asynchronizer is useful.
.
introduction for smartphone apps responsiveness is critical.
the apps can easily be unresponsive because mobile devices have limited resources and have high latency excessive network accesses .
with the immediacy of touch based uis even small hiccups in responsiveness are more obvious and jarring than when using a mouse or keyboard.
some sluggishness might motivate the user to uninstall the app and possibly submit negative comments in the app store.
previous research shows that many android apps su er from poor responsiveness and one of the primary reapermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
copyright 20xx acm x xxxxx xx x xx xx ... .
.sons is that apps execute all workload in the ui event thread.
the ui event thread of an android app processes ui events but long running operations i.e.
cpu bound or blocking i o operations will freeze it so that it cannot respond to new user input or redraw.
android documentation warns that developers should not use long running operations in the ui event thread.
the primary way to avoid freezing the ui event thread is to resort to concurrency by extracting long running operations into a background thread.
while programmers can use java.lang.thread to fork concurrent asynchronous execution it is cumbersome to communicate with the main thread.
android framework provides a better alternative asynctask which is a high level concurrent construct.
asynctask can also interact with the ui thread by updating the ui via event handlers.
for example the event handler onpostexecute executes after the task is nished and can update the ui with the task results.
in this paper we rst present a formative study to understand how developers use asynctask .
we analyzed a corpus of popular open source android apps comprising .34m sloc produced by developers.
the formative study answers the following questions rq1 how is asynctask used?
we found that of the studied projects use asynctask in di erent places.
in of the uses developers extracted long running operations into asynctask via manual refactoring.
in the remaining cases they used asynctask from the rst version.
rq2 how is asynctask misused?
we found two kinds of misuses.
first in of the invoked asynctask the code runs sequentially instead of concurrently the code launches anasynctask and immediately blocks to wait for the task s result.
we found similar problems in our previous studies on concurrent libraries in c .
second we found that in cases code in asynctask accesses gui widgets in a way which is not thread safe.
this leads to data races on these gui widgets.
rq3 is asynctask underused?
we found that places in projects execute long running operations in ui event thread.
this also con rms the ndings of a recent study by liu et al.
that shows that of reported responsiveness bugs in an android corpus arise because developers tend to forget encapsulating long running operations inasynctask .
inspired by these ndings we designed developed and evaluated asynchronizer an automated refactoring tool that enables developers to use asynctask .
to perform the refactoring the developers only need to select the code that 1they want to run in background.
asynchronizer will automatically create an instance of asynctask as an inner class generate event handlers in asynctask and start the task.
however manually applying this refactoring is non trivial.
first a developer needs to reason about elds method arguments and return value for asynctask and the statements that can be moved into asynctask .
this requires reasoning about control and dataow.
second the developer has to deal with several special cases.
for example this orsuper are relative to the enclosing class where they are used whereas after extracting them into asynctask they are relative to the inner asynctask class.
third the developer needs to analyze the read write e ects on shared variables in order to prevent introducing data races.
to solve these challenges we decompose the refactoring into two steps code transformation and safety analysis.
the transformation part uses eclipse s refactoring engine to rewrite the code.
the safety analysis uses a static race detection approach specialized to asynctask .
we implemented it as an extension of the iterace race detector.
this paper makes the following contributions .
formative study to the best of our knowledge this paper presents the rst study on the usage misusage and underusage of asynctask in android apps.
.
algorithms we designed the analysis and transformation algorithms to address the challenges of refactoring long running operations into asynctask .
the algorithms account for inversion of control by transforming sequential code into callback based asynchronous code and reason about non interference of updates on shared variables.
.
tool we implemented the refactoring in a tool asynchronizer which integrates with the eclipse refactoring engine.
.
tool evaluation to evaluate asynchronizer s usefulness we used it to refactor places in open source android projects.
we evaluate asynchronizer from ve angles.
first since of the cases meet refactoring preconditions it means that the refactoring is highly applicable.
second in of the cases the changes applied by asynchronizer are similar with the changes applied manually by open source developers thus our transformation is accurate.
third asynchronizer changes loc in les in just a few seconds per refactoring.
fourth using asynchronizer we discovered and reported data races in apps.
replied and con rmed races.
this shows that the automated refactoring is safer than manual refactoring.
fifth we also submitted patches for refactorings in apps.
replied and accepted refactorings.
this shows thatasynchronizer is valuable.
the tool and experimental subjects are available at .
background on android programming .
android gui programming android guis are typically composed of several activities .
an activity represents a single gui screen.
for example the login screen of an email client is an activity.
an application gui transitions through a sequence of activities each of which is independent of the others.
however at any given time only one activity is active.
activities contain gui1public class mainactivity extends activityf public boolean onoptionsitemselected menuitem item f ... new button new onclicklistener f public void onclick ... f exporttospreadsheet gameids 7g 8g 9g private void exporttospreadsheet nal list gameids f ... new asynctask void void string f protected void onpreexecute string lename fg protected string params f ... for object gameid gameids f games.add dbhelper.
ndgamebyid gameid publishprogress void null g string lename ... return lename g protected void onprogressupdate void... values f progressdialog.incrementprogressby g protected void onpostexecute string lename f progressdialog.dismiss g protected void oncancelled string lename fg 30g.execute void null 31g 32g figure real world example of asynctask inkeepscore onclick main thread task.execute onpreexecute background thread os library findgamebyid access db publishprogress onprogressupdate onpostexecute loop figure where is asynctask code executing?
widgets.
similar to many other gui frameworks such as swing and swt android uses an event driven model.
events in android apps include lifecycle events e.g.
activity creation user actions e.g.
button click menu selection sensor inputs e.g.
gps orientation change etc.
developers de ne event handlers to respond to these events.
for example oncreate handler is invoked when an activity is created while onclick handler of a button is invoked when a button is clicked.
android framework uses a single thread model to process events .
when an application is launched the system creates a main thread i.e.
the ui event thread in which it will run the application.
this thread is in charge of dispatch2ing ui events to appropriate widgets or lifecycle events to activities.
the main thread puts events into a single event queue dequeues events and executes corresponding event handlers.
however if the main thread executes cpu intensive work or blocking i o calls such as network access or database queries this results in poor responsiveness.
once the main thread is blocked no events can be dispatched and processed so application will not be responsive to users actions.
to avoid unresponsiveness developers should exploit concurrency and extract long running operations into another thread.
.
asynctask in android framework to ease the use of concurrency android framework provides asynctask class.
asynctask is a high level abstraction for encapsulating concurrent work.
asynctask also provides event handlers such as onpostexecute that execute on the main thread after the task has nished.
thus the background task can communicate with the main thread via these event handlers.
we illustrate a typical usage of asynctask using a realworld app keepscore that keeps scores for games that require tallying points as one plays.
figure shows an asynctask that reads game scores from a database and exports them in a spreadsheet le.
the methods that start with on are event handlers.
figure shows the ow of this asynctask .
line sets up a listener for a button and when the button is clicked method exporttospreadsheet is called.
this method creates an asynctask line and executes it concurrently with the main thread.
method line encapsulates the work that executes in the background.
the task queries database and adds the results to a list games line .
finally the result of the background computation is returned i.e.
filename at line .
while the task is executing it can report its progress to the main thread by invoking publishprogress and implementing onprogressupdate handler.
in the example the task publishes its progress every time it nds a game line so the main thread can update a progress dialog line .
the main thread executes the onpostexecute handler after nishes.
in this example the handler updates the gui by dismissing the progress dialog line .
notice that this handler takes the result of the task as parameter filename at line .
when it manages the lifecycle of an asynctask the main thread executes onpreexecute line before the .
it also executes the oncancelled line when the task is cancelled.
the three generic types of asynctask line represent the parameter types of onprogressupdate and the return type of .
notice that there are two ways that the main thread can fetch the result of a asynctask .
one the result is available in the onpostexecute .
second the result can be explicitly requested through the getmethod on the task.
this method has blocking semantics if the result is available it will return immediately otherwise it will block the main thread until the result becomes available.
.
formative study on usage of asynctaskin this section we present our formative study to understand how developers use misuse and underuse asynctask in open source android apps.
.
experimental setup corpus of android apps.
we selected our corpus of android apps from github .
to nd android apps we lter java repositories by searching if their readme le contains android app keyword.
we also manually con rmed that these repositories are android apps.
we apply two more lters.
first because we want to contact developers we need to avoid analyzing inactive projects.
thus we only keep repositories that contain at least one commit after june .
second because we want to study the usage of asynctask in mature representative apps we ignore toy applications i.e.
apps that have less than sloc.
also we ignore all forked applications since they are similar to the original repository.
finally we use the top most popular projects as our corpus comprising .34m sloc produced by developers.
analysis.
we want to study whether developers refactor existing code into asynctask i.e.
they encapsulate existing statements into asynctask or whether they introduce asynctask on new code they write from scratch.
thus we study not the latest version of the code which contains asynctask but the rst version of the code where developers introduce this construct.
to do this we searched the commit history of our corpus through gitective api identi ed the commits that add import statements to asynctask and manually inspected the versions before and after such commits.
this helps us understand questions about correct and incorrect usage.
to understand whether the corpus contains underusage of asynctask we want to identify long running operations that execute in the ui event thread and are potentially decreasing the responsiveness of the application.
these operations are candidates to be encapsulated within asynctask .
thus we rst created a black list of long running operations that android documentation warns should be avoided in the ui.
we used eclipse s search engine to nd call sites to such operations.
using the call graph hierarchy we analyzed whether they appear directly or indirectly in event handlers but not in asynctask orthread .
to assure validity and reliability we make all the data set and the results available online .
.
results table shows the results about usage and misusage in the projects that use asynctask .
the second row shows the items we count including the number of instances of asynctask column how many event handlers of asynctask are implemented by developers columns to .
number of misuse which includes accessing gui in column and wrong usage of get column .
the third row counts these items in newly introduced asynctask i.e.
code where developers use asynctask from scratch .
the forth row counts these items in code that was manually refactored by developers to use asynctask .
the fth row sums the total usage in newly introduced and refactored asynctask .
3table asynctask usage and misuage.
usage misusageitem asynctask instances onpostexecute onpreexecute onprogressupdate oncancelled gui access wrong usage ofget newly introduced125 manually refactored106 total using the data in tab.
we answer the following three questions rq1 how is asynctask used?
out of projects use asynctask to embrace concurrency.
this shows asynctask is adopted in android apps.
out of of asynctask instances are newly introduced when developers add new features.
however there are out of asynctask refactored.
here we found two refactoring scenarios.
first in cases the sequential code was refactored directly into asynctask .
second in cases the code is refactored from regular java thread into asynctask .
this is reasonable since asynctask provides event handlers and is easier to use than thread when the background thread needs to communicate with the main thread.
lastly we notice that onpostexecute handler is the most widely implemented by developers out of .
however for the other three handlers the implementation percentage is only and .
a possible explanation is that after a task is done applications have to update ui and report the result to users.
onpostexecute handler provides an easy way to update ui without explicitly knowing when the task is nished so it is implemented in most cases.
rq2 how is asynctask misused?
we found that asynctask in manual refactoring access gui in .
however based on the android document accessing gui from outside main thread will lead to races because android ui toolkit is not thread safe.
data races can also occur on the non gui objects after developers transform sequential code to concurrent code.
figure shows a manual refactored asynctask inchatsecureandroid project.
at line onloadfinished handler eventually calls startgroupchat method in which an asynctask is executed.
this task writes to eld mrequestedchatid at line .
however this eld is read at line which can be executed concurrently with line .
thus there is a race onmrequestedchatid .
note that this data race is found by asynchronizer in our evaluation see sec.
rather than being found manually in this formative study.
also nine manually refactored asynctask s are misused because developers invoke getmethod on the task immediately after starting the task.
as we mentioned in sec.
invocation ofgetblocks the current thread until the result is available.
thus such usage blocks the main thread immediately and de es the purpose of using asynctask .1public class newchatactivity extends sherlockfragmentactivity f public void onloadfinished loader loader cursor newcursor f resolveintent if mrequestedchatid f ... 6g 7g private void resolveintent f startgroupchat path host listconns.get ... 11g private void startgroupchat ... f ... new asynctask string void string f protected string params f ... mrequestedchatid session.getid g 19g.execute room server 20g 21g figure in chatsecureandroid project developers introduce races in manual refactoring.
rq3 is asynctask underused?
we found that out of projects call long running apis in ui event handlers at places.
in these projects projects have already used asynctask .
still we found places where asynctask is underused.
the remaining projects never use asynctask .
based on our ndings for rq1 we conclude that asynctask is widely adopted and developers manually refactor their code to use asynctask in many cases.
however as rq3 shows asynctask is still underused.
rq2 shows that manual refactoring may introduce bugs.
based on the results for rq1 rq3 we conclude that there is a need for safe refactoring tools to enable developers to transform code towards asynctask presented in sec.
as well as help developers check possible races that can occur between the code running in asynctask and the code running in the main thread presented in sec.
.
.
transformations this section describes the code transformation that enables developers to move code from main thread into asynctask .
we implement the transformation in our tool asynchronizer .
we rst explain the overall work ow of the tool and then illustrate the transformations.
.
refactoring workflow and preconditions we implement asynchronizer as a plugin in the eclipse ide .
to use asynchronizer the programmer selects statements that she wants to encapsulate within asynctask and then chooses the convert to asynctask option from the refactoring menu.
the programmer can also specify the class and instance name that asynchronizer will use to generate asynctask .asynchronizer moves the selected statements into asynctask.
method.
in addition asynchronizer also infers the subsequent statements that can be moved to onpostexecute .
before applying the changes asynchronizer gives the programmer the option to preview them in a before and after pane.
then asynchronizer transforms the code in place.
after the transformation the programmer can invoke asynchronizer s safety analysis component to check data 41public class routeselectactivity extends listactivityf ... public void oncreate bundle savedinstancestate f super .oncreate savedinstancestate ... listview lv getlistview nal string qry select... nal string selectargs fmstopid datenow datenow g cursor mcsr databasehelper.readabledb .rawquery qry selectargs startmanagingcursor mcsr lv.setontouchlistener mgesturelistener if mcsr.getcount tv.settext r.string.route ing else if mcsr.getcount tv.settext r.string.stop unused lv.addfooterview tv cursoradapter adapter new cursoradapter this mcsr setlistadapter adapter 35g 37g a before1public class routeselectactivity extends listactivityf ... public void oncreate bundle savedinstancestate f super .oncreate savedinstancestate ... listview lv getlistview nal string qry select... nal string selectargs fmstopid datenow datenow g processroutes prtask new processroutes lv prtask.execute qry selectargs 11g class processroutes extends asynctask object void cursor f listview lv processroutes listview lv f this.lv lv 16g protected cursor args f string qry string args string selectargs string args cursor mcsr databasehelper.readabledb .rawquery qry selectargs startmanagingcursor mcsr return mcsr 24g protected void onpostexecute cursor mcsr f lv.setontouchlistener mgesturelistener if mcsr.getcount tv.settext r.string.route ing else if mcsr.getcount tv.settext r.string.stop unused lv.addfooterview tv cursoradapter adapter new cursoradapter routeselectactivity.
this mcsr setlistadapter adapter 35g 36g 37g b after figure relevant code from gr transit app.
programmer selects lines to in a and asynchronizer performs all the transformations.
the left hand side shows the original code whereas the right hand side shows the refactored code by asynchronizer.
races due to the transformation.
we will present the safety analysis in sec.
.
if asynchronizer found data races the programmer still needs to con rm and x them manually.
only after this the refactored code is correct.
figure a shows a code snippet from an android app gr transit that displays bus routes and schedules .
the code snippet is used to show the bus routes that pass a given bus stop.
if the programmer applies our transformation to lines to asynchronizer will transform the code to fig.
b .
in a subsequent version of gr transit the programmers have done this transformation manually.
their new code modulo syntactic di erence is the same as asynchronizer s output.
asynchronizer checks the following three preconditions before transforming and reports failed preconditions.
p1 the selected statements do not write to more than one variable which is read in the statements after the selection.
such a variable needs to be returned by but java methods can only return one single variable.
p2 the selected statements should not contain return statements.
a return statement in the original code enforces an exit point from the enclosing method.
however the same return statement extracted into an asynctask can no longer stop the execution of the original method.
p3 the selection contains only entire statements.
selecting an expression that is part of a statement is not allowedbecause it would force the asynctask to immediately invoke the blocking asynctask.get to fetch the expression this de es the whole purpose of launching an asynctask .
.
create method the rst step of the transformation is to move the selected statements into method.
this is similar toextract method refactoring in which programmer moves a piece of code into a new method.
in this step asynchronizer need to determine the arguments and the return value of .
the arguments are the local variables which are used in the selection but declared before it.
the return value is the local variable which is de ned in the selection but used after it.
in fig.
b the method takes two arguments qryand selectargs and returns mcsr.
however note that has only one varargs parameter i.e.
array of unknown length and its type is speci ed by the type argument generic of asynctask .
if all local variables are of the same type asynchronizer sets this type as the rst generic type argument for asynctask .
if the passed in local variables are of di erent types as it is the case for our example asynchronizer uses java.lang.object as the generic type argument fig.
b line and dereferences and type casts the parameters fig.
b lines and .
if has no arguments or return value it uses void as parameter type or return type and returns null.
.
create onpostexecute handler the second step is to infer which code can be put into onpostexecute handler.
because the android framework invokes the onpostexecute after the method has nished the analysis needs to determine that the statements inside these two methods follow the same controlow as in the original program.
a naive implementation is to move all the statements after the selected code into onpostexecute .
however this may break the control ow of the main thread.
a statement cannot be moved if it is not dominated by the statements in the selected code or if it is a return statement.
a statement dominates another if every path from the entry point to the latter statement passes through the former statement.
algorithm infers the set of statements to be moved to onpostexecute .
the inputs of the algorithm include the selected code that will be put into selected the list of statements syntactically after the selected code post and the return variable of rv .
the output is the set of statements which can be moved to onpostexecute moved .unmoved contains the statements which cannot be moved.
the algorithm rst selects the pre x of post in which all statements are dominated by selected and do not return lines to .
the remaining statements cannot be moved so they are put into the unmoved variable line .
the algorithm then constructs the nal result as the pre x of dominated for which all statements have no e ect on any statement in dominated lines to .
this ensures no data dependencies are broken.
unmoved is updated with any statements which are not in moved line .
finally if unmoved contains statements that use the resulting value of asynchronizer adds a call to asynctask s getmethod before the rst such use lines to .
in the example shown in fig.
a all the statements after the selected code lines to can be put into onpostexecute .
however suppose there was a statement at line that returns mcsr.
such a statement would not be moved to onpostexecute .
furthermore asynchronizer would add a call to asynctask.get before this return statement because it uses mcsr.
in the current implementation asynchronizer uses eclipse jdt s variable bindings to approximate data dependencies.
.
create class declaration in this step asynchronizer creates elds constructor and class declaration for asynctask .
fields are generated by analyzing the statements in onpostexecute .
since onpostexecute only have one parameter which is the return value of the tool converts all the other arguments needed by onpostexecute into elds of asynctask .
for example in fig.
b local variable lvis needed by onpostexecute .asynchronizer declares a eld lvin the asynctask line and adds a constructor to initialize this eld line .
after that it creates an inner class declaration using all the code elements which have been created above line .
finally it generates two statements to create task instance and call execute method and replaces the selected code by these two statements lines and .
.
special cases asynchronizer also analyzes code to properly transform several special cases algorithm inferringpoststmts selected post rv input selected the selected code post all statements after the selected code rv return variable of output moved statements put into onpostexecute dominated unmoved for all stmt inpostdo ifselected dominates stmt and not stmt contains return then dominated dominated append stmt else break end if end for unmoved post dominated moved for all stmt indominated do if not unmoved is data dependent on stmt then moved moved append stmt else break end if end for unmoved post moved ifunmoved usesrvthen invoke getmethod before the rst use of rvinunmoved end if return moved s1 andonpostexecute cannot be declared to throw checked exceptions.
thus if the selected statements throw exceptions e.g.
programmer selects fileoutputstream.write method which throws ioexception asynchronizer needs to generate try catch block to handle the exceptions.
asynchronizer rst collects the exceptions that are declared to be thrown by the selected code.
if these exceptions are caught in the original refactored method it copies the corresponding catch clauses into oronpostexecute to handle the exceptions.
otherwise it generates empty catch clause.
in our experiment all the cases that throw exceptions have corresponding catch clauses in the original code.
s2 the original code may use this orsuper pointer fig.
a line .
after moving it to an inner asynctask class our tool replaces the original pointer with outer class this or super pointer fig.
b line .
.
data race check our formative study sec.
shows that developers do introduce data races when they manually refactor sequential code into asynctask concurrent code.
these data races are either accesses to gui elements from the or possibly concurrent accesses to other shared resources.
data races are hard to nd as they only manifest themselves under certain thread schedules.
to assist developers with the refactoring we propose a static race detection approach specialized to the thread structure generated by asynctask .
we implement our approach as an extension of the iterace race detector .
iterace is a static race detector for java parallel loops that achieves low rates of false warnings by taking advantage of the extra semantic information provided by the use of highlevel concurrency constructs.
it uses the known thread safety properties of concurrent collection classes summarizes races that occur in libraries at the level of the application and specializes for the thread structure of lambda style parallel loops.
6while iterace is only capable of analyzing parallel loops its approach of taking advantage of the implicit thread structure of high level concurrency constructs is also applicable toasynctask .
we thus extend iterace to nd races that occur between and other threads.
.
data races generally a data race is a pair of accesses one of which is a write to the same memory location with no ordering constraint between the two accesses.
for asynctask a data race can occur between accesses in and accesses which may execute in parallel with the asynchronous task.
while the precise set of instructions that may execute in parallel cannot be determined statically we can nd an approximation of it.
asynchronizer relies on the andersen style static pointer analysis provided by wala .
thus our analysis works over an abstract heap built along with a k bounded context sensitive call graph.
the underlying analysis is ow insensitive except for the limited sensitivity obtained from the ssa form.
our tool makes the following approximation for a race instruction i in call graph node n races with instruction i in call graph node n if both access the same eld of the same abstract object at least one of the instructions is a write access and hn i imay happen in parallel with hn i i. .
may happen in parallel we now introduce an approximation of the happens inparallel relation induced by the asynctask .
for simplicity we present the algorithm from the perspective of analyzing the races involving one asynctask at a time.
letnbbe the abstract call graph node for the analyzed method.
let nhbe the event handler call graph node which executed nb sasynctask note that depending on the choice of abstraction there can be multiple call graph nodes representing runtime invocations of .
let nhbe the set of all the event handler call graph nodes in the current application.
for the example in fig.
nbis the invocation of the method on line and nhis the execution of onloadfinished line which led to nb.
letiebe the instruction which executes the asynctask containing nb.
for our example in fig.
ieisexecute method invocation at line .
let nebe the node executing ie.
our choice of context sensitivity ensures its uniqueness.
letg be the so called supergraph having as nodes pairs hn ii where nis an call graph node and iis an instruction in n. intra procedural i.e.
control ow graph cfg edges are lifted to the new graph.
call site instructions are linked to the entry and from the exit nodes of the lifted cfg corresponding to the call s target call graph node.
letg c9rbeg with all its call to return edges removed.
call to return edges are the intra procedural edges linking a call instruction directly to the next instruction bypassing the interprocedural paths.
figure shows the supergraph without call to return edges for the example in fig.
.
removing call to return edges does not a ect reachability but it does a ect the dominator relation used below.
call to return edges prevent instructions in a called method dominate any instruction after the call.
we say that the instruction hn i imay happen in paronloadfinished ... invoke resolveintent resolveintent startgroupchatid ... startgroupchat ... ....execute ... race!
this.mrequestchatid ...onloadfinished ... this.mrequestchatid ...onloadfinished ... return from resolveintent ... ....get forkjoinxfigure supergraph without call to return edges g c9r for the code snippet in fig.
.
the nodes are call graph node instruction pairs.
the arrows are intra and inter procedural edges.
the crossed out arrow is part of g but not g c9r.
dashed arrows denote reachable relations.
allel with instruction hn i iifhn i iis reachable from the node nb and either hn i idoes not dominate hne ieiong c9r or if n calls ne i does not dominate the call to neon the n s cfg.
e.g.
in fig.
hn i iis the node for line which is within the method.
hn i iis the node for line which does not dominate the forking node line .
thus the nodes for lines and may happen in parallel.
furthermore as the two instructions read and write the same eld mrequestchatid of the same object this they may race.
thus our tool raises a warning.
.
android model android applications are event based so exercising the code depends on events triggered by the ui sensors network etc.
in order to analyze the application statically asynchronizer uses a synthetic model of several key android classes.
figure shows the callgraph for the code snippet in fig.
.
asynchronizer creates synthetic calls between the object initializer the bytecode init method called before the constructor of an activity or widget and its events handlers.
thus mainactivity s initializer calls among others itsonoptionsselected event handler.
similarly asynchronizer puts a synthetic call between a listener s initializer node to its handlers and between the an asynctask sexecute and its .
this is an over approximation of the application s possible behavior because it may be possible that a particular event will not be triggered.
as the analysis is ow insensitive it does not matter that the handler method is invoked at the handler object initialization point not at the event trigger point.
asynchronizer use the following strategy to select entry point for the analysis if the refactored class itself is an activity it uses activity.
init as entry point if the refactored class is a gui widget class i.e.
a view it uses the object initializer of both the activities who use this widget and the widget class itself as entry point i.e.
the analysis may run multiple times .
in terms of safety our analysis is subject to the traditional limitations of static pointer analysis.
aside from the 7mainactivity.
init mainactivity.onoptionsitemselected ... onclicklistener.
init onclicklistener.onclick ... mainactivity.exporttospreadsheet ... asynctask.execute asynctask.
part of the callgraph for the code in fig.
.
dashed arrows are synthetic call graph edges.
synthetic calls described above re ection and native code are only handled up to what is provided by the underlying pointer analysis engine wala .
in some cases android apps use re ection to construct objects such as gui widgets.
our analysis does not analyze such objects.
this could be improved by looking into the con guration les used for de ning the ui .
also the analysis call graph contains a single node for each event.
considering our may happen in parallel de nition this may lead to false negatives for the cases where an event is invoked repeatedly.
regarding precision our current implementation does not consider event handling order.
this leads to some false warnings in our evaluation.
for example the oncreate handler is always handled before onstart .
thus an asynctask started inonstart could not happen in parallel with oncreate .
.
ev aluation to evaluate the usefulness of asynchronizer we answer the following evaluation questions eq1.
applicability how applicable is asynchronizer ?
eq2.
accuracy how accurate is asynchronizer when performing the code transformations?
eq3.
e ort how much programmer e ort is saved by asynchronizer ?
eq4.
safety isasynchronizer safer than manual refactorings?
eq5.
value do programmers nd refactorings applied by asynchronizer useful?
.
experimental setup we want to evaluate asynchronizer on real open source code but because we are not the original developers of the code it is hard to know on which code to apply the refactoring.
thus we use two sets of experiments.
first we let the source code itself tell us which parts need to be refactored.
to do this we run asynchronizer on projects that were manually refactored by the open source developers and compare the outcomes.
second we start from the responsiveness issues detected by other researchers and run asynchronizer on code that was not refactored yet and determine whether the refactorings are useful for the original code developers.
we use the rst experiment to answer eq1 eq4 and the second experiment to answer eq5.
replicating existing refactorings.
we select projectsfrom the projects that we used in our formative study.
each of these projects has at least two manual refactorings from sequential code to concurrent code via asynctask .
the left hand side of tab.
shows the size of each project in nonblank non comment source lines of code1.
for each project we applied asynchronizer to the code version just before the version that contained manual refactorings and we only refactored the same code as the manual refactorings did.
notice that manual refactorings occur in several versions so we checked out the version we need every time we applied asynchronizer .
we applied asynchronizer to replicate all manual refactorings in these projects.
we report several metrics for each project.
to measure the applicability we count how many code fragments met the refactoring preconditions and thus can be refactored by asynchronizer .
to measure the accuracy of code transformations we compared the code transformed by asynchronizer with manually changed code and report the number of cases that have di erences in oronpostexecute method.
notice that here we are only interested to compare the code changes described in sec.
but these changes may still contain data races we answer safety separately .
to measure the e ort that a programmer would spend to refactor the code manually we report the number of lines and les that are modi ed by the refactoring.
these numbers are a gross estimate of the programmer e ort that is saved when refactoring with asynchronizer .
although we measure e ort indirectly many changes and analysis are non trivial.
to answer the safety question we ran asynchronizer to analyze data races introduced by transformation.
notice that we bubbled up the races in libraries to application level .
we manually checked all the races and categorize them into four categories xed directly the races are xed by developers during their manual refactoring xed later the races are not xed during manual refactoring but are xed in a later version never xed the races are not xed even in the latest version false the races are false warnings.
the races that are xed directly manifested immediately after a developer rst encapsulated code into asynctask .
since in their commit the developers included both the refactoring and the race xes it implies that they are aware of the existence of these races.
for the races that are xed later we also count how many days on average it took developers to nd and x races as reported by the time span between the commit that introduces the race and the commit that xes the races.
for the races that are still not xed in the latest version we reported all of them to developers and suggested how to x them.
applying new refactorings.
the preferred way to test for responsiveness is to run performance tests.
however none of the android apps that we found had performance tests.
creating performance tests requires domain knowledge generating test inputs that are representative e.g.
relevant database entries etc.
thus to measure the value of the refactoring we select six projects that have potential responsiveness issues shown in tab.
.
these issues are detected in but they have neither been reported nor xed.
notice that these six projects are di erent from the projects in our formative study.
we manually identi ed the latent long running operations in main thread.
for example 1we use david wheeler s sloccount to get size and we only report size of java code.
8table results of applying asynchronizer to projects that have manual refactorings.
project name sloc applicability accuracy e ort safety passed failed di .
loc mod.files mod.
xed di rectly xedlaternever xedfalsetotalfix time day libreliodev android sonet socializesdk android chatsecureandroid gwindowwhatandroid irccloud android cyclestreets android owncloud android androidsettings androidcalendar myexpenses allplayers android grtransit total we search for call sites to database apis in main thread.
then we applied asynchronizer on these operations and generated patches from the refactoring.
when asynchronizer raised a race warning we checked and xed the race.
we also included the x in the refactoring patches.
we submitted these patches to developers.
in total we applied asynchronizer to places column passed failed in tab.
in these projects.
we grouped all changes and submitted six patches one patch per project .
.
results table tabulates results of applying asynchronizer to projects that have manual refactorings.
applicability columns and show the number of refactorings that pass or fail preconditions p1 p3.
among the places where we applied the refactoring satisfy the preconditions.
this shows that our refactoring is highly applicable.
of the four places that fail preconditions failed p1 failed p2 failed p3 one case failed two preconditions .
we had to manually modify the code to satisfy the preconditions.
to satisfy precondition p1 we convert the local variables into elds.
for precondition p2 we temporarily remove the return statements before refactoring and put them back to the appropriate places after refactoring.
for precondition p3 we expanded the selected expression into a full statement and then supplied it as the input to asynchronizer .
after changing the input source code to pass preconditions we applied asynchronizer to these four cases and included them along with the other metrics shown in tab.
.
accuracy column shows the number of di erences between manual and automated refactorings.
the di erences do not include other changes made by developers e.g.
adding new features .
there is only one case in libreliodevandroid project where the two outputs di er.
in this case manual refactoring moves fewer statements into onpostexecute handler but they don t a ect the semantics which means that the code behaves the same way in both cases.
e ort in total the refactoring modi ed lines of codein les see loc mod.
andfiles mod.
columns in tab.
.
on average each refactoring changes lines of code.
more important many of these changes are non trivial programmers need to infer elds method parameters and return value which statements can be moved into onpostexecute as well as deal with special cases.
in contrast when using asynchronizer the programmer only has to initiate the transformation.
asynchronizer takes less than seconds per refactoring.
1public class oauthlogin extends activityf public void oncreate bundle savedinstancestate f ... new asynctask string void string f protected string args f moauthprovider new commonshttpoauthprovider ... 7g 8g.execute ... 9g public boolean shouldoverrideurlloading webview view string url f ... new asynctask string void string f protected string args f moauthprovider.retrieveaccesstoken ... g 16g.execute ... 17g 18g figure developers of sonet project con rmed that the races on moauthprovider will not lead to bug.
safety columns to show the races that asynchronizer detected automatically and we checked manually.
notice that races are not xed immediately in the manual refactoring but are xed in a later version.
the strategies to x these races include adding synchronizations moving the statements involved in races outside of asynctask changing shared variables into local variables or removing the shared variables.
interestingly among these races races inallplayers android project are xed incorrectly the rst time developers invoke getimmediately after executing theasynctask .
they applied a second patch to x them correctly in a later version.
in the four projects that x races in a later version developers spent days in total to apply patches fix time column .
there are false warnings.
9table results of applying asynchronizer to projects that have potential responsiveness issues.
project name sloc passed failed races files mod.
connectbot fbreaderj k mail keepassdroid vudroid vlc total the reasons for the false warnings were discussed in sec.
.
.
the remaining races still exist in the latest version.
we reported all of them to developers.
they xed races in irccloud android and they con rmed races in chatsecureandroid and grtransit .
the developers of sonet do not think the races lead to bugs.
we show one simpli ed code snippet from sonet in fig.
.
in the experiment we think the two asynctask lines and can be executed concurrently so there is a race on moauthprovider lines and .
however the developers con rmed that the second task cannot run until the rst completes.
in practice developers can avoid checking such races by customizing synthetic call graphs based on their domain knowledge about which event handlers may happen in parallel.
for this example they can remove the second event handler from the call graph while checking the rst task.
our result shows columns fixed later never fixed out of races are neither detected nor xed when developers perform manual refactoring.
even when they are xed in a later version the timespan is long.
thus asynchronizer is safer than manual refactoring.
value table shows results where we used asynchronizer to refactor long running operations from main thread into asynctask .
we used a corpus of projects where in total we applied asynchronizer to places in les.
cases satis ed the preconditions.
similar to the previous experiment for the two cases that failed the preconditions we manually modi ed the code to satisfy the preconditions.
we also check the races reported by asynchronizer column .
notice that the races we show in tab.
do not include false warnings there are false warnings in total .
we created patches which include the transformations and xes for races and submitted the patches to the open source developers.
at the time when this paper is written the developers from k mail and keepassdroid have accepted ten refactorings.
the developers of vudroid and vlcdo not think the operations encapsulated into asynctask signi cantly a ect ui responsiveness.
for example vudroid developers said zoomroll class instance is a singleton for application and hence your patch will change only the rst time load delay.
i have never observed considerable time delays on activity start .
this shows the importance of having domain knowledge but also shows that our refactoring approach can produce useful results accepted by developers.
.
related work liu et al.
empirically study three performance bugpatterns in android apps one of which is running longrunning operations in main thread.
they also propose an approach to detect such operations statically.
yang et al.
test the responsiveness of android apps by adding a long delay after each heavy api call.
choi et al.
uses machine learning to learn a model for smartphone apps and generate test inputs from the model.
jensen et al.
propose a test generation approach to nd event sequences that reach a given target line in smartphone app.
concolic testing and random testing is also applied to smartphone apps.
their work focuses on testing of android apps.
however our work is a compensation of theirs developers can exploit asynctask refactoring to eliminate the performance issues that are detected in testing.
sai et al.
propose an approach to detect gui accesses from outside the main thread.
this technique can be integrated with asynchronizer to help developers avoid gui access in asynctask while performing refactoring.
some techniques are proposed to analyze event driven applications.
raychev et al.
proposed a dynamic data race detection for event driven program based on javascript.
zheng et al.
statically check concurrency bugs due to asynchronous calls for ajax applications.
less scalable model checking based techniques have also been proposed for event driven or gui applications .
there are several empirical studies on the usage of libraries software evolution and refactoring .
kavaler et al.
study how android apis are used and asked by developers.
kim et al.
investigate api level refactorings and bene ts from refactoring .
bavota et al.
study the bugs introduced by refactorings.
our previous work shows people tend to misuse concurrent apis in java and c .
in this work we study how people use concurrent apis provided by android framework.
several refactorings are proposed to improve performance by introducing concurrency or optimizing binary code while others guarantee the correctness of concurrent program .
however our refactoring retro t concurrency into android apps to improve responsiveness.
.
conclusions developers introduce concurrency into programs via concurrent constructs.
however refactoring sequential code to concurrent code is non trivial tedious and error prone.
we presented a formative study on android s asynctask .
our study shows that developers use asynctask both to implement new features and to refactor existing sequential code.
however we found that manual refactoring introduces performance bugs by misplacing the asynctask.get their concurrent code runs sequentially.
also we found data races in manually refactored code.
in some cases it took developers hundreds of days to nd and x these bugs.
we presented asynchronizer which automates refactoring sequential code to use asynctask .
the refactoring is composed of two steps a code transformation that moves user selected code into asynctask and a safety analysis that checks data races.
in our empirical evaluation we applied asynchronizer on android apps.
we found that the tool is widely applicable it is accurate compared to manual code transformations it saves programmers e ort it is safer than manual refactoring and open source developers accepted several patches with refactorings created by asynchronizer .
this shows that the asynchronizer is useful.
.