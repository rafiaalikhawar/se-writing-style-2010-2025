detecting and analyzing insecure component usage taeho kwon zhendong su university of california davis kwon su cs.ucdavis.edu abstract software is commonly built from reusable components that provide desired functionalities.
although component reuse significantly improves software productivity insecure component usage can lead to security vulnerabilities in client applications.
for example we noticed that widely used ie based browsers such as ie tab do not enable important security features that ie enables by default even though they all use the same browser components.
this insecure usage renders these ie based browsers vulnerable to the attacks blocked by ie.
to our knowledge this important security aspect of component reuse has largely been unexplored.
this paper presents the first practical framework for detecting and analyzing vulnerabilities of insecure component usage.
its goal is to enforce and support secure component reuse.
our core approach is based on differential testing and works as follows.
suppose that componentcmaintains a security policy configuration to block certain malicious behavior.
if two clients of component c say a reference and a test subject handle the malicious behavior inconsistently the test subject uses cinsecurely.
in particular we model component usage related to a policy based on accesses to the configuration state inside the component and the conditional jumps affected by the data read from the state.
we utilize this model to detect inconsistent policy evaluations which can lead to insecure component usage.
we have implemented our technique for windows applications and used it to detect and analyze insecure usage of popular software components.
our evaluation results show that insecure component usage is a general concern and frequently occurs in widely used software and our detection framework is practical and effective at detecting and analyzing insecure component usage.
in particular it detected several serious new vulnerabilities and helped perform detailed analysis of insecure component usage.
we have reported these to the affected software vendors some of whom have already acknowledged our findings and are actively addressing them.
this research was supported in part by nsf career grant no.
nsf cybertrust grant no.
nsf ccf grant no.
nsf tc grant no.
and the us air force under grant fa9550 .
the information presented here does not necessarily reflect the position or the policy of the government and no official endorsement should be inferred.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary nc usa.
copyright acm ... .
.categories and subject descriptors d. .
testing and debugging testing tools general terms reliability security keywords insecure component usage differential testing testing and analysis of real world software .
introduction component based development has been a major paradigm for engineering software.
in particular a client application can perform desired functionalities by invoking interface calls of a component.
this paradigm allows better code reuse and makes software development more productive.
for example trident a browser layout engine developed by microsoft has been used in ie and many other windows applications.
although component reuse has significant benefits it may lead to security vulnerabilities if a component is not used properly in its client software.
the following example which we first discovered through a manual examination inspired this research.
ie enables an xss filter by default .
however ie based browsers such as ie tab use the same browser components as ie but do not enable the xss filter.
this insecure component usage makes these ie based browsers vulnerable to xss attacks.
as this example shows insecure component usage can cause serious vulnerabilities in component based software.
however this problem has not been much explored.
previous work on component security has focused on designing and developing frameworks for secure component usage detection of insecure components and surveys on component security issues .
in this paper we present a differential analysis framework to detect and analyze insecure component usage in component based software.
here is the key idea behind our framework.
suppose that two applications a reference a which we assume to be correct and secure w.r.t.
component usage and a test subject b reuse components that check security policies to block malicious activities.
if a andbconfigure or evaluate the policies inconsistently bmay have unprotected runtime execution.
in the xss filter example earlier ie acts as the reference and ie tab uses urlmon.dll insecurely because it neither configures the built in security policies for xss filter nor utilizes them to block xss attacks.
to realize our framework there are two main technical challenges how to extract the configurations of security policies maintained by a component and how to detect potential insecure component usage of a client software.
extracting policy configurations.
we monitor the writes to component memory space that potentially stores security policy configu1rations.
these memory writes provide several pieces of important information instructions that configure relevant security policies locations of the buffers to store the policies and concrete configuration data.
for example urlmon.dll maintains a memory buffer in its global data region to store the url action policies.
ie configures the policies via memory writes.
to check a security policy an application retrieves its configuration data from the relevant memory buffer and uses the data for comparison.
in this case if a reference and a test subject configure the same security policy in an inconsistent manner the comparison results are different making them take different execution paths.
based on this idea we define missing and incorrect configurations that can lead to insecure component usage.
amissing configuration corresponds to the case where the reference only configures and checks a particular set of security policies.
thus the test subject is vulnerable to attacks that can be blocked by these policies.
the earlier xss filter example belongs to this category.
an incorrect configuration corresponds to the case where both the reference and the test subject configure and check a particular set of security policies but their different configuration data cause inconsistent subsequent execution paths.
for example while ie enables feature http username password disable ie tab does not.
the configuration of this security policy is checked by both ie and ie tab at runtime but the inconsistent configuration data lead them to behave differently.
specifically ie tab allows user names and passwords in a url address leading to potential attack vectors for phishing .
we provide a detailed analysis of this issue in section .
detecting inconsistent policy configurations.
as we discussed earlier the inconsistent configuration of a security policy leads to inconsistent subsequent execution patterns.
for detection we capture control flows triggered by the configuration data from the reference and the test subject at runtime and compare them.
to capture control flow information we determine conditional branches whose evaluations are potentially affected by the configuration data via static binary analysis and capture information regarding whether or not each conditional branch has been taken at runtime.
from these observations we design our differential analysis framework as a three phase analysis p1 detecting potential policy evaluation p2 extracting policy related execution and p3 detecting inconsistent policy configurations.
p1 detecting potential policy evaluation.
this phase detects information related to policy evaluation from dynamic execution of the reference and static properties of a target component.
to this end we detect instructions that read data from component memory space at runtime.
afterward we perform static forward data slicing to detect conditional jumps that can be affected by the data.
if such conditional jumps exist the data can control the subsequent execution paths at runtime.
thus the detected instructions potentially read the configuration data and evaluate relevant security policies.
we use this information to perform subsequent analyses scalably.
p2 extracting security policy related execution.
this phase extracts software execution related to the policy configuration and evaluation performed by the reference and the test subject.
to capture the policy configuration we detect memory writes to component memory space at runtime.
regarding policy evaluation we log the memory reads and the comparison results on the conditional jumps detected in the previous phase.
p3 detecting inconsistent policy configurations.
this phase analyzes inconsistent policy controlled executions between the reference and the test subject to detect missing and incorrect configurations.
in particular we determine whether the conditional jumps relevant to a particular security policy are evaluated consistently.
for evaluation we implemented our framework for windows reading configuration data configuring security policy evaluating security policy configuration state matched unmatched data operand figure security policy configuration and evaluation.
applications and applied it to detect inconsistent policy configurations in reusing popular software components.
our results show that inconsistent policy configurations happen frequently and lead to security vulnerabilities.
in particular we detected several insecure usages of the browser components that disable default protection mechanisms of ie .
our framework can also precisely locate root causes of the detected insecure usages which can help developers fix any detected vulnerabilities and securely reuse software components.
the results also show that our framework is scalable.
it took less than minutes total to detect inconsistent policy configurations in reusing urlmon.dll across all six analyzed browsers.
this paper makes the following main contributions we introduce and formalize insecure component usage in terms of inconsistent policy configurations and evaluations.
we develop the first practical framework based on differential analysis to detect inconsistent policy configurations.
our framework works directly on software binaries.
we implement our framework as a practical tool and evaluate its effectiveness by detecting and analyzing insecure usage of widely used components in real world software.
.
detection framework .
background and definitions security policy related execution.
a security policy configuration serves as a key part of software protection because it determines whether or not certain malicious behavior is to be blocked e.g.
ie xss filter .
figure depicts the runtime process of configuring and evaluating security policies software maintains its global state and updates the global state to configure a security policy and when evaluating the policy the software reads data from the global state and checks whether or not the data match a specified operand.
based on the above description we formally define security policy related execution.
definition .
c onfiguration state .aconfiguration state denoted by m is an associative array whose key and value pair hki viicorresponds to a configured security policy identifier and its configuration data respectively.
we define the configuration and evaluation of a security policy in terms of accesses to a configuration state m. 2definition .
s ecurity policy configuration .for a given configuration state m a security policy configuration functionconf updatesmbased on a new policy configuration hk vi wherekandvcorrespond to a policy identifier and its configuration data respectively conf m k v m0such that m0 k0 v ifk0 k m k0 otherwise definition .
s ecurity policy evaluation .given a configuration state m a security policy evaluation function eval takesk a policy identifier and p a given operand eval m k p matched ifm p unmatched otherwise we next define security policy related execution.
definition .
s ecurity policy related execution .
a security policy related execution for software sunder workload w denoted by s w is a sequence of policy configurations or evaluations s w hs1 s miwheresi conf m k v a policy configuration or si eval m k p a policy evaluation .
note that in definition .
the configuration state mchanges at runtime because sdynamically configures new security policies during its execution over the workload w. also note that s w provides precise information on policy evaluations during s s execution overw.
we now define security policy evaluation patterns.
definition .
s ecurity policy evaluation pattern .
for a given s w the security policy evaluation pattern denoted by epat s w is the sub sequence epat s w extracted from the policy evaluations from s w whereki pi and eval ki pi correspond to a policy identifier an operand for its policy evaluation and the evaluation result matched orunmatched respectively.
insecure component usage.
for a reference rand a test subjectt we define two types of inconsistent policy configurations missing andincorrect configurations.
definition .
m issing configuration .the test subjecttmisses the configuration of a policy kevaluated by the referencerif9p s hk p si2 epat r w and8p s hk p si62 epat t w .
definition .
i ncorrect configuration .the test subjecttincorrectly configures a policy kif9p r r2 hk p r 1i2 epat r w hk p r 2i2epat t w .
inconsistent policy configurations can lead to unprotected software execution we define it as follows.
definition .
u nprotected software execution .
suppose that a security policy kblocks a malicious behavior at runtime.
given a reference r a test subject t and a common workloadw tis unprotected w.r.t.kifrblocks buttdoes not.
suppose that a component cmaintains its configuration state mat runtime.
if a client using cconfigures a policy stored by m insecurely it can be unprotected w.r.t.
the policy.
we next define insecure component usage.
definition .
i nsecure component usage .suppose that a component cmaintains a security policy kthat blocks a malicious behavior at runtime.
for a reference rand a test subject t that usec tinsecurely uses cw.r.t.kiftis unprotected w.r.t.
k. .
overview to detect inconsistent policy configurations formalized in definitions .
and .
it is necessary to analyze how security policies are set and enforced in code.
however it is challenging because most components are distributed as binaries and it is difficult to know which memory locations are used for security policy configuration and evaluation.
to address this issue at the high level we design our framework as two phases runtime extraction andoffline detection.
in the runtime extraction phase we instrument executions of a reference and a test subject to capture security policy related executions definition .
.
we perform an offline analysis to detect insecure component usage in the captured executions.
although the high level approach appears straightforward the main challenge is how to perform scalable and precise analysis.
for example ie performs millions of memory accesses at runtime and it is practically infeasible to instrument and analyze all of them.
to address this scalability issue our framework uses the following optimizations instrumenting target component execution filtering irrelevant memory accesses and performing preliminary analysis on policy evaluation.
instrumenting target component execution.
instrumenting all instructions executed by an application at runtime suffers from poor scalability.
to mitigate this issue our framework only instruments components of interest at runtime because the configuration state maintained by the components is generally accessed by their code.
suppose that the configuration state mis maintained by a componenta.
when other components access m they generally invoke relevant interface calls of athat accessm.
it is possible that other components can directly access m but this cannot be used in component based software development because the location of mcannot be reliably resolved.
for example the base addresses of the components loaded at runtime often change making locations of their global data regions inconsistent.
filtering irrelevant memory accesses.
as we discussed capturing all accesses to arbitrary memory space is not feasible.
to mitigate this issue we filter the memory accesses that are unlikely to be relevant to security policy related executions.
ourkey insight is that the code executed by any thread can access the configuration state maintained by a component at runtime.
suppose that two different threads configure and evaluate a particular security policy.
in this case both threads should access the same memory location.
otherwise integrity issues on the configuration data would arise.
based on this observation we filter the logging of accesses to thread specific memory space such as the stack.
performing preliminary analysis on policy evaluation.
according to figure policy evaluations are conducted by reading data from the configuration state and determining whether or not the data is matched with a specified operand.
in order to detect inconsistent policy configurations it is necessary to capture the results of policy evaluations at runtime.
however it again suffers from scalability problems because the policies are generally evaluated by conditional jumps such as jne which are executed frequently to determine program flow at runtime.
thus instrumenting all conditional jumps is infeasible in practice.
to address this problem we perform a preliminary analysis to detect those conditional jumps affected by data reads from the configuration state.
our observation is that the evaluation of the conditional jumps are affected by the data reads from the configuration state see figure .
we detect these conditional jumps via dynamic and static binary analyses.
specifically we dynamically capture the memory reads from the configuration state under a given workload.
then we extract the conditional jumps potentially affected by them via static binary analysis.
we use information on the memory reads 3target components reference preliminary analysis on policy evaluation extraction of interface entries extraction of security policy related execution instrumentation point ip analysis runtime trace extraction detection of insecure policy configuration offline detection trace sets ip info ip info reference test subject figure detection framework.
and the conditional jumps to reduce logging of policy evaluations in the subsequent phase.
based on these optimizations we present our framework in figure .
the following sections illustrate details of each phase in our framework using a running example.
in particular we detect insecure component usage to allow potentially malicious url addresses in ie based browsers.
in the example we use wininet.dll as a target component and access as the workload for detection.
.
instrumentation point analysis preliminary analysis on policy evaluation.
as discussed instrumenting all memory reads and conditional jumps is not feasible.
to address this problem we detect them in advance and instrument their executions in the subsequent analysis.
our key observation is that there exists data flow between the memory reads and the conditional jumps.
according to figure the policy evaluation is affected by the configuration data read.
based on this we locate the instructions relevant to the policy evaluation via dynamic and static program analyses.
in particular we dynamically instrument the execution of target components to detect reading data from the configuration state and perform static forward data slicing w.r.t.
the detected memory reads to locate relevant jumps.
note that we assume heap or global data regions may contain the configuration state because they are not thread specific section .
.
figure a shows an example of policy controlled execution bywininet.dll during the workload.
in particular i1reads the configuration data globalprocessdisableuserpswdforhttp stored in the global data region of wininet.dll and determines whether or not the data is equal to zero.
the evaluation result affects the invocation of the geturladdress function at i5by deciding one of its parameters i.e.
the value of eax.
to detect the instructions relevant to policy evaluation we capture the instructions to read data from the global data region in wininet.dll during the workload via dynamic binary instrumentation i.e.
i1 .
then we extract the static forward slice w.r.t.
the data read by i1.
in this case the slice contains i1andi2 because thecmpinstruction at i1setszfaccording to the comparison result andjztakes zfto determine the next instruction to execute.
once the slices w.r.t.
the detected memory reads are extracted we analyze them to locate the instructions relevant to the policy evaluation.
in particular suppose that sis a forward data slice w.r.t.
a memory read instruction i. in this case we consider i relevant to the policy evaluation only if scontains conditional jumps.
this is because policy evaluations are generally performed by both memory reads and relevant conditional jumps see figures and a .
based on this idea we determine the memory reads and the conditional jumps in its forward slice as the instrumentation points in the subsequent analysis.
note that we only perform this preliminary analysis for the reference software.
this is because our framework does not detectsecurity policies configured only in the test subject definitions .
and .
.
to detect them we swap the test subject with the reference and repeat the analysis.
extracting interface entries.
as we have discussed when a componentamaintains the configuration state m other components generally access mby invoking interface calls exported by a. thus information on the invoked interface calls provides us with detailed insight on insecure component usage.
to capture the information our framework dynamically instruments the entry points of the interface calls exported by the target components.
to this end it is necessary to determine the interface entries as the instrumentation points.
however it is difficult to locate them at runtime because the instructions at the entries are also frequently executed by non entry code at runtime.
for example while the push instruction is often executed at the entry point as part of a function prologue it is also used for parameter passing.
to address this problem we perform static binary analysis to extract the interface call entries and pass them into the subsequent analysis as the instrumentation points.
our key observation is that the addresses of the interface call entries are generally stored in data tables that can be read from outside of the component.
because components are developed as positionindependent code they generally support memory chunks that can be accessed by other components to resolve the virtual addresses of desired interface calls at runtime.
for example the pe and elf formats have export table and procedure linkage table to provide dynamic linking respectively.
we statically analyze data reference to the entries of all functions in the target components.
we consider the function entries that have such data