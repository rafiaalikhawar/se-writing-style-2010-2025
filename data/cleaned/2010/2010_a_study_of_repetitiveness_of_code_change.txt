a study of repetitiveness of code changes in software evolution hoan anh nguyen anh tuan nguyen tung thanh nguyen tien n. nguyen and hridesh rajan iowa state university email hoan anhnt tung tien hridesh iastate.edu abstract in this paper we present a study of repetitiveness of code changes in software evolution.
repetitiveness is defined as the ratio of repeated changes over total changes.
focusing on fine grained code changes we model a change as a pair of old and new ast sub trees within a method.
a change is considered repeated within or cross project if it matches another change having occurred in the history of the project or another project respectively.
we report the following important findings.
first repetitiveness of changes could be as high as at small sizes and decreases exponentially as size increases.
second repetitiveness is higher and more stable in cross project setting than in within project one.
third fixing changes repeat similarly to general changes.
importantly learning code changes and recommending them in software evolution is beneficial with accuracy for top recommendation of over and top of nearly .
repeated fixing changes could also be useful for automatic program repair.
i. i ntroduction in a project software artifacts are written and maintained by human beings.
to err is human thus software is also defect prone.
developers could repeat their own mistakes or unknowingly repeat the errors from others.
a reason for that is the nature of software reuse and its practice by software engineers to save development effort.
common programming tasks expressed in programming languages may lead to similarity in source code.
software reuse could be at different levels of abstraction.
multiple software projects could share common specifications designs or algorithms.
they may reuse the same libraries and frameworks resulting in api usage patterns or common programming idioms in source code.
such similar code may lead to the similar software changes andrepeated defects and fixes within or across different projects.
several approaches in mining software repositories msr have taken that observation and advanced its applications in automating several software evolution and maintenance tasks.
an example application is automatic program repairing based on previously seen fixing patterns in the same or different projects.
par is an automatic pattern based program repair method that learns common patterns from prior human written patches.
fixwizard recommends fixes based on the code peers clones and code with similar api usages.
weimer et al.
proposed genprog a patch generation method that is based on genetic programming.
other types of application are automated library update language library migration etc.
semdiff is a method to learn from previous updating changes to a framework in order to update its client code.
libsync learns adaptation change patterns fromclient code to update a given program to use the new library version.
zhong et al.
mine common code transformation to support language migration.
while those approaches have gained much success in msr they focus on respective application domains and are often studied on small scale settings with small sets of subject projects.
there is still no large scale systematic study on how repetitive software changes are across the histories of software projects what are the repetitiveness characteristics of software changes or whether fixing changes exhibit different repetitiveness than general ones.
to address them we conducted a largescale study with the following key research questions r1 how code changes repeat in software evolution and r2 how useful those repeated and previously seen changes fixes within or across different projects are.
the answers for those questions not only provide the empirical evidences but also could enhance those aforementioned msr approaches.
for example a genetic programming based automatic program repair could avoid unnecessary mutations by considering the information on the popular types and sizes of program elements that have been used in fixes for certain program contexts thus reducing their search space for possible fixes.
language migration or library update methods could benefit in similar manners when the repetitive characteristics of changes are studied.
in our study we collected a large scale data set consisting of java projects with .
billion lines of code locs at the latest revisions .
million code change revisions .
million fixing ones .
million changed files and .
billion changed locs.
we extracted consecutive revisions and compared their abstract syntax trees asts .
a change is modeled as a pair of subtrees in the asts.
a change s t is considered as matching another change s t ifsands andtandt structurally match with the abstracting on the literal and local variables nodes.
the size of a change s t is measured as the height of the sub tree sin the source ast.
its type is defined as the ast node type of s. we perform the analysis in two settings within and cross project.
in the within project setting a change in a project is considered as repeated if it matches another change previously occurred in the project s history.
in the cross project setting it is considered as repeated if it matches another change occurring in another project.
repetitiveness is computed via the number of repeated changes over the total number of changes.
we studied repetitiveness of changes in three dimensions size type and general fixing changes.
the key findings in our study include the following repetitiveness is very high for changes of small sizes up to for the changes of sizes and however it decreases exponentially as size increases.
repetitiveness for changes with sizes larger than is very small.
thus the above automatic tools should consider change fragments with the sizes from changes of size are on literals identifiers modifiers etc .
repetitiveness also varies by syntactic types of changes.
changes involving simple structures e.g.
array accesses method calls are highly repetitive while those with compound structure e.g.
control loop statements are less.
in addition most popular types of fixing changes include method calls infix expressions condition e.g.
if and loop statements e.g.
for enhance for .
thus program repair tools could focus on those types with small sizes in their search space and then combine them.
cross project repetitiveness is generally higher and more stable than within project one.
in addition while crossproject repetitiveness of fixing changes is as high as that of general changes and even higher in small change sizes within project repetitiveness of fixing changes is low.
this implies that program repair tools should not rely solely on the changes in a single project but rather make use of repeated bug fixes across different projects.
to learn the recommending capability of repetitive changes fixes we conducted an experiment in which we wrote a simple tool to recommend different options of changes fixes for a given code fragment based on the collected repetitive changes fixes.
we found that accuracy for top fixing recommendation is over top is nearly .
the corresponding numbers for general changes are and .
this result shows a promising future for more sophisticated learning approaches to the aforementioned software maintenance problems.
sections ii iv present our data collection and experimental procedures.
sections v vii present the results and our analysis.
section viii is the related work.
conclusions appear last.
ii.
c oncepts a. illustration example let us start with an illustration example on code change and repetitiveness.
figure shows two changes on two ifstatements.
they are considered as fine grained changes because they occur within individual methods.
both of them include a replacement of a literal or by a variable bory and an addition of an elsebranch.
the variables and literals in the pairs aand x band y and have the same roles.
that is if we replace a b and with x y and respectively we can derive the second change from the first.
therefore we consider the second change repeat the first or vice versa .
in this paper we aim to study the characteristics of such repeated changes for example how often they occur how large they are what are the popular types etc.
in the next section we will formally define the concepts such as code changes and repeated code changes.source fragment target fragment change 1if a b a a if a b a a b else break change 2if x y x x if x y x x y else break fig.
.
an example of code change b. code and code change representation as writing and modifying code developers would think of code in terms of programming constructs such as functions statements or expressions rather than lines of code or sequences of lexical tokens.
for example in the above illustration example one would think about the code before change as an if statement and modify it by replacing an operand in aninfix expression by another and adding an else branch .
to address this phenomenon in this study we model source code and code change in terms of program constructs rather than the lower levels of representation such as code tokens or lines of code.
in a program language a programming construct is often defined as a syntactic unit and represented as a subtree in an abstract syntax tree ast .
for example an ifstatement is represented as an ast s subtree in which the root node specifies its type i.e.
ifstatement and the children nodes represent its sub constructs i.e.
an expression for the predicate and two code blocks for two branches.
definition code fragment a code fragment in a source file is a syntactically correct programming construct and is represented as a subtree in the abstract syntax tree of the file.
we consider a code change as a replacement of a code fragment by a different code fragment.
since a code fragment is modeled via an ast we formulate code change as follows definition code change a code change is represented as a pair of asts s t wheresandtare not label isomorphic.
since ast are labeled trees the condition of not being label isomorphic is needed to specify that the code fragments before and after change are different.
in this definition sor tis called source ortarget tree respectively.
either of them but not both could be a null tree.
sortis a null tree when the change is an addition or deletion of code respectively.
to check two code changes for repetitiveness we could match their source and target trees correspondingly.
however as seen in the illustration example repeated changes might have different variable names or literal values.
therefore we need to perform normalization to remove those differences before matching.
an ast tree tis normalized by re labeling the nodes for local variables and literals.
for a node for a local variable its new label is the node type i.e.
id concatenating with the name for that variable via alpha renaming.
for a node for a literal its new label is the node type i.e.
lit concatenating with its data type.
figure shows the ast trees for the code changes in the illustration example after normalization.
as seen nodes forif infix asgn id v1 id v2 id v1 infix id v1 lit numif infix asgn id v1 id v2 id v1 infix id v1break id v2if if statement infix infix expression asgn assignment id identifier lit literal num number break break statemente e 2e a a e l n fig.
.
tree based representation of code changes variables aand xare re labeled as id v1 while the ones for b and yhave the label of id v2 since v1and v2are the respective names for them after alpha renaming.
the nodes for literals and have the same label lit num .
thus after normalization two changes have the same tree based representation.
using normalization we define repeated code changes as follows definition repeat code change a code change s t is a repeated change of another one s t whens ands and t andtare label isomorphic after normalization.
we want to study the repetitiveness of changes in a project in both scenarios within its history and across the histories of different projects.
therefore we define definition a change in a project pis a repeated change within a project if it is a repeated change of another one occurring in an earlier revision of p. it is a cross project repeated change if it is a repeated change of another in other project s .
since we want to study the repetitiveness of code changes on types and sizes we need to define them.
we use the ast type of the source tree as the type of the code changes since we want to learn what types of code fragments that are frequently changed.
for size in literature size of a tree is often defined as its number of nodes.
however for source code the number of nodes of asts highly vary.
for example a method call might have no children e.g.
no parameter or many children e.g.
many parameters .
in our experiment some trees might have thousands of nodes .
in contrast tree height i.e.
the number of nodes along the longest path from the root node to a leaf node varies less often from to .
thus we choose tree height as a measurement of change size.
we define type and size as the following.
definition change type and size type and size of a code change s t are ast type and the height of s or oft ifsis a null tree respectively .
for example in the illustration example two code changes have type of if i.e.
changes to ifstatements .
their size is .
iii.
r esearch questions and methodology a. research questions in this study we are interested in studying the popularity and potential usefulness of repeated code changes and fixes.
therefore the first research question we want to answer is r1.
how repetitive code changes and bug fixes are in software evolution?table i collected projects and changes projects total source files millions total locs .
billions total revisions .
millions revisions having code changes .
millions revisions having fixing changes .
millions total changed files .
millions total locs of changed files .
billions total changed methods .
millions total ast nodes of changed methods .
billions total changed ast nodes millions total detected changes millions we are interested in repeated code changes in different dimensions.
first we want to know how large they are i.e.
size of change and what kind of program constructs that they often occur on i.e.
type of change .
such information will help designers of development tools use repeated changes to focus more on the sizes and types of changes that most likely repeat.
in addition whether changes repeat in within and crossproject settings is also important.
if they repeat frequently in the within project setting then historical changes fixes of a project will be a useful source for predict and recommend future changes fixes of that project.
if they repeat frequently in the cross project setting then we can learn changes fixes from other projects to use for a project especially when it is newly developed.
lastly we want to study whether the respectiveness of fixing changes an important type of changes is different from that of general changes.
r2.
how useful repeated and previously seen changes and bug fixes are?
we are interested in the potential use of repeated changes and fixes to recommend changes and fixes for a project in its development maintenance and evolution.
we expect that if repeated changes and fixes are popular a tool could learn from frequently repeated changes and fixes for recommendation.
b. data collection to answer those questions we have collected a large dataset of code changes.
first we downloaded from sourceforge.net a hosting service for open source projects the development history of all projects written in java and using svn forversion control.
we focused on only java and svn to reduce engineering effort and simplify the classification of change types e.g.
we do not have to define common ast representation for different languages .
future research could include other languages and version control systems.
we filtered out the projects with very short development histories i.e.
projects with less than revisions are discarded.
table i summaries our final dataset.
it contains projects which at their last snapshots have in total millions of source files and .
billion non blank non commented lines of code.
the projects cover variety of domains and topics and have been written by thousands of developers.
we downloaded their repositories to our server for faster processing.
in term of changes the projects in our dataset have in total .
million revisions among them .
million revisions having code changes and .
millions having fixing changes.
to detect fixing changes we used the popular key word based approaches in which if the commit log message of a revision has the keywords indicating fixing activities the code changes in that revision are considered as fixing changes.
we processed all .
million revisions and parsed in total .
million changed source files with the total size of .
billion lines of code.
our change detection algorithm detected .
million changed methods with the total size of .
billion ast nodes.
from those methods it detected million finegrained code changes made from million changed ast nodes.
the processing time was hours.
c. methodology overview in this section we describe our process to collect code changes fixes from the corpus to build our change database search for repeated changes fixes and compute their repetitiveness.
this process composes of three steps and is applied to each revision of every project in the corpus.
detecting all code changes for each revision.
since we focus on the fine grained changes we collect only changes within the bodies of changed methods.
updating detected changes to our database.
the database is globally accessed for all projects to improve the performance in the study of cross project repeated changes.
computing the repetitiveness for all changes in both within and cross project settings for different dimensions size type and fix non fixing.
let us explain in detail these steps in the next sections.
d. detecting code changes coarse grained differencing the purpose of this step is to map methods before and after a commit.
we use our origin analysis tool oat for this step.
for each revision given as set of changed files provided by the version control system oat identifies the mapping for each class method before and after the change.
we extend oat to support also mapping of classes instance static initializers and treat them similarly as methods.
the un mapped methods and initializers are discarded.
all mapped ones are used for fine grained differencing in the next step.
fine grained differencing to derive those fine grained changes within the body of each changed method we use our prior ast differencing algorithm .
given a pair of methods before and after the change the algorithm parses them into asts and finds the mapping between all the nodes between two trees.
the key idea of this algorithm is that it maps two nodes based on their node types and the structural similarity between the two sub trees rooted at them.
the unmapped nodes are considered as deleted in the old tree or added in the new tree.
along with the mapping the algorithm also provides the information if the mapped nodes have change in their labels or in their descendants.
for example in figure the algorithm detects that the literal node lis deleted under the infix expression node e2 and the identifier node nis added under e .
the node e2 in turn is mapped with e 2with the same label and has change in its children nodes.
similarly the top ifstatements and the assignments aare mapped with changes in descendent nodes.
it can also identify that e1 s operator is modified and a break statement is added as the elsebranch of the ifstatement.
collecting code changes for each pair of trees t andt of a changed method we aim to collect all changes with different heights sizes .
our tool traverses them in preorder from the roots to get the changes.
if a node nintis mapped to a node n int and they change in either labels or children nodes a code change represented by a pair of trees t n t n is extracted where t n andt n are the trees rooted at nandn respectively.
if a node nintdoes not have any mapped nodes in t a change of t n null is extracted.
similarly if a node n int is un mapped a change of null t n is extracted.
note that if a tree is deleted or added all of its sub trees will also be collected into the change database because the changes of the sub trees constitute to the changes of that root tree.
during collecting the changes the parent child relation between trees are also recorded.
this information will be used in recommending changes.
figure shows all collected changes with different heights sizes from for the illustration example in figure .
the change of height is shown in figure .
note that one change of small size can be included in a larger one.
we analyze change repetitiveness when the code fragment size increases.
e. building change database and computing repetitiveness design strategies we design our data structure and algorithm with the key idea that a change and its repeated one have the same type and size and the same pair of source and target asts after normalization.
if we create a hashcode for each change by concatenating the hashcodes of its normalized source and target trees repeated changes will have the same hashcode.
thus if the changes are grouped based on hashcodes computed via that scheme repeated changes will be hashed to the same group which have the same size and type.
we used those groups to compute the number of repeated changes by size and by type.
based on that idea we extracted the changes in our dataset into a change database.
this database is a dictionary of changelit num id v1 breakinfix id v1 id v2e infix id v1 id v2e infix id v1 lit nume linfix id v1 id v2e nasgn id v1 infix id v1e 2a asgn id v1 infix id v1 id v2a e n lit numlnull nullnull height height height fig.
.
extracted code changes for different heights for the example in figure 1function builddatabase projectlist l changedatabase d foreach projectpinl foreach revision rin revisionlist p foreach changec changelist r h hashcode c ifdnot contain h d new changegroup c d .count 9end 11function compute changedatabase d foreach groupcind 13h hashcode c s size c foreach projectpind .count n d .count nw d .count if d .count.size nc d .count foreach projectpand size s 20rw nw n 21rc nc n 22end fig.
.
algorithm for extracting and computing repetitiveness groups indexed by hashcodes computed by aforementioned method.
each change group contains a hash table to map a project s id to the number of changes having the same hashcode in that project.
this hash table is used to compute the within and cross project repetitiveness.
that is if a project phas a count np thenpwill have np 1changes repeated withinp.
if the hash table has another project then all np changes of pare counted toward cross project repetitiveness.
detailed algorithm figure lists the algorithm for building the change database function builddatabase lines and computing the repetitiveness function compute lines .
to build the change database the algorithm processes each change cin each project p. first it computes the hashcode forc line .
if the database does not have a change group for that hash code a new change group is created for it lines .
then the count value for pis updated line .
function compute line computes repetitiveness in size.
n is the total number of changes of size sin project p. nw and nc are the numbers of changes repeated within and across projects respectively.
they are updated using the above idea lines .
after they are computed within and cross project repetitiveness for pat sizes rw and rc are computed as the ratios of nw and nc over n respectively.
computation for type is similar not shown .iv.
a nalysis results a. boxplot representation of change and fix repetitiveness figure shows repetitiveness results of general and fixing changes in both within and cross project settings.
for each change size sfrom we computed the repetitiveness r s for all corresponding changes of every project.
thus for each sizes we have a distribution of projects as data points.
this distribution is plotted as a box plot with five quartiles the lower whisker the lower edge of the box the middle line the upper edge of the box and the upper whisker .
there are box plots for sizes.
let us explain the leftmost boxplot in figure for the within project repetitiveness of general changes of size .
the quartile i.e.
median is at .
since the median could be seen as the center of the distribution one could say that on average the projects in our dataset have of their size changes repeated within individual project.
the quartile is at implying that more than of the projects have at least those changes repeated within a project.
the quartile is at meaning that at least of projects have those changes repeated more than .
the quartile is suggesting that at least of total projects have of their size changes repeated within a project.
the inter quartile difference between and lines is referring to the spread of the distribution.
b. exponential relationship of repetitiveness and size comparing the box plots for different change sizes in both within and cross project settings we see that repetitiveness is very high for small changes but it significantly decreases when the change size increases as expected.
for example in the cross project setting size changes have median repetitiveness of more than but that for size changes drops below .
the repetitiveness of larger changes size of is very small less than on average .
we modeled r s andswith several classes of simple curves and found that the exponential curve r s e s represents their relationship the best.
we used the least square method to compute two parameters and for every project.
.
.
.
.
.
.0within project changes .
.
.
.
.
.0cross project changes .
.
.
.
.
.0within project bug fixes .
.
.
.
.
.0cross project bug fixes fig.
.
repetitiveness of code changes and fixes over change size for all projects in the corpus table ii r2of fitted exponential curve to repetitiveness setting change median .
within project general .
fixing .
cross project general .
fixing .
the goodness of fit is measured by the coefficient of determinationr2.
the closer r2is to the better the fit is.
table ii summarizes the goodness of fit.
as seen it is very high.
for example for general changes in the withinproject setting median r2is .
and of projects have r2of at least .
.
results in the cross project setting are similar.
the median r2is .
and of projects have r2 of at least .
.
this high level of fit for most of projects in the dataset implies that r s has a strong exponential relationship to s. that is repetitiveness of code changes decreases exponentially when change size increases .
as an implication the automatic program repair or library update tools should focus on the change fragments with the syntactic units of the height from to reduce the search spaces of solutions size changes are on literals variables .
c. within and cross project repetitiveness comparison as seen in figure the box plots for the sizes from in the cross project setting are higher than those in the withinproject setting.
for example for size changes the mediancross project repetitiveness is while the within project one is .
for size changes the corresponding numbers are and .
to statistically verify this observation we use the paired wilcoxon test to compare the distributions of r s in the within project and cross project settings.
all the tests for sizes from to infer that cross project repetitiveness is statistically higher than within project repetitiveness .
for large sizes changes repeat about the same or slightly less frequently in the cross project setting.
for all sizes the inter quartiles of box plots in the crossproject setting is always shorter than those in the withinproject one.
for example the inter quartile for cross project repetitiveness with size changes is while that in the within project setting is .
however at the size the difference is insignificant with the corresponding numbers of .
and .
.
nevertheless that result implies that repetitiveness in cross project setting is more stable .
thus repeated changes are more likely to be found across projects.
d. repetitiveness of bug fixes as seen in figures and table ii repetitiveness of fixing changes is similarly to that of general changes.
that is at smaller sizes sfrom to bug fixes repeat frequently with repetitiveness usually higher than in the cross project setting.
at larger sizes sfrom fixing changes repeat less frequently with repetitiveness often less than .
thus the automatic program repair methods should focus on the change fragments with the small sizes from .
importantly we conducted a paired wilcoxon test and foundthat at smaller sizes from to cross project repetitiveness of fixing changes is statistically higher than that in the within project setting .
as an example the median of cross project repetitiveness for size fixing changes is in comparison with in the within project setting.
the corresponding numbers for size fixing changes are and .
as seen within project repetitiveness of fixing changes is low.
those results suggest that automatic patching and program repairing tools should not rely solely on the changes in an individual project but rather make use of repeated bug fixes across different projects .
in figure repetitiveness for cross project changes is comparable to that for cross project bug fixes.
however our paired wilcoxon test results showed that at the small sizes repetitiveness of fixing changes is statistically higher than that of general changes .
this suggests that the bug fixes tend to be at small sizes.
thus automatic patching tools could start with small changes and gradually compose them.
e. repetitiveness on representative projects while previous sections present the results on the analysis on all projects in our dataset this section presents the results for a small set of the representative projects for further detailed analysis.
figure plots the cross project repetitiveness values of general changes in solid lines and fixing changes in dashed lines for those projects.
as seen although following the same trends the curve for one project might look different from another.
for example the curve for general changes in jeditis higher than that of jitterbit they have similar parameters however forjedit is larger than that forjitterbit .
figure also illustrates that at smaller sizes some projects have the repetitiveness of fixing changes higher than that of general changes such as jitterbit orspringframework .
figure plots for the same projects in the within project setting.
as seen the repetitiveness of fixing changes is lower than that of general changes.
in some projects such as jquant orpulse java the difference is quite significant.
f .
repetitiveness and change type change type we perform another analysis for the repetitiveness of changes classified based on the types of the corresponding code structures.
given a change as a pair of ast sub tree s t its type is defined as the ast node type ofs.
for example if sis a sub tree for an ifstatement that change is classified as a change to an ifstatement.
the repetitiveness of a change type is computed as the ratio of the number of repeated changes of that type over the total number of changes of that type in all projects we did not compute separately for each project .
from the previous results we focused on the repetitiveness in the cross project setting.
in addition to general changes we also computed the repetitiveness of fixing changes.
we choose most popular ast node types and divide them in groups.
the array group contains nodes representing program elements related to arrays such as an array access or array declaration.
the callgroup contains nodes representingtable iii cross project repetitiveness and change type general changes fixing changes group type total repeat total repeat array array declaration .
.
array access .
.
array initializer .
.
array creation .
.
call super constructor .
.
constructor .
.
super method .
.
class instantiation .
.
field access .
.
method .
.
super field access .
.
expression postfix .
.
prefix .
.
infix .
.
instance of .
.
cast .
.
conditional .
.
statement case .
.
throw .
.
assert .
.
catch .
.
if .
.
while .
.
try .
.
for .
.
synchronized .
.
enhanced for .
.
initializer block .
.
switch .
.
do while .
.
the elements related method constructor calls and field accesses.
the expression group is for expressions.
the statement group contains all statements such as if while try throw etc.
repetitiveness table iii lists the total number and repetitiveness of changes computed for those types.
at a first glance the number of changes is different for those types.
for example method calls infix expressions and ifstatements have the most changes while changes to constructor calls super field accesses and dostatements are less .
the repetitiveness for changes also vary according to change types.
it is very high for changes related to arrays expressions and calls often while it is very low for common statements such as iforwhile often no more than .
it is interesting that changes to method calls are the most popular and frequently repeated repetitiveness while changes to ifstatements are also popular but repeat much less frequently just repetitiveness .
change size is a possible explanation for this observation.
array accesses and method calls especially super calls are structurally simpler than the compound statements e.g.
iforwhile thus they could repeat more.
for example of changes to array accesses have sizes of while only of changes to ifstatements have such small sizes.
in addition among statements the small ones such as case throw and catch statements also repeat more frequently than the larger ones .
.
.
.
.
.
.0jeditmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0jitterbitmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0jquantmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0lateralgmmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0pulse javamk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0springframeworkmk.vector dat .
.
.
.
.
.0mk.vector fix fig.
.
cross project repetitiveness of general solid line and fixing changes dashed line .
.
.
.
.
.0jeditmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0jitterbitmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0jquantmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0lateralgmmk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0pulse javamk.vector dat .
.
.
.
.
.0mk.vector fix .
.
.
.
.
.0springframeworkmk.vector dat .
.
.
.
.
.0mk.vector fix fig.
.
within project repetitiveness of general solid line and fixing changes dashed line 1function recommend tree s changedatabase d list t changes c d.getchangeswithsourcetree s foreach c s r c 5bestscore computescore s r d 6as getklevelancestors s 7ar getklevelancestors r foreach p q as at score computescore p q d ifscore bestscore bestscore score 11t.addandsortbyscore r bestscore returnt 13end 15function computescore tree s treer changedatabase d 16ns number of occurences of changes having sas source tree 17ns r number of occurences of change s r returnns r ns 19end fig.
.
algorithm for recommending changes importantly as seen in table iii cross project repetitiveness of bug fixes is high especially for small program constructs.
it is as high as in general changes and much higher than the fixing changes in the within project setting.
this result on change repetitiveness over change size and type suggests that the aforementioned automated program repair should focus on the fixes with small sizes and of highly repetitive types such as array access method calls and if case statements.
v. c hange recommendation a. experiment setting to learn the recommending capability of repetitive changes and fixes we conducted an experiment in which we wrote a simple tool to recommend different options of changes fixes for a given code fragment based on the collected repetitive changes fixes.
for each project we ran the tool on all the changes in a chronological order.
such a change is represented as a pair of trees s t wheresis for the original code fragment source and tis for the replacing one target .
the tool takessand returns a ranked list t s ofkrecommendations.
iftmatches any result in that list we count this as a hit i.e.
a correct recommendation.
the overall accuracy is defined as the ratio between the number of hits over the total number of recommended cases.
the process is repeated for different values of k. the process was first run for within project mode.
that is the recommendation list t s is collected only from the previous changes of the project under processing.
then we ran it in hybrid mode where the recommendation list t s is also collected from the changes of all other projects.
in addition to running for general changes we also performed the same procedure for fixing changes.
figure shows the pseudo code of the algorithm for recommending the target tree.
given a source tree s it looks for all existing changes s r line .
the score of a target r is computed as the ratio between the number of occurrences of change from storand the number of occurrences of all changes having sas the source tree lines .
this score means the confidence of choosing ras the target of source s among all other seen targets.
we use as the smoothing factorfor the cases where the numbers of occurrences are too small.
for better results the algorithm considers the surrounding code ofsandrwhen ranking candidate targets.
the idea is that if the enclosing fragment of ris also the target of an enclosing fragment of swith high confidence rmight have a better chance to be the right target.
thus it also considers the scores among their ancestors.
the recommendation score for ris defined as the maximum score among the score between s andrand the scores between any pair of their ancestors.
this score is used to rank the candidate targets in the list.
note that the counting of nsandns rin function computescore can be adjusted to fit with the settings.
in the within project setting only the occurrences seen in the same project and before the revision of the change s t are counted.
in the hybrid setting in addition to the occurrences as in the within project setting all the ones seen in other projects are also counted.
b. recommendation result in within project setting figure shows the accuracy of recommending changes and fixes in the within project setting.
we executed the recommendation tool for largest projects with different values of k the number of recommendations and .
the accuracy for each kis shown as a box plot.
as seen the top accuracy is around to with the median value of around .
at k the accuracy can be up to and the median is around .
after that accuracy is stable i.e.
does not improve much with more recommendations.
the accuracy for recommending fixing changes is lower than that for general changes.
the median accuracy is around even though with more recommendations.
given the lower withinproject repetitiveness of fixing changes this result is expected.
c. recommendation result with hybrid approach hybrid approach combines both within and cross project repeated changes.
as seen in figure for general changes the median top accuracy is now around .
at k the accuracy can be up to and the median is around .
the median accuracy for fixing changes also increases to .
this result shows that fix recommendation tools could benefit much from cross project fix repetitiveness.
threats to validity.
although our dataset contains a large number of projects all of them are developed on java.
thus the observations on the repetitiveness of changes over change size and type might not be generalizable for projects developed in other languages or paradigms.
in addition all subjects are open source software thus their repetitiveness characteristics especially in the cross project setting might not be the same for commercial software.
another threat is on the accuracy of recommended changes and fixes.
we currently compare the recommended changes fixes and actual ones by their trees after normalization for literals and local variables.
in other words that accuracy result is for template recommendation rather than that of concrete variable names and literal values.
however we expect that in the concrete application of change fix recommendation a tool must concretize the literal values and local variables names.
.
.
.
.6within project recommendation of changes .
.
.
.6within project recommendation of bug fixes .
.
.
.6hybrid recommendation of changes .
.
.
.6hybrid recommendation of bug fixes fig.
.
accuracy of changes and fixes recommendation vi.
r elated work our study is related to the large scale study by gabel and su on the uniqueness of source code on more than million locs in software projects.
they consider a source file as a sequence of syntactical tokens with the abstraction on variables names.
they reported syntactic redundancy at levels of granularity from tokens.
at the level of granularity with tokens of each project is redundant.
later in a study about projects hindle et al.
have used n gram model to show that source code has high repetitiveness and n gram model has good predictability and could be useful in code suggestion.
another large scale study on code reuse at the filelevel was from mockus on .
millions source files in continually growing .
thousand unique projects.
they reported that more than of the files were used in multiple projects.
jiang and su locate functionally equivalent code fragments based on testing.
the method could be used to study source code reuse at the functional level.
there are advanced approaches in automatically generating synthesizing the program fixes based on the previously seen fixes in the projects histories .
weimer et al.
proposed genprog a patch generation method that is based on genetic programming.
kim et al.
introduced par an automatic pattern based program repair method that learns common patterns from prior human written patches.
our study provides empirical evidences for such automatic patch generation approaches.
our prediction model could serve as the baseline to enhance those approaches.
our prior study in fixwizard and a study by kim et al.
have confirmed the recurring nature of fixes.
however they were conducted in a much smaller scale with less than ten projects.there are a large body of research and tools on clone detection which is concerned with the detection of copyand paste fragments of code .
generally they can be classified based on their code representations.
the typical categories are text based token based tree based and graph based .
most clone detection tools focus on individual projects rather than across projects.
there have been several studies on software changes non essential changes change based bug prediction code clone changes cloning across projects patch identification threats when using version histories to study software evolution etc.
giger et al.
proposed an approach to predict type of changes such as condition changes interface modifications inserts or deletions of methods and attributes or other kinds of statement changes.
they use the types and code churn for bug prediction .
our prediction study does not have different types of changes but focuses more exact fine grained changes.
vii.
c onclusions in this paper we present a study of repetitiveness of code changes in software evolution.
repetitiveness is defined as the ratio of repeated changes over total changes.
we model a change as a pair of old and new ast sub trees within a method.
first we found that repetitiveness of changes could be very high at small sizes and decreases exponentially as size increases.
second repetitiveness is higher and more stable in cross project setting than in within project one.
third fixing changes repeat similarly to general changes.
importantly learning code changes and recommending them in software evolution is beneficial with accuracy for top recommendation of over and top of nearly .