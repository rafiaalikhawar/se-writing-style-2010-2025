see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation object centric debugging article in proceedings int ernational conf erence on softw are engineering june .
ic se.
.
citations 54reads author s including alexandr e ber gel relationalai publica tions citations see profile osc ar nier strasz univ ersity of bern publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y osc ar nier strasz on f ebruar y .
the user has r equest ed enhanc ement of the do wnlo aded file.object centric debugging preprint version to be published at icse jorge ressia software composition group university of bern switzerland scg.unibe.chalexandre bergel pleiad lab department of computer science dcc university of chile pleiad.dcc.uchile.closcar nierstrasz software composition group university of bern switzerland scg.unibe.ch abstract during the process of developing and maintaining a complex software system developers pose detailed questions about the runtime behavior of the system.
source code views offer strictly limited insights so developers often turn to tools like debuggers to inspect and interact with the running system.
unfortunately traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations though the questions developers pose often have more to do with objects and their interactions.
we propose object centric debugging as an alternative approach to interacting with a running software system.
we show how by focusing on objects as the key abstraction natural debugging operations can be defined to answer developer questions related to runtime behavior.
we present a running prototype of an object centric debugger and demonstrate with the help of a series of examples how object centric debugging offers more effective support for many typical developer tasks than a traditional stack oriented debugger.
i. i ntroduction debugging is formally the process of finding and reducing the number or defects in a computer program thus making it behave as expected.
more broadly however debugging is the process of interacting with a running software system to test and understand its current behavior.
software developers frequently turn to debuggers to obtain insight into parts of a running system before attempting to change it rather than to remove defects.
similarly in test driven development debuggers are frequently used as a development tool to identify those parts of the system that need to be implemented next.
traditional debuggers are focused on the execution stack .
the developer identifies parts of the source code of interest and sets breakpoints accordingly.
the software then runs until a breakpoint is reached and the developer can then inspect and interact with the code and entities in the scope of the breakpoint.
unfortunately this process is ill matched to typical development tasks.
first of all breakpoints are set purely with respect to static abstractions rather than to specific objects of the running system.
as a consequence identifying the right place to set breakpoints in the source code requires a deep understanding of what happens duringthe execution.
second debugging operations are focused on the execution stack rather than on the objects.
there exists therefore a considerable conceptual gap between the interface offered by the debugger and the questions of interest by the developer.
sillito et al.
identified kinds of questions that programmers ask themselves when they perform a change task on a code base.
a typical such question which is particularly relevant here is where is this variable or data structure being accessed?
developers take two approaches to answer this question.
the first approach is to follow the control flow and use the step over and step into stackbased operations.
manual step wise execution works well when the code space to explore is relatively small but may be impractical otherwise.
the second approach is to place breakpoints in all potential places where the variable might be accessed.
again this can work well for a small code space but can quickly become impractical if a variable is potentially accessed from many methods.
some debuggers allow the developer to insert breakpoints on accesses to instance variables.
however when such a breakpoint is applied to a particular class all instances of the class are affected.
if the developer needs to follow a specific object s instance variable access then he needs to proceed through breakpoint executions until the right object is found.
even with a small number of instances this process is error prone and not straightforward.
these approaches are inherently static since they start from the static source code.
neither approach directly answers the question where is this variable or data structure being accessed?
for a specific object.
there is consequently a gap between the kinds of questions developers ask about the running software system and the support offered by traditional debuggers to answer these questions.
object centric debugging attempts to close the gap between developers questions and the debugging tool by shifting the focus in the debugger from the execution stack to individual objects.
the essence of object centric debugging is to let the user perform operations directly on the objects involved in a computation instead of performing operationson the execution stack.
a fundamental difference between conventional and object centric debugging is that the latter is specified on an already running program .
instead of setting breakpoints that refer to source code one sets breakpoints with reference to a particular object.
the contributions of the present paper are a new technique called object centric debugging which provides a set of operations targeted to objects than to the execution stack.
examples illustrating the advantages of object centric debugging over traditional stack based debugging.
a prototype implementation of an object centric debugger.
outline the remainder of this paper is structured as follows section ii explains and motivated the need for object centric debugging.
section iii presents the objectcentric approach with its operations.
in section iv we demonstrate how our approach solves the challenges of object centric debugging with various case studies.
section v presents our infrastructure to implement objectcentric debuggers.
section vi analyzes how object centric debugging can be implemented in other languages.
in section vii we discuss the state of the art of debugging.
section viii summarizes the paper and discusses future work.
ii.
m otivation during software development and evolution programmers typically need answers to various questions about how the software behaves at runtime.
although various dynamic analysis tools exist the programmers first mainstream tool choice to explore the state of a running program is the debugger.
the classical debugger requires the programmer to set breakpoints in the source code before debugging is enabled and then offers the programmer operations to explore the execution stack.
unfortunately the debugger is not designed to answered many of the questions that programmers typically pose making it difficult if not impossible for the programmer to set meaningful breakpoints.
in this section we explore these questions and establish three challenges that a debugger should meet to better support software evolution tasks namely i intercepting access to object specific runtime state ii monitoring objectspecific interactions and iii supporting live interaction.
these challenges lead us to propose object centric debugging to meet these challenges.
a. questions programmers ask sillito et al.
identified kinds of questions that programmers ask when they perform a change task on a code base.
several of these questions involve understanding the program execution when during the execution is this method called?
q. where are instances of this class created?
q. where is this variable or data structure being accessed?
q. what are the values of the argument at runtime?
q. what data is being modified in this code?
q. how are these types or objects related?
q. how can data be passed to or accessed at this point in the code?
q. what parts of this data structure are accessed in this code?
q. sillito et al.
note in several sessions the debugger was used to help answer questions of relevancy.
participants set breakpoints in candidate locations without necessarily first looking closely at the code .
in the context of a running object oriented system these questions express that programmers need to deal with specific objects at runtime.
consider for example questions and .
simply by placing a breakpoint in the method concerned q. or in the constructor s of the class being instantiated q. and running either the program or its test suite one can quickly obtain answers to these questions and then explore the execution stack to obtain detailed information about the calling context.
this procedure works fine when trying to understand the general behavior of objects.
however when introducing polymorphism and delegation the behavior of objects of the same class changes depending on their composition.
these cases require an object specific analysis and simple breakpoint are not the best option.
conditional breakpoints are heavily used in real world application development when programmers need to interrupt the execution of the application when a particular expression is evaluated to true.
first the programmer needs to find the specific object he is interested in.
then the programmer has to specify a suitable condition to identify the specific object already found rather than directly interacting with it.
this approach may be feasible if there exist only few objects to analyze.
if however there are many instances of many classes setting conditional breakpoints may be tedious and error prone.
the situation is much the same with many of the other questions.
b. getting to the objects both traditional stack centric and object centric debuggers share a common operational process.
developers use debuggers to understand the runtime behavior of a system.
in the runtime the developer deals with objects instead of with their static representation in the source code.
stack centric and object centric debugging diverge when the developer finds a particular object that is not behaving as expected.
in a traditional stack centric debugger the developer leaves the debugger and turns to the static representation of the system to place regular or conditional breakpoints to steer the execution around a particular object.
in an object centric 2debugger the developer does not need to leave the debugger but applies object centric operations directly on the object of interest.
in both cases we need to get to the objects that are relevant for the debugging case.
however once the relevant objects have been detected the steering method is completely different.
object centric debugging allows the developer to continue interacting with the runtime applying operations directly on the objects instead of working with the static representation of the system.
c. intercepting object specific state access questions and all have to do with tracking state at runtime.
consider in particular question where is this variable or data structure being accessed?
let us assume that we want to know where an instance variable of an object is being modified.
this is known as keeping track of side effects .
one approach is to use step wise operations until we reach the modification.
however this can be time consuming and unreliable.
another approach is to place breakpoints in all assignments related to the instance variable in question.
finding all these assignments might be troublesome depending on the size of the use case as witnessed by our own experience.
during the development of a reflective tool we faced the situation that an unexpected side effect occurred.
the bytecode interpreter of the host language1is modeled by the class instructionstream .
this class defines an instance variable called pc i.e.
program counter which models where the execution is in the instruction stream.
the class methodcontext is a subclass of contextpart itself a subclass of instructionstream .
during our development we encountered an unexpected increase of the variable pc in an instance of methodcontext .
tracking down the source of this side effect is highly challenging of the methods defined on instructionstream access the variable comprising assignments the instance variable is written times in instructionstream s subclasses.
in addition the variable pchas an accessor that is referenced by intensively used classes.
without a deep understanding of the interpreter it is difficult to track down the source of the error with simple debugging strategy.
some debuggers provide instance variable related breakpoints.
however these breakpoints are not object specific thus requiring the introduction of conditional breakpoints to interrupt execution only in the right context.
questions and can also be difficult to answer through classical debugging.
the typical approach in each case is to statically identify possible call sites that may access or modify the data in question insert breakpoints and then invoke the debugger.
for complex programs which are the only programs that are really of interest finding and suitable breakpoints may be an overwhelming task and running the debugger may yield false positives.
d. monitoring object specific interactions let us reconsider question when during the execution is this method called?
if the programmer is only interested in knowing when the method is called for a specific object or caller then a conditional breakpoint may be set i.e.
which will only cause the debugger to start if the associated condition is met.
this however assumes that the object can be statically identified since the breakpoint is set in the source code view not at runtime.
furthermore if the source code of the object in question is not accessible the programmer will be forced to set breakpoints at the call sites.
question poses further difficulties for the debugging approach how are these types or objects related?
in statically typed languages this question can be partially answered by finding all the