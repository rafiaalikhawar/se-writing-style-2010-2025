flexible design pattern detection based on feature types ghulam rasool comsats institute of information technology lahore pakistan e mail grasool ciitlahore.edu.pkpatrick m ader institute for systems engineering and automation sea johannes kepler university linz austria e mail patrick.maeder jku.at abstract accurately recovered design patterns support development related tasks like program comprehension and reengineering.
researchers proposed a variety of recognition approaches already.
though much progress was made there is still a lack of accuracy and flexibility in recognition.
a major problem is the large variety of variants for implementing the same pattern.
furthermore the integration of multiple search techniques is required to provide more accurate and effective pattern detection.
in this paper we propose variable pattern definitions composed of reusable feature types.
each feature type is assigned to one of multiple search techniques that is best fitting for its detection.
a prototype implementation was applied to three open source applications.
for each system a baseline was determined and used for comparison with the results of previous techniques.
we reached very good results with an improved pattern catalog but also demonstrated the necessity for customizations on new inspected systems.
these results demonstrate the importance of customizable pattern definitions and multiple search techniques in order to overcome accuracy and flexibility issues of previous approaches.
keywords design pattern recognition pattern detection pattern definition feature based pattern recognition program comprehension code analysis regular expressions i. i ntroduction design patterns are meant to solve recurring problems in software system design and so to improve reusability maintainability comprehensibility evolvability and robustness of applications .
design patterns are not per se beneficial but do have advantages if chosen wisely .
the recovery of design patterns from applications started years ago with the publication of gamma et al.
s prominent book and the first attempt for the recovery of these patterns by kr amer et al.
.
the fact that the later publication is cited more than times highlights the relevance of the topic.
though much work has been done in the area of pattern recognition since the early days some key questions still remain unanswered.
in the following paragraphs we will emphasize on four of the main issues and how our approach contributes to their solution.
first there is still no consensus about which information realizes the existence of patterns in source code.
a fundamental demand for the pattern research community is the development of consistent definitions of design patterns across the community .
until that problem is solved comparing the results of pattern recognition techniques is a challenging problem as we will demonstrate in that paper.
authors claimcorrectness of their results on the same problem though a deep analysis shows differing recovered patterns.
the cause of disparity in most cases are different interpretations of patterns and their differing implementation variants.
though a consistent definition of patterns is required and will help to mitigate the problem to some extend such a definition cannot solve the problem completely.
programming languages will offer new features programmers will find new pattern variances and even new patterns.
a solution to this problem should be an extensible and customizable set of pattern definitions containing all the standard patterns while leaving room for new developments.
second the comparison of approaches is extremely difficult due to the unavailability of benchmarks and trusted baselines for them.
similar to the creation of consistent pattern definitions the pattern research community is required to provide agreed benchmark examples with known baselines to cope with that problem.
creating a baseline for a project requires the manual inspection of the source code which is especially for bigger systems a very challenging and expensive task.
to cope with that problem we introduce trusted baselines by comparing and analyzing the results of previous approaches.
these baselines and the results of our approach will be published as an attempt to overcome the problem of missing benchmarks.
third pattern detection approaches are usually language dependent and support in the best case only a small number of programming languages.
the underlying problem here apart from the different syntax of different programming languages is that the features for the implementation of patterns vary across languages and so require a successful approach to handle language dependent variants of patterns.
our approach is currently capable to detect patterns within c c c and java source code and it can easily be extended for other languages.
furthermore we provide a customizable and extensible catalog of patterns and their variants which facilitates the recognition in all current and in future programming languages.
fourth many previous approaches have only been demonstrated in extracting a subset of the so called gang of four gof design patterns .
the issue here is that the recognition of these patterns varies in complexity.
while some patterns are easily identifiable due to their unique structure the task becomes more challenging for others.
our approach to that problem is the separation of a pattern definition into recurring features.
these features are structural relational and behavioral parts that make up a pattern.
a feature type will be detected in the source code with a search technique that is most fitting for it s characteristics.
that means that we apply different technologies for detecting different parts of a pattern in order to overcome accuracy problems.
we evaluated our approach with three applications and all gof patterns.
in conclusion the contribution of our work is a thoroughly evaluated pattern detection technique based on flexible and extensible pattern definitions and search techniques.
the paper is organized as follows section ii discusses the current state of art of work that has resemblance with our approach.
section iii refers to the specification of patterns and their variants as a basis for our approach.
section iv discusses the actual approach used for the detection of design patterns.
the prototyping tool used to realize the concept of our approach is presented in section v. section vi describes the experimental set up chosen to evaluate our approach shows results extracted by the approach and discusses them.
finally section vii concludes the whole approach.
ii.
r elated work as discussed in the introduction early research on design pattern detection dates back almost years.
a number of approaches applying different recognition techniques to the problem has been developed and studied.
we cannot introduce all of these approaches here and it is not necessary as there are good reviews about the characteristics of different techniques used in the field of design pattern recovery .
the authors of the first paper presented a deep insight on work starting from the infancy of design pattern recovery to the publication of this article.
the approach presented in uses static program analysis for the detection of patterns from source code of different applications.
the authors represent examined software and design patterns as graphs and use matrices to represent relationships between source code artifacts.
the proposed methodology uses similarity algorithms to cluster hierarchies which reduce the search space for pattern detection.
the authors report precision and recall on the examined examples.
though precision and recall become suspicious as upon comparison of our results with the reported ones a number of reported true positives seem to be false positives.
other researchers also refer to disparities in the results of the discussed approach.
gu eh eneuc and antoniol present a multilayered semiautomatic approach for design pattern detection from java source code.
the approach uses static analysis to detect relationships.
dynamic analysis based on trace analysis techniques is used to compute exclusivity and life time relationships for aggregation and composition relationships.
the authors performed experiments on open source systems and achieved an average precision of for the supported design motifs and report recall.
authors of the same group presented an improvedapproach using constraints programming supplemented with numerical analysis in order to improve the performance of their previous approach.
they performed experiments on gof patterns applying the previously used examples and additional ones.
while performance was improved accuracy did not change.
costagliola et al.
present a visual language based pattern recovery approach along with different case studies.
the approach extracted adapter bridge composite decorator and proxy with precision and recall from small systems.
the same group proposed a two phase approach .
in phase design pattern instances are recovered at a coarse grained level by parsing the design structure of an inspected system.
identified patterns are then in phase validated by a fine grained source code analysis.
the authors performed experiments on open source systems extracting structural design patterns.
they improved and extended their approach in and used the same case studies.
the extended approach first constructs a uml class diagram represented in svg format.
the class diagram is then mapped with a visual language grammar to detect different patterns.
comparing the results of both approaches we noticed that the extracted pattern are the same in both approaches so it is hard to conclude about an improvement.
we will refer to the results of that approach when discussing the evaluation of our approach.
dong et al.
present a design pattern recovery approach based on the use of matrices and weights.
the dp miner toolkit is used to build a matrix of inspected source code.
all classes in the system correspond to rows and columns and relationships between a pair of classes to a value of the corresponding cell in the matrix.
information on design patterns is encoded as matrix and weights.
the discovery of design patterns is performed by matching matrices and weights with arithmetic computations.
the authors performed experiments on different case studies and aim to recover adapter bridge strategy and composite design patterns.
precision values are only provided for jhotdraw and recall has not been computed.
shi and olsson extract program intent in order to recognize patterns from java source code.
the technique has reclassified all gof patterns in the context of reverse engineering.
their tool recovers all gof patterns from source code with the exception of prototype iterator and builder.
the authors do not provide precision and recall for their extracted results.
while comparing our results we found a large number of false positives and false negatives among the results provided by their tool.
concluding from the discussion of related work we found that most approaches are based on a single recognition technique.
furthermore the approaches perform experiments either on java or c projects and most of them not on all gof patterns.
achieved results are debatable for some approaches.
the various implementation variants for each pattern hinder approaches with only a fixed set of pattern definitions from reaching high accuracy of pattern recovery.
within that paper we are introducing an approach that seeks to overcome these problems.product concreteproductcreator fm1 fm2 concretecreator fm1 fm2 product concreteproductcreator fm1 fm2 concretecreator fm1 fm2 product concreteproduct concretecreator fm1 fm2 creator fm1 fm2 variant a variant b variant cfig.
.
three implementation variants of the factory method pattern iii.
d esign patterns as collection of features design patterns are typically described in terms of several aspects such as intent structure behavior and sample code.
a design pattern usually consists of multiple elements forming its structure of relationships between these elements and of a described behavior of the elements.
a clear specification and description of a design pattern not only helps with its application in forward engineering i.e.
for its successful implementation but it also plays a key role in the recovery of a pattern from existing source code.
the aim of our work was to develop a pattern specification technique that is precise enough to be automatically applicable by a tool but also understandable and customizable for humans.
while analyzing all the gof patterns and their known variances we found that they were composed of recurring substructures among different variants of the same pattern but also among different patterns.
we call these sub structures features of a pattern and were able to specify all gof patterns from a collection of different feature types.
examples of these feature types are a class that is part of a pattern a generalization relationship between two classes an aggregation between two classes and a method return type which is equal to a certain class.
a. example factory method this subsection introduces the factory method pattern in the original version proposed by the gof and also shows two alternative ways for implementing the same pattern.
we will use that example throughout the paper to discuss and illustrate our approach.
the factory method pattern is used for creating a class of products without specifying the class creating those products.
recognizing the factory method pattern in source code is a challenging task due to its many different implementation variants.
radonjic and corriveau report about nine structural variants to implement that pattern.
figure shows three of these variants all implementing the factory method pattern.
on the left hand side of the figure variant a the original version as described by the gof is depicted.
in that original version the factory method pattern is a composition of the following features f1 a concretecreator class f2 a creator class generalizing the concretecreator class f3 a creator class and a concretecreator class that have at least one common factorymethod method f4 every factorymethod method is creating a concreteproductclass and returns a concreteproduct of type product f5 a concreteproduct class realizing the product interface f6 a concretecreator class not generalizing the concreteproduct class f7 a concretecreator class not generalizing the product class a second and a third variant of the pattern are depicted as variants b and c in figure .
both differ slightly from the original version and their specification consists of other and additional features.
iv.
p attern recognition approach based on an analysis of open problems in the field of pattern recognition see section i and based on an intensive study of related work in the same field see section ii we propose an open and extensible detection approach that consists of two stages stage creating semi formal definitions for each pattern of interest and its variants based on common extensible feature types.
stage detecting patterns by identifying its features with different search technologies best fitting to the respective feature.
within the first stage of the approach a catalog of pattern specifications to be recognized is being created.
the fundamental concept applied in this stage is the use of recurring feature types for the specification of patterns and their variants.
these feature types have iteratively been derived while creating a catalog of all gof patterns and their commonly known variants.
both collections the set of feature types as well as the set of pattern definitions are extensible.
within the second stage of the approach the specified definitions are used to detect pattern instances in the source code.
figure depicts the recognition process.
we assume that the source code as well as an automatically created model of the source code are available for analysis see right handside of figure .
a recognition controller triggers all required analysis steps.
it iterates through each feature defined within the definition of a pattern under inspection.
depending on the type of the current feature it selects a search technology for detecting the feature either within the source model or the source code itself.
depending on whether a feature is matched or not existing candidate patterns are extended or pruned.
both stages of the approach are described in depth in the following two subsections.
inspected source code.java .c .cpp ...reverse engineered source code modelsql model analysis feature speci f ic code parsermodel and code regex matcher annotation analyzer ... multiple recognition technologies depending on searched featurepattern de f initionsfeature type de f initions recognition controller recognized candidate patterns1 iterate through features of a pattern de f intionrefer to apply recognition technology according to feature type prune and expand recognitized patterns based on results for feature currently under inspectionextracted from fig.
.
overview of the proposed recognition approach a. stage defining patterns as discussed before a standard pattern catalog defining all patterns and their variants is not available but required for accurate pattern definition.
a solution to that dilemma is a variable and customizable pattern catalog collecting commonly agreed pattern definitions but being also open for additions and improvements.
before referring to the concepts of that pattern catalog we are introducing the concept of feature types that forms the basis of pattern definitions.
feature types the backbone of our pattern definitions are feature types.
these feature types are reusable across all pattern definitions and can be imagined as being elementary and recurring across various design patterns see section iii .
for the detection of each feature type we use a search technology that is most efficient while still being precise enough for the feature s detection.
the current prototype uses the following search technologies sql for analyzing the source code model regular expressions for analyzing texts e.g.
identifiers and comments in the source code model and the source code and source code parsers for identifying specific features not certainly identifiable through the other techniques.
a feature type is characterized by a search technology a query parameters and a return type.
the query is specific to the applied search technology and connects all these concepts.
the purpose of a query is to retrieve all instances of a feature meeting certain criteria.
these criteria are either fixed within the defined query or they are parametric.
parameters receive their value upon the use of a feature type within a concrete pattern definition.
parameter can be defined as a static value or as a reference to the result of a related feature.the purpose of static parameters is keeping the number of required feature types at a convenient level.
for example a feature type for detecting a common attribute and that for detecting a common method between two classes distinguish only in the type of the searched elements.
static parameters allow to create a feature type that detects common members of two classes and to set the type of the actually searched member as a parameter within the concrete pattern definition.
dynamic parameters allow to relate the detection results of multiple features.
that is to pass the instances retrieved for one feature of a pattern definition can be used in a following query.
referring back to the example of a common method among classes the intention usually is not to detect all common methods between all classes within an inspected source code but to identify common methods between classes that have previously been detected as having other features.that means dynamic parameters allow to relate features to each other.
table i examples of feature types used for the definition of the factory method pattern ft1 has class returns list of classes technology sql query on source model ft2 has super class class returns list of classes technology sql query on source model ft3 have common method class1 class2 returns list of methods technology sql query on source model ft4 is returning class method1 returns class technology specific parser inspecting source code ft5 is realizing interface class1 returns list of interfaces technology sql query on source model ft6 are generalized class1 class2 returns boolean value technology sql query on source model ft7 are aggregated class1 class2 returns boolean value technology specific parser inspecting source code our approach currently uses feature types that allowed us to define all the gof patterns and their variations.
table i shows a subset of these feature types.
the table also shows the applied detection technology parameters and the results type for each feature type.
we show these feature types as they contribute to the factory method example used throughout that paper.
required feature types not currently available but required for a new pattern definition can be added to the xml feature type catalog.
all feature types can be separated into two categories exploring feature types and checking feature types.
an exploring feature type returns all artifacts that form a searched feature usually in combination with another artifact providedas parameter.
for example ft2 see table i returns all super classes of a given class.
a checking feature type consumes one or more artifacts as parameters checks for the existence of a feature involving the provided artifacts and returns a boolean result.
for example ft6 see table i checks whether or not a generalization relationship is existing between two provided classes.
pattern definitions after introducing the concept of feature types we are now discussing the actual pattern definitions.
these are a hierarchical structure comprised of the following concepts pattern catalog collection of all pattern definitions pattern definition section of the catalog collecting all those variant definitions that capture implementation variants of the same pattern and are focussed on the detection of the same type of pattern variant definition section of a pattern definition that defines one implementation variant of a pattern as a collection of features feature section of a variant definition that has a type defined in the feature type catalog and defines all the types parameters as static values or dependencies to other features the feature is the basic concept of our pattern definitions the other three concepts group features into a pattern variant multiple variants into a pattern definition and finally all patterns into one pattern catalog.
a variant definition is a combination of all relevant features which in turn may use different recognition techniques.
a feature must be of a type that is part of the feature type catalog.
furthermore each feature has to define the parameters of its feature type see previous discussion of feature types .
parameters are either defined as fixed values static parameter or as reference to results of a previous feature within the current variant definition dynamic parameter .
in the current form of the approach features are detected sequentially as they appear in a variant definition.
that means that