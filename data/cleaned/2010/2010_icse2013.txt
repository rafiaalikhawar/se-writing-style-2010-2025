published in proceedings of the 35thinternational conference on software engineering icse san francisco california may .
inferring likely mappings between apis amruta gokhale vinod ganapathy yogesh padmanaban amrutag cs.rutgers.edu vinodg cs.rutgers.edu ypadmana cs.rutgers.edu department of computer science rutgers university piscataway nj usa abstract software developers often need to port applications written for a source platform to a target platform.
in so a key task is to replace an application s use of methods from the source platform api with corresponding methods from the target platform api.
however this task is challenging because developers must manually identify mappings between methods in the source and target apis e.g.
using api documentation.
we develop a novel approach to the problem of inferring mappings between the apis of a source and target platform.
our approach is tailored to the case where the source and target platform each have independently developed applications that implement similar functionality.
we observe that in building these applications developers exercised knowledge of the corresponding apis.
we develop a technique to systematically harvest this knowledge and infer likely mappings between the apis of the source and target platform.
the output of our approach is a ranked list of target api methods or method sequences that likely map to each source api method or method sequence.
we have implemented this approach in a prototype tool called rosetta and have applied it to infer likely mappings between the java2 platform mobile edition and android graphics apis.
i. introduction software developers often wish to make their applications available on a wide variety of computing platforms.
the developer of a gaming app for instance may wish to make his app available on smart phones and tablets manufactured by various vendors on desktops and via the cloud.
the key hurdle that he faces in so is to port his app to these software and hardware platforms.
why is porting software a di cult problem?
consider an example suppose that we wish to port a java2 platform mobile edition javame based game to an android powered device.
among other tasks we must modify the game to use android s api the target platform instead of javame s api thesource platform .
unfortunately the process of identifying the api methods in the target platform that implement the same functionality corresponding to that of a source platform api method is cumbersome.
we must manually examine the sdks of the source and target apis to determine the right method or sequence of methods to use.
to add complexity there could be multiple ways in which a source api method can be implemented using the target s api methods.
for example the fillrect method in javame s graphics api which fills a specified rectangle with color can be implemented using either one of these two sequences of methods in android s graphics api setstyle drawrect or as moveto lineto lineto lineto lineto drawpath we have omitted class names and the parameters to these method calls .
one way to address this problem is to populate a database ofmappings between the apis of the source and target plat forms.
in this database each source api method or method sequence is mapped to a target api method or method sequence that implements its functionality.
the database could contain multiple mappings possibly ranked for each source api method in cases where its functionality can be implemented in di erent ways by the target api.
the mapping database significantly eases our task.
we need only consider the mappings in this database to find suitable target api methods to replace a source api method instead of painstakingly poring over the sdks and their documentation.
such mapping databases do exist but only for a few source target api pairs e.g.
android ios and symbian qt to windows and ios to qt and they are populated by domain experts well versed in the source and target apis.
our contribution .we present an approach to automate the creation of mapping databases for any given source target api pair.
to bootstrap our approach we rely on the availability of a few similar application pairs on the source and target platform.
a source platform application sand a target platform application t possibly developed independently by di erent sets of programmers constitute a similar application pair if they implement similar high level functionality.
for example bothsandtcould implement the tictactoe game on javame and android respectively.
this situation is not uncommon in modern app markets where independentlydeveloped versions of popular apps are available in markets hosted by di erent vendors.
our approach builds upon the observation that in implementingsandt their developers exercised knowledge about the apis of the corresponding platforms .
we provide a systematic way to harvest this knowledge into a mapping database which can then benefit other developers porting applications from the source to the target platform.
our approach works by recording traces of sand texecuting similar tasks structurally analyzing these traces and extracting likely mappings using probabilistic inference.
each mapping output by our approach is associated with a probability which indicates the likelihood of the mapping being true.
the intuition is that the more evidence we see of a mapping e.g.
the same pair of api methods being used across many traces to implement similar functionality the higher the likelihood of the mapping.
the output of our approach is a ranked list of mappings inferred for each source api method.
we demonstrate our approach by building a prototype tool called rosetta in reference to the legendary rosetta stone to infer likely mappings between the javame and android graphics apis.
we chose javame and android because both platforms use the same language for application development.
however this requirement is not germane to our approach sn tn src tgt prb a a b b a b a b .
.
.
.
t1 t2 t3 inference s1 t1 combine step collect apps s1 t1 s1 t1 ..... a !b ...!a !b !...
!s1 s2 s3 source api apps target api apps ..... src tgt prb a a b b a b a b .
.
.
.
step get trace pairs step infer mappings for each trace pair step combine inferences across traces fig.
.
workflow of our approach to inferring likely api mappings.javame trace android trace graphics.setcolor paint.setstyle graphics.fillrect color.parsecolor graphics.setcolor paint.setstyle graphics.fillrect color.parsecolor graphics.fillrect canvas.drawline graphics.fillrect canvas.drawline canvas.drawline canvas.drawline canvas.drawline note each trace snippet shows the method invoked and the class in which the method is implemented.
javame and android classes are prefixed with javax microedition lcdui and android graphics respectively.
for brevity we only refer to method names and not their classes.
fig.
.
snippets from traces of similar executions of javame and android based tictactoe games.
and it may be possible to adapt rosetta to work with source and target apis that use di erent languages for application development.
we evaluated rosetta with a set of twenty one independently developed javame android application pairs.
rosetta was able to find at least one valid mapping within the top ten ranked results for of the javame api methods observed in our traces.
further for of javame api methods the top ranked result was a valid mapping.
ii.
a pproach overview we present the workflow of our approach figure tailored to javame and android as the source and target platforms respectively.
we only provide informal intuitions here and defer the details to xiv.
the workflow has four steps.
step collection of application pairs.
the first step is to gather a database of applications in both the source and target platform.
for each source application in the database we require a target application that implements the same highlevel functionality.
for example if we have a tictactoe game for javame we should locate a tictactoe game for android that is as functionally and visually gui wise similar to the javame game as possible.
given the popularity of modern mobile platforms and the desire of end users to use similar applications across platforms such application pairs are relatively easy to come by.
of course given that the games were independently developed for these two platforms there may be minor di erences in functionality.
for example the android game may o er menu options that are di erent from those of the javame game.
however as we discuss in step we can restrict ourselves to inducing functionally similar execution paths in these applications.
any functional di erences that still make their way into these execution paths will manifest as inaccuracies during probabilistic inference in step .
however the e ect of these inaccuracies can be mitigated by combining inferences across multiple applications pairs and their executions in step .
step execution and collection of trace pairs.
in this step we take each application pair and execute them in similar ways i.e.
we provide inputs to exercise similar functionality in these applications.
as we do so we also log a trace of api calls invoked by the applications.
this gives a trace pair consisting of one trace each for the source and targetapplications.
figure presents a snippet from a trace pair that we gathered for tictactoe games on the javame and android platforms.
they were collected by starting the game waiting for the screen to display a grid of squares and exiting.
since the traces in each pair were obtained by exercising similar functionality in the source and target applications these traces must contain some api calls that can be mapped to each other.
this is the key intuition underlying our approach.
of course an application can be invoked in many ways and in this step we collect several trace pairs for each application pair.
the output of this step is a database of functionally equivalent trace pairs traces tracet across all of the application pairs collected in step .
steps and involve manual e ort while steps and are automated.
step trace analysis and inference.
in this step we analyze each trace pair to infer likely api mappings implied by the pair.
our inference algorithm relies on various attributes that are determined by the structure of the traces.
we cast the attributes as inputs to a probabilistic inference algorithm xiv .
the output of this step is a probability for each pair of source and target api calls a a that indicates the likelihood of a mapping to a denoted here as a !a .
our algorithm can also infer mappings between method sequences e.g.
a !a b ora b !a .
we now discuss the attributes used by our approach using our running example.
our aim is to find likely mappings for the javame calls setcolor and fillrect .
for simplicity we restrict our discussion to the snippets of the traces shown in figure .
in reality our analysis considers the entire trace.
call frequency.
ifa in the source api maps to the a in the target api then the frequency with which these method calls occur in functionally similar trace pairs must also match.
the trace pairs may di er in the absolute number of method calls that they contain so we focus on the relative count of each method call which is the raw count of the number of times that a method is called normalized by trace length.
the table below shows the raw and relative counts of various method calls based upon the snippets in figure .
using this attribute the following api mappings appear likely setcolor !parsecolor setcolor !setstyle fillrect !drawline while the others appear unlikely.
in fact our approach works on method sequences aswell using the same reasoning as above and infers that setcolor !setstyle parsecolor is a mapping.
api call raw count relative count setcolor .
fillrect .
setstyle .
parsecolor .
drawline .
call position.
the location of method calls in a trace pair provides further information to determine likely mappings.
since the traces exercise the same application functionality method calls that map to each other should appear at similar positions in the trace pair.
the table below shows the position of each of the method calls in our running example roughly categorized as belonging to the first half or the second half of the corresponding traces.
we can therefore reinforce the beliefs about api mappings inferred using call frequencies.
api call first half second half setcolor x fillrect x setstyle x parsecolor x drawline x call context.
the context in which a method call a appears is defined to be the set of api methods that appears in its vicinity in the execution trace e.g.
within a pre set threshold distance preceding or following a in the trace .
for example both setcolor calls appear in the preceding context offillrect calls in the javame trace using a threshold distance of calls .
likewise parsecolor and setstyle appear in the preceding context of drawline in the android trace.
in fact the sequence setstyle parsecolor appears in the preceding context of the first drawline .
from this we can infer that iffillrect !drawline holds then the mapping setcolor !setstyle parsecolor is likely to hold.
method names.
while trace structure as captured by the attributes above contributes to inference method and class names also contain useful information about likely mappings and we leverage this attribute as well.
we use levenshtein edit distance to compute the similarity of method names.
using this attribute for instance we can lend credence to the belief that setcolor maps to parsecolor .
our approach combines these attributes to output likely mappings each associated with a probability.
we can rank the results using the corresponding probabilities and use thresholds to limit the number of results that are output.
step combining inferences across traces.
the inference algorithm of step works by analyzing a single trace pair.
in the final step we combine inferences across multiple traces.
during combination we weight inferences obtained from the analysis of individual trace pairs using the confidence of each inference.
intuitively more data we have about an inferred mapping from a trace pair the stronger our confidence in that inference.
thus our confidence in mapping a !a obtained from a trace pair where these calls occur several times is stronger than the same mapping obtained from a trace pair where these calls occur infrequently.
we use this heuristic to combine inferences across trace pairs.iii.
f ramework to represent and infer mappings we now describe the framework used to represent and infer likely mappings between apis.
we restrict ourselves to identifying likely mappings between methods of the source and target apis.
we do not currently consider the problem of determining mappings between arguments to these methods that is a related problem that can be addressed using parameter recommendation systems e.g.
.
lets fa b c gand t fa b c gdenote the sets of methods in the source and target apis respectively.
our goal is to determine which methods intimplement the same functionality on the target platform as each method in son the source platform.
to denote mappings our framework considers a set of boolean variables xs t where s2s and t2t.
the boolean variable xa ais set to true if the method call a maps to the method call a and false otherwise.
this framework extends naturally to the case where a method or sequence of methods in scan be implemented with a method sequence in t. for example suppose that the method a is implemented using the sequence a b in the target.
we can denote this by assigning true to the boolean variable xa ab.
likewise we can also denote cases where the functionality of a sequence of methods a b in the source platform is implemented using a method a on the target platform by setting the boolean variable xab atotrue.
although our framework theoretically supports inference of mappings between arbitrary length method sequences e.g.
xabc abc true for performance reasons we configured rosetta to only infer mappings between method sequences of length two.
we approach the problem of inferring api mappings by studying the structure of execution traces of similar applications on the source and target platforms.
we use the trace attributes informally discussed in xii to deduce api mappings.
our approach is inherently probabilistic.
it cannot conclude whether a call a definitively maps to a call a rather it determines the likelihood of the mapping.
thus it infers pr xa a true for each boolean variable xa a. as it observes more evidence of the mapping xa abeing true it assigns a higher value to this probability.
therefore our framework treats each boolean variable xa aas a random variable and our probabilistic inference algorithm determines the probability distributions of these random variables.
each application trace has several method calls and the inference algorithm must leverage the structure of these traces to determine likely mappings.
the inference algorithm draws conclusions not just about individual random variables but also about how they are related .
for example consider a trace snippet traces a a b b of an application from the source api and a snippet tracet a a b b from the corresponding execution of a similar application on the target.
suppose also that these are the only occurrences of a b a and b intracesand tracet respectively and that these execution traces have approximately the same number of method calls in total.
by just observing these snippets and relying on the frequency ofmethod calls each of the following cases is a possibility xa a true xa b true xb a true xb b true.
however if xa b true then because of the relative placement of method calls in these traces i.e.
call context it is unlikely that xb a true.
now suppose that by observing more execution traces we are able to obtain more evidence that xa b true then we can leverage the structure of this pair of traces to deduce that xb a is unlikely to be a mapping.
intuitively the structure of the trace allows us to propagate the belief that if xa bistrue then xb aisfalse .
our probabilistic inference algorithm uses factor graphs for belief propagation.
factor graphs.
letx fx1 x2 xngbe a set of boolean random variables and j x1 x2 xn be a joint probability distribution over these random variables.
jassigns a probability to each assignment of truth values to the random variables inx.
given such a joint probability distribution it is natural to ask what the values of the marginal probabilities mk xk of each random variable xkinxare.
marginal probabilities are defined asmk xk p i k i2 xi2ftrue falsegj x1 x2 xn .
that is they calculate the probability distribution of xkalone by summing upj over all possible assignments to the other random variables.
mk xk allows us to compute pr xk true .
factor graphs allow e cient computation of marginal probabilities from joint probability distributions when the joint distribution can be expressed as a product of factors i.e.
j x1 x2 xn q ifi xi .
each fiis a factor and is a function of some subset of variables xi x. for example consider a probability distribution j x y z .
let this distribution depend on three factors f x y g y z and h z i.e.
j x y z f x y .g y z .h z defined as follows f x y .
if x y false .
otherwise.
g y z .
if y z true .
otherwise.
h z .
if z true .
otherwise.
f g h x y z fig.
.
factor graph of j x y z .a factor graph denotes such joint probabilities pictorially as a bipartite graph with two kinds of nodes function nodes and variable nodes.
each function node corresponds to a factor while each variable node corresponds to a random variable.
a function node has outgoing edges to each of the variable nodes over which it operates.
figure depicts the factor graph of j. the ai community has devised e cient solvers that operate over such graphical models to determine marginal probabilities of individual random variables.
we do not discuss the details of these solvers since we just use them in a black box fashion.
factor graphs cleanly represent how the random variables are related to each other and can influence the overall probability distribution.
one of the key characteristics of factor 1becausejis a probability distribution the product j x y z is in fact z f x y g y z h z where zis a normalization constant introduced to ensure that the probabilities sum up to .
henceforth zis implied and will not be shown explicitly.graphs which led us to use them in our work is that they were designed for belief propagation i.e.
in transmitting beliefs about the probability distribution of one random variable to determine the distribution of another.
to illustrate this consider the probability distribution j x y z discussed above.
jcan be interpreted as denoting the probabilities of the outcomes of an underlying boolean formula for various assignments to x y and z. under this interpretation we could say that the boolean formula evaluates totrue for those assignments to x yandzfor which the value ofj x y z is above a certain threshold e.g.
if the threshold is .
andj true true false is .
we say that the formula istrue under this assignment.
now suppose that yis likely to befalse i.e.
pr is above a threshold.
we are asked to find under what conditions on xandzthe boolean formula still evaluates to true i.e.
j x y z is above the threshold.
from the definitions of the factors f g and h we know that jobtains values that are likely to exceed the threshold if x y false y z true andzistrue.
given that yis likely to be false false these factors lead us to deduce that xis also likely to be false giving f x y a high value and zis likely to be true giving g y z and h z high values thereby pushing the value ofjabove the threshold.
intuitively the factor graph allows us to propagate the belief about the value of yinto beliefs about the value of xandz.xiv shows how we cast the problem of inferring likely api mappings using factor graphs thereby allowing us to transmit beliefs about one mapping into beliefs about others.
iv .
d esign and implementation of rosetta we now describe in detail the rosetta prototype which currently infers mappings between the javame and android graphics apis.
specifically we focus on the machinery that enables steps discussed in xii.
a. infrastructure for trace collection to record execution traces we instrumented javame programs via bytecode rewriting.
we used the asm toolkit to insert logging functionality that records the name of each method call and class name prior to invocation.
during runtime this results in a trace of all methods invoked.
we then filter out just those methods that derive from the class javax microedition lcdui the javame graphics api.
in all this api has distinct methods.
rosetta infers mappings for those methods that appear in application traces.
we did not employ bytecode rewriting for android applications because of the lack of publicly available tools to rewrite android s dexbytecode.
instead we leveraged the dalvik virtual machine v2.1r1 to record the names of all methods invoked by an application.
we record all method and class names and then filter methods in the following classes prefix android graphics text view widget content dialoginterface app dialog app alertdialog app actionbar .
this api has distinct methods.
the di erence in the sizes of these apis illustrates in part the di culties that a programmer manually porting an application would face.with this infrastructure a rosetta user can collect traces for a pair of similar applications on both platforms.
as discussed inxii the user must exercise similar functionality in both applications thereby collecting a pair of traces that record this functionality.
this process can be repeated multiple times for the same application exercising di erent functionalities thereby resulting in a database of trace pairs.
although it is hard to provide concrete guidelines to exercise similar functionality we found that it was relatively easy to do so for gaming applications.
given similar games they will likely have the same logic and similar guis on both applications.
we simply performed the same moves on games in both platforms avoiding situations that involve randomness where possible e.g.
choosing the two user mode to avoid the computer picking moves at random .
however randomness is not always avoidable e.g.
some games only support user versus computer modes and this randomness may manifest in the corresponding portions of the traces as well.
despite this rosetta infers high quality mappings because its inference algorithm prioritizes method mappings that persist both across the entirety of each trace pair and across multiple trace pairs.
b. trace analysis and inference in this step rosetta analyzes each trace pair collected in the previous step and draws inferences about likely api mappings implied by that trace pair.
recall from xiii that we use a boolean random variable xa ato denote a mapping between a and a likewise xa abetc.
for method sequences .
in this step rosetta uses factor graphs to compute pr xm m true for each such random variable where mandmdenote individual methods or method sequences from the source and target apis respectively.
the value of this probability determines the likelihood that the corresponding mapping holds.
the intuition behind rosetta s use of factor graphs is as follows.
the set of random variables xm mimplicitly defines a joint probability distribution jover these random variables j xa a xa b xb a xb b xa ab xb ab .
as inxiii we can assignja boolean interpretation.
that is we treat j as a probability distribution that estimates the likelihood of an underlying boolean formula being true under various truth assignments to the random variables xa a xa b etc.
from this joint distribution our goal is to find the probability distributions of the individual random variables.
under this boolean interpretation if pr xa a true acquires a high value it means that the boolean formula underlying jis likely to betrue ifxa aistrue thereby leading us to conclude that a is likely to map to a .
likewise if pr xa a true acquires a low value a is unlikely to map to a .
the main challenge in directly realizing this intuition within an inference tool is that the boolean formula underlying jis unknown for if it were known then any satisfying assignment to it would directly yield an api mapping!
.
as a result the joint probability distribution jcannot be explicitly computed.
however the attributes described in xii determine the conditions that are likely to influence j. thus we formalize each of these attributes as factors and estimatealgorithm inferring likely mappings.
input a trace pair traces tracet .
output pr xm m true for each xm m where mandmare methods and sequences in traces tracet respectively.
methseqs set of methods and method sequences that appear in traces sequences up to length in our prototype methseqt set of methods and method sequences that appear in tracet foreach m2methseqsandminmethseqt do ffreq xm m simcount m m traces tracet fpos xm m simpos m m traces tracet fname xm m simname m m foreach m n2methseqsandm ninmethseqt do fctxt xm m xn n simctxt m n m n traces tracet fctxt xm n xn m simctxt m n n m traces tracet let the setfdenote the factors gathered above.
letj xa a xa b xb a xb b xa ab xb ab q f2ff.
use factor graphs to obtain marginal probabilities for each xm mfromj.
algorithm subroutines invoked by algorithm .
simcount m m traces tracet begin relcount m occurences of mintraces length traces relcount m occurences of mintracet length tracet return min relcount m relcount m relcount m relcount m end simpos m m traces tracet begin relpos m relative positions of mintraces relpos m relative positions of mintracet avgrp m average of values in relpos m avgrp m average of values in relpos m if the values in the array relpos m are within a threshold of the trace length of avgrp m and likewise for relpos m and avgrp m then return min avgrp m avgrp m avgrp m avgrp m else return undecided the value of undecided is .
end simname m m begin if mandmare individual methods then return levenshtein .ratio m m else return undecided end simctxt m n m n traces tracet begin relcount m n occurences of min preceding context of nintraces length traces relcount m n occurences of min preceding context of nintracet length tracet relcount n m occurences of nin preceding context of mintraces length traces relcount n m occurences of nin preceding context of mintracet length tracet ifapproxmatch relcount m n relcount m n and approxmatch relcount n m relcount n m then return high we configued high to be .
else return high .
end the joint probability distribution as the product of these factors.
of course these factors are not comprehensive i.e.
there may be other factors that influence the value of j. rosetta can naturally accommodate any new factors they are simply treated as additional factors in the product.
rosetta s trace analysis computes four families of factors one each for the four attributes.
it combines them and uses them for probabilistic inference of likely mappings as shown in algorithm .
call frequency ffreq .the intuition underlying this factor is that if mmaps to m where mandmare individual methods or method sequences then the frequency with which they appear in functionally similar traces must match.
thus wecompute the relative count of mand mas the number of times that they appear normalized by the corresponding trace length.
we then use the ratio of relative counts of mandmto compute ffreq.
this is described in the subroutine simcount shown in algorithm .
call position fpos .we observed in our experiments that certain api methods and sequences appear only at specific positions in the trace.
for example api methods that initialize the screen or game state appear only at the beginning of the trace.
to identify such methods and sequences we use a similarity metric that determines the relative position of the appearance of the method call or call sequence in the trace i.e.
its o set from the beginning of the trace normalized by the trace length.
of course there may be multiple appearances of the method call or sequence in the trace so we average their relative positions.
in this factor we restrict ourselves only to calls and sequences that are localized in a certain portion of the trace i.e.
if the relative positions are not within a threshold of the trace length of the average this factor does not contribute positively or negatively to the likelihood of the mapping undecided is a probability of .
.
this is described in the subroutine simpos in algorithm .
method names fname .we use the names of methods in the source and target apis to determine likely mappings.
unlike the other factors which are determined by trace structure i.e.
program behavior this is factor relies on a syntactic feature.
the simname subroutine in algorithm uses a ratio based upon the levenshtein edit distance computed using a standard python library .
this ratio ranges from for identical strings to for strings that do not have a common substring.
simname only returns a valid ratio for individual methods for sequences it returns undecided .
call context fctxt .we define the context of a method call a in a trace as the set of method calls that appear in the vicinity of a .
likewise the context of a sequence a b is the set of method calls that appear in the vicinity of this sequence if it exists in the trace .
considering context allows us to propagate beliefs about likely mappings.
recall the example presented in xiii where considering the frequency of the method calls a b a and b alone does not allow precise inference of mappings.
in that example the context of the calls allows us to infer that if xa bistrue then xb ais unlikely to be true.
of the four factors that we consider fctxt is the only one that relates pairs of random variables the others assign probabilities to individual random variables.
we define the context of a method call or sequence m in the trace as the set of method calls and sequences that appear within a fixed distance kofmin the trace in our prototype k .
when computing the context of m we also consider whether the entities its context precede mor follow m. to compute context as a factor we use the function simctxt which considers all pairs of methods and method sequences m n that appear in the source trace and all pairs m n that appear in the target trace.
we then count the number of times mappears in the preceding contextofnin the source trace i.e.
within k calls preceding each occurence of n and normalize this using the trace length relcount m n likewise we compute relcount n m and the corresponding metrics for the target trace.
we then check whether relcount m n matches relcount m n and relcount n m matches relcount n m we do not require the relative counts to match exactly rather their di erence should be below a certain threshold in our prototype approxmatch encodes this matching function.
if both the counts match then the factor fctxt xm m xn n positively influences the inference that if xm mistrue then xn n is also true and vice versa.
the simctxt function ensures this by returning a high probability value.
likewise if the counts do not match fctxt xm m xn n would indicate that xm mandxn n are unlikely to be true simultaneously.
note that this does not preclude xm morxn nfrom being true individually.
intuitively the boolean interpretation of fctxt xm m xn n is xm m xn n .
in our prototype we set the value of high as .
.
we conducted a sensitivity study by varying the value of high between .
and .
and observed that it did not significantly change the set of likely mappings output by rosetta.
to illustrate the context factor consider again the example fromxiii.
there simctxt a b a b would be high while simctxt a b b a would be high using exact matches forrelcount instead of approxmatch to ease illustration .
therefore we can infer that xa aandxb bcould both be true but that xa bandxb aare unlikely to be true simultaneously.
we implemented rosetta s trace analysis and factor generation algorithms in about lines of python code.
we used the implementation of factor graphs in the bayes net toolbox bnt for probabilistic inference.
rosetta generates one factor for each boolean xm mfor each of the three factor families ffreq fpos fname .
letting sand tdenote the number of unique source and target api calls observed in the trace there areo s2t2 such boolean variables because mandminclude individual methods and method sequences of length two .
likewise rosetta generates two fctxt factors for each pair m n and m n resulting in a total of o s4t4 factors.
we restricted rosetta to work with method sequences of lengths one and two because of the rapid growth in the number of factors.
future work could consider optimizations to prune the number of factors thereby allowing inference of mappings for longer length method sequences.
c. combining inferences across traces as discussed so far we apply probabilistic inference to each trace pair which results in di erent values of pr xm m true for each boolean variable xm m. in this step we combine these inferences across the entire database of trace pairs.
one way to combine these probabilities is to simply average them.
however if we do so we ignore the confidence that we have in our inferences from each trace pair.
the more occurrences we see of a method call or sequence min a source trace the more confidence we have in the values of pr xm true .
therefore we compute a weighted average of these probabilities with the relative count of each source call as the weight.game traces javame traces android traces factor graphs avglen maxlen avglen maxlen maxnodes maxedges backgammon blackjack bubblebreaker checkers chess four in a row freecell hangman mahjongg v1 mahjongg v2 memory minesweeper roulette rubics cube scrabble simpledice snake soltaire sudoku tetris tictactoe fig.
.
statistics of traces and factor graphs for various javame and android games.
the actual runtime traces of the games are filtered to leave only javame and android graphics api calls.
we report the average and maximum lengths of these filtered traces.
for each game we also show the size of the largest factor graph across all its traces.javame class methods top totvalid top alert canvas command display displayable font form game.gamecanvas game.layer game.sprite graphics image list textfield total fig.
.
results of applying rosetta to the traces obtained from the games shown in figure .
we have shown the number of unique javame methods categorized by class for which rosetta inferred at least one valid mapping in the top ten top10 and the total number of valid mappings found in the top ten totvalid .
also shown is the number of javame calls for which rosetta s top ranked inference was a valid mapping top .
see also figure and figure for a more detailed rank distribution of mappings.
pr xm m true combined p traces relcount m pr xm m true p traces relcount m we chose this approach because of its modularity.
as we collect more trace pairs and inferences from them we can combine them with mappings inferred from other traces in a straightforward way using the weighted average approach.
alternatively we could have chosen to concatenate individual traces in the same order for both components of each trace pair to produce a super trace and perform probabilistic inference over this super trace.
however if we do so then we would have to reproduce the super trace after each new trace pair that is collected and execute the inference algorithm over the ever growing super trace.
this approach is neither memory e cient nor time e cient.
in contrast our weighted average approach provides more modular support to add inferences from new trace pairs as they become available.
this weighted average is presented to the user as the output from rosetta.
we present the output of rosetta to the user in terms of the inferred mappings for each source api call.
for each source api method or method sequence we present a list of mappings inferred for it ranked in decreasing order of the likelihood of the mapping.
v .
e valuation a. methodology to evaluate rosetta we collected a set of javame applications for which we could find functionally equivalent counterparts in the android market.
in particular we chose board games for two reasons.
first many popular board games are available for both the javame and android platforms.
checking the functional equivalence of two games is as simple as playing the games and ensuring that the moves of the game are implemented in the same way on both versions.
second the use of board games also eases the task of collecting trace pairs.
moves in board games are easy to remember and can be repeated on both game versions to produce functionally equivalent traces on both platforms.note that a pair of functionally equivalent games on javame and android could di er in the features that they implement.
however when tracing these games we restrict ourselves to the subsets of features that are common to both games.
to collect traces we ran javame games using the emulator distributed with the sun java wireless toolkit version .
.
.
for android games we used the emulator that is distributed with the android .
sdk.
figure shows the games that we used the number of trace pairs that we collected for each game and the sizes of the traces for the javame and android versions.
we ran rosetta on these traces to obtain a set of likely mappings.
this set is presented to the user as a ranked list of mappings inferred for each javame method or method sequence .
to evaluate the list associated with each javame method we consulted the documentation of the javame and android graphics apis to determine which members of the list are valid mappings.
b. quality of inferred mappings figure presents the results of running rosetta on the traces that we collected.
this figure shows the number of distinct javame methods that we observed in the trace grouped by the parent javame class to which they belong.
thus for example there were four unique javame methods belonging to the alert class in our traces namely alert.setcommandlistener alert.setstring alert.settype and alert.settimeout .
in all there were unique javame methods in our traces.
for each of these javame methods we determined whether the top ten ranked mappings reported for that method contained a method or method sequence from the android api that would implement its functionality.
when interpreting rosetta s output for a javame method we mark a method sequence from the android api as a valid mapping even if it is only a subsequence of a longer method sequence that implements the javame method s functionality.
we did so because rosetta currently only supports inference of mappings with method sequences up to length two.
as reported in figure we found such valid mappings for of the observed0 number of javame methods rank of first valid mapping fig.
.
this figure shows the rank distribution of the first valid mapping found for each javame method.
in all for each of javame methods a valid android mapping appeared within the top ten results reported for that method.
for javame methods the top ranked mapping was a valid one.
number of valid mappings found rank of valid mappings fig.
.
this figure shows the rank distribution of all valid mappings found by rosetta.
for each rank it shows the number of valid mappings that appear at that rank across all javame api methods observed in our traces.
in all we found valid mappings ranking in the top ten.
javame methods .
figure depicts in more detail the rank distribution of the first valid mapping found for each of these javame methods.
the top ranked mapping for of these methods was a valid one.
recall that a javame method can possibly be implemented in multiple ways using the android api.
thus the ranked list associated with that method could possibly contain multiple valid mappings.
rosetta s output contained a total of valid mappings within the top ten results of the javame methods.
figure depicts the rank distribution of all the valid mappings found by rosetta.
below we illustrate a few examples of mappings inferred by rosetta the graphics.cliprect method in javame intersects the current clip with a specified rectangle.
rosetta correctly inferred the android method canvas.cliprect as its topranked mapping.
in javame graphics.drawchar draws a specified character using the current font and color.
in rosetta s output the sequence paint.setcolor canvas.drawtext which first sets the color and then draws text was the second ranked mapping forgraphics.drawchar .
the graphics.drawrect javame method was mapped to the android methods canvas.drawrect rank and canvas.drawlines rank all of which can draw rectangles.
c. impact of individual factors variant valid ffreq62.
fname .
fpos .
ffreq fctxt .
ffreq fname .
ffreq fpos .
fig.
.
studying the impact of various combinations of factors.rosetta s output is the result of combining all the four factors discussed inxiv b. we also evaluated the extent to which each of these factors contributes to the output.
to do so we constructed factor graphs using the traces in figure individually with ffreq fpos and fname .
because fctxt correlates two mappings we did not consider it in isolation.
we also considered a few combinations of factors to study how the mappings change as factors are added.
we inferred mappings with these factor graphs and compared the resulting mappings with those obtained by rosetta.for each factor graph variant in figure we report the fraction of rosetta s valid mappings that correspond to a valid mapping inferred by the variant.
as we did with rosetta we only report valid mappings that rank in the top ten in the output of these factor graph variants.
as figure shows the addition of more factors generally improves the accuracy of the reported mappings.
this is because the addition of more factors incorporates more trace features into the probabilistic inference algorithm thereby removing spurious mappings.
d. runtime performance we ran rosetta on a pc with an intel core2 duo cpu running at .80ghz and 4gb memory running ubuntu .
.
for each of the traces reported in figure rosetta took between minutes to analyze traces and output mappings.
on average approximately of this time was consumed by the algorithms in xiv b which produce factor graphs and was consumed by the factor graph solver.
the solver consumed 2gb memory for the largest of our factor graphs.
as discussed rosetta currently supports inference on method sequences of length up to two.
we also configured rosetta to work with longer method sequences which would produce larger factor graphs.
however the factor graph solver ran out of memory in these cases.
e. experiments with microemulator there have been some recent e orts to allow the execution of legacy javame applications on the android platform.
microemulator is one such open source tool that works on javame applications.
it rewrites javame api calls in the input application with the corresponding android api calls.
the implementation of microemulator therefore implicitly defines a mapping between the javame and android graphics apis.
however microemulator does not translate the entire javame graphics api and only allows javame applications with rudimentary guis to execute on android devices.
nevertheless the mappings that it does implement provide a basis to evaluate rosetta.
we considered a subset of five javame games from figure that microemulator could successfully translate chess minesweeper snake sudoku tictactoe executedthem and collected the corresponding traces of javame api calls.
we then repeated the same set of experiments on the microemulator converted versions of these applications and collected the corresponding traces of android api calls and fed these trace pairs to rosetta.
in our evaluation we determined whether the api mappings inferred by rosetta contained the mappings implemented in microemulator.
across the javame traces for these five games we observed distinct javame graphics api methods translated by microemulator.
in rosetta s output we found at least one valid mapping for of these javame methods within the top ten ranked results for the corresponding javame method.
rosetta only failed to discover an api mapping for the javame method alert.setstring .
out of javame methods with valid mappings methods had valid top ranked mappings to their android counterparts.
f .
threats to validity there are a number of threats to the validity of our results which we discuss now.
first although we attempted to find javame and android games that are functionally equivalent di erences do exist in their implementations.
this is because javame is an older mobile platform that does not support as rich an api as android many android calls do not even have equivalents in javame.
together with randomness that is inherent in certain board games xiv a this could result in traces which contain android calls implementing functionality unseen in the source application.
they may mislead the attributes used by our inference algorithm e.g.
frequency of calls leading to both invalid mappings as well as valid mappings being suppressed in the output.
second there is no ground truth of javame to android mappings available to evaluate rosetta s output the mappings in microemulator aside as a result of which we are unable to report standard metrics such as precision and recall.
we interpreted rosetta s results by consulting api documentation.
such natural language documentation is inherently ambigious and prone to misinterpretation.
we mitigated this threat by having two authors independently cross validate the results.
finally a threat to external validity i.e.
the extent to which our results can be generalized comes from the fact that we only inferred mappings for a pair of graphics apis using board games.
it is unclear how many mappings we would have inferred using other graphical applications e.g.
o ce applications or for other families of apis.
vi.
r elated work an upcoming survey article by robillard et al.
provides a good overview of prior work on mining api mappings.
among these the work most directly related to ours is the mam project .
mam s goal is the same as rosetta s i.e.
to mine software repositories to infer how a source api maps to a target api.
the mam prototype was targeted towards java as the source api and c as the target api.
despite sharing the same goal mam and rosetta di er significantly in the approaches that they use each with itsadvantages and drawbacks.
to mine api mappings between a source and a target api mam relies on the existence of software packages that have been ported manually from the source to the target platform.
for each such software package mam then uses static analysis and name similarity to align methods and classes in the source platform implementation with those of the target platform implementation.
aligned methods are assumed to implement the same functionality.
mam s use of static analysis allows it to infer a large number of api mappings about mappings between java and c .
it also allows mam to infer likely mappings between arguments to methods in the source and target apis which rosetta does not currently do.
however unlike rosetta mam requires that the same source application be available on the source and target platforms.
mam s approach of aligning classes and methods across two implementations of a software package does not allow the inference of likely api mappings if there are similar but independently developed applications for the source and target platforms.
mam s approach is also limited in that it uses name similarity as the only heuristic to bootstrap its api mapping algorithm.
in contrast rosetta uses a number of attributes combined together as factors and can easily be extended to accommodate new similarity attributes as they are designed.
most importantly while mam uses a purely syntactic approach to discover likely api mappings rosetta s approach uses similarities in application behavior .
nita and notkin develop techniques to allow developers to adapt their applications to alternative apis.
they provide a way for developers to specify a mapping between a source and a target api following which a source to source transformation automatically completes the transformations necessary to adapt the application to the target api.
rosetta can potentially complement this work by inferring likely mappings.
androider is a tool to reverse engineer application guis.
androider uses aspect oriented programming techniques to extract a platform independent gui model which can then be used to port guis across di erent platforms.
while androider provides a gui for a target platform by analyzing guis of a source platform at runtime rosetta instead infers api mappings and is not restricted to gui related apis.
bartolomei et al.
analyzed wrappers between two java gui apis and extracted common design patterns used by wrapper developers.
they focused on mapping object types and identified the challenges faced by wrapper developers.
method mappings given by rosetta can possibly be used along with their design patterns to ease the job of writing wrappers.
a number of prior projects provide tool support to assist programmers working with large evolving apis e.g.
.
the programmer s time is often spent in determining which api method to use to accomplish a particular task.
these projects use myriad techniques to develop programming assistants that ease the task of working with complex apis.
rosetta is complementary to these e orts in that it works with cross platform apis .
a related line of research is on resources for api learning e.g.
.
these projects attempt to easethe task of a programmer by synthesizing api usage examples evolution of api usage and extracting knowledge from api documentation.
again most of these techniques work on apis on a single platform.
rosetta s cross platform approach can possibly be used in conjunction with these techniques to facilitate cross platform api learning.
finally rosetta s probabilistic inference approach was inspired by other uses of factor graphs in the software engineering literature.
merlin uses factor graphs to classify methods in web applications as sources sinks and sanitizers.
such specifications are useful for verification tools which attempt to determine whether there is a path from a source to a sink that does not traverse through a sanitizer.
to infer such specifications merlin casts a number of heuristics as factors and uses belief propagation.
kremenek et al.
also made similar use of factor graphs to infer specifications of allocator and deallocator methods in systems code.
factor graphs are just one approach to mining specifications a number of prior software engineering projects have considered other mining techniques e.g.
.
future work could consider the use of such techniques in rosetta as well.
vii.
s ummary and future work we presented a generic approach to infer mappings between the apis of a source and target platform.
our rosetta prototype used this approach to infer likely mappings between the javame and android graphics apis.
while we are encouraged thus far by the success of rosetta future work could extend it in a number of ways to overcome its current shortcomings.
mapping method arguments.
rosetta could be extended to also discover mappings between method call arguments.
to do so the tracing infrastructure must be extended to log method arguments and their types and new factors and inference techniques must be developed to map arguments.
mapping longer method sequences.
although our framework supports the inference of mappings between method sequences of arbitrary length we restricted the rosetta prototype to sequences of length two to limit the number of factors produced by our algorithms in xiv b. future work could investigate optimizations to prune the number of factors so that rosetta can scale to longer method sequences.
hybrid approaches.
rosetta s use of runtime techniques fundamentally limits the mappings inferred to only those source and target api methods that appear in the trace.
it may be possible to increase coverage using a hybrid technique that combines static analysis e.g.
mam with rosetta s trace based approach.
more platforms.
finally the rosetta prototype can be extended to work on larger subsets of the javame and android apis and also to infer mappings between other api pairs e.g.
ios and android .