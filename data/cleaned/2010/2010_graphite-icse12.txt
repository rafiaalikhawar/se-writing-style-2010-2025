active code completion cyrus omar youngseok yoon thomas d. latoza brad a. myers carnegie mellon university pittsburgh pa usa fcomar youngseok tlatoza bam g cs.cmu.edu abstract code completion menus have replaced standalone api browsers for most developers because they are more tightly integrated into the development workflow.
refinements to the code completion menu that incorporate additional sources of information have similarly been shown to be valuable even relative to standalone counterparts offering similar functionality.
in this paper we describe active code completion an architecture that allows library developers to introduce interactive and highly specialized code generation interfaces called palettes directly into the editor.
using several empirical methods we examine the contexts in which such a system could be useful describe the design constraints governing the system architecture as well as particular code completion interfaces and design one such system named graphite for the eclipse java development environment.
using graphite we implement a palette for writing regular expressions as our primary example and conduct a small pilot study.
in addition to showing the feasibility of this approach it provides further evidence in support of the claim that integrating specialized code completion interfaces directly into the editor is valuable to professional developers.
keywords code completion development environments i. i ntroduction software developers today make heavy use of the code completion support found in modern source code editors .
most editors provide code completion in the form of a floating menu containing contextually relevant variables fields methods types and other code snippets.
by navigating and selecting from this menu developers are able to avoid many common spelling and logic errors eliminate unnecessary keystrokes and explore unfamiliar apis without incurring the mental overhead associated with switching to an external documentation tool or api browser.
several refinements and additions to the code completion menu have previously been suggested in the literature.
these have focused on leveraging additional sources of information such as databases of usage history inheritance information api specific information partial abbreviations examples extracted from code repositories and crowdsourced information to increase the relevance and sophistication of the featured menu items.
as with the standard form of code completion many of these sources of data can also be utilized via external tools e.g.
calcite uses information that could already be accessed using the jadeite tool .
empirical evidence presented in these studies however suggests that directly integrating these kinds of tools into the editor is particularly effective.for example users of the calcite tool completed more tasks in a lab study unfortunately a jadeite control group was not included.
in all of these systems the code completion interface has remained primarily menu based.
when an item is selected code is inserted immediately without further input from the developer.
these systems are also difficult to extend a fixed strategy determines the completions that are available so library providers cannot directly specify new domain specific or contextually relevant logic.
in this paper we propose a technique called active code completion that eliminates these restrictions1.
this makes developing and integrating a broad array of highly specialized developer tools directly into the editor via the familiar code completion command significantly simpler.
this technique is motivated by the evidence discussed above and further evidence provided in this paper that developers prefer and make more effective use of tools that do not require leaving the immediate editing environment.
in this paper we discuss active code completion in the context of object construction.
for example consider the following java code fragment public color getdefaultcolor f return if the developer invokes the code completion command at the indicated cursor position the editor looks for a palette definition associated with the type of the expression being entered which in this case is color .
if an associated palette is found a menu item briefly describing this palette is added to the standard code completion menu.
when selected the corresponding palette is shown replacing the standard code completion menu.
figure 1a gives an example of a simple palette that may be associated with the color class2.
the developer can interact with such palettes to provide parameters and other information related to her intent and receive immediate feedback about the effect these choices will have on the behavior of the object being constructed.
when this interaction is complete the palette generates appropriate source code for insertion at the cursor.
figure 1b shows the inserted code after the user presses enter .
1portions of this work previously appeared in a poster abstract .
2a video demonstrating this process is available at natprog graphite.html.figure .
a an example code completion palette associated with the color class.
b the source code generated by this palette.
in accordance with best practices we sought to address the following questions before designing and implementing our active code completion system what specific use cases exist for this form of active code completion in a professional development setting?
what general criteria are common to types that would and would not benefit from an associated palette?
what are some relevant usability and design criteria for palettes designed to address such use cases?
what capabilities must the underlying active code completion system provide to enable these use cases and user interface designs?
to help us answer these questions we conducted a survey of professional developers section ii .
their responses along with information gathered from informal interviews and code corpus analyses revealed a number of non trivial functional requirements for palette interfaces as well as the underlying active code completion architecture section iii .
participants also suggested a large number of use cases demonstrating the broad applicability of this technique.
we organize these into several broad categories section iv .
next we describe graphite an eclipse plug in that implements the active code completion architecture for the java programming language section v allowing java library developers to associate custom palettes with their own classes.
we describe several design choices that we made to satisfy the requirements discovered in our preliminary investigations and briefly examine necessary trade offs.
finally we conducted a pilot lab study with a more complex palette implemented using graphite that assists developers as they write regular expressions section vi .
the study provides specific evidence in support of the broader claim that highly specialized tools that are integrated directly with the editing environment are particularly useful.
we conclude that active code completion systems like graphite are useful because they make developing deploying and discovering such tools fundamentally simpler.
ii.
s urvey to validate our general conceptualization of active code completion develop concrete criteria to constrain our systemand palette designs and create a list of use cases to justify this effort we began by conducting a large survey of professional software developers.
a. participants we recruited participants for this survey3primarily from a popular programming related discussion forum hosted on the popular website reddit.com .
an additional participants were computer science graduate students at cmu.
recruitment materials in both cases stated that we were seeking developers familiar with an object oriented programming language like java c or visual basic and an integrated development environment like eclipse or visual studio .
participants were told that the survey would take approximately minutes to complete and no reward was offered.
of the people who started the survey participants completed it.
we examine the responses from completed surveys only in the analyses below.
b. familiarity with programming languages and editors we first asked participants about their level of familiarity with several programming languages on a five point likert scale4.
.
of the participants indicated that they were an expert in at least one language and an additional .
were very familiar with at least one language.
on average participants rated themselves as very familiar with java c c and javascript familiar with c python and php and somewhat familiar with visual basic and perl.
we also asked participants to select which integrated development environments ides and code editors that they were familiar with.
the eclipse ide was familiar to .
of participants.
this was followed by visual studio at .
vi vim at .
netbeans at .
emacs at .
and intellij idea at .
.
participants could also enter other choices and a number of editors and ides were entered including xcode textmate and notepad .
none somewhat familiar familiar very familiar expert regular expressions sql separate test script .
.
guess and check .
.
external tool .
.
search for examples .
.
other .
.
figure .
distribution of responses to survey questions asking about typical strategies for writing regular expressions and sql queries.
class nearly every time most of the time some of the time rarely never color .
.
.
.
.
regexp .
.
.
.
.
sql .
.
.
.
.
figure .
the distribution of responses to the question consider situations where you need to instantiate the class.
what portion of the time in these situations do you think you would use this feature?
c. palette mockups we presented participants with a series of mockup palettes for a color class more complex than the one we ultimately implemented in figure 1a a regular expression class and a sql query class.
participants were also shown mockup screenshots demonstrating how a user could invoke the palette and a mockup showing the code that would be inserted once a selection had been made.
before presenting each mockup we gathered information about the strategies that they would normally use to instantiate the class.
for the color class the majority of participants indicated that they would look in the code completion menu .
or in the class documentation .
for a predefined constant if asked to instantiate an object corresponding to the color navy which is not in fact a standard color in java.
another .
indicated that they would use an external tool such as an image editor to determine the rgb values corresponding to the color.
before asking participants about regular expressions and sql queries we asked participants to rate their familiarity with these concepts.
few participants indicated that they were unfamiliar with regular expressions and no participants were unfamiliar with creating sql queries providing further evidence that our participants were not novice developers.
figure summarizes the strategies that participants generally preferred for instantiating regular expressions and sql queries.
using an external tool was a common strategy in both cases particularly for sql queries but several other strategies were also represented.
finally after showing the series of mockup screenshots we asked participants to rate how useful the integrated palette would be to them if they needed to instantiate the corresponding class.
the responses to this question for each palette are summarized in figure .
in each case morethan half of the participants indicated that they would use active code completion at least some of the time.
the regular expression palette was considered particularly useful while the color and sql palettes showed a more reserved pattern of responses.
in addition to asking for a simple rating for each palette we also solicited open ended comments.
a large number of participants volunteered comments for the color palette for the regular expression palette and for the sql palette.
these responses were highly valuable when developing the design criteria below and helped to explain the patterns observed in figure .
iii.
d esign criteria using the information gathered from the survey as well as informal discussions with developers and researchers we developed design criteria constraining both the overall system design as well as the design of individual palettes.
in the section headings below the number of survey responses summed over the three palette mockups that contained the listed concern as judged by the authors of this paper are listed in parenthesis.
these criteria were useful in designing graphite section v and we note that this collection of criteria may also be relevant to researchers designing other kinds of editor integrated tools.
based on the variety of concerns expressed by participants in our survey the design space for these tools appears to be quite complex.
a. maintaining separation of concerns the most common issue participants had was that palettes seemed to violate the principle of separation of concerns.
the color palette for example allows developers to insert color constants directly into the program logic.
many developers noted that this is considered bad practice or should be limited to the prototyping phase of a project.
this concern was also expressed in responses to the sql palette which required inserting parameters to connect to a database so that the query could be tested.
the resulting code included initialization steps needed to connect to the specific database that was entered and several participants noted that much of this information should appear in an external resource file separated from the program logic.
few participants made similar comments about the regular expression palette however indicating that regular expressions are considered a part of the program logic rather than data by most developers.
this suggests that tool and palette designers may wish to explicitly aprise users of relevant best practices and acknowledge that palettes that generate constant data may be most useful in the prototyping phase.
it can be noted that when transitioning from a prototype to production quality software the code generated by a palette or tool may be used as template to be refactored as needed.
it also suggests that resource file and stylesheet editors may particularly benefit from active code completion support.b.
integration with testing frameworks the regular expression palette shown to the participants allowed users to immediately test a pattern against provided strings.
these test strings and the results of performing the match were inserted as comments below the generated source code.
a number of participants requested that unit tests be generated instead likely due to concerns that future modifications might introduce bugs or due to the desire to conform to standard testing practices.
to support the generation of unit tests the active code completion architecture would need to support code generation at locations other than at the cursor.
c. support for reinvocation several participants asked for the ability to reinvoke a palette from previously generated source code.
in order to support this feature the architecture must provide the palette with enough information to reconstruct its state.
to complicate matters however users may wish to modify the generated code between invocations of the palette and have these modifications reflected in the palette s state upon reinvocation e.g.
modify the rgb values in the case of the color class .
moreover there may be important aspects of the palette s state that are not directly available in the generated code such as parameters controlling the palette s user interface.
indeed associating tool related metadata with code is known to be cumbersome in purely textual languages since all metadata must be directly visible within comments or annotations.
d. support for palette settings and history a related feature important to many participants was support for maintaining settings and usage history across invocations of the same palette at different code locations.
for example participants requested that the color palette include a list of recent or favorite colors and participants inquired about whether the database connection information was maintained between invocations of the sql palette.
e. support for nested expressions in all of the examples that we gave the parameters entered into the palette interface corresponded to simple constant expressions rather than complex expressions referring to variables from the surrounding context.
a number of participants noticed this limitation.
for example several participants asked sql query strings as these are typically constructed using user generated data in practice.
although a simple expression entry box may suffice in simple scenarios architectural support is needed for palettes that need to inspect the code context e.g.
to verify well formedness or if code highlighting code completion and other advanced editing features are needed within the palette itself.f .
keyboard navigability although our mockup screenshots did not include any completely mouse driven interfaces several participants commented that the color palette included interface elements taken from standard color dialog boxes that could only be manipulated using the mouse.
these comments were generally severe in their condemnation of mouse based interfaces in developer tools consistent with our finding that a significant portion of our participants were using editors like vim that place a strong emphasis on keyboard shortcuts.
g. responsiveness a common theme in our discussions with developers as well as in comments left on our recruitment thread was that integrated development environments like eclipse were already too slow and that an extension such as the one we were proposing would only be acceptable if it did not affect performance and responsiveness any further.
h. ide and language portability the mockups we showed users were based on the java and the eclipse ide.
as we showed a number of participants preferred other languages or editors.
many of these participants made comments asking that the features we describe be ide and programming language independent.
indeed the palettes we demonstrated could be used with only slight modifications in a variety of programming languages given suitable architectural support for porting palettes between editing environments.
i. varying user needs while some participants wanted simpler palettes others requested significant new capabilities indicating that user needs may vary substantially.
for example our initial color palette different from the one shown in figure was deemed overly complex by many participants .
other users wanted additional features such as an eyedropper tool for selecting a color directly from an image on the screen.
the regular expression and sql palettes were considered too simple by and participants respectively .
users suggested syntax highlighting several mechanisms for generating testing and sharing regular expressions and queries and the ability to browse sql databases.
due to this wide range of user needs even for a single class it may be that support for multiple palettes or a tabbed palette interface would be helpful in practice.
to support incremental improvements based on such user feedback an architecture that makes deploying new and updated palettes relatively painless would also be valuable.
iv.
u secases at the end of the survey we asked the the participants to suggest other classes that could benefit from an associated palette to support our claim that active code completionis broadly applicable and to allow us to characterize the specific scenarios where it may be most useful.
a total of participants made one or more suggestions which we classified into several broad categories we omit a few of these below due to space constraints .
as above the number of participants suggesting a palette in each category is listed in parenthesis.
we also include suggestions made by researchers and developers in private discussions without including them in the provided counts.
a. graphical elements the most popular suggestions were graphical elements influenced perhaps by our demonstration of the color palette.
some participants suggested palettes for classes representing primitive graphical objects such as brush and font selectors or polygon editors while other participants were focused on user interface elements such as buttons check boxes and frame layouts.
a few also suggested palettes for manipulating 3d primitives such as transformation matrices in a more direct and intuitive manner.
a practitioner also suggested that because setting up a plot or graph is often significantly simpler using a direct manipulation interface it would be a natural candidate for a palette as well.
b. query languages the second most popular category of suggestions consisted of various interfaces for query languages also likely due to the examples we provided to participants.
in addition to variants of the sql and regular expression palettes developers also wanted to work with other types of queries such as xpath or xquery for xml.
c. simplified or domain specific syntax another interesting class of suggestions were cases where a more natural syntax than the syntax provided by java is desirable.
one suggestion was a palette that automatically escaped strings containing quotation marks or escape sequences.
a related category of suggestions consisted of palettes that offered a more natural interface for generating strings containing code in other languages such as html e.g.
offering syntax highlighting escaping tag matching and other features.
domain specific syntax for complex mathematical expressions and chemical formula were also mentioned in discussions with practitioners.
an interesting suggestion that we investigated further involved java s collection classes such as arraylist and hashmap .
a participant suggested that these classes could be associated with a palette that offered a simplified literal syntax for initialization pointing toward other languages that do offer such a literal syntax e.g.
javascript.
without such syntax these classes must be tediously initialized using a separate method call for each element.
to determine whether this usage pattern is common we conducted a corpus analysis using randomly selected projects from the qualitascollection class total literal percentage arraylist .
hashmap .
hashset .
hashtable .
vector .
total .
figure .
usage patterns for common java collection classes in the java.util package in our code corpus.
uses that fit a pattern that can be captured by a literal make up a significant portion of all uses.
not all possible usage scenarios of this type were captured by our analysis so these numbers are lower bounds.
corpus containing over 1m lines of code.
we began by searching for places in these projects where java collection classes were being instantiated then looked to see whether this instantiation code was immediately followed by method calls that inserted items into the collection indicating a case where a literal may have been used if available.
figure summarizes the results of this analysis providing evidence in support of the claim that a palette that simplifies this process could be useful for general purpose programming.
d. unclear parameter implications another category of use cases contains classes where it can be difficult to predict what the run time behavior of a particular parameter choice may be.
examples given included audio filters e.g.
pitch manipulation and animation descriptors e.g.
speed or shape parameters .
by giving immediate visual or auditory feedback using a preview panel these parameters can be tweaked without requiring the execution of the full application.
e. integrating with documentation and examples some participants suggested integrating tutorials or lists of relevant examples directly using a palette so that these can be discovered more easily by new users and inserted directly into code without requiring switching to a web browser and executing a search.
f .
complex instantiation and cleanup procedures a related category contains classes that require complex instantiation and cleanup procedures.
for example in order to read a text file in java the developer might want to usebufferedreader class.
this class can be difficult to use because it requires try catch block and one must remember to close the file after reading it.
by using a palette to choose a file or choose a variable which contains the file path the developers could easily instantiate these objects and get an outline containing the full life cycle of the file.
similarly palettes may help to alleviate the factory pattern usability problem .
as long as the developers remember which class to use they will not need to remember how to instantiate that class.
we explore this further in our user study in section vi.g.
instantiation by example in some cases it is possible to describe an object by example.
for instance a class that represents a shortcut key combination may be most easily instantiated using a palette that simply reads a shortcut key from the developer.
h. proof assistants a proof assistant is a tool for constructing proof terms.
according to the well known curry howard isomorphism between programming languages and formal logics proof terms correspond to expressions and propositions correspond to types .
active code completion works directly with types to help developers construct expressions so if applied to a language with a cleanly developed connection to formal logic e.g.
coq palettes would be useful for constructing interactive proof assistant interfaces.
v. s ystem design and implementation after completing the survey we built an active code completion system named graphite an acronym for graphical palettes to helpinstantiate types in the editor.
we chose to build the system as an extension to eclipse for java because this combination was the most widely used amongst participants in our survey.
in the subsections below we describe how several novel design decisions made it possible to satisfy design criteria from section iii and enabled several use cases described in section iv .
the end result is a simple system that allows an api s developers as well as external developers to build rich html5 based palettes that can be associated with both in built and user defined classes directly.
developers using an api can discover and invoke these palettes through the standard code completion menu.
a. html5 based palettes palette developers build palettes using html5 technologies html css and javascript .
we made this decision for several reasons.
eclipse is written in java and uses the swt and jface graphical user interface toolkits but these are not widely used outside of the eclipse ecosystem.
javascript was among the most well known languages in our study just behind java c and c and is highly flexible.
a number of useful libraries are available e.g.
jquery .
as noted in section iv h a number of participants in our field study indicated that they hoped that our tool would be available for other ides and other programming languages.
all major windowing toolkits feature a web browser control so html5 based palettes can easily be loaded by different editor environments without developer intervention.
deploying palettes using standard urls is also simpler than attempting to integrate them directly into java libraries and packages.
it also eases the process of incremental and rapid development as all major browsers now feature sophisticated debuggers and run time inspection facilities.b.
palette api palettes communicate with the host ide using a simple javascript api.
to access this api the palette must include a small script named graphite.js into their page.
the default implementation of this script provides an implementation of the api methods for testing in a standard web browser.
when loaded into an editor the editor plug in replaces these methods with specialized implementations.
the api consists of the following methods accessed through a global object named graphite insert str inserts the specified string at the cursor and closes the palette.
the indentation is automatically inserted after any newlines in this string.
cancel closes the palette without inserting code.
note that the esc key cancels by default and palettes are modal so clicking outside a palette will not cancel.
getselectedtext returns the text that is currently selected in the editor or an empty string if no text has been selected.
this method is used to implement reinvocation users simply select previously generated code and invoke the palette as described in section i. the palette is responsible for parsing the selected text to extract relevant parameters.
getide getlanguage return a string that specifies the ide and language that is being used eclipse and java in our implementation.
by limiting the complexity of this api we reasoned that developers would be able to create specialized palettes more easily.
a simple hello world palette is only two lines of code for example.
an additional benefit is that the developers of other editing environments should also be able to create plug ins that support graphite palettes with minimal effort.
c. palette discovery graphite currently provides two methods for associating a palette with a particular class so that the editor plug in can include it in the code completion menu when relevant.
annotation based for user defined classes that the palette developer has the authority to modify the graphitepalette annotation associates a palette with the class.
the annotation must specify the url of the palette and can contain some other optional information e.g.
the description that is shown in the code completion menu .
this allows api providers to provide palettes that are specialized to their libraries and distribute them directly alongside their code.
the benefit of this approach is that users of the api are not required to discover that an external tool exists and explicitly install it into their ide.
explicit in cases where a palette developer cannot modify a class directly such as palettes for classes in the java standard library end users can explicitly associate a palette with the fully qualified name of a class via a preference pane in the eclipse ide.figure .
the regular expression palette developed using graphite and used by subjects in the treatment group of the user study described in sec.
vi.
d. design trade offs the design that we have described is light weight highly flexible and does not significantly impact ide responsiveness.
it also lays foundations for ide and language portability.
however this design also leads to trade offs because palettes are implemented in javascript any differences between the semantics of java and javascript can be problematic.
for example color names are slightly different between java and javascript as are the regular expression engines.
although a java applet could be used in cases where these differences are critical this is still more difficult than it would be if the palettes were implemented in the same language.
the palette user interface must stay within its bounding box user interface elements like pop up menus unless they are provided by the browser itself are thus more difficult to implement and may require additional api support in the future.
several use cases could benefit from greater access to the surrounding code or even the surrounding project.
implementing this modularly is particularly difficult and the eclipse api does not easily allow for serialization of the sum of its contextual knowledge for consumption by a palette.
because the reinvocation mechanism relies on parsing the selected code the burden is high for both palette developers although javascript libraries for parsing java code are available and palette users.
a better solution would be one where palette related metadata is stored directly with the generated code.
this could be partially addressed by the use of special comments to delimit sections of generated code and store palette metadata but a more elegant solution would require a change in how java source code is represented.
e. palettes we implemented two palettes using the jquery library for basic functionality which we used in the pilot study described below.
color selection the color selection palette we ultimately developed was significantly simpler than the one shown in the preliminary survey due to user comments.
it allows users to enter any valid css color string satisfyingthe requirements for keyboard navigability.
the entered color is syntax checked and a preview is shown.
standard java colors are also available as swatches that can be selected by the mouse if desired.
reinvocation support is provided.
this palette took about lines of code and markup not including the jquery library.
much of this was needed to translate arbitrary css color strings into rgb values rather than for user interface logic.
regular expressions writing correct regular expression patterns is difficult.
the regular expression palette associated with the pattern class in the java standard library allows users to enter and test regular expression patterns interactively before inserting them into their code.
the focal point of this palette is the pattern input area.
as the user enters a pattern into this input area syntax errors are indicated with a red background the background remains white when the pattern is valid.
in addition to the pattern a regular expression consists of flags that can change its matching behavior in various ways.
our palette allows users to toggle the case sensitivity flag of the regular expression using a small checkbox labeled ignore case placed next to the input area.
a keyboard shortcut is also available indicated using the underlined letter ctrl i .
to allow users to test the behavior of the regular expression that they have entered two columns are available below the expression input area.
the left column contains an input area labeled should match... and the right column contains an input area labeled should not match... .
users use these to enter lists of test strings into each column.
the background colors behind these strings change to indicate whether the regular expression that has been entered matches or does not match that string.
green indicates that the pattern matched the string and red indicates that it does notmatch regardless of the column that the test is in this scheme was chosen based on feedback from an initial pilot of this palette the results of which are not included below.
a key describing this color scheme is displayed after the first test has been entered not shown above see video .
users can navigate the palette using the keyboard using standard tab cycling behavior.
the label in each text area remains visible until some input has been entered rather than disappearing immediately on focus.
when a user is satisfied with the regular expression that they have entered she can press the enter key to insert the appropriate java source code.
because java requires that the regular expression pattern be placed inside a string literal additional escape sequences are needed in front of backslashes.
this can be tedious and error prone if done manually.
the palette automatically inserts these escape sequences.
in addition to the source code itself the tests are retained in a comment beginning on the next line.
if the user wishes to modify the regular expression or change the test set she can highlight the code that was inserted and then invoke the palette once again.
the palette parses the selected text to extract the regular expression and tests.
this palette required about lines of code and markup.
vi.
p ilot study we conducted a small controlled pilot study to evaluate the usefulness and usability of the graphite system for a specific development task writing regular expressions and found significant benefits for the treatment group.
a. study methods between subjects design we used a between subjects design by randomly assigning the participants to either the control group or the treatment group.
in the control group subjects were not shown or able to use any palettes.
in the treatment group subjects were shown the simple color palette shown in figure and allowed to discover and use the regular expression palette shown in figure if they wished.
no specific training on the use of this palette was provided to simulate realistic usage scenarios.
we chose a between subjects design because a withinsubjects design would have required us to produce pairs of tasks with equal difficulties.
this turned out to be very challenging.
second we could not easily ignore a learning effect during the experiment if we had used a within subjects design.
we observed that this effect was quite strong as most subjects had not used regular expressions recently.
training only the participants in the treatment group were shown how to invoke graphite palettes in the context of an eclipse code editor with a palette for the color class.
we chose to demonstrate the tool using a color palette instead of the regular expression palette itself because we wanted to simulate the condition where a user had discovered the palette naturally.
the demonstration of the color palette was brief taking about two minutes.
we then described the nature of the task to the subject and allowed them to begin giving them minutes to complete all tasks in any order.
tasks there were a total of tasks to be completed in minutes.
the first tasks involved writing regular expressions to validate various data formats e.g.
temperatures and the remaining tasks involved writing regular expressions to retrieve data from a document.
the participants were allowed to move back and forth while the experiment and they were allowed to use anyexternal resources including the internet local console and so forth we did not observe any usage of programs other than the web browser however .
the only restriction we placed on their activity was that they were not allowed to directly search for the answer to a task online.
we omit descriptions of each individual question due to space limitations.
b. participants we recruited phd students from cmu.
the subjects were randomly assigned into two groups subjects were assigned to the control group and the other subjects to the treatment group.
there were six male participants and one female participant.
participants were compensated in the amount of dollars for their participation.
all subjects had prior experience with both java and regular expressions assessed using a preliminary survey similar to the one described in section ii.
of note the subjects in this study were slightly less skilled with java and regular expressions than in the previous survey.
this is consistent with the responses of the phd students who participated in the online survey who were also slightly less experienced on average.
the only other significant difference in responses was that the phd students were slightly less likely to prefer the use of external tools.
the difference in the case of regular expressions was .
c. hypotheses in designing the regular expression palette we had hypothesized that users would experience difficulties with two particular aspects of the java pattern api that it used a factory pattern for instantiation as opposed to the standard instantiation construct and that it required special care with escape sequences escape sequences in the pattern must themselves be escaped because the regular expression is written as a java string literal.
we observed difficulties with both of these issues in the control group but not in the treatment group.
the treatment group also completed more tasks than the control group on average vs. .
the behaviors observed in these groups are described below.
d. preliminary reading all subjects were somewhat rusty on the details of the java pattern api.
after reading the prompt for the first task all subjects began by searching for and reviewing documentation related to regular expressions.
in all but one of these cases the subject looked at the api documentation for the java pattern class during this initial review.
the remaining subject a member of the control group referred to quick reference documentation provided by an external tool.
in all cases the documentation was left accessible in a browser window throughout the study often displayed simultaneously alongside the coding window due to the large screen available for the study.e.
control group in our previous online survey we had found that no single strategy for writing regular expressions dominated the others.
we observed each of the common strategies use of external tools test scripts and guess and check.
one subject began by using an external tool called regexpal.com.
after writing a full regular expression and attempting to test it using the tool the subject became dissatisfied with it and switched to a different tool regextester.com.
this tool too appeared to be unsatisfactory as all subsequent tasks were performed without the aid of external tools or tests.
the other subjects chose to write their regular expressions directly within eclipse from the beginning.
one of these subjects never compiled or checked the accuracy of the regular expressions beyond making sure eclipse errors were addressed while the other two attempted to write java stubs within the test files to test the regular expression that they had written.
they experienced considerable difficulty with this task with one subject taking over minutes to write the test code.
the code could only check one example at a time and the subject used it to check a single positive example per task.
one of the four control subjects tried the new pattern construct.
an eclipse error alerted the subject to the problem shortly thereafter.
after referring to an example in the inline api documentation for the class the subject was able to correct this error.
the remaining subjects all noticed this example beforehand and were able to avoid this problem.
three of the four control subjects experienced significant difficulties associated with escape sequences.
one subject recognized the error fairly quickly after eclipse complained that the escape sequences used in the pattern were invalid they were in fact valid escape sequences for regular expression patterns but not for string literals.
the subject continued to miss escape sequences occasionally throughout the remainder of the study but was able to fix them quickly after eclipse alerted the subject to the error.
for the other two subjects the problem was more severe.
in both cases they noticed the error that eclipse gave but thought it indicated a problem with their pattern itself.
one subject thought that the uses of symbolic escape sequences like were incorrect.
he decided to replace these with ascii escape sequences after looking up an ascii conversion table.
this was an unnecessary and overly complex solution to the problem.
the other subject thought that the problem was in his use of the whitespace escape sequence s. thus he spent several minutes looking up how to match whitespace correctly.
in so he found a description of the doubleescape problem in java and fixed the problem after that.
f .
treatment group one subject was already familiar with an external tool regexpal.com also used by a subject in the control group and used it variously throughout the task.
in most cases thesubject used the external tool s quick reference documentation while using our palette for authoring and testing.
at other times the subject used the external tool itself.
the subject indicated that in some cases he was not sure that our palette was free of bugs when something unexpectedly matched or did not match.
we did not observe any actual errors related to regex matching in our tool however.
and also because the external tool provided syntax and substring highlighting a useful feature for complex regular expressions.
when done with the external tool the subject pasted the pattern into our tool to generate the appropriate code.
as such the subject had no difficulties with escaping or factory pattern instantiation.
the other two subjects in the treatment group did not use any external tools.
both subjects decided not to use our palette for the first task likely because they forgot that it was available since they spent some time looking up api documentation after our initial demo with the color palette.
they both recognized the need for the factory pattern and also both had an initial error related to escaping that they were able to resolve before moving on.
one of these subjects also began to write tests within a main method.
beginning with the second task both subjects remembered that a palette may be available and were able to invoke it correctly.
they all recognized that the primary input box was where the regular expression should be entered and that the two other input boxes were for positive and negative tests respectively.
two of the subjects did not initially realize that multiple tests could be entered and that entering even a single test required pressing the enter key.
one subject never fully understood this relating after the study that he thought that the palette would notify him when he was done if the example that he had entered was not matched by the pattern.
the other subject was able to use the test case input boxes correctly after initial experimentation.
this was perhaps due to the wording of the prompts under these entry boxes enter a test case above .
this problem was corrected in a version of the palette developed following this study.
two of the subjects used the reinvocation feature of the palette but neither highlighted the test cases meaning that they had to enter new test cases every time they reinvoked the palette.
this may have been due to the fact that our example with the color palette involved only a single line of text unlike the example in figure .
the third subject never used this feature.
two of the subjects expressed confusion about the meaning of the green and red backgrounds on the test cases.
although we provided a key saying that green meant that pattern matches string the headings of the two columns match may have caused confusion.
we had changed the meaning of these colors due to feedback from our initial presentation of the tool soit is clear that regardless of the interpretation given some subjects were confused.
despite these difficulties however the basic functionality of the palette seemed to help all of the subjects.
none struggled with issues related to escaping and instantiation for example.
although the sample size is not large enough to make many quantitative judgements it was observed that the treatment group completed more of the tasks than the test group on average tasks for the treatment group vs. for the control group .
all of the subjects in the treatment group as well as members of the control group who were shown the palette after the study indicated that they felt that the palette was helpful and several provided specific suggestions for improvements.
g. threats to validity in addition to the small sample size and the sampling bias discussed earlier subjects in the treatment group may have been biased to use our features due to their novelty although two subjects did not use the palette until their second task .
we only tested a regular expression palette so other types of palettes may not necessarily be as useful and this palette had significant flaws that were corrected only after this study.
vii.
r elated work in addition to the code completion work discussed in the introduction some other research areas are related to active code completion.
a. active libraries we named this technique active code completion because of its relation to the general concept of active libraries .
active libraries are libraries that contain program logic that is invoked at either compile time or here design time.
b. visual languages because active code completion involves graphical user interface elements but ultimately generates textual source code representations it can be considered a hybrid approach that borrows interaction techniques from visual languages while remaining compatible with conventional programming languages.
this hybrid approach may help address some of the usability challenges previously associated with visual languages cf.
.
editing environments like barista and the rba editor also merge concepts from both text based and structured editors by allowing for alternative code representations within a relatively conventional layout.
barista provides the opportunity for rich type specific interfaces but it is an ide generation framework so new extensions require recompilation.
the rba editor focuses on code readability rather than new modes of interaction but new registrations can be added relatively easily.
both tools use a custom domain specific language which is likely to be unfamiliar to many users.in future work we hope to explore an extensible keyboard driven code generation based approach that leverages structured code representations to eliminate the difficulties associated with reinvocation and maintaining palette state described in this paper.
c. specific ide features there exist some ide features that have been specifically designed for certain types.
for example coderush and resharper have color dialogs that allow developers to launch a color picker directly from the code editor.
intellij idea has an inline regular expression palette driven by its intentions system as well .
however these ide specific features are hard coded user defined types cannot provide similar functionality.
recent versions of visual studio support user defined palettes associated with specific fields rather than classes of user interface widgets .
these are shown only in the property pane when using the graphical window layout editor.
viii.
c onclusion motivated by evidence that integrating highly specialized tools directly into a developer s workflow is useful we have developed the concept of active code completion as a generalization of conventional code completion.
we validated the usefulness by generating a number of use cases and developed general design constraints for such tools as well as the underlying architecture by conducting an extensive survey of professional developers.
based on these findings we developed graphite an active code completion architecture that makes several novel design decisions that ease the development deployment and discovery of user defined palettes.
we created palettes for color and regular expression classes and validated the latter palette s usefulness with a pilot study providing evidence for the more general claim that integrating palettes into code completion is useful.
we claim that active code completion systems like graphite will considerably ease this process.
ix.
a vailability graphite is free open source software available from the url on the first page.
we encourage readers to install it and tell us about any interesting palettes that they develop.
acknowledgment we would like to thank the participants in our survey and pilot study jonathan aldrich the plaid group the students of 899d anonymous reviewers and the uiuc software engineering seminar group for valuable feedback.
this material is based upon work supported by the national science foundation under grant no.
ccf .
co is supported by a doe csgf under grant no.
de fg02 97er25308 and nsf grant ccf and yy is supported by the korea foundation for advanced studies.