mit open access articles unifying execution of imperative and declarative code the mit faculty has made this article openly available.
please share how this access benefits you.
your story matters.
citation milicevic aleksandar et al.
unifying execution of imperative and declarative code.
proceedings of the 33rd international conference on software engineering icse may honolulu hawaii usa acm press .
.
web.
as published .
.
publisher association for computing machinery persistent url version author s final manuscript final author s manuscript post peer review without publisher s formatting or copy editing terms of use creative commons attribution noncommercial share alike .
unifying execution of imperative and declarative code aleksandar milicevic derek rayside kuat y essenov daniel jackson computer science and artificial intelligence laboratory massachusetts institute of technology aleks drayside kuat dnj csail.mit.edu abstract we present a uni ed environment for running declarative speci cations in the context of an imperative object oriented programming language.
speci cations are alloy like written in rst order relational logic with transitive closure and the imperative language is java.
by being able to mix imperative code with executable declarative speci cations the user can easily express constraint problems in place i.e.
in terms of the existing data structures and objects on the heap.
after a solution is found the heap is updated to re ect the solution so the user can continue to manipulate the program heap in the usual imperative way.
we show that this approach is not only convenient but for certain problems can also outperform a standard imperative implementation.
we also present an optimization technique that allowed us to run our tool on heaps with almost objects.
categories and subject descriptors d. .
programming environment d. .
requirements speci cations d. .
automatic programming general terms design languages keywords formal methods executable speci cations declarative programming constraint based languages .
introduction squander is a framework that provides a uni ed environment for writing declarative constraints and imperative statements in the context of a single program.
this is particularly useful for implementing programs that involve computations that are relatively easy to specify but hard to solve algorithmically.
in such cases declarative constraints can be a natural way to express the core computation whereas permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.imperative code is a natural choice for reading the input parameters populating the working data structures setting up the problem and presenting the solution back to the user.
the ability to switch smoothly back and forth between declarative logic and imperative programming makes it possible to implement this kind of program more elegantly and with less e ort on the programmer s part.
we propose a technology that can execute declarative speci cations without requiring the programmer to write a single line of imperative implementation.
the supported speci cation language is jfsl an alloy like language that supports rst order relational logic with transitive closure and standard java expressions.
the expressive power of jfsl makes it easy to succinctly write complex relational properties in terms of a program s data structures and reachable objects on the heap.
as we shall show in some cases this form of execution is competitive with handwritten imperative code in others it is not but there are still contexts in which it makes sense to trade performance for other bene ts .
by being able to mix imperative code with executable declarative speci cations the user can easily express constraint problems in place i.e.
in terms of the existing data structures and objects on the heap.
the execution engine runs a solver when a declarative constraint is encountered and automatically updates the heap to re ect the solution.
afterwards the program continues to manipulate the heap in the usual imperative way.
without such a technology the standard approach is to translate the problem into the language of an external solver with specialized hand written code run the solver and then translate the solution back to the native programming language using more specialized code.
this requires more work and is more error prone.
this paper presents the implementation of our framework discusses the bene ts of the uni ed environment and shows several illustrative examples in which the direct execution of a declarative speci cation outperforms a handwritten imperative implementation.
the framework is affectionately named squander since it squanders computational resources running an np complete boolean satis ability sat algorithm to execute all programs including those that have much lower complexity.
it can be freely obtained from .
contributions of this paper include a framework for uni ed execution of imperative and declarative code that combines an existing pre post invariant annotation language with a single extension to magically execute a procedure with a speci ca tion but containing no code and which requires no preprocessing and no change to the execution environment beyond inclusion of the squander library a treatment of data abstraction using serialization techniques that allows speci cations to reference the state of abstract objects in particular the collections of the java library as well as user de ned datatypes in a representation independent fashion an optimization technique for large object heaps that overcomes a key problem in translation to sat namely that the sheer number of potential objects leads with a naive encoding to an array of sat variables whose highest index is greater than java s largest integer a series of small examples illustrating the expressiveness of the declarative notation and its performance advantages for some puzzles and graph algorithms a case study in which an existing non trivial program that was previously implemented with a handwritten encoding was retro tted with the new framework as a test of its application in a slightly larger setting.
.
example sudoku solver as an example consider a simple sudoku solver.
the solver is given a partially lled puzzle figure and is expected to ll out the empty cells with integer values so that the following constraints hold cell values must be in f1 ng wherenis the dimension of the puzzle n in this example all cells within a given row column or sub grid have distinct values.
figure a random sudoku puzzle s t a t i c c l a s s c e l l fi n t v a l g means empty i n v a r i a n t a l l v i n t j v !
l o n e t h i s .
c e l l s .
elems .
v a l .
v s t a t i c c l a s s cellgroup f c e l l c e l l s p u b l i c cellgroup i n t n ft h i s .
c e l l s new c e l l g g p u b l i c c l a s s sudoku f cellgroup rows c o l s g r i d s i n t n p u b l i c sudoku i n t n fi n i t n g ensures a l l c c e l l jc .
val c .
val t h i s .
n modifies c e l l .
v a l p u b l i c v o i d s o l v e fsquander .
exe t h i s gg listing sudoku speci cation a suitable java data model for this problem is given in listing ignore the annotations for now.
a cellgroup contains an array of cells with no duplicate values overlapping cellgroup s are then de ned in the class sudoku for each row column and sub grid.
the init method invoked from thesudoku s constructor has the task of creating exactly n n cell objects n n ncellgroup objects and properly establishing the sharing of cells between cellgroup s. now onto the solving part.
the invariant for cellgroup s given above can be expressed in a single line of jfsl listing invariant annotation .
it says that for all integer valuesvdi erent from select all cell objects from the cellgroup.cells eld with the value v this.cells.elems.value.v and ensure that their count is either or lone .
class invariants assert properties of all members of a class but cannot be executed per se .
to establish an executable constraint we de ne a standard java method and annotate it with a speci cation which includes a precondition requires on the state before method invocation assumed true if not speci ed a postcondition ensures on the state after the method has been executed a frame condition modifies indicating what parts of the state the method is allowed to modify.
in this case the speci cation for the solve method simply says that in the post state i.e.
after the method has been executed by squander all cells must be lled out with non zero values.
the frame condition limits modi cations to those cell.value elds that are currently empty since we don t want to modify values given up front.
these constraints implicitly conjoined with the class invariant are su cient to solve the sudoku puzzle.
the method body is simply a call to a utility method namely squander.exe which invokes the solver and attempts to satisfy the speci cation by updating the cell values.
following execution of solve assuming a solution is found the program may proceed to for example print out the solved puzzle using the usual imperative paradigm.
otherwise an exception is thrown to signal that the specication could not be satis ed.
.
background .
kodkod a solver for relational logic kodkod is a constraint solver for relational logic.
it takes a relational formula to be solved along with de nitions of a set of untyped relations consisting of bounds for each relation and a bounded universe of atoms from which the relations in the solution are populated.
it translates the formula to a boolean satis ability problem and applies an o the shelf sat solver to search for a satisfying solution which if found is translated back to the relational domain.
relations in kodkod are untyped meaning that every relation can potentially contain any tuple drawn from the nite universe.
the actual set of tuples that a relation may contain is de ned through kodkod bounds .
two bounds need to be speci ed lower bound to de ne tuples that a relation must contain and upper bound to de ne tuples that a relation may contain.
the size of these bounds is what primarily in uences the search time the fewer tuples there are in the di erence of the upper and the lower bound the smaller the search space the faster the solving.
.
jfsl jforge specification language jfsl is a formal speci cation language for java.
as in alloy all expressions evaluate to relations.
jfsl providescommon relational algebra operators join .
transpose tuple constructor transitive closure and re exive transitive closure as well as set algebra operators union di erence and intersection .
like in java the universe of discourse consists of java objects null and primitive values.
each type corresponds to a set of objects of exactly that type e.g.
intis the set of all primitive integers while object is the set of all instances of class object excluding subclasses .
each eld is treated as a binary relation from its declarer type to its value type.
the value type is represented by a union of the concrete types that are assignable from the eld s declared type.
an array type t is represented with a ternary relation elems of type t int t null .
the bracket operator is conveniently treated as a left join so a is equivalent to b. a.elems ifais an array or b.a otherwise.
formulas are built from expressions using boolean algebra the cardinality operator set comprehensions e.g.
x t p x and quanti cations e.g.
all x t p x .
jfsl speci cations are written as java annotations.
besides the already mentioned invariant requires ensures and modifies clauses jfsl provides support for speci cation elds via the specfield annotation.
de nition of a speci cation eld consists of the type declaration and optionally an abstraction function which de nes how the eld value is computed in terms of other elds.
for example specfield x one int x this.y this.z de nes a singleton integer eld x the value of which must be equal to the di erence of yand z. speci cations elds are inherited from super types and sub types can override the abstraction function by simply rede ning it this is particularly useful for specifying abstract datatypes such as java collections.
the frame condition has an important role in precisely specifying the e ects of a method.
it takes the form modifies f with three parts.
the rst and the only mandatory part is the name of the modi able eld f. it is optionally followed by the instance selector s which speci es instances for which the eld may be modi ed taken to be all if not speci ed and the upper bound u of the modi cation taken to be the full extent of the eld s type if not speci ed .
in the sudoku example listing we used an instance selector to specify that only the empty cells may be modi ed.
in squander the instance selector provides the only mean of specifying the modi able instances.
if for some reason we wanted to additionally constrain the values that may be assigned to the cells we could either add constraints to the ensures clause or use the upper bound clause of the frame condition.
the di erence is that the former is less e cient the frame condition s upper bound is translated directly to kodkod bounds which shrinks the search space at the beginning of the search as opposed to leaving it large and constraining the search by adding more rules.
.
from objects to relations squander execution begins when the utility method squander.exe is called by the client code and involves the following steps assembling the relevant constraints from the annotations comprising the method s speci cation as well as class annotations corresponding to invariants of all relevant classes determined by a traversal of the heap from the receiver object construction of relations representing the values of objects and their elds in the pre state and additional relations for modi able elds to hold their values in the post state along with their kodkod bounds parsing of the constraints and conversion to a single relational formula handed to kodkod for solving if a solution is found translation of the kodkod result objects into updates of the java heap state by modi cation of the object elds.
.
heap traversal and object serialization the rst concern for squander is discovering the reachable portion of the heap.
the traversal algorithm is a standard breath rst algorithm although depth rst would sufce too starting from a given set of root objects the caller instance plus method arguments and repeatedly visiting all children until all reachable objects have been visited.
the interesting part is how to enumerate children i.e.
how to serialize a given object into a set of eld values.
squander provides a generic mechanism that allows for di erent object serializers based on the object s class.
for example the default object serializer simply returns values of an object s elds.
this behavior is good in many cases including user de ned classes.
however when serializing abstract types such as an object of type java.util.set we would like to return only the members of the set excluding objects that are artifacts of the representation such as hash buckets .
an abstraction function is needed to separate the actual content from the internal representation and this is exactly what object serializers provide.
similarly they also provide concretization functions that are used to restore an object s state from a given set of abstract values returned by the solver.
through this mechanism squander provides support for java collections and java arrays more details in section and allows users to easily customize behavior for user de ned abstractions.
.
.
keeping track of type parameters java collection classes make extensive use of parametric types also called generics in java terminology .
this allows the programmer to indicate the type of objects a collection may contain e.g.
a set of nodes set node rather than a set of arbitrary objects set .
unfortunately though since generics were a late addition to java they are implemented using type erasure and the parameter information is only available at compile time.
for ease of use squander is a runtime mechanism that uses the standard jvm so it has no access to the compile time type information.
knowing the exact types of objects including type parameters is important.
one reason is that we don t want to have to write explicit casts in our speci cations every time we refer to an element of a collection as one must do in java when not using generics .
other reasons are mainly concerned about performance without knowing the type parameter the extent of the elements of a set is the set of all objects on the heap.
if the set is actually a set of integers than the actual extent is much smaller which would result in a smaller bound if the set was modi able see section .
which may dramatically improve kodkod s running time.
java re ection does however provide static types of elds and method parameters which include type parameter information.
say there is a eld declared as set node nodes the fact that the eld is a set of nodes can be obtained atruntime.
consequently if we know that some object objwas read as a value of the eld nodes we can conclude that the type of objis actually set node .
almost all objects during the heap traversal are discovered by reading eld values.
it is only the caller instance whose origin is not known all other objects are either passed as method parameters or read as eld values so complete type information can be obtained for all objects but the root.
.
reading parsing and type checking jfsl when a new class is discovered during heap traversal its speci cation is obtained by re ection.
the speci cation of a class includes class invariants invariant and speci cation elds specfield .
these can be speci ed either directly in the source le using java annotations or through a special spec le which must be found in the classpath and whose name must correspond to its target class s full name.
next text based speci cations are parsed and type checked e.g.
to make sure that all identi ers can be resolved to actual classes elds in the program and that expressions have expected types etc.
and eventually translated into relational expressions.
for most of this task squander borrows functionality from jforge .
.
example of a translation to illustrate translation we ll rst give an example even simpler than the sudoku example from section .
afterwards we ll de ne the translation process more formally.
consider an insertion into a binary search tree.
for the purpose of translation we don t need to give either the full speci cation or the full source code listing since the structure of the heap alone is su cient to explain most of the details.
the class bstcontains a single pointer to the root node and the node class contains pointers to left and right sub trees as well as a single integer value through the eld key .
the snapshot shown in figure gives an example of a heap consisting of a tree t in the class bst four node objects of which only three are reachable and four key values.
when a node is inserted all node pointers may potentially be modi ed so the speci cation for the insert method declares elds root left and right as modi able.
the resulting set of relations is shown in table .
relations in the upper section are unary given relations and represent objects found on the heap.
the middle section contains relations that are also given because they are used to either represent unmodi able elds or values in the prestate of modi able elds.
finally the relations in the bottom section represent the post state of modi able elds these are the relations for which the solver will attempt to nd appropriate values.
by default the lower bound is an empty set and the upper bound is the extent of the eld s type.
note however that squander also allows the users to tighten these bounds by specifying the exact objects that are allowed to be modi ed using the instance selector clause of the frame condition as de ned in section .
.
for example for the relation left it is easy to specify in jfsl that the only left pointers that may be modi ed are those of nodes whose left pointers are currently set to null.
as previously reported by samimi et al.
this can lead to a signi cant speed up in certain cases.
to control the scope of the modi cation more nely squander additionally allows the users to constrain the setof possible values for a eld by using the upper bound clause of the frame condition.
bst node figure a snapshot for the pre state of t.insert z bst1 ft1gn3 fn3g bst this ft1g n1 fn1gn4 fn4g z fn4g n2 fn2gnull fnullgints f0 6g key f n1!
n2!
n3!
n4!
g root pre f t1!n1 g leftpre f n1!n2 n2!null n3!null n4!null g right pre f n1!n3 n2!null n3!null n4!null g root fg ft1g fn1 n2 n3 n4g left fg fn1 n2 n3 n4g fn1 n2 n3 n4g right fg fn1 n2 n3 n4g fn1 n2 n3 n4g table translation of the heap from figure to bounds a single exact bound or a pair of lower upper bounds .
defining relations and bounds the translation does not use all elds but rather considers only relevant elds i.e.
those that are explicitly mentioned in the speci cation for the current method.
similarly not all reachable objects are needed only objects reachable by following the relevant elds are included in the translation.
these objects will be referred to as literals .
first we de ne a nite universe consisting of all literals and integers within the bound.
for every literal a unary relation is created.
these relations are constant i.e.
they are given an exact bound lower and upper bounds are equal of a single unary tuple containing the corresponding literal.
for each java type one could either create a relation with appropriate bounds so that it contains the known literals or one could construct a relational expression denoting the union of relations corresponding to all instance literals of that type.
in our implementation we took the former approach since it results in more readable expressions which helps in debugging and has no performance impact.
for every eld including speci cation elds a relation of type fld.decltype!fld.type1is created to hold assignments of eld values to objects.
if the eld is modi able inferred from its mention in a modifies clause an additional relation is created with the su x pre appended to denote the pre state value.
relations for unmodi able elds are given an exact bound that re ects the current state of the heap.
for the modi able relations the pre relation is given the same exact bound and the post relation is bounded so that it may contain any tuple permitted by the eld s type.
local variables such as this return and method arguments are treated similarly to literals.
table summarizes how relations and bounds are created.
function reltakes a java element and depending on whether the element is modi able returns either one or two relations the notation means list of and ris 1fld.decltype is the declaring class of fldthe constructor for relations taking a name and a type for the relation .
function bound takes a java element and its corresponding relation and returns a bound for the relation.
the bound data type contains both lower and upper bounds.
if only one expression is passed to its constructor b both bounds are set to that value.
helper functions is mod is post and fldval are used to check whether a eld is modi able to check whether a relation refers to the poststate and to return a literal that corresponds to the value of a given eld of a given literal respectively.
rel element!
rel literal lit rel type t rel field d ifismod d r d.name d.decltype!
d.type r d.name pre d. decltype!
d.type else rel local var bound element relation !bound bound literal lit relation r b lit bound type t relation r s lit tb lit bound field d relation r ifismod d ispost r b fg ext d. decltype d.type else b s lit objectlit dval lit d bound return ret relation r b fg ext ret.
type bound local var relation r b var ext !expression helper ext fg ext t s lit tlit ext t xs extt extxs table translation of di erent java constructs into relations function rel and bounds function bound .
restoring the java heap state after running kodkod to search for a solution the java heap state must be updated to re ect the outcome of the search.
if kodkod reports that a solution could not be found squander simply throws an exception which can be caught and handled by the client code.
if there exist multiple solutions to the given problem kodkod will nondeterministically return one2.
the solution is then restored to the java heap by modi cation of the object elds through re ection.
finally execution returns to the client code.
the process of restoring the heap is straightforward.
during the translation to kodkod squander saves the mapping from java objects to kodkod atoms and from java elds to kodkod relations.
therefore a kodkod solution containing values of all relations in the form of tuples of atoms can be directly mapped back to the values of java elds.
.
minimizing the universe size to represent a relation rof arityk kodkod allocates a matrix of size nk wherenis the number of atoms in the universe.
for performance reasons kodkod uses a single 2kodkod can also enumerate all possible solutions one at a time and that functionality is exported by squander .
this feature is for example useful for generating test instances that satisfy a certain property.sequential array indexed by a java integer and so the size of the matrix is limited to the largest integer values in java integer.max value .
consequently if the universe contains atoms or more the matrix for a ternary relation would contain at least 12913cells which would exceed the size limit so the relation could not be represented in kodkod.
in practice this can be a problem.
squander makes frequent use of ternary relations e.g.
for representing arrays lists and maps and heaps with more than objects are not uncommon for problems that we would like to be able to solve with squander so a simple translation like the one described in section .
which simply creates a new atom for every object it nds on the heap is not feasible.
as an illustration in our case study on a course scheduling application for the mit undergraduate degree program explained in section the heap contains more than objects.
.
kodkodpart translation our kodkodpart translation achieves a universe with fewer atoms by establishing a mapping from java objects also called literals as in section .
to kodkod atoms that is not necessarily an injective function.
in other words multiple literals are allowed to map to a single atom so that there can be fewer atoms than literals.
the key requirement is however that there exists in the larger context an inverse function from atoms back to literals so that the heap can be properly restored after a solution has been found.
this inverse function we will see can be contructed with the help of available type information.
consider the tree insertion example shown in figure .
domainsd literalsl and assignments of literals to domains d!p l for this example are summarized in table .
d fbst node null integerg l fbst1 n1 n2 n3 n4 null 6g bst fbst1g node fn1 n2 n3 n4g null fnullg integer f0 6g table summary of domains and instances recall that eld types are represented as unions of base types in this section also called partitions .
for instance the type of the eld bst.root isbst!node null because values of this eld can be either instances of node or the null constant.
that means that all objects of class node plus the constant null must be mapped to di erent atoms so that it is possible to unambiguously restore the value of the eld root.
this is the basic idea behind the kodkodpart translation all literals within any given partition must be mapped to di erent atoms whereas literals not belonging to a common partition may share atoms .
the inversion function can then work as follows for a given atom rst select the correct partition based on the type of the eld being restored then unambiguously select the corresponding literal from that partition.
to complete the example the set of all unary types used in the speci cation for this example is t fbst bst null node node null null integerg this set is discovered simply by keeping track of types of all relations created for java elds and it automatically becomes the set of partitions.
a valid assignment of atoms to literals that uses only atoms as opposed to which is how many the original translation would use could be bst1!a0n1!a0n2!a1n3!a2n4!a3 null!a40!a0 !a1 !a2 !a3 .
partitioning algorithm for a given set of base domains d literalsl and partitionst tis of typep d and a given function d!
p l that maps domains to their instance literals this algorithm produces a set of atoms aand a function l!a so that for every partition p function returns di erent values for all instance literals of p. formally 8p2t 8l1 l22 p l16 l2 l1 l2 where is a function that for a given partition returns a comprehension of all instance literals of all of its domains t !p l p f d jd2pg obviously a simple bijection would satisfy this speci cation but such a solution wouldn t achieve its main goal which is to minimize the number of atoms because the number of atoms in this case would be exactly the same as the number of literals.
in order to specify solutions that actually improve performance we require the algorithm to produce a result that minimizes the cardinality of a i.e.
the total number of atoms .
in summary the algorithm works as follows .
dependencies between domains are computed.
a domain depends on all domains with which it shares a partition.
let the function d!p d express this d fd1jd16 d 9p2t d12p g .
the largest partition pmaxis found such that 69p2t j p j j pmax j .
for every literal lin pmax an atomais created it is added to the universe aand assigned to l so that l a. from this point onwards ais xed.
.
for every other partition piteratively for all literals lp2 p that do not already have an atom assigned a set of possible atoms alpis computed and the rst value from this set is assigned to lp.alpis obtained when atoms corresponding to all literals of all dependent domains is subtracted from a. for a discussion of why it is su cient to simply nd the largest partition and allocate that many atoms see a limitation of this technique is that if the class object is used as a eld type or anywhere in the speci cation it will result in one big partition containing all literals because every class is a subclass of object so that the result is equivalent to the original translation.
similarly if there exists a single partition with more than literals the problem will still be unrepresentable.
.
user defined abstractions for library types when specifying a program we would like to be able to refer to the content of library types to iterate over the elements of a java set for example.
clearly we do not wish to expose to the internals of the various setimplementations so we cannot write declarative statements that directly refer to the elds of hashset for example.
we also do not wantour speci cation to depend on a concrete implementation of these classes.
this is a common problem and squander provides a generic solution by letting the users write abstraction and concretization functions for library classes.
the task of supporting an arbitrary third party class consists of writing a .jfspec le with abstract eld de nitions and writing an object serializer as an implementation of the iobjser interface that provides abstraction and concretization functions for the abstract elds.
the .jfspec les are written in jfsl.
they contain abstract elds the same specfield annotation is used and invariants invariant .
some abstract elds may have only a type declaration whereas others may also be given an abstraction function written in jfsl expressed in terms of the existing elds.
the accompanying object serializer must provide concrete implementations of abstraction and concretization functions for only those abstract elds not already having an abstraction function de ned in the .jfspec le.
the abstraction function absfunc takes a concrete object and returns values of its abstract elds.
the concretization function concrfunc takes a concrete object and a value of an abstract eld and is expected to restore that value to the concrete object by mutation.
the code for serializers is straightforward and is omitted for lack of space.
squander provides built in support for java collections and java arrays through this mechanism.
.
specification for java sets and maps the abstract representation of a set is a set of elements which is captured in a single specfield named elts similarly for maps a binary relation also named elts is used to represent the mapping from keys to values listing .
additional elds size keys vals are de ned for convenience an abstraction functions is also provided so that the serializer is not required to implement abstraction and concretization functions for them.
additionally an invariant is speci ed for maps constrain each key to map to at most one value.
i n t e r f a c e set k f specfield e l t s s e t k specfield s i z e one i n t jt h i s .
s i z e t h i s .
e l t s g i n t e r f a c e map k v f specfield e l t s k v specfield s i z e one i n t jt h i s .
s i z e t h i s .
e l t s specfield keys s e t k jt h i s .
keys t h i s .
e l t s .
v specfield v a l s s e t v jt h i s .
v a l s t h i s .
e l t s i n v a r i a n t f a l l k k jk i n t h i s .
e l t s .v one t h i s .
e l t s g g listing speci cation for setand map .
specifications for java lists and arrays to capture the abstract representation of a list we again declare a single eld again named elts but of type int e listing .
this time however we must include an additional constraint to ensure that these elds represent a valid list there should be exactly one element for every index from inclusive to the size of the list exclusive and no elements at any other index.
we write this constraint as an invariant in the same jfspec le.
as before we de ne eld size to represent the number of elements in the list.
finally we de ne an extra eld prev de ning the reverse ordering whose use is illustrated in the case study described later.
the abstraction function for this eld makes use of a constant relation namely dec which is built in to squanderand evaluates to all pairs fi i 1g where both iandi are integers drawn from the nite universe.
java arrays are likewise supported through this mechanism and their speci cation is almost identical to that given in listing .
this mechanism automatically supports multidimensional arrays because in java multi dimensional arrays are simply arrays of arrays and our mechanism for de ning speci cations is inherently compositional.
i n t e r f a c e l i s t e f specfield e l t s i n t e specfield s i z e one i n t jt h i s .
s i z e t h i s .
e l t s specfield prev e e j t h i s .
prev t h i s .
e l t s .
dec .
t h i s .
e l t s i n v a r i a n t a l l i i n t j i i t h i s .
s i z e ?
one t h i s .
e l t s no t h i s .
e l t s g listing speci cation for list .
examples and ev aluation in this section we demonstrate how our framework is e cient enough to be used at least in some cases as a primary implementation mechanism where in contrast previous uses of solving during execution have focused on specialized applications such as redundant computation as a fallback or for exploring behavior in the early stages of the development process .
.
solving hard problems if a problem is solvable in polynomial time a careful manual implementation is likely to outperform a squander implementation.
but if the problem itself is di cult a solution withsquander may turn out due to the e ciency of sat solvers to perform better than a hand written algorithm.
of course squander will not always o er the most e cient solution most of these problems have been well studied and highly specialized heuristics have been developed for solving them.
nevertheless it is perhaps surprising how competitive a sat based solution is even including squander s overhead of encoding and decoding with many handwritten solutions.
for our comparison we used standard textbook solutions to the benchmark problems which are typically based on backtracking with pruning.
in tables and we give total running time of our tool squander translation time to kodkod ttransl translation time from kodkod to cnf tkodkod and sat solving time tsat .
.
.
hamiltonian path algorithm a hamiltonian path in a graph is one that visits each node in the graph exactly once.
listing shows both the data representation that we used for graphs and the speci cation for this problem.
to nd a solution the framework must create a fresh array of nodes to hold the result this is speci ed explicitly using the freshobjects annotation.
the speci cation asserts that the returned path contains all nodes in the graph and that for every two consecutive nodes in the path there exists an edge between them in the graph.
the textbook backtracking algorithm uses an adjacency matrix to represent a graph.
we took this particular implementation from the web site of the cornell course on algorithms and data structures .
in our experiment we generated two categories of directed graphs graphs without any hamiltonian paths and graphs containing one or more hamiltonian paths.
for eachgraphs size we ran the experiment on di erent graphs of that size measured the execution times and calculated the average.
all experiments included warmup runs to neutralize possible e ects of class loading etc.
p u b l i c c l a s s graph f p u b l i c s t a t i c c l a s s node fi n t v a l u e g p u b l i c s t a t i c c l a s s edge fnode src d s t g p r i v a t e set node nodes p r i v a t e set edge edges ensures f r e t u r n i n t h i s .
edges .
e l t s r e t u r n .
s r c d s t t h i s .
nodes .
e l t s r e t u r n .
l e n g t h t h i s .
nodes .
e l t s a l l i i n t ji i r e t u r n .
l e n g t h r e t u r n .
d s t r e t u r n .
s r c g modifies f r e t u r n .
l e n g t h r e t u r n .
elems g freshobjects c l s edge .
c l a s s num p u b l i c edge hp fr e t u r n squander .
exe t h i s gg listing hamiltonian path speci cation the following procedure was used to generate graphs .
generate and add nnodes to the graph .
generate a random permutation of nodes and add edges between the neighboring nodes in the permutation including the edge between the last and the rst node.
at this point the graph contains a hamiltonian cycle.
.
randomly choose a number between and percent of the maximum number of nodes n n and keep adding random edges until the number of edges in the graph is equal to the chosen number.
.
randomly choose a node and remove all its incoming edges.
at this point the graph still contains at least one hamiltonian path the one that starts from the node selected in this step.
.
if the goal is to generate graphs with no hamiltonian paths remove all outgoing edges of the node selected in the previous step.
the results are shown in table .
for the manual implementation establishing the absence of a hamiltonian path is harder than nding one if it exists since this requires exploring all paths from the rst node i.e.
whichever node it chooses rst .
sometimes it can happen that the rst node has no outgoing edges in which case the manual algorithm terminates instantly but on average the problem becomes hard for a random graph with or more nodes.
in contrast the boolean solver seems to easily locate the isolated node no matter where it is found in the graph and can thus prove nonexistence of a hamiltonian path more easily.
finding a path when one exists is harder but on average the declarative solution still scales better than the backtracking algorithm.
.
.
the n queens problem the problem of n queens involves placing nqueens on ann nchess board so that no queen can take any of the others.
e. w. dijkstra in his book on structured programming describes a backtracking solution with pruning which we implemented in java for the purpose of our experiment.
this algorithm keeps track of rows columns and diagonals that have been taken by the queens already placed on the board so every time it has to pick a position for the next queen it avoids all con icting cells thus pruning a large portion of the search space.
there is a known polynomial time algorithm for n queens which rst guesses a solution and then performs a local search using agraphs without hamiltonian paths graphs with hamiltonian paths manual .
.
t o t o t o t o t o t o .
.
.
t o t o t o t o t o squander .
.
.
.
.
.
.
.
.
.
.
.
.
.
t o t o ttransl .
.
.
.
.
.
.
.
.
.
.
.
.
.
t o t o tkodkod .
.
.
.
.
.
.
.
.
.
.
.
.
.
t o t o tsat .
.
.
.
.
.
.
.
.
.
.
.
.
.
t o t o table hamiltonian path execution times gradient based heuristic to move certain queens around until all con icts have been resolved.
requires r e s u l t .
l e n g t h n ensures f a l l k i n t jk k n l o n e c e l l i .
k a l l k i n t jk k n l o n e c e l l j .
k a l l q1 r e s u l t .
e l t s jno q2 r e s u l t .
e l t s q1j q1 .
i q2 .
i j jq1 .
i q1 .
j q2 .
i q2 .
j j j q1 .
j q2 .
j j jq1 .
i q1 .
j q2 .
i q2 .
j g modifies f c e l l .
i c e l l .
j g p u b l i c s t a t i c v o i d nqueens i n t n set c e l l r e s u l t listing nqueens speci cation listing gives the speci cation for n queens.
the nqueens method takes an integer n and a set already containing exactly n cell3objects and is expected to modify the coordinates of the given cells so that they represent a valid positioning of nqueens.4the frame condition speci es that only cell coordinates are modi able.
the two bracketed subexpressions respectively mean that all cellinstances are modi able the upper bound is f0 n 1g values for cell coordinates .
in the post condition the third all clause asserts that no two di erent cells queens in the resulting set may be in the same row column or either diagonal.
the rst two universal quanti er clauses are redundant they state that every row and every column must contain exactly one cell object which follows from the third constraint.
even though they are not required for correct execution redundant constraints often as here improve the performance of the solver.
to improve clarity we could introduce a special annotation e.g.
advicespec to hold such redundant constraints which don t add anything new to the problem speci cation but only help the performance.
n manual .
.
.
.
t o t o squander .
.
.
.
.
.
ttransl .
.
.
.
.
.
tkodkod .
.
.
.
.
.
tsat .
.
.
.
.
.
table n queens execution times in seconds 3cell is a simple wrapper class for iand jcoordinates of the chess board.
4the reason why this method takes a set of cells as opposed to creating a new set with n cell s in it is non essential squander can t arbitrarily create new objects instead it requires the user to explicitly pass the number of new objects via freshobjects annotations.
unfortunately annotations cannot take variables as arguments only constants.table shows results for di erent values of n. for smaller values up to the manual backtracking algorithm performs better although squander s performance is not terrible .
for larger values of n squander scales considerably better.
it computes a solution for queens in seconds whereas the manual algorithm begins to time out that is exceed the ve minute limit we set at only queens.
.
course scheduler case study as a larger case study we re implemented an existing application a course scheduler that helps students select courses to complete graduation requirements.
given a student s current standing it nds a path to graduation that meets the program requirements for the undergraduate degree in eecs at mit.
the mit program o ers around courses de nes prerequisites for more than courses and also speci es some additional requirements e.g.
mandatory courses selections of multiple options from groups of courses etc .
the original implementation used the kodkod constraint solver directly via its api.
about lines of code were written to translate the student s standing and the set of mit requirements to relational constraints run kodkod to nd a solution and nally translate the kodkod solution back to the original data structures.
it is these lines of code that squander is intended to eliminate.
conceptually the complexity of coming up with correct speci cation for the problem remains the same the di erence is that the user can now write about lines of human readable speci cations instead of manually writing lines of code to walk the heap construct all the kodkod relations create all the constraints through the kodkod api and nally restore the solution onto the heap.
the goal of this case study was to assess the usability of squander on a real world program whose core lies in solving a constraint problem.
a key goal was to make minimal changes to the existing data structures of the original application so that the rest of the application e.g.
gui i o etc.
might be reused without modi cation.
squander s built in abstractions for collection classes used extensively in the data model were essential in reducing the annotation burden.
we had to annotate user de ned classes with invariants de ne additional speci cation elds when necessary and introduce a single new method solve with a speci cation capturing the course requirements.
a second goal was to show that the framework could scale to a large heap.
the novel translation presented in section enabled us to handle heaps with almost objects.
the time it takes squander to nd a solution for a problem of this size is less than seconds.
the original implementation still runs faster it takes about second but the cost of its development was much higher.
i n v a r i a n t f f o r a l l c o ur se s p r e r e q s must be taken i n the p r e v i o u s s e m e s t e r s t h i s .
prereqused .
e l t s .
e l t s i n t h i s .
s c o u r s e s .
e l t s .
e l t s .
t h i s .
s e m e s t e r s .
prev .
t h i s .
s c o u r s e s .
e l t s .
e l t s i n c l u d e p r e r e q u i s i t e s f o r c o u r s e s t h i s .
s c o u r s e s .
v a l s .
e l t s prereqmap .
p r e r e q s .
keys i n t h i s .
prereqused .
keys c o u r s e and s e m e s t e r a t t r i b u t e s match a l l sem semester jt h i s .
s c o u r s e s .
e l t s .
e l t s .
a t t r i b u t e s .
e l t s i n sem .
a t t r i b u t e s .
e l t s don t s k i p s e m e s t e r s a l l sem semester jsome t h i s .
s c o u r s e s .
e l t s .
e l t s !
t h i s .
s e m e s t e r s .
prev .
i s p a s t some t h i s .
s c o u r s e s .
e l t s .
e l t s don t a s s i g n c o u r s e s more than once a l l sem semester jno t h i s .
s c o u r s e s .
e l t s .
e l t s t h i s .
s c o u r s e s .
e l t s .
e l t s don t add n u l l n u l l !
i n t h i s .
s c o u r s e s .
v a l s .
e l t s g p u b l i c c l a s s schedule f p r i v a t e l i s t semester s e m e s t e r s p r i v a t e map semester set course s c o u r s e s p r i v a t e map course set course prereqused g p u b l i c c l a s s problem f p r i v a t e degreeprogram dp p r i v a t e schedule s c h e d u l e p r i v a t e set requirement a d d i t i o n a l r e q s ensures f a l l req t h i s .
a d d i t i o n a l r e q s .
e l t s t h i s .
dp .
g r o u p i n g s .
e l t s .
groupingreqs .
e l t s jreq .
cond t h i s .
dp .
rootgrouping .
c o u r s e s .
e l t s i n t h i s .
s c h e d u l e .
s c o u r s e s .
v a l s .
e l t s g modifies f modify s e m e s t e r to s e t of c o u r s e s map but don t change the mapping f o r pa s t s e m e s t e r s t h i s .
s c h e d u l e .
s c o u r s e s .
v a l s .
e l t s fs t j a v a .
u t i l .
set course jno sem semester j sem .
i s p a s t sem s t i n t h i s .
s c h e d u l e .
s c o u r s e s .
e l t s g modify the used p r e r e q u i s i t e s map t h i s .
s c h e d u l e .
prereqused .
e l t s p u b l i c v o i d s o l v e fsquander .
exe t h i s gg listing partial speci cation for the course scheduler .
specification the total number of lines of speci cation we wrote for this case study was less than .
here we illustrate only the most interesting portion the rest can be found in .
class schedule is the primary class.
it contains a list of semesters given in advance and not to be modi ed and a mapping from semesters to courses scourses to be computed.
it may contain some existing assignments e.g.
courses already taken which are not to be modi ed.
course prerequisites are de ned in disjunctive normal form as sets of sets of courses with an additional eld prereqused holding the choice of course used to satisfy a course s prerequisite.
the speci cation that captures these invariants and others is shown in listing .
the core of the speci cation for the scheduler is associated with the method solve listing .
aside from