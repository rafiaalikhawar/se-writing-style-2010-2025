automatic testing of sequential and concurrent substitutability michael pradel department of computer science eth zurich switzerlandthomas r. gross department of computer science eth zurich switzerland abstract languages with inheritance and polymorphism assume that a subclass instance can substitute a superclass instance without causing behavioral differences for clients of the superclass.
however programmers may accidentally create subclasses that are semantically incompatible with their superclasses.
such subclasses lead to bugs because a programmer may assign a subclass instance to a superclass reference.
this paper presents an automatic testing technique to reveal subclasses that cannot safely substitute their superclasses.
the key idea is to generate generic tests that analyze the behavior of both the subclass and its superclass.
if using the subclass leads to behavior that cannot occur with the superclass the analysis reports a warning.
we find a high percentage of widely used java classes including classes from jboss eclipse and apache commons collections to be unsafe substitutes for their superclasses of these classes lead to crashes and even more have other behavioral differences.
i. i ntroduction a. substitutability classes extend and refine other classes through subclassing.
polymorphism allows a reference of a superclass type to point to a subclass instance.
to ensure that using a superclass reference gives the expected behavior each subclass should behave like the superclass when being used through the superclass type.
this requirement is called substitutability and can be enforced through behavioral subtyping .
we call a subclass that fulfills this property a safe substitute for its superclass and an unsafe substitute otherwise.
substitutability is crucial for object oriented programming.
it allows a programmer to reason about the behavior of an object based on the object s statically declared type that is without knowing its runtime type.
what if a programmer that uses objects of declared type super could not assume subclasses to be safe substitutes?
a prudent programmer would have to study all subclasses of super figure out which of them are compatible with the intended usage and add runtime type checks before each use of an object with an unknown runtime type.
since this approach would add boilerplate code and runtime overhead it obviously reduces the benefits of subclassing and polymorphism.
to avoid these problems substitutability is widely accepted as one of the bedrock principles of object oriented programming.
despite the importance of substitutability programmers get little help from existing languages and tools to ensure that subclasses are safe substitutes.
popular languages such astreemap m newtreemap or newfasttreemap m.put m m.polllastentry m.hashcode result ok if mistreemap stackoverflowerror ifmisfasttreemap figure .
a sequentially used class that is an unsafe substitute.
java enforce substitutability only on the type level but not on a deeper semantic level.
while the type system ensures that an overriding method is type compatible with the overridden method it does not guarantee that the overriding method semantically substitutes the overridden method.
specification and verification techniques to ensure substitutability through behavioral subtyping have been proposed but none of them has found its way into mainstream programming.
furthermore we are not aware of any practical tool that helps programmers find substitutability problems.
as a result of this lack of support programmers are susceptible to creating subclasses that are unsafe substitutes.
for example consider fasttreemap from the apache commons collections library.
fasttreemap is a subclass of treemap and therefore should behave like a treemap when being referred to as a treemap .
figure shows a usage of these classes that reveals that fasttreemap is an unsafe substitute fortreemap .1executing the code succeeds if mis atreemap but raises an exception if mis afasttreemap .
this difference may crash a client program that expects a treemap reference to behave like a treemap .
we reported this problem to the developers who acknowledged our report.
b. substitutability in concurrent programs substitutability which traditionally has been considered in sequential programs is equally important in concurrent programs.
similar to sequential programs a subclass instance referenced through a superclass type and shared by multiple concurrent threads should behave like a superclass instance.
in particular subclasses of a thread safe class must be threadsafe as well.
that is if multiple threads are allowed to call 1we use the syntax new a or new b to say that either of the constructors can be executed.
2see issue in the commons collections bug tracker.
the class will be removed in the next version of the library.properties p newproperties or newpropertymap p.setproperty a b p.remove a p.clear thread thread result ok if pisproperties nullpointerexception ifpispropertymap figure .
a concurrently used class that is an unsafe substitute.
methods of a shared object without synchronization then this property must be preserved by subclasses.
unfortunately existing languages and tools do not support programmers in ensuring substitutability for thread safe classes.
figure shows a substitutability problem in propertymap from jboss.
the class extends properties a thread safe class from the java standard library and therefore should also support concurrent usage.
however propertymap causes an exception in a concurrent usage whereas the same usage succeeds with the superclass.
we reported this problem to the developers who fixed the bug.
c. our approach how can developers find unsafe substitutes such as figures and ?
this paper presents an automatic testing technique that detects subclasses that cannot safely substitute their superclasses.
given two classes super andsub the technique generates test cases that can test both super instances and sub instances.
then the analysis uses the behavior of super as an oracle for sub and reports a warning if sub behaves differently from its superclass.
we present two variants of this oracle the output oracle which reports any difference in the visible output and the crash oracle which reports a warning only if subleads to a crash that does not occur with super .
the analysis checks substitutability for sequentially and concurrently used classes and among many others finds the bugs in figures and .
our analysis is easy to apply precise and incomplete.
it is easy to apply because the only input are the classes to test possibly accompanied by auxiliary classes to create method arguments.
the approach is precise because all reported warnings point to classes that are unsafe substitutes.4furthermore each warning comes with a concrete test case showing how the subclass behavior differs from the superclass behavior.
on the downside the analysis is incomplete that is it cannot guarantee that a subclass is a safe substitute.
incompleteness is the price we pay for an easy to apply and precise analysis.
we apply the analysis to pairs of widely used and welltested java classes and have two main findings.
we find that surprisingly many subclasses are unsafe substitutes of the analyzed subclasses lead to 3see issue in the jboss common bug repository.
4precision is guaranteed only to the degree that constructor mappings section iii c are precise.
in practice the crash oracle section iii d2 has no false positives during our evaluation.crashes that do not occur with their superclass and even more subclasses produce output that differs from the output of their superclass.
we find that developers care about substitutability problems we reported ten bugs out of which seven got fixed after a short time.
moreover at least three other bugs detected by our analysis have been fixed independently of us.
d. contributions in summary this paper contributes the following an automatic and precise analysis to find subclasses that cannot safely substitute their superclasses.
we consider substitutability which has traditionally been studied in sequential programs in concurrent programs.
empirical evidence that the problem of ensuring substitutability is not yet solved and that our analysis is a step towards solving it.
ii.
b ackground theperils of polymorphism polymorphism and subclassing are part of most popular class based object oriented programming languages.
this section briefly discusses problems emerging when these two language features interact and describes how substitutability helps to avoid these problems.
polymorphism allows a reference of type super to point to an object of any subtype sub ofsuper .
polymorphic