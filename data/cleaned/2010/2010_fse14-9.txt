querying sequential software engineering data chengnian sunyhaidong zhangxjian guang louxhongyu zhangx qiang wangxdongmei zhangxsiau cheng khooz yuniversity of california davis usa xmicrosoft research beijing china xnational university of singapore singapore cnsun ucdavis.edu khoosc nus.edu.sg haidong.zhang jlou honzhang qiang.wang dongmeiz microsoft.com abstract we propose a pattern based approach to e ectively and e ciently analyzing sequential software engineering se data.
di erent from other types of se data sequential se data preserves unique temporal properties which cannot be easily analyzed without much programming e ort.
in order to facilitate the analysis of sequential se data we design a sequential p attern q uery l anguage spql which speci es the temporal properties based on regular expressions and is enhanced with variables and statements to store and manipulate matching states.
we also propose a query engine to e ectively process the spql queries.
we have applied our approach to analyze two types of se data namely bug report history and source code change history.
we experiment with eclipse bug reports and code revisions of android.
spql enables us to explore interesting temporal properties underneath these sequential data with a few lines of query code and low matching overhead.
the analysis results can help better understand a software process and identify process violations.
categories and subject descriptors h. .
languages query languages d. .
management software quality assurance sqa general terms languages management keywords sequential data pattern matching query mining software repository permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction over the years of software practice there is a plethora of software engineering se data produced by di erent processes and tools.
these data include source code bug reports change logs metric data etc.
many organizations are now maintaining large software repositories and are willing to mine or even share their se data to facilitate the exchange of results and to improve their current practices by learning from others.
the construction of software repositories is further facilitated by the open source software movement which also o ers a vast amount of se data to the public.
the increase in number and size of software repositories brings both opportunities and challenges for researchers and practitioners.
there is a great variability in se data.
many existing approaches e.g.
focus on the relational aspect of se data and treat se data as structured data in a database.
other approaches e.g.
focus on the textual aspect of se data and treat se data as a set of documents.
we nd that many kinds of se data also have the sequential nature which is often displayed as a sequence of activity records.
for example during the lifetime of a bug report from its initially creation to nal close there is usually a series of status changes.
during the lifetime of a source code le there is often a series of revisions.
the sequential nature of data provides invaluable insight into the software maintenance process and opens up the possibility of conducting more holistic study of software projects in ways previously unexplored.
in this paper we propose a highly adaptable patternmatching approach for e ective and e cient query of sequential se data.
with our query language spql sequential pattern q uery l anguage a user can specify a query describing the characteristics of sequential se data.
the matching results can be returned by the spql query engine.
query language the language is a hybrid of regular expressions and several constructs from imperative programming languages i.e.
variables if statement assignment statements and function calls .
this design choice makes the language capable of expressing complex queries and also easy to learn especially for developers with experience on regular expressions.
query engine the query engine is powered by a proposed extension of non deterministic automata nfa simulation algorithm that supports variables and actions.
the classicalnfa simulation algorithm for regular expression matching over strings is stateless that is no matching state is maintained.
in contrast in our engine a user can store necessary information in variables that can be used later in subsequence matching.
the query engine is designed independent of the sequential data under analysis and therefore it is highly adaptable to new data sources.
our technique can be applied to analyze sequential se data such as bug report history and source code change history.
these analysis have real world motivations.
considering the following example that was given by a test team leader in microsoft during an interview with the authors the bug report histories are recorded in bug tracking systems but currently no tool is available to analyze them.
this type of information can be important.
for example a bug can be reopened multiple times after it is xed before it is eventually closed and such a bug often indicates a problematic bug or the ignorance of the assigned developers.
there is no easy way for current bug tracking systems to retrieve such bug reports.
often a user can query bug reports of which a bug status was changed to the current value but cannot query if the bug status was ever changed to a temporary value in a sequence of revisions.
in our approach we can write the query in figure with one auxiliary variable three revision events of interest a pattern body described in the syntax of regular expressions specifying the pattern of initially resolved then reopened one or more times and nally closed and a where clause specifying that we are only interested in bug reports that are reopened more than twice.
int counter an event defines an element of interest in a sequence indicated by the expression surrounded by the brackets.
event resolved status resolved event reopened status reopened an action to update the variable counter counter event closed status closed the following is the pattern body resolved reopened closed where counter figure spql query to retrieve bug reports which are resolved rst then reopened more than twice and nally closed current bug tracking systems do not support this query.
even if we have direct access to the back end database it is hard for us to express this query in sql as the query involves temporal properties among rows of the table exceeding the expressiveness of sql.
in order to ful ll the same task we need to write a program to directly interact with the back end database.
assume that the revision history of each report is already read into a list seq we need to manually write the following java code which implements exactly the behavior of the spql query in figure .
note that the code is simpli ed for illustration purpose.
besides the function match the whole program should also implement otherfunctions to retrieve the bug reports into memory by executing sql statements and construct a list of revision history for each bug report.
boolean match list revision seq int index boolean fixed false while index seq.size revision r seq.get index if r.field.equals status r.new value.equals resolved fixed true break whether the report is fixed before?
if !fixed return false int counter while index seq.size revision r seq.get index if r.field.equals status r.new value.equals reopened counter whether it is reopened more than twice?
if counter return false revision last seq.get seq.size whether the last status is closed?
return last.field.equals status last.new value.equals closed figure a sample java program implementing the query in figure partial we have implemented the proposed language and its runtime engine and applied it to analyze the evolution of eclipse bug reports between and and code revisions of android between and .
the case studies reveal that the proposed approach can enable stakeholders to investigate complex sequential se data in a repository with a few lines of code and the matching overhead is low.
the results show that the proposed language and tool can complement the searching functionality of the existing software repository management systems and can help improve software engineering practice.
we summarize our contributions as follows .
we propose a new pattern matching based approach for analyzing sequential software engineering data.
we design a query language spql and a matching algorithm for retrieving the data records that satisfy speci ed sequential patterns.
.
we implement an e cient runtime engine to support spql and the retrieval overhead is negligible.
.
we explore the application scenario of the proposed approach in software development and maintenance process.
this paper is organized as follows.
section describes necessary background.
section introduces the syntax and the semantics of the spql query language.
section describes the design of query engine that supports spql.
section describes the overview of the tool implementation.
section 6describes the case studies that illustrate the application scenarios of the proposed query tool.
section surveys related work followed by section that concludes the paper with future work.
.
background many kinds of se data exhibit the sequential nature.
a series of revisions can be made to these data.
each revision may update the values of certain elds in the data records.
we refer to the current value of the data records as a snapshot of the evolution history.
speci cally the sequential se data can be expressed as a series of snapshots seq he1 e2 eni whereei i n is a snapshot and is sorted in chronological order.
notation wise we use jseqjto denote the number of snapshots in seq seq to denote the i th snapshot ei and seq where i j jseqj to denote the subsequence ofseqhei ei eji.
in this paper we use two types of se data bug report history and source code change history to illustrate the proposed query approach.
.
bug report history nowadays bug tracking systems such as bugzilla and jira have been widely adopted in software development and maintenance processes.
they enable developers testers and users to track the bug status.
initially when a bug is found by a tester or user he she can le a new report in the system.
if reproducible the bug is accepted and assigned to a developer.
after the bug is xed the tester veri es and closes it.
all these status transitions are recorded in the repository.
moreover stakeholders can update the elds of a report at any time.
during the lifetime of a bug report from its being initially opened to nally closed there is usually a series of such revisions referred to as evolution of bug reports.
such history information is an essential indicator of software process maturity in an organization .
table shows the evolution of the eclipse bug report .
this bug report was originally led on october and went through following up revisions.
therefore the history of bug report has snapshots.
each row in the table represents one snapshot and the changed elds are highlighted in bold.
for example in the second snapshot the severity of the bug was promoted from normal tocritical and the priority was promoted from p3 top1.
table the evolution history of eclipse bug report containing snapshots date product comp.
severity pri.
status jdt debug normal p3 new jdt debug critical p1 new jdt debug critical p1 assigned platform ui critical p1 assigned platform ui critical p1 new platform debug critical p1 new platform ui critical p1 new platform ui critical p1 resolved .
source code change history software is constantly evolving due to changing user requirements new product features bug xes or refactoring.changes to software are inevitable.
the developers are assigned a new feature or a defect to work on upon a change request.
after coding is complete they commit the changes for integration via a version control system such as svn or git .
during a long period of software evolution many developers could be involved in modifying a same le .
table shows a segment of the revision history of the le core java android webkit webview.java in android git repository.
this le went through revisions.
each row represents a revision to the le.
note that the table only shows three attributes of each revision and the other attributes are hidden due to space constraint.
table a segment of the revision history of webview.java in android date committer log leon scroggins if the dom changes text eld ... nicolas roard layers support cary clark extract selected text from ... leon scroggins show label information as ... leon scroggins info only when accessing a ... .
query language we design a s equential p attern q uery l anguage spql to query sequential software engineering data.
in this section we introduce the syntax of spql and its dynamic semantic model.
.
language syntax the spql language is designed to be similar to regular expression and the underlying matching is performed based on non deterministic nite automata nfa .
however the expressiveness of regular expressions is limited as the matching is simple character equality testing and stateless.
in order to meet the requirements of se data analysis our pattern language incorporates complex matching predicates and also introduce global variables which can save necessary information during matching and such information can be used in the later matching tests.
generally a pattern de nition consists of the following four components .variable declaration .
variables are globally accessible in all matching predicates.
they can be used to store necessary information or to evaluate matching predicates.
.event de nition .
each event de nition speci es the condition under which a snapshot is matched and the actions to update global variables if the matching is successful.
.pattern body .
the body de nes the sequential pattern.
the syntax is similar to regular expressions.
.where clause .
this clause speci es the last criterion whether the se data evolves in the given pattern.
after matching the pattern body against a sequence of snapshots the global variables are updated with new values.
this clause tests whether the valuation of the global variables satis es a certain condition.
figure displays the backus naur form bnf grammar of our query language.
as shown in the rule htypei thehtypei int j string j bool j float j list j set hvardecli htypeihvarnamei hexpi h eldi the attributes de ned in the schema harglisti hexpi hexpi ?
hlistexpi hsetexpi harglisti hexpi hintijhstringijhboolijh oatijhchari j hlistexpijhsetexpi j h eldijhvarnamei j huopihexpijhexpihbopihexpi j hfunc namei harglisti hstmti hvarnamei hexpi heventi event hevent namei hexpi hstmti hregexpi hevent nameij .
jhregexpihkleenei j hregexpihregexpij hregexpi j hregexpi hregexpi hkleenei j j ?
hwherei where hexpi hpatterni hvardecli heventi ?hregexpi ?
hwherei?
figure bnf grammar of spql language language supports four primitive types and two aggregate types of data types frequently used in software engineering data matching predicates and statistics computation.
a variable declaration hvardeclispeci es the type and the name of a variable with its initial value.
an expression hexpi evaluates to a value from a string boolean number literal a read from a variable a eld of a snapshot compositional computation over expressions with binary operators hbopi e.g.
or unary operators huopi e.g.
!
and or a function call.
the language is independent of domain speci c snapshots.
the production rule h eldiis a list of attribute names dened in the provided schema le.
an eventheventirepresents a speci c snapshot of interest in sequential se data and speci es the following two components matching predicate is the expressionhexpienclosed within the brackets the condition under which a snapshot is matched.
post action .
ifhexpiis evaluated against a snapshot totruethen the statements within the curly braces are executed subsequently.
we refer to these statements aspost action and they update the variables according to the current values of global variables and the elds of the snapshot under matching.
the pattern body follows the syntax of regular expressions to specify temporal properties.
a pattern body can be asingle event hregexpihregexpi concatenation of pattern bodies hregexpijhregexpi alternative between two pattern bodies hregexpihkleenei kleene structures moreover it supports the operator to force the matching to start from the very beginning of the data to force the matching to end at the last snapshot of the data operator .
to match any single snapshot.
it also supports ?
and to post x a pattern p p?
to match zero or one p p to match one or more p andp to match zero or more p. int start day int end day event definitions event non p1 priority !
p1 event first priority p1 start day date event other priority p1 event last priority p1 status closed end day date non p1 first other last pattern body where end day start day where clause figure a query to retrieve high priority bug reports xed within days figure shows an example query.
it retrieves bug reports which are xed within days after their priorities become the highest level p1.
given an evolution history of a bug report h he1 e2 eni this pattern requires the following .
the matching should start from the rst snapshot e1 ofh indicated by .
zero or more snapshots from the start of h i.e.
none or h where i jhj can be with non p1 priority indicated by non p1 .
the rest of the snapshots must be with p1 priority and the last snapshot must be closed indicated by rst other last .
the global variable start daystores the date when the bug report is assigned with p1 and the variable end day stores the date when the bug report is closed.
.
the where clause speci es that the time span between the date when the report becomes p1 priority and the date when it is closed should not exceed days.
.
dynamic semantic model in order to facilitate describing the execution model we rst formulate necessary concepts for matching predicates post actions and where clause de ned in pattern queries.
given a pattern query q let pred denote the set of matching predicates actdenote the set of post actions de ned in the event de nitions and where denote its where clause.definition valuation .
lethv1 vnibe the list ofnvariables de ned in q and the cartesian product of the variable domains is denoted as d q d q dom v1 dom vn then a valuation of qis an element ofd q hval1 val ni2d q where8i2 dom vi denotes the domain of variable vi andvali2dom vi .
note that a valuation is not a value of a single variable.
it is a vector de ned over the whole set of global variables and an element in the vector is a value corresponding to a distinct variable.
let denote the set of snapshots the matching predicates pred2pred can be formally de ned as pred d q !ftrue falseg matching predicate where true represents that a snapshot s2 matches the predicate pred under the variable valuation v2d q false otherwise.
similarly a post action act2actcan be formally de ned as act d q !d q post action which takes as input a snapshot and a variable valuation and returns a new valuation after computation.
the where clause can be formalized as where d q !ftrue falseg where clause testing whether a variable valuation satis es a criterion.
the dynamic semantics of our query language is based on the interpretation of nfa.
each pattern query is compiled into an execution model.
the pattern body is translated into an nfa by thompson s method and the matching predicates and post actions in the event de nitions are compiled as the labels of the transitions.
definition nfa .
the nfa corresponding to the pattern body is de ned as a tuple f hq e i where q a set of vertices referred to as states e q q a set of directed transitions between states e!pred f g a function assigning a matching predicate in pred to a transition.
an transition can be taken without consuming a bug report snapshot from an evolution history.
it is introduced when we compile pattern bodies containing alternatives orkleene structures by thompson s method .
e!act f g a function associating each transition with an action.
an action simply returns the input valuation without modi cation.
the start state of this nfa.
the accepting nal state of this nfa.
the special symbols and are not encoded into the model but handled in algorithm .
figure shows the execution model compiled from the query in figure .
graphically we represent a transition as spred !
actt wheresis the source state tis the sink state pred above the arrow is the matching predicate and act below the arrow is the post action.
if pred is evaluated to true then the action actis executed otherwise not.
if pred oractis empty we just leave it blank.
figure the nfa compiled from the query in figure .
this nfa is associated with two variables and one where clause.
the labels for predicates or post actions are omitted.
similar to the standard interpretation of nfa with strings given a sequence of bug report snapshots he1 e2 eni we interpret the nfa from the start state with the sequence and at each non transition spred !
actt we consume a snapshotefrom the sequence and test whether the current valuationvof global variables and ecan satisfy pred e v .
if yes we set the global variable valuation with act e v .
during matching if the nal state is reached and the valuation of global variables satis es the where clause we report that the given snapshot sequence matches the pattern query.
.
query engine this section describes the algorithm underneath the runtime engine for implementing query matching testing.
the proposed matching algorithm is based on the concept of nfa simulation.
nonetheless di erent from the classic nfa simulation for regular expressions over simple strings spql queries support global variables which can not only participate in the matching predicates but also be updated during matching.
section .
describes the details of this pattern matching algorithm and section .
analyzes its time and space complexity.
.
main algorithm algorithm lists the main algorithm for the pattern query matching.
given a set of sequential se data seqand a pattern query q this algorithm returns true ifseqmatchesq.
it rst compiles the query into an nfa nfa and then delegates the matching test to the function match de ned in algorithm .
generally match tests whether a subsequence seq where i j jseqj can be accepted by nfa.
ifqhas been speci ed that the matching should start from the head of seqwith the symbol then match is called at line with the whole seq.
otherwise the algorithm iterates through seqat line and invokes match for each subsequence seq until it nds a match.
the queryqis likely speci ed with the symbol that the matching must end at the tail of seq i.e.
matchingend and this part is handled in the function match .algorithm main algorithm input seq the sequential se data input q the pattern query output trueifseqmatchesq false otherwise 1letnfadenote the nfa compiled from the query q 2letmatchingend denote whether qhas ifqhas then matching starts from the head of seq return match nfa seq matchingend fori tojseqjdo if match nfa seq matchingend then return true .
matching algorithm in classic regular expressions each pattern is rst translated into an nfa before matching.
due to the nondeterminism of nfa there are three ways to test whether a string can be accepted by the nfa.
the rst way is to convert an nfa to a deterministic nite automata dfa as for a character at each state in dfa there is at most one available transition to take as the next step.
the second way is backtracking such as the implementation of regular expression in perl programming language.
it searches for a valid path from the start state of nfa to the nal state.
if a path becomes not feasible it backtracks to a previous state and branches to another path.
since the number of paths in an nfa can be exponential this implementation may suffer from severe performance overhead.
the last approach is multiple state simulation of nfa proposed in .
it maintains a setsof reached states.
initially scontains the start state .
givensand a character the algorithm searches the nfa for a set s0of next states reachable from the states in s. in the next iteration the algorithm uses s0as the starting point to search for the reachable states.
it repeats this process until the accepting state is reached.
compared to the backtracking approach as the multiple state simulation does not need to maintain a path it is much e cient.
suppose the length of the string is mand the number of states in nfa isn then the time complexity is o mn .
in our runtime engine we opt for the simulation approach mainly for its e ciency.
the reason that we do not choose the rst approach is the di culty in converting the nfa ofspql to dfa.
di erent from regular expressions our query language involves complex matching predicates and it is possible that two matching predicates may partially overlap.
for example say there is one nfa state with two outgoing matching predicates x andx .
to convert this nfa we need to analyze these two predicates and separate them into three disjoint predicates x x andx .
this separation process is complex and expensive as a matching predicate can be a compound of multiple predicates.
moreover a matching predicate can be associated with a post action and this further complicates the dfa approach.
algorithm implements the core matching algorithm.
it takes as input an nfa nfacompiled from the query a list of report snapshots and a boolean value matchingend indicating whether the matching should end at the tail of the list.
if matchingend is true this algorithm returns true if the whole listcan be accepted by nfa.
if matchingend isalgorithm match nfa list matchingend input nfa nfa compiled from the query input list a list of snapshots input matchingend whether to match the end of list output whether listmatchesq 1prev f init g where is the start state of nfaand init is the initial valuation of global variables fori tojlistjdo snapshot list current ?
foreach state valuation in prev do trans the set of non transitions reachable from state via or more transitions foreach spred !
acttin trans do if pred snapshot valuation false then snapshot and valuation dissatisfy the matching predicate pred continue valuation0 act snapshot valuation current current f t valuation0 g if t6 where valuation0 then tis not final state or where clause is not satisfied continue tis the final state and where clause is satisfied if matchingend then if i jlistjthen return true else return true prev current return false false it returns true if there exists a subsequence list i which can be accepted by nfa.
as aforementioned the multiple state simulation in regular expression matching maintains a set of reached nfa states.
di erently this algorithm maintains a set of pairs as our approach supports global variables.
in particular in each pair state valuation the rst element is an nfa state and the second element is a valuation of global variables.
a pair means that there exists at least one path from the start state to the state such that the list of post actions associated to this path updates the global variables to the valuation .
the set prev declared at line is stores the reached statevaluation pairs.
initially it only contains the pair init where is the start state of nfaand initis the initial valuation of global variables.
the loop at line iterates through thelistfrom the head to the tail and advances the matching innfa.
the set current declared at line is the set storing the next state valuation pairs by consuming the snapshot list initially ?.
the loop at line implements the logic to propagate current from prev.
after the propagation is done the set prev iscleared and assigned with the content ofcurrent at line for the next iteration of propagation.
the following generally describes the process to propagate current .
for each pair state valuation inprev i.e.
line the algorithm searches nfato collect all the non transitions which are reachable from the state via zero or more transitions.
for each spred !
acttof such transitions if the current snapshot and the variable valuation can satisfy the matching predicate pred then we compute a new variable valuation valuation0by executing the associated post action actover snapshot and the old valuation .
i.e.
line .
.
complexity analysis this section analyzes the complexity of algorithm .
given a sequence listof bug report snapshots a spql queryqand the nfa nfacompiled from q we use the symbols in table to facilitate the analysis of time and space complexity.
table symbols for complexity analysis l the length of list l jlistj m the number of non transitions in nfa d q as de ned in de nition it denotes the set of all possible valuations for variables in the query q c we assume that for each nfa state it has a constant number c of reachable non transitions via or more transitions i.e.
jtransj cat line .
in the worse case c m. based on the loop at line for each pair in prev it is possible that the cnon transitions in trans at line generate cdistinct state valuation pairs.
assuming prev hasxpairs then after the loop at line prev will have c x pairs.
initially the set prev contains only element at line .
for the rst snapshot in list prev grows to c elements.
for the second snapshot prev grows toc2elements.
then c3 c4 and for the last snapshot prev hasclelements in the worst case.
the total number of pairs ever in prev is o c c2 cl .
hence the time complexity is o l whenc and iso cl whenc .
the space complexity is o cl which is the maximum size of the set prev.
as each element in prev is a pair of an nfa state and a valuation the size is also bounded by m d q .
again similar to time complexity the space complexity is also manageable.
.
tool implementation we have implemented the proposed language spql and the runtime engine in java.
figure displays the overall framework of our tool.
its core is the query engine which accepts as input spql queries from users searches the underlying databases and returns the matching results to the users.
the tool is designed to be independent of speci c se data sources and is adaptable to new data sources and application domains e.g.
behavior logs .
when applying spql to a domain users only need to prepare the following two components schema which describes the attributes of data in a domain.
each attribute has an associated type and name.
for example the schema of bug report includes creation date product severity priority etc.
adaptor the query engine abstracts and models data as sequences of snapshots.
an adaptor is an intermediate layer between this abstraction and the domainspeci c database.
it allows the engine to access the figure the overall framework of our tool database without knowing the details and design of the database.
the adaptor must be implemented consistently with the corresponding schema.
that is when the adaptor converts a data record in the database into a snapshot in a sequence all the attributes of the snapshot must conform to the schema.
.
application scenarios in order to evaluate the e ectiveness and e ciency of the proposed approach in querying di erent types of se data we describe two studies in this section and show how the proposed approach can be used to accomplish them.
the case studies are conducted on a laptop with intel core i7 .70ghz and gb memory.
.
detecting violations in bug management process in this task we use spql to express several violation patterns in the bug management process.
these violation patterns are learnt from historical process execution data using a contrasting pattern mining algorithm .
they are meaningful to the bug management process of a speci c commercial bank introduced in .
however we believe that even though they may not be deemed as anomalous to bug management processes of other organizations they can still provide some hints to further improve the process quality.
moreover our query language is general and stakeholders can always deploy their own organization speci c violation patterns to monitor their bug handling process.
in this study we collect the eclipse bug reports from to .
for each bug report its evolution history is recovered by crawling its modi cation history page.
after removing the reports with no revision history or required elds product component severity etc.
we get bug reports in total.
table distribution of evolution history length range number percent.
.
.
.
.
table shows the statistics on the number of bug report snapshots.
the rst row is the range of number the secondrow is the total number of bug reports within that range and the last row is the percentage.
the results show that around .
bug reports status have been updated more than times snapshots .
the maximum number of bug report snapshots is .
.
.
closed right after assigned when a bug report is assigned to a developer the developer needs to set the report status to resolved before closes it.
a violation pattern is that a bug report is closed right after it is assigned without any other status in between which is not allowed by the eclipse bugzilla usage guide either.
we use the following query to ful ll this task.
event closed status closed event assigned status assigned assigned closed this query takes .
second to nish and returns matching reports.
we manually read the returned bug reports and con rmed their validity.
for example bug report was initially new then assigned to a developer and later directly closed without being resolved.
according to the eclipse bugzilla usage guide there should exist at least one state of resolved before the bug is closed.
therefore the handling process of these bug reports violates the guidelines.
we could integrate our tool to a bug tracking system to automatically detect the violation patterns in a bug repository.
such an integration can also automatically alert the users when they try to directly close the bug without resolving it thus avoiding a process violation.
this could be an interesting application of our approach in future.
.
.
product change analysis in this task we analyze the following problem how many bug reports product eld is changed?
the product eld is important for bug triage .
it is set by the bug reporter and supposed not to change frequenly over time.
however the reporter may not thoroughly understand the bug at the beginning and may assign the bug to a wrong product.
when developers get to know the bug better they can change this eld accordingly.
we use the following query to ful ll this task.
string prev product event first true prev product product event change prev product !
product prev product product event no change prev product product first no change change no change table distribution of product changes changes no.
pct.
changes no.
pct.
.
.
.
.
.
.
0the distribution of product changes returned by this query is displayed in table .
the column changes shows the number of changes made to the product eld the column no.
shows the absolute number of reports with the corresponding changes and the column pct.
shows the percentage.
the results show that around .
of bug reports have their product status changed at least once.
.
analyzing file revision history in this section we show how spql can be applied to analyze le revision history.
previous empirical studies found that when more people work on a le it has more failures .
thus it is interesting to know the number of people who have ever touched a particular le.
this could help project teams identify potential problematic code and design better source code change policies.
table distribution of revision history length range number percent.
.
.
.
.
.
we collected the revision history of the android source code les between and .
there are les and each le is associated with a sequence of revisions.
in total there are code revisions.
table shows the statistics of the length of each le revision history.
there are .
les that have gone through more than revisions.
we apply spql to nd out which les are revised by multiple developers within a period of time.
the following query searches for the android les that are modi ed by more than developers within a month.
the variable authors stores the committer names and the where clause tests whether the retrieved segment of the le revision sequence satis es the criterion.
int first day int last day set authors event first event true first day committer date authors add authors committer event other event true last day committer date authors add authors committer first event other event where last day first day size authors it takes seconds to execute this query and les are returned including the le webview.java in table .
compared to the experiments on eclipse bug report evolution querying android le revision history takes longer time.
this is because of the larger amount of the le revision data.
figure shows the details of the runtime performance.
the x axis is the length of the revision sequences and the yaxis is the average time taken to match the query against the sequences.
from the plot we can draw the conclusion that in0 length of sequencesruntime ms figure runtime millisecond of matching w.r.t length of revision sequences general the runtime performance increases with the length of sequences and the maximum time is around second even for sequences containing more than snapshots.
.
discussions our language is a general language that can be applied to many application scenarios.
we have shown how spql can be used to analyze temporal properties beneath the bug report and le revision data.
all the queries are concise and most of them are within lines of code.
the following discusses how spql is related to the sql based and programming based approaches.
sql.
the backend of a bug repository is a relational database.
assume we have direct access to the backend database we could perform queries in sql.
however we do not believe this is a good solution.
first as illustrated by figure not all queries especially those involving temporal properties can be expressed in sql.
second the bug tracking system needs to expose the implementation details to the user and the users are required to master advanced sql features such as table joins and group clauses.
programming based approach .
all of the queries described in this paper can be answered via programming.
however it could cost much more time than writing a short spql query.
for example the program in figure is much longer than the spql query in figure .
our approach provides users a simple and lightweight method for answering complex queries.
.
threats to validity our case studies are subject to two threats to validity.
internal validity .
the rst is threat to internal validity which is the possible aws in the implementation of thespql runtime engine.
to minimize this threat we rst wrote and executed considerable unit and system test cases to explore di erent aspects of the runtime engine.
second in addition to the queries used in this paper we also wrote other queries to investigate bug report history.
lastly we implemented a variant of the matching algorithm algorithm specially optimized for queries without variables.
this variant runs faster and also serves as a reference to check the correctness of the implementation of algorithm .
external validity .
our empirical evaluation is subject to threat to external validity with regard to the concern that the experimental results might not generalize to other queries or datasets.
regarding the runtime as the evolution history of a bug report in the eclipse repository is usuallynot long our engine can respond quickly within seconds.
the experiment on android le revision history takes longer time which is mainly due to the longer sequences and the retrieval of all quali ed segments within a sequence.
we believe this could be alleviated by con ning the length of a segment to search as people are mostly interested in revisions within a nite interval of time.
the runtime performance also depends on the complexity of queries.
.
related work this section surveys three lines of research related to our work querying software repository software process evaluation and program matching and monitoring.
.
querying software repository many software repository management tools provide users with searching functionalities.
for example in bugzilla and jira a user can specify predicates on elds in bug reports and the two systems return the bug reports satisfying the conditions to the user.
a predicate could be like the eld summary should contain a speci c word or the eld product should be a speci c value .
both systems also provide support for retrieving bug reports with evolution history predicates.
especially jira has an advanced and expressive query language jql to retrieve bug reports with predicates on revision histories.
for example jql has a keyword was to retrieve bug reports which currently have or previously had the speci ed value for the speci ed eld.
the other keyword changed is used to retrieve bug reports having a value which had been changed for the speci ed eld.
from an evolutionary perspective the expressiveness of jql is still limited.
it only supports querying the modication in a single bug report revision but cannot capture temporal properties involving multiple revisions such as the analysis task in figure .
moreover it does not support variables in queries and therefore it is impossible to collect information during matching for complex analysis tasks.
in contrast our query language spql supports global variables and is able to express complex temporal patterns involving multiple revisions.
the variables and the where clause make spql capable of ful lling considerable types of analysis tasks as shown in our case studies.
regarding the implementation jql translates queries into sql statements and uses its database system as the runtime engine whereas spql bases its runtime engine on nfa to capture temporal properties in a sequence of revisions.
however spql is not a replacement but a good complement of jql.
we believe that incorporating spql into the current bug tracking systems will further improve their searching functionalities.
kenyon is a system that extracts source code change histories from scm systems such as cvs and subversion .
kenyon automatically checks out the source code for each revision and extracts change information such as the change log author change date etc.
kim et al.
proposed tare as an exchange language for mining software repositories .
it is envisioned that ta re can support the representation and integration of software change transaction and project data mined from scm software con guration management systems.
researchers have also proposed semantic web based approaches to integrate and query software engineering data collected from di erent softwarerepositories .
however the above related work does not provide features for users to perform temporal properties related queries.
hindle and german proposed scql a rst order temporal logic based query language for source control repositories.
scql is able to represent the temporal relationships such as before and after .
scql requires a formal model of source control repositories while our spql speci es the temporal properties using regular expressions.
spql is also enhanced with variables and statements to store and manipulate matching states.
in particular our work is di erent from debugadvisor and boa .
in debugadvisor when a developer is diagnosing a bug he she can issue a fat query containing natural language description of the bug core dumps execution traces etc.
to the system and the system returns all the associated artifacts including patches of similar bugs which have been xed before.
in this way the developer may nd a clue or hint quickly to solve the bug.
boa is a language and infrastructure to ease the analysis of software repositories.
users can write small boa programs to implement complex analysis tasks in research on software repository mining.
similar to these work our work also proposes a language and tool for querying software repository.
however we focus more on the temporal properties and enable users to analyze sequential se data.
.
software process evaluation chen et al.
propose a machine learning approach to evaluating a software defect management process.
in detail the lifetime of a bug report corresponds to an execution of defect management process and such an execution is represented as a sequence of status transitions of the bug report.
based on the process speci cation and process evaluators expertise each execution is classi ed as normal or anomalous .
their approach rst learns a binary classi cation model from the historical evaluation results and then applies the model to classify future process executions.
sun et al.
further improves this approach by mining explicit evaluation rules from evaluation history.
each rule is capable of explaining why a process execution is evaluated as normal oranomalous .
our query language can be used to express the mined evaluation rules as violation patterns which can be deployed to monitor the running process execution.
if an execution matches a violation pattern the defect process monitor can inform stakeholders of the anomalous state of the execution.
.
program matching and monitoring a line of remotely related research is program matching and monitoring.
brunel et al.
propose an extension to computation tree logic with variables and use this logic extension to match code snippets in system code of linux in order to perform collateral code evolutions .
martin et al.
propose program query language to check whether runtime behavior of an application conforms to speci ed design rules.
meredith et al.
propose to use parametric context free grammars to express desired program behaviors and base the runtime monitor on lr parsing algorithm to check property conformance.
our work is di erent from these studies.
first the application domains are di erent.
second the declaration of variables in spql is more exible and the variables can be used to aggregate information.
but those variables usedin these studies are mainly for selecting runtime events of interest.
.
conclusions and future work many types of software engineering data have the sequential nature and preserve temporal properties.
in this paper we propose a pattern based approach to e ectively and e ciently analyzing sequential software engineering data.
we have presented a query language spql as well as the associated query engine.
we have shown that the proposed approach can be used to analyze di erent types of sequential se data including bug evolution source code revisions and user logs.
the analysis results can help users better understand a software process and identify violations.
there are many interesting directions we would like to explore in future work.
for example parametric queries .
in a parametric query a user can use parameters in initial values of variable declarations matching predicates post actions and where clauses.
before executing the query the user instantiates the parameters and the parametric query becomes non parametric.
with this feature a category of analysis tasks can be further simplied by varying parameters.
more query languages .
it would be interesting to support more types of query languages.
similar to we can allow users to write queries in di erent logics.
for example a query can be written in regular expressions linear temporal logic computation tree logic or even more expressive context free grammars.
due to di erent degrees of expressiveness and di erent design purposes of these logics this feature will provide users with more freedom for expressing their intentions.
intgeration .
our approach can be integrated into existing bug tracking systems and version control systems to help users identify problems in software development and maintenance process.
user studies .
although spql is designed to be a lightweight query language and the tool is designed to be adaptable to new data sources the usability of the language and tool should be evaluated.
in future we will perform user studies to further evaluate the e ectiveness of the proposed approach in practice.
.