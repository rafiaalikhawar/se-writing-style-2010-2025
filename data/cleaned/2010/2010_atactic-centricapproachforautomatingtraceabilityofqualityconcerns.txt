see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation a tactic centric approach for automating traceability of quality concerns conf erence paper in proceedings int ernational conf erence on softw are engineering june .
ic se.
.
citations 97reads author s including mehdi mir akhorli association f or computing machiner y publica tions citations see profile yonghee shin publica tions citations see profile jane cleland huang dep aul univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y mehdi mir akhorli on f ebruar y .
the user has r equest ed enhanc ement of the do wnlo aded file.a tactic centric approach for automating traceability of quality concerns mehdi mirakhorli yonghee shin jane cleland huang and murat cinar school of computing depaul university chicago il m.mirakhorli acm.org yshin cdm.depaul.edu jhuang cs.depaul.edu murat.cinar87 gmail.com abstract the software architectures of business mission or safety critical systems must be carefully designed to balance an exacting set of quality concerns describing characteristics such as security reliability and performance.
unfortunately software architectures tend to degrade over time as maintainers modify the system without understanding the underlying architectural decisions.
although this problem can be mitigated by manually tracing architectural decisions into the code the cost and effort required to do this can be prohibitively expensive.
in this paper we therefore present a novel approach for automating the construction of traceability links for architectural tactics.
our approach utilizes machine learning methods and lightweight structural analysis to detect tactic related classes.
the detected tactic related classes are then mapped to a tactic traceability information model.
we train our trace algorithm using code extracted from fifteen performance centric and safety critical open source software systems and then evaluate it against the apache hadoop framework.
our results show that automatically generated traceability links can support software maintenance activities while helping to preserve architectural qualities.
keywords architecture traceability tactics traceability information models i. i ntroduction software traceability provides critical support for a broad range of software engineering activities including impact analysis regression testing and compliance verification.
unfortunately the cost and effort required to establish and maintain effective and accurate traceability links can be inhibitively expensive often resulting in organizations implementing only the minimal traceability needed to comply to regulatory or process guidelines.
this problem is especially evident when it comes to tracing quality concerns which describe system level attributes such as security reliability performance and safety.
such concerns are often addressed in the solution domain through the strategic adoption of architectural tactics which we informally define as re usable solutions for satisfying a quality concern.
a more formal definition is provided by bachman et al.
who define a tactic as a means of satisfying a quality attribute response measure by manipulating some aspects of a quality attribute model through architectural design decisions .
there are many different kinds of tactics.
for example a system with high reliability requirements might implement the heartbeat tactic to monitor availability of a critical component or the votingtactic to increase fault tolerance through integrating and processing information from a set of redundant components.
unfortunately unless these architectural decisions are fully documented architectural knowledge can be lost over time and as a result there is a tendency for system quality to degrade as developers modify components without fully understanding the underlying design decisions.
current software engineering tools practices and supporting traceability techniques contribute to this problem through failing to make underlying design decisions and their related quality concerns visible to software engineers .
at the same time quality concerns tend to have a crosscutting impact on the solution and can therefore affect numerous components and exhibit complex interdependencies .
this introduces a dilemma.
on one hand it can be difficult and costly to trace quality concerns into the architectural design as the end result may involve creating and maintaining an almost impossible number of traceability links but on the other hand failing to trace architectural concerns leaves the system vulnerable to problems such as architectural degradation.
this paper therefore presents a novel and cost effective approach for tracing architecturally significant concerns specifically those concerns which are implemented through the use of common architectural tactics.
the proposed process involves the steps depicted in figure .
first a tacticclassifier identifies all classes related to a given tactic and then establishes tactic level traceability through mapping those classes to the relevant tactic.
second a more finelytuned classifier is used in conjunction with lightweight structural analysis to identify the subset of classes which play clearly defined roles in the tactic.
for example in the case of the heartbeat tactic the classifier attempts to identify heartbeat emitter and heartbeat receiver roles or in the case of the voting tactic it attempts to identify voting coordinators andvoters .
the detected tactic related classes are then mapped to tactic traceability information models ttims which anchor the traceability process and connect the classified classes to a relevant set of design rationales requirements and other related artifacts .
the novel contribution of this work is twofold.
first it introduces and evaluates a set of algorithms and processes designed to automatically reconstruct traceability links for architectural tactics.
this builds on our prior work .
c ieee icse zurich switzerland 639tactic related code snippets role related classes indicator terms role related code snippets training phase fine grained classification phase fine grained lightweight structural analysis tactic related classes training phase coarse grained system to be traced classification phase coarse grained indicator terms identified classes mapped to proxies in ttims trace matrix classes classes coarse grained class to tactic mapping role grained class to tactic mapping links generated automatically from mappings classes code code classes links evaluated upon first use.
figure .
an overview of the tactic related trace reconstruction process which required all traces to be created manually.
second we contextualize our work through an extended study showing the use of architectural tactics in performance centric faulttolerant software systems.
the remainder of this paper is laid out as follows.
section ii provides a more detailed explanation of architectural tactics and introduces the concept of tactic traceability information models.
sections iii iv and v describe our tactic classifier and the approach we took to identify tactic related classes and their associated tactic roles.
section vi presents a case study in which traceability links were automatically reconstructed for tactics in the apache hadoop framework and then used to support a simulated software maintenance problem.
the paper concludes with a discussion of threats to validity related work and conclusions.
ii.
a rchitectural tactics architectural tactics come in many different shapes and sizes and describe solutions for a wide range of quality concerns .
for example reliability tactics provide solutions for fault mitigation detection and recovery performance tactics provide solutions for resource contention in order to optimize response time and throughput and security tactics provide solutions for authorization authentication non repudiation and other such factors .
table i depicts the architectural tactics we identified through inspecting the code and supporting documentation of performancecentric fault tolerant open source software systems.
our analysis focused on different tactics and clearly highlighted the pervasive nature of architectural tactics in the examined systems.
a. tactics selected for study due to the significant cost and effort of manually constructing the answer sets needed to evaluate our approachagainst non trivially sized projects we limited the work described in this paper to the heartbeat scheduling resource pooling authentication and audit trail .
these tactics were selected because they represented a variety of reliability performance and security concerns.
the tactics are defined as follows heartbeat one component emits a periodic heartbeat message while another component listens for the message.
the original component is assumed to have failed if the heartbeat fails.
this tactic is used to achieve reliability goals.
scheduling resource contentions are managed through scheduling policies such as fifo first in first out fixedpriority and dynamic priority scheduling.
resource pooling limited resources are shared between clients that do not need exclusive and continual access to a resource.
pooling is typically used for sharing threads database connections sockets and other such resources.
authentication ensures that a user or a remote system is who it claims to be.
authentication is often achieved through passwords digital certificates or biometric scans.
audit trail a copy of each transaction and associated identifying information is maintained.
this audit information can be used to recreate the actions of an attacker and to support functions such as system recovery and nonrepudiation.
b. tactic traceability information models our approach to tracing architectural tactics builds upon the fundamental concept of ttims described in our earlier work .
the ttim concept emerged as a result of an earlier study of tactical architectural decisions which we conducted across a wide range of software intensive systems including the airbus a320 family boeing boeing 7j7 nasa robots and also performance centric systems such as google chromium os .
each ttim640table i ananalysis of tactics across several open source projects fault tolerant performance centric software systems from sourceforge heartbeat scheduling authentication audit trail resource pool.
active repl.
recovery passive repl.
authorization permiss.
check crc encryption process monitor rem.
service fault detection v oting rife a web application engine with support for content management.
fault tolerant corba omg document ptc carmen robot control software with navigation capabilities rossume an open source robot simulator for control and navigation.
jworkosgi implementation of the jmx and jmx remote api into osgi bundles.
smartfrog distributed application development framework cardamom real time distributed and fault tolerant middleware aclanalyser tool suit to validate verify and debug multi agent systems jfolder web based application development and management tool.
enhydra shark xpdl and bpmn workflow server chat3 an instant messenger.
ace tao ciao framework for high performance distributed real time systems.
google chromium os x4technology tools framework enterprise application software.
openaccountingj web based accounting erp system.
legend included in the code snippet dataset and used for experiments described in this paper for information purposes only describes the elements needed to trace an individual architectural tactic back to its contribution structures i.e.
quality goals rationales intents and forward to the elements that realize the tactic in both the design and the code.
the ttim includes a set of roles describing the essence of the tactic a set of semantically typed links that define relationships between pairs of artifacts and a set of trace proxies which provide mapping points for establishing traceability links.
the tactic itself is modeled as a set of interrelated roles.
for example the heartbeat tactic which is depicted in figure includes the primary roles of receiver emitter and fault monitor .
additional roles not shown in this figure but described in our earlier work include parameters such as the heart beat rate and the heartbeat checking interval .
in this paper we focus only on the primary roles of each tactic.
in addition to roles the ttim also includes a set of reusable semantically typed traceability links.
these include internal links such as lessmuchsends pulse greatermuchwhich define relationships between roles in the tactic as well as a set of external links which are used to establish traceability to the code or the design.
finally the ttim contains a set of trace proxies which are used to transform the traceability task to a simple mapping task.
a developer or analyst has to simply map the proxy onto one or more elements in the architecture and or code in order to establish traceability.
once these mappings are accomplished all of the traceability information embedded in the ttim is automatically inherited by the project.
as a result ttims have been shown to reduce the cost and effort of traceability .
traceability can be established at different levels of granularity .
coarse grained traceability links take less effort to construct and maintain but provide less accurate quality concern requirement fr or nfr reliability availability rationale heartbeat tactic component heartbeat emitter component heartbeat receiver component fault monitor sends pulse monitors fault code proxy heartbeat emitter proxy heartbeat receiver proxy fault monitor tactic link role link role link role link figure .
tactic traceability information model for heartbeat tactic information than finer grained links when actually used .
our approach therefore supports traceability at either the tactic level or the role level as depicted in figure .
iii.
i dentifying tactic related classes although the tactic detection problem may initially appear to be a special case of design pattern recognition it turns out to be more challenging.
unlike design patterns which tend to be described in terms of classes and their associations tactics are described in terms of roles and interactions .
this means that a single tactic might be implemented using a variety of different design patterns or proprietary designs.641for example we observed the heartbeat tactic implemented using i direct communication between the emitter and receiver roles found in chat3 and smartfrog systems ii the observer pattern in which the receiver registered as a listener to the emitter found in the amalgam system iii the decorator pattern in which the heartbeat functionality was added as a wrapper to a core service found in rossume and jworkosgi systems and finally iv numerous proprietary formats that did not follow any specific design pattern.
as a tactic is not dependent upon a specific structural format we cannot use structural analysis as the primary means of identification.
our approach therefore relies primarily on information retrieval ir and machine learning techniques to train a classifier to recognize specific terms that occur commonly across implemented tactics however we also use light weight structural analysis to support the differentiation of specific tactic roles.
to classify classes according to various tactics we utilized an algorithm that we had previously developed to detect nonfunctional requirements nfrs and to trace regulatory codes .
prior studies demonstrated that this algorithm matched or outperformed standard classification techniques including the naive bayes classifier standard decision tree algorithm j48 feature subset selection fss correlationbased feature subset selection cfs and various combinations of the above for the specific task of classifying nfrs in the studied datasets .
the classifier includes three phases of preparation training and classifying which are defined as follows a. preparation all data is preprocessed using standard information retrieval techniques and each class and or tactic description is transformed into a vector of terms.
b. training the training phase takes a set of preclassified code segments as input and produces a set of indicator terms that are considered representative of each tactic type.
for example a term such as priority is found more commonly in code related to the scheduling tactic than in other kinds of code and therefore receives a higher weighting with respect to that tactic.
more formally let qbe a specific tactic such as heart beat.
indicator terms of type qare mined by considering the set sqof all classes that are related to tactic q. the cardinality of sqis defined as nq.
each term tis assigned a weight score prq t that corresponds to the probability that a particular term tidentifies a class associated with tactic q. the frequency freq cq t of term tin a class description c related with tactic q is computed for each tactic descriptiontable ii indicator terms learned during training tactic name document trained indicator termscode trained indicator terms heartbeat heartbeat fault detect messag period watchdog send tactic failur alivheartbeat ping beat heart hb outbound puls hsr period isonlin scheduling prioriti schedul assign process time queue robin higher weight dispatchschedul task prioriti prcb sched thread rtp weight tsi authentication authent password kerbero sasl ident biometr verifi prove ticket purportauthent credenti challeng kerbero auth login otp cred share sasl resource pooling thread pool number worker task queue executor creat overhead minpool thread connect sparrow nbp processor worker timewait jdbc ti audit trail audit trail record activ log databas access action monitor useraudit trail wizard pwriter lthread log string categori pstmt pmr insq.prq t is then computed as prq t nq summationdisplay cq sqfreq cq t cq nq t n t npq t npq c. classification during the classification phase the indicator terms computed in equation are used to evaluate the likelihood prq c that a given class cis associated with the tactic q. letiqbe the set of indicator terms for tactic qidentified during the training phase.
the classification score that class cis associated with tactic qis then defined as follows prq c summationtext t c iqprq t summationtext t iqprq t where the numerator is computed as the sum of the term weights of all type qindicator terms that are contained in c and the denominator is the sum of the term weights for all type qindicator terms.
the probabilistic classifier for a given type qwill assign a higher score prq c to class c that contains several strong indicator terms for q. classes are considered to be related to a given tactic qif the classification score is higher than a selected threshold.
iv.
t actic level linkreconstruction the first step of reconstructing tactic related traceability links utilizes the classifier described in equations and to detect classes that implement the targeted tactic.
for experimental purposes we investigated two different training methods.
the first method trained the classifier using textual descriptions of each tactic while the second method trained the classifier using code snippets taken from classes implementing each of the tactics.
a. datasets two datasets were developed to support the task of training and evaluating the tactic grained classifier.
.
.
.
.
.
.
.
.
.
f measure classification threshold scheduling .
.
.
.
.
.
.
.
.
f measure classification threshold resource pooling .
.
.
.
.
.
.
.
.
f measure classification threshold heartbeat .
.
.
.
.
.
.
.
.
f measure classification threshold audit trail .
.
.
.
.
.
.
.
.
f measure classification threshold authentication .
.
.
.
.
term thresholds a trained using tactic descriptions .
.
.
.
.
.
.
.
.
f measure classification threshold scheduling .
.
.
.
.
.
.
.
.
f measure classification threshold resource pooling .
.
.
.
.
.
.
.
.
f measure classification threshold heartbeat .
.
.
.
.
.
.
.
.
f measure classification threshold audit trail .
.
.
.
.
.
.
.
.
f measure classification threshold authentication .
.
.
.
.
term thresholds b trained using code snippets from tactics implemented in open source systems figure .
results for coarse grained detection of tactic related classes at various classification and term thresholds for five different tactics tactic descriptions dataset for each of the five targeted tactics i.e.
heartbeat resource pooling scheduling audit trail and authentication we retrieved ten descriptions of tactics taken from text books online descriptions and publications.
for training purposes the dataset also included descriptions of non tactic related it documents.
the following text provides an excerpt from a tactic description for the audit trail tactic a record showing who has accessed a computer system and what operations he or she has performed during a given period of time.
audit trails are useful both for maintaining security and for recovering lost transactions..... code snippets dataset for each of the five targeted tactics we identified different open source projects or parts of a large project in which the tactic was implemented.
for each of these projects we retrieved code segments that were closely related to the tactic.
we also retrieved four additional non tactic related classes for training and testing purposes.
the following code represents two methods extracted from a code snippet for the audit tactic.
public boolean isaudituseridentifypresent return this.audituseridentify !
null public bigdecimal getauditsequencenumber return this.auditsequencenumber b. experiments experiments were conducted to determine whether the classification method described in equations and could be used to identify tactic related classes for the five targeted tactics and also to determine whether the tactic descriptions or the code snippets produced better classification results.we hypothesized that the code trained classifier would be more effective for retrieving tactic related classes.
method training with tactic descriptions in the first experiment we trained the classifier using the tactic descriptions and then tested the trained classifier against the code snippets .
the experiment was repeated using a variety of term thresholds and classification thresholds.
method training with code snippets in the second experiment we trained the classifier using code snippets.
because of the time consuming nature of finding and retrieving architectural tactics from large open source systems we adopted a standard fold cross validation process in which the code snippets dataset served as both the training and testing set.
in each execution the data was partitioned by project such that in the first run nine projects each including one related and four unrelated codesnippets were used as the training set and one project was used for testing purposes.
following ten such executions each of the projects was classified one time.
the experiment was repeated using the same pairs of term thresholds and classification thresholds used in the previous experiment.
table ii shows the top ten indicator terms that were learned for each of the five tactics using the two training techniques.
while there is significant overlap the codesnippet approach unsurprisingly learned more code oriented terms such as ping isonlin and pwriter .
c. evaluation metrics results were evaluated using four standard metrics of recall precision f measure and specificity computed as follows where code is short hand for code snippets .643table iii a s ummary of the highest scoring results tactic training methodfmeasure recall prec.
spec.
term classification threshold auditdescript.
.
.
.
.
.
code .
.
.
.
.
authenticationdescript.
.
.
.
.
.
code .
.
.
.
.
heartbeatdescript.
.
.
.
.
code .
.
.
.
.
poolingdescript.
.
.
.
.
.
.
code .
.
.
.
schedulingdescript.
.
.
.
.
code .
.
.
.
.
recall relevantcode retrievedcode relevantcode while precision measures the fraction of retrieved code snippets that are relevant and is computed as precision relevantcode retrievedcode retrievedcode because it is not feasible to achieve identical recall values across all runs of the algorithm the f measure computes the harmonic mean of recall and precision and can be used to compare results across experiments fmeasure precision recall precision recall finally specificity measures the fraction of unrelated and unclassified code snippets.
it is computed as specificity nonrelevantcode truenegatives falsepositives d. results figure reports the f measure results for classifying classes by tactic using several combinations of threshold value.
in four of the five cases namely scheduling authentication audit and pooling the code trained classifier outperformed the description trained classifier.
in the case of heartbeat the description trained classifier performed better at term threshold values of .
and classification thresholds of .
to .
.
one phenomenon that needs explaining in these graphs are the horizontal lines in which there is no variation in f measure score across various classification values.
this generally occurs when all the terms scoring over the term threshold value also score over the classification threshold.
table iii reports the optimal results for each of the tactics i.e.
a result which achieved high levels of recall .
or higher if feasible while also returning as high precisiontable iv instances of architectural tactics in apache hadoop tactic class countexplanation package name or subsystem heartbeat 27hdfs uses a master slave architecture with replication.
all slaves send a heartbeat message to the master server indicating their health status.
master server replicates a failed node slave .mapreduce subsystem the mapreduce subsystem uses heartbeat with piggybacking to check the health and execution status of each task running on a cluster.hdfs subsystem resource pooling36 mapreduce uses thread pooling to improve performance of many tasks e.g.
to run the map function.mapred package a global compressor decompressor pool used to save and reuse codecs.compress package block pooling is used to improve performance of the distributed file system.hdfs subsystem combines scheduling job pooling .
organizes jobs into pools and shares resources between pools.mapreduce subsystem scheduling scheduling services are used to execute tasks and jobs.
these include fair dynamic capacity schedulingcommon mapreduce audit trail audit log captures users activities and authentication events.mapred package authentication35 uses kerberos authentication for direct client access to hdfs subsystems.security package the mapreduce framework uses a digest md5 authentication scheme.mapreduce hdfs subsys.
as possible.
the results show that in four cases the codetrained classifier recalled all of the tactic related classes while also achieving reasonable precision.
the descriptiontrained classifier achieved recall of for only two of the tactics.
v. r ole level linkreconstruction to train a classifier to differentiate between various tactic roles we constructed a role snippets dataset .
this dataset was a modification of the code snippets dataset in which each of the tactic related code snippets was replaced by separate code snippets for each of the tactic s roles.
for example each project for the scheduling tactic included one code segment implementing the scheduler role one code segment implementing the scheduled by role as well as four unrelated code segments.
the previously described fold cross validation experiment was repeated with the role based code snippets to see if we could effectively retrieve classes according to their role in the project.
results from this experiment not otherwise reported showed that the terms used across roles in a given tactic were quite similar and so differentiation was poor.
to address these problems we conducted an extensive exploratory investigation to determine how best to classify classes by roles however we report only the final technique that was adopted.
the first two steps in the process utilize the previously described classifier while steps three to six utilize light weight structural analysis.
the heuristics of this analysis were derived through analyzing the tactic 644related code found in fault tolerant corba the google chromium os and the rossume robotic system.
we hypothesized that utilizing class hierarchy information and class dependencies caused by method calls could improve the quality of tactic traceability.
our approach includes includes the following steps .
the tactic grained classifier is first run against the entire set of classes in order to identify an initial set of tacticrelated classes for each tactic.
.
the role grained classifier is then run against the subset of classes returned by the tactic grained classifier.
following this step each of these classes is assigned a probability with respect to each of the tactic related roles.
.
based on observations that tactic related behavior is often specified in base classes probabilities are propagated across lessmuchextends greatermuchrelationships if the probability in the base class for a specific tactic role is higher than that of the derived class.
values are not propagated across lessmuchimplements greatermuchrelationships because classes that implement an interface define their own behavior.
.
based on observations that most tactics require communication between roles dependency analysis is performed to eliminate classes that do not interact with other tacticclassified classes.
for example a class assigned some probability of being a heartbeat receiver is in fact unlikely to actually play that role unless it is associated with other classes which are also classified as heartbeat related.
however this heuristic is not valid for all tactics as some tactics might implement roles using inbuilt class libraries.
for example resource pooling might be implemented using the classes from java.util.concurrent meaning that it is possible to have a tactic related yet isolated class.
furthermore in the case that standard library functions are used in this way it becomes relatively trivial to identify the occurrence of such a tactic.
for purposes of our study we therefore apply this heuristic to all tactics apart from resource pooling .
.
wherever feasible classes are placed into functional groupings according to their associations so that different instances of the same tactic can be separated out.
.
finally classes are classified according to the role with the highest probability score as long as that score is higher than a predetermined threshold.
we explored other options for structural analysis.
for example while it might seem reasonable to differentiate between a heartbeat sender and receiver according to the direction of the heartbeat message the variety of implementations made this quite difficult.
unfortunately it was not feasible to evaluate this lightweight structural approach against the previously used code snippets as they did not carry associated structural information.
we therefore conducted an initial evaluation of this approach within the richer context of the following casestudy.
specific results are reported in section vi c.vi.
a c ase study the goal of the case study is to reconstruct tacticrelated traceability links in the apache hadoop software framework a system which supports distributed processing of large datasets across thousands of computer clusters.
the hadoop library includes over classes and provides functionality to detect and handle failures in order to deliver high availability service even in the event that underlying clusters fail.
a. tactics in apache hadoop the first step of the case study involved building an answer set for evaluation purposes by manually identifying heartbeat resource pooling scheduling audit trail and authentication tactics in hadoop.
this was accomplished by i reviewing the available hadoop literature to look for any