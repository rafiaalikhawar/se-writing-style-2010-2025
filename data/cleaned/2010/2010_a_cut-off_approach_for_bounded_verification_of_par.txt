see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation a cut off approach for bou nded verification of parameterized systems conf erence paper in proceedings int ernational conf erence on softw are engineering may .
.
sour ce dblp citations 21reads author s qiusong y ang instit ute of softw are chinese ac ademy of scienc es publica tions citations see profile mingshu li chinese ac ademy of scienc es publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y qiusong y ang on june .
the user has r equest ed enhanc ement of the do wnlo aded file.a cut off approach for bounded verification of parameterized systems qiusong y ang1 qiusong yang itechs.iscas.ac.cn 1laboratory for internet software technologies institute of software chinese academy of sciences beijing p .r.
chinamingshu li1 mingshu iscas.ac.cn 2state key laboratory of computer science institute of software chinese academy of sciences beijing p .r.
china abstract the features in multi threaded programs such as recursion dynamic creation and communication pose a great challenge to formal veri cation.
a widely adopted strategy is to verify tentatively a system with a smaller size by limiting the depth of recursion or the number of replicated processes to nd errors without ensuring the full correctness.
the model checking of parameterized systems a parametric in nite family of systems is to decide if a property holds in every size instance.
there has been a quest for nding cut o s for the veri cation of parameterized systems.
the basic idea is to nd a cut o on the number of replicated processes or on the maximum length of paths needed to prove a property standing a chance of improving veri cation e ciency substantially if one can come up with small or modest cut o s. in this paper a novel approach called forward bounded reachability analysis fbra based upon the cut o on the maximum lengths of paths is proposed for the veri cation of parameterized systems.
experimental results show that veri cation e ciency has been signi cantly improved as a result of the introduction of our new cut o s. categories and subject descriptors d. .
software program veri cation model checking formal methods general terms veri cation algorithms keywords parameterized system bounded model checking cut o .
introduction in multi threaded programs such as those written in the java and c programming languages it may be necessary for permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.numerous replicated processes or threads to be dynamically created during the program s execution.
this may be done for example to enable the concurrent manipulation of di erent requests or to support various kinds of background computations.
the veri cation of such kinds of systems poses a great challenge because it is often di cult if not impossible to predict the precise number of replications that may be needed for any particular execution.
this may cause the veri cation of such programs to be undecidable especially when such features as concurrency recursion dynamic creation and communication are present.
a strategy that is often adopted is to verify another program that is derived from the original program by limiting the depth of recursion or the number of replicated processes.
while the veri cation of this derived program does not assure the veri cation of the original it may nd the errors in the derived program that then might be expected to also be present in the original program.
thus for example the java program given in fig.
is derived from the producerconsumer problem presented in by the removal of the method modi er synchronized of the getandputmethods.
in only kcreplications of a class c a limit provided by the analyst are allowed to be created.
this creates a bound on the state space and enables veri cation of the derived program.
we note that even if this kind of reduced version of a program is decidable the size of the state space needed for veri cation may still spiral out of control when the number of replicated processes grows.
of more concern perhaps is the possibility that some errors that depend on the number of replicated processes e.g.
those that arise from higher levels of concurrency might not be detected when only derived versions having bounded numbers of replications are investigated.
for example a derived version of the producerconsumer system may not be su cient to support detecting that new elements will still be put into the bu er even when it is full if the number of replicated processes is limited to less than the capacity of the bu er buf capacity in the derived version.
therefore there is considerable interest in determining whether it is possible to compute a cut o on the number of process replications or on the maximum length of paths in a derived version that is su cient to assure that a veri cation of the derived program also serves as a veri cation of the original program.
in this paper we explore this possibility focusing on parameterized systems a subset of concurrent systems that involve multiple heterogeneous classes of nitestate processes and depend on parameters that de ne thenumber of replications of each class s process template .
an advantage of parameterized systems is that the goal of veri cation of such systems is to decide if a property holds for every system size.
thus the veri cation of a property of a parameterized system will hold irrespective of the system size and thus without any concern for determining a bound on the number of process replications.
unfortunately the veri cation of general parameterized systems is undecidable .
on the other hand veri cation of a class of commonly used systems consisting of many identical and nite state processes is decidable .
problem statement.
there has been a quest for ndingcut o s bounds on the number of replications or the maximum length of paths that nevertheless assure the possibility of the veri cation of parameterized systems.
the basic problem is to show that for a given property sand a parameterized system p n1 n2 nk c1 cl u1 u2 uk n1 n2 nk denoting an in nite family of concurrent systems in which each system is composed of c1 throughclandn1replications of u1throughnkreplications ofukrunning in parallel synchronously there is a cuto c p s which is invariant with respect to n1 n2 nk on the number of replications of each process template or on the maximum length of paths needed to prove the property s. an advantage of cut o approaches is that the veri cation of an in nite family of systems can be turned into a veri cation problem having a nite state space.
if one can come up with a cut o that is small or moderate in size veri cation e ciency might be substantial.
prior work.
the prior work on cut o s can be classi ed into two categories a cut o s on the number of replications .
several pioneering attempts such as those based on process closures bisimulation process invariants and network invariants have succeeded in reducing the veri cation of parameterized systems to the veri cation of a system with a nite number of processes.
however these approaches are semi automatic and the closures or invariants needed to support these veri cations have to be supplied by the analyst.
more recently papers by and have demonstrated the existence of cut o s for various kinds of parameterized systems and speci cation logic pairs.
unfortunately most cut o s that have been demonstrated do not lead to e cient decision procedures or e ective means for reductions and small cut o s have only been demonstrated for some relatively simple types of systems.
b cut o s on the maximum length of paths .
a cut o phrased in terms of the maximum length of paths would seem to o er computational complexity advantages as a system whose bound is on the number of nodes in its longest path would seem to have a far smaller search space than a system whose bound is the same number of replicated processes as the number of global states in the latter may grow exponentially.
moreover note that in bounding the longest path a cut o on the number of replicated processes is inferred by assuming that each node in a path is executed by a di erent process replication .
in and the authors show that a cut o exists for the veri cation of parameterized systems composed of a control process and an arbitrary number of user processes against indexed ltl properties.
the proof of the existence of such cut o s is useful in proving the decidability of the decision procedures for such systems.
however this previous work has not shown how to compute the value of a cut o and thus is unable topublic class intbu er f protected int data count front nal simplelock lockfull new simplelock nal simplelock lockempty new simplelock public intbu er int capacity f data new int array allocation g public void put intx f while count data.length lockfull.await wait until bu er is not full data x count count lockempty.notify wake up a waiting process g public int get f while count lockempty.await wait until bu er is not empty intx data front front data.length count count lockfull.notify wake up a waiting process return x g public class producer implement runnable f protected intbu er buf public producer intbu er b fbuf b g public void run f random random new random intval random.nextint buf.put val g g public class consumer implement runnable f protected intbu er buf public consumer intbu er b fbuf b g public void run f intval buf.get system.out.println val g g public class main f protected nal int buf capacity public static void main string args f intbu er buf new intbu er buf capacity while true f new thread new consumer buf .start new thread new producer buf .start g g figure producer consumer example help in the veri cation of actual systems of this kind.
contributions.
in this paper an fbra approach based upon the cut on the maximum length of paths is proposed for the veri cation of parameterized systems with only rendezvous actions against a property automaton a nite state machine specifying a set of undesirable behavior.
at the same time the approach is sound and complete.
a novel approach to determine cut o s given a parameterized system and a property automaton at most increasingly re ned abstractions fa0 a1 ai a 1g are generated where is the total number of local states of all class templates.
let cibe a cut o on the maximum length of paths needed to decide if the property holds in ai.
we rst show that it is straightforward to calculate c0.
second we prove that ci i can be reduced to the sum ofgiandci wheregiis a number inherent to ai.
finally c will be the cut o that we expect.
premature termination if someci i is equal to zero no undesired paths are feasible in ai.
the construction ofaiensures thatc is also equal to zero meaningthat no undesired paths will be feasible in the original system.
then we know that the property does hold and the decision procedure can terminate.
this makes the calculation of the nal cut o c unnecessary.
on the other hand the decision procedure can also terminate with a conclusion that the property does not hold if a counter example found inaiis also a feasible path of the original system.
guided forward reachability analysis typical forward reachability analyses of parameterized systems such as or its variant use !
con gurations as abstractions and xed point algorithms to construct a nite reachability graph.
however the problem with those approaches is that the loss of information during the generation of !
reachability graphs makes it di cult to construct a counterexample when a property does not hold.
a cut o for forward reachability analyses allows for a direct search over a non compacted in nite reachability graph.
experiment results the results show that our cut o technique can help with the veri cation of real systems against properties of real interest.
experimental results show that veri cation e ciency has been greatly improved as a result of the introduction of our new cut o s. the rest of this paper is organized as follow preliminary de nitions of parameterized systems are presented in section .
section gives an overview of our approach and those technical sta laying a foundation for every step of the approach is presented in section .
experimental results are given in section and related work is included in section .
section concludes this paper.
.
parameterized systems as for the de nition of each component of a parameterized system we will follow those notions presented in except that the broadcast actions are excluded.
to describe guarded transitions of a parameterized system we rst need the following de nition boolean guards actions letb fb1 bngbe a set of global boolean variables and let b0be their primed version.
a boolean guard gis either the formula true and false or the conjunction of literals p wherep n such that iis eitherbor bfrom some b2b.
a boolean action ais a formula b0 v1 b0 n vn whereviis one oftrue false b ifor i n. process aprocess is a tuplehs i where s a nite set of states a set of actions used for constructing guarded transitions.
let be g a. an action can be either of the following internal action denoted as .
rendezvous action including !
output and ?
input .
the action or !
is enabled if gis evaluated to be true and the global boolean variables will be updated according to aif the action is executed.
the input action ?
is enabled as long as there is an enabled rendezvous action !.
a subset of s s regulating a set of guarded transitions.parameterized system aparameterized system is a tuplehb c1 cl hu1 n1i huk nkii denoted as p n1 nk whereci hsci ci cii i l and uj hsuj uj uji j k .
following the terminologies of c1throughclare called control processes which can only be created once during each execution of the system.
the templates u1throughuk also called user processes can have an arbitrary number of replications as indicated by n1throughnk.
all the control and user processes run in parallel synchronously and share information through the global boolean variables of b. global state aglobal state of a parameterized system has the form of g h g1 g2i where hv1 vniwith vi i n 2ftrue falsegis an evaluation of those boolean variables in b fb1 bng g1 hs1 sli withsi2sci i l collects the set of states of control processes and g2 hs11 s1n1 sk1 sknkiwith a dimension n1 nkandsij2sui i k j ni represents the local states of replicated processes of u1throughuk.
then the operational semantics of a parameterized system is de ned as operational semantics letg h s1 sl i g0 h s0 s0 l i and .
then g !g0 denoting that the system transits from gtog0through a transition if and only if one of the following conditions holds if there exists iandusuch thatsi !uand true thens0 i uands0 j sjfor allj6 i. if there exists i j u andvsuch thatsi !
!u sj ?
!v and true thens0 i u s0 j vands0 m smfor allm6 i j. in this paper properties of parameterized systems are expressed in property automata whose accepting languages paths leading to trap states prescribe undesirable behavior of veri ed systems.
if there exists a path accepted by a property automaton which is also feasible in a parameterized system we would say that the property does not hold in the system otherwise it does.
property automata aproperty automaton is an fsm hs f s t s i wheres is a nite set of states fis a set of accepting states tis a set of trap states and s s is a set of transitions.
a label in has one of the following forms unsubscribed event g where is an internal action or a communication event between !
and ?.
subscribed event i g whereihas a form off i j li mj g withiandjbeing indexes to control processes and liandmjbeing indexes to theith replication of uland thejth replication of um respectively.
this event refers to a transition in which one of the indexed processes or replications participates.
if a user process replication is referred we also call it a regulated replication .
using predicate abstraction techniques representing each boolean predicate over concrete variables with a boolean variable the producer consumer problem presented in fig.
can be abstracted as a nite set of automata.
as shown inu1 producer s1 s2bfull trues3 lockfull await !bfull false s4putdata s5bempty0 false s6bfull trues7bfull0 false s8lockempty notify !
lockempty notify!c1 lockfull s1 s2lockfull.await?
lockfull.notify?
u2 consumer s1 s2bempty trues3lockempty await !bempty false s4getdata s5bfull0 false s6bempty trues7bempty0 false s8lockfull notify !
lockfull notify!c2 lockempty s1 s2lockempty.await?
lockempty.notify?
figure control user processes of the producer consumer example fig.
the two automata modeling the locks lockfull and lockempty correspond to the control processes of the parameterized system while the other two automata named producer and consumer are the user processes.
the set of global boolean variables of the system consists of bfull and bempty .
the property automaton stating that a producer can not put extra data into the bu er when it is full and a consumer can not withdrawn data from the bu er when it is empty is presented in fig.
in which the diamond node represents a trap state.
s1 s2s3 s4 fbfalse0 true bfull0 trueg bfull0 truebempty0 true putdatagetdata fbfull0 false putdatag fbempty0 false getdatag figure no getdata putdata operation when the bu er is empty full .
overall approach in this section an overall view of our approach is presented.
to start with we rst need the following de nitions con guration acon guration is a vector of the form c hs ai wheresis astate vector andais acounter vector .
a con guration can be thought of as the abstraction of a global state of a parameterized system.
instead of enumerating the state of each replication of user processes the counter vector only records the number of replications in each local state.
as a result two global states can not be di erentiated if they have the same number of replications in each local state.i bounded con gurations a vectorv2zmis said to be i bounded ifv j for all j i wherev j represents theith component of v. a con guration is said to be ibounded if its counter vector is i bounded.
i r bounded con gurations a vectorv2zmis said to bei r bounded if v j rorv j !for all j i where!is greater than any integer.
a con guration is said to be i r bounded if its counter vector is i r bounded.
a non i r bounded con guration is an i bounded but not i rbounded con guration.
by showing how the producer consumer program is veried against the property given in fig.
we ll demonstrate how our approach works.
the veri cation procedure can be summarized as follows construction of extended reachability graph erg an erg is actually the synchronous product of the property automaton and the parameterized system.
it models the execution of control processes and regulated replications of a parameterized system and their execution s impact on the property automaton while the states of other replications of user processes are collected through counter vectors.
because two replications of a user process exhibit the same behavior as long as they are in the same local state it still ensures that the original veri cation problem for a parameterized system holds if and only if all violation states are not reachable in the generated erg.
instead of directly using the complete erg corresponding to a veri cation problem a set of increasingly re ned abstractions of it fa0 ai a 1g is sequentially generated.
in the abstraction ai each con guration is only required to be i bounded.
all graphs start from the same initial con guration hs ai in which all global boolean variables are initialized all control processes and regulated replications are in their initial states and the counter vector s elements corresponding to initial states of user processes are set to!.
the introduction of !is to ensure that a conclusion will hold irrespective the size of a parameterized system.
then new con gurations reachable from the initial con guration are added.
the procedure continues until all reachablei bounded con gurations have been enumerated.c1 hhs1 f t s s1i h!p1 !c1ii c2hhs1 f f s s1i h 1p4 1p5iibempty0 false c6 hhs1 f f s s1i h 1p4 1p7iibfull0 false c7 hhs2 t f s s1i h 1p4 1p6iibfull0 true c8 hhs1 f f s s1i h 1p4 1p5 1c6 1c8iilockfull notifyc3hhs1 f t s s1i h 1p5 1p7iibfull0 false c9 hhs1 f t s s1i h 2p5 2p7iibfull0 false c10 hhs2 t t s s1i h 2p5 1p6 1p7iibfull true c11 hhs1 f t s s1i h 1c6 1c8 1p5 1p7iilockfull notify c4hhs1 t t s s1i h 1p5 1p6iibfull true c12 hhs4 t t s s1i h 1p3 1p4 1p5 1p6iiputdatac5 hhs1 f t s s1i h 1c6 1c8iilockfull notify figure extended reachability graph a4of the producer consumer program however the abstract reachability graph obtained is normally an in nite reachability graph because of the existence of!elements in counter vectors and it prevents a direct forward reachability analysis.
we will prove that aionly needs to include i ci bounded con gurations to determine the cut o ci where is equal to or because the parameterized systems considered in this paper contain no broadcast actions and an element in the counter vector will be added or decreased at most by during a transition .
if a non i ci 1bounded con guration is encountered during the construction of ai we just simply discard it.
inductive calculation of cut o s the induction basisc0is obtained by investigating the coarsest abstraction a0.
letc0be the length of the longest shortest paths in a0starting from one con guration to another in which the property automaton is in a trap state if such paths exist otherwise c0 .
as for the induction of cifromci ci will be set to be the length of the longest shortest paths in aistarting from one con guration to another in which the property automaton is in a trap state otherwise ciwill be set to the sum of ci 1andgi wheregiis the length of the longesti ci 1bounded path of aiif a non i ci 1bounded con guration has been discarded during the construction of aiand otherwise ciis equal to zero.
termination criteria at most inductions are needed being the total number of local states of user processes andc will be the cut o on the maximum length of paths needed to decide if the property automaton holds in the veri ed parameterized system.
the veri cation procedure can also terminate prematurely a an intermediate cut o ci i is equal to zero indicating that no undesired behavior exists in the upward abstraction of the original parameterized system and thus the property does hold b a counter example found in an abstract graph ai i is not spurious and it is also feasible in the original parameterized system indicating that the property does not hold.
an example abstract erg a4for the producer consumer program is presented in fig.
.
the elements of each state vector in left to right order respectively correspond to the current state of the property automaton the global boolean variables bfull andbempty and the current states of the two control processes lockfull andlockempty .
for thesimplicity of notations we use the notation h kci pi mcj pj ito represent a vector in which the element corresponding to the ith local state of consumer producer is equal tokand the element to the jth local state is equal tom while all other elements are zeros.
as the elements !p1and!c1will be staying unchanged in the whole reachability graph they are not explicitly speci ed other than in the initial con guration.
it should be noted that a di erent abstract reachability graph might be generated if the mapping from elements of counter vectors to local states of user processes is changed.
for example the con guration c3will not be bounded if the states5ofconsumer is mapped on an element whose position index is less than while it is under our current default mapping in which the rst four elements are mapped on the local states s2 s1 s7 ands8ofproducer from left to right.
in this paper a randomly selected mapping is used and the research on heuristically selecting an optimal mapping for a veri cation problem is out of the scope of this paper.
in addition we can conclude the cut o c4of the producer consumer program is as there is a path with a length of leading to a trap state.
.
detailed methodologies in this section the procedure to construct an erg from a parameterized system is given.
more importantly several theorems supporting every step of our approach and their sketch proofs are provided1.
before that we rst present two simple concepts.
a path is said to be i bounded if each con guration in it is i bounded.
an i bounded path is said to be i looped i loop free if there are no two congurations in it such that their state vectors are the same and the rst ielements of their counter vectors are componentwise equal.
similar concepts can also be de ned for i r bounded con gurations and paths.
construction of erg .
given a parameterized system p hb c1 cl hu1 n1i huk nkiiand a property automaton hs f ticharacterizing the correctness of the parameterized system.
we assume that the automaton refers to a set of regulated replications that are 1detailed proofs further details about the experiment systems and raw data given in the next section can be seen from generated from user processes fur1 urhg.
ani bounded or i r bounded erg is a directed graph hv eisuch that v a set of con gurations.
each con guration c2v has the form ofhs ai wheres2s b sc1 scl sur1 surhcollects the current states of the property automaton control processes and regulated replications and stores the evaluation of all global boolean variables and the counter vector acollects states of non regulated replications of user processes.
e v v. letc hhs s sl hi aibe ani bounded i r bounded con guration which has already been added to the graph c0 hhs0 s0 s0 l hi a0i and .c !c0 denoting that the combination of the property automaton and the parameter system transits from ctoc0by executing a transition if and only if the appending of c0does not form an i looped path and is an internal action executed by a control process or a regulated replication and there exists iandusuch thatsiu !uand true thens0 i u a0 a s0 j sjfor allj6 i and s0 s .
assume is a total automaton.
is an internal action executed by an unregulated replication and there exists sm !sn2 uv whereuv v k is a user process true and the sum of aandh 1sm 1sniisi bounded i r bounded then s0 i sifor all i l h a0 a h 1sm 1sni ands0 s .
is the communication between si !
!uand sj ?
!v which are executed by a control process and a regulated replication respectively and true thens0 i u s0 j v a0 a s0 s l ands0 m smfor allm6 i j. is the communication between si !
!u a transition executed by a control process or a regulated replication and sm ?
!sn a transition executed by a user process uv the sum of aand h 1sm 1sniisi bounded i r bounded and true thens0 i u a0 a h 1sm 1sni s0 s l ands0 j sjfor allj6 i. is the communication between sm !
!sn a transition executed by a user process uv and sx ?
!sy a transition executed by a user processuz the vector a h 1sm 1sni h 1sx 1syiis i bounded i r bounded and true then s0 i sifor all i l h a0 a h 1sm 1sni h 1sx 1syi ands0 s l .
during the construction of an erg it might be the case that there is a self loop transition in some user process such that smandsnin a transition sm !snrefer to the same local state.
as demonstrated in we can insert intermediate con gurations to address the issue.
for an i bounded erg a path of it is called a path with a trap state if the path is ended with a con guration in which the property automaton is in a trap state.
then we have the following theorems for the constructed ergs theorem .a property automaton holds in a parameterized system if and only if there are no paths with a trap state in the corresponding bounded erg.
the theorem holds because an bounded erg precisely models the behavior of the property automaton control processes and regulated replications.
it s unnecessary to di erentiate one non regulated replication from another as they exhibit the same behavior if they are in the same local state and thus their states can be collected using counter vectors.
letgbe a con guration of aiandmin g i denote the length of the shortest i bounded path with a trap state in aistarting from g if at least one such path exists otherwise de ne min g i .ci maxfmin g i jg2aig is de ned as the length of the longest shortest i bounded paths with a trap state starting from con gurations of aiif such paths exist otherwise de ne ci .
the next theorem states howciis calculated through inductions.
its proof is similar to the one given in to prove the decidability of covering problems for vector addition systems.
theorem .ci r 2ci i cifor0 i where r js j jsc1j jsclj jsur1j jsurhjis the product of the size of the individual automata.
proof.
assume that there is an i bounded path with a trap state in the i bounded erg otherwise ci .
case there is an i 2ci bounded path with a trap state.
then there must be an i 2ci bounded path with a trap state and the path is also i loop free.
it is obvious that the path s length must be r 2ci i .
case otherwise.
then there is an i bounded path with a trap state which is not i 2ci bounded.
the path can be re presented as p1p2such thatp1is i 2ci bounded and p2begins with a con guration c hs ai which is not i 2ci bounded.
without loss of generality we assume that a i 2ci.
from case we can choose p1to be of length r 2ci i .
sincep2is ani bounded path with a trap state we know that there exists a path p0 2of length ciwhich is also ani bounded path with a trap state and starting with s. note that all the entries in a state s counter vector will be increased or decreased less than or equal to in each transition.
we can conclude that p0 2is a i bounded path with a trap state.
hence p1p0 2is an i bounded path with a trap state of length r 2ci i ci.
based on theorem it is rather straightforward to construct an algorithm for a cut o based reachability analysis of parameterized systems.
we only need to check those paths with a length c to decide if a property holds.
however c might be an astronomical gure if we simply use theorem .
for the example veri cation problem presented in fig.
we will get c0 c1 c2 c3 .
to further improve veri cation e ciency the following lemma holds lemma .if there are no paths with a trap state in the i 2ci bounded erg and no i bounded but non i 2cibounded con gurations have been discarded during the construction then ci .
lemma .if non i 2cibounded con gurations are discarded during the construction of the i 2ci boundedtable list of example problems used in the experiments.
index systems j jcjcjujuj p1 bin example inverse dependency f control user p2 loop example looped dependency f control user p3 simple protocol mutual exclusive t server client p4 no orphan packets t p5 full put f p6 producer empty get f lockfull producer p7 consumer produce first t lockempty consumer p8 empty get and full put f p9 gas station start pumping first t pump client p10 start pumping first t pump erg ci 1will be less than or equal to the length of the longest shortest i bounded paths with a trap state if such paths exist otherwise ci ci gi wheregi 1the length of the longest path of the i 2ci bounded erg.
the correctness of the rst lemma is rather obvious.
in theorem s proof the length of the longest i 2cibounded path is bounded by r 2ci i while lemma uses a rather smaller bound gi 1obtained through investigating the veri cation problem itself.
from these two lemmas we have the following theorem theorem .to inductively calculate ci 1fromci only a nite i 2ci bounded erg is needed.
we also have two theorems supporting the premature termination of the inductive process making the calculation of the nal cut o c unnecessary theorem .ifci for any i then there will be noj bounded paths with a trap state in the j bounded erg for any jsuch thati j and the property does hold.
theorem .for a path with a trap state of the i 2ci bounded erg it will be a concrete counter example in the original parameterized system if each con guration in the path is bounded and the property does not hold.
in addition we can construct an i ci bounded erg instead of an i 2ci bounded one if no complementary actions are simultaneously enabled in a state of user processes as it is impossible for an element in the counter vector to be decreased by during a transition.
.
experimental results the systems used in the following experiments are listed in table .
for each example problem the details such as the control processes and user processes of a parameterized system the property to be veri ed and their sizes are presented.
here the size of an fsa is the sum of the number of states and transitions.
the indicator t or f shows whether or not the property actually holds in the system being veri ed.
the last column gives the total number of local states of all user processes.
our algorithm called forward bounded reachability analysis fbra and existing typical algorithms for veri cation of parameterized systems are implemented in java.
each data sample collected during the experiments consists of execution time size of memory space needed to store the globalstates reached during the veri cation and some peculiar data to each algorithm.
the algorithms were run on a hp laptop with a dual p8400 .26ghz cpu and 1gb of memory running windows xp.
.
results of fbra we tested the algorithm fbra on the example problems listed in table .
for the reason of limited space the inductions to calculate cut o s for some typical example problems are given in table complete results are presented in the web page given in footnote .
the boolean variable b1i is true if an i bounded path with a trap state is encountered during the ith induction while b2iis true when some i bounded but not i ci bounded nodes are encountered during the ith induction.
the cut o for each induction is listed inciand the number of states visited during each induction is recorded in si.
fbra s average execution time on each example problem is given in the last column.
from table we can rst observe that theorem can improve veri cation e ciency dramatically by avoiding useless inductions for certain problems.
as for the problems p4 p9andp10 the fbra algorithm draws a conclusive conclusion that the property holds in the veri ed parameterized system after the rst induction because c0is equal to zero.
in the problems p2andp5 a concrete counter example is found during an intermediate induction and the whole decision procedure also terminates prematurely as a result of theorem .
secondly the variable b2iis remarkably similar to the evaluation function in branch and bound search algorithms.
if ani bounded but not i ci bounded node is encountered during the ith induction then b2ibeing set to true the branch rooted with the node will be discarded for further exploration to nd an i bounded path with a trap state.
if b2i true for some i it also indicates that the state space explored in the ith induction is reduced because of the introduction of ci as shown in p1 p2andp3.
thirdly assume that the algorithm fbra does not terminate after the th induction as shown in p1andp3.
the th induction in which the original parameterized system instead of one of its abstractions is used is going to be executed to calculate c .
ifc is equal to zero we can claim that the property does hold.
otherwise a counterexample whose length is not greater than c may exist in the parameterized system.
if being lucky enough we might encounter such one counter example during the calculation ofc in the case of p1 and the th induction will be completely unnecessary.
otherwise all the paths withtable experimental results of fbra indexb1b2cs t ms indexb1b2cs t ms p1i t f .6p2i t f i t f i t f i t f i t f i t f i t t i t t p4i f f .
p3i t f .7p5i t f i t f i t f i t f i t f i t f i t f i t f i t f i f t i t t i f f i t f p9i f f i t f f10i f f i t f a length c are needed to be checked to decide if a real counter example does exist as shown in p3.
.
fbra vs. others although cut o approaches are presented in and those results highly depend on some unique characteristics of veri cation problems such as ring or network topologies of processes process symmetry indexed logic without the next operator.
as a di erent combination of parameterized systems and property speci cation is used in this paper it prevents the direct comparison of our approach with existing cut o approaches.
to demonstrate the e ectiveness of our approach we made a comparison between the algorithm fbra and typical existing algorithms for veri cation of parameterized systems albeit they are not based on cut o s. we implemented the forward reachability analysis frakm algorithm proposed by r.m.
karp and r.e.
miller a variant of frakm proposed by e.a.
emerson and k.s.
namjoshi named fraen and the backward reachability analysis bra algorithm proposed by p.a.
abdulla et al.
fraen and bra are also both used by j. esparza et al.
in .
in the literature a lot of algorithms have been derived from these three basic ones to verify parameterized systems or other systems with an in nite state space.
in these algorithms the concept of quasi order a binary relationship i.e.
re exive and transitive on the set of global states plays a critical part in constructing a nite reachability graph.
a con guration c hs aiis said to be the pre order of another con guration c0 hs0 a0i denoted as c c0 ifs s0anda a0.
letdandd0be two congurations that have been added to a partially generated reachability graph.
let ebe a new con guration backward or forward reachable from d but not from d0.
the strategies adopted by those algorithms to decide if the new con guration is added to the existing partial reachability graph are di erent from one another.
they are summarized in table where each symbol denotes that the algorithm in the same row uses the rule in the same column to compact the state space and each symbol does not.
in the algorithm bra the new con guration edoes not need to be explicitly represented if d e d0 e d e ord0 e. the new con guration ewill be replaced by a corresponding !
con guration if d eord ein the algorithm frakm.the algorithm fraen extends frakm by introducing an extra rule that the new con guration eis discarded and a new edge from e s predecessor to d0is added ife d0.
table strategies for discarding new states algorithms d ed0 ee d0d ed0 e bra frakm fraen fbra we have implemented the above algorithms and tested them on the example problems listed in table .
the results are presented in table .
to ease the comparison between the algorithm fbra and the others the fbra s experimental results are repeated there.
in summary fbra outperforms bra in p3 p4 p5 p7 p8andp10 bra performs better in p1 p2andp6 and they are matched up in p9.
fbra outperforms frakm in all example problems except forp3andp4.
although fbra outperforms other algorithms in many of the example problems its time and space e ciency is relatively lower in p1andp2than bra in p1andp3than frakm in p1 p2 p3andp10than fraen.
the ine ciency of fbra results from the enumeration of all the states of ergs.
however the loss of information resulted from the introduction of !
con gurations in fraen makes it very di cult to e ciently construct a counter example from the compacted reachability graph or to estimate a cuto of the length of i ci bounded paths with a trap state in the i th induction the core of fbra.
it remains an open problem to use the strategies adopted by other forward reachability analysis algorithms such as frakm and fraen to improve fbra s e ciency further.
.
related work to counter the state explosion problem in which the number of states of a reachability graph may grow exponentially with the number of processes some approaches are presented in to reduce an in nite set of veri cation problems a veri cation problem for a system with a certain size to a single problem.
typically in the reduction is based on the collapse theorem stating that for alltable comparison of fbra bra frakm fraen index fbra bra frakm fraen states time ms states time ms states time ms states time ms p1 .
.
.
p2 .
p3 .
.
p4 .
.
.
p5 .
out of memory .
p6 .
.
out of memory p7 .
.
p8 .
out of memory p9 .
out of memory .
p10 out of memory .
k r mkandmrwill be ictl equivalent if mr p and mr p are equivalent where mkis a system of kidentical nite state processes and p is a closure of the identical processp.
however these approaches are only partially automated requiring human ingenuity to construct a closure process or process invariant .
a decision procedure for veri cation of ltl properties of single processes i.e.
speaking either about the control process or a user process is given in based on a cuto on the length of paths to be considered.
in essence the decision procedure reduces such a veri cation problem to a boundness problem of vector addition systems vass .
the problem with the approach is that the existence of a cut o in theory is enough to prove the decidability of the decision problem.
however the procedure for calculating the cut o is notoriously complicated and it is de nitely too large to be helpful for reducing the state space to be explored for a veri cation problem.
in systems formed by a synchronous parallel composition of a single control process with an arbitrary number of identical user processes are considered.
the correctness of properties are expressed in an indexed temporal logic and de ned over the control process all user processes or every distinct pair of processes.
the decision procedure is based on constructing an abstract graph in which one only distinguishes whether none or at least one process is at a certain control location.
the abstraction graph may have bad paths that do not correspond to computation of any size instance.
the core of the algorithm is to nd an accepting good path in the graph.
the termination of the algorithm is guaranteed by the existence of a cut o on the length of paths to be explored.
similarly to the cut o is only a conservative upper bound to prove the algorithm s decidability and the cut o itself does not directly contribute to the improvement of veri cation e ciency.
instead of a cut o on the length of paths to be explored a cut o on the number of instances of the user process is calculated in .
in the paper asynchronous systems comprised of an arbitrary number of homogeneous copies of a generic process template are considered and correctness properties are expressed using indexed ctl nx.
then model checking for systems of arbitrary size nis reduced to model checking for systems of size up to a small cut o sizec.
although we have not directly compared it with our algorithm the state space with the given cut o number of processes has to be generated and explored which is usually exponential in the number of processes.parameterized systems de ned in this paper can also be modeled as petri nets.
to counter the explosion caused by the high dimensionality of practical petri nets those places correspond to local states of user processes which are thought of being not important are discarded to construct an abstraction in .
if the abstraction is too coarse an automatic re nement is performed and a more precise abstraction is obtained.
the process is iterated until the property is proved to be true or false.
however only partial space of each abstraction is explored in our method because of the cut o ciand the iterative process can be terminated whenci for some i .
.
conclusion and discussions in this paper a novel approach is proposed for the verication of parameterized systems based on cut o s on the maximum length of paths needed to be explored.
given a parameterized system and a property automaton stating a set of undesirable behavior of the system a cut o on the maximum length of paths to decide if the property holds is determined through an inductive procedure.
in each induction only a nite abstract reachability graph is needed and thus the veri cation of a parameterized system with an in nite state space is turned into a series of veri cations of nite state systems.
the existence of a cut o on the maximum length of paths allows for a direct forward reachability analysis of parameterized systems otherwise a compacted nite reachability graph has to be constructed rst and it is rather straightforward to construct a counter example when a property does not hold.
experimental results show that the algorithm outperforms typical forward and backward reachability analysis algorithms in many of the example problems.
in the de nition of property automata only behavior of indexed user processes is considered.
actually they can be extended to safety properties such as global deadlock free properties.
one way is to use property automata to describe all possible bad sequences of resource acquire release operations.
an alternative one is to convert a deadlock free property as it is guaranteed that at least one of the state transitions is always enabled.
as future work our approach can be extended to liveness properties in b uchi automata although calculating ci 1fromciwill become much more complicated.
in addition there is an implicit ordering on the local states of user processes in this paper.
as discussed previously adi erent i ci bounded erg might be generated if a di erent ordering is used.
as a result the ordering of visiting con gurations during each induction will be changed.
it might be possible to heuristically nd an optimal ordering leading to better experimental results.