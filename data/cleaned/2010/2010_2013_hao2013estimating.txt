estimating mobile application energyconsumption using program analysisshuai hao ding li william g. j. halfond ramesh govindanuniversity of southern california usa shuaihao dingli halfond ramesh usc.eduabstract optimizing the energy efficiency of mobile applica tions can greatly increase user satisfaction.
however developerslack viable techniques for estimating the energy consumptionof their applications.
this paper proposes a new approach thatis both lightweight in terms of its developer requirements andprovides fine grained estimates of energy consumption at thecode level.
it achieves this using a novel combination of programanalysis and per instruction energy modeling.
in evaluation ourapproach is able to estimate energy consumption to within of the ground truth for a set of mobile applications from thegoogle play store.
additionally it provides useful and meaningfulfeedback to developers that helps them to understand applicationenergy consumption behavior.index terms mobile app fine grained energy estimation program analysis.i.
introductionsmartphones and tablets allow people to carry around morecomputational power in their hands than most had on theirdesktops just a few years ago.
however the usability of thesedevices is strongly defined by the energy consumption ofmobile applications and user reviews of applications revealmany customer complaints related to energy usage.research in estimating the energy usage of mobile deviceshas explored a wide variety of techniques ranging fromspecialized hardware cycle accurate simulators and operatingsystem level instrumentation to carefully calibrated software based energy profilers that provide coarse grained energyestimates.
from the perspective of a developer wishing tooptimize energy consumption of an application each of theseapproaches has one or more shortcomings specialized hard ware can be expensive cycle accurate simulators and oper ating system level instrumentation can slow down a mobileapp beyond the point of usability and coarse grained energyestimates may not be able to pinpoint hotspots within an app.to address these shortcomings we explore a novel ap proach calledelens that combines two ideas that havenot previously been explored together program analysistodetermine paths traversed and track energy related informationduring an execution andper instruction energy modelingthatenableselensto obtain fine grained estimates of applicationenergy.elensdoes not require the developer to possessspecialized hardware or to instrument the operating system does not impact the usability of applications and can measureenergy usage at method path or line of source granularity.these two ideas work in concert as follows.
when adeveloper wishes to obtain an energy estimate for specific usecases of a mobile app elensuses instrumentation to identifythe corresponding paths of an application that will be executedand record runtime information that is needed by the energymodels sectioniii .
to compute the energy estimate elensanalyzes the recorded paths and runtime information to extractthe energy relevant information and uses this information todrive the energy models and estimate the energy consumptionof each bytecode or api call for the hardware componentsof the system e.g.
cpu memory network and gps .
theenergy models are provided by a software environment energyprofile seep whose design and development enables theper instruction energy modeling sectioniv .elensenergyconsumption estimates can be computed at different levelsof granularity application method path and line of sourcecode and integrated into a development environment such aseclipse so that developers can visualize the energy usage oftheir application during development.elenshas several desirable properties that distinguish itfrom prior work.
by design it islightweight elensdoesnot require modifications to the mobile operating systemor require expensive power monitoring hardware.
moreover elensprovidesfine grainedvisibility into the energy con sumption of an application at multiple levels of granularitydown to an individual line of source code.
using experimentson popular mobile applications obtained from the androidmarketplace we demonstrate two other important properties sectionv .elensisaccurate it is able to estimate the powerconsumption of real marketplace applications to within ofground truth measurements.
competing methods that are path insensitive or use coarse grained energy models can be anorder of magnitude more inaccurate.
finally it isfast allowingdevelopers to easily analyze the energy behavior of multiplecombinations of hardware and operating systems.ii.
relatedworkpower modeling is a broad area of research that encom passes several sub fields including architecture operatingsystems and software engineering.
given space limitations we present representative pieces of work from each area toplaceelensin the context of prior work.closely related toelensis the body of prior work onarchitectural power modeling which has attempted to modelor profile the power consumption of individual instructions.tiwari and colleagues model the energy of an in struction using a base energy as well as a transition energyfor each pair of instructions.
steinke discusses a moredetailed power model that takes architectural features such aspipeline stalls into account.
sinha and colleagues show978 .
c ieee icse san francisco usa 90that arm instructions all consume comparable energy.
finally mehta and colleagues profile energy usage at the level ofarchitectural functional units.
in contrast to this body of work elensestimates bytecode energy costs energy of bytecodesshows considerably higher variation and may be less affectedby architectural effects at the instruction level.cycle accurate simulators have also been developed toestimate software energy consumption of software such assim panalyzer and wattch .
these approaches cansimulate the actions of a processor at an architecture leveland estimate energy consumption in each cycle.
comparedtoelens these methods can be highly inefficient e.g.
sim panalyzer needs instructions to simulate the executionof a single instruction impeding their usability for complexmobile applications that involve user interaction.novel hardware designs have been proposed to estimateenergy consumption.
the leap platform which we usein this work provides fine grained measurements of energy.others have designed an fpga based embedded device toperform component wise energy profiling and empiricallymeasured the energy impact of using different software de sign patterns .
by contrast elensrequires no specializedhardware to obtain fine grained estimates of app energy usage.other works focus on the energy consumption of the operat ing system at routine or system call level .they all build power models at the system or routine call level which describe the power consumed as a function of somefeature of the system or routine call e.g.
the cpu utilizationor the input parameters .
these power models are then used toestimate system level energy consumption.elensis inspiredby this work but builds models at the instruction granularity and so is able to estimate power down to the granularity of aline of source code.a complementary approach explicitly models thestate transitions between hardware power states of smartphonehardware components cpu wifi gps etc.
.
this approachthen estimates the power states of each component duringa system call based on the call input parameters.
usingthis and measured values of hardware power states it ispossible to compute the approximate energy consumption ofapplications and functions that invoke system calls.
however unlikeelens this requires manual instrumentation of theapplication framework and may not work for applications withenergy intensive application level code.also complementary is recent work that allows devel opers to estimate overall application energy usage using anemulator.
in contrast elenscan be integrated into an ide andprovides much finer grained energy estimates making it moreseamless for the developer to optimize applications for energy.beyond instruction level and call level energy modeling some work has also considered path energy profiling.
tanand colleagues model path energy costs using the ball larus profiling technique .
in comparison elensdirectlyestimates bytecode costs and environment invocations soit can be used to compute energy utilization at differentgranularities.tangential toelensis a body of work that has attempted toestimate the energy consumption of java on different virtualmachines .elensprovides fine grainedestimates of energy usage within an application.likeelens seo and colleagues built aninstruction level model of java bytecodes and linear modelof interfaces of the jvm and operating system calls.
unlikeelens however they require modifications to the jvm toestimate bytecode costs online.
moreover they do not performany path sensitive analysis and so are able to provide energyconsumption estimates only at the system level.complementary methods for estimating the energy usageof applications have relied on operating system level instru mentation together with hardware support for energymeasurement.elensrelies on power profiles and does notrequire modifications to the operating system.finally in a previously published workshop paper we described preliminary work that used execution tracesto estimate cpu energy consumption.
this paper extendsthat work by improving the underlying analyses adding amore sophisticated cpu model that accounts for frequencyscaling and expanding the technique to include other hardwarecomponents such as ram wifi and gps via the seep.furthermore elensis able to handle real marketplace appli cations whereas the previous work could only estimate energyfor instructions that were not invocations.iii.
ourapproach forenergyestimationelensanalyzes the implementation of a mobile applicationand provides code level estimates of the energy that it will con sume at runtime.
the results of this analysis are summarized atthe granularity of the whole program path method and sourceline to help the developer make informed implementationdecisions for reducing energy consumption.
the inputs tothe approach figure1 are the software artifact the workload which describes the way the software willbe used at runtime and system profiles which use per instruction energy models to specify the power characteristicsof the platforms for which the developer is targeting theimplementation sectioniv .
withinelens there are threecomponents the workload generator sectioniii a translatesthe workload into sets of paths through the software artifact the analyzer sectioniii b uses the paths and system profilesto compute an energy estimate and the source code annota tor sectioniii c combines the paths and energy estimate tocreate an annotated version of the source code that is providedto the developer.
the output ofelensis a visualization thatshows the estimated energy consumption of the software atthe path method source line and whole program granularity.a.
generating the workloadthe workload generator is responsible for converting theuser level actions for which the developer wants an estima tion to the path information used by the analyzer and sourcecode annotator.
trivially this information could be providedby assuming that every path in the artifact is executedn91fig.
overview ofelensnumber of times.
however this would not be an accuratereflection of how the application would execute at runtime andsince energy consumption is not uniform over different paths the resulting estimate would not be as helpful.
for example in a video viewing application the paths traversed to watcha video will consume more power than the paths traversed tostart or exit the application.the inputs to the workload generator are the workloaddescription w and the implementation of the application s.theworkload descriptionis a specification of the behaviorof the application for which the developer wants to estimateenergy consumption and can be represented as a sequence ofuse caseshu1 u2 .
.. uni.
the workload generator instrumentssto create a version s0 that will record the paths traversedduring an execution.
next the workload generator runs eachui2wons0.
the paths traversed foruiare denoted aspi.
theset of allpi p is the output of the workload generator.the workload description can be specified informally wherethe developer simply interacts with the instrumented applica tion or formally where the sequence of actions is explicitlylisted and can be executed by automated android testing tools such as monkeyrunner and robotium .
we only requirethat the specification mechanism must be able to execute theinstrumented version of the application so the paths traversedby the application are recorded.
there is no adequacy criterionfor the workload description except that it represents the set ofactions that are of interest to the developer.
for example aninformal workload description of a video player may specifythat the user perform the following actions a start theapplication b search for a video using the term elensaticse c play the first video found d replay the video 100times and e exit the application.the instrumentation inserted by the workload generatorrecords the path traversed through each method of the appli cation.
this recording is based on an efficient path profilingtechnique proposed by ball and larus .
the ball larusapproach assigns weights to edges of a method s control flowgraph cfg such that the sum of the edge weights alongeach unique path through the cfg results in a unique path id a single instrumentation variable per method then suffices torecord the traversed path for one method invocation.
therefore eachpiis comprised of a sequence of sub path tuples eachdenoted byhm idi wheremis the method andidis the idof the path traversed.
our implementation extends the ball larus approach to handle nested method calls concurrency and exceptions as described in sectionv a.to illustrate the output of workload generator considera software artifact with three methodsa bandc.
for thisartifact a possiblepis hha 1i hb 1i ha 2ii hha 2i hc 3ii which contains two paths.
the first corresponds to a use casein which path of methodais executed followed by path ofmethodband then path of methoda.
the second correspondsto a use case in which path of methodais executed followedby path of methodc.algorithm 1estimate energy consumptioninput h set of hardware components l source line m method andp pathoutput energy estimate in joules1 cost hq m li regenerate p d propagatedt q for allh2hdo5 for alli2qdo6 fh powerstate i h ifl i l m i mthen8 cost h c i h fh d i return h2hcost h b. estimating energy consumptionthe analyzer computes energy estimates using the pathinformation provided by the workload generator and theenergy cost functions from a software environment energyprofile seep algorithm1 .
as input the analyzer takes asequence of sub pathsp2p methodm source line numberl and set of hardware componentshto be accounted for inthe estimation.
for each instruction1specified bylandm theanalyzer calculates the energy cost using the cost functionsdefined in the seep.
the output of the analysis is then theenergy estimatee in joules of the path method or sourceline.
an energy estimate for the entire software artifact can becalculated by summing the calls for eachpi2p.the seep defines energy cost functionsc for all in structions.
broadly speaking there are two dimensions alongwhich energy costs may vary for instructions power state andpath dependent information.
most components such as thecpu network and gps have multiplepower states modernsmartphone cpus can operate at different frequencies whichconsume different amounts of energy the gps may be onor off and the network may be idle transmitting receiving or have selectively enabled multiple antennas.
thus c candepend upon the power state of the corresponding componentwhen a bytecode or api component is executed.
furthermore some api invocations energy consumption is based on path dependent information.
for example sending data over thenetwork incurs energy costs roughly proportional to the sizeof the data transfer.
during the process of workload generation 1we useinstructionto denote both bytecodes and system api calls.92elenstracks the power states of hardware components andalso certain types of path related data.
this information isincluded as one or more arguments to the cost functionsdefined in the seep.
details and examples of path dependentinformation are provided below and in sectioniv.the first operation performed by the analyzer is to re generate the instruction sequence represented byp line ofalgorithm1 .
as defined by the ball larus algorithm givena subpathhm idi it is possible to regenerate the sequence ofinstructions that define each subpath.
theregeneratecombineseach subpath inpto define the complete path entry to exit taken during the execution.
for nested method calls wheremethodacalls methodb regeneratecalculates the sequenceof instructionsa1 a2 .
.. antraversed inaandb1 b2 .
.. bmtraversed inb.
ifakis an invocation tob then the finalsequence would bea1 a2 .. .
ak b1 b2 .
.. bm ak .
.. an.
iden tifying which subpaths inpwere called by other subpathsis straightforward sincepis a sequence and eachhm idiisappended topaftermexits.
the final output ofregenerateisthe tuplehq m li where isqis the complete path mmapseach instruction inqto its containing method andlmapseach instruction inqto its source code line number.the energy cost of certain instructions is based on path dependent information.
for example the cost of a networksend instruction depends upon the amount of data sent and thecost of opening an input stream will depend on the stream type.line of the algorithm propagates argument and type dataalongqthat can be used to identify this type of informationand initializes a functiondthat relates this informationto each instruction.
thepropagatedtfunction implementsthis functionality by simulating data flow along the pathq.the instrumentation introduced by the workload generatorrecords information such as the size of data operated onby an instruction or the class implementing an api call atspecific points of the execution.propagatedtthen simulatesthe stack contents alongqto track the types and relevant dataattributes to the point where they are needed by the energycost functions.
stack simulation works well in this contextbecause it is operating on only one complete path q and onlya subset of all instructions on the path need to be simulated.in cases where values are manipulated by an uninstrumentedfunction e.g.
a library call an average value is used for theenergy cost functions.
more details on the specific types ofinformation tracked is discussed in sectioniv.many path dependent apis require specialization of thegeneral approach described above.
due to space constraints we provide two representative examples of the analysis em ployed by thepropagatedtfunction.
precisely identifyingthe class that extendsinputstreamis difficult because inandroid applications these often originate from a factory class.to gather this information the workload generator inserts aprobe intos0after calls to specific factory methods to recordthe implementing class type.
this information is then used toannotate the data item in the stack simulation so that whentheinputstreamapi is called the implementing class onthe stack can be identified and the appropriate cost functions fig.
source line visualization provided byelensused.
allocation instructions set aside memory space foran array.
for example network buffers may allocate a bytearray and define its size using a hard coded constant of .thepropagatedtfunction tracks loads of constants onto thestack so that when they are popped and used as arguments thevalue of the constant can be identified.
in the example above the analyzer would be able to determine that is the valueof the constant on the stack used to supply the argument tothe allocation statement.as described above many components have multiple powerstates.
for example modern cpus conserve power by chang ing the cpu frequency in response to high or low utilization.an instruction s power consumption can therefore depend onthe frequency of the cpu when it is executed.
the functionpowerstate used in line maps each instructioni2qto thepower statefhof componenth wherehmay be the cpu wifi or other component with multiple power states wheniwas executed.elenscomputesfhby tracking during workloadgeneration when component power state changes occur.
thecost functions for each instruction takefhandhas arguments.for example assuming a cpu has two frequency levels highand low the cpu cost function for anldcinstruction wouldreturn two different energy cost valuesehighorelow dependingon whetherfcpureported the frequency as high or low for thatinstance of the instruction.each instruction that satisfies the method and line numberconstraints is added to the total energy cost lines .the analyzer calculates an instruction s energy cost for eachcomponent of the platform as a function of its type path dependent data and component power state.
the analyzer canbe configured to explore different sets of hardware componentsvia the inputh.c.
energy annotationsthe source code annotator converts the path informationand energy estimation numbers into a graphical representationthat allows developers to visualize the energy consumptionof their software.
the representations connect the estimatedenergy numbers to the implementation structure of the soft ware artifact.
the ability to visualize energy usage at a sourcecode line level is a unique feature ofelens.
feedback at thislevel allows developers to iteratively refine implementation93details such as statements and loops to improve the overallenergy consumption of the software.
we have implemented thevisualization as an eclipse plugin which can provide visualrepresentation of the energy consumption at four differentgranularity levels whole software per method per line ofsource code and for each path.
note that for each granularitylevel the energy consumption can be shown for some or alluse cases in the workload.
the mechanism for two of theserepresentations is discussed below the mechanisms for pathand whole software annotations follow from these.per line of source code for a given source file theannotator ranks each source line according to its energy costover allp2p.
then the rankings are mapped to a colorspectrum such as blue to red and each line of source codeis colored based on its position on the spectrum.
this resultsin a seesoft like visualization of the power consumptionof the software.
figure2shows a screenshot of a java sourcefile with the energy based colorings.method representation for a given source file the sourcecode annotator generates the call graph cg of the softwareartifact.
the methods in the cg are ranked according to theirenergy consumption over allp2pand then assigned a colorin a spectrum based on their relative use of energy.
a method sassigned color and energy value are then used to annotate thecorresponding node in the cg.iv.
softwareenvironmentenergyprofilethe software environment energy profile seep providesper instruction energy cost functions for each component ofthe target platform.
the use of the seep allowselenstoanalyze energy consumption on multiple platforms by sim ply providing different seeps as input to the analyzer.
weanticipate that a seep will be developed and distributed bya platform s manufacturers as part of the platform s softwaredevelopment kit.
this method of distribution makes it unnec essary for developers to use complicated or expensive energymonitoring equipment.
currently it is not common practicefor manufacturers to provide seeps so we discuss below thesteps required to develop a seep.for each distinct hardware component the seep containsa function that estimates the energy cost of each instructionat each distinct power state of the hardware component.
thus ccpu i f denotes the cpu energy cost of instructioniatfrequencyfandcwifi i the wifi cost2.to estimate these cost functions we used the leap powermeasurement device .
leap reports energy consumptionmeasurements at a fine granularity for each hardware com ponent in the system its analog to digital converter daq samples each component s current draw at khz.
it containsan atom processor that runs android version .
so wecan measure the energy consumption of android applications.in addition the leap provides android applications withthe ability to trigger a pulse that can be used to correlate2the latest wifi standard .11n supports multiple power states.
wehave left cost functions for .11n as future work.application activity with daq readings.
this capability allowsus to time specific sections of profiling code by generatingpulses at the beginning and end of sections of code whoseenergy consumption we wish to measure.
the daq readingsare stored in a log and post processed in order to estimatethe total energy consumed between a pair of pulses.
thesemeasurements are performed by hardware external to thecomponents.the energy cost functions for instructions can be broadlygrouped into two categories those with a path dependentenergy cost and those with a path independent energy cost.the cost functions for the latter can be approximated for eachhardware component by knowing only information local tothe instructions.
the path dependent instructions require addi tional information that can only be identified by incorporatinginformation from prior instructions in the executed path.
theprofiling for both types is explained in more detail below.a.
path independent cost functionscost functions for instructions with path independent costscan be calculated for each hardware component using thetype of instruction and power state e.g.
cpu frequency of the hardware component at which the instruction wasexecuted.
we identified these instructions by analyzing the im plementation of the dalvik virtual machine and confirmed ouranalysis through empirical measurements.
to profile individualinstructions we created a set of test scripts each of whichprofiles an individual instruction by placing that instructionin a loop that executes million times.
this ensures ameasurement of a sufficiently long duration that exceeds thedaq sampling interval and reduces variance.
each loop is thenrun ten times on a quiescent system to minimize the impactof cold starts cache effects or background processes such asgarbage collection .
we subtract the cost of the loop setup andleap pulse instructions from the measured cost.some instructions require the results of executing otherinstructions.
for example anaddinstruction requires thattwo operands be pushed on to the stack.
to handle this adependency is identified between the test scripts.
for instance if theldcinstruction is used to push operands on the stack then the test script for theaddinstruction includes thesebytecodes.
when profiling theaddinstruction we subtractthe cost of the twoldcinstructions.
we repeated this processfor all of the dalvik bytecodes we identified as having alocal cost.
details for different categories of bytecodes areprovided below.
this list is not intended to be exhaustive butto illustrate how different categories were handled invocations and returns from application function whenthe target of an invocation is an application function thetarget method will already be instrumented by the workloadgenerator so only the overhead of the invocation and returnneeds to be profiled.
in the profiling scripts it was not possibleto isolate an invoke from a return both are required toexecute in pairs.
therefore we measured all combinations ofinvoke and return types and then calculated the cost of eachinstruction.
values for these instructions varied according to94the type of invoke e.g.
virtual or static and the type of valuereturned e.g.
void integer or float .invocations to fixed cost apis many invocations to systemapis performed operations such as setting a property thatcould be described with a fixed cost.
these were profileddifferently than regular instructions because of their relativelyhigh execution time both in terms of the functionality theyimplemented and argument initialization.
we profiled thoseapis that had a fixed cost over all hardware componentsand were called from within one of the applications usedin our evaluation.
this set included approximately 500unique apis.
for these we instrumented our application toobtain energy consumption incurred by each api and ranour applications several times to obtain a sufficient number ofenergy consumption samples for each api call.
the averageof these samples for each api was used as its fixed cost.other instructions the energy costs for loads and storesvaried according to the basic type on which they operated e.g.
integer or float .
for arithmetic and logic instructions the energy cost varied based on the operation performedand the basic type on which the operations were performed.stack management instructions had a fixed cost.
finally jumpsand branches incurred a fixed cost regardless of the type ofcondition they check.b.
path dependent instruction coststhe energy cost for path dependent instructions is basednot only on hardware power state and instruction type butalso on information that is provided by other instructions inthe path such as the size of the arguments to a network sendinstruction.
in general we found four categories of path depen dent instructions allocation instructions invocations of systemapis whose cost depends on the argument data invocations ofsystem apis whose cost depends on the implementing class and invocations whose cost depends on external data.
thesetypes are discussed in more depth below.allocation instructions such asanewarray cause mem ory to be set aside for an array of basic types.
our mea surements indicate that the cost of allocation statements islinearly proportional to the amount of memory allocated.therefore the cost of an allocation instruction is a linearfunction with respect to the size of the array and the sizeof the basic type allocated.
the size of a basic type e.g.
char int and object reference is known ahead of time and theruntime instrumentation can record an estimate of the arraydimension at runtime which is then propagated along thepath by thepropagatedtfunction described in sectioniii.for allocation of objects thenewcommand has a simplerfixed cost function as it only initializes a pointer which isfollowed by an invocation of the object s constructor whichis handled as an invoke to function.the energy cost of data dependent invocations is based onthe size of the arguments to the invocation.
this type ofinvocation is often used to access hardware components suchas the network or perform data manipulations such as datasorting.
for modeling invocations to hardware components our profiling was informed by research work that investigatedand modeled power consumption of various android hardwarecomponents.
we identified salient features of these modelswhose values could be provided via program analysis andused empirical evaluation of the leap node to determinevalues for hardware specific constants.
hardware componentmodels were built for the cpu ram wifi and gps.
it wasnot possible to model additional components because theyrequired hardware modification to the leap to wire theminto the daq a necessary step to verify the accuracy of themodels.
as we show in sectionv we were able to achievehigh accuracy and believe that the process is straightforwardto extend to other hardware components as the ability tomeasure them within the leap framework becomes available.to provide the argument data size to the energy cost model thepropagatedtfunction propagates the size of data structuresto data dependent invocations.the cost incurred by some invocations relies on data orconditions external to the application that cannot be identifiedusing analysis of the path.
for example for an invocationthat retrieves a web page or queries a database there aretwo associated energy costs the invocation that makes therequest for data and the processing of the response.
in ourexperimentation we found that the former could be modeledaccurately as a function of the response time of the externalsource of data and the latter as a function of the size ofthe response.
to build the energy cost functions for theseinvocations we instrumented all invocations that made exter nal data requests to record the name of the data requested e.g.
url database query or filename response time andresponse size.
we used this information to build a map fromthe data name to its response attributes.
then when computingthe cost of an invocation that depends on external data weused the map to look up the name of the requested data andprovided the response time as an argument to the invocation senergy cost function.
when a subsequent invocation occursthat processes or iterates over the returned data the size ofthe response is supplied as an argument to this invocation scost function.
as with the previous types of invocations theresponse attributes were propagated to the invocation using thepropagatedtfunction.
we used this methodology to estimatethe cost of database calls to the android sqlite database andinvocations to thehttpmessageinterface.invocations of some methods can vary significantly basedon the class that provides the method implementation.
forexample the cost of accessing the member functions of theabstract classinputstreamwill depend on whether itsimplementation is provided by a network based class suchaschunkedinputstream or a file based class such asfileinputstream.
to handle this type of invocation weused manual analysis and empirical measurements to identifythe methods whose energy varied due to differences in theirimplementing class.
we analyzed each such method and itsimplementation to determine whether a model could be builtbased on simply profiling the method or whether a more com plex model based on argument size or external data needed95to be constructed.
the energy cost function for these methodscould therefore depend on data tracked by thepropagatedtfunction argument data and implementing class information.v.
eva l uat i o nin this section we empirically evaluateelensby measuringtheaccuracyof its energy estimates illustrating theuseful nessof our approach by evaluating whether time profilingwould have been an effective substitute for energy profiling and demonstrating theusabilityofelensin an interactivedevelopment setting by measuring its run time.
we concludewith a case study that demonstrates howelenscan be used tounderstand how applications consume energy.a.
methodologyour evaluation is based on an implementation ofelenswhich is able to estimate the energy usage ofunmodifiedandroid applications from the google play store.
as input elenstakes the implementation of an application in dalvikbytecode and uses thedex2jartool3to convert it into javabytecode.
the java bytecode version is then provided as inputto the workload generator and source code annotator.
theoutput ofelensis a visualization and reports on the estimatedenergy consumption of the application.the workload generator uses thebcelinstrumentationlibrary4to add path profiling instrumentation as discussedin sectioniii and to collect the data and type informationas needed for the seep.
in our implementation we identifyand discard paths that result in exceptions since their catchblocks may cause control flow to jump outside of the method a behavior for which the ball larus algorithm is undefined.overall this only resulted in less than .
of paths beingdiscarded.
concurrency is handled by using the thread s id toidentify the counter that must be updated to track the path id.after instrumenting the application it is compiled from javabytecode back to dalvik bytecode using the standard androiddxtool and deployed to the leap platform.
the use caseswere run manually by interacting with the application whileit was deployed on the leap platform.the algorithms for the analyzer and source code annotatorwere implemented as discussed in sectionsiii bandiii c.the analyzer uses the seep that we built as specified insectioniv.
the source code annotator was built as an eclipseplugin and can display energy consumption at the level ofgranularity of the whole application method path or sourceline.
screenshots for the plugin are shown in sectioniii c.subject applications tableishows the set of subjectapplications that we used in our empirical evaluation.
for eachapplication the table shows the number of classes defined inthe implementation c the total number of methods acrossall of those classes m number of total bytecodes bc and a brief description of the functionality of the application.we used total bytecode count instead of source lines because3 apps were downloaded from the google play market andsource code was not provided as part of the distribution.we selected the applications based on three criteria diversity of provided functionality ability to convert thedalvik bytecode to java bytecode and ability of theapplication to run on the leap platform.
the last twocriteria curtailed the number of applications available for usto experiment with.dex2jaris not yet fully mature andis sometimes unable to completely translate dalvik to javabytecode.
furthermore many applications use native librariesthat are not available for the leap s x86 processor.b.
accuracy ofelenswe first compare the accuracy of the estimates produced byelensagainst the ground truth gt measured by the leapplatform.
to do this we provide each application as input toelens.
this generates an instrumented version that is deployedto the leap platform where we interact with each applicationto exercise its most prominent features.
during the execution the leap platform measures power consumption across all ofthe hardware components.
after the execution the analyzercomputes energy estimates which are summarized and reportedby the source code annotator.
we compared the measuredgt against theelensestimates at both the method and wholesoftware level.
as explained below it was not possible tocalculate gt at the line of source code level.we also compareelensto two other plausible strategies forapproximating the energy consumption of mobile applications.theaverage bytecodestrategy does not unlikeelens useper instruction energy cost functions but assumes that eachinstruction has a uniform cost that can be calculated byaveraging the cost of all instructions over all runs of theapplication.
theno path sensitivitystrategy does not unlikeelens account for the specific paths traversed in a method butestimates energy based on the number of times a method iscalled multiplied by the cost of all of the method s bytecodes using per instruction energy costs .
these strategies representthe results that could be achieved by a developer with a methodprofiler e.g.
gprof and power measurement device but eachlacks one important capability ofelens per instruction energymodeling and program analysis respectively .the gt is calculated by taking hardware level measure ments on the leap platform while the application is running.however there are three challenges that preclude a straight forward measurement and require a more complex process forestablishing gt.
first the applications can pause while waitingfor user input or a data response.
although the application isnot executing the device will still consume energy that shouldnot be counted towards an application s gt.
although thisidle time is imperceptible to humans our measurements showthat it dominates the total execution time of an applicationand must be excluded in order to not have a gt dominatedby times when the application is idle.
second even whenmeasuring the application energy during periods when it isnot idle the leap or any power monitor cannot distinguishif the measured energy was expended by the application or96table i subject applicationsapplication information estimation error time vs. energy timing s appc m bc descriptioncpu ram wifi gpsr costinsttestbbc reader590 rss reader for bbc news .
.
.
.
16bubble blaster ii932 game to blast bubbles .
.
.
.
17classic alchemy751 game to combine chemical elements .
.
.
.
17location428 provide location with pl2303 dirver .
.
.
.
10skyfire684 web browser .
.
.
.
8textgram632 text editor5.
.
.
.
6background processes.
third the leap samples at khz so in theory it can only capture energy usage of methods whoseexecution time exceeds .1ms.
in practice we found thatreliable energy estimates can only be obtained for functionswhich run for at least ms. this meant that gt for manymethods could not be measured and it was not possible tomeasure energy consumed by a specific source line of code.all three of these were addressed by our experiment smethodology.
to address idle time we identified and times tamped apis where the applications could block and idle.unless other threads in the application were executing duringthe blocked time we counted this as idle time and subtractedit from the gt.
to ensure that measured energy was accuratelyattributed we performed the gt measurements on a quiescentsystem.
as mentioned in sectioniv our technique does notaccount for garbage collection or process switching so weidentified points during the execution when these occurred andexcluded the energy consumed along the affected subpathsfrom both the energy calculation and the gt total.
thisrepresented only .
of the total paths traversed in ourexperiments.
lastly to account for sampling frequency weonly conducted accuracy experiments at the whole programand method level.
only methods that ran for more than 10msat a time were included in the evaluation.note that this does not meanelenscannot be used forsource line estimates only that the leap platform couldnot provide gt to evaluate the accuracy of these estimates.elensexcludes waiting time energy because it counts onlyinstructions executed by the application and is able to estimateenergy usage of arbitrarily small functions because it usesprofiled costs of bytecode energy usage.
for the same reason elenscan isolate the energy usage of application code.
theseare significant advantages of our approach.figure3 a shows the accuracy at the level of granularityof the whole application.
our subject applications are shownalong the x axis.
figure3 b shows accuracy at the methodlevel for those methods whose running time exceeded 10ms.note that for all methods there were only six that executedlong enough to get an accurate gt measurement.
for eachapplication or method the bars show on a logarithmic scalethe average estimation error compared against gt of ten runsreported byelensand the two reference techniques averagebytecode and no path sensitivity.
each bar also shows onestandard deviation above and below average estimation error.the results show thatelensis able to calculate energyestimates with high accuracy at both the whole program andmethod level.
for the subject applications elens estimationerror at the whole program level was below across allapplications with an overall average of .
std.
deviation of3 and from .
to with an overall average of .
atthe method level std.
deviation of .
.
furthermore elensis able to accurately break down application energy usage byhardware component tablei its energy estimation errors forall hardware components are within .
note that locationwas the only app that used gps.
this is highly encouraging and suggests thatelenscan be a viable approach for exploringthe energy usage of mobile applications.in comparison the two other plausible strategies are inaccu rate by several orders of magnitude.
specifically the averageestimation error for average bytecode at the whole programlevel was and for no path sensitivity was .
tounderstand why average bytecode is inaccurate we plotteda distribution of bytecode energy costs.
this distribution omitted for brevity is highly skewed with a small numberof instructions using more than an order of magnitude moreenergy than the rest.
thus an average bytecode cost can eitherinflate the energy estimate for a program that does not usethese expensive instructions or underestimate energy usage forprograms that do.
moreover our results also indicate that path sensitivity is crucial for capturing energy usage of applicationsand methods.
this is because our subject applications aresignificantly large and have a large number of potential pathsthat may be explored during an execution.overall these results provide a compelling demonstration ofthe accuracy ofelens its ability to provide energy estimatesat granularity that is beyond the reach of hardware powermonitors and of the importance of the two pillars of its design per instruction energy modeling and path sensitivity .c.
why do we need energy profilers?traditionally using execution times obtained from a methodprofiler is a common way for developers to identify methodsthey will focus on to improve the efficiency of their applica tion.
in this section we show that execution time may not bea good proxy to identify energy inefficient segments of codeand that specialized energy profilers likeelensare necessary.to demonstrate this we first calculated the execution timeand energy estimate of each method of each application.
toobtain the execution time we profiled each method usingtimestamps and calculated the corresponding energy estimatefor the method usingelens.
we then compared the informationin two different ways to evaluate whether time is indeed areasonable proxy for energy cost.correlation we first determined whether there is a linearcorrelation between the execution time of a method and its97 textgram bubble alchemy skyfire bbc locationestimation error elensaverage bytecodeno path sensitivity a whole program accuracy run load oncreate a onactioncycleestimation error elensaverage bytecodeno path sensitivity b method level accuracy textgram bubble alchemy skyfire bbcenergy consumption c top five energy hotspotsfig.
plots ofelensaccuracy comparison and top energy hotspotsestimated total energy across all components .
we do thisby calculating the pearson correlation coefficient of the twoseries.
values of the coefficient closer to or indicatethat the two series have a strong positive or negative linearrelationship and values closer to zero indicate that they areuncorrelated.
the pearson coefficients rin tablei are nearlyzero across all applications indicating that there is almost nolinear correlation between execution time and energy usage.ranking similarity we then considered that even if energyand time were not linearly related the relative rankings bythe metric might provide useful guidance.
so we measured thesimilarity of the rankings by calculating their cosine similarity a technique used to measure similarity between two vectorsin n dimensional space.
in this case we defined two vectors v0 v1 .. .v methods where eachviwas defined for one vector asmethodi s energy rank and for the other methodi s executiontime rank.
the cosine similarity ranges from to with 1denoting the exact opposite ranking denoting independentrankings and denoting the same ranking.
tableishowscosine similarity values closer to than to or for all butone application skyfire.
this strongly suggests that for mostapplications time and energy are almost independent.there are at least two reasons why time and energy areuncorrelated.
the first is that many hardware components havemultiple power states.
two different methods can take thesame time to execute on a cpu but when one of them isexecuting the cpu may be at frequencyf1 while when theother is executing it may be atf2.
iff2 f1 the energyconsumed by the latter will be more than that consumed bythe former.
the second explanation lies in the asynchronousdesign of system and api calls.
when an application sendsdata over the network that data is buffered by the operatingsystem so the application may not be charged the time takento transmit the data.
however elenswill accurately accountfor the energy cost of transmitting the data since it profilesthe send api call.these results demonstrate the importance of an approachlikeelens which can guide energy optimizations more accu rately than method profilers based on execution time.d.
analysis timein this section we evaluate one aspect of usability ofelens namely whether it is fast enough to be used duringsoftware development.
we measured for each application overa series of executions the time the workload generator tookto instrument tinst and the time needed by the analyzer tocalculate the energy estimate given the output of the workloadgenerator test .
tableishows these two measures for eachapplication.
as the results show the instrumentation timeranged from about to minutes and the analysis timeranged from to seconds.
in practice instrumentation timewould be much lower because after each developer iteration itwould only be necessary to reinstrument the changed classesas opposed to all classes our numbers report the latter .
theanalysis time is fairly low in comparison and would not hinderusability during development.we did not measure the overhead introduced at runtime byour instrumentation because our method of executing use caseswas to manually interact with the application and we could notcontrol for normal human variations when interacting with theinstrumented and non instrumented versions of the application.anecdotally the runtime overhead was imperceptible to usersinteracting with the instrumented application.
using the addi tional estimated energy consumed by our instrumentation asa proxy we estimate that the runtime overhead ranged from0.
.
across the applications.e.
usingelensto compare applicationswe conclude by illustrating howelenscan be used tocompare application energy usage.
we have left a morecomplete study of application energy characteristics to futurework but this section begins to explore howelenscan be usedto understand where energy is expended in an application andhow that differs across applications.to study application energy usage we calculated for eachapplication the top energy hotspots.
the bar graph offigure3 c plots the subject applications on the x axis and for each application the fraction of total application energyconsumed by the top hotspots in order from left to right.as this figure shows applications vary widely in how energyusage is distributed.
the fraction of total energy that can beattributed to the top hotspots varies from about forbubble blasterto an astounding forskyfire.
moreover as the figure shows even among the top hotspots energyconsumption can be significantly skewed inskyfire a singlehotspot uses over of application energy!less evident from this figure is an understanding of thecauses of high energy usage but an examination of thetop hotspots listing omitted for space reasons revealsinteresting insights.
inskyfire an android library call forhttp downloads consumes the most energy but in thebbc98reader the top hotspots include api calls for downloadingand rendering content as well as downloading advertisements.intextgramas well as in the two games appropriately enough graphics computations dominate the top hotspots.
in thesecases an included package or library consumed a significantamount of energy in response to this an application developermight either choose to optimize the library implementation orre implement the functionality provided by the library in amore energy efficient manner.vi.
conclusionthis paper presents a new technique elens for estimatingenergy consumption of applications written for android mo bile devices.elensbrings together two ideas per instructionenergy modeling and program analysis in order to accurately and without requiring power measurement hardware estimateapplication energy usage at the level of granularity of thewhole application method path or source code line.
anevaluation ofelenson six marketplace applications showsthat its energy estimates are accurate to within and itsrun time is acceptable.
moreover elenscan reveal insightsabout energy usage across different applications and its energyestimates are uncorrelated with execution time suggesting thatmethod profilers may not help in optimizing applications forenergy use.
overall the results of the evaluation were verypositive and indicate thatelensis an accurate fast and usefultechnique for estimating energy consumption.acknowledgementsthis work was supported by the national science founda tion under grant no.
cns and a zumberge researchaward from the university of southern california.
any opin ions findings conclusions or recommendations expressed inthis work are those of the authors and do not necessarily reflectthe views of the sponsors.
the authors would like to thanknilesh mishra for his help on the leap platform.
the firstauthor was supported by annenberg graduate fellowship.