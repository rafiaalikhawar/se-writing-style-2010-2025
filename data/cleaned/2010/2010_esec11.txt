semistructured merge rethinking merge in revision control systems sven apel j rg liebig benjamin brandl christian lengauer university of passau germanychristian k stner philipps university marburg germany abstract an ongoing problem in revision control systems is how to resolve conflicts in a merge of independently developed revisions.
unstructured revision control systems are purely text based and solve conflicts based on textual similarity.
structured revision control systems are tailored to specific languages and use language specific knowledge for conflict resolution.
we propose semistructured revision control systems that inherit the strengths of both the generality of unstructured systems and the expressiveness of structured systems.
the idea is to provide structural information of the underlying software artifacts declaratively in the form of annotated grammars.
this way a wide variety of languages can be supported and the information provided can assist in the automatic resolution of two classes of conflicts ordering conflicts and semantic conflicts.
the former can be resolved independently of the language and the latter using specific conflict handlers.
we have been developing a tool that supports semistructured merge and conducted an empirical study on software projects developed in java c and python comprising merge scenarios.
we found that semistructured merge reduces the number of conflicts in of the sample merge scenarios by on average compared to unstructured merge.
we found also that renaming is challenging in that it can increase the number of conflicts during semistructured merge and that a combination of unstructured and semistructured merge is a pragmatic way to go.
categories and subject descriptors d. .
distribution maintenance and enhancement version control d. .
management software configuration management general terms management measurement experimentation keywords revision control version control software merging semistructured merge fstm erge feature house permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.
.
introduction revision control systems a.k.a.
version control systems have a long tradition in software engineering and are a major means for managing revisions and variants of today s software systems .
a programmer creates a revision of a software system by deriving it from the base system or from another revision a revision can be developed and evolve in isolation and it can be merged again with the base system or another revision.
a major problem of revision control is how to resolve merge conflicts that are caused by concurrent changes e.g.
when two developers independently change the same method .
zimmermann found in an empirical study of four large projects that to of all merge scenarios exhibit conflicts .
in recent years two classes of revision control systems have emerged revision control systems that operate on plain text and revision control systems that operate on more abstract and structured document representations.
the first class is being used widely in practice because such systems are typically languageindependent.
popular systems of this class are cvs subversion and git.
henceforth we call them unstructured revision control systems .
a problem of unstructured revision control systems is that when conflicts occur no knowledge of the structure of the underlying software artifacts is available.
this makes it difficult to resolve certain kinds of conflicts as we will illustrate.
the second class of revision control systems is explored mainly in academia with the goal of solving the conflict resolution problems of unstructured revision control systems .
the idea is to use the structure and semantics of the software artifacts being processed to resolve merge conflicts automatically .
these systems operate on abstract syntax trees or similar representations rather than on plain program text and incorporate all kinds of information on the underlying language.
a drawback is that relying on a particular language s syntax or semantics they sacrifice language independence.
henceforth we call them structured revision control systems .
there is a trade off between generality and expressiveness of revision control systems .
a revision control system is general if it works with many different kinds of software artifacts.
it is expressive if it is able to handle many merge conflicts automatically.
inspired by this trade off we propose a new class of revision control systems called semistructured revision control systems which inherit the strengths but not the weaknesses of unstructured and structured revision control systems.
the idea is to increase the amount of information that a revision control system has at its disposal to resolve conflicts while maintaining generality by supporting many languages.
in particular we concentrate on the merge process so we speak of semistructured merge .
we developed a generic engine called fstm erge that merges different revisions of a software system based on the structure ofthe software artifacts involved.
users can plug a new language intofstm erge by providing a declarative specification of their language s syntax i.e.
a grammar enriched with information for conflict resolution.
while this approach is not entirely languageindependent it is still quite general.
first it enables to resolve conflicts that are caused by differing orderings of program elements independently of the language.
second it allows the user to plug in dedicated conflict handlers in order to define further possibly language dependent resolution strategies.
if for whatever reason there is no grammar available for a certain language fstm erge can use a fallback solution to parse software artifacts line by line which makes it equivalent to the unstructured approach.
overall we make the following contributions based on an analysis of the trade off between generality and expressiveness we propose the concept of semistructured merge which combines the strengths of unstructured and structured merge.
it is able to resolve ordering conflicts independently of the language and it can be extended by conflict resolution handlers to define additional language dependent conflict resolution strategies.
we provide the tool fstm erge for semistructured merge as an extension of the feature house tool infrastructure for software composition .
by using fstm erge on artifacts written in java c and python we demonstrate its applicability and generality.
we report on an empirical study on software projects to quantify the benefits of semistructured merge and to identify open issues.
in a nutshell we found that semistructured merge can reduce the number of conflicts in of the sample merge scenarios by .1furthermore our study reveals that renaming is a challenge for semistructured merge that can increase the number of conflicts in of the sample merge scenarios by which we discuss.
a combination of unstructured and semistructured merge reduces the number of conflicts in our study by compared to pure unstructured merge.
the latter three contributions are novel compared to an earlier workshop paper .
the key contribution is the empirical study whose goal has been to explore how far we can get with an approach that is centered around ordering conflicts and conflict handlers the results are encouraging as we will discuss.
the prototypical tool fstm erge is under ongoing development in particular it was a means to conduct the study.
.
background and related work there is a large body of work on revision control systems and conflict resolution in software merging .
the purpose of a revision control system is to manage different revisions of a software system.
usually revisions are derived from a base program or from other revisions.
users can check out revisions from the repository make asynchronous changes and check them in again.
by branching the main development line or trunk a programmer can create independent revisions which can be changed and evolve independently e.g.
to add and test new features .
independent revisions can be merged back with the base program or with other revisions which may have been changed in the meantime.
the key issue we address in our work is merge conflict resolution .
conflicts may occur while merging independent changes.
a major goal of research on this problem is to empower revision control systems to resolve merge conflicts automatically that is to reduce 1we write m sas an abbreviation for the mean value mof a data set and its standard deviation s.the number of conflicts that otherwise have to be resolved manually by the user .
first we illustrate the problem of conflict resolution in unstructured merge.
then we illustrate the ability of structured merge to resolve conflicts better than unstructured merge.
.
unstructured merge to illustrate the conflict resolution problem we use the running example of a simple stack implementation as shown in figure top .
henceforth we call this program the base program or simply stack .
it contains a class stack that implements interface cloneable and that contains a field items and the two methods push andpop.
now suppose a programmer would like to add a new method top tostack but would like to develop this feature in its own branch independently of the main branch i.e.
the base program .
to this end the programmer creates a branch with a new revision top.
furthermore suppose another programmer adds subsequently a method sizedirectly to the main branch by creating revision size of the base program.
figure middle presents code for the two revisions each of which adds a new method to class stack .
finally suppose that at some point in time the two branches are merged again to combine both revisions including the new methods.
merging the two branches involves merging the two revisions topandsize solid arrows on the basis of the common ancestor the base program stack dashed arrow .
this process is called a three way merge because it involves three revisions .
in our example the merge process reports a conflict that cannot be resolved automatically with unstructured merge.
figure bottom contains the output of the merge tool of cvs for this example.
the output shows that the tool is not able to merge the two new methods topand size such that both can be present in the merged program because it cannot determine the desired order of both methods.
similar conflicts are reported by the merge tools of subversion and git the user has to merge the revisions manually.
this example is very simple but it suffices to illustrate the problems of unstructured merge.
an unstructured merge tool operates solely on the basis of text lines or tokens.
it identifies new text fragments with regard to the common ancestor base program and stores the common fragments before and after the new fragments.
if the two revisions change or extend text in the same region the system reports a conflict.
that is it is not able to decide how to merge the changes or extensions.
in our example the merge tool knows that two independent text fragments which actually implement the two methods topandsize are added to the same location of the base program which is enclosed by the two fragments that implement the methods push andpop .
the problem is that the unstructured merge tool does not know that these fragments are java methods and that a merge of the two is actually straightforward because their order within their enclosing class can be permuted safely.
if the tool knew this it would be able to resolve the conflict automatically.
there are actually two solutions include method topfirst and then method size or vice versa.
.
structured merge in the past many tools have been proposed that leverage information on the artifact language to resolve as many conflicts as possible .
westfechtel and buffenbarger pioneered this field by proposing tools that incorporate structural information such as the context free and context sensitive syntax in the merge process .
researchers proposed a wide variety of structural comparison and merge tools including tools specific to java and c .
some tools even consult additionally semantic information of the language .
let us illustrate the abilities of structured merge by a further ex base program s tack 1import java.util.linkedlist 2public class stack t implements cloneable private linkedlist t items new linkedlist t public void push t item items.addfirst item public t pop if items.size return items.removefirst else return null revision t op 1import java.util.linkedlist 2public class stack t implements cloneable private linkedlist t items new linkedlist t public void push t item items.addfirst item public t top return items.getfirst public t pop if items.size return items.removefirst else return null revision s ize 1import java.util.linkedlist 2public class stack t implements cloneable private linkedlist t items new linkedlist t public void push t item items.addfirst item public int size return items.size public t pop if items.size return items.removefirst else return null mergeunstructured top stack size 1import java.util.linkedlist 2public class stack t implements cloneable private linkedlist t items new linkedlist t public void push t item items.addfirst item top stack.java public t top return items.getfirst public int size return items.size size stack.java public t pop if items.size return items.removefirst else return null branch merge figure merging the revisions s izeand t opwith unstructured merge ample in figure .
suppose we have the base stack implementation and we create two independent revisions one that enables stack objects to be serialized revision serializable and another that allows programmers to flush the elements of the stack to a data stream revision flushable .
figure depicts excerpts of the revisions.
merging the two revisions with the base program using unstructured merge causes two conflicts.
first the system is not able to merge the two new import statements and second it is not able to merge the implements clauses of the two revisions.
figure bottom shows the conflicts as reported by the merge tool of cvs.base program s tack 1import java.util.linkedlist 2public class stack t implements cloneable ... revision s erializable 1import java.util.linkedlist 2import java.io.serializable 3public class stack t implements cloneable serializable private static final long serialversionuid ... revision f lushable 1import java.util.linkedlist 2import java.io.flushable 3public class stack t implements cloneable flushable ... public void flush ... mergeunstructured serializable stack flushable 1import java.util.linkedlist serializable stack.java 3import java.io.serializable 5import java.io.flushable flushable stack.java serializable stack.java 8public class stack t implements cloneable serializable private static final long serialversionuid 11public class stack t implements cloneable flushable flushable stack.java private linkedlist t items new linkedlist t public void push t item items.addfirst item public t pop if items.size return items.removefirst else return null public void flush ... branch merge figure merging the independently developed revisions flushable and s erializable with unstructured merge in contrast a structured revision control system that knows that the base program and the revisions are written in java is able to resolve such conflicts automatically.
it knows that the order of imports does not matter and that in this case implements clauses can be combined by union.
beside the types of conflicts we have seen so far there are other types of conflicts that can be resolved by structured revision control systems on the basis of language specific knowledge.
for example aforloop in java consists of a head and a body and the head consists of three parts.
this information is useful when two revisions modify disjoint parts of the head.
even if a structured merge cannot merge a conflict automatically it may have information that assists the programmer in resolving the conflict e.g.
even if the heads of two forloops cannot be merged a structured merge tool knows that the conflict occurs in a loop head and not in an arbitrary line of text .
.
generality vs. expressiveness the previous discussion reveals that there is a trade off between generality and expressiveness of revision control systems as has been observed before .
unstructured revision control systems are very general.
they can be used with every kind of textual software artifact but they are not able to resolve conflicts that requireknowledge on the language of the artifacts involved.
in contrast a structured revision control system is typically tailored to a particular language.
so it would be possible to build a revision control system for java that can resolve the conflicts we have discussed so far and in addition many other conflicts.
however such a system would be less useful in a setting in which a software system consists of artifacts written in many different languages e.g.
java jsp python sql and ant in a web application .
this trade off motivates us to explore the space between unstructured and structured revision control systems.
can we design a system that is able to handle a wide variety of software artifacts and that has enough information on these artifacts to resolve a reasonable number of conflicts automatically?
a trivial solution would be to develop one structured revision control system for every artifact type that occurs in a software project respectively.
a problem with this naive approach is that it is very tedious and error prone.
moreover in many cases not all artifact types can be anticipated.
.
finding a balance previous attempts to find a proper balance between structured and unstructured merge have some limitations.
niu et al.
have proposed a merge approach that is both structured and independent of the language .
they represent programs as graphs and use graph morphisms to capture the relationships between the structural elements of the programs to be merged.
the focus on graph structures instead of on tree structures is the biggest difference to our approach.
the question of the scalability of graph based algorithms may be raised as general graph algorithms are usually more complex than tree algorithms.
niu et al.
tested their approach only using a single c program of moderate size.
it is not clear how their tool performs on larger programs and how difficult it is to provide support for new languages.
the approach of dig et al.
assumes a setting in which refactorings of the documents under revision control are recorded and replayed on demand .
that is their approach is not applicable to scenarios in which this additional information is not available which appears to be the rule rather than the exception in practice.
other approaches require that the documents to be merged come with a formal semantics which is not always feasible in practice because even for mainstream languages such as c there is no formal semantics available.
we explore whether we can reduce the number of conflicts without these limitations.
.
semistructured merge .
overview program structure trees.
the basic idea of semistructured revision control systems is to represent software artifacts as trees and to provide information on how the nodes of a certain type e.g.
methods or classes and their subtrees are merged.
we call such a tree which is essentially a parse tree a program structure tree orfeature structure tree .
in figure a we show a simplified program structure tree of the base program stack and in figures b and c simplified program structure trees of revisions topandsize.
it is important to note that not all structural information is represented in the tree.
for example there are no nodes that represent statements or expressions.
but this information is not lost it is contained as plain text in the leaves not shown .
so a program structure tree is not necessarily a full parse tree it abstracts from some details and contains them as text.
in our setting the order of child nodes of a common parent is arbitrary.
that is it may change without affecting the program semantics.
this is a key items push popstack t stack items push popstack t stack sizeitems push top popstack t stack items push top popstack t stack size b d a c figure revisions of the stack example as program structure trees property when resolving conflicts that rely on the element order as we will explain shortly.
the choice of which kind of structural element is represented by a distinct node depends on the expressiveness which we want to attain with semistructured merge.
let us explain this choice by means of the stack example.
taking the three program structure trees as input a merge tool can produce the desired output without conflict only by superimposing the trees as shown in figure d .2why does this algorithm work?
it works because the order of method declarations in java does not matter so superimposing the trees just adds the two new methods topandsize in any possible order.
if the two revisions added methods with identical signatures the tool would have to merge the statements of their bodies.
this would be more difficult since their order matters and statements do not have unique names .
even with all the knowledge on the java language at our disposal there remain cases in which we cannot say how to merge sequences of statements.
this is the reason why we choose to represent methods as opaque leaves and their statements as text content in other languages we may choose a different granularity.
conflict types.
the ability of semistructured merge to resolve certain conflicts is based on the observation that the order of certain elements e.g.
of classes interfaces methods fields imports and so on does not matter.
we call such conflicts ordering conflicts .
a merge algorithm that resolves just ordering conflicts automatically is defined more simply than a fully structured merge.
a semistructured merge uses an abstraction of the structure of the document which provides just enough information to identify ordered items.
furthermore in the example of figure we see that unstructured merge is not able to combine the differing implements clauses of two revisions of a class.
with semistructured and structured merge we are able to achieve this because we know that lists of types can be unified in this case .
the routine that resolves conflicts of a special kind is called a conflict handler .
to distinguish conflicts for which we use special conflict handlers from the conflicts that occur due to ordering issues we call the former semantic conflicts and the latter as before ordering conflicts.
we do not claim that it is possible to define a conflict handler for every case.
however at least a conflict handler can assist the developer in identifying and resolving conflicts.
but what do we do with program elements which we do not 2superimposition merges trees recursively beginning from the root based on structural and nominal similarities .
fstnonterminal name type 2classdecl class type impllist fielddecl classconstr methoddecl fstterminal name impl merge implunion 6impllist implements type type fstterminal name id params merge linebasedmerge 8methoddeclaration type id params ?
statement ... figure an excerpt of a simplified java grammar with annotations know how to merge such as method bodies with statements?
the answer is simple we represent the elements as plain text and use conventional unstructured merge.
that is if a conflict occurs inside a method body we do not attempt to resolve it automatically much like in unstructured merge.
note that superimposition alone is not sufficient to implement semistructured merge because revisions may remove program elements.
for example one or both revisions of stack may remove method push .
the result should be a stack without this method.
to this end the merge algorithm has to check whether one or both revisions remove elements and so on.
in our tool we implemented a set of standard rules for removing elements following rcs s merge whose description we omit here because they do not add anything to the discussion.
.
system architecture and annotations our system consists of two parts a generic engine that knows how to identify and resolve certain conflicts and a small abstract specification for each artifact language of the program s or document s elements whose order does not matter or for which special conflict handlers are available.
the abstract specification of a document structure is given by an annotated grammar of the language.
most of the work is done by the generic merge engine using the grammar as a guide.
this architecture makes it relatively easy to include new languages by providing proper abstract specifications compared to implementing a complete structured merge tool from scratch.
to illustrate the role of annotations consider the excerpt of a simplified java grammar in figure .
it contains a set of production rules.
for example rule classdecl defines the structure of classes containing fields fielddecl constructors classconstr and methods methoddecl .
production rules may be annotated with fstnonterminal and fstterminal .
the former annotation defines that elements corresponding to the rule are represented as nodes in the corresponding program structure tree there may be subnodes and the order of elements or nodes is arbitrary.
in our example we annotate the rule for class declarations with fstnonterminal because classes may contain further classes methods and so on and the order of classes in a file or package may vary.
the annotation parametername is used to assign a name to the corresponding node in the program structure tree.
annotation fstterminal is like annotation fstnonterminal except that subelements are represented as plain text and that the developer can decide how code corresponding to the element in question is merged.
for example we annotate the rule for method declarations with fstterminal to represent their inner statements by plain text as explained before.
annotation parameter merge defines that the method s content is merged by a classic line based merge algorithm as used in unstructured merge.
a further interesting example is the rule for describing the syntax of implements lists fig.
lines .
this rule is annotated with1public class implunion public final static string handler implunion public static void compose fstterminal a fstterminal b fstterminal comp fstnonterminal parent string ifca a.getbody string ifcb b.getbody string ifccomp ifcb ifca ... figure an excerpt of a conflict handler for merging implements lists in java fstterminal so the subelements i.e.
list of type names are represented as plain text.
but in contrast to method declarations we state that implements lists are merged by a special conflict handler that combines them by union merge implunion .
this conflict handler is specific to java s implements list and provided as a plugin forfstm erge viafeature house s plugin mechanism .
in figure we show an excerpt of a possible implementation in our tool.
note that the name of the handler defined in constant handler line matches the name of the selected handler in the annotated grammar fig.
line .
the example of figure illustrates the simplicity of defining conflict handlers.
it is important to note that conflict handlers are not always language independent but optional if not provided unstructured merge is used .
conflict handlers can be used not only to resolve conflicts but also to provide structured and languagespecific information on the kind of conflict and potential conflict resolution strategies in the case a conflict cannot be resolved automatically using the information available.
for example we could use a conflict handler to specify how the parts of a forloop head are merged and if this is not possible to provide information on the kind and cause of the conflict.
.
balancing generality and expressiveness semistructured merge is a combination of unstructured merge and structured merge.
elements whose order is arbitrary are represented by nodes and can be merged by superimposition.
elements whose order is not arbitrary are represented by text and merged either by unstructured merge or by special conflict handlers.
that is we have a choice per language of which elements are to be represented by nodes and which by text and which elements are treated by conflict handlers.
with a coarse granularity we have simple program structure trees e.g.
with java classes as leaves but cannot resolve conflicts at the method level.
that is the expressiveness of the merge algorithm is limited.
a finer granularity leads to more complex trees e.g.
with java fields and methods as leaves but also allows a merge tool to resolve ordering conflicts automatically or via conflict handlers .
the result is a higher expressiveness of the merge algorithm.
as we have illustrated an annotated grammar contains sufficient information to guide a revision control system in merging java artifacts.
but how does this approach facilitate generality?
indeed for a language to be supported we need some information in the form of an annotated grammar and if desired special conflict handlers so the tool is not entirely language independent.
but for many languages such a grammar is easily provided since standard grammars in backus naur form are available on the web for many languages and adding annotations is a matter of hours at most.
also implementing special conflict handlers in the form of java code is a matter of hours e.g.
for concatenating implements lists a few lines of java code are sufficient .
.
summary to summarize semistructured merge is more expressive than unstructured merge since certain conflicts can be resolved automatically based on information on the underlying languages.
and semistructured merge is more general than structured merge since a wide variety of languages can be supported on the basis of an annotated grammar which needs to be provided only once per language.
if for whatever reason no information on a given language is available semistructured merge behaves exactly like unstructured merge parsing the corresponding software artifact line by line.
.
implementation to demonstrate the feasibility of our approach we implemented a semistructured merge tool and used it to merge artifacts written in java c and python.
.
generic merge engine we have implemented a first prototype of a semistructured merge tool called fstm erge which is able to resolve ordering conflicts and which can be extended with special conflict handlers.
fstm erge and the sample programs of our empirical study are publicly available on the project s web site.
fstm erge takes advantage of the existing tool infrastructure feature house as illustrated in figure .
the tool fstgenerator generates almost all code that is necessary for the integration of a new language into fstm erge .fstg enerator expects the grammar of the language in a specific format called feature bnf of which we have already shown an example in figure .
we have extended fstg enerator andfeature bnf to support annotations relevant to semistructured merge.
using a grammar written in feature bnf fstg enerator generates an ll k parser that produces program structure trees and a corresponding pretty printer both of which are then integrated intofstm erge .
furthermore developers have the opportunity to plug in special conflict handlers and to activate them in the grammar using annotation parameter merge .
after the generation step fstm erge proceeds as follows the generated parser takes the base program and two revisions written in the target language and produces a program structure tree for each program fstm erge performs the semistructured merge as explained before the trees are superimposed deletions are handled separately and special conflict handlers or a conventional unstructured merge are applied to the leaves the generated pretty printer writes the merged revisions to disk.
generatorc java ... c haskell javacc python special conflict handlers and line based mergemerge parser and revisionsbase program structure tree revisionsmergedpretty printer fstmergefstgeneratorfeaturebnf structure treesprogram program figure the architecture of f eature house language plugins we have tested fstm erge with three languages java c and python.
all three languages are common in projects that use revision control systems and all are sufficiently complex and different from each other to demonstrate the practicality and generality of our approach.
as a basis we used publicly available grammars that we adapted and annotated for our purposes.
beside technical problems with the python grammar the python grammar relies on indentation plugging the three languages into feature house andfstm erge was easy.
annotating and testing them was a matter of a few hours.
furthermore we implemented special conflict handlers for merging implements extends and throws lists and for modifiers mainly for displaying information on the conflicts.
typically the implementation of a conflict handler requires only a few lines of well separated java code and follows the pattern of the handler shown in figure .
.
empirical study to quantify the benefits of our approach and to discover open issues we conducted an empirical study on merging and conflict resolution in a number of software projects.
.
motivation methodology due to our experience with feature house in software productline engineering we expect that integrating further languages is easy.
the interesting issue is whether in its current form semistructured merge can play to its strengths in real software projects.
the point is that concentrating on ordering and certain semantic conflicts is a fairly simple approach.
by means of examples we have demonstrated that semistructured merge is able to resolve conflicts that cannot be resolved with unstructured merge.
but how frequently do such conflicts occur in real software projects?
how far can we get with such a simple approach?
hypothesis many of the conflicts that occur in merging revisions are ordering conflicts which can be resolved automatically with semistructured merge.
an additional fraction of conflicts can be resolved with conflict handlers.
although there is some evidence that revisions often involve additions of larger structures such as entire functions we need a substantial set of data to answer the question systematically.
to this end we used both semistructured merge and unstructured merge in a number of merge scenarios and compared the resulting numbers of conflicts lines of conflicting code and conflicting files.
unfortunately we could not compare semistructured merge with structured merge because there are simply no practical tools available least of all for java c and python.4also we could not compare our approach with tools that build on formal semantics or on refactoring replaying because our approach aims at a broader scenario in which this information is not available.
beside the quantitative analysis we looked at selected samples of merged code in order to learn about the influence of the merge approach on the resulting code structure.
we found a number of differences that may have an impact on code comprehension which we discuss in section .
.
4we are aware only of the academic prototypes for c of westfechtel and buffenbarger .
these tools are not able to resolve ordering conflicts personal communication with westfechtel .
.
sample projects criteria.
an important issue is how to select merge and conflict scenarios in a comparison of semistructured and unstructured merge.
developing our own case study would leave too much room for bias.
using only one or two scenarios would threaten external validity i.e.
we would not be able to generalize our findings .
thus we decided to base our study on a substantial number of opensource projects developed by practitioners for real applications.
we explored sourceforge a popular open source software portal for candidates.
we had two criteria the projects must be of reasonable but varying sizes and either semistructured merge or unstructured merge must produce at least one conflict.
to this end we analyzed the revision history of the candidates including logs for real and realistic merges which we call henceforth merge scenarios .
technically we used subversion to browse the revision histories and to check out revisions.
in principle we could have used any other state of the art revision control system but we were most familiar with subversion.
identifying merge scenarios.
we have been considering two kinds of merge scenarios merges that have actually been performed in the revision history of a project and merges that are realistic considering the history of a project.
based on the logs we were able to extract information on merges that actually have been performed by the developers and to obtain the revisions involved.
since subversion has no standard log entry type for merges 5we used comments of the developers that point clearly to merges.
beside merges that actually happened we searched for merges that could have been performed the logs are not clear about this or that are realistic considering the revision history to increase the sample size.
one kind of indicator is a sequence of multiple alternating changes in different branches e.g.
trunk !branch!
trunk .
this pattern indicates concurrent development and points to potential conflict scenarios as long as the changes in different branches are not identical .
a second indication is that developers evolve only a single branch in many revisions.
merging the branch back to the trunk is a classic scenario in revision control e.g.
to merge new features that have been added and tested in a separate branch with the trunk and is likely to produce conflicts when the trunk has changed in between typically the more changes the more conflicts .
technically a merge scenario is a triple consisting of a base revision a left branch and a right branch.
the base revision marks the point in time in which the left or right branch was copied from the other.
this way we ensure that both branches have a common ancestor which is necessary for a three way merge.
furthermore we check the two independently evolved branches out at the same point in the revision history which is a prerequisite for merging them in practice.
in table we list information on the sample projects including name domain number of lines of code number of merge scenarios and programming language.
since java is widely used we were able to locate ten projects with ten conflict scenarios each.
for c and python we located fewer candidates with fewer conflict scenarios.
overall our sample consists of projects with in summary merge scenarios comprising summed over all scenarios million lines of code.
all merge scenarios are available and documented on the project s web site.
5this entry type is available since version .
but all sample projects use earlier versions or did not take full advantage of this feature.project domain loc ms lang.
autowikibrowser semi autom.
wikipedia editor k c bitpim mobile phone synchronization k python cruisecontrol.net continuous integration server k c drjava development environment k java emesene instant messaging client k python eraser secure data removal tool k c exe elearning xhtml editor k python freecol turn based strategy game k java fireirc irc client k c genealogyj editor for genealogic data k java ifolder directory synchronization k c itext pdf library k java jabref bibtex entry manager k java jedit programmer s text editor k java jfreechart chart library k java jmol viewer for chemical structures k java matplotlib plotting library k python nasa worldwind virtual globe k c pmd bug finder k java process hacker process viewer k c rss bandit news feeds reader k c spambayes bayesian anti spam classifier k python squirrelsql graphical sql client k java wicd network manager for linux k python table overview of the sample projects all available on loc lines of code ms number of merge scenarios.
.
results in table we depict the results of our analysis in terms of the numbers of conflicts conflicting lines of code conflicting files and semantic conflicts.
for the purpose of the study we defined conflict handlers for structural elements of java c and python implements lists modifiers and so on .
typically the handlers are very simple and only flag a semantic conflict.
so we did not implement specific resolution strategies but we just counted situations in which they can be applied which is sufficient for the quantitative analysis.
details on the conflict handlers are available on the project s web site.
due to the sheer amount of data we provide for each project mean values over all merge scenarios.
detailed information on each merge scenario including the number of conflicts conflicting lines of code conflicting files and semantic conflicts per file and per merge scenario in the form of tables and diagrams are available on the project s web site.
based on the results we classify the projects into two categories according to which numbers are reduced by semistructured merge compared to unstructured merge .the number of conflicts conflicting lines of code and conflicting files are reduced or on the same order of magnitude.
.the number of conflicts or conflicting lines is significantly increased highlighted in tab.
but other numbers are reduced.
we have highlighted projects that fall into the second category with a gray background in table .
compared to unstructured merge semistructured merge including conflict handlers can reduce the number of conflicts in of the sample merge scenarios by the number of conflicting lines of code is reduced in of the sample merge scenarios by the number of conflicting files is reduced in of the sample merge scenarios by .
remarkably in of of the sample merge scenar conflicts confl.
loc confl.
files sem.
confl.
project um sm um sm um sm um sm autowikibrowser bitpim cruisecontrol.net drjava emesene eraser exe fireirc irc client freecol genealogyj ifolder itext jabref jedit jfreechart jmol matplotlib nasa worldwind pmd process hacker rss bandit spambayes squirrelsql wicd table mean conflicts per scenario numbers of conflicts conflicting lines of code conflicting files and semantic conflicts for semistructured merge sm and unstructured merge um .
ios semistructured merge increases the number of conflicts by .
we found this result counter intuitive at first why should additional information incur additional conflicts?
in section .
we explain that renaming is the reason for the increased number of conflicts and conflicting lines of code in the projects of the second category.
to present more than just the mean values and to explore the reasons for the differences of the individual projects we had a closer look at some representatives.
in figure we display the numbers of conflicts and conflicting lines of code of all merge scenarios of cruisecontrol.net first category .6the numbers show that semistructured merge can play to its strengths in cruisecontrol.net the same applies to other projects of our sample all projects without gray cells in table .
in figure we display the numbers of nasa worldwind second category .
interestingly semistructured merge produces more conflicts than unstructured merge which we did not expect initially.
however the number of conflicting lines of code is reduced significantly.
this is similar for all projects in which the number of conflicts is increased.
in section .
we discuss reasons for the diverging numbers.
finally we were surprised that the numbers of semantic conflicts are rather low compared to the numbers of ordering conflicts especially when considering the quite high number of elements that we handle with special conflict handlers.
a notable difference is itext which we discuss in section .
.
6the name of a merge scenario is composed of the revision number of the base revision and the revision number of the left and right branch which are equal as explained in sec.
.
.
for example rev0815 denotes a merge of the left and right branch of revision based on the base revision .
figure results for cruisecontrol.net first category figure results for nasa worldwind second category .
discussion we found many scenarios in which semistructured merge is superior to unstructured merge in that it reduces the number of conflicts conflicting lines of code and conflicting files.
so we can confirm our hypothesis many of the conflicts that occur in merging revisions are ordering conflicts which can be resolved automatically with semistructured merge.
we also found that an additional fraction of conflicts can be potentially resolved with language specific conflict handlers.
nevertheless the fact that in some cases semistructured merge increases the number of conflicts or conflicting lines of code surprised us.
we had expected semistructured merge to be at least as good as unstructured merge.
to address this issue and to learn more about the nature of semistructured merge we reviewed the merged revisions of all projects manually.
next we provide a summary of our findings.
renaming.
an analysis of the projects of the second category revealed that renaming poses a challenge for semistructured merge.
the point is that semistructured merge uses superimposition to merge revisions.
if a program element is renamed in one revision in one of the branches the merge algorithm is not aware of this fact and cannot map the renamed element to its previous version.
this results in a situation in which we have in one branch an empty or non existent element.
in figure we illustrate a situation in which semistructured merge produces more conflicts and conflicting lines than unstructured merge.
in the base revision we have a simple stack.
in revision some change method push ofstack has been changed.
in revision renaming class stack has been renamed to renamedstack .
unstructured merge does not produce any conflicts because the changes to the method and the class name are located in different lines.
semistructured merge identifies merge partners by name so it treats class stack and class renamedstack as distinct elements.
the result of semistructured merge is shown at the bottom of in figure .
it contains a conflict comprising four lines of code.
the worst case is that a directory is renamed instead of a class as in the stack example.
this happened for instance in pmd and jmol.
in these cases unstructured merge reports for each file of the directory a large conflict because it cannot map the files of the renamed directory to the corresponding files of the other branch and uses empty files instead.
the same happens in semistructured merge except that the conflicts are not reported per file but per method or constructor in the file.
this results in more conflicts but the overall number of conflicting lines is smaller than in unstructured merge.
the reason is that unstructured merge flags entire files as conflicts and semistructured merge only individual structural elements such as methods.
we discuss how to handle renaming better in section .
.
semantic conflicts.
we did not find many semantic conflicts compared to other conflicts.
an exception is itext.
examining itext s source code we found that at some point the developers switched from java .
to java .
.
this transition involved renaming a large number of raw types to generic types e.g.
from linkedlist tolinkedlist string .
thus the cause for the exceptionally high number of semantics conflicts is again a form of renaming.
structural boundaries.
an observation we made when examining the results of unstructured and semistructured merge is that semistructured merge due to its structure driven and fine grained nature leads always to conflicts that respect boundaries of classes methods and other structural elements.
this is not the case for unstructured merge.
we found that respecting structural boundariesbase program s tack 1public class stack t public void push t item items.addfirst item revision s ome change 1public class stack t public void push t item intcount items.addfirst item revision r enaming 1public class renamedstack t public void push t item items.addfirst item mergesemistructured some change stack renaming 1public class renamedstack t public void push t item items.addfirst item 6class stack t somechange stack.java public void push t item intcount items.addfirst item renamed stack.java branch merge figure semistructured merge in the presence of renaming i.e.
aligning the merge with the program structure is beneficial because this way we could understand conflicts in terms of the underlying structure even though this may result in more conflicts e.g.
one per method instead of one per file .
automation.
a goal of research on software merging is to minimize the number of conflicts that require manual intervention to be resolved .
however an automatic resolution of conflicts has to be taken with a grain of salt.
for example if two developers add independently two methods that are intended to be the same but the conflict resolution recognizes them as different this mismatch goes unnoticed.
this can happen in unstructured structured and semistructured merge.
it is desirable to minimize the amount of manual intervention but it is useful to keep information on conflict resolutions.
semistructured merge has benefits in this regard as it knows about the structural elements involved not only about text.
.
threats to validity construct validity.
although the output of semistructured merge in the presence of renaming is not satisfactory cf.
fig.
it still allows us to detect conflicts properly and to incorporate them in our data.
a threat to construct validity is that the number of conflicting lines of code may be estimated too low because the renamed element is not considered cf.
fig.
.
however after code inspection we found that this fact is negligible for our conclusions.
internal validity.
a threat to internal validity is that the results we obtained are influenced by hidden variables other than the kindof merge which is the independent variable .
due to the simplicity of our setting we can largely rule out such confounding variables.
we applied semistructured and unstructured merge to the same set of merge scenarios and counted the number of conflicts subsequently on the merged code.
furthermore we used a comparatively large sample projects merge scenarios million lines of code to rule out confounding variables such as programming experience programming style and the difference between domains.
a potential threat to internal and external validity is our approach of selecting conflict scenarios.
the problem is that none of the projects we found contains explicit information on merges in its logs.
so we had to search the logs for comments that indicate merge scenarios such comments are fortunately quite common .
to increase the number of conflict scenarios we considered further merge scenarios based on a number of patterns in the revision hierarchy e.g.
small alternating changes in two independent branches or branches that end abruptly see section .
.
overall we are confident that the conflict scenarios we selected reflect a broad spectrum of the current practice in revision control due to the large sample and thus our results are reliable in this respect.
one can speculate about the influence of the merge approach on patterns of concurrent development.
developers may avoid certain programming and change patterns in order not to run into conflicts when using unstructured merge.
the availability of semistructured merge may influence developers in the choice of their patterns because more conflicts can be resolved.
even though a comprehensive analysis of code quality is well beyond the scope of the paper a look at samples of merged code made us confident that the resulting code structure of semistructured merge can aid code comprehension as the merge process follows the structural boundaries of the artifacts involved.
however a series of controlled experiments is necessary to provide a definite answer to this question.
external validity.
a common issue is to what extent the external validity of our study relies on the selection of samples.
can we generalize to other projects in other domain and written in other languages?
to increase external validity we collected a substantial number of projects and merge scenarios written in different languages and of different domains.
this does not guarantee that we will arrive at the same picture in other projects domains and languages but we are confident that we have covered a broad spectrum of merge scenarios.
.
open issues perspectives we see some interesting open issues.
a first issue is the role of refactoring.
so far we have not addressed changes such as the renaming of methods or classes systematically.
we found that renaming can increase the number of conflicts substantially compared to unstructured merge.
the reason is that superimposition relies on nominal equality.
we see two ways of dealing with this problem.
first we could use unstructured merge instead of semistructured merge for files that contain renamings.
a merge tool can simply compare the numbers of conflicts produced by semistructured merge and by unstructured merge on a per file basis and choose the better alternative.
since merging is done in linear time the overhead should be acceptable.
for our sample the combination of unstructured and semistructured merge reduces the number of conflicts in sum by compared to pure unstructured merge and by compared to pure semistructured merge .
a merge in our setting takes about min but compared to the time for resolving conflicts manually the overhead for applying both kinds of merge can be safely neglected.additionally like in the approach of dig et al.
we could trace renamings and pass this information to the revision control subsystem.
this way pairs of corresponding elements can be matched even though they have different names and the conflict of figure can be resolved automatically.
this would further decrease the number of conflicts but is only applicable in specific scenarios.
beside renaming a further issue is that semistructured merge much like structured merge relies on structural information so the revisions must be syntactically correct.
whereas it is best practice to commit only correct programs or documents which has been confirmed by our study we found only one python project with a few problematic revisions this is not a strict requirement of today s unstructured revision control systems.
in such cases the artifacts involved have to be parsed as plain text such that semistructured merge behaves exactly like unstructured merge.
it is interesting to explore whether in such cases syntactically correct fragments can be represented by program structure trees and only the incorrect fragments as plain text.
in discussions at v amos some people asked how resolving ordering conflicts influences program comprehension.
the background is that in our approach the merge tool decides the order e.g.
of method declarations in a class .
an empirical assessment of this issue is well beyond the scope of this paper but an interesting avenue of further work.
however examinations of sample code make us believe that semistructured merge can aid program comprehension as it follows the structural boundaries of the artifacts involved in the merge process.
.
conclusion both unstructured and structured revision control systems have strengths and weaknesses.
the former are very general but cannot resolve certain kinds of conflicts.
the latter are typically tailored to specific languages and thus can resolve conflicts better than the former.
to reap the benefits of both worlds we propose semistructured merge.
developers provide information on the artifact languages declaratively in the form of annotated grammars as well as in the form of pluggable conflict handlers.
this way a wide variety of different languages can be supported while taking advantage of the information provided during the merge process.
we have implemented a tool for semistructured merge and plugged in support for java c and python.
in an empirical study we found that semistructured merge can substantially reduce the number and size of conflicts that occur during merges be it in terms of the number of conflicts the number of conflicting lines of code and the number of conflicting files .
we also found situations in which semistructured merge increases the number of conflicts or the number of conflicting lines of code.
but in every case either the number of conflicting lines of code or the number of conflicts decreases.
in the presence of renaming semistructured merge produces more but often smaller conflicts than unstructured merge.
in general semistructured merge is finer grained than unstructured merge and disallows conflicts across class or method boundaries.
interestingly a combination of unstructured and semistructured merge can reduce the number of conflicts further by compared to pure unstructured merge .
in the future we would like to explore whether it is possible to trace renaming and to use this information during the merge process.
.