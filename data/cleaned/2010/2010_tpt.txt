termination proofs from tests aditya v. nori microsoft research india adityan microsoft.comrahul sharma stanford university sharmar stanford.com abstract we show how a test suite for a sequential program can be profitably used to construct a termination proof.
in particular we describe an algorithm tpt for proving termination of a program based on information derived from testing it.
tpt iteratively calls two phases a an infer phase and b a validate phase.
in the infer phase machine learning in particular linear regression is used to efficiently compute a candidate loop bound for every loop in the program.
these loop bounds are verified for correctness by an off the shelf checker.
if a loop bound is invalid then the safety checker provides a test or a counterexample that is used to generate more data which is subsequently used by the next infer phase to compute better estimates for loop bounds.
on the other hand if all loop bounds are valid then we have a proof of termination.
we also describe a simple extension to our approach that allows us to infer polynomial loop bounds automatically.
we have evaluated tpt on two benchmark sets microbenchmarks obtained from recent literature on program termination and windows device drivers.
our results are promising on the micro benchmarks we show that tpt is able to prove termination on more benchmarks than any previously known technique and our evaluation on windows device drivers demonstrates tpt s ability to analyze and scale to real world applications.
categories and subject descriptors d. .
statistical methods general terms testing verification this author performed the work reported here during a summer internship at microsoft research india.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.keywords machine learning software model checking termination .
introduction proving termination of sequential programs is a hard and important problem whose solutions can broadly improve software reliability and programmer productivity.
there is a huge body of work that is based on a number of interesting techniques such as abstract interpretation bounds analysis ranking functions recurrence sets and transition invariants .
in spite of these techniques much progress has to be made to design an efficient and scalable technique for program termination.
in the world of safety checking there are a number of efficient and scalable techniques that use tests for proving safety properties of programs .
this is advantageous as most programs have test suites that ensure quality and more importantly these tests are a rich source of reachability information in other words information from tests gives reachability information for free without the need for any static analysis .
unfortunately there are no analogous techniques for proving termination or liveness properties of programs.
we ask the following question can a test suite for a program be used profitably for constructing termination proofs?
in this paper we answer this question in the affirmative and present an algorithm tpt that uses information from tests to construct a sound proof of termination of a program.
tpt is based on the insight that information from tests can be used to efficiently learn loop bounds for every loop in a program w. if every loop in whas a sound loop bound then this is a proof of termination of w. the algorithm iteratively calls two phases a an infer phase and b a validate phase.
in the infer phase machine learning in particular linear regression is used to efficiently compute a candidate loop bound for every loop in the program.
these loop bounds are verified for correctness by an off the shelf checker.
if a loop bound is invalid then the safety checker provides a test or a counterexample that is used to generate more data which is subsequently used by the next infer phase.
on the other hand if all loop bounds are valid then we have a proof of termination.
this separation of the infer phase from the validate phase allows our approach to handle more expressive syntax than previous approaches for termination of numerical programs.
being driven by tests also allows us to easily extend tpt to infer polynomial loop bounds automatically see section .
tpt is easy to implement.
in fact the infer phase of tpt is implemented by1g c d int x int y 3a s s u m e x y while x !
y if x y x x y if y x y y x return x figure computing gcd.
1g c d int x int y 3a s s u m e x y instrumented code 5a x b y c while x !
y instrumented code 8c c 9w r i t e l o g a b c x y if x y x x y if y x y y x return x figure instrumented gcd program.
just one line of matlab code while the validate phase is an off the shelf safety checker.
the contributions of this paper are as follows we describe tpt a novel termination prover for sequential programs that is based on information derived from tests.
this information is analyzed to automatically learn loop bounds.
we present an empirical evaluation of tpt on various benchmarks from recent papers on program termination and our results are encouraging.
on these benchmarks tpt is able to prove termination on more benchmarks than any previously known technique.
we also evaluate tpt on windows device drivers and the results are positive.
there are two drivers in this set of drivers for which tpt is able to successfully prove termination whereas the terminator tool fails.
this demonstrates tpt s ability to analyze and scale to real world applications.
the rest of the paper is organized as follows section informally illustrates the tpt algorithm with the help of a motivating example.
in section we review background material necessary for this paper.
section formally describes thetpt algorithm and section extends the algorithm to the non linear case.
section describes our experimental evaluation.
in section we discuss related work and finally section concludes the paper.
.
overview of the technique letl while bdosbe a loop defined over the variables x1 ... x n. our goal is to find an expression x1 ... x n defined over the initial values of the variables x1 ... x nsuch that the maximum number of iterations of lover all possible1g c d int x int y 3a s s u m e x y 4a x b y c while x !
y annotation 7f r e e invariant c a b x y annotation 9a s s e r t c a b c c if x y x x y if y x y y x return x figure annotated gcd program.
values of x1 ... x nis bounded above by x1 ... x n .
it is easy to see that such a bound x1 ... x n will imply termination of l. therefore for an arbitrary program a termination proof is a loop bound ifor every loop liin the program.
we will illustrate our technique on the gcdprogram shown in figure .
we also assume the availability of a test suite for this program.
this program has a loop lines which performs the greatest common divisor gcd computation.
our objective is to automatically compute an upper bound on the number of iterations of the loop over all inputs x yto the program by testing the program.
to collect data from these tests we instrument the program the instrumented gcd program is shown in figure .
the ghost variables variables aandb in line record the initial values of the variables xandyrespectively and are not modified by the loop.
the variable cis a loop counter which is initialized to zero in line .
the loop counter cis incremented in every iteration of the loop line .
the values of the variables a b c xandyare recorded at the beginning of the loop in line via the call to the function writelog .
the function writelog records the program state specifically the values of variables that are its arguments to a log file.
we want to bound the number of loop iterations cby a linear expression a b over the inputs aandb.
in particular we want to compute w1 w2 w3 r such that a b w1a w2b w3 and c a b .
next tpt executes the instrumented program over test inputs and accumulates the resulting data via calls to the logging function writelog .
using the log file tpt constructs two data matrices aandcdefined as follows in addition to the all ones column the first column the matrixacontains the test input values to the program in each row one row for every program state generated before executing the loop body and the matrix ccontains the corresponding value of the loop counter c. assume that we test the program on inputs x y .
as a result we have a 1ab 131c c the rows generated by each input have been partitioned.
each input generates as many rows as the number of iterations.
the problem of learning an upper bound on the loop counter ccan be looked upon as a linear regression problem in machine learning .
in linear regression we are given a set of input output pairs as input and the goal is to learn a function which maps the inputs to the outputs.
in our setting the inputs are the rows of a the outputs are the corresponding rows of c and we want to learn a function b that maps the rows of ato the rows of c. for our purpose we use a variant of linear regression to learn a bound on c. conventional linear regression aims to find w w1 w2 w3 such that c w1a w2b w3 cis a linear function of the parameters wwhich is why the regression is called linear .
this can be obtained by solving the following optimization problem min i w1ai w2bi w3 ci where ai bi is the ithrow of a and ciis the ithrow of c. since we want an upper bound on c we add additional constraints w1ai w2bi w3 ci for all i this results in the following quadratic programming problem min i w1ai w2bi w3 ci s.t.
aw c for the matrices aand cin equation w1 w2 w3 is a solution to this optimization problem.
thereforetpt returns a b a b as the candidate loop bound.
next in the validate phase we check whether a b is indeed a valid loop bound.
since the tests represent an underapproximation of program behaviors it is possible that there is a yet unseen test that executes the loop for more than a b iterations.
to handle this we annotate the program with an assertion encoding the soundness of this bound and check it using an off the shelf safety checker.
for our example the annotated program is shown in figure .
if the safety checker is able to verify the assertion of line then we have verified that the program terminates.
for proving soundness of the loop bound a safety checker will also need a loop invariant.
unfortunately these invariants can be quite hard to infer.
for our example the loop invariant is a bound on the loop counter cthat is a linear expression over the values of the program variables a b xand y. once again this is a linear regression problem.
using the log file generated by the instrumented program in figure on inputs x y we constructthe following matrices a 1abxy 13121 c c matrix ais the same as ain equation except that it also contains values for the program variables xandy.the problem of computing a loop invariant translates to the following linear regression problem find w w1 w2 w3 w4 w5 such that a b x y w1a w2b w3x w4y w5 and c a b x y .
thus we want to solve the following optimization problem min i w1ai w2bi w3xi w4yi ci s.t.
aw c this optimization problem is also a quadratic program which can be efficiently solved using an off the shelf solver.
for our example we obtain a b x y a b x y and thus c a b x yis the desired loop invariant.
once again since this invariant has been computed from an underapproximation of program behaviors it is just a candidate invariant and thus has to be checked for validity.
therefore this inferred invariant is marked as a free invariant in line of figure .
a free invariant is just a candidate invariant that can potentially be useful to the safety checker.
if the free invariant is invalid then the safety checker can simply ignore it.
on the other hand if the safety checker is able to prove that the free invariant is an invariant then it can use this candidate invariant to prove the assertion.
indeed in our experiments see section on all the benchmarks for which tpt is able to prove termination the free invariants were actual invariants.
however it is often the case that these candidate invariants had to be strengthened by our safety checker to make them inductive.
for the program in figure we observe that our safety checker uses the free invariant to obtain the following inductive invariant c a b x y x y this invariant is sufficient to prove the assertion of figure and therefore tpt is able to prove the termination of the gcdprogram in figure .
.
preliminaries w.l.o.g.
we consider while programs wwhich are defined by the following grammar w x ea w w ifebthen welse wfi while ebdow where xis a variable eais an arithmetic expression and ebis a boolean expression.
.
algebra amonomial x1 ... xn ris an expression of the form x1 ... x n xk1 1xk2 ...xknn.
the degree of amonomial xk1 1xk2 ...xknnis defined as n i 1ki.apolynomial f x1 ... xn ris a weighted sum of monomials f x1 ... x n kwkxk1 1xk2 ...xkn n kwk k where k xk1 1xk2 ...xknnis a monomial.
the degree of a polynomial is the maximum degree over its constituent monomials degree f def max k degree k wk leta rm nbe a matrix defined over the set of real numbers rwith mrows and ncolumns.
let x rndenote a vector .
the vector xcan also be represented as a row matrix xt r1 n where tis the matrix transpose operator.
in general the transpose of a matrix a denoted atis obtained by interchanging the rows and columns of a. in other words a rm n at ij aji.
given two matrices a rm pandb rp n their productabis a matrix c rm nwith each entry cijdefined as follows cij n k 1aikbkj the inner product x y of two vectors xand yis the product of the matrices corresponding to xtandywhich is defined as xty n i 1xiyi .
linear regression and quadratic programming given a matrix x rm nand a column vector y rm linear regression is the problem of learning a function fsuch that f xi yi where xiis the ithrow of xandyiis the ithrow of y. specifically the function fis a linear expression over model parameters rnsuch that for each i f xi x i and yi f xi .
in general such a function fmight not exist in which case linear regression aims to compute a function fsuch that f xi best approximates yi.
this approximation is formally characterized by the following optimization problem min i xt i yi in other words we would like to minimize a quadratic function of .
from an implementation point of view see section it is convenient to write equation in matrix notation as follows min1 2 txtx t xty consider the data points represented by shown in figure .
these data points correspond to rows of the matrixxin equation .
linear regression attempts to find a best fit line as defined by the optimization problem in equation for these points specifically linear regression finds 0and 1such that y 0 1xis the best linear approximation of f. as we will see in section .
for proving termination it is useful to further constrain the parameters by inequality constraints x yas follows min1 2 txtx t xty s.t.
x y xy figure finding the best fit line using linear regression.
xy figure a solution to the quadratic program in equation .
equation is an instance of quadratic programming which is defined as follows min1 2 th tf s.t.
m n by replacing hwthxtx fwith xty mwith x andnwith yin equation we obtain the constrained linear regression problem in equation .
for the data in figure solving the quadratic program in equation results in the line shown in figure .
an interesting feature of this solution line is that f x yfor all data points x y which is precisely the property that we require for estimating loop bounds.
.
algorithm the tpt algorithm is described in figure .
the algorithm takes a while program was input together with a test suite for w. assume that the program whasl possibly nested loops l1 ... l l. for every loop lk k l tpt returns a loop bound k. note that a valid loop bound for each loop in wdefines a proof of termination for w.a s previously illustrated by figure in line the call to the function instrument datainstruments the program so that information from testing the program wis recorded to a log file.
the program wis instrumented as follows consider a loop lfrom lk l k .l e t x1 ... x nbe the variables in the scope of the loop l.f o re a c h xi i n create a ghost variable gi and let cbe a variable representing a loop counter.
every ghost variable girecords the value of its corresponding variable xibefore the program enters the loop l. the loop counter cis also initialized to zero before the program enters l. at the beginning of each iteration of the loop l the values of all the variables in the scope ofl including the newly introduced ghost variables and loop counter are written to a log.
the value of cis also incremented before writing to the log ensuring that it is incremented in every iteration of the loop.
formally if l tpt w while program test suite returns a loop bound forw.
wi instrument data w logfile test wi repeat logfile logfile test wi ak ck l k datamatrix loopbound logfile ak ck l k datamatrix freeinvariant logfile k l k qp ak ck l i k k l k qp ak ck l k for k l k 1do iffail then roundorpartition ak ck l k end if end for wcheck instrument check w k l k k l k done check wcheck until done return i l i figure the tpt algorithm for a while program.
while ebdosod then the instrumented loop liis defined as follows gi xi i n c while ebdo c c writelog g1 ... g n x1 ... x n c s od therefore the instrumented program wiis the program w with all loops instrumented as described in equation .
the call to writelog returns a sequence of concrete states.
in this case a concrete state maps all the variables passed as arguments to writelog to their corresponding values.
the program wiis first executed over all tests in the test suite line and the results are stored in logfile .
iftest executes wi on some test for more iterations than a user specified time out then the loop is classified as potentially non terminating and the proof fails.
lines perform the main computation of the algorithm which primarily consists of two phases analogous to the abstraction and refinement phases of cegar based model checking tools .infer phase lines this phase processes logfile to compute the data matrices aiandcifor every loop li using which a candidate loop bound iis estimated line as well as the data matrices aiand ciusing which the free invariant iis estimated line .
.validate phase line this phase uses an offthe shelf safety checker for checking the validity of the candidate loop bounds computed in the infer phase.
the function datamatrix loopbound line constructs from logfile two matrices akand ckfor every loop lkin the program w.l e t lk denote the total number of times the entry of the loop lkis executed over all tests in the test suite .
every row in the matrix akrepresents a concretestate for all the ghost variables in lk.
therefore the i j th entry of akis the value of the jthghost variable obtained when the entry of lkis executed the ithtime by tests from .
the ithentry of the matrix ckis the corresponding value of the loop counter for the same execution.
therefore ak has dimension lk by the number of ghost variables for lk and ckhas dimension lk by one.
the function datamatrix freeinvariant line constructs from logfile two matrices akand ckfor every loop lkin the program w. every row in the matrix akrepresents a concrete state for all variables including the ghost variables in lk.
therefore the i j thentry of akis the value of the jth variable obtained when the entry of lkis executed the ith time over all tests from .
the ithentry of the matrix ck is the corresponding value of the loop counter for the same test.
therefore akhas dimension lk by the number of variables for lk and ckhas dimension lk by one.
to summarize akis a sub matrix of akand ck ck.
next in line the call to the function qpsolves lquadratic programming instances one for each loop lk k l in the program w. this is done by using an off the shelf quadratic programming solver for each instance thereby computing a candidate loop bound kfor each loop lk.a s we will see in section .
the candidate loop bound kcan be efficiently computed from akandck.
if the loop bound computation fails lines then appropriate corrective measures are taken details in section .
.
the loop bound computation is said to have failed when the bound obtained does not have integral coefficients.
the computation in line is similar to that in line but results in the calculation of the free invariant for every loop.
the candidate loop bounds k l k 1together with the free invariants k l k 1are given to the checking procedure check in line .
the procedure check uses an off the shelf safety checker to check whether the instrumented program wcheck is correct.
ifl while ebdosodis a loop in wwith candidate loop bound free invariant and variables in scope x1 ... x n then the instrumented loop lcheck is defined as follows gi xi i n c while bdo free invariant c assert c c c s od the result wcheck of the function call instrument check in line is the program wwith all loops instrumented as described in equation .
if the program wcheck is safe then kfor every loop lkis an upper bound and tpt terminates by returning a termination proof k l k .
otherwise check returns a set of counterexamples or tests that explain why some candidate loops bounds are not valid the computation in lines is repeated with these new tests line and the process continues until we have found a sound upper bound for every loop in w. to summarize the infer and validate phases of tpt operate iteratively and in each iteration if the actual bound for every loop cannot be derived then the algorithm automatically figures out the reason for this and appropriate action in the form of corrective measures section .
or generat ing more tests this corresponds to the case where the data generated is insufficient is taken.
.
the infer phase letlbe a loop and let aandcbe its corresponding data matrices for the loop bound calculation computed in line of figure .
let the data matrix a t and the data matrix c t then any valid loop bound w g over ghost variables g for l with w rn is such that aw c we would also like our candidate loop bound forlto be predictive.
in other words if we run the program on more test inputs then the bound should still be satisfied.
therefore we employ machine learning techniques for generating a predictive bound.
we describe these techniques next.
linear regression finds a wsuch that aw c. it has been successfully used to derive predictive answers in a variety of applications.
more formally linear regression finds a w which minimizes the following quantity min i m at iw ci in our setting using a wcomputed by linear regression naively has the following problem there is no guarantee that wis an upper bound.
that is it is possible that for some rows at iofa at iw c i. this motivates the need for a constrained linear regression that is minimize the expression in equation subject to the constraints aw c. in other words we are interested in solving the following quadratic program min1 2wtataw wtatc s.t.
aw c upon solving the quadratic program we are able to compute an upper bound that is consistent with the current set of concrete program states.
the techniques described above are also useful for efficiently generating a free invariant for a loop.
.
the validate phase after a candidate bound for every loop in the program has been obtained tpt asks an off the shelf safety checker to validate these bounds.
to reduce the burden of invariant inference on the safety checker tpt also provides it with free invariants which are computed by the infer phase.
it is important to note that the free invariants only serve as hints to the safety checker.
if a free invariant is invalid then the safety checker ignores it.
in section we show empirical data that establishes the usefulness of free invariants obtained via linear regression of test data.
if a loop bound is invalid then the safety checker returns a counterexample or a test that demonstrates the violation of the assertion.
this set of tests denoted by in figure is used to generate more concrete states and this ensures better loop bounds in the next iteration of tpt.
.
corrective measures there can be several reasons for the failure of bound generation line in figure .
the first reason is that the bound obtained for a loop cannot be expressed as a linearexpression with integer coefficients.
we describe a simple rounding strategy to handle this issue.
if a variable has value between n .
and n .
where nis an integer then we round it to n. if a variable still does not have an integral coefficient then we check if it is constrained by the program to be positive or negative.
if yes then we round it soundly ceiling for positive input variables and floor for negative input variables.
this is sound because increasing the coefficient of positive variables can only make the bound looser and similarly for the negative variables.
hence the rounded bounds can be imprecise but they are consistent with the data and are sufficient to prove termination.
in our experiments out of all the benchmarks tpt succeeds on rounding was performed only in four cases.
for the rest the output obtained by solving the quadratic program of equation was already integral.
if rounding fails then the reason might be that the loop does not have a single bound.
the loop might show different behaviors for different inputs and hence a single bound is perhaps not possible for this mix of two or more behaviors.
therefore there is a need to partition the input values to the loop such that for each region in the partition the tests in that region have the same bound.
once a correct partitioning has been obtained linear regression can be used to obtain the bounds for each individual partition.
we consider two simple schemes for partitioning the data .partition according to the predicates syntactically occurring in the program.
for instance if the guard for al o o pi s p q then we can partition the input values based on whether they satisfy the predicate p q o r both.
.
.partition according to the path executed in running the test.
there are existing techniques that are based on control flow refinement to do this systematically.
in if there is an if condition in the loop that shows phases it has the property that once the condition becomes false it remains false until the program exits the loop then the loop is rewritten into a sequence of two loops the first containing the then branch and the second containing the else branch.
using information from tests it is easy to detect if a condition is showing phases.
if the above heuristics fail that is either there is no obvious partitioning by predicates or branches showing phases then tpt fails.
if even after partitioning we obtain coefficients for which the above rounding process fails then we declare failure of tpt.
these heuristics for partitioning are basically trying to handle disjunctive bounds.
how to split the proof burdens for termination is a well known open problem .
our technique is good at obtaining linear or nonlinear bounds when they exist.
handling disjunctive bounds systematically is left for future work.
the failure to infer the correct partition is the primary reason why this technique can fail.
in our benchmarks for two benchmarks we performed predicate based splitting and for one benchmark we needed path based splitting.
we illustrate partitioning by predicates with the help of the example program shown in figure .
we can partition the tests into three regions each defined by the predicates a m b n a m b n a m b n .
by applying the infer phase to the tests1a i b j c while i m j n 3i i 4j j 5c c figure program that requires partitioning.
1u x v y w z c while x y 3c c if z 5z z 6x x z else 8y y figure example program that requires a nonlinear loop bound.
based on each of these regions separately we obtain a m b n c m n a b a m b n c m a a m b n c n b the safety checker is able to prove the disjunctive loop bound in equation .
using clustering algorithms in machine learning for inferring disjunctive loop bounds systematically is left for future work.
.
non linear bounds since the tpt algorithm is driven by tests it is able to seamlessly handle non linearities.
we illustrate this using the example program in figure .
letdbe the degree of the polynomial representing the loop bound.
assume that dis bounded above by for this example.
as before just as in the linear case we create the data matrices aandc the matrix ais such that the ithrow of acorresponds to the ithconcrete program state.
each column of a corresponds to a monomial of degree at most two over the variables u vandw where u vandware ghost variables recording the initial values of the program variables x yandzrespectively .
therefore ahas columns one for each of the monomials u v w uu vv ww uv uwandvw.
for instance when the program is tested on the input x y z i t generates a row of awith ten ones.
theithrow of the matrix cis the number of iterations for the ithexecution of lk.
by way of random testing where the inputs x yandzto the program are in the range and only test inputs that execute the loop at least once are selected we obtain tests essentially this is a form of rejection sampling to select tests .
thus ais a matrix and cis a matrix.
solving the quadratic program as defined by equation we obtain the solution wt this gives us a loop bound u w u v w w2 c u v w w2after applying rounding see section .
for a description of rounding .
next using the data from the logfile we compute the free invariant c y w v z see section .
this free invariant together with the assertion encoding the candidate loop bound is fed to a safety checker which is able to prove the bound and therefore termination of this program.
.
experimental evaluation we have evaluated the tpt algorithm on various benchmarks for termination from as well as some windows device drivers.
all experiments were performed on a .67ghz intel xeon processor system with gb ram running windows and matlab r2012a.
the infer phase of tpt i n particular equation is implemented using just one line of matlab code quadprog at a at c a c where a care the data matrices for a loop.
micro benchmarks.
these benchmarks are shown in the first column of table and are categorized as follows .benchmarks prefixed by oct are from the octanal distribution.
these include programs such as heapsort and bubblesort.
.benchmarks prefixed by driver are code fragments from windows device drivers.
these benchmarks have been hand translated to remove pointer aliasing.
.benchmarks prefixed by poly are from the polyrank distribution.
these benchmarks are tricky programs such as mccarthy s function with non trivial termination arguments.
device drivers.
we also evaluated tpt on windows device drivers to demonstrate its ability to analyze and scale to real world applications.
these drivers are part of the sdv rp toolkit available at .
the statistics for these drivers are shown in columns and of table .
the column locis the number of lines of code and the column loops is the number of loops that are reachable from the harness to these drivers.
we performed a simple static analysis to determine this loop reachability information.
evaluation.
the second column of table shows the total time spent bytpt in its infer phase.
the third column shows the total time taken by the validate phase of tpt.
the fourth column shows the total time in seconds taken by tpt.w e observe that a significant fraction of the total analysis time is spent in the validate phase.
for the micro benchmarks the data or tests were generated naively each input variable was allowed to take values from nton where n was between and .
therefore if a program has two input variables we generated o n2 tests.
if the benchmark program had nondeterministic branches then we ranname infer time sec validate time sec total time sec result oct1 .
.
.
oct2 .
.
.
oct3 .
.
.
oct4 .
.
.
oct5 .
.
.
oct6 .
.
.
driver1 .
.
.
driver2 .
.
.
driver3 .
.
.
driver4 .
.
.
driver5 .
.
.
driver6 .
.
.
driver7 .
.
.
driver8 .
.
.
driver9 .
.
.
driver10 .
.
.
poly1 .
.
.
poly2 .
.
.
poly3 .
.
.
poly4 fail na .
fail poly6 .
.
.
poly7 fail na .
fail poly8 fail na .
fail poly9 .
.
.
poly10 fail na .
fail poly11 .
.
.
poly12 fail na .
fail table name is the name of the benchmark infer time is the time taken by the infer phase of tpt in seconds.
validate time is the time in seconds taken by the validate phase of tpt to verify the candidate loop bounds.
the fourth column shows the total time taken by tpt.
the last column indicates the result of the analysis whether tpt proved termination found a termination bug or failed fail .
group total tpt o p pr t lr lta lf cta oct driver poly all table group is the benchmark group the last row represents the sum of results over each of the three groups total is the number of benchmarks in the corresponding group tpt is the number of benchmarks in each group on which tpt successfully completes its analysis ois an octagon based termination analysis pis a polyhedra based termination analysis pris a script on top of tisterminator lrislinearrankterm an abstract interpretation over an abstract domain which represents ranking functions lta is algorithmic learning based termination analysis lfisloopfrog a summary based termination analysis ctais a compositional termination analysis .
it three times for each input value one with nondeterminism replaced by true one with nondeterminism replaced by false and one with nondeterminism replaced by rand .
while it is possible to generate tests more intelligently using inputs from a very small bounding box demonstrates the generality of our technique by not tying it to any particular test generation technique.
on measuring the sensitivity to test data we found that at most randomly selected states from the test data were sufficient to obtain a sound bound for all our benchmarks.
for the micro benchmarks we used for validation it can handle non linearities consume candidate invariants and requires tests.
unfortunately on verification failure might not produce a reachable counterexample.
static analysis tools such as yogi do find reachable counterexamples but cannot handle non linearities.
for the microbenchmarks we run an increasing number of naively generated tests until validates the inferred bounds.
the fifth column shows the results reported by tpt.a shows that tpt was able to prove the termination of all loops in the benchmark program.
a shows that tpt found a true non termination bug.
for such programs tpt terminates with a suspect trace it is important to note that tpt does not report a certificate of non termination.
however our technique can be combined with non termination provers in the spirit of to derive a certificate of nontermination.
for all the benchmarks on which the infer phase succeeds in computing a bound tpt is able to prove termination.
for these cases the free invariant obtained by linear regression was an actual invariant.
however the free invariant had to be strengthened by the validate phase to obtain an inductive invariant.
tpt required rounding for oct3 driver10 poly3 and poly6 and used the simple strategy described in section .
.
for the remaining benchmarks the quadratic programming solver gave exact integral bounds.
one major reason for why numerical techniques are not common in verification isname loc loops infer validate tpt time sec time sec time sec kbfiltr .9k .
.
.
diskperf .3k .
.
.
fakemodem .1k .
.
.
serenum .3k .
.
.
flpydisk 6k .
.
.
kbdclass .5k .
.
.
table performance of tpt on windows drivers.
because of the difficulty in obtaining integral results.
in the case of linear regression for inference of loop bounds this concern is dispelled empirically.
rounding is usually not needed and even when it is needed it is quite simple.
for the benchmarks driver10 andpoly1 tpt requires predicate based partitioning and for the benchmark poly11 tpt uses path based partitioning.
it is interesting to note that poly1 can also be handled by path based partitioning.
tpt fails on the benchmarks poly4 poly7 poly8 and poly12 .
on preliminary examination it seems like these benchmarks require more sophisticated partitioning of data.
development of learning algorithms for identifying these partitions is ongoing work.
for instance poly4 requires the data to be partitioned according to whether an input is positive or negative.
tptfails on poly10 as this benchmark has many assume statements and therefore it is hard to generate data by running the program and simultaneously satisfy all assume statements.
symbolic execution techniques are required for generating data for such benchmarks.
in terms of performance the time taken by tpt is comparable with previous work.
an exact comparison with the times reported by previous approaches is not meaningful as we are running on newer hardware .
however we reproduce the number of benchmarks on which previous techniques are successful in table from their respective papers.
from table it is important to note that tpt is able to successfully prove more benchmarks in this suite than any previously known technique.
one of the reasons for this is that regression is able to quickly guess sound bounds and invariants using a reasonable amount of data as is evident from the times taken by the infer step.
moreover unlike existing techniques since the infer phase of tpt is driven by tests it does not get confused by program text.
finally the results of tpt on windows device drivers is reported in table .
we used an existing test suite that was available for these drivers obtained by running the yogi tool .
the validate phase was implemented using the yogi tool which is routinely used to check safety properties of windows device drivers.
as seen from the table tpt is able to successfully prove termination for all these drivers.
in contrast terminator is unable to complete on the serenum andflpydisk device drivers it runs out of memory when the memory limit is set to .
gb .
it is also interesting to note that the infer phase of tpt is very efficient and almost all the time taken by tpt is spent in validating the loop bounds.
we believe that the infer phase of tpt which is driven by data from tests is almost independent of the size or complexity of the program.
.
related work our work falls into the category of using machine learning for proving program properties .
there is a large body of work on termination and bounds analysis.
we draw acomparison with techniques that are most closely related to tpt.
regression has also been used to determine the execution time of programs for empirical computational complexity and profiling .
these approaches have no soundness guarantees.
we have shown that regression can be used to not only obtain sound bounds sufficient for proving termination but also for discovering invariants required for proving the bounds.
in contrast to these approaches we use a constrained variant of regression that is efficiently solvable by quadratic programming.
there is a lot of work that addresses the problem of mining useful information from tests .
deriving invariants from tests for the purpose of proving safety properties has been pioneered by the daikon approach .
in contrast tpt is a novel testing based approach for proving program termination.
in safety checking a candidate invariant is refuted by a counter example state which does not satisfy the candidate .
interestingly for tpt the counterexample state is not very relevant since termination is not a safety property.
what is relevant for tpt is the number of times a loop body iterates for a given counter example.
podelski and rybalchenko describe a complete procedure for proving termination for a restricted class of programs.
cousot gulwani et al.
and bradley et al.
compute ranking functions by using a template and solving constraints encoding the program.
tpt on the other hand operates on data generated from tests and the constraints which verify that a given bound is an actual bound in the validate phase are much simpler to solve than the constraints used to synthesize ranking functions.
bradley et al.
developed termination techniques based on the lexicographic polyranking principle.
these techniques can prove termination of all the tricky loops in the poly benchmarks described in section .
these techniques were originally developed for transition systems and therefore they find it hard to deal with complex control flow.
in contrast the infer phase of tpt does not even look at the program and in the validate phase the safety checker just encodes control flow as a constraint which is subsequently handed off to an smt solver.
since tpt does not rely on predicate abstraction for inferring termination arguments it is also able to outperform techniques based on algorithmic learning .
techniques for handling termination of non linear programs are based on a restricted program syntax because they want their termination argument to be sound by construction.
for instance babic et al.
can prove the termination of non linear programs with a restricted syntax by finding regions of guaranteed divergence .
due to their restricted syntax they cannot prove the termination of the program in figure .
in contrast tpt does not require its infer phase to be sound.
this allows us to use predictive machine learning algorithms which work well in practice for the synthesis of bounds.
tpt recovers soundness via the validate phase.
gulavani et al.
adopt a similar approach and try to find a bound for an instrumented loop counter by abstract interpretation.
using their ideas we can extend our technique to infer loop bound expressions which can contain logarithms exponentials and square roots.
the idea is to just add a column to the data matrix for every feature that can occur in the bound and provide enough axioms to the checker to reason about the features.proofs using transition invariants require a well chosen partitioning.
obtaining this partitioning is a well known hard problem and several heuristics exist.
terminator is based on transition invariants and performs partitioning iteratively.
it will be useful to see if abstraction refinement techniques like those employed by terminator can help us obtain a good partitioning.
are abstract interpretation based approaches for termination.
these approaches failwhen non linear computations are involved.
we note that leaves handling disjunctions as an open problem and handles disjunctions by enumerating all paths in a loop.
tpt requires partitioning when no bounds exist.
in most loops occurring in practice as attested by our experiments the loops do have linear or polynomial bounds.
together with proving termination it seems important to produce certificates of non termination for potentially nonterminating programs.
we are exploring whether our technique can be combined with in the spirit of .
our technique is related to bounds analyses of gulwani et al.
.
these approaches find it difficult to handle nonlinearities.
as a consequence they instrument the program with multiple counters with the hope that all counters will have linear bounds.
in contrast we can obtain non linear bounds.
it is important to note that gulwani et al.
can find more precise bounds than tpt as their bounds can contain richer operators like max.
for the program in figure gulwani et al.
can compute the bound max a b .
on the other hand tpt infers a looser bound a b .
since our goal is to obtain bounds for the purpose of proving termination these loose bounds suffice.
that said since we are using linear regression our bounds are not very loose.
but since they are restricted to linear or polynomial expressions they are not as tight.
when the number of iterations of a loop is a deterministic function of the input then can use dynamic information and polynomial interpolation to compute a loop bound which is subsequently validated using a proof assistant.
however many of our examples have internal nondeterminism and therefore an interpolating polynomial does not exist while a loop bound still exists .
.
conclusion in this paper we have presented a novel algorithm tpt for proving termination of programs using information derived from tests.
programs usually have test suites associated with them and we are able to learn loop bounds automatically from these test suites using a modification of linear regression.
we have also shown how to extend linear regression so as to infer polynomial loop bounds.
our empirical results show that tpt significantly improves the state of the art in termination analysis on micro benchmarks tpt is able to prove termination on more benchmarks than any previously known technique.
our results over windows device drivers demonstrates tpt s ability to analyze and scale to real world applications.
there are number of interesting directions for future work automatic partitioning as seen in section tpt fails to prove termination on four benchmarks all of which require more sophisticated partitioning of data.
it would be interesting to see if clustering algorithms in machine learning can be combined with regression to infer disjunctive loop bounds systematically.other instantiations of tpt it would also be interesting to extend tptfor proving liveness properties as well as total correctness of programs.
we believe that these would require a tighter integration of tpt with a safety checker.
.