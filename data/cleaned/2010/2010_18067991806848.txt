aura a hybrid approach to identify framework evolution wei wu1 y ann ga l gu h neuc1 giuliano antoniol2 and miryung kim3 1ptidej team dgigl cole polytechnique de montr al canada 2soccer lab dgigl cole polytechnique de montr al canada 3eced the university of texas at austin usa e mail wuwei guehene iro.umontreal.ca giuliano.antoniol polymtl.ca miryung ece.utexas.edu abstract software frameworks and libraries are indispensable to today s software systems.
as they evolve it is often timeconsuming for developers to keep their code up to date so approaches have been proposed to facilitate this.
usually these approaches cannot automatically identify change rules for one replaced by many and many replaced by one methods and they trade o recall for higher precision using one or more experimentally evaluated thresholds.
we introduce aura a novel hybrid approach that combines call dependency and text similarity analyses to overcome these limitations.
we implement it in a java system and compare it on ve frameworks with three previous approaches by dagenais and robillard m. kim et al.
and sch aferet al.
the comparison shows that on average the recall of aura is .
higher while its precision is similar e.g.
.
lower.
.
introduction software frameworks1and libraries are widely used in software development for cost reduction.
they evolve constantly to x bugs and meet new requirements.
in theory the application programming interface api of the new release of a framework should be backward compatible with its previous releases so that programs linked2to the framework continue to work with the new release.
in practice the api syntax and semantics change .
for example from jhotdraw .
to .
method ch.ifa.draw.
figures.lineconnection.end was replaced by lineconnection.getendconnector such a change may have direct consequences on a program using the jhotdraw frame1without loss of generality we use the term framework to mean both frameworks and libraries.
2we refer readers to for a discussion on the links between frameworks and programs.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.work such as compile errors or indirect ones such as runtime errors if invoking a deleted method using re ection.
to prevent backward compatibility problems developers may delay or avoid using a new release.
yet if they want to bene t from new features or security patches they must evolve their programs.
this evolution process often requires a lot of e ort because developers must dig into the documents and or source code of the new and previous releases to understand their di erences and to make their programs compatible with the new release.
consequently many approaches have been developed to ease this evolution process and reduce the developers e orts.
some require that the framework developers do additional work such as providing explicit change rules with annotations or that they record api updates to the framework.
.
to reduce the framework developers involvement some approaches automatically identify change rules that describe a matching between target methods i.e.
methods existing in the old release but not in the new one and replacement methods in the new release .
however framework developers may not be willing to build change rules manually or use speci c tools.
also some previous approaches cannot detect change rules for target methods not used within the previous releases of the framework and program.
others such as cannot identify replacement methods if the names of the old and new releases are not similar enough.
still others require context dependent thresholds which are chosen through experimental evaluations and may not apply in di erent contexts.
furthermore no existing approaches can automatically handle one replaced by many one to many in the following or many replaced by one many to one change rules as illustrated in the following section.
it is important to identify these one to many and many to one change rules because they can guide developers towards new functionalities in the new release.
in particular developers should be provided with as many relevant change rules as possible to save their e orts to identify appropriate rules from a potentially very large code base.
thus an approach should have the maximum recall without decreasing its precision.
indeed it is easier for a developer to discard an inappropriate change rule among a couple of h undred rules than to identify an appropriate change rule among thousands of possible method pairs.
consequently we propose a novel hybrid language and context independent approach aura automatic change rule assistant that combines the advantages and overcomes the limitations of previous approaches .
it increases recall by combining call dependency and text similarity analyses in a multi iteration algorithm .
it automatically adapts to di erent frameworks by not using any experimentally evaluated threshold .
it reduces developers e orts by automatically generating one to many and many to one change rules.
using a detailed evaluation on four medium size real world systems we show that the percentage of one to many and many to one change rules covers .
of the total number of target methods.
moreover the results of the evaluation show that the combination of call dependency and text similarity analyses into a multi iteration algorithm improves on average recall by .
in comparison to previous approaches with a slight decrease of .
in precision.
in our evaluation we also apply aura to eclipse and compare its results with those of semdi developed by dagenais and robillard .
we show that the approximated precision of aura is .
while semdi s is up to .
.
in the remainder of this paper section presents motivating examples that illustrate the limitations of previous approaches.
section discusses related work.
section describes our approach while section evaluates it on ve real world systems.
section discusses open issues and section concludes this paper and discusses future work.
.
motiv ating examples we illustrate the advantages of aura with the following motivating examples.
multi iteration algorithm.
let us assume that a developer must adapt her client program from using eclipse jdt .
to its .
release as shown in figure .
the method indents.computeindentlength ... was called in .
.
however this method on longer exists in .
.
using an automatic approach the developer would expect to obtain the following change rules indents.getchangeindentedits ... a indentmanipulation.getchangeindentedits ... indents.computeindentlength ... a indentmanipulation.indexofindent ... where ameans should be replaced with .
previous approaches using either text similarity or call dependency analyses could provide the developer with the rst change rule but would not readily suggest the second one because the method signatures are not similar enough and the callers of the methods changed as well.
aura would report the two change rules above.
with its multi iteration algorithm aura detects that indents.getchangeindentedits ... is replaced by indentmanipulation.getchangeindentedits ... in the rst iteration.
then in the following iteration using the rst change rule aura also reports that indents.computeind version .
package org.eclipse.jdt.internal.core.dom.rewrite public class sourcemodifier implements isourcemodifier public replaceedit getmodifications string source ... return indents.getchangeindentedits ... package org.eclipse.jdt.internal.core.dom.rewrite class indents void getchangeindentedits ... ... int length indents.computeindentlength ... ... version .
package org.eclipse.jdt.internal.core.dom.rewrite public class sourcemodifier implements isourcemodifier public replaceedit getmodifications string source ... return indentmanipulation.getchangeindentedits ... package org.eclipse.jdt.core.formatter class indentmanipulation void getchangeindentedits ... ... int length this.indexofindent ... ... figure example of many iterations version .
protected jmenu createeditmenu ... menu.add new cutcommand cut view new menushortcut x ... version .
protected jmenu createeditmenu ... menu.add new undoablecommand new cutcommand cut this new menushortcut x ... figure example of a one to many change rule.
entlength ... is replaced by indentmanipulation.indexofindent ... .
one to many change rules.
let us assume that a developer must adapt a program built on top of jhotdraw .
to its .
release.
the program adds some new commands to the framework.
for the sake of simplicity let us use cutcommand in figure .
syntactically this command would not compile with the new release because the expected signature of commands has changed.
semantically release .
introduces an undo redo mechanism that should be used by the new command if appropriate.
therefore the developer would expect to obtain the following change rule automatically which advices the developer to consider making the command undoable.
cutcommand.cutcommand drawingview... a cutcommand.cutcommand alignment drawingeditor and undoablecommand.undoablecommand command previous approaches using either text similarity or 326ca ll dependency analyses would only report a change rule from cutcommand.cutcommand drawingview... tocutcommand.cutcommand alignment drawingeditor i.e.
a rule xing the syntactic di erence.
they would not help the developer in spotting the new feature provided by the framework with its new feature of undoable commands.
aura reports a one to many change rule that suggests replacing the target method cutcommand.cutcommand drawingview... with calls to the replacement methods cutcommand.
cutcommand alignment drawingeditor andundoablecommand.undoablecommand command .
figure illustrates the new implementation where an undoablecommand now encapsulates cutcommand.
many to one change rules.
let us assume that a developer must adapt a program built on top of jedit .
to its .
release and the program called methods directorymenu.directorymenu ... markersmenu.markersmenu and recentdirectoriesmenu.recentdirectoriesmenu which are replaced by enhancedmenu.enhancedmenu ... in the release .
.
with previous approaches that generate one toone change rules the developer could know that directorymenu.directorymenu ... is replaced by enhancedmenu.
enhancedmenu ... but would need to nd the other two methods manually.
some previous approaches such as might produce erroneous change rules for the other two target methods due to their high textual similarity with other irrelevant methods.
with aura the developer will be informed that the three methods are replaced by enhancedmenu.enhancedmenu ... which frees her from manually searching for replacements or relying on incorrect suggestions.
.
related work several approaches help developers evolve their programs when the frameworks that they use change.
we studied these approaches and identi ed eight features.
table summarizes the di erent approaches according to their features and highlight the advantages of aura.
we now further de ne and discuss the di erent features and approaches.
capturing api updates.
existing approaches of capturing api level changes either require the framework developers e orts by manually specifying the change rules or by requiring them to use a particular ide to automatically record the refactorings performed.
chow and notkin presented a method that requires the framework developers to provide change rules with the new releases.
catchup!
and jbuilder record the refactoring operations in one release and replay them in another.
molhadoref also employs a record and replay technique for handling api level changes in merging program versions.
these approaches are able to provide accurate change rules because of the framework developers involvement which might not always be available.
matching techniques.
previous approaches use di erent code matching techniques to nd change rules between old and new releases.
dagenais and robillard developed semdi which suggests adaptation to clients by analyzing how a framework adapts toits own changes.
sch aferet al.
mined framework usage change rules from already ported instantiations.
these two previous approaches compute support and con dence value on call dependency analysis.
godfrey and zou presented a semi automatic hybrid approach to perform origin analysis using text similarity metrics and call dependency analyses.
s. kim et al.
automated godfrey and zou s approach.
di catchup developed by xing and stroulia analyses textual and structural similarities of uml logical design models to recognise api changes.
m. kim et al.
s approach leveraged systematic renaming patterns to match old apis to new apis.
many to one and one to many.
godfrey and zou detected three cases of merging clone elimination service consolidation pipeline contraction and three cases of splitting clone introduction service extraction pipeline expansion .
we extend merging splitting to many to one one to many change rules.
the di erence between merging splitting and many to one oneto many change rules is that the former is limited to cases de ned by godfrey and zou while the latter includes any case e.g.
new functionality.
semdi and di catchup are able to report many to one and one to many change rules but are semi automatic i.e.
developers must manually select correct replacements from a provided candidate list.
m. kim et al.
s approach automatically reports many to one rules.
simply deleted.
simply deleted target methods have no replacement methods in the new release.
semi automatic approaches and those that require framework developers involvement are able to report simply deleted rules.
automatic approaches do not report this type of change rule explicitly in their result.
automatic and thresholds.
all automatic approaches except record andreplay ones use thresholds to keep a balance between precision and recall.
typically they use experimentally evaluated thresholds to lter out candidate replacement methods thus potentially increasing precision but decreasing recall.
types of changes.
sch aferet al.
classi ed changes between old and new releases into change patterns.
we summarize them into three categories of change rules method rules all the targets and replacements of a change rule are methods eld rules all the targets and replacements of a change rule can be methods or elds inheritance rules the inheritance relation changes.
we report the types of changes found by each approaches and compare the results in section .
summary.
aura overcomes the following limitations of existing approaches 2text similarity based approaches cannot detect replacement methods that do not share similar textual names with their target methods.
2call dependency based approaches cannot detect re327appr oachesf eatures main one to many simplyfdi matching many to onedeleted methods fields inheritance auto threst echnique rule s ru les rule s rel ations mati chold s cho wet al.
y es a no no y es y es no no no no semdi no cd y es y es y es y es no no no y es go dfrey et al.
no ts m and cd y es y es y es y es no no no y es catc hup!
y es n a no no no y es y es y es y es no m. kim et al.
no ts no y es y es y es no no y es y es s. kim et al.
no ts m and cd no no no y es no no y es y es sc h afer et al.
no cd no no no y es y es y es y es y es di c atchup no ts and ss y es y es y es y es y es y es no y es a ura no cd and ts y es y es y es y es no no y es no t able feature comparison.
a annotation cd call dependency fdi framework developer involvement m metrics n a not applicable ts text similarity ss structural similarity placement methods for target methods that are not used in frameworks and linked programs.
2no approach can automatically detect many to one and one to many change rules.
2all automatic approaches except record and replay use thresholds set through experimental evaluations which may not apply in any context.
.
our approach our approach is based on call dependency and text similarity analyses and a multi iteration algorithm.
we choose call dependency and text similarity as the main matching techniques of our hybrid approach for two reasons previous approaches using these analyses have good precision these techniques are compatible with each other because they apply directly to source code.
the assumption of our approach is that a target method is deleted or replaced by one or more replacement methods and more than one target method can be replaced by the same replacement method.
all replacement methods are taken from the candidate set of all methods existing in the new release of a framework or belonging to other frameworks provided by the same vendor.
we do not consider methods from the frameworks of di erent vendors.
for example when we analyze org.eclipse.jdt.core the methods from other eclipse plug ins such as org.eclipse.jface belong to the candidate replacement method set but those from sun java foundation classes jfc do not.
we include the methods from the frameworks provided by the same vendor only because framework developers may move methods between their frameworks.
this inclusion is a good trade o between accuracy and performance because a large candidate set compromises performance but increases precision.
after analyzing the results of the four mediumsize subject systems in the evaluation we found that less than of all methods were replaced by those from the frameworks of other vendors.
.
preliminary call dependency analysis discovers the calls between the methods of frameworks and the programs using them.
these calls re ect the behavior of frameworks more accurately than text similarity in particular when detecting many to one and one to many change rules.
to illustrate the call dependency analysis used in our approach let us de ne an anchor as either a pair of meth ods with the same signature including return type declaring module name and parameter lists that exist in both the old and new releases of the framework or a pair of methods already identi ed as target and replacement methods.
we also de ne two predicates for an anchor a old a the method of ain the old release new a the method of ain the new release in the following we note m1!m2 if a method m1 calls a method m2 if it does not .
we compute the con dence value cv for a given target method tand its candidate replacement method cas cv t c a t c a t with a t jjfajais an anchor old a !tgjj a t c jjfajais an anchor old a !t new a !cgjj where jjsjjrepresents the cardinality of s. the con dence value represents the call dependency similarity of a target method and its candidate replacement methods.
to compute the text similarity of two methods we tokenize each method signature as proposed by lawrie et al.
by splitting them at upper case letters and other legal characters except lower case letter and numbers for example and in java.
based on the tokenized signatures our text similarity algorithm computes the similarity of two methods using rst their signatures return types declaring modules names and parameter list then their levenshtein distance ld and nally their longest common subsequence lcs .
when we compare the text similarities of two candidate replacement methods to a target method we rst compare their signature level similarity.
if they are di erent we do not compute their ld and lcs.
we apply the same strategy to ld and lcs.
we combine ld and lcs to compare the text similarity between two methods because ld and lcs pertain to two di erent aspects of string comparison ld is concerned with the di erence between strings but is not able to tell if they have something in common while lcs focuses on their common part but is not able to tell how di erent they are.
for example let us assume that we want to identify the string most similar to abbetween a abc and abcd.
both aand abchave the same ld and both abcandabcd have the same lcs.
thus by combining ld and lcs we can identify that abcis most similar to ab.
.2algorithm using the previous call dependency and text similarity analyses aura generates change rules from the old to the new release of a framework in the following steps .
global data set generation by di erentiating the sets of method signatures in the old and new releases we build the set of target methods stm the set of anchors sa and the set of global candidate replacement methods sgcrm which includes all the methods de ned in the new release.
the target methods whose change rules were already detected in previous iterations are not included in stmand whose replacements are excluded from sgcrm were added to saafter being detected.
.
target methods classi cation.
using call dependency analysis we divide stmin stmca ftja2sa 9old a !tg stmuca ftja2sa old a !tg with stm stmca stmuca .
candidate replacement method set generation.
also using call dependency analysis for each target method tinstmca we build the set of corresponding candidate replacement methods in the new release using the predicate crms t fmjm2sgcrm a2sa old a !t old a 9m new a !mg .
con dence value computation.
we compute the con dence value of each candidate replacement method cin crms t with respect to its corresponding target method t with t2stmca.
we then generate change rules for all target methods in stmca using the con dence values and jjhcs t jj where hcs t fcjc2crms t cv t c g as follows 4a.8tj jjhcs t jj .
we build the change rule tac and add it to sa in the form of an anchor .
if sadoes not change we stop iterating and go to the next step or we go back to step .
4b.8tj jjhcs t jj .
the relation between tand its candidate replacement methods is one to one or one tomany.
we assign the proper candidate replacement methods using text similarity analysis and the number n m a t of times that tand its candidate replacement methods are called in their anchors in two steps 4b1.
key replacement methods identi cation.
we use text similarity to identify key replacement methods for all t. the key replacement method kr t to tis the only method that is the most similar to tfrom the candidate replacement methods whose names are equal to t s or from the methods in hcs t .
4b2.
co replacement methods identi cation.
the co replacement methods to tare chosen from chcs t usingn m a t and the support s t c de ned below.
a target method can have zero or more co replacement meth ods regardless of their textual similarity.
we de ne the chcs t of co candidate methods and kas t of anchors that call kr t and two counters such as chcs t fcjc2hcs t cis not a keyreplacement method to any target methods g kas t faja2sa new a !kr t g n m a t jjfnew a !mja2kas t gjj allkr a fkjk is a key replacement new a !kg alln t a jjfnew a !kja2kas t k2allkr a gjj from an anchor a2kas t we compute the call count of the key replacement of t m n kr t a t the call count of a candidate method c2chcs t p n c a t and the call count of all the key replacement methods called ina q alln t a .
we compare pwith mandqand only keep co candidate methods meeting the two conditions 2m p cis called more than one time and exactly as many as the number of times that kr t is called.
in this case chas a high possibility to collaborate with kr t in the new release.
2q p q cis called as many as or more than the number of times that the key replacements of all target methods in the same anchor a and all the keyreplacements are called more than once.
in this case cis likely to collaborate with all the key replacements.
then we select the co candidate methods left in chcs t with the highest support s t c as the co replacement methods where the support is de ned as s t c jjfmj m2 fall the methods in the new release g m!kr t m!cgjj for a target method whose replacement methods are detected in this step if its co replacement methods set is empty aura generates a one to one change rule otherwise it generates a one to many rule.
4c.8tj jjhcs t jj .
we choose the most similar candidate replacement methods to tfrom the methods whose name is equal to t s incrms t or from all the methods incrms t .
then we choose the candidate methods with the highest con dence value as the replacement methods.
the rules detected by this step could be one to many rules if there is more than one candidate method with same textsimilarity and con dence values.
in this step we give textsimilarity analysis priority over con dence value because a con dence value less than indicates a behavior change in one or more anchors.
.
text similarity only rule generation.
for each t2stmuca we use text similarity to nd its replacement methods with the most similar signatures from sgcrm.
if there is more than one candidate replacement method we select one randomly.
we could generate one to many rule if there is more than one candidate method with the same 329sub ject systems re leases methods jf reechart0.
.
.
.
jhot draw5.
.
je dit4.
.
st ruts1.
.
.
org.ec lipse.jdt.core .
or g.eclipse.jdt.ui .
t able subject systems.
text similarity to a target.
but according to our evaluation most relevant cases are one to one rules.
.
simply deleted method rule identi cation finally we examine the target methods in stmuca .
if the replacement of one of these methods also exists in the old release we mark the target method as simply deleted method i.e.
a target method with no replacement method in the new release.
we only identify simply deleted method rules in this step because target methods in stmuca have never been used or their context of use changed between the old and new releases.
furthermore their most similar candidate replacement methods are not methods added to the new release.
these target methods are most likely to be simply deleted.
.
implementation we implemented our approach as a java program that includes two components model builder and rule generator.
the former component converts the source code of the old version and of the new version of a program into the language independent aura model.
the current version of model builder is an eclipse plugin operating on the abstract syntax tree generated by the eclipse java parser.
the latter component generates change rules using the aura model.
it can be used both as an eclipse plugin or as a standalone java program.
the executable and source code of aura can be found on our web site5.
.
ev aluation we now evaluate and compare aura on several systems.
.
design we evaluated aura on ve open source systems meeting the following conditions di erent sizes developed independently from each other and studied in previous work.
the last condition reduces the bias in the selection of the subject systems and facilitates the comparison with previous work.
table summarizes the ve subject systems.
we use the four medium size systems jfreechart jhotdraw jedit and struts to compare aura with the approaches of m. kim et al.
and sch aferet al.
.
we use the large system org.eclipse.jdt.core andorg.eclipse.
jdt.ui to compare aura with semdi .
we reuse the results of the three approaches provided by their authors because it is impractical to reanalyse all the target systems and also to avoid experimenter bias.
we include one to many change rules by treating them as one to one change rules because the previous approaches do 5w ww.ptidej.net downloads experiments icse10bnot report such rules.
we convert many to one change rules into as many one to one change rules as target methods.
.
hypothesis and performance indicators our hypothesis is that aura will nd more relevant change rules than the previous approaches with comparable precision i.e.
it will have a better recall than and similar precision to those of the previous approaches.
we cannot use recall and precision directly to compare the performance of aura and the previous approaches because the set relevant rules isa priori unknown in precision jjfrelevant rules gtfretrieved rules gjj jjfr etrieved rules gjj recall jjfrelevant rules gtfretrieved rules gjj jjfr elevant rules gjj therefore to eliminate the in uence of this unknown set we de ne the set fcorrect rules g which can be obtained by manually inspecting the set fretrieved rules gas fcorrect rules g frelevant rules gtfretrieved rules g we introduce the di erences in precision p and recall r as two functions of the change rules detected by two di erent approaches aandb p a b precision a precision b prec ision b jfcorrect rules gaj jf retrieved rules gbj jfr etrieved rules gaj jf correct rules gbj r a b recall a recall b re callb jfcorrect rules gaj jf correct rules gbj jfcor rect rules gbj using p a b and r a b we can compare the precision and recall of two approaches and avoid the in uence of the unknown set frelevant rules g. we compute fcorrect rules gfor aura on four medium size systems jfreechart jhotdraw jedit and struts by manual inspection.
for the previous approaches we use the data provided by the corresponding authors.
for the two eclipse plug ins org.eclipse.jdt.core and org.eclipse.jdt.ui from .
to .
aura generates more than change rules.
thus it is impractical to validate all these rules manually.
we follow dagenais and robillard s evaluation method choose the same three client programs of these plug ins i.e.
org.eclipse.jdt.debug.ui mylyn and jbosside compile them with eclipse .
use the change rules found by our approach to solve the compile errors in scope i.e.
compile errors caused by the methods not existing anymore in release .
and compute the precision of the change rules that cover these compile errors.
.
comparison on the medium size systems in table we present the p and ron each subject system between aura and m. kim et al.
s and sch afer et al.
s approaches in column and .
we then report the average values for each approach in column and .
in the last three rows we present the total average values of 330sy stems ind icators a ura m. kim et al.
r pav erages r p jhotdraw correct rule .
.
.
.
.
.
pre cision .
.
je dit correct rule .
.
.
.
pre cision .
.
jf reechart correct rule .
.
.
.
.
.
pre cision .
.
sy stems ind icators a ura sc h afer et al.
r pav erages r p jhot draw correct rule .
.
.
.
.
.
pre cision .
.
st ruts correct rule .
.
.
.
.
pre cision .
.
t otal pre cision of aura .
av erage r .
p .
t able comparison of the results on medium size systems with simply deleted change rules.
sy stems a ura se mdi org.e clipse.
errors in scope jdt.d ebug.ui found rules .
.
correct rules my lyn errors in scope .
.
found rules correct rules jb osside errors in scope .
.
found rules correct rules pr ecision .
t able evaluation of a sample of change rules on the large system.
aura compared to the two approaches r is .
with a precision of .
while p is .
.
comparison with m. kim et al.
s approach.
m. kim et al.
present their results in two formats rst order relational logic rules for example all methods in class a replaced by the same name methods in class b except methods a and b and matches for example a.c a b.d .
the latter format corresponds to the change rules of aura.
therefore we use the number of matches from to compare their results with ours.
on average pis .
while r is .
.
we gain in recall at the small expense of precision.
on jhotdraw from .
to .
and jfreechart from .
.
to .
.
the rs are .
and .
while the ps are .
and .
respectively.
these results show that the combination of call dependency and text similarity analyses improves recall with precision comparable to approaches based on text similarity analyses.
a slight decrease of precision .
is acceptable because the recall increases satisfactorily .
.
on jedit from .
to .
the r is .
while p is .
.
the p decrease is is twice as much as that of jhostdraw from .
to .
.
two factors cause this decrease.
first call dependency analysis is more sensitive to structural changes than text similarity analysis.
in jedit .
the api remained quite stable but the implementation of the methods changed radically.
aura rst uses call dependency analysis that generates irrelevant change rules that could be avoided if it used text similarity analysis directly.
second aura does not use any experimentally evaluated thresholds that would help balancing recall and precision.comparison with sch fer et al.
s approach.
on average p is .
while ris .
.
aura has positive r and pboth on jhotdraw from .
to .
and struts from .
to .
.
in comparison to sch aferet al.
s .
on jhotdraw from .
to .
the rand p are .
and .
while they are .
and .
on struts from .
to .
.
.
text similarity analysis is the main contributor to the improvements.
in our evaluation the change rules of .
target methods of jhotdraw from .
to .
are detected by call dependency analysis while the number for struts from .
to .
.
is only .
.
text similarity analysis generates the change rules for the other target methods.
in sch aferet al.
s results more change rules were identi ed than by aura using call dependency analysis because they also generate other types of change rules that are not in the scope of aura such as change rules for elds inheritance relations and methods existing in both the old and new releases.
aura only generates change rules for methods that physically disappeared in the new release.
.
comparison on a large size system in table we present the results of aura and semdi to solve the compile errors of three eclipse .
plug ins when compiling them against eclipse .
.
in semdi correct rules are de ned as replacement methods that can be found in the top three recommendations provided by semdi .
it is easy for developers to choose the right replacement from these three.
in our approach we provide only one recommendation per target method.
therefore to compare the results of aura with those of semdi we must account for this discrepancy in the way correct rules are counted.
if every correct rule was the rst recommendation of the top three semdi would have a precision of .
comparable to the precision of .
of aura.
however it is also possible that the correct rule was the second or third of the top three.
consequently for the rst recommendation the precision of semdi could be actually less than thus aura is competitive with semdi .
3a ura only analyzed the packages org.gjt.sp.
and compared its results with those of m. kim et al.
.
these packages contain the code for jedit main functions and are large enough for manual analysis target methods .
4con rmed by dagenais it is .
.
.5comparison w o simply deleted methods previous approaches such as do not explicitly report simply deleted change rules in their results.
we remove the simply deleted change rules from aura results and compare these with the results of the previous approaches to assess their in uence on precision and recall.
as shown in table pis stable and remains similar to that with simply deleted method rules .
vs .
.
rdecreases from .
to .
.
the rs of aura to the two approaches are di erent.
the rto kim et al.
s approach decreases to .
while the r to sch aferet al.
s approach drops to .
.
the sharp decrease of rhas two causes.
first large number of target methods are deleted from the new releases without replacements.
through manual inspection we found that on average .
of target methods in the change rules generated by aura are simply deleted from the new releases of the four medium size systems.
for struts from .
to .
.
this percentage is as high as methods .
second aura and sch aferet al.
s approach have di erent scopes so rdecreases dramatically.
even with this decrease of r on struts from .
to .
.
.
.
aura still improves recall with similar precision when not considering simply deleted method rules.
.
performance since the analyses of aura and of the previous approaches were conducted on di erent hardware and software platforms the reported performance data are only descriptive and we will not compare them.
the analysis of the four medium size systems takes less than three minutes on windows xp sp3 with intel core duo .5ghz and 4gb ram.
m. kim et al.
report computation times of seven minutes on average while sch afer et al.
report less than minutes but do not specify their software and hardware platforms.
analysing eclipse jdt core and ui .
.
takes seven hours on centos .
with amd opteron dual core .4ghz and 16gb ram.
semdi took hours on a pentium d .2ghz with 2gb of ram running ubuntu server .
.
.
threats to validity we now discuss the threats to validity of our evaluation following the guidelines provided for case study research .
construct validity threats concern the relation between theory and observation in our context they are mainly due to errors introduced in the algorithm and the manual validation.
we are aware that we could have introduced a bias during the manual validation of the change rules produced by aura.
we did our best to avoid this bias and provide all data on line for further independent validation5.
aura in step uses a random selection that could also introduce variation in our results.
however these variations should occur very rarely.
threats to internal validity do not a ect this study being a systematic comparison of aura with the previous approaches using well de ned measures p and r .
conclusion validity threats concern the relation between the treatment and the outcome.
we used un biased systematic measures and the data provided by the authors of the previous approaches without any changes other than those discussed in section .
thus we believe that no threats to the validity of our conclusion remain.reliability validity threats concern the possibility of replicating this study.
we attempted here to provide all the necessary details to re implement aura and replicate its evaluation and comparison.
moreover all studied systems and data from the previous approaches are publicly available or available upon request to their authors.
the raw data on which our study is based are available on the web5.
threats to external validity concern the possibility to generalize our ndings.
we studied ve systems of di erent size belonging to di erent domains and evaluated by the previous approaches.
however we only analyzed java code therefore it is possible that aura would perform di erently on other programming languages like c or c .
further validation on a larger set of systems and comparison with other approaches are desirable.
.
discussion we now discuss the strengths and limitations of aura.
.
strengths higher recall and comparable precision.
the evaluation results show that aura has higher recall than and comparable precision to those of previous approaches.
three factors contribute to the improvement .
combination of call dependency and text similarity analyses.
approaches using call dependency analysis can only nd change rules whose target and replacement methods are called by some anchors.
for the ve systems that we analyzed on average only .
of the change rules are found by call dependency analysis.
sch aferet al.
can nd more rules because they also generate other types of change rules besides target method change rules.
approaches using text similarity analysis nd rules for all target methods but with a higher rate of false positives.
in practice they trade o recall for precision using thresholds.
aura is able to nd change rules for more target methods than previous approaches but with a slight loss of precision.
the evaluation results show that the r of aura is .
with about .
lower precision on average.
.
multi iteration algorithm.
the multi iteration algorithm improves both recall and precision.
it impacts positively the results in two cases the rst case is illustrated in section the second case occurs by removing the replacement methods of other already detected target methods from the candidate replacement method set of a target method.
for example if the candidate set of m is fa b g and in a previous iteration aura detected that a is the replacement of x then aura removes a from the candidate replacement method set of m and immediately identi es its replacement as b .
this second case does not preclude identifying many to one change rules in a previous iteration.
on the four medium size systems the average precision decreases by .
if we a use a one iteration algorithm calculated after both call dependency and textsimilarity analyses.
.
three unit text similarity.
aura uses signaturelevel similarity ld and lcs to compute the text similarity of two methods.
on the four medium size systems the average precision decreases by .
.
and .
if we remove each step respectively.
332sy stems indi cators a ura m. kim et al.
r pav erages r p jhotdraw correct rule .
.
.
.
.
.
p recision .
.
jed it correct rule .
.
.
.
p recision .
.
jf reechart correct rule .
.
.
.
.
.
p recision .
.
sy stems indi cators a ura sc h afer et al.
r pav erages r p jhot draw correct rule .
.
.
.
.
.
p recision .
.
st ruts correct rule .
.
.
.
.
p recision .
.
pre cision of aura .
t otal r .
av erage p .
t able comparison of the results on medium size systems without simply deleted change rules many to one one to many simply deleted rules.
previous approaches only automatically generate one toone change rules.
some approaches can semi automatically generate many to one and one to many rules but developers must manually analyze the rules to select the appropriate replacement methods.
aura applies a calldependency analysis rst and then uses a text similarity analysis to overcome this limitation of previous approaches.
none of the previous automatic approaches explicitly reports simply deleted method change rules.
we manually identi ed that in the four medium size systems .
of target methods in the change rules that aura generated are simply deleted.
we argue that simply deleted method rules are as important as other types of change rules because they are a part of the total change rules of a program.
they should be identi ed evaluated and counted in the precision and recall computation.
threshold.
existing automatic approaches which do not require framework developers involvement depend on experimentally evaluated thresholds.
these thresholds cannot be predicted for a new framework without analyzing it and evaluating the result.
we could use the values of the tuned thresholds for some frameworks already analyzed but they might not be applicable.
aura completely eliminates thresholds and adapts naturally to di erent frameworks.
it could therefore be used immediately by developers without any settings.
.
limitations aura cannot detect one to many and many to one change rules for target methods that are not called by any anchor.
however it can still nd one to one rules using text similarity analysis.
major changes to the internal implementation of anchors compromise the precision of aura.
for example the precision of aura for jedit from .
to .
decreases by .
wrt.
m. kim et al.
s because between the two releases the api remained quite stable but the implementation of the methods changed radically thus confusing the rst steps of our approach based on call dependency analysis.
this limitation is shared by all call dependency based approaches.
aura only generates change rules for methods.
during the evaluation of aura we found that some getters arereplaced by direct eld accesses.
future work includes modifying the de nition of change rules to take into account eld and type related changes by analyzing inheritance relations and polymorphism.
.
conclusion and future work we presented aura an hybrid approach that combines call dependency and text similarity analyses to provide developers with change rules when adapting their programs from one release of a framework to the next.
our approach o ers the following contributions .
it increases recall by combining call dependency and text similarity analyses in a multi iteration algorithm .
it automatically adapts to di erent frameworks by not using any experimentally evaluated threshold .
it reduces developers e orts by automatically generating one to many and many to one change rules.
the results of the evaluation of aura on four mediumsize systems and in comparison to previous work showed that the combination of call dependency and text similarity analyses into a multi iteration algorithm improves recall on average by .
with a slight decrease of .
in precision.
we also applied aura on eclipse and compared its results with those of semdi and showed that the approximated precision of aura is .
while semdi s is up to .
.
in future work we plan to extend our approach in several directions analyze target systems in other programming languages than java add heuristics that generate change rules for types and elds by analyzing inheritance relations and polymorphism combine aura with approaches that use other matching techniques present aura results in rst order relational logic rules as introduced by m. kim et al.
perform usability studies to determine the e cacy of aura.
.