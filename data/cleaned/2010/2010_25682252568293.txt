enhancing symbolic execution with veritesting thanassis avgerinos alexandre rebert sang kil cha and david brumley carnegie mellon university thanassis alexandre sangkilc dbrumley cmu.edu abstract we present mergepoint a new binary only symbolic execution system for large scale testing of commodity off the shel f cots software.
mergepoint introduces veritesting a new technique that employs static symbolic execution to amplify the effect of dynamic symbolic execution.
veritesting allows mergepoint to find twice as many bugs explore orders of magnitude more paths and achieve higher code coverage than previous dynamic symbolic execution systems.
mergepoint is currently running daily on a node cluster analyzing linux binaries has generated more than billion smt queries million test cases crashes and found bugs in distinct applications.
categories and subject descriptors d. .
testing and debugging symbolic execution f. .
semantics of programming languages program analysis general terms algorithms security verification keywords veritesting symbolic execution verification .
introduction symbolic execution is a popular automatic approach for testing software and finding bugs.
over the past decade numerous symbolic execution tools have appeared both in academia and industry demonstrating the effectiveness of the technique in finding crashing inputs generating test cases with high coverage exposing software vulnerabilities and generating exploits .
symbolic execution is attractive because it systematically explores the program and produces real inputs.
symbolic execution works by automatically translating a program fragment to a logical formula.
the logical formula is satisfied permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.by inputs that have a desired property e.g.
they execute a specific path or violate safety.
at a high level there are two main approaches for generating formulas.
first dynamic symbolic execution dse explores programs and generates formulas on a per path basis.
second static symbolic execution sse translates program statements into formulas where the formulas represent the desired property over any path within the selected statements.
in this paper we describe mergepoint a system for automatically checking all programs in a linux distribution using a new technique called veritesting .
the path based nature of dse introduces significant overhead when generating formulas but the formulas themselves are easy to solve.
the statement based nature of sse has less overhead and produces more succinct formulas that cover more paths but the formulas are harder to solve.
veritesting alternates between sse and dse.
the alternation mitigates the difficulty of solving formulas while alleviating the high overhead associated with a path based dse approach.
in addition dse systems replicate the path based nature of concrete execution allowing them to handle cases such as system call s and indirect jumps where static approaches would need summaries or additional analysis.
alternating allows mergepoint with veritesting to switch to dse based methods when such cases are encountered.
mergepoint operates on bit linux binaries and does not require any source information e.g.
debugging symbols .
we have systematically used mergepoint to test and evaluate veritesting on binaries from debian linux.
the binaries were collected by downloading and mining for executable programs all available packages from the debian main repository.
we did not pick particular binaries or a dataset that would highlight specific aspects of our system instead we focus on our system as experienced in the general case.
the large dataset allows us to explore questions with high fidelity and with a smaller chance of per program sample bias.
the binaries are exactly what runs on millions of systems throughout the world.
we demonstrate that mergepoint with veritesting beats previous techniques in the three main metrics bugs found node coverage and path coverage.
in particular mergepoint has found distinct bugs by stack hash in different programs.
overall mergepoint has generated over billion smt queries and created over million test cases.
out of the bugs result in user input overwriting the instruction pointer and we have confirmed shell spawning exploits for .permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
our main contributions are as follows.
first we propose a new technique for symbolic execution called veritesting.
second we provide and study in depth the first system for testing every binary in an os distribution using symbolic execution.
our experiments reduce the chance of per program or per dataset bias.
we evaluate mergepoint with and without veritesting and show that veritesting outperforms previous work on all three major metrics.
finally we improve open source software by finding over bugs and generating millions of test cases.
debian maintainers have already incorporated patches due to our bug reports.
we have made our data available on our website .
.
overview at a high level symbolic execution can be partitioned into two main approaches dynamic symbolic execution for testing and static symbolic execution for verification.
dynamic approaches work by generating per path formulas to test specific paths while static based approaches generate formulas over entire programs with the goal of verifying overall safety.
our main insight is to carefully alternate between the two schemes to harness the benefits of both while mitigating path explosion in dynamic approaches and solver blowup in static approaches.
in particular we start with dynamic symbolic execution but switch to a static verification based approach opportunistically.
when we switch to static mode we only check program fragments with the goal of testing not verification.
while we are not the first to suggest using static and dynamic techniques in combination the careful application of alternation as proposed in veritesting reduces overall overhead and results in improved performance along key metrics.
previous approaches typically lost on at least one metric and sometimes several.
in this section we provide a high level overview of standard metrics the key parts of dynamic and static algorithms as well as the tradeoffs between approaches.
.
testing metrics testing systems including dynamic symbolic execution sys tems are typically evaluated using three metrics number of real bugs found node coverage and path coverage.
node or code or line or statement coverage measures the percentage of code covered by generated test cases with respecttotheentireapplication.
nodecoverageisaneffective way of measuring the performance of a test case generation system andhasbeenusedrepeatedlytomeasuresymbolic execution systems performance .
path coverage measures the percentage of program paths analyzed.
unlike node coverage which has a finite domain the total number of program statements many programs have a potentially infinite number of paths e.g.
a server and measuring the path coverage is not possible.
in our evaluation we use three distinct metrics for approximating path coverage .
.
the number of unique bugs is measured by counting the number of unique stack hashes among crashes.
we report bugs only when a generated test case can produce a core file during concrete execution.
all three metrics are important and none dominates in all scenarios.
for example node coverage is useful but even node coverage may fail to find real bugs.
also it may be possible to achieve node coverage but never execute a loop more than once.
bugs that require several iterationsalgorithm dynamic symbolic execution algorithm with and without veritesting input initial location l0 instruction decoder instrat data worklistw path predicate symbolic store 1w l0 true initial worklist 2whilew ne ationslash do l w picknext w symbolically execute the next instruction 4switchinstrat l do 5casev e assignment 6s succ l 7caseif e gotol conditional jump 8e eval e 9if issat e issat e then dse forks states 11s l e succ l e veritesting integration 11s cfg cfgrecovery l cfge transitionpoints cfgreduce cfg out staticsymbolic cfge forpoint transitionpoints do ifout ne ationslash then 17s out s 18s finalize s else ifissat e then 20s l e elses succ l e 22caseassert e assertion e eval e ifissat e thenreportbug e 25s succ l e 26casehalt continue end of path 27w w s to trigger e.g.
buffer overflows will be missed.
testing more paths is better but an analysis could game the metric by simply iterating over fast to execute loops more times and avoiding slow execution paths.
again bugs may be missed and nodes may not be covered.
one could find all bugs but never know it because not all paths are exhausted.
.
dynamic symbolic execution dse algorithm presents the core steps in dynamic symbolic execution.
the algorithm operates on a representative imperative language with assignments assertions and conditiona l jumps adapted from previous work .
a symbolic executor maintains a state l where lis the address of the current instruction is the path predicate and is a symbolic store that maps each variable to either a concrete value or an expression over input variables.
a satisfying assignment typically checked by a sat or smt solver is an assignment of values to symbolic input variables that will execute the same execution path.
an unsatisfiable path predicate means the selected path is infeasible.
on line the algorithm initializes the worklist with a state pointing to the start of the program.
the picknext function selects the next state to continue executing and removes it from the worklist s. there are a variety of search heuristics for selecting the next instruction to execute including starting with a concrete trace generational1084search dfs and bfs.
symbolic execution switches over the instruction types in line .
safety checks are performed with assertions.
for example every memory dereference is preceded by an assertion that checks whether the pointer is in bounds.
the semantics of assignment assert and halt are all straightforward.
the central design point we focus on in this paper is handling a branch instruction shown in line .
the two instances of line contrast our approach with others .
in dse whenever both branches are feasible two new states are added to the worklist one for the true branch and one for the false a process we refer to as forking .
each one of the forked executors is later chosen from the worklist and explored independently.
advantages disadvantages.
forking executors and analyzing a single path at a time has benefits the analysis code is simple solving the generated path predicates is typically fast e.g.
in sage of all queries takes less than second since we only reason about a single path and the concrete path specific state resolves several practical problems.
for example executors can execute hard to model functionality concretely e.g.
system calls side effects such as allocating memory in each dse path are reasoned about independently without extra work and loops are unrolled as the code executes.
the disadvantage is the path or state explosion1problem the number of executors can grow exponentially in the number of branches.
the path explosion problem is the motivation for our veritesting algorithm .
.
static symbolic execution sse static symbolic execution sse is a verification technique for representing a program as a logical formula.
potential vulnerabilities are encoded as logical assertions that will falsify the formula if safety is violated.
calysto and saturn are example sse tools.
because sse checks programs not paths it is typically employed to verify the absence of bugs.
as we will see veritesting repurposes sse techniques for testing program fragments instead of verifying complete programs.
the main change is on line of algorithm .
modern sse algorithms can summarize the effects of both branches at path confluence points.
in contrast dse traditionally forks off two executors at the same line which remain subsequently forever independent.
due to space we do not repeat complete sse algorithms here and refer the reader to previous work .
shows our sse algorithm using a dataflow framework.
advantages disadvantages.
unlike dse sse does not suffer from path explosion.
all paths are encoded in a single formula that is then passed to the solver note the solvermaystillhavetoreasoninternallyaboutanexponentia l number of paths .
for acyclic programs existing techniques allow generating compact formulas of size o parenleftbig n2 parenrightbig wherenis the number of program statements.
despite these advantages over dse state of the art tools still have trouble scaling to very large programs .
problems include the presence of loops how many times should they be unrolled?
formula complexity are the formulas solvable if we encode loops and recursion?
the absence of concrete state what is the concrete environment the program is running in?
as well as unmodeled behavior a kernel 1depending on the context the two terms may be used interchangeably an execution state corresponds to a program path to be explored.model is required to emulate system calls .
another hurdle is completeness for the verifier to prove absence of bugs all program paths must be checked.
.
veritesting dse has proven to be effective in analyzing real world programs .
however the path explosion problem can severely reduce the effectiveness of the technique.
for example consider the following line program that counts the occurrences of the character b in an input string 1intcounter values 2for i i i if input b counter values 7if counter bug the program above has 2100possible execution paths.
each path must be analyzed separately by dse thus making full path coverage unattainable for practical purposes.
in contrast two testcases suffice for obtaining full code coverage a string of b s and a string with no b s. however finding such test cases in the 2100state space is challenging2.
we ran the above program with several state of the art symbolic executors including klee s2e mayhem and cloud9 with state merging .
none of the above systems was able to find the bug within a hour time limit they ran out of memory or kept running .
veritesting allows us to find the bug and obtain full path coverage in seconds on the same hardware.
veritesting starts with dse but switches to an sse style approach when we encounter code that similar to the example above does not contain system calls indirect jumps or other statements that are difficult to precisely reason about statically.
once in sse mode veritesting performs analysis on a dynamically recovered cfg and identifies a core of statements that are easy for sse and a frontier of hard to analyze statements.
the sse algorithm summarizes the effects of all paths through the easy nodes up to the hard frontier.
veritesting then switches back to dse to handle the cases that are hard to treat statically.
conceptually the closest recent work to ours is dynamic state merging dsm by kuznetsov et al.
.
dsm maintains a history queue of dse executors.
two dses may merge depending on a separate and independent heuristic for smt query difficulty if they coincide in the history queue.
fundamentally however dsm still performs per path execution and only opportunistically merges.
veritesting always merges using sse not dse on all statements within a fixed lookahead.
the result is veritesting formulas cover more paths than dse at the expense of longer smt queries but avoid the overhead of managing a queue and merging path based executors.
in the rest of this section we present the main algorithm and the details of the technique.
.
the algorithm in default mode mergepoint behaves as a typical dynamic concolic executor .
it starts exploration with a concrete seed and explores paths in the neighborhood of the original 2for example parenleftbig100 parenrightbig 278paths reach the buggy line of code.
the probability of a random path selection strategy finding one of those paths is approximately278 .1085loop unknown model retsystem call exit3 2entry a unreachable node transition points2a retsystem call exit32entry incomplete loop1 b figure veritesting on a program fragment with loops and system calls.
a recovered cfg.
b cfg after transition point identification loop unrolling.
unreachable nodes are shaded.
seedfollowingagenerationalsearchstrategy .
mergepoint does not always fork when it encounters a symbolic branch.
instead mergepoint intercepts the forking process as shown in line of algorithm of dse and performs veritesting.
algorithm presents the high level process of veritesting.
the algorithm augments dse with new steps .cfgrecovery recovers the cfg reachable from the address of the symbolic branch .
.
.cfgreduce takes in a cfg and outputs candidate transition points and a cfg e an acyclic cfg with edges annotated with the control flow conditions .
.
transition points indicate program locations where dse may continue.
.staticsymbolic takes the acyclic cfg eand current execution state and uses sse to build formulas that encompass all feasible paths in the cfg e. the output is a mapping from cfg enodes to sse states .
.
.finalize given a list of transition points and sse states returns the dse executors to be forked .
.
.
cfg recovery the goal of the cfg recovery phase is to obtain a partial control flow graph of the program where the entry point is the current symbolic branch.
we now define the notion of underapproximate and overapproximate cfg recovery.
a recovered cfg is an underapproximation if all edges of the cfg represent feasible paths.
a recovered cfg is an overapproximation if all feasible paths in the program are represented by edges in the cfg.
statically recovering a perfect non approximate cfg on binary code is known to be a hard problem and the subject of active research .
a recovered cfg might be an underapproximation or an overapproximation or even both in practice.
veritesting was designed to handle both underapproximated and overapproximated cfgs without losing paths or precision see .
.
mergepoint uses the cfg recovery mechanism from our binary analysis platform bap .
the algorithm is customized to stop recovery at function boundaries system calls and unknown instructions.
the output of this step is a partial possibly approximate intra procedural control flow graph.
unresolved jump targets e.g.
ret call etc.
are forwarded to a generic exitnode in the cfg.
figure 1a shows the form of an example cfg after the recovery phase.
.
transition point identification unrolling once the cfg is obtained mergepoint proceeds to identifying transition points.
transition points define the boundary of the sse algorithm where dse will continue exploration .
to calculate transition points we require the notion of postdominators and immediate postdominators definition postdominator .
a node d postdominates a node n denoted as pdom d n iff every path from n to the exit of the graph goes through d. definition immediate postdominator .
a node d immediately postdominates node n denoted as ipdom d n iff pdom d n z ne ationslash d pdom d z pdom z n .
transition points.
for an entry node eending in a symbolic branch a transition point is defined as a node n such that ipdom e n .
for a fully recovered cfg a single transition point may be sufficient e.g.
the bottom node in figure 1a.
however for cfgs with unresolved jumps or system calls any predecessor of the exitnode will be a possible transition point e.g.
the retnode in figure 1b .
transition points represent the frontier of the visible cfg which stops at unresolved jumps function boundaries and system calls.
the number of transition points gives an upperbound on the number of states that may be forked.
unrolling loops.
loop unrolling represents a challenge for static verification tools.
however mergepoint is dynamic and can concretely execute the cfg to identify how many times each loop will execute.
the number of concrete loop iterations determines the number of loop unrolls.
mergepoint also allows the user to extend loops beyond the concrete iteration limit by providing a minimum number of unrolls.
to make the cfg acyclic back edges are removed and forwarded to a newly created node for each loop e.g.
the incomplete loop node in figure 1b which is a new transition point that will be explored if executing the loop more times is feasible.
in a final pass the edges of the cfg are annotated with the conditions required to follow the edge.
the end result of this step is a cfg eand a set of transition points.
figure 1b shows an example cfg without edge conditions after transition point identification and loop unrolling.
.
static symbolic execution given the cfg e mergepoint applies sse to summarize the execution of multiple paths.
previous work first converted the program to gated single assignment gsa and then performed symbolic execution.
in mergepoint we encode sseasasinglepassdataflowanalysiswheregsaiscomputed on the fly.
table presents the sse algorithm following standard notation .
to illustrate the algorithm we run sse on the following program if x y else if x y figure shows the progress of the symbolic store as sse iterates through the blocks.
sse starts from the entry of the cfg eand executes basic blocks in topological order.
basic blocks contain straightline code and execution follows algorithm taking as input from in a path context and a symbolic store and outputting the updated versions forout .
enables multi path sse by encoding the conditionals required to follow an execution path using ite1086false falsetruetrueb1 if x b2 if x b6 b4 y b5 b3 y figure symbolic store transformations during sse.
algorithm veritesting transfer function input basic block b path context symbolic store 1foreach inst bdo 2switchinstdo casev e caseassert e 7return if then else expressions.
for example following the true branch after the condition x in figure gives ite x where denotes the taken path and the non taken.
tocomputetheinputset in forabasicblockweapply a meet operation across all incoming states from predecessor blocks following algorithm .
the path context is obtained for each incoming edge and then applied to the symbolic store.
for example for the edge from b3 to b6 in figure is updated to y 3 ite x .
to merge s or s from paths that merge to the same confluence point we apply the following recursive merge operationmto each symbolic value m v1 v1 m v2 v2 m ite e v1 v2 ite e v v ite e m v1 v m v2 v this way at the last node of figure the value of ywill be m ite x ite x ite x y0 which is merged to ite x ite x y0 capturing all possible paths.
during sse mergepoint keeps a mapping from each traversed node to the corresponding state out .
note that values from unmerged paths values can be immediately simplified e.g.
ite e x x. handling overapproximated cfgs.
at any point during sse the path predicate is computed as the conjunction of the dse predicate dseand the sse predicate computed by substitution sse .
mergepoint uses the resulting predicate to perform path pruning lines and in algorithm offering two advantages any infeasible edges introduced by cfg recovery are eliminated and our formulas only consider feasible paths.algorithm veritesting meet function input basic block b pred.
blocks b1 b2 store dse 1function context b parent begin 2 out parent taken e edge parent b 3e eval e dse 4iftaken issat e then return 6else if taken issat e then return 8else return infeasible edge 9 1 context b b1 2 context b b2 10 m 1 2 11foreach v 2do m 1 2 13return .
transition point finalization after the sse pass is complete we check which states need to be forked.
we first gather transition points and check whether they were reached by sse line in algorithm .
for the set of distinct based on their jump target address transition points mergepoint will fork a new symbolic state in afinalize step where a dse executor is created l using the state of each transition point.
generating test cases.
though mergepoint can generate an input for each covered path that would result in an exponential number of test cases in the size of the cfg e. by default we only output one test per cfg node explored by static symbolic execution.
note that for branch coverage the algorithm can be modified to generate a test case for every edge of the cfg.
the number of test cases can alternatively be minimized by generating test cases only for nodes that have not been covered by previous test cases.
underapproximated cfgs.
last before proceeding with dse veritesting checks whether we missed any paths due to the underapproximated cfg.
to do so veritesting queries the negation of the path predicate at the exitnode the disjunction of the path predicates of forked states .
if the query is satisfiable an extra state is forked to explore missed paths.
incremental deployment .
veritesting is an online algorithm it runs as the program executes.
if any step of the veritesting algorithm fails the system falls back to dse until the next symbolic branch.
an advantage of this approach table sse as a dataflow algorithm.
in and out denote the input and output sets of basic blockb.
domain symbolic execution state direction forwards transfer function algorithm boundary initial execution state init initialize out dataflow equationsin logicalandtext p pred b out out fb in meet function algorithm 31087figure mergepoint architecture.
is that the implementation can be gradually deployed supporting all possible programming constructs is not necessary since veritesting runs on a best effort basis.
.
mergepoint architecture the ultimate goal of mergepoint is to perform effective testing on thousands of applications.
in this section we provide a high level description of the system and key design choices .
.
overview mergepoint follows the design of a concolic executor.
the symbolic execution engine runs on top of an instrumentation tool and x86 instructions are jited to an intermediate representation before being symbolically executed.
a taint analysis layer ensures that the symbolic executor is used only when necessary i.e.
only for instructions operating on input derived data.
the layers of the mergepoint executor are shown on the left of figure .
to enable veritesting the mergepoint executor is enhanced with two main modules shaded a static symbolic executor and a cfg recovery module.
in the rest of this section we discuss how the executor fits within the mergepoint distributed infrastructure .
and a key design decision in the handling of symbolic expressions .
.
.
distributed infrastructure as a stand alone tool the mergepoint executor takes in a program and a user configuration including a time limit inputs etc.
and outputs test cases bugs and statistics.
one goal of mergepoint is to test software en masse.
however a single minute experiment on programs requires almost weeks of cpu time.
to test our techniques we developed a distributed infrastructure that utilizes multiple nodes to run programs in parallel.
figure presents the end to end architecture of mergepoint.
mergepoint employs a first come first served central queuing policy.
the policy is simple yet yields high utilizati on a program waiting at the top of the dispatcher queue is sent to the next available symbolic executor instance.
data generated at every node are aggregated and stored in centralized storage.
we use stored data as an immediate feedback mechanism about the performance behavior of the symbolic executor on a large number of programs.
the feedback mechanism served as a guide on several design choices e.g.
using a hash consed language .
.
s42 s ss s s ss a s b x s s is symbolic x x x x x x x x x assert x figure hash consing example.
top left na vely generated formula.
top right hash consed formula.
.
a hash consed expression language whenever a program variable is used in an expression eval in algorithm replaces it with its value in the symbolic store.
a na ve substitution algorithm may introduce an exponential blowup even for a straightline program.
for example the path predicate for figure is s s s s s s s s where there are uses of the svariable .
hash consing is a technique for avoiding duplication during substitution and reusing previously constructed expressions.
previous work in symbolic execution has made extensive use of hash consing variants to avoid duplicate expressions.
examples include creating maximally shared graphs using expression caching or ensuring that structurally equivalent expressions that are passed to the smt solver are reused .
mergepoint goes one step further and builds hash consing intothe language.
the constructor for every expression type is hash consed by default meaning that the implementor of the symbolic executor is incapable of creating duplicate expressions.
every previously computed expression is stored and will be reused.
mergepoint also provides iterators over hash consed expressions for standard operations fold map map reduce etc.
to ensure all traversals are linear in the size of the expression.
following the approach of mergepoint stores hashconsed expressions in an array of weak