supporting domain specific state space reductions through local partial order reduction p eter bokor tu darmstadt darmstadt germany pbokor cs.tu darmstadt.dejohannes kinder epfl lausanne switzerland johannes.kinder epfl.chmarco serafini yahoo!
research barcelona spain serafini yahoo inc.comneeraj suri tu darmstadt darmstadt germany suri cs.tu darmstadt.de abstract model checkers offer to automatically prove safety and liveness properties of complex concurrent software systems but they are limited by state space explosion.
partial order reduction por is an effective technique to mitigate this burden.
however applying existing notions of por requires to verify conditions based on execution paths of unbounded length a difficult task in general.
to enable a more intuitive and still flexible application of por we propose local por lpor .
lpor is based on the existing notion of statically computed stubborn sets but its locality allows to verify conditions in single states rather than over long paths.
as a case study we apply lpor to message passing systems.
we implement it within the java pathfinder model checker using our general java based lpor library.
our experiments show significant reductions achieved by lpor for model checking representative message passing protocols and maybe surprisingly that lpor can outperform dynamic por.
i. i ntroduction the use of formal verification methods can avoid failures in the design or implementation of a system and is thus of growing importance for the development processes of complex software.
a successful and widely used method is model checking which allows the fully automated verification of temporal properties.
model checking is limited by state explosion however a fundamental problem in verification especially of concurrent systems.
the state space explosion problem can be greatly mitigated by partial order reduction por a general concept for reducing the model checking resources such as memory and time.
several notions of por implement this concept differing from each other in flexibility and efficiency.
the commonality of these approaches is that the developer of a model checker is expected to verify complex conditions to guarantee soundness.
this hurdle can prevent developers from implementing por or even lead to erroneous implementations.
in this paper we propose an approach that simplifies the conditions to be verified but gives up neither the flexibility nor theefficiency of por.
next we explain why previous notions of por are difficult to use and how our approach improves on them.
the general concept of por lies in the commutativity of non interfering transitions.
conceptually a transition is a research supported in part by ec fp7 indexys loewe tud cased and dfg tud gkmm grk .fig.
.
non interfering transitions t1andt2.
states s12 ands3are deadlocks.
mechanism to change the state of the system e.g.
a java method or the delivery of a message.
por is based on the simple observation that the execution of non interfering transitions leads to the same state irrespective of which of these transitions is executed first.
in figure t1andt2are non interfering because both paths st1 s1t2 s12 andst2 s2t1 s12 lead to s12 .
therefore it is sufficient to explore the execution of these transitions in a single representative order reducing memory and time required for model checking.
por is sound if no state is missed that is relevant for verifying the target property.
for example although t1andt2 are non interfering it is an unsound reduction to explore only the pathst1 s1t2 s12 if the property states the reachability of s3.
existing notions of por define necessary conditions of soundness that are hard to check in general because they require global knowledge about the state graph which limits the applicability of por.
this problem is usually addressed by fixing the application of por to a particular specification language and computational model such that soundness is guaranteed by construction.
as a result existing specification languages with por support are few and restrictive in different ways they consider restricted computational models for example fifo based message passing petri nets or process algebras they only allow models with deterministic transitions or acyclic state graphs they preserve only invariants or they only support bug finding .
we present a novel take on por to ease its application to rich specification languages.
we call our approach local por lpor because locality is key to simplify the verification of por conditions for designing new model checkers in fact the simplicity of lpor allows an easy development of new po reductions.
lpor consists of an input interface accessible by the user of lpor and a por algorithm hidden from the user .1at the interface of lpor the user defines locally interfering transitions whose soundness can be verified more easily than the global path based soundness conditions in other por approaches.
this local information is sufficient for our lpor algorithm to efficiently compute sound partial order reductions.
in the example of figure the user can define and verify the following local interferences t2can enable t3 when executed in s and t1is dependent on is disabled by t3 when executed in s2 .
based on this information the lpor algorithm knows that t1andt2are non interfering and can establish that exploring only the paths st2 s2t1 s12 andst2 s2t3 s3preserves all deadlock states a fundamental preservation property used by lpor to preserve more complex specifications.
in the following we further detail our main contributions.
lpor stubborn set algorithm.
lpor s interface section ii contains two intuitive relations between transitions namely can enable and dependency .
each of these relations is local i.e.
they are defined given paths of at most length two.
transitions that are not included in these relations are considered to be non interfering and are used by lpor to achieve reduction.
the user has to prove the non interferences correct but it is sound to declare transitions as interfering even when they are not.
an important feature of lpor is that non interfering transitions are completely configurable while other approaches conservatively assume certain transitions to be interfering e.g.
transitions executed by the same process .
lpor also supports necessary enabling transitions which we generalize from .
although the definition of such transitions does involve paths they naturally appear in highlevel languages.
the lpor algorithm section iii computes stubborn sets statically and supports general transition systems without assumptions about the state graph or transitions.
intuitively a stubborn set is a large enough subset of the transitions enabled in the current state e.g.
t2 in sin figure such that no deadlock state remains unvisited if only transitions in stubborn sets are executed.
lpor leverages stubborn sets to preserve properties in the temporal logic ctl x. lpor is fast thanks to a novel pre computation scheme which allows to compute information needed by lpor once before model checking and then to repeatedly use it in every new state.
applying lpor to message passing.
we instantiate the relations at lpor s interface for general message passing systems section iv .
this example also shows that the use of lpor is straightforward for domain experts.
we briefly discuss two additional lpor application examples.
first we use a petri net example in explaining the lpor 1in the remainder of this paper by user we mean the user of lpor and not necessarily the end user of the model checker.
algorithm section iii b .
second we show how the por approach used in the spin model checker can be expressed in lpor terms section vii .
experiments and comparison with dpor.
we implement lpor as an openly available java library called java lpor section v that easily integrates with existing model checkers.
as an example use case of java lpor we implement our message passing instantiation of lpor in the java pathfinderbased model checker mp basset .
we evaluate the efficiency of lpor using message passing examples.
our experiments with mp basset show that lpor achieves significant up to time and space reductions for model checking real world fault tolerant message passing protocols section vi .
furthermore countering current notions of dynamic por being superior to static por we also show that lpor implementing static por competitively improves upon dynamic por without entailing the constraints of dynamic por.
ii.
t he lpor i nterface the typical application scenario of lpor is adding por to the analysis of systems written in some specification language.
assume that a model checker implementing the lpor algorithm section iii is available for this language.
we will show in section v how we support the integration of lpor into existing model checkers.
now the user an expert in the domain of the language must provide two inputs at lpor s interface.
first unless it is not already available she must define the semantics of the language in terms of a state transition system section ii a .
second based on her domain specific knowledge she defines and proves two intuitive relations containing pairs of interfering transitions section ii b .
these relations are local considering paths of length at most two.
lpor leverages a third optional relation which is not strictly local but naturally appears in high level languages.
a. non deterministic state transition systems a state transition system sts is a triple s t s where sis the set of states tis the set of transitions and s0 s is the set of initial states.
every transition t tis a relation t s s. a transition tis enabled in s siff there is an s ssuch that s s t. otherwise tis disabled in s. the set of all enabled transitions in sis denoted by enabled s .
a states sis called a deadlock if enabled s .
we write s0t1t2...t n snand say that there is a path from s0to sniff for every i n we have that si s i ti .
in this case we say that snis reachable froms0.
if s0 s0 then we say that snis reachable.
a transitions tis said to be in a paths0t1t2...t n snif tis among t1 t ... t n. our approach allows transitions to be non deterministic i.e.
given t tands s there might be multiple s ssuch that s s t. other approaches e.g.
are restricted to deterministic transitions.
on the one hand while a transition system always allows to refine a non deterministic transition into several deterministic transitions an implementation of such a refinement is not necessarily straightforward for a particular system model.
furthermore the performance of por algorithms can be adversely affected by an increase in t the number of all transitions.
on the other hand refining transitions can improve space reduction since only some of the refined transitions might have to be contained in a stubborn set .
not requiring deterministic transitions leaves a larger design space for exploring trade offs in transition refinement.
b. interfering transitions a transition tcan enable another transition t if in at least one state where t is disabled executing tresults in a state wheret is enabled.
we say that a relation is can enabling if it is a superset of all pairs t t of transitions such that tcan enablet .
definition a relation ce t tis can enabling iff ce t t s s s st s t atio slash enabled s t enabled s .
we define that t is dependent on tif both tandt are enabled in some state tandt are co enabled and either a tcan disable t or b their subsequent execution in different orders results in different states tandt do not commute .
by convention tis not dependent on itself.
we say that two transitions are dependent independent if one none of them is dependent on the other.
note that the following relation is not necessarily symmetric.
definition a relation dep t tis a dependency relation iff dep t t t atio slash t s s s t t enabled s st s and either a t atio slash enabled s or b s s stt s and notst t s .
next we define a relation that contains a pair of transitions tandt if t is a necessary enabling transition net fort i.e.
t must be executed at least once for tto be enabled adapted from necessary enabling sets .
note that this relation is based on paths.
it is purely optional though as it is sound to not include pairs of transitions in a net relation or in particular to define an empty one.
similarly it is always sound to include a pair of even non interfering transitions in can enabling and dependency relations.
definition a relation net t tis a necessary enabling transition net relation iff net t t s0 s0 s s t1 ... t n t if s0t1t2...t n s t enabled s then t tifor some i n .
note that the transitive closure of every net relation is also a net relation.
every user provided net relation can thus be extended to its closure.
iii.
t he lpor s tubborn set algorithm now we present lpor our local partial order reduction algorithm.
formally lpor computes stubborn sets which are subsets of enabled s in a state ssuch that it is sufficient to explore transitions in such a subset.
lpor can be configured to preserve properties from simple deadlock freedom to arbitrary ltl xand ctl xspecifications.
lpor can be adapted to similar por semantics such as ample or persistent sets .
we chose stubborn sets because they allow the most relaxed system model.
for example both persistent and ample sets assume deterministic transitions.
lpor is a static por algorithm i.e.
given a state sof the system lpor outputs a stubborn set in swithout further exploration as opposed to dynamic por .
therefore lpor can be implemented in stateful even parallel explicit state model checking.
we present a simplified variant of the lpor algorithm that assumes that the search path i.e.
a path from an initial state to s is available.
the search path can be obtained by depth first search.
however a generalized form of lpor makes no assumption about the search path and is compatible with both depth and breadth first search.
therefore it is amenable to symbolic binary decision diagram based implementations as well.
for space reasons the generalized lpor algorithm is presented appendix i. we first review stubborn sets section iii a then we present the core lpor algorithm and sketch its correctness i.e.
lpor indeed computes stubborn sets section iii b .
then we discuss some optimizations of lpor section iii c and the preservation of general temporal properties section iii d .
a. preliminaries stubborn sets given a state s0 a set stub s0 of transitions is weakly stubborn if the two properties d1 and d2 are satisfied .
d1 verifies the commutativity of transitions in the stubborn set with transitions outside the stubborn set.
d2 ensures that there is at least one transition that cannot be disabled by transitions outside the stubborn set.
d1 t stub s0 t1 t ... t n t stub s0 sn s if s0t1t2...t nt snthens0tt 1t2...t n sn.
d2 if enabled s0 atio slash then t stub s0 t1 t ... t n t stub s0 if s0t1t2...t n snthent enabled sn .
such a transition tis called key transition .
a stubborn set is called strong if every t stub s0 enabled s0 is a key transition.
note that a key transition is always enabled in s0.
the unreduced state graph is explored by starting from an initial state and executing every transition in enabled s when a new state sis visited.
the reduced state graph is obtained by executing only the enabled transitions fromstub s .
if t stub s andtis non deterministic then every s with s s tis visited.
d1 and d2 guarantee that all deadlocks of the unreduced state graph are contained in the reduced one.
in order to preserve properties other than deadlock freedom stub s0 needs to satisfy additional constraints .
note that transitions in stub s are not necessarily enabled in s. although disabled transitions cannot be executed they can ease the design of stubborn set algorithms and even result in smaller stubborn sets when used to preserve certain temporal properties .
2appendices are included in the technical report version of this paper available online .
function fwdenablesetidx t t forall t en fwdenableset t do if t t dep then return true return false function fwdenableset tr 4tr tr do tr tr forall t1 tdo forall t en tr do if t t ce then en en t2 t1 t net tr tr t1 en whiletr e atio slash tr return tr algorithm fwdenableset t and fwdenablesetidx t t are pre computed for every t t t. stub ti trans ti whiletrans e atio slash do chooset trans trans trans t forall t1 enabled s stub do if t1 t dep then stub stub t1 if dep is non transitive thentrans trans t1 else if fwdenablesetidx t1 t then if tdep en fwdenableset t1 tdep t dep en t2 en t2 e atio slash stub t2 then stub stub t1 trans trans t1 return stub algorithm the lpor ti s stubborn set algorithm for a state s s an initial transition ti enabled s and a current search path t .
b. the stubborn set algorithm as stated before the use of net in lpor is optional.
we therefore start out by explaining the lpor algorithm algorithm without the net optimization where net .
forward enable sets lpor uses two helper functions fwdenablesetidx t t andfwdenableset t algorithm whose return values can be pre computed before model checking because they are independent of the state.
the first function returns true if tcan be the first in a sequence of enabling transitions that enables another transition t on whicht is dependent lines .
fwdenablesetidx is defined based on the forward enable set fwdenableset t of t which contains those transitions that can be enabled through a sequence of enabling transition starting with t lines .
more precisely the set contains all transitions t such that t t is in the transitive closure of a can enabling relation ce .
the set contains tuples of the form t en wheretis a transition and en is a set of transitions which is used in the net optimized version of lpor.
if the net relation is empty en is also empty line .
we now explain how lpor uses these two functions to compute stubborn sets.
stubborn set computation in addition to the relations ce dep and net lpor has three parameters a transition ti enabled s called initial transition which is in the stubborn set the current state s and the search path t for algorithm it suffices that is a set containing t1 ... t n .
from d2 no stubborn set in scan be empty unless enabled s .
conceptually lpor proceeds similarly to other static por algorithms by applying different rules of the form iftis in the stubborn set then transitions t1 t ... must also be in the set .
in this case we say that t1 t ... are added on behalf of t. lpor maintains two sets of transitions stub which represents the stubborn set line and trans which contains a transition tin stub such that new transitions might be added to stub on behalf of t line .
therefore lpor adds transitions to stub until trans is empty lines and stub is returned line .
we now explain how transitions are added on behalf of a transition tin trans .
first we add those enabled transitions t1thattis dependent on lines .
we add t1if either t1andtdo not commute disallowed by d1 or it can disable t which can violate d2 .
note that dep does not have to be symmetric as d1 allows thattandt1do not commute.
we will show an example of this case in a message passing instance of lpor section iv .
there is another way to violate the stubborn set conditions an enabled transition t1outside the stubborn set can start a sequence of enabling transitions that enables another transition on which tis dependent d1 .
this can only happen if fwdenablesetidx t1 t is true line .
in this case we addt1to the stubborn set line .
note that the condition in lines is trivially true if lpor is run without net optimization because the en sets are empty.
in both previous cases t1is added to trans line and so that lpor can verify whether new transitions must be added on behalf of t1.
we discuss the optimization for transitive dependency relations line in section iii c. net optimization stubborn set computation can benefit from the net relation if more than one transition t2is necessary for some transition t1to be enabled.
in this case a stubborn set does not need to contain allsucht2but only one that has not been executed yet.
the net optimization cannot be fully pre computed as the check whether a transition has not been executed yet can only be carried out during the search.
however we can store these t2transitions in the en field associated with t1.
it is key to our net optimization that the content of en fields is propagated along the can enabling relation i.e.
if tcan enable t1and t en and t1 en are in a forward enable set then en en line .
this is because the transitions necessary to be executed for tto be enabled are transitively also necessary to be executed for t1to be enabled.
then using the notation of algorithm if some t2is in theen field associated with a transition tdep we can verify given the current state s that t2has not been executed yet .
assume that tdep en is in the forward enable set of t1and the conditions in lines are true.
then we only add t1 to the stubborn set if either t2is not in the stubborn set or t2has already been executed i.e.
is contained in the model checker s current search path line .
note that for some transition t t en can be in a forward enable set multiple fig.
.
a petri net example.
times with different en .
this is possible if tcan be enabled by different sequences of transitions.
example we illustrate the lpor algorithm on a simple petri net example figure .
for this net ce t3 t t4 t t5 t dep t1 t t2 t net t4 t t5 t are valid enabling dependency and net relations respectively.
note that we omit the possible t3 t t4 t and t5 t fromnet for this example.
figure depicts the initial token marking s the set of enabled transitions in sis t1 t t .
consider a run of lpor in s with initial transition t1 i.e.
lpor t1 s .
as t2is disabled in s no transition is added to the stubborn set in lines .
supposed that transitions are processed by ascending index t4is added to the stubborn set because fwdenableset t4 t4 t3 t4 t t2 t4 t t2 t dep and t4andt5are both not in the stubborn set.
however thanks to the net optimization t5is not added because fwdenableset t5 t5 t3 t4 t t2 t4 t t4 already is the stubborn set and is empty.
as a result lpor t1 s t1 t enabled s .
correctness the next theorem states that lpor indeed generates stubborn sets.
the proof of the theorem can be found in appendix ii.
a sketch of the proof is given below.
theorem let s t s be an sts and ce dep and net a can enabling dependency and net relation respectively.
then for all s s ti enabled s and t with s0 s0 s0 s lpor ti s is a stubborn set.
proof sketch.
a key property of lpor is that when executed in a state s s0 every transition tin lpor ti s is independent of all transitions t1 t ... t nthat are in a path starting from sand that are outside lpor ti s .
to show that d1 and d2 hold consider the paths starting from s0 as illustrated in figure .
we first show that tis a key transition d2 .
indirectly assume that tifor some i ncan disable t i.e.
t atio slash enabled si .
therefore tmust be dependent on ti a contradiction by the previous property.
as tis a key transition t enabled si for every i n. let s nbe a state such that sn 1tn snt s n. from the fig.
.
illustration of the proof of theorem .
above property tis independent of tn so there exists s n such that sn 1t s n 1tn s n. repeating this rule ntimes we obtain a path st s t1 s 1t2 ... tn s n 1tn s n which proves d1.
worst case complexity algorithm is guaranteed to terminate proof in appendix ii and has worst case time complexity o t t with and o t without net optimization.
despite the worst case exponential overhead of the net optimization our experiments show that lpor with net can achieve significant reductions of model checking time section vi .
we now sketch the idea behind the above complexity results.
assume that checks for set inclusion and adding removing elements to from sets take constant time.
the basic quadratic time complexity in t is due to trans containing at most t transitions line and adding at most t transitions to the stubborn set on behalf of every transition in trans line .
note that every transition in trans is also in stub and no transition is ever removed from stub.
therefore the condition in line and that enabled s is fixed throughout an execution of algorithm guarantee that every transition is added at most once to trans .
without net optimization the condition in lines is always true.
therefore no computation overhead is added in this case.
with net optimization the condition requires to range through possibly each element in a forward enable set and check if this element is in the stubborn set.
as elements of the forward enable set are tuples of a transition and a subset of transitions the maximum size of such a set is t t .
c. further optimizations and possible extensions first if the dependency relation is transitive then the enabled transition t1does not have to be added to trans line .
this is sound because all transitions that would be added to the stubborn set on behalf of t1are also added on behalf of t. lpor is a non deterministic algorithm with three main sources of non determinism each of them possibly affecting the size of the stubborn set the selection of the initial transition the selection of tin line and the order in which forall iterates through the transitions in line .
the tuning of these parameters in such a way that they result in small stubborn sets depends on the analyzed system.
we improve the net optimization by making it stateconditional i.e.
t is a net for tin a state sif tis not enabled in sandt must be in any path starting from sbeforetcan be enabled.
the details of this optimization can be found in appendix i. while state conditionality can increase the achieved state reduction it also increases the time overhead by limiting the possibilities for pre computation.
the net optimization can be generalized to necessary enabling sets i.e.
for each transition ta set t of transitions such that at least one transition in t must be executed for t to be enabled.
this gives more flexibility compared to lpor wheret contains at most one transition.
lpor computes strong stubborn sets which implies that all transitions that can disable a transition tin the stubborn set are also included in the set.
in general it is possible that a transition is removed from a strong stubborn set such that the resulting set is stubborn in the weak but not in the strong sense.
however an algorithm computing weak stubborn sets can incur a higher time overhead in lpor this would require to refine dependency in terms of can disable and might not commute relations.
d. preserving temporal logics with lpor the reduced search using stubborn sets preserves all deadlocks of the unreduced state graph.
in order to preserve other properties such as invariants or liveness stubborn sets must satisfy constraints in addition to d1 and d2.
lpor can be configured to preserve a general class of properties written in ctl x computational tree logic without the next operator .
subclasses of this logic include simple invariants or ltl x linear temporal logic without the next operator .
for details of how lpor can be used to preserve ctl x properties we refer the reader to appendix iii.
iv.
a c ase study lpor for message p assing we now briefly introduce a general language for messagepassing systems with detailed formalization in appendix v and define suitable lpor relations from section ii .
the simplicity of these definitions shows that the use of lpor is indeed straightforward for domain experts.
a. specifying message passing systems a message passing mp system or protocol consists of processes that communicate via messages .
every process maintains a local state that is updated by executing local guarded transitions from a set t. a transition tis executed by process id t if the guard of tevaluates to true the guard depends on the incoming messages and the local state of the process.
the execution of a transition is an atomic event which consumes zero or more messages received by the executing process changes the local state and sends multiple messages on behalf of the process.
a transition is called a quorum transition if it can consume multiple messages.
transitions can be non deterministic.
for example if a transition can be executed for two different incoming messages then the first message to be consumed by the transition is non deterministically selected.
the global state of the system consists of the local process states and all undelivered messages.
an sts corresponding to an mp protocol can be naturally defined such thats t ands0are the sets of states transitions and initial states of the mp system respectively.
so far the language resembles the usual formalization of message passing systems .
now we extend the syntax with some special transitions.
every transition tcan be associated with t.m i andt.m o the set of messages possibly received sent by t and t.i andt.o the set of processes that tcan receive and send messages from to .
we assume the local state of a process to be an assignment of values to local variables .
given a variable x tis a write transition with respect to xand we write x w t if tcan change the value of xin some state.
similarly tis called aread transition x r t if the guard of tdepends on the value of x. as a special case a write transition tis an increment transition x inc t if talways increases the value of x. increment transitions are relevant in the context of timestamp compare read transitions t x compts t a class of transitions common in concurrent systems e.g.
.
such a transition tusesxto store a timestamp and compare it with the timestamps of incoming messages.
the guard of tcan be true only if the timestamp of the message is greater or equal than the current value of x. the sets r t w t inc t and compts t can be conservatively determined by lightweight static analysis.
b. lpor relations for message passing systems can enable relation we say that a transition tcan locally enable another transition t of the same process if tis a write and t is a read transition with respect to some common variable x. an exception to this rule is if tis an increment andt is a timestamp compare transition with respect to x. in this case tcannot enable t because a process sends no new message to itself and the timestamp xis increased by t. formally can local enable t t id t id t x w t r t x atio slash inc t compts t where id t denotes the process executing transition t. a transition tcan remotely enable a transition t if it may send messages that can be received by t .
a necessary condition for this to happen is that tandt are executed by different processes id t atio slash id t that transition tcan send a message to the process executing t id t t.o that transition t can receive a message from the process executing t id t t .i and that tcan send a message that can be received by t t.m o t .m i atio slash .
therefore we define that can remote enable t t id t atio slash id t id t t.o id t t .i t.m o t .m i atio slash .
definition given an mp system mp can enable can remote enable can local enable.
dependency relation a transition t is dependent on t if both are executed by the same process or if tcan remotely enablet .
the intuition is that local transitions may change the state of the same process and if tcan remotely enable t then tcan send a message that is processed by t .
our dependency relation can be refined by excluding pairs of transitions that are executed by the same process and access a disjunct set of variables.
this is a refinement that we do not consider in this paper.
note that the following relation can be asymmetric which enables lpor to compute smaller stubborn sets.
definition given an mp system mp dependency t t t atio slash t id t id t can remote enable.
net relation the following net relation is based on the observation that a transition twitht.i atio slash cannot be enabled unless a process sends a message to process id t .
for example imagine that trepresents a function that requires input from a majority of processes.
this implies that t.i n i.e.
a majority of the number of all processes n. then tcan be enabled only after each of these processes has sent a message to process id t .
note that we have to check two additional conditions to make sure that a transition is indeed a net for t. firstly tis required to be input deterministic i.e.
talways consumes a message from every process in t.i .
otherwise tcan possibly be enabled even if a process in t.i sends no message to process id t .
secondly it is possible that i t.i and process ihas multiple transitions say t andt that can enable t formally id t id t t atio slash t t t t t can remoteenable .
in this case neither t nort is necessarily a net fort.
the net relation is defined below.
in appendix i an example is shown of how the content of the channels can be used to make this relation state conditional.
definition given an mp system mp net t t tis input deterministic id t t.i t t can remote enable t t id t atio slash id t .
the next theorem states that the above relations are indeed lpor relations as of section ii b a task that must be carried out by the user.
the proof of this theorem can be found in appendix iv.
theorem given an mp system mp can enable mpdependency andmp net are can enabling dependency and net relations respectively.
v. j ava lpor a nlpor i mplementation we implement lpor in a java library called java lpor.
java lpor can be integrated into any explicit state model checker.
the lpor algorithm currently implemented by javalpor computes stubborn sets satisfying d1 d2 and an additional constraint regarding visible transitions i.e.
transitions that might interfere with the target property.
this constraint of visible transitions allows lpor to preserve invariants i.e.
state local assertions that must hold in every reachable state.
the source code of java lpor is available for download .
the main steps of integrating java lpor are as follows.
as a running example we show how we used java lpor to implement message passing lpor from section iv.
specifying the transitions before the search can start the transitions of the system must be provided as java classes.
for example the input language of mp basset our model checker for message passing protocols is an extension of java and implements the language from section iv a. within mp basset transitions are represented by the class transitionmp .
implementing the lpor relations java lpor exports lpor s relations via the following interface.
this generic interface is parametric in the class tof transitions.
public interface lporrelations t public boolean dep t t1 t t2 public boolean canenable t t1 t t2 public boolean net t t1 t t2 for example the following snippet shows the implementation of our dependency relation for message passing systems compare with definition .
the method t1.islocal t2 returns true iff id t1 id t2 .
public boolean dep transitionmp t1 transitionmp t2 return !t1.equals t2 t1.islocal t2 canremoteenable t1 t2 setting up lpor for the preservation of invariants java lpor requires to identify visible transitions.
in our current implementation the user is required to annotate visible transitions using the following interface.
public interface visibilitychecker t public boolean isvisible t t given the list of all transitions trans the lpor relationsrel and a class vis for checking visible transitions an lpor utility instance can be created.
its constructor is responsible for pre computing the forward enable sets.
the instance of lporutil can then be used to compute stubborn sets for a particular state by invoking the lpor method.
as arguments the method requires an initial transition and the list of enabled transitions.
transitions are identified by their index in trans .
public class lporutil t public lporutil list t trans lporrelations t rel visibilitychecker t vis this.trans trans this.rel rel this.vis vis precompute public int lpor int t i int enabledtrans ... ... computing stubborn sets finally the following snippet shows how the set of transitions that must be executed in a state is pruned by a call to the lpor method of an lporutil instance.
this is also how we integrated java lpor into mpbasset.
enabledtrans lporutil.lpor inittrans enabledtrans vi.
lpor e xperiments in this section we present our results of using lpor to model check various fault tolerant message passing protocols.
table i performance results of lpor implemented within mp b asset using java lpor.
unreduced dporlporprotocol res.
stateless lpor only lpor net processes states time states time states time on line states time on line states time on line paxos ok 38mil 192h 22h53m 341mji 6h14m 6h19m 234mji 6h59m 7h1m 061mji 3h18m 3h21m mod.
8h51m 28h32m mod.
8h51m 24h10m mod.
4h45m 18h52m f paxos ce 1h34m 50s mji 1m16s mji 1m43s mji 1m40s f paxos2 ce 16mil 192h 12m31s mji 1h24m mji 1h25m mji 1h28m register ok 47m 6m50s 763mji 5m57s 5m59s 451mji 4m32s 4m32s 451mji 4m36s 4m36s mod.
6m17s 9m23s mod.
5m3s 7m1 mod.
4m55 7m52s register ce 1m52 40s mji 1m4s mji 55s mji 58s register ce 181h 3m56s mji 3m37s mji 2m32s mji 2m34s multicast ok 1m34s 1m46s 674mji 38s 38s 607mji 1m29s 1m30s 2178mji 37s 37s mod.
1m2s 1m47s mod.
2m7s 2m7s mod.
59s 1m46s multicast ok 28m13s 44m45s 382mji 6m12s94 186mji 26m26s12 494mji 3m34s mod.
7m8s 11m2s mod.
29m32s 31m15s mod.
5m4s 9m32 multicast ce 3m32s 2m8s mji 1m57s mji 1m4s mji 1m47s a. target protocols and properties we selected the following representative protocols paxos a widely used crash tolerant consensus protocol the byzantine tolerant echo multicast protocol and a crash tolerant regular storage protocol in the style of .
we assume meaningful finite protocol instances where at least one process fault is tolerated.
we consider the main safety properties of these protocols namely paxos must not return different values consensus echo multicast sends the same value to each recipient agreement and a read operation returns a value not older than the one written by the latest preceding write operation regularity .
each of these properties can be expressed by invariants a class of properties preserved by lpor.
for evaluating the bug finding capabilities of lpor we inject faults into both the protocols and the properties.
a detailed description of these specifications can be found in appendix vi.
b. comparison with dynamic por we compare lpor with dynamic por dpor .
we explain how dpor differs from static por spor in section vii.
in general the benefit of dpor is that it needs to be less conservative about the selection of paths that are explored in the reduced search.
however our experiments show the efficiency of lpor over dpor improving on the reductions of a message passing dpor implementation.
like any spor algorithm lpor can be soundly combined with dpor for further reduction .
this must respect the restrictions imposed by dpor however.
for example dpor assumes the absence of cycles in the state space.
we only consider protocol examples with acyclic state spaces for a fair comparison.
we compare lpor with the original dpor algorithm by flanagan and godefroid because this preserves with the visibility constraint the properties of our example protocols.
for example the dpor variant in only guarantees that every transition executed in the unreduced search is also executed in the reduced one.
in order to preserve invariants java lpor prevents nontrivial stubborn sets from including visible transitions .this constraint can also be implemented in dpor such that if a visible transition is executed in a state during the search then all enabled transitions in this state will be executed.
for comparing lpor with dpor we use the basset model checker which implements an adaptation of flanagan and godefroid s dpor algorithm for actor programs.
the actor semantics used in basset is similar to our model of messagepassing except that quorum transitions are not supported.
therefore we extended basset s dpor implementation with quorum transitions when a process executes a quorum transition the vector clock of the process will be updated to be the maximum of its current value and the values of the vector clocks of the senders of the messages where the values correspond to the time of sending the message.
in basset this computation involves one sender as every transition consumes a single message.
c. experimental setup we run our experiments in a deterlab testbed on 2ghz xeon machines.
we compare lpor with the unreduced models and dpor our extension of basset s dpor implementation as explained above.
we integrated both this dpor algorithm and lpor as described in section v within the mp basset model checker .
the source of this version of mp basset is available online .
for fair comparison both of our por implementations use the same heuristic for initial transitions.
we refer the reader to appendix vi for details of this heuristic.
dpor is run as stateless search because dpor can be unsound if state comparison is used .
we use three versions of the lpor algorithm.
first we run the full fledged algorithm but switch off state comparison stateless .
second we run a stateful search but switch off the net optimization lpor only .
third we run stateful search and lpor with state conditional net support lpor net .
we also count the number of visited states in the stateless searches for both lpor and dpor.
d. our reduction results the results of our experiments are shown in table i. we write ok if the model checker finds no bug otherwise in case of faulty protocols or wrong specifications a counterexample ce is returned.
f paxos and f paxos2 are two faulty versions of paxos.
we used wrong specifications for the other protocols.
the best result for each protocol instance is written in bold.
in buggy instances the search is stopped after finding the first bug i.e.
the search is non exhaustive.
therefore the number of visited states depends on the order in which transitions are executed in a state.
this schedule can be different in dpor and lpor.
we observe that the por based search finds bugs faster than unreduced search and there is no clear winner between dpor and lpor.
lpor is highly efficient as shown by the exhaustive search results ok reducing the number of states by up to to and search time by up to see register example.
although the additional online checks in the net optimization slow down lpor as discussed in section iii b e.g.
states sec versus states sec for exhaustive multicast the additional state reduction can add up to reducing the total model checking time.
indeed the net optimization can be very efficient by achieving additional space and time reductions of up to see multicast exhaustive search result.
lpor outperforms dpor in allexhaustive search experiments even in stateless search where the benefit of lpor is not biased by the stateful optimization.
in addition lpor proves to be more time efficient than dpor i.e.
the time overhead of lpor is smaller.
for example the stateless exhaustive runs of register visit the same number of states but lpor is faster.
e. execution time issues in this section we discuss the trade offs affecting the time overhead of lpor as implemented within mp basset.
mp basset is an extension of basset a model checker for actor programs.
basset in turn builds on java pathfinder jpf a stateful model checker for java.
similarly to basset mp basset is a java application run by jpf.
as such it can run java code at two levels first in the modeled layer which is a jpf simulated jvm second in the host jvm where jpf also runs which is accessible from the modeled layer via an interface called model java interface mji .
roughly speaking jpf explores the state space of the application run in the modeled layer.
due to the indirection of the modeled layer execution in this layer is slower than in the host jvm.
the modeled application can always execute code in the host jvm using mji.
however as there is a speed penalty of using mji time efficient jpf applications should use mji with care.
one source of this time overhead is that mji converts parameters of mji method calls between the modeled and the host jvm s object model.
to explore this trade off we created and compared two architectures one where the lpor algorithm runs in the modeled layer and another one where it runs in the host jvm.
in our experiments the mji based implementation was faster.
this meets our expectations for state unconditional lpor only because no state information is passed and thus converted to java lpor whereas in state conditional lpor net the net relation is a function of a small fraction of the current state see section iv b .
for our messagepassing instantiation of lpor the mji overhead turns out to be more time efficient than executing the lpor algorithm in the modeled layer even in the lpor net case.
this does not necessarily generalize.
in other lpor applications particularly where the entire state has to be converted for mji the execution time penalties may trade off differently.
table i shows the model checking time of both implementations mji and mod.
stands for the implementation in the modeled and the host jvm layer respectively .
for space reasons we omit the modeled layer times for the ce results as they show similar trends as for ok. we also measure the benefit of using pre computation.
the times where forward enable sets are computed on line no pre computation are written in parentheses.
otherwise the times shown include the time of pre computation.
the benefit of pre computation is significant in the modeled layer implementation.
we observe a higher relative gain of using pre computation in net optimized lpor.
the reason is that forward enable sets containing non empty en fields in the net optimized case tend to be larger thus their computation takes longer.
the reason why the mji implementation does not greatly benefit from pre computation for our particular protocol examples is two fold first lines in lpor algorithm are executed in a relative small number of states second the body of the do while loop in the forward enable set computation algorithm is executed only a few times during an average invocation of fwdenableset .
we leave the investigation of other protocols which could very well show a completely different profile for future work.
vii.
r elated work the basic structure of the lpor algorithm is similar to godefroid s stubborn and persistent set algorithms which start with a transition and keep adding new transitions using the dependency and can enabling relations until the current set of transitions is not stubborn.
an application of these algorithms to new languages is only possible after a translation into a specific language used in that specifies processes communicating via shared objects.
transitions in this language are assumed to be deterministic.
furthermore the algorithms in do not support pre computation.
the ample set algorithms in also restrict to processbased systems and deterministic transitions.
moreover they conservatively assume that a non trivial ample set consists of all enabled transitions of a particular process.
promela is a general language with explicit support for multi process systems and message passing.
spin is a widelyused model checker for specifications written in promela .
spin supports a specific form of por which is based on the observation that transitions t1andt2are independent if they are from different processes and t1is the only transition writing to or reading from a fifo channel exclusive write or read respectively .
such interferences can be easily expressed in lpor by excluding t1 t and t2 t from the dependency relation.
we note that in the description of t1andt2are considered independent only in states where the channel is non empty non full .
this is because their definition of dependency includes that a transition can enable another transition.
in fact t1can enable read send transitions but t1andt2are always state unconditionally independent in the sense of definition .
it is possible to give a graph theoretic implementation of lpor as proposed in .
in this approach the vertices of the graph are transitions and tis connected to t1if t1needs to be added to the stubborn set on behalf of t. then certain vertices of this graph e.g.
included in properly selected strongly connected components correspond to stubborn sets.
dynamic por dpor is a por implementation which computes a persistent set in some state sgradually while the successors of sare explored.
in this way the persistent set algorithm can learn about interfering transitions and needs not to guess them as in static por.
in other words dpor explores future paths instead of guessing them.
however dpor also makes static assumptions about co enabled dependent transitions.
furthermore dpor is inherently a depth first search it needs to know the sequence of transitions in the current path which is not straightforward in parallel model checking and can be unsound with stateful model checking .
in recent work we propose a heuristic to translate from one transition system to another to maximize the reduction of por and apply it to message passing systems.
this translation is orthogonal to lpor which requires a transition system at its input.
the input relations of lpor can be partly or entirely derived automatically using a sat solver an approach similar to .
moreover sat based bounded model checking can be used to compute more accurate enabling sequences than our forward enable sets.
for example given transitions t1 t t it is possible that t1can enable t2 and t2can enable t3 but t2cannot enable t3if t2was enabled by t1.
viii.
c onclusions we have proposed lpor a framework for easy to use flexible and efficient por implementations.
while existing por implementations trade flexibility for ease of use and efficiency e.g.
spin s por limits to exclusive write read fifos or dpor prohibits cycles the strength of lpor is that it provides these features at the same time.
in ongoing work we study if state conditional can enabling and dependency relations can improve on lpor s reductions.
for example a state conditional can enabling relation can be used to rule out transitions t1in line of algorithm that cannot enable any transition in the current state.
another possible extension is to add symmetry reduction to lpor.
although po and symmetry reductions are compatible in theory no implementation of their combination is available nor its efficiency was tested on real examples.
acknowledgement.
we thank gerard holzmann for his insights of the por theory as implemented by spin to enable an objective comparison across lpor and spin.