jalangi a selective record replay and dynamic analysis framework for javascript koushik sen eecs department uc berkeley ca usa.
ksen cs.berkeley.eduswaroop kalasapur tasneem brutch and simon gibbs samsung research america north first street san jose ca usa s.kalasapur t.brutch s.gibbs sisa.samsung.com abstract javascript is widely used for writing client side web applications and is getting increasingly popular for writing mobile applications.
however unlike c c and java there are not that many tools available for analysis and testing of javascript applications.
in this paper we present a simple yet powerful framework called jalangi for writing heavyweight dynamic analyses.
our framework incorporates two key techniques selective record replay a technique which enables to record and to faithfully replay a user selected part of the program and shadow values and shadow execution which enables easy implementation of heavy weight dynamic analyses.
our implementation makes no special assumption about javascript which makes it applicable to realworld javascript programs running on multiple platforms.
we have implemented concolic testing an analysis to track origins of nulls and unde ned a simple form of taint analysis an analysis to detect likely type inconsistencies and an object allocation pro ler in jalangi .
our evaluation of jalangi on the sunspider benchmark suite and on ve web applications shows that jalangi has an average slowdown of 26x during recording and 30x slowdown during replay and analysis.
the slowdowns are comparable with slowdowns reported for similar tools such as pin and valgrind for x86 binaries.
we believe that the techniques proposed in this paper are applicable to other dynamic languages.
categories and subject descriptors d. .
testing and debugging symbolic execution testing tools general terms veri cation keywords javascript dynamic analysis concolic testing the work of this author was supported in full by samsung research america.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction javascript is the most popular programming language for client side web programming.
advances in browser technologies and javascript engines in the recent years have fueled the use of javascript in rich internet applications and several mobile platforms including android ios tizen windows blackberry firefox os support applications written in html5 javascript.
a key reason behind the popularity of javascript programs is that they are portable.
once written javascript based applications can be executed on any platform that has a web browser with javascript support which is quite common in modern day devices.
javascript being a dynamic language also attracts developers through its exible features that do not require explicit memory management static typing and compilation.
with a renewed interest in javascript many complex applications such as google docs gmail and a variety of games are being developed using html5 javascript.
however unlike c c java and c javascript is signi cantly shorthanded in the tools landscape.
the dynamic and re ective nature of javascript makes it hard to analyze it statically .
in this paper we present a dynamic analysis framework called jalangi for javascript.
the framework provides a few useful abstractions and an api that signi cantly simpli es implementation of dynamic analyses for javascript.
the framework works through source code instrumentation and allows implementation of various heavy weight dynamic analyses techniques.
jalangi incorporates two ideas .selective record replay a technique which enables to record and to faithfully replay a user selected part of the program.
for example if a javascript application uses several third party modules such as jquery box2djs along with an application speci c library called myapp.js our framework enables us to only record and replay the behavior of myapp.js.
.shadow values which enables us to associate a shadow value with any value used in the program.
a shadow value can contain useful information about the actual value e.g.
taint information or symbolic representation of the actual value .
the framework supports shadow execution on shadow values a technique in which an analysis can update the shadow values and analysis state on each operation performed by the actual execution.
for example a shadow execution can perform symbolic execution or dynamic taint propagation.there are a few constraints which dictated the design of the above techniques in jalangi .
.
we wanted to design a framework that is independent of browsers and javascript engines.
such a design enables us to design dynamic analyses that are not tied to a particular javascript engine.
independence from browsers and javascript engines also enables us to easily maintain our framework in the face of rapidly evolving browser landscape we do not need to upgrade or rebuild our framework whenever there is an update of the underlying browser.
we achieve browser independence through selective source instrumentation.
an attractive feature of jalangi is that it can operate even if certain source les are not instrumented.
.
we wanted a framework where dynamic analysis of an actual execution on a browser e.g.
a mobile browser can be performed on a desktop or a cloud machine.
this is important when we want to perform a heavy weight analysis such as symbolic execution.
a heavy weight analysis is often impossible to perform on a resource constrained mobile browser.
moreover an analysis that requires access to various system resources such as le system cannot be implemented in a browser without signi cantly modifying the browser.
we address this design constraint through a two phase analysis framework.
in the rst phase an instrumented javascript application is executed and recorded on a user selected platform e.g.
mobile chrome running on android .
in the second phase the recorded data is utilized to perform a user speci ed dynamic analysis on a desktop environment.
.
a dynamic analyses framework should allow easy implementation of a dynamic analysis.
previous research and our experience with concolic testing and race detection techniques have shown that support for shadow values and shadow execution could signi cantly simplify implementation of dynamic analyses techniques.
a straight forward way to implement shadow values would be to replace any value say val used in a javascript execution by an object called annotated value actual val shadow tainted where the eld actual stores the actual value and the eld shadow can store necessary information about val.
to accomodate such replacements we modify every operation e.g.
eld access performed by the javascript execution because every value whether primitive or not could now be wrapped by an object.
the modi ed operations rst retrieve the actual values from the annotated values representing the operands of the operation and then perform the operation on the actual values to compute the result of the operation.
this simple implementation would work if we could modify every operation performed by a javascript engine.
unfortunately jalangi instruments only user speci ed code.
moreover jalangi cannot instrument native code.
therefore if we call array.pop where array is an annotated value and popis a native function we will get an exception.
jalangi alleviates this problem by using the selective record replay engine it only records the execution of the instrumented code and replays the instrumentedcode.
any code that is not and can not be instrumented including native code is not executed during the replay phase.
since jalangi supports shadow values and shadow execution during the replay phase it will never execute un instrumented code on annotated values.
thus jalangi s record replay technique is necessary for correct support of shadow values and shadow execution.
injalangi we have implemented several existing and new dynamic analyses concolic testing concolic testing performs symbolic execution along a concrete execution path generates a logical formula denoting a constraint on the input values and solves a constraint to generate new test inputs that would execute the program along previously unexplored paths.
our implementation of concolic testing supports constraints over integer string and object types and novel type constraints.
tracking origins of null and undefined this analysis records source code locations where null and unde ned values come into existence and reports them if they cause an error.
whenever there is an error due to such literals such as accessing the eld of a null value the shadow value of the literal is reported to the user.
dynamic taint analysis a dynamic taint analysis is a form of information ow analysis which checks if information can ow from a speci c set of memory locations called sources to another set of memory locations called sinks.
we have implemented a simple form of dynamic taint analysis in jalangi .
detecting likely type inconsistencies this dynamic analysis checks if an object created at a given program location can assume multiple inconsistent types.
sometimes these kind of type inconsistencies could point us to a potential bug in the program.
we have noticed such issues in two sunspider benchmark programs.
simple object allocation pro ler this dynamic analysis computes the number of objects created at a given allocation site and how often the object has been accessed.
if an allocation site creates too many constant objects then it could lead to memory ine ciency.
we have found such a problem in one of the web applications in our benchmark suite.
jalangi is available at sra siliconvalley jalangi under apache .
license.
we evaluated jalangi on the cpu intensive sunspider benchmark suite and on several user interaction rich web applications.
our evaluation results show that jalangi has an average overhead of 26x during recording and 30x during replay.
this is better than pinplay by a factor of 2x 3x and slower than valgrind .
we also found that existing dynamic analyses could easily be implemented in jalangi .
.
technical details to simplify exposition of our techniques and to avoid explanation of the nuances of javascript we use a simplejavascript like imperative language.
the syntax of this language is shown below.
v v1 v2 are variable identi ers f f1 f2 are eld identi ers p p1 p2 are function parameter identi ers op are operators such as ... pgrm stmt stmt varv v c v1 v2opv3 v1 opv2 v1 call v2 v3 v4 ifvgoto return v v1 v2 v1 v3 function v1 p1 f stmt g function de nition c number string undefined null true false ff1 v1 g object literal array literal function v1 p1 f stmt g function literal a program in this language is a sequence of labeled statements.
the statements in the language are in three address code.
ifvgoto is the only statement that allows conditional jump to an arbitrary statement.
a compiler framework can be used to convert more complex statements of javascript into statements of this language by introducing temporary variables and by adding additional statement labels.
for example controlow statements such as while for can be converted into a sequence of statements in this language using ifvgoto .
we use the statement v1 call v2 v3 v4 to represent function method and constructor calls where v2 denotes the function that is being called v3 denotes the this object inside the function andv4 denote the arguments passed to the function.
we usev1 to denote both access to an element of an array and access to a eld of an object.
.
selective record replay we assume that the user of jalangi selects a subset of the javascript source in a web application for record replay.
jalangi instruments the user selected source for recordreplay.
during the recording phase the application is executed with the instrumented les on a platform of the user s choice e.g.
a mobile browser or a node.js interpreter .
during recording the entire application is executed i.e.
all instrumented and un instrumented javascript les and native codes get executed.
during the replay phase jalangi only replays the execution of the instrumented sections.
this asymmetry of execution in the two phases has two key advantages .
one could record an execution of a javascript application on an actual platform e.g.
a mobile browser and then replay the execution for the purpose of debugging on a desktop javascript engine such as node.js or a javascript engine embedded in an ide.
the replay does not require access to any browser speci c native javascript libraries such as libraries for manipulating the dom.
.
during replay since we avoid execution of uninstrumented code and native code we can easilyimplement various dynamic analysis that depend on shadow values and shadow executions.
a trivial way to perform faithful record replay of an execution is to record every value loaded from memory during an execution and use those values for corresponding memory loads in the replay phase.
this approach has two challenges how do we record values of objects and functions?
how do we replay an execution when an un instrumented function or a native function such as the javascript event dispatcher calls an instrumented function?
note that we do not allow the execution of un instrumented and native functions during the replay phase.
therefore we need an alternative mechanism to execute instrumented functions that are being invoked by un instrumented functions during recording.
we address the rst challenge by associating a unique numerical identi er with every object and function and by recording the value of those unique identi ers.
we address the second challenge by explicitly recording and calling instrumented functions that are being invoked from uninstrumented functions or are dispatched by the javascript event dispatcher.
we avoid recording of every load of memory based on the following observation if we can compute the value of a memory load during the replay phase by solely executing the instrumented code then we do not need to record the value of the load.
in order to determine if the value of a memory load needs to be recorded jalangi maintains a shadow memory during the recording phase.
the shadow memory is updated along with the actual memory during the execution of instrumented code.
execution of un instrumented and native code does not update the shadow memory.
during the load of memory in the recording phase if jalangi nds any di erence between the value of the actual memory being loaded and the value stored in the corresponding shadow memory jalangi records the value of such memory loads.
this ensures that correct values are available during the replay phase.
figure shows the instrumentation that jalangi performs for record replay.
the instrumentation does not change the behavior of the actual execution.
jalangi introduces a shadow variable v0for every local and global variable v.jalangi introduces a local variable p0for every formal parameter pof an instrumented function.
similarly for every eld fof every object jalangi introduces a shadow eldf0.
note that if v1 denotes access of the eld denoted by the string stored in v2 then v1 denotes the access of the corresponding shadow eld.
during the recording phase jalangi keeps the actual memory and shadow memory in sync as much as possible.
note that a eld of an object may not be in sync with the corresponding shadow eld if the eld gets updated in native or un instrumented code.
whenever a variable or a eld of an object is updated jalangi adds instrumentation to update the corresponding shadow variable or shadow eld of the object.
for example v1 v2 gets modi ed to v10 v1 v2 .
the instrumentation performs the following additional three transformations if a local or global variable vor a eld of an objectv1 is loaded in a statement we rst call v0 v sync v v0 or v1 v1 varv varv0 varv v c v0 v sync c v1 v2opv3 v20 v2 sync v2 v20 v30 v3 sync v3 v30 v10 v1 v2opv3 v1 opv2 v20 v2 sync v2 v20 v10 v1 opv2 ifvgoto v0 v sync v v0 ifvgoto return v v0 v sync v v0 return v v1 v2 v20 v2 sync v2 v20 v30 v3 sync v3 v30 v2 v2 sync v2 v2 v10 v1 v2 v1 v3 v10 v1 sync v1 v10 v20 v2 sync v2 v20 v30 v3 sync v3 v30 v1 v1 v3 v1 call v2 v3 v4 v20 v2 sync v2 v20 v30 v3 sync v3 v30 v40 v4 sync v4 v40 ... v10 v1 sync instrcall v2 v3 v4 ff1 v1 g f f1 v10 v1 sync v1 v10 g function v1 p1 f function v1 p1 f stmt enter v1 g varp10 ... stmt g figure instrumentation for record replay.
sync c is equivalent to sync c undefined .
sync v1 v1 respectively before the actual load.
in the recording phase the function sync records the value stored in the memory if the values stored in the actual and shadow memory are di erent i.e.
if the arguments of the sync are di erent .
in the replay phase sync returns the rst argument if the corresponding load in the recording phase was not recorded and returns the recorded value otherwise.
this ensures that in the replay phase jalangi gets the exact value that is loaded during the recording phase.
we replace call v2 v3 v4 by sync instrcall v2 v3 v4 .
during the replay phase function instrcall invokes call v2 v3 v4 if function v2 is instrumented.
otherwise it explicitly calls any instrumented function that is invoked while executing the un instrumented or native function v2.
we use the function replay de ned in figure to call instrumented functions whose callers are not instrumented.
we insert the statement enter v1 as the rst statement of any instrumented function with name say v1.
in the recording phase enter v1 records the value of the function v1.
in the replay phase instrcall invokes the recorded function if the function is called from a un instrumented or native function.
figure de nes the functions sync instrcall and enter which are inserted by jalangi instrumentation.
the library maintains an array trace of the recorded values along with their types.
trace stores the value of the ithmemory load.
the array is initialized and populated during the recording phase and is used in the replay phase.
at the end of recording trace is serialized to the lesystem in json format.
during replay the serialized le is used to initialize trace .
function sync is de ned as described before.
if the second argument of sync is not provided then we assume that the second argument is undefined .jalangi uses the ag recording to indicate if an execution is meant for recording or replay.
for a recording execution if the two arguments ofsync are di erent then jalangi records the value and the type of the value in the sparse array trace .
otherwise jalangi skips recording i.e.
keeps the entry trace undefined .
if the value of v1insync is restricted to primitive types i.e.
number string boolean unde ned or null we can simply do trace v1 .
however the type of v1could be an object or a function.
to handle objects and functions sync calls trace getrecord v1 where getrecord v1 returns an object whose type eld is set to the type of v1and valis set to v1ifv1is of primitive type.
if type of v1is a non null object or function then we use the unique numerical id of the object or function as its value to be recorded.
the unique numerical id of a non null object or function is stored in its hidden eld id .
if the object or function has no unique id getrecord creates and assigns a unique numerical id to the object or function.
in a replay execution if trace isundefined inside a call of sync then sync returns the value present in the actual memory.
otherwise sync returns the value recorded in the trace .sync could simply return trace if the value of v1insync is restricted to primitive types.
since type of v1 could be object or function trace .type records the type ofv1andtrace .val stores the value or unique id of v1if v1is of primitive type or object function type respectively.
if the type of v1is non null object or function we need to return the object or function that has the unique id recorded in trace .val .sync calls syncrecord rec v1 to achieve this.
syncrecord maintains a map objectmap from unique identi ers to object functions.
if syncrecord discovers that the recorded unique id maps to an object function in the objectmap it returns that object function.
otherwise if syncrecord nds that the recorded unique identi er has no map in the objectmap syncrecord does the following ifvis a fresh object function i.e.
which has not been assigned an unique id in the current execution syncrecord assigns the recorded unique id rec.val to the object vand updates objectmap to remember this mapping.
syncrecord returns the object v. otherwise syncrecord has encountered an unde ned value or a stale value.
therefore syncrecord creates a mock empty object function assigns the recorded id p e r s i s t t r a c e a f t e r r e c o r d i n g d u r i n g r e p l a y i n i t i a l i z e t r a c e from p e r s i s t e d t r a c e var trace var i id objectmap f u n c t i o n getrecord v f if v !
null typeof v o b j e c t jj typeof v f u n c t i o n f if !
v v id returnftype typeof v val v g gelsef returnftype typeof v val vg g g f u n c t i o n syncrecord rec v f var r e s u l t rec .
val if rec .
val !
null rec .
type o b j e c t jj rec .
type f u n c t i o n f if objectmap r e s u l t objectmap elsef if typeof v !
rec .
type jjv v rec .
type o b j e c t ?fg f u n c t i o n fg v rec .
val objectmap v r e s u l t v g g return r e s u l t g f u n c t i o n sync v1 v2 f i i if recording f if v1 !
v2 trace getrecord v1 return v1 gelsef if trace return syncrecord trace v1 else return v1 g g f u n c t i o n enter v f i i if recording f trace getrecord v trace .
isfuncall true g g f u n c t i o n instrcall f o a1 .
.
.
an f if recordingjjisinstrumented f return call f o a1 .
.
.
an else return replay g f u n c t i o n replay f while trace .
isfuncall f var f syncrecord trace undefined f g return undefined g figure record replay library to that object updates the objectmap and returns the mock object function.
the function replay plays an important role in the replay phase.
it ensures that any instrumented function that got invoked from an un instrumented or native function is called by jalangi explicitly.
the replay function is de f u n c t i o n annotatedvalue actual shadow f t h i s .
actual actual t h i s .
shadow shadow g f u n c t i o n a v f if v i n s t a n c e o f annotatedvalue return v .
actual return v g f u n c t i o n s v f if v i n s t a n c e o f annotatedvalue return v .
shadow return undefined g figure annotated value pendent on the enter function inserted at the beginning of every instrumented function.
enter records the value of the function that is currently being executed.
it also sets the eld isfuncall of the record appended to trace totrue.
a true value of trace .isfuncall indicates the record appended to trace corresponds to the invocation of the function denoted by trace .val .
now let us see how this record is used in the replay phase.
jalangi calls instrcall in place of any call statement in the code.
instrcall in turn invokes call ifjalangi is in the recording phase or during replay phase when function fis instrumented.
this ensures that jalangi executes any function whether instrumented or un instrumented normally during the recording phase and that jalangi only executes instrumented functions normally during the replay phase.
if the function f inside instrcall is un instrumented then there is a possibility that fcould have called some instrumented function in the recording phase.
in order to replay the execution of those instrumented functions jalangi calls replay .replay rst computes the function object by looking at the next record in the trace and then invokes it if isfuncall is true.
the invocation does not pass any argument because jalangi has no record of the arguments being passed to the function.
the arguments get synced inside the function as they are being read inside the function.
jalangi starts the replay phase by calling the replay function instead of calling the entry function of the application.
.
shadow values and shadow execution jalangi enables a robust framework for writing dynamic program analyses through shadow values and shadow execution.
a user de ned shadow execution can be performed byjalangi during the replay phase.
jalangi only performs shadow execution of instrumented code without instrumentation jalangi cannot analyze the behavior of uninstrumented or native code.
in shadow execution jalangi allows the replacement of any value used in the execution by an annotated value .
the annotated value can carry extra information about the actual value.
for example an annotated value can carry taint information in a taint analysis or a symbolic expression describing the actual value in symbolic execution.
in jalangi we denote an annotated value using an object of type annotatedvalue de ned in figure .
an object of type annotatedvalue has two elds the eld actual stores the actualvalue and the eld shadow stores the shadow value i.e.
extra information about the actual value.
a value say v in javascript can be associated with shadow value say s by simply replacing vbynew annotatedvalue v s .
the projection function a v returns the actual value of v ifvis an annotated value and returns votherwise.
similarly the projection function s v returns the shadow value associated with vifvis an annotated value and returns undefined otherwise.
if a javascript value is replaced by a user de ned annotated value during an analysis the built in javascript operations will fail.
for example if we replace the number value by the annotated value new annotatedvalue null then addition of this value with another number say would result in naninstead of .
to avoid such situations we instrument code so that jalangi performs the built in javascript operations on the actual values instead of the annotated values.
for example v1opv2 is replaced by a v1 op a v2 .
similarly v1 is replaced by a v1 .
the instrumentation inserted by jalangi to perform shadow execution with shadow values along with record replay is shown in figure .
the instrumentation assumes that the global variable anlys could point to a user de ned analysis object during the replay phase.
after the execution of a javascript statement the corresponding method in the anlys object is called to perform a user speci c analysis.
for example consider the statement v1 v2opv3.
after the execution of this statement in the replay phase jalangi calls thev1 anlys binary op v2 v3 v1 to perform an analysis speci c function for the binary operation op.
for example ifv2 is the number and v3 is the annotated value new annotatedvalue tainted then after the execution of the actual statement v1 will be and then execution of v1 anlys binary op v2 v3 v1 could store new annotatedvalue tainted in v1 to represent the fact if one of the operands of a binary operation is tainted then the result of the operation is also tainted.
following is another example in the context of symbolic execution.
if v2 is the annotated value new annotatedvalue 2x1 and v3 is the annotated value new annotatedvalue x2 x1 then after the execution of v1 anlys binary v2 v3 v1 where anlys performs symbolic execution v1 will be the annotated value new annotatedvalue x1 x2 .
note that in the symbolic execution the symbolic expression corresponding to a concrete value is represented as a string in the shadow value.
.
example analysis tracking origin of null and undefined values in figure we describe a simple dynamic analysis using the shadow execution framework for jalangi .
the analysis tracks the origin of null and undefined in a javascript execution.
if during an execution access is made to the eld of a null orundefined value or if an invocation of a value which is null orundefined is encountered the analysis could report the line number of code where the null or undefined value originated.
the analysis creates an object anlys where we de ne the methods literal getfield and call.
the operations corresponding to these methods could create null and undefined values.
therefore if the value returned by any of these operations is null orundefined we annotate the re varv varv0 varv if anlys anlys literal v anlys literal undefined v c v0 v sync c if anlys anlys literal v anlys literal c v1 v2opv3 v20 v2 sync v2 v20 v30 v3 sync v3 v30 v10 v1 a v2 op a v3 if anlys anlys binary v1 anlys binary op v2 v3 v1 v1 opv2 v20 v2 sync v2 v20 v10 v1 op a v2 if anlys anlys unary v1 anlys unary op v2 v1 ifvgoto v0 v sync v v0 if anlys anlys conditional anlys conditional v if a v goto return v v0 v sync v v0 return v v1 v2 v20 v2 sync v2 v20 v30 v3 sync v3 v30 a v2 a v2 sync a v2 a v2 v10 v1 a v2 if anlys anlys getfield v1 anlys getfield v2 v3 v1 v1 v3 v10 v1 sync v1 v10 v20 v2 sync v2 v20 v30 v3 sync v3 v30 a v1 a v1 v3 if anlys anlys putfield a v1 anlys putfield v1 v2 v3 v1 v20 v2 sync v2 v20 call v2 v3 v4 v30 v3 sync v3 v30 v40 v4 sync v4 v40 ... v10 v1 sync instrcall a v2 v3 v4 if anlys anlys call v1 anlys call v2 v3 v4 v ff1 v1 g f f1 v10 v1 sync v1 v10 g function v1 p1 f function v1 p1 f stmt enter v1 g varp10 ... stmt g figure instrumentation for record replay and shadow execution turn value with the location information.
getlocation returns the line number in the original code where the instrumentation was inserted by jalangi .
the above example shows how one could implement a dynamic analyses using jalangi .
in our framework we havef u n c t i o n syncrecord rec tv f m var v a tv r e s u l t rec .
val if rec .
val !
null rec .
type o b j e c t jj rec .
type f u n c t i o n f if objectmap r e s u l t objectmap elsef if typeof v !
rec .
type jjv v rec .
type o b j e c t ?fg f u n c t i o n fg v rec .
val objectmap v r e s u l t v g g m if a tv r e s u l t m r e s u l t tv return r e s u l t g figure updated syncrecord for shadow execution.
modi ed lines are labeled with m anlys f l i t e r a l f u n c t i o n c f if c nulljjc undefined f return new annotatedvalue c getlocation g g getfield f u n c t i o n v1 v2 r f if r nulljjr undefined f return new annotatedvalue r getlocation g g c a l l f u n c t i o n f o a1 .
.
.
an r f if r nulljjr undefined f return new annotatedvalue r getlocation g g g figure tracking origins of unde ned and null implemented full concolic testing and taint analysis using shadow execution.
we believe that many other dynamic analyses can be implemented easily using jalangi .
.
example consider the example javascript program in figure .
let us assume that the entire program is instrumented except the body of the function foo.
the trace generated by an execution of the program in a browser is also shown in the figure.
note that during the recording phase we create an unique identi er for each of the objects accessed inside the body of the program.
the object document is available in the browser but the object never got created in the body of the program.
during the replay a mock object is created fordocument anddocument is set to an identi er obtained from the recorded trace.
document.url is set to a string value obtained from the trace.
during the recording phase mydoc gets set to document inside un instrumented code.
therefore after the execution of foo mydoc will contain the object document and the shadow variable mydoc will still be undefined .
jalangi will therefore record the value of mydoc when it is returned from myload .
during the replay jalangi will sync the value of mydoc which it will discover in objectmap .
the value of mydoc will be set to the mock object with id created during the replay.
thus the replay phase will faith un i n s t r u m e n t e d f u n c t i o n foo f mydoc document g to be i n s t r u m e n t e d var mydoc f u n c t i o n myapp f document .
onload f u n c t i o n myload f var ur l document .url foo return mydoc g g trace sync f u n c t i o n l i t e r a l myapp and s e t myapp ftype f u n c t i o n val 1g r e c o r d e n t e r myapp ftype f u n c t i o n val isfuncall trueg sync l o a d o f document and s e t document ftype o b j e c t val 2g sync f u n c t i o n l i t e r a l myload and s e t myload ftype f u n c t i o n val 3g r e c o r d e n t e r myload where myapp i s c a l l e d by the e v e n t d i s p a t c h e r ftype f u n c t i o n val isfuncall trueg sync g e t f i e l d document ftype s t r i n g val h t t p .
.
.
i n d e x .
h t m l g sync f u n c t i o n l i t e r a l f o o and s e t f o o ftype f u n c t i o n val 4g sync l o a d o f mydoc on r e t u r n ftype o b j e c t val 2g figure an example javascript program.
assume that the function foois not instrumented.
executing the program on a browser generates the trace .
fully mimic the recorded execution even in a non browser environment.
.
implementation we have implemented jalangi in javascript.
the code of this framework is available under apache .
open source license at jalangi .
in the actual implementation we do not transform javascript into the three address code described in section .
rather we modify the ast in place by replacing each operation with an equivalent function call.
we perform instrumentation ahead of time in future we plan to support load time instrumentation using a proxy.
handling eval jalangi exposes the instrumentation library as a function instrumentcode .
this enables us also to dynamically instrument any code that is created and evaluated at runtime.
for example we modify any call to eval s to eval instrumentcode s .
handling exceptions exceptions do not pose any particular challenge in jalangi except for uncaught exceptions being thrown from uninstrumented code.
we wrap every function within a trycatch nally block.
in the catch block we re throw the exception.
in the nally block we call any analysis speci ccode corresponding to the function call.
handling ajax calls and event handlers event handlers and handlers of ajax calls appear as toplevel function invocations in the recorded trace.
if the handlers are instrumented then the replay function de ned in figure invokes them in the order in which they were invoked in the recorded execution.
in record replay described in figure we record any literal value any value returned by a function call and any function value that is executed.
this could still result in large amount of record data.
in our implementation we avoid recording any literal value.
we only record the return value of a function if the function is un instrumented or native.
similarly we avoid recording a function value at the beginning of the execution of the function if the function is called from an instrumented function.
concolic testing we have implemented concolic testing as an analysis in jalangi .
we store the symbolic expression corresponding to each concrete value in its shadow value.
concolic execution takes place during the replay phase the shadow execution updates the shadow value of each value.
we perform record replay execution of the program for each generated input.
in our implementation of concolic testing we handle linear integer constraints and string constraints involving concatenation length and regular expression matching.
we also handle type constraints and a limited set of constraints over