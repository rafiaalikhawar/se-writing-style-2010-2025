automatic early defects detection in use case documents shuang liu1 jun sun2 y ang liu3 yue zhang2 bimlesh wadhwa1 jin song dong1and xinyu wang4 1national university of singapore 2singapore university of technology and design 3nanyang technological university 4zhejiang university abstract use cases as the primary techniques in the user requirement analysis have been widely adopted in the requirement engineering practice.
as developed early use cases also serve as the basis for function requirement development system design and testing.
errors in the use cases could potentially lead to problems in the system design or implementation.
it is thus highly desirable to detect errors in use cases.
automatically analyzing use case documents is challenging primarily because they are written in natural languages.
in this work we aim to achieve automatic defect detection in use case documents by leveraging on advanced parsing techniques.
in our approach we first parse the use case document using dependency parsing techniques.
the parsing results of each use case are further processed to form an activity diagram.
lastly we perform defect detection on the activity diagrams.
to evaluate our approach we have conducted experiments on real world as well as academic use cases.
the results show the effectiveness of our method.
categories and subject descriptors .
d. .
requirements specifications keywords .
natural language processing use cases .
introduction use cases are the main technique for understanding user requirements which have been widely adopted in the modern software development life cycle over the last two decades.
each use case describes a sequence of interactions between a software system and an external actor such that the actor is able to achieve some goal.
collectively use cases are used to define all the necessary system activities that have significance to the users.
as use cases are developed during a very early stage of the software development life cycle they also serve as the basis for developing detailed functional requirements help in design development and validation system testing and maintenance.
high quality use case documents can improve the sustainability of software.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
case documents are usually written in natural languages which may inevitably introduce defects like inconsistency redundancy and incompleteness.
moreover those defects are hard to identify or verify due to their informal format.
in the current practice use case analysis is conducted manually e.g.
requirement analysts manually extract analysis models e.g.
state machine activity diagram from use cases and search for defects in the models or validate them against test cases.
manual analysis is hardly ideal as it requires a lot of human efforts and is often error prone.
as a result use cases are much less useful than they could or should be.
there are existing works on automatic analysis of use cases .
but still we identify the following challenges which have not been addressed satisfactorily.
firstly actual use case documents are often larger and more complex than those have been reported in existing works .
for large use case documents the diversity of grammar rules and ambiguities presented in the document raise great technical challenges in automatic understanding them.
secondly common problems in use cases are inconsistency and incomplete flows.
existing approaches have so far mainly focused on analyzing inconsistency problems and leave incomplete flows unconsidered.
lastly some existing approaches e.g.
rely on users to provide use case specific templates for parsing which is ad hoc and may require knowledge about shallow parsing techniques.
in this work we are motivated to provide automatic techniques to identify defects in use case documents during the early stage of system development.
we attempt to answer the following research questions.
how can we automate the process of extract useful information from use case documents as much as possible?
can we formally define the common defects in use cases and develop systematic methods to find those defects?
how can we generalize the method to handle use case documents from different domains even when the documents are written by different people?
we contribute in the following three aspects.
we explore dependency parsing technique to help understand use case documents.
we provide 8rules based on general english grammar to analyze the dependency parsing results.
we formally define common consistency and integrity related defects in use cases and provide algorithms to automatically check those defects.
we conduct experiments with use case documents of different systems from different application domains.
the results show that our method can achieve good accuracy in analyzing sentences from different domains as well as in finding defects.
related work xiao et.al.
extracted access control policies acp from software descriptions and checked the validity of the policies against the use case steps within the same document.
semantic patterns for acp sentences are provided based on the manually defined verb phrases and pos tags obtained from shallow use case receive the order with special group initiating actor trader pre conditions .
the order is legal.
main flow .
gsys accepts the symbol of order.
.
check the order.
.
if the order is legal record values of the group.
.
find the constraint in the system according to the group name.
.
save the order into database.
.
price the order.
.
during the processing it could create matches only when the constraints are permitted.
for example no match should be created if there is not enough cash in the group.
.
this ends the use case.
alternative flow in step if there is no such constraint in the system the system will reject this order.
post conditions .
order with special group is received by the system.
figure example of use case description parsing.
gervasi and zowghi proposed to uncover inconsistencies in natural language use case descriptions with formal reasoning techniques.
propositional logic formulas are adopted to represent facts hypotheses and constrains which are extracted from natural language descriptions.
sinha et.al.
proposed an analysis engine and a prototype tool text2test for use cases.
shallow parsing techniques are used to analyze natural language sentences.
domainspecific knowledge is required for annotating concepts and context information.
the works depend on document specific information such as keywords writing styles etc.
we explore to use dependency parsing technique which provides richer syntactic information and enables adjusting rules without any domain specific information to be provided.
thus our approach is more adaptive.
tan et.al.
focus on detecting inconsistencies between program comments and the source code.
zhong et.al.
propose to infer resource specifications from api documentations to detect resource manipulation order problems.
this kind of approaches handle natural language with limited patterns.
templates are usually used to extract information from those natural language sentences.
.
preliminary this section introduces the use case document template adopted in our approach and the uml activity diagram.
.
use case document template there is no standard template for writing use case documents as concluded by fowler .
the choice of use case styles may be highly project dependent as affected by factors such as the criticality and the number of people involved.
it is recommended that for small projects a simple casual use case template can be chosen.
for large life critical projects it is more appropriate to use a hardened fancier and fully addressed template .
we focus on fully addressed use cases since they are usually adopted by large life critical projects.
there is no universally adopted fullyaddressed use case template.
however it has been reported by cockburn that the readers almost universally select the singlecolumn numbered plain text full sentence form .
therefore in this work we focus on this most popular writing style in literature.
figure is one use case in a stock trading system document1which follows roughly the cockburn style .
note that our work does 1this is a real system used for real time stock trading in the amount of billions.
the document is provided by our industry collaborator.
we omit sensitive keywords due to the confidentiality.
check order record value find constraint d44 save order price order a1 reject order d43 some operation nf41 recieve gsys order figure example activity diagram not aim at handling all the possible writing styles of use cases.
we are rather interested in investigating advanced nlp techniques to aid defects detection in use case documents.
the issues caused by different writing styles can be tackled by providing more robust pre processing steps.
we formally define the concepts involved in use case descriptions below.
definition a ction .anaction is defined as a tuple a vb sub obj wherevb sub obj are natural language phrases representing the main verb subject and object of the sentence.
for example in figure the action tuple of the first sentence in main flow section is check order the subject is missing in an imperative sentence .
definition p redicate .apredicate is defined as a tuplep ar r a a2 wherear2 f1 2gis the arity of the predicate ris the relation symbol of the predicate a1anda2are the arguments of the relation symbol.
the predicate can be monovalent or divalent depending on the structure of the sentence.
predicates of higher arity are not used very frequently.
therefore we do not consider predicates with more than two arities in our work.
to gain an intuitive view a monovalent predicate is legal order 2can be generated from the sentence in the pre conditions section in figure .
definition s entence .asentence is defined as a tuple s s c n s nj wheres is the sentence number in the corresponding section of the use case 2ais the action of the sentence c2pis the guard condition for executing the sentence ns2nandnj2nare the logical previous and succeeding sentence of the current sentence respectively.
for example the alternative flow sentence in figure corresponds to the following sentence structure a1 reject system order is no there constraint .
the number 3indicates that the current alternative flow step starts from main flow step .
indicates that there is no explicit assigned step after the current step then the flow goes to the next neighboring step.
definition u secase .ause case is defined as a tupleuc ucname prec postc mf af ucname is the name of the use case prec pandpostc pare the predicates extracted from sentences in the pre condition and postcondition sections mf andafare the list of sentences sin the main flow and alternative flow sections of the use case.
2we use underline to replace spaces.
786use case documents sentences in dep tree activity diagram use cases in sentence struct build activity diagram analysis of dep ps trees find defects artifact processing step phase i phase ii defect report dictionary train dep parser .
dependency parsing use cases separated in sentences preprocessing .
phrase structure parsing sentences in ps tree trained dep parser optional phase with zpar with trained dep parser figure overview of our approach .
uml activity diagram uml activity diagrams are commonly adopted to describe the event flows in use case documents for the purpose of coordinating low level behaviors.
definition a ctivity node .anactivity node is defined asn na ncwherena nm is action node and nc nm t is the control node.
nm is the name for each node.
2ais the action associated with the action node.
t2 fdecision final initial gis the type of the control node.
in figure the rounded rectangles are action nodes.
the diamond enriched circle and solid circle represent the choice node final node and initial node respectively.
they are control nodes.
definition a ctivity edge .anactivity edge is defined ase sn tn g wheresn2n tn2nandg2pare the source target nodes and the guard condition of the activity edge.
the guard condition for an activity edge must be satisfied in order to fire the corresponding edge.
definition a ctivity diagram .a uml activity diagram is defined as ad adname prec postc an ae whereadname is the name of the activity diagram.
an n andae eare the set of activity nodes and activity edges in the diagram.prec pandpostc pare the pre conditions and post conditions of the activity diagram.
in this work we consider a subset of uml activity diagram features which are related to control flows.
the features which capture object flows are not considered since our defects detection methods utilize only the control flow information.
.
our approach the overview of our approach is illustrated in figure .
the rectangles represent artifacts that are produced as intermediate final processing results.
the ellipses represent the processing steps.
our method consists of two phases.
in the first phase we take a use case document as input and parses each sentence in the document into parse trees dependency tree and phrase structure tree .
the second phase takes parse trees as input and generates a uml activity diagram for each use case.
afterwards defects in the use cases are checked.
the output of our method includes the uml activity diagrams and a defect report where all defects with horizontal links to the original document are listed.
there is also an optional phase as enclosed in the dashed lined area.
it provides a way to train a domain adaptive dependency parser to improve the accuracy of dependency parsing.
we discuss our approach in this section.
.
pre processing use case documents this step is conducted to filter noises from the input document so as to improve the accuracy of the dependency parser.
we removes the irrelevant information and formatting symbols such asgsys accepts the symbol of order nns vbp dt nn in nnroo t subobj nmod nmod pmod figure example of a dependency tree spppp np gsysvpaaaa!!!!
vbp acceptsnppppp the symbol of order figure example of a phrase structure tree parenthesized comments and bullets which may affect the parsing accuracy.
the output text satisfies the following conditions.
each sentence is stored in a separate line.
each punctuation is preceded by a space.
step index number is stored in a separate line.
parenthesis are replaced by lbr or rbr .
there is no empty line in the document.
.
free text parsing in this work we leverage on zpar a statistical dependency and phrase structure parser for analyzing syntactic information.
dependency parsing the dependency parser step .
is used to extract bootstrap information for action tuples.
it conducts statistical analysis on pos tags based on a large data set which guarantees that it provides more general results than directly analyzing pos tags based on the templates extracted from the sample document.
the dependency parsing technique can also provide richer syntactic details i.e.
the dependency relation between pairs of words which provide the subject object and main verb information of a sentence directly.
the output format of the dependency parser is a dependency tree.
figure shows the dependency tree for the first sentence in the main flow section in figure .
the middle row is the original sentence in tokenized words .
the last row is the part of speech pos tags of the corresponding words.
the labeled links are dependency relations between two words.
for example the link from the word gsys to the word accepts labeled with sub represents that gsys is the subject of accepts .
the word accepts is the root i.e.
the main verb of the sentence.
phrase structure parsing the phrase structure parser step .
is used to identify the modified supplement information.
it provides a parse tree in which sentences are parsed into noun verb phrases and sub sentences based on the subordinating modification relation thus provides complete context information for an identified word.
the parsing result is a phrase structure tree as shown in figure .
the leaf nodes are the plain text tokens.
the non leaf nodes are pos tags where s vp np represents a sentence verb phrase and noun phrase respectively.
the phrase structure tree is used in combination with the dependency tree in our analysis phase to obtain more accurate results.
for example in figure we identify that the object is symbol from the dependency tree.
the phrase structure tree in figure provides the complementary information that the symbol is an attribute of the order .
this kind of attributive information is useful in comparing action tuples.
787table rules to extract action tuples rules main verb have root not be jj vb be root not jj vb be root not jj prd modal root not be jj vb root pi subject pi l root sub object pi l root obj prd prp pi l root sbar vc vmod table templates to extract condition predicates templates ex nn prp md vb not no dt jj nn prp .
ex nn prp md vb not no vb .
ex nn prp md vb not no dt nn jj .
.
analyzing parse trees the goal of analyzing parse trees is to extract the sentence structuresas defined in definition .
the sentence step number s step start n s and join n j nodes are extracted based on keyword matching.
the methods to extract the action tuple and the condition predicate care discussed as follows.
extract action tuples an action tuple as defined in definition contains a subject an object and a main verb of a sentence.
these parts are immediately available in a dependency tree.
for example in figure the dependency labels sub obj androot indicate that the subject object and main verb are gsys symbol and accepts respectively.
however dependency parsing suffers from a common problem of natural language parsing i.e.
fragile to ambiguities and noises.
thus relying only on the dependency labels may not provide good accuracy due to the deviations in the dependency trees caused by the diversity of sentence patterns tenses and subordinate structures.
to improve the parsing accuracy we provide 8adjusting rules based on general english grammar.
rely on the phrase structure parsing result to identify related context information.
the rules shown in table are general in the sense that they are based on natural language grammars and do not contain any document specific patterns or key words.
there are kinds of information i.e.
plain text pos tags and dependency label used in our rules.
the plus symbol composes constraints for consecutive words.
we use braces to represent compulsory information when more than one kind of information is used on one word.
brackets are used to represent optional information and the slash symbol is used to represent a choice among the candidates.
for example rule requires that the parent of the word should be labeled as root and the word itself should be labeled as obj orprd orprp both constrains are compulsory.
extract condition predicates we notice that sentences which contain conditions are often complex e.g.
with sub clauses.
the dependency parser is likely to produce a random dependency tree especially for the condition sub clause.
we also notice that the condition sub clauses are usually written in simple formats.
therefore we extract the condition predicates through template matching.
for example to process the alternative flow sentence in figure our method first truncates the condition containing sub clause i.e.
if there is no such constraint in the system .
the sub clause matches the first template in table and condition predicate is no there constraint is obtained.
.
building activity diagram the main idea to build an activity diagram is to link action tuples with control flow information.
there are two kinds of control flow indicators.
one is the control flow information such as go jumpto step that we identified by analyzing the content of a sentence.
the other is the structure of use cases i.e.
consecutive sentences in each section of the use case represent the ordering in the control flow.
sentences in the alternative flow section are the branch flows of sentences in the main flow section.
we build an activity diagram for each use case based on the identified information in step .
figure shows the activity diagram that is generated from the use case in figure by our approach.
the action node is labeled with the step number and the action tuple extracted from the corresponding sentence.
the decision node diamond is labeled with the step number of the sentence in which it is generated.
the guards edges and nodes in dashed line in figure represent the missing flow step that our method detected.
the main flow step labeled 47in figure does not have a corresponding action node in the activity diagram since it does not describe an action step thus is removed during the activity diagram building procedure.
.
formal definition for use case defects to guide our analysis towards finding defects in use cases we formally define the defects originally proposed by t rner et.al.
and develop algorithms to systematically find them.
specifically we focus on defects which are objective and have high defect intensity.
the defects we focus on are defined below.
inconsistent step numbering captures the situation where the sentence numbers of main flow or alternative flow are not consistent.
this may lead to incorrect step referencing.
for example in figure the step number 3is missing in the main flow.
as a result the alternative flow has referred to a non existing main flow step.
definition d1 .givenuc2uc if9s uc mf cont s uc af cont s s n s6 null uc mf cont s n s uc af cont s n s s nj6 null uc mf cont s n j uc af cont s n j the use case is said to have inconsistent step numbering defect.
the function cont checks whether the item is a member of the list.
in some use cases the starting step in main flows of the alternative flow is not clearly specified.
this may lead to ambiguity when merging the alternative flows with the main flow.
definition d2 .givenuc2uc if9s uc af cont s s ns null then the use case contains the unclear alternative flow starting step defect.
an overly strong precondition is one such that inconsistencies between the precondition and the guard conditions of an edge may occur.
for example in figure the sentence in the precondition has already restricted the order to be legal thus the second sentence of the main flow which checks the validity of the order is redundant.
definition d3 .the pre condition of an activity diagramadis overly strong if given an activity diagram ad2ad 8prec2ad prec 9e2ad ae conflict e g prec where conflict is a function deciding whether two predicates conflict.
missing of alternative flows is the case when the main flow defines some action under some specific condition however not all the other possible conditions are addressed.
for example in figure step 43in the main flow specifies the condition if the order is legal .
but it is not specified what if that condition does not hold.
definition d4 .given an activity diagram ad2ad 8n2ad n ifn2nc n t decision outg n .
the use case contains the missing alternative flow defect.
outg n je2ad e e sn njreturns the number of edges out going from a given node.jjis the cardinal number operation on a set.
788algorithm check unnecessary strong precondition input ad activity diagram output whether find an over strong precondition or not 1letnbe the initial node 2while there are unvisited nodes in addo marknas visited ifn2nathen ifinchangestatusdict n vb then returnfalse ifn2nc n t decision then ifguard condition of any edges outgoing from nis conflict with any p2ad prec then report an over strong precondition defect returntrue setnto the next node following the edge in ad 12returnfalse .
finding defects following the definitions in section .
we discuss each defect finding method in details in this section.
inconsistent step numbering d is checked based on the use case structure.
we check all the sentences in mf andafsections of a use case.
if we find an nsfield referring to a sentence that is not inmf af an inconsistent step numbering defect is reported.
to detect an unclear alternative flow starting step d defect we check all the sentences in the afsection of a use case.
if we find a sentence with its nsfield not specified an unclear alternative flow starting step defect is reported.
the process of detecting unnecessary strong preconditions d is shown in algorithm .
the rationale is that the pre condition of a use case is the required initial status of the use case.
if the status is not changed by the action steps it should be preserved.
the input to algorithm is an activity diagram ad.
we traverse the activity diagram ad starting from the initial node in the while loop.
for each node n if it is an action node line we first check whether the action verb n vb associated with the node is a statuschanging verb line .
if yes we stop and return false.
otherwise if it is a decision node line we further check all the predicates associated with the edges outgoing from the decision node and see whether they conflict with any precondition predicate of ad line .
if yes an over strong precondition defect is reported.
we manually defined a status changing dictionary based on all the main verbs in the action tuples that we extract in step in figure .
for example the action save the order may change the status of the order and check the order will not change the order status.
the manually dictionary defining process is liberated and reinforced by referring to the wordnet lexical database for english.
to detect missing alternative flows d we traverse each activity diagram to check all the decision nodes and see whether they have branch edges.
if no branch edge is present for a decision node with guard conditions a missing alternative flow error is reported.
.
training dependency parser to handle the problem caused by document specific factors such as grammar errors and specific sentence structures we provide a way to train a domain adapted dependency parser.
in the case of the stock trading system we manually labeled of wrongly labeled sentences randomly selected from the document to train a domain adapted dependency parser.
this is shown in the dashed box step in figure .
the trained dependency parser will replace the zpar dependency parser in the dependency parsing step.
this is an optional step in our overall procedure and is only needed in order to achieve higher accuracy on document specific patterns.table accuracy of parsing doc type wrong pc correct total prec stsaction w o action w predicate asaction w o action w predicate .
ev aluations to test the applicability of our approach we evaluate our methods with 219use cases which cover different application domains financial health care machinery monitoring and e commerce systems adopted from real industry systems as well as academic publications.
due to the space constraints we put all the experiment data and the implementation information on our website .
.
accuracy of free text parsing the accuracy of the free text parsing is measured by the accuracy of the action tuples and predicates generated.
table shows the evaluation results.
the columns from left to right represent the document used doc the evaluation type type the number of wrongly wrong partially correctly pc and correctly correct identified action predicate the total number of sentences total and the precision prec of the corresponding evaluation type.
the precision is calculated by the formula prec correct total.
an action tuple is identified as correct iff all the three fields of it are correctly extracted.
due to the large number of sentences in the stock trading system we randomly sampled of the sentences in the document to check the accuracy.
to show how robust extensible the dependency parsing can be we check the accuracy on identifying action tuples based only on the dependency label.
the results are shown in the action w o rows in table .
we can see from the results that even without applying any of the adjusting rules we can achieve more than accuracy on identifying action tuples.
the accuracy of the analysis results action w with our provided adjusting rules is much higher.
for the stock trading system since it is written by non native english speakers there are many grammar errors which lead to the incorrect result.
the academic system documents are comparatively well written thus zpar achieves a higher accuracy.
from the experiment results we notice that the rules used to adjust extraction of action tuples are indeed useful.
an increase in accuracy of for the stock trading system and for the those academic use cases is seen.
the rules are generalizable to different documents written by different development groups.
it is promising to increase the accuracy by providing more rules.
.
accuracy of the activity diagram builder the accuracy of the activity diagram building method is measured by whether the nodes and edges are correctly generated and linked in the activity diagram and whether the guard conditions are correctly associated with the edges that are correctly generated in the activity diagrams.
for the stock trading system out of use cases have correct nodes and edges generated.
all the guard conditions are correctly associated with those edges.
the use cases which do not have activity diagrams correctly generated either contain alternative flow steps which do not have clear starting steps or have multiple conditions described within one consecutive steps.
actually this kind of writing style is not consistent with the majority of other use cases in the document which follow the cockburn style.
for the academic use cases out of 31use cases are correctly generated.
789table experiment results of defect detection id ifirif ir prec rec d118 d222 d319 d483 .
accuracy of the defect finder to evaluate the accuracy and effectiveness of our defect finding methods we adopt the standard metrics of precision prec and recall rec .
we define prec jif irj ifandrec jif irj ir whereif represents the set of items automatically identified by our method andirrepresents the set of defects that are manually detected from the document which act as the baseline in the evaluation.
table shows the evaluation results on the stock trading system.
22alternative flow steps are detected with defect type d2 i.e.
do not have clear starting step number.
two of them are false positives.
the reason is because of the irrelevant sentence presented in that step.
our method found 19cases where the precondition is inconsistent with the guard conditions on the flow.
our manual detection finds 21such cases.
the reason for the missing cases is that our predicate extraction method fails to extract the correct predicates for the two cases.
for detecting missing alternative flows d our tool found 83potential defects out of which 59are real defects.
the24false positives appear in 8use cases which have different writing styles with the majority of the other use cases.
thus our method failed to generate correct activity diagrams for those use cases which further leads to those false positives.
actually the document is loosely written such that use case pre conditions and post conditions do not couple with each other well.
therefore there are very limited information we can use to do the checking.
this is also the reason why the accuracy of the free text parsing does not affect too much on the accuracy of the defects detection.
.
dicussions there are some limitations manual efforts and threads to validity of our approach.
we discuss them in this section.
limitations we only assign coarse semantic meanings such as synonym conflict status changing to words in our method.
this may lead to missing of cases in defect checking.
for example in figure the action save order changes the status of the order but does not affect the legality of the order in this case.
however our method will ignore all the branch conditions after the save order action node since the verb save indicates changes of status on order.
assigning fine grained semantic meanings to words may solve this problem.
manual efforts in our approach there are three steps which may require human intervention.
if the input use case document does not follow the cockburn writing style some efforts of rewriting the use case document into the cockburn style are needed.
to decide conflict predicates three domain specific dictionaries i.e.
the synonym dictionary the conflict dictionary and the statuschanging verbs dictionary need to be manually categorized.
our method provides all possible candidates for the dictionaries based on our automatically extracted subject object and main verbs for each sentence.
then the wordnet lexical database is inspected to provide the preliminary dictionaries.
therefore the only manual effort is to check and decide the dictionaries based on the preliminary dictionaries.
if a user wants to train a domain adaptive parser manual efforts on labeling sentences into dependency trees are required.
however this step is optional in our approach.
our method achieves good accuracy without the training process.threats to validity in the evaluation we manually inspect each kind of defects and use the manual inspection results as the baseline.
the manual defects detecting is subjective to the experimenter s understanding.
to reduce this factor in our evaluation the documents are checked by two phd students in school of computing nus who have requirement engineering and natural language processing background.
for the stock trading system since it has more than sentences we did not check all the sentences when evaluating the accuracy of free text parsing.
to reduce the possible threads to validity caused by this we randomly sampled of the sentences and manually inspect the results.
.
conclusion and future work in this work we proposed a method to automatically detect defects in use case documents.
our method leverages on dependence parsing technique which allows document independent rules to be provided and is more adaptable to documents of different writing styles than shallow parsing techniques.
we formally defined common use case defects.
the evaluation with 5different use case documents shows that our method is effective in finding possible defects.
our method provides horizontal links to the original document to enable easy manual validation.
for future works we explore to enrich our method by considering semantic level meanings which may improve the conflict checking precision as discussed in section .
another possible direction is to investigate statistical classification models e.g.
logistic regression to improve the accuracy of action tuple extraction.
.