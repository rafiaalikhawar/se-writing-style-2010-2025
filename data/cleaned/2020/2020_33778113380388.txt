targeted greybox fuzzing with static lookahead analysis valentin w stholz consensys diligence mythx germany valentin.wustholz consensys.netmaria christakis mpi sws germany maria mpi sws.org abstract automatic test generation typically aims to generate inputs that explore new paths in the program under test in order to find bugs.
existing work has therefore focused on guiding the exploration toward program parts that are more likely to contain bugs by using an offline static analysis.
in this paper we introduce a novel technique for targeted greybox fuzzing using an online static analysis that guides the fuzzer toward a set of target locations for instance located in recently modified parts of the program.
this is achieved by first semantically analyzing each program path that is explored by an input in the fuzzer s test suite.
the results of this analysis are then used to control the fuzzer s specialized power schedule which determines how often to fuzz inputs from the test suite.
we implemented our technique by extending a state of the art industrial fuzzer for ethereum smart contracts and evaluate its effectiveness on real world benchmarks.
using an online analysis is particularly suitable for the domain of smart contracts since it does not require any code instrumentation adding instrumentation to contracts changes their semantics.
our experiments show that targeted fuzzing significantly outperforms standard greybox fuzzing for reaching of the challenging target locations up to 14x of median speed up .
acm reference format valentin w stholz and maria christakis.
.
targeted greybox fuzzing with static lookahead analysis.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa 12pages.
introduction automatic test generation is known to help find bugs and security vulnerabilities and therefore improve software quality.
as a result there has emerged a wide variety of test generation tools that implement techniques such as random testing and blackbox fuzzing greybox fuzzing as well as dynamic symbolic execution and whitebox fuzzing .
these techniques differ from each other in how much of the program structure they take into account.
in general the more structure a testing tool may leverage the more effective it becomes in discovering new paths but the less efficient it is in generating permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
inputs.
for example greybox fuzzing lies in the middle of this spectrum between performance and effectiveness in increasing coverage.
in particular it uses lightweight runtime monitoring that makes it possible to distinguish different paths but it may not access any additional information about the program under test.
what these techniques have in common is that just like any static or dynamic path based program analysis they can usually only explore a subset of all feasible paths in a program under test for instance in the presence of input dependent loops.
for this reason path based program analyses are typically not able to prove the absence of errors in a program only their existence.
to make bug detection more effective existing work has focused on guiding the exploration toward warnings reported by a static analysis e.g.
unverified program executions e.g.
or sets of dangerous program locations e.g.
.
this is often achieved with an offline static analysis whose results are recorded and used to prune parts of the search space that is then explored by test generation.
the offline static analysis may be semantic e.g.
based on abstract interpretation or not e.g.
based on the program text or its controlflow graph.
a semantic analysis must consider all possible program inputs and states in which a piece of code may be executed.
as a result the analysis can quickly become imprecise thus impeding its purpose of pruning as much of the search space as possible.
for better results one could resort to a more precise analysis which would be less efficient or to a more unsound analysis.
the latter would limit the number of considered execution states in order to increase precision but may also prune paths that are unsoundly verified .
our approach.
in this paper we present a technique that semantically guides greybox fuzzing toward target locations for instance locations reported by another analysis or located in recently modified parts of the program.
this is achieved with an online static analysis.
in particular the fuzzer invokes this online analysis right before adding a new input to its test suite.
for the program path that the new input explores see bold path in fig.
the goal of the analysis is to determine a path prefix prefor which all suffix paths are unable to reach a target location e.g.
txandtyin fig.
.
this additional information allows the fuzzer to allocate its resources more strategically such that more effort is spent on exercising program paths that might reach the target locations thereby enabling targeted fuzzing.
more precisely this information feeds into a specialized power schedule of the fuzzer that determines how often to fuzz an input from the test suite.
we refer to our online static analysis as a lookahead analysis since given a path prefix pre it looks for reachable target locations along all suffix paths sub tree rooted at piin fig.
.
we call the last program location of prefix preasplit point piin fig.
.
unlike a ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea valentin w stholz and maria christakis p1 pi pi tytx pr e figure execution tree of a program containing target locations txand ty.
the lookahead analysis analyzes a path bold to identify a prefix presuch that no suffix paths reach a target location.
traditional static analysis the lookahead analysis does not consider all possible execution states at the split point when analyzing all suffix paths only the ones that are feasible along pre.
in other words the lookahead analysis combines the precision of a pathsensitive analysis along a feasible path prefix with the scalability of a path insensitive suffix analysis.
intuitively for a given path the precision of the lookahead analysis is determined by the number of suffix paths that are proved not to reach any target locations.
therefore to optimize precision the analysis tries to identify the firstsplit point piin fig.
along such that all targets are unreachable.
note that the lookahead analysis may consider any program location along as a split point.
when combining greybox fuzzing with an online lookahead analysis we faced four main challenges which we address in this paper.
in particular we provide answers to the following questions how can the lookahead analysis effectively communicate its results to the fuzzer?
how lightweight can the analysis be to improve the effectiveness of the fuzzer in reaching target locations without having a negative impact on its performance?
how can the analysis be invoked from a certain split point along a path?
what are suitable split points for invoking the analysis to check all suffix paths?
our implementation uses harvey a state of the art industrial greybox fuzzer for ethereum smart contracts which are programs managing crypto currency accounts on a blockchain.
we extended harvey to incorporate bran a new static analysis framework for smart contracts.
a main reason for targeting the domain of smart contracts is that adding code instrumentation to contracts changes their semantics and all existing techniques that use an offline static analysis rely on instrumenting the program under test.our experiments on benchmarks show that targeted fuzzing significantly outperforms standard greybox fuzzing for reaching of the challenging target locations up to 14x of median speed up .
contributions.
we make the following contributions we introduce a greybox fuzzing algorithm that uses a lightweight online static analysis and a specialized power schedule to guide the exploration toward target locations.
we implement this fuzzing algorithm by extending the harveygreybox fuzzer with bran a static analysis for smart contracts.
we evaluate our technique on real world benchmarks and demonstrate that our lookahead analysis and power schedule significantly increase the effectiveness of greybox fuzzing in reaching target locations.
outline.
the next section provides background on greybox fuzzing and smart contracts.
in sect.
we give an overview of our technique through an example.
sect.
4explains the technical details and sect.
5describes our implementation.
we present our experimental evaluation in sect.
discuss related work in sect.
and conclude in sect.
.
background in this section we review background on greybox fuzzing and smart contracts.
.
greybox fuzzing greybox fuzzing is a practical test generation technique that has been shown to be very effective in detecting bugs and security vulnerabilities e.g.
.
alg.
1shows exactly how it works.
the grey boxes should be ignored.
a greybox fuzzer takes as input the program under test prog and a set of seed inputs s. the fuzzer runs the program with the seeds line and associates each input with the unique identifier of the path it exercises or pid.
the pids data structure therefore represents a map from a pidto the corresponding input.
note that a path identifier is computed with lightweight runtime monitoring that allows the fuzzer to distinguish different program paths.
next the fuzzer selects an input from pids for mutation line which is typically performed randomly.
this input is assigned an energy value which indicates how long it should be fuzzed line .
the input is then mutated line and the program is run again with this new input line .
if the new input exercises a path that has not been seen before it is added to pids with the corresponding path identifier lines .
this process terminates when a bound is reached such as a timeout or a number of generated inputs line .
when that happens the fuzzer returns a test suite comprising all inputs in pids each exercising a different path in the program.
.
smart contracts ethereum is one of the most well known blockchain based computing platforms.
like a bank ethereum supports accounts that store a balance in digital assets and are owned by a user.
more specifically there is support for two account types namely user and contract accounts.
790targeted greybox fuzzing with static lookahead analysis icse may seoul republic of korea contract accounts are not managed by a user but instead by a program.
the program associated with a certain contract account describes an agreement between the account and any users that interact with it.
for example such a program could encode the rules of a gambling game.
to store information such as bets from various users a contract account also comes with persistent state that the program may access and modify.
a contract account together with its managing program and persistent state is called a smart contract.
however the term may also refer to the code alone.
ethereum smart contracts can be developed in several high level languages such as solidity and vyper which compile to ethereum virtual machine evm bytecode.
users interact with a smart contract for instance to place a bet by issuing a transaction with the contract.
the transaction simply calls one of the contract functions but in order to be carried out users need to provide a fee.
this fee is called gasand is approximately proportional to how much code needs to run.
any transaction that runs out of gas is aborted.
overview we now give an overview of our approach through the example of fig.
.
example.
the figure shows a constructed function bar which is written in solidity and contained in a smart contract.
the comments should be ignored for now.
there are three assertions in this function on lines and .
a compiler will typically introduce a conditional jump for each assertion where one branch leads to a location that fails.
let us assume that we select the failing locations t14 t19 and t22 of the three assertions as our target locations.
note that any target locations could be automatically selected based on various strategies e.g.
recently modified code for smart contracts under development assertions added manually or by the compiler for checked errors such as division by zero etc.
out of the above locations t14andt19are unreachable whereas t22is reachable when input parameter ahas value .
generating a test input that reaches location t22is difficult for a greybox fuzzer and equally so for blackbox fuzzers for two reasons.
first the probability of generating value for parameter ais tiny namely 1out of .
this means that for the fuzzer to increase the chances of reaching t22 it would need to fuzz certain promising inputs with a large amount of energy.
however standard greybox fuzzers are agnostic to what constitutes a promising input that is more likely to reach a target location when mutated.
second there are more than program paths in function bar.
in fact the then branch of the first if statement line contains two input dependent loops lines 11and16 whose number of iterations depends on parameters wandz respectively.
recall that a greybox fuzzer generates new inputs by mutating existing ones from the test suite.
therefore the larger the size of the test suite the larger the space of possible mutations and the lower the chances of generating an input that reaches the target location.
existing work.
as discussed earlier there is existing work that leverages the results of an offline static analysis to guide automatic test generation toward unverified executions e.g.
.
to apply such a technique on the example of fig.
let us assume a very lightweight static analysis that is based on abstract1function bar uint256 w uint256 x uint256 y uint256 z uint256 a returns uint256 uint256 ret if x if x !
ret if y ret w w ret while w !
w assert w drop this line z z ret while ret !
z z assert ret z assert x !
w z else ret a a a assert ret !
return ret figure the running example.
interpretation and uses the simple constant propagation domain .
note that for each program variable the constantpropagation domain can only infer a single constant value.
when run offline this analysis is able to prove that target location t14is unreachable.
this is because after the loop on line the analysis assumes the negation of the loop condition that is w which is equivalent to the asserted condition.
however the analysis cannot prove that location t19is also unreachable.
this is because after the if statement on line variable ret has abstract value .
in other words the analysis finds ret to be unconstrained since the constant propagation domain is not able to express that its value is either or .
given that ret is zremains after the loop on line .
it is therefore not possible for the analysis to determine whether these two variables always have the same value on line 19and verify the assertion.
as a result automatic test generation needs to explore function bar as if no static analysis had previously run.
to check whether the assertion on line 19always holds a testing tool would have to generate inputs for all paths leading to it thus including each iteration of the loop on line .
on the other hand an existing technique for directed greybox fuzzing performs lightweight instrumentation of the program under test to extract a distance metric for each input which is then used as feedback for the fuzzer.
so the instrumentation encodes a static metric that measures the distance between the instrumented and the target locations in the control flow graph.
in our example such metrics are less effective since all instructions are relatively close to the target locations and the control flow graph alone is not precise enough to determine more semantic reachability conditions.
791icse may seoul republic of korea valentin w stholz and maria christakis in addition when directly fuzzing bytecode or assembly a controlflow graph might not be easily recoverable for instance due to indirect jumps.
lookahead analysis.
in contrast our approach alleviates the imprecision of a static analysis by running it online and does not require an explicit complete control flow graph.
our greybox fuzzer invokes the lookahead analysis for each input that is added to the test suite.
starting from split points e.g.
p1 pi and piin fig.
along an explored program path the analysis computes a path prefix pre for which all suffix paths do not reach any target location e.g.
txandty .
we refer to such a path prefix as a no targetahead prefix see def.
2for more details .
as we explain below the lookahead analysis aims to identify short no target ahead prefixes.
as an example let us consider the constant propagation analysis and an input for function bar with an even value for x thus making execution take the then branch of the first if statement on line .
along the path exercised by this input the analysis fails to show that both target locations t14andt19are unreachable for the suffix paths starting from line .
in fact the analysis is as imprecise as when run offline on the entire function.
however it does verify the unreachability of the target locations for all suffix paths from line by propagating forward the constant value of variable ret i.e.
for an even y and otherwise .
out of the many paths with an even value for x the two no target ahead prefixes until line through the then and else branches of the if statement on line are actually the shortest ones for which the lookahead analysis proves that target locations t14andt19are unreachable.
power schedule.
the no target ahead prefixes computed by the lookahead analysis are used to control the fuzzer s power schedule which assigns more energy to certain inputs according to two criteria.
first it assigns more energy to inputs that exercise a rare i.e.
rarely explored no target ahead prefix.
the intuition is to fuzz these inputs more in order to increase the chances of flipping a branch along the rare prefix and thereby reaching a target location.
note that flipping a branch in a suffix path can never lead to a target location.
for this reason our power schedule no longer distinguishes inputs based on the program path they exercise but rather based on their no target ahead prefix.
to maximize the chances of discovering a target location with fuzzing the lookahead analysis tries to identify the shortest no target ahead prefixes which are shared by the most suffix paths.
for the example of fig.
consider the two no target ahead prefixes until line that we discussed above.
consider also the no target ahead prefix until the successful branch of the assertion on line .
the inputs that exercise these prefixes are dynamically assigned roughly the same energy by our schedule if one of them is exercised more rarely than the others it is given more energy.
this makes reaching target location t22significantly more likely than with standard power schedules based on path identifiers which assign roughly the same energy to each input exercising one of the thousands of paths in bar.
second our power schedule also assigns more energy to inputs exercising rare split points in a no target ahead prefix similarly to how existing work assigns more energy to rare branches .
the intuition is the following.
any newly discovered no targetahead prefix is by definition rare it has not been fuzzed before.since it is rare the power schedule will assign more energy to it as discussed above.
however there are programs where new no target ahead prefixes can be easily discovered for instance due to an input dependent loop.
in such cases a power schedule only focusing on rare prefixes would prioritize these new prefixes at the expense of older ones that explore rare program locations such as split points.
for this reason when a split point in a no target ahead prefix becomes rare the power schedule tries to explore it more often.
as an example consider the code in fig.
2while taking the comments into account that is replace lines 5and19with the comments and drop line .
the assertion on line 19holds but the constant propagation analysis is too weak to prove it.
as a result for any path through this assertion its no target ahead prefix has to include line .
however new no target ahead prefixes are very easily discovered for instance by exploring a different number of iterations in any of the two loops.
so even if at some point the fuzzer discovers the path that successfully exercises the assertion on line its no target ahead prefix will quickly become less rare than any new prefixes going through the loops.
the corresponding input will therefore be fuzzed less often even though it is very close to revealing the assertion violation.
by prioritizing rare split points for instance line our power schedule will assign more energy to that input.
this increases the chances of mutating the value of ato be and reaching target t22.
both of these criteria effectively guide the fuzzer toward the target locations.
for fig.
our technique generates a test that reaches t22in 27s on average between and 48s in runs .
standard greybox fuzzing does not reach t22in out of runs with a timeout of 300s.
the target location is reached in 113s during a fifth run so in 263s on average.
for this example our technique achieves at least a 10x speed up.
why smart contracts.
while our approach could in principle be applied to regular programs it is particularly useful in the context of smart contracts.
one reason is that in this setting combining an offline static analysis with test generation using code instrumentation would change the program semantics.
recall that a transaction with a smart contract is carried out when users provide enough gas which is roughly proportional to how many instructions are run.
since instrumentation consumes gas at execution time it could cause a test generation tool to report spurious outof gas errors.
note that harvey the fuzzer we use in this work does not instrument the program to collect path identifiers but relies on call backs from the virtual machine.
another reason for targeting smart contracts is that most deployed contracts are only available as bytecode and recovering the control flow graph from the bytecode is challenging.
technique in this section we describe our technique in detail by first formally defining a lookahead analysis sect.
.
.
we then discuss how to integrate such an analysis with greybox fuzzing to enable a more targeted exploration of the search space sect.
.
.
lastly we present a concrete algorithm for a lookahead analysis based on abstract interpretation.
792targeted greybox fuzzing with static lookahead analysis icse may seoul republic of korea .
lookahead analysis let us first define a prefix and a no target ahead prefix of a given path.
definition prefix .given a program pand a path inp we say that preis aprefix of iff there exists a path which we call suffix such that concat pre .
note that in the above definition may be empty in which case pre.
definition no target ahead prefix .given a program p target locations t and a prefix preof a path in p we say that preis anotarget ahead prefix iff the suffix of every path concat pre inpdoes not contain a target location t. note that any path in a program pis trivially a no target ahead prefix since there cannot be any target locations after reaching the end of its execution.
for a given no target ahead prefix the analysis computes a lookahead identifier lid that will later be used to guide the fuzzer.
definition lookahead identifier .given a no target ahead prefix pre the lookahead identifier is a cryptographic hash hash pre .
the above definition ensures that it is very unlikely that two different no target ahead prefixes map to the same lid.
unlike a path identifier pid in standard greybox fuzzing which is computed purely syntactically a lidcaptures a no target ahead prefix which is computed by semantically analyzing a program path.
as a result two program paths with different pids may share the same lid.
in other words lookahead identifiers define equivalence classes of paths that share the same no target ahead prefix.
definition lookahead analysis .given a program p an input i and a set of target locations t alookahead analysis computes a lookahead identifier for the corresponding no target ahead prefix pre of path exercised by input i and a set of split points sps along pre.
note that a lookahead analysis that simply returns the hash of path exercised by input iand all locations along is trivially sound but typically imprecise.
for a given input the precision of the analysis is determined by the length of the no target ahead prefix and thereby the number of suffix paths that are proved not to contain any target locations.
in other words the shorter the no target ahead prefix for a given input the more precise the lookahead analysis.
.
fuzzing with lookahead analysis the integration of greybox fuzzing with a lookahead analysis builds on the following core idea.
for each input in the test suite the lookahead analysis determines a set of split points that is program locations along the explored path.
it then computes a no target ahead prefix which spans until one of these split points and is identified by a lookahead identifier.
the fuzzer uses the rarity of the lookahead identifier as well as of the split points that are located along the no target ahead prefix to assign energy to the corresponding input.
the grey boxes in alg.
1highlight the key extensions we made to standard greybox fuzzing.
for one our algorithm invokes thealgorithm greybox fuzzing with lookahead analysis.
input program prog seeds s target locations t 1pids runseeds s prog 2while interrupted do 3input pickinput pids 4energy 5maxenergy assignenergy input 6maxenergy lookaheadassignenergy input 7while energy maxenergy do input fuzzinput input pid run input prog ifisnew pid pids then lid sps lookaheadanalyze prog input t pids add pid input lid sps pids energy energy output test suite inputs pids lookahead analysis on line .
this is done for every new input that is added to the test suite and computes the lidof the no targetahead prefix as well as the split points spsalong the prefix.
both are stored in the pids data structure for efficient lookups e.g.
when assigning energy .
we also replace the existing power schedule on line with a specialized one given by lookaheadassignenergy line .
as discussed in sect.
our power schedule assigns more energy to inputs that exercise either a rare lidor a rare split point along a no target ahead prefix.
we define the new power schedule in the following.
definition rare lid .given a test suite with lids alid is rare iff fuzz rarity cutoff where fuzz measures the number of fuzzed inputs that exercised so far and rarity cutoff 2isuch that 2i min fuzz 2i.
for example if the lidwith the fewest fuzzed inputs has been explored times then any lidthat has been explored less than 26times is rare.
the above definition is inspired by an existing power schedule for targeting rare branches that introduced such a dynamically adjusted rarity cutoff .
their experience shows that this metric performs better than simply considering the nlids with the lowest number of fuzzed inputs as rare.
definition rare split point .given a test suite with split points spsalong the no target ahead prefixes a split point pis rare iff fuzz p rarity cutoff where fuzz p measures the number of fuzzed inputs that exercised pso far and rarity cutoff 2isuch that 2i min p spsfuzz p 2i.
power schedule.
our power schedule is defined as follows for an input iwith lid and split points spsalong the no target ahead 793icse may seoul republic of korea valentin w stholz and maria christakis algorithm lookahead algorithm.
input program prog input input target locations t 1 run input prog 2i 3sps 4while i do 5ifissplitpoint i then 6 pre sps sps 8 loc prefixinference pre ifaretargetsunreachable prog loc t then return computehash pre sps i i 12return computehash sps output lookahead identifier split points sps prefix min 2selected i k if is rare p sps pis rare otherwise .
in the above definition selected i denotes the number of times that iwas selected for fuzzing line in alg.
and kis a constant in our implementation .
intuitively our power schedule assigns little energy to inputs whose lidis not rare and whose no targetahead prefix does not contain any rare split points.
otherwise it assigns much more energy the amount of which depends on how often the input has been selected for fuzzing before.
the energy grows exponentially up to some bound k similarly to the cut offexponential schedule in aflfast .
.
lookahead algorithm alg.
2shows the algorithm for the lookahead analysis which is implemented in function lookaheadanalyze from alg.
1and uses abstract interpretation .
first the lookahead analysis executes the program input concretely to collect the exercised path line in alg.
.
given path it searches for the shortest no target ahead prefix preby iterating over possible split points p lines .
let us explain these lines in detail.
on line the algorithm calls a predicate issplitpoint which is parametric in which locations constitute split points.
all locations along could be split points but to narrow down the search the implementation may consider only a subset of them for instance at conditional jumps.
at each split point the analysis performs two separate steps prefix inference and suffix checking.
the prefix inference line statically analyzes the prefix preusing abstract interpretation to infer its postcondition .
this step essentially executes the prefix in the abstract for all possible inputs that exercise this path.
given condition the analysis then performs the suffix checking to determine if all target locations are unreachable line .
this analysis performs standard forward abstract interpretation by computing a fixed point.
if all target locations are unreachable the analysis terminates and returns a non empty lidby computing a hash over the program locations along the path prefix pre line .
this ensures that the analysis returns as soon as it reaches thefirst split point for which all targets are unreachable.
in addition it returns the set of all split points along prefix pre.
even though off the shelf abstract interpreters are not designed to perform prefix inference and suffix checking it is relatively straightforward to extend them.
essentially when invoking a standard abstract interpreter on a program the path prefix is always empty whereas our lookahead analysis is partially path sensitive i.e.
for the prefix but not the suffix .
due to this partial pathsensitivity even an inexpensive abstract domain e.g.
constant propagation or intervals might be able to prove unreachability of a certain target location which would otherwise require a more precise domain for an empty prefix .
split points.
in practice it is important to choose split points with care since too many split points will have a negative impact on the performance of the lookahead analysis.
in our implementation we only consider split points when entering a basic block for the first time along a given path.
the intuition is that the lookahead analysis should run every time new code is discovered.
our experiments show that this design decision results in negligible overhead.
calls.
to keep the lookahead analysis lightweight we analyze calls modularly.
more specifically any calls to other contracts are conservatively treated as potentially leading to target locations.
note that inter contract calls are used very sparingly in smart contracts and that intra contract calls are simply jumps.
implementation our implementation extends harvey .
it is actively used at one of the largest blockchain security consulting companies1both for smart contract audits and as part of an automated smart contract analysis service2 more than .9m analyzed contracts from march to december .
for our purposes we integrated harvey with bran our new abstract interpretation framework for evm bytecode which is open source3.
bran is designed to be scalable by performing a very lightweight modular analysis that checks functional correctness properties.
unlike other static analyzers for evm bytecode e.g.
securify and madmax bran runs directly on the bytecode without having to reconstruct the control flow graph or decompile to an intermediate language.
bran is equipped with a constant propagation domain which is commonly used in compiler optimizations.
it handles all opcodes and integrates the go ethereum virtual machine to concretely execute any opcodes with all constant arguments.
prefix length.
during our preliminary experiments with the integration of harvey andbran we observed that the prefix length may become quite large for instance in the presence of inputdependent loops.
however the running time of the lookahead analysis is proportional to the prefix length and our goal is to keep the analysis as lightweight as possible.
for this reason our implementation ignores any split points after the first bytecode locations of the prefix.
note that this design decision does not affect the soundness of the lookahead analysis it only reduces the search space of prefixes and might result in considering the entire path as the no target ahead prefix.
794targeted greybox fuzzing with static lookahead analysis icse may seoul republic of korea experimental evaluation we now evaluate our technique on real world ethereum smart contracts.
first we discuss the benchmark selection sect.
.
and describe our experimental setup sect.
.
.
we then evaluate the effectiveness of the static lookahead analysis in greybox fuzzing sect.
.
and identify potential threats to the validity of our experiments sect.
.
.
.
benchmark selection we evaluated our technique on a total of smart contracts which originate from github repositories.
tab.
1gives an overview.
the first column lists a benchmark identifier for each smart contract under test while the second and last columns provide the name and description of the containing project.
note that a repository may contain more than one contract for instance including libraries from each repository we selected one or more contracts for our evaluation.
the third and fourth columns of the table show the number of public functions and lines of solidity code in the benchmarks.
we provide links to all repositories as well as the changesets used for our experiments in a technical report .
it is important to note that the majority of smart contracts are under lines of code.
still contracts of this size are complex programs and each of them might take several weeks to audit.
however as it becomes clear from the example of fig.
code size is not necessarily proportional to the number of feasible program paths or the difficulty to reach a particular target location with greybox fuzzing.
the repositories were selected with the goal of ensuring a diverse set of benchmarks.
in particular they include popular projects such as the ens domain name auction the consensys multisig wallet and the microraiden payment service.
in addition to being widely known in the ethereum community these projects are highly starred on github stars in total on median have been independently audited and regularly transfer large amounts of assets.
moreover our selection includes contracts from various application domains like auctions wallets and tokens attacked contracts namely the dao and parity wallet as well as contracts submitted to the first underhanded solidity coding contest uscc .
entries in this contest aim to conceal subtle vulnerabilities.
for selecting these repositories we followed guidelines on how to evaluate fuzzers .
we do not randomly collect smart contracts from the ethereum blockchain since this would likely contaminate our benchmarks with duplicates or bad quality contracts that is contracts without users assets or dependencies for instance on libraries or other contracts.
.
experimental setup our experiments compare the integration of harvey andbran incl.
three variants with harvey alone to evaluate the effectiveness of targeted fuzzing.
the comparison focuses on the time it takes for each configuration to cover a set of target locations.
harveyis the only greybox fuzzer for smart contracts and there are no existing targeted black or whitebox fuzzers for smart contracts.
implementing a targeted whitebox approach purely for comparison for instance based on symbolic execution such as katch isbids name functions losc description 1ens ens domain name auction cmsw consensys multisig wallet gmsw gnosis multisig wallet 6bat bat token advertising 7ct consensys token library 8ercf erc fund investment fund 9fbt firstblo o d token e sports hpn havv en payment network mr micr oraiden payment service mt mod token supply chain pc payment channel rnts request network token sale da o thed ao organization vt valid token personal data uscc1 uscc entr y uscc2 uscc honorable mention uscc3 uscc 3r d place uscc4 uscc 1st place uscc5 uscc 2nd place pw parity multisig wallet bnk bankera token total table overview of benchmarks.
the first column lists a benchmark identifier for each smart contract under test while the second and last columns provide the name and description of the containing project.
the third and fourth columns provide the number of public functions and lines of source code in the benchmarks.
beyond the scope of this paper.
existing work already provides a detailed comparison showing how targeted grey and whitebox approaches complement each other.
targets.
we randomly selected up to four target locations for each benchmark to avoid bias e.g.
by only targeting assertions or recently modified code .
in particular we picked contract locations of varying difficulty to reach based on when they were first discovered during a 1h standard greybox fuzzing run.
so we randomly picked at most one newly discovered location if one existed from each of the following time brackets in this order 60m 30m .
15m .
.5m and .
.75m.
this ensures that all targets are reachable.
consequently for a given prefix any unreachable targets are proved so by the constant propagation domain.
this is possible mainly due to the path sensitivity provided by the prefix inference which strengthens the capabilities of the imprecise constant propagation domain during suffix checking.
runs.
we performed runs of each configuration on the benchmarks of tab.
.
for each run we used a different random seed the same seed input and a time limit of 1h i.e.
600s .
in our results we report medians and use wilcoxon mann whitney u tests to determine if differences in medians between configurations are statistically significant.
machine.
we used an intel xeon cpu .67ghz core machine with 50gb of memory running debian .
.
.
results we now evaluate the effectiveness of our technique by investigating five research questions.
795icse may seoul republic of korea valentin w stholz and maria christakis rq1 effectiveness of targeted fuzzing.
tab.
2compares our baseline configuration a which does not enable the static lookahead analysis with configuration b which does.
note that configuration a uses the cut off exponential power schedule of aflfast whereas b uses our specialized schedule.
the first two columns of the table indicate the benchmark and target ids.
columns and show the median time in seconds required to discover the first input that reaches the target location time to target for both configurations and column shows the speed up factor.
column shows the p value which indicates the level of statistical significance here we use p .05for significant differences.
the last two columns show vargha delaney a12 effect sizes .
intuitively these measure the probability that configuration a is faster than b and vice versa.
for out of target locations we observe significant differences in time i.e.
p .
marked in bold in the table.
configuration b significantly outperforms a for out of of these target locations with a median speed up of up to 14x for one of the targets in benchmark .
in general the results suggest that targeted fuzzing is very effective and unsurprisingly its impact is most significant for difficult targets i.e.
with high time to target for configuration a .
specifically for the targets with ta 900ortb configuration b is significantly faster for with insignificant differences between a and b for the remaining targets.
note that running the static analysis with an empty prefix resembling an offline analysis on these benchmarks is not able to guide the fuzzer at all.
since all our target locations are reachable by construction the analysis soundly reports them as reachable.
therefore the fuzzer still needs to explore the entire contract to see if they indeed are.
rq2 effectiveness of lookahead analysis.
to measure the effect of the lookahead analysis we created configuration c which is identical to configuration b except that the analysis is maximally imprecise and inexpensive.
specifically aretargetsunreachable from alg.
2simply returns false and consequently the computed lids capture entire program paths similarly to pids.
as shown in tab.
there are significant differences between configurations b and c for target locations.
configuration b is significantly faster than c for out of targets and they are equally fast for of the remaining target locations.
interestingly configuration c is faster than a for all target locations with significant differences .
this suggests that our power schedule regarding rare split points is effective independently of the lookahead analysis.
rq3 effectiveness of power schedule.
to measure the effect of targeting rare lids and rare split points in our power schedule we created configuration d. it is identical to configuration b except that it uses a variant of aflfast s cut off exponential power schedule .
the original power schedule assigns energy to an input ibased on how often its pidhas been exercised.
in contrast our variant is based on how often its lidhas been exercised and corresponds to using the results of the lookahead analysis with a standard power schedule.
however as shown in tab.
configuration b is faster than configuration d for of targets with significant differences .
this indicates that our power schedule significantly reduces the timeto target thus effectively guiding the fuzzer.bid target id ta tb ta tb p a12 aa12 b 179145a51 35ee .
.
.
.
.
.
79145a51 bd4 .
.
.
.
.
.
060a46c9 d03 .
.
.
.
.
.
060a46c9 e29 .
.
.
.
.
.
2060a46c9 16a5 .
.
.
.
.
.
060a46c9 1f11 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
708721b5 4ac .
.
.
.
.
.
3708721b5 1ca0 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
9b8e6b2a d08 .
.
.
.
.
.
9b8e6b2a 18f0 .
.
.
.
.
.
9b8e6b2a 1fee .
.
.
.
.
.
9b8e6b2a .
.
.
.
.
.
5a3e5a7f c09 .
.
.
.
.
.
5a3e5a7f 23f .
.
.
.
.
.
5a3e5a7f 1da8 .
.
.
.
.
.
5a3e5a7f 1d67 .
.
.
.
.
.
387bdf82 da7 .
.
.
.
.
.
8e2aedada 15a7 .
.
.
.
.
.
8e2aedada 17bb .
.
.
.
.
.
e2aedada d71 .
.
.
.
.
.
8e2aedada 13a8 .
.
.
.
.
.
9dada6ee2 .
.
.
.
.
.
dada6ee2 b ee .
.
.
.
.
.
dada6ee2 90e .
.
.
.
.
.
d98d1d6b 1f10 .
.
.
.
.
.
d98d1d6b 401a .
.
.
.
.
.
d98d1d6b 3cdd .
.
.
.
.
.
d98d1d6b 3ce8 .
.
.
.
.
.
3ae06fb e 34db .
.
.
.
.
.
3ae06fb e 3de2 .
.
.
.
.
.
3ae06fb e 3ef3 .
.
.
.
.
.
3ae06fb e 10b2 .
.
.
.
.
.
0203d94d .
.
.
.
.
.
b8c706d1 125e .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
06ef1a9c 27ce .
.
.
.
.
.
06ef1a9c b41 .
.
.
.
.
.
06ef1a9c a16 .
.
.
.
.
.
1c57401c ef1 .
.
.
.
.
.
1c57401c .
.
.
.
.
.
ac0bf5ee 15e4 .
.
.
.
.
.
ac0bf5ee 171b .
.
.
.
.
.
ac0bf5ee 15e0 .
.
.
.
.
.
ac0bf5ee 70c .
.
.
.
.
.
54142e12 .
.
.
.
.
.
d047b56e 5fb .
.
.
.
.
.
b9ebdb99 40c .
.
.
.
.
.
b9ebdb99 3d1 .
.
.
.
.
.
f1e90f8f 9fd .
.
.
.
.
.
a788e7af 1f07 .
.
.
.
.
.
a788e7af 1e29 .
.
.
.
.
.
a788e7af .
.
.
.
.
.
a788e7af 32b .
.
.
.
.
.
9473c978 .
.
.
.
.
.
9473c978 e33 .
.
.
.
.
.
9473c978 150e .
.
.
.
.
.
9473c978 8e8 .
.
.
.
.
.
table comparing time to target between configuration a w o lookahead analysis and b w lookahead analysis .
nonetheless configuration d is faster than a for all targets with significant differences.
this shows the effectiveness of the lookahead analysis independently of the power schedule.
796targeted greybox fuzzing with static lookahead analysis icse may seoul republic of korea bid target id tc tb tc tb p a12 aa12 b 179145a51 35ee .
.
.
.
.
.
79145a51 bd4 .
.
.
.
.
.
060a46c9 d03 .
.
.
.
.
.
060a46c9 e29 .
.
.
.
.
.
2060a46c9 16a5 .
.
.
.
.
.
060a46c9 1f11 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
708721b5 4ac .
.
.
.
.
.
3708721b5 1ca0 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
9b8e6b2a d08 .
.
.
.
.
.
9b8e6b2a 18f0 .
.
.
.
.
.
9b8e6b2a 1fee .
.
.
.
.
.
9b8e6b2a .
.
.
.
.
.
5a3e5a7f c09 .
.
.
.
.
.
5a3e5a7f 23f .
.
.
.
.
.
5a3e5a7f 1da8 .
.
.
.
.
.
5a3e5a7f 1d67 .
.
.
.
.
.
387bdf82 da7 .
.
.
.
.
.
8e2aedada 15a7 .
.
.
.
.
.
8e2aedada 17bb .
.
.
.
.
.
e2aedada d71 .
.
.
.
.
.
8e2aedada 13a8 .
.
.
.
.
.
9dada6ee2 .
.
.
.
.
.
dada6ee2 b ee .
.
.
.
.
.
dada6ee2 90e .
.
.
.
.
.
d98d1d6b 1f10 .
.
.
.
.
.
d98d1d6b 401a .
.
.
.
.
.
d98d1d6b 3ce8 .
.
.
.
.
.
d98d1d6b 3cdd .
.
.
.
.
.
3ae06fb e 34db .
.
.
.
.
.
3ae06fb e 3de2 .
.
.
.
.
.
3ae06fb e 3ef3 .
.
.
.
.
.
3ae06fb e 10b2 .
.
.
.
.
.
0203d94d .
.
.
.
.
.
b8c706d1 125e .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
06ef1a9c 27ce .
.
.
.
.
.
06ef1a9c b41 .
.
.
.
.
.
06ef1a9c a16 .
.
.
.
.
.
1c57401c ef1 .
.
.
.
.
.
1c57401c .
.
.
.
.
.
ac0bf5ee 15e4 .
.
.
.
.
.
ac0bf5ee 171b .
.
.
.
.
.
ac0bf5ee 15e0 .
.
.
.
.
.
ac0bf5ee 70c .
.
.
.
.
.
54142e12 .
.
.
.
.
.
d047b56e 5fb .
.
.
.
.
.
b9ebdb99 40c .
.
.
.
.
.
b9ebdb99 3d1 .
.
.
.
.
.
f1e90f8f 9fd .
.
.
.
.
.
a788e7af 1f07 .
.
.
.
.
.
a788e7af 1e29 .
.
.
.
.
.
a788e7af .
.
.
.
.
.
a788e7af 32b .
.
.
.
.
.
9473c978 .
.
.
.
.
.
9473c978 e33 .
.
.
.
.
.
9473c978 150e .
.
.
.
.
.
9473c978 8e8 .
.
.
.
.
.
table comparing time to target for configurations b and c. rq4 scalability of lookahead analysis.
one key design decision for using an online static analysis as part of a dynamic analysis i.e.
greybox fuzzing was to make the static analysis as lightweightbid target id td tb td tb p a12 aa12 b 179145a51 35ee .
.
.
.
.
.
79145a51 bd4 .
.
.
.
.
.
060a46c9 d03 .
.
.
.
.
.
060a46c9 e29 .
.
.
.
.
.
2060a46c9 16a5 .
.
.
.
.
.
060a46c9 1f11 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
708721b5 4ac .
.
.
.
.
.
3708721b5 1ca0 .
.
.
.
.
.
3708721b5 .
.
.
.
.
.
9b8e6b2a d08 .
.
.
.
.
.
9b8e6b2a 18f0 .
.
.
.
.
.
9b8e6b2a 1fee .
.
.
.
.
.
9b8e6b2a .
.
.
.
.
.
5a3e5a7f c09 .
.
.
.
.
.
5a3e5a7f 23f .
.
.
.
.
.
5a3e5a7f 1da8 .
.
.
.
.
.
5a3e5a7f 1d67 .
.
.
.
.
.
387bdf82 da7 .
.
.
.
.
.
8e2aedada 15a7 .
.
.
.
.
.
8e2aedada 17bb .
.
.
.
.
.
e2aedada d71 .
.
.
.
.
.
8e2aedada 13a8 .
.
.
.
.
.
9dada6ee2 .
.
.
.
.
.
dada6ee2 b ee .
.
.
.
.
.
dada6ee2 90e .
.
.
.
.
.
d98d1d6b 1f10 .
.
.
.
.
.
d98d1d6b 3ce8 .
.
.
.
.
.
d98d1d6b 401a .
.
.
.
.
.
d98d1d6b 3cdd .
.
.
.
.
.
3ae06fb e 34db .
.
.
.
.
.
3ae06fb e 3de2 .
.
.
.
.
.
3ae06fb e 3ef3 .
.
.
.
.
.
3ae06fb e 10b2 .
.
.
.
.
.
0203d94d .
.
.
.
.
.
b8c706d1 125e .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
b8c706d1 .
.
.
.
.
.
06ef1a9c 27ce .
.
.
.
.
.
06ef1a9c b41 .
.
.
.
.
.
06ef1a9c a16 .
.
.
.
.
.
1c57401c ef1 .
.
.
.
.
.
1c57401c .
.
.
.
.
.
ac0bf5ee 15e4 .
.
.
.
.
.
ac0bf5ee 171b .
.
.
.
.
.
ac0bf5ee 15e0 .
.
.
.
.
.
ac0bf5ee 70c .
.
.
.
.
.
54142e12 .
.
.
.
.
.
d047b56e 5fb .
.
.
.
.
.
b9ebdb99 40c .
.
.
.
.
.
b9ebdb99 3d1 .
.
.
.
.
.
f1e90f8f 9fd .
.
.
.
.
.
a788e7af 1f07 .
.
.
.
.
.
a788e7af 1e29 .
.
.
.
.
.
a788e7af .
.
.
.
.
.
a788e7af 32b .
.
.
.
.
.
9473c978 .
.
.
.
.
.
9473c978 e33 .
.
.
.
.
.
9473c978 150e .
.
.
.
.
.
9473c978 8e8 .
.
.
.
.
.
table comparing time to target for configurations b and d. and scalable as sensible.
that is why our lookahead analysis is modular and uses an inexpensive and therefore scalable constantpropagation domain.
797icse may seoul republic of korea valentin w stholz and maria christakis our results confirm that the total running time of the lookahead analysis is a tiny fraction of the total running time of the fuzzer .
.93s of a total of 3600s per benchmark median .73s .
this confirms that even a very lightweight static analysis can boost the effectiveness of fuzzing.
rq5 effect on instruction coverage.
in our evaluation there were no noticeable instruction coverage differences between any of our configurations.
this indicates that our approach to targeted greybox fuzzing mainly affects the order in which different program locations are reached.
even though we prioritize certain inputs by assigning more energy to them the fuzzer still mutates them randomly and eventually covers the same instructions as standard fuzzing.
to avoid this we would need to restrict some mutations e.g.
ones that never discover new lids much like fairfuzz restricts mutations that do not reach rare branches.
.
threats to validity we have identified the following threats to validity.
external validity.
a potential threat to the validity of our experiments has to do with external validity .
in particular our results may not generalize to other contracts or programs.
to alleviate this threat we selected benchmarks from several diverse application domains.
moreover we provide the versions of all contracts used in our experiments so that others can also test them .
the results may also not generalize to other target locations but we alleviate this threat by selecting them at random and with varying difficulty to reach.
internal validity.
internal validity is compromised when systematic errors are introduced in the experimental setup.
a common pitfall in evaluating randomized approaches such as fuzzing is the potentially biased selection of seeds.
during our experiments when comparing the different configurations of our technique we consistently used the same seed inputs for harvey.
construct validity.
construct validity ensures that any improvements for instance in effectiveness or performance achieved by a particular technique are due to that technique alone and not due to other factors such as better engineering.
in our experiments we compare different configurations of the same greybox fuzzer and consequently any effect on the results is exclusively caused by their differences.
related work our technique for targeted greybox fuzzing leverages an online static analysis to semantically analyze each new path that is added to the fuzzer s test suite.
the feedback collected by the static analysis is used to guide the fuzzer toward a set of target locations using a novel power schedule that takes inspiration from two existing ones .
in contrast the most closely related work performs an offline instrumentation of the program under test encoding a static distance metric between the instrumented and the target locations in the control flow graph.
when running a given input the instrumentation is used to obtain a dynamic aggregated distance.
this distance subsequently guides the fuzzer toward the target locations.since a control flow graph cannot always be easily recovered from evm bytecode e.g.
due to indirect jumps our lookahead analysis directly analyzes the bytecode using abstract interpretation .
our implementation uses the constant propagation domain to track the current state of the evm for instance to resolve jump targets that are pushed to the execution stack .
unlike traditional static analyses it aims to improve precision by performing a partially path sensitive analysis that is path sensitive for a prefix of a feasible path recorded at runtime by the fuzzer and path insensitive for all suffix paths.
guiding greybox fuzzers.
besides aflgo there is a number of greybox fuzzers that target specific program locations rare branches uncovered branches or suspected vulnerabilities .
while several of these fuzzers use an offline static analysis to guide the exploration none of them leverages an online analysis.
guiding other program analyzers.
there is a large body of work on guiding analyzers toward specific target locations or potential failures by combining static and dynamic analysis.
these combinations typically perform an offline static analysis first and use it to improve the effectiveness of a subsequent dynamic analysis for instance by pruning parts of the program.
for example check n crash integrates the esc java static checker with the jcrasher test generation tool .
similarly dyta combines the .net static analyzer clousot with the dynamic symbolic execution engine pex .
yogi constantly refines its over and under approximations in the style of counterexample driven refinement .
in contrast our lookahead analysis is online and constitutes a core component of our targeted greybox fuzzer.
hybrid concolic testing combines random testing with concolic testing .
even though the technique significantly differs from ours it shares an interesting similarity it uses online concolic testing during a concrete program execution to discover uncovered code on the fly.
when successful the inputs for covering the code are used to resume the concrete program execution.
symbolic execution.
in the context of symbolic execution there have emerged numerous search strategies for guiding the exploration for instance to target deeper paths in depth first search uncovered statements or less traveled paths .
our technique resembles a search strategy in that it prioritizes exploration of certain inputs over others.
compositional symbolic execution has been shown to be effective in merging different program paths by means of summaries in order to alleviate path explosion.
dynamic state merging and veritesting can also be seen as forms of summarization.
similarly our technique merges different paths that share the same lookahead identifier for the purpose of assigning energy.
the more precise the lookahead analysis the shorter the no target ahead prefixes and thus the more effective the merging.
program analysis for smart contracts.
there is a growing number of program analyzers for smart contracts ranging from random test generation frameworks to static analyzers and verifiers .
in contrast we present a targeted greybox fuzzer for smart contracts the first analyzer for contracts that incorporates static and dynamic analysis.
798targeted greybox fuzzing with static lookahead analysis icse may seoul republic of korea conclusion we have presented a novel technique for targeted fuzzing using static lookahead analysis.
the key idea is to enable a symbiotic collaboration between the greybox fuzzer and an online static analysis.
on one hand dynamic information i.e.
feasible program paths are used to boost the precision of the static analysis.
on the other hand static information about reachable target locations more specifically lookahead identifiers and split points is used to guide the greybox fuzzer toward target locations.
our experiments on real world benchmarks show that targeted fuzzing significantly outperforms standard greybox fuzzing for reaching of the challenging target locations up to 14x of median speed up .
we believe that the idea of using an online lookahead analysis to prune the search space of a path based technique e.g.
fuzzing or symbolic execution is not specific to smart contracts.
however the trade offs e.g.
with respect to scalability of the lookahead analysis may be significantly different in other settings whether different programming languages or different path based techniques .
we plan to investigate such variants in the future.