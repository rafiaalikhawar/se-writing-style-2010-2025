verified from scratch program analysis for learners programs andreas stahlbauer university of passau germanychristoph fr drich university of passau germanygordon fraser university of passau germany abstract block based programming languages like scratch support learners by providing high level constructs that hide details and by preventing syntactically incorrect programs.
questions nevertheless frequently arise is this program satisfying the given task?
why is my program not working?
to support learners and educators automated program analysis is needed for answering such questions.
while adapting existing analyses to process blocks instead of textual statements is straightforward the domain of programs controlled by block based languages like scratch is very different from traditional programs in scratch multiple actors represented as highly concurrent programs interact on a graphical stage controlled by user inputs and while the block based program statements look playful they hide complex mathematical operations that determine visual aspects and movement.
analyzing such programs is further hampered by the absence of clearly defined semantics often resulting from ad hoc decisions made by the implementers of the programming environment.
to enable program analysis we define the semantics of scratch using an intermediate language.
based on this intermediate language we implement the bastet program analysis framework for scratch programs using concepts from abstract interpretation and software model checking.
like scratch bastet is based on web technologies written in typescript and can be executed using nodejs or even directly in a browser.
evaluation on 279programs written by children suggests that bastet offers a practical solution for analysis of scratch programs thus enabling applications such as automated hint generation automated evaluation of learner progress or automated grading.
ccs concepts software and its engineering integrated and visual development environments software testing and debugging.
keywords software model checking scratch education acm reference format andreas stahlbauer christoph fr drich and gordon fraser.
.
verified from scratch program analysis for learners programs.
in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn .. .
.
introduction block based programming is increasingly popular for introducing learners to programming as well as for simplifying the challenges of programming for domain experts with limited programming skills .
in block based programming languages program statements are represented visually as blocks which users drag and drop from a toolbox of available commands to visually arrange programs.
this paradigm is implemented by many popular programming environments such as for example alice snap pencilcode or 28other drag and drop programming environments surveyed recently .
block based programming increasingly has applications outside of education for example in domains such as robotics or internet of things .
the recent success of the block based approach however can be attributed to a large extent to the popularity of scratch .
at the time of this writing the popular scratch programming environment had more than 54million registered users who have publicly shared more than 53million programs1and written more programs not shared.
although block based programming languages like scratch are successful at making programming easier they do not simplify program analysis even though at first glimpse scratch programs look small and easy they tend to consist of many highly concurrent scripts which are composed of blocks that hide complex mathematical functions that control the program s visual representation.
to lower the entry barriers and to foster widespread adoption most block based programming environments are designed as web applications and the interpreters for these blocks tend to be built into the web applications and are often implemented in an ad hoc way without clearly defined semantics.
since scratch programs do not have an intermediate language that they are translated to statically analyzing a scratch program with its full semantics would therefore require to conduct an analysis of the scratch vm together with the scratch program to be analyzed loaded into it.
although challenging the demand for automated program analysis has never been higher for example for automated hint generation supporting program improvement evaluating learner progress or automated grading .
in this paper we introduce bastet2 a general program analysis framework for scratch .
figure illustrates the overall workflow ofbastet using a primary school programming task in which the aim is to make the circus director move to the monkey sprite.
to analyze scratch programs bastet uses a textual intermediate language leila described in section .
bastet provides a library describing the functionality of all scratch blocks in leila .
as an example the leila implementation of the move n steps block is shown.
the scratch program itself is translated to leila and the same intermediate language is used for formal specification .
the program is then interpreted using the semantics of is the ancient egyptian goddess of cats the scratch logo is a cat.
35th ieee acm international conference on automated software engineering ase abstractreachabilitygraphactorstageisscratchstagebegin endactormonkeyisscratchspritebegin end program leila actordirectorisscratchspritebegin .... scriptonstartupdobegin repeatforeverbegin pointtowards locate monkey movesteps end end endmove steps blocklibrary scratch defineatomicmovesteps n integer begin declarenfasfloat definenfascastntofloat declareradiansasfloat defineradiansasdegtorad .
castdirectiontofloat declaredxasfloat declaredyasfloat definedxasnf cos radians definedyasnf sin radians definexasx castdxtointeger defineyasy castdytointeger end blocklibrary leila when clicked forever pointtowards monkey move 1steps program scratch stagemonkeydirectorspecification leila task controltransitionsystems actordirectorobserverisobserverbegin .... scriptonstatementfinisheddobegin .... if...thenbegin failure end end end3 scriptgroup directorobserver scriptgroup stage scriptgroup monkey scriptgroup director pointtowards a actor movesteps n integer onstartup pointtowards locate monkey movesteps 5figure bastet overview scratch programs are translated to the leila intermediate language which bastet analyzes using concepts from abstract interpretation and software model checking with respect to a leila specification.
leila section .
thus enabling the application of various program analysis configurations using concepts from abstract interpretation and software model checking section .
like scratch bastet itself is based on web technologies and written in typescript and can be executed in nodejs or even directly in a web browser.
in detail the contributions of this paper are as follows we define the leila intermediate language for scratch programs and their formal requirements specification section .
we discuss the central parts of its semantics as well as approximations to handle the complexity of scratch.
we introduce the bastet program analysis framework section and release it as an open source project.
we empirically demonstrate that bastet is practically applicable to scratch programs written by children section .
a pilot study of 279children s implementations of four educational programs shows that the translation of scratch programs into leila and the interpretation with bastet maintains the program semantics.
this demonstrates that bastet provides the foundations for many different types of program analysis on scratch.
by releasing bastet as open source we hope to inspire many future automated analyses and support techniques thus helping learners as well as their teachers or automated tutoring systems.
background before we present our framework we introduce relevant background based on existing work .
we use upper case lettersa b ... z or letters with a hat ba bbfor sets lower case lettersa b ... z for set elements lists and sequence variables are indicated by adding a bar a a the set of all words over an alphabet ais denoted bya .
sets are enclosed in curly brackets a1 ... lists in angle brackets a1 ... and tuples in round brackets a1 ... an .scratch.
scratch programs are developed visually and blockbased in the corresponding development environment .
as in other block oriented languages the grammar of scratch is defined implicitly by allowing or preventing scratch blocks to be combined.
a scratch program app is composed of a set of visual entities consisting of the sprites and the stage the program in fig.
is composed of the sprites director andmonkey and the stage stage.
the visual entities are rendered on a canvas each entity is rendered on a separate layer .
one visual entity is composed of a set of scripts a set of custom blocks and sound and image resources.
each script handles an event and is composed of a set of blocks to execute.
scratch programs are controlled by events typically triggered by mouse or keyboard inputs.
a scratch program is executed in the scratch virtual machine.
concrete states and behaviours.
the semantics of ascratch program app is defined by the set of concrete execution traces it exhibits that is c .
the set of all possible concrete execution traces c c c consists of the set of finite traces c and the set of infinite traces c .
one program trace c c0 ... c is a sequence of concrete states and always starts in the initial concrete state c0of a program.
a concrete state c c configuration of a scratch program is a listc p1 ... pn of concrete process states pi x v. each concrete process state piis a mapping from a data location x x a variable to a data value v v. we call an instance of a scratch script a process.
a concrete process state describes the state of a process at one point in time the set of all processes is denoted by .
processes are organized into process groups that correspond to visual entities of a scratch program we also use the term actor for such an entity.
the set of data values is typed that is it is the union v vint vfloat vstring vlistof data values of different types a list value is a sequence v vlistof data values.
a set of special data locationsxctrl pid pgroup pc pstate pwaitfor ptime xstores 151information about the computation control state of the processes and the environment pidis the process identifier pgroup identifies the process group pcis the program counter which denotes the position in a script to execute pstate wait running yield done is the computation state of the process pwaitfor is the set of processes the process waits for ptime denotes the time that has elapsed since the application has been started.
other typical elements in the set x are variables that describe the sprite attributes such as position size and the orientation of a sprite x y size direction x. intermediate language analyzing scratch programs statically is hard since it would require to analyze the full scratch vm along with the scratch program because the vm defines the functionality of blocks the semantics of scratch are implemented in the scratch vm3.
the semantics of scratch blocks is defined informally on the scratch wiki4 a workaround5 which defines how to mimic a block s semantics without using that block is given for each of the blocks.
we reverse engineered the semantics of scratch and its blocks and describe it based on our own intermediate language leila learners intermediate language similar to the use of promela in thespin model checker for c programs .
we replicate the functionality of the blocks available in scratch in a scratch block library written in leila.
only control structures data types expressions and statements that are relevant to mimic the behavior ofscratch in this library are part of the leila language definition.
.
language features leila is designed to aid in program analysis and also to be easily readable for people that are familiar with block based programming languages like scratch also because leila is intended to be used as a specification language by teachers.
leila allows for inheritance and event driven programming and has distinct keywords for program analysis and verification.
data is exchanged either via message passing or via global memory access.
syntax.
the syntax of leila is oriented on languages that are used to introduce people to programming early for example pascal grail orlogo and influenced the design ofscratch.
evidence shows that these languages use syntactic elements that are often more intuitive for novices compared to those in widely used general purpose languages.
figure shows central parts of leila s grammar.
the full antlr grammar is shipped with our framework.
an example for a program written in leila can be found in fig.
.
actors and roles.
we use the term actor corresponding to the keyword actor to denote an entity that is visible to the user or the environment also for interaction using inputs or by passing messages that provides functionality to act in a particular role.
leila supports inheritance by providing the keyword isand uses the keyword roleto define abstract actors that is collections of pre defined methods and attributes data that can be instantiated in an actor.
we consider this notion of actors and roles to be closer to the intuition that is promoted by scratch.
examples for typical roles to realize scratch programs are sprite and stage.
3github.com llk scratch vm4en.scratch wiki.info 5en.scratch wiki.info wiki list of block workarounds program program id group group actor role id begin comps end comps ressource attribute method script ressource image sound id uri attribute declare id as type type integer float boolean string listof type actor script script on event do stmts method define id params stmts extern id params stmts params param param param id type stmts begin stmt end event bootstrap startup started asclone message string specevent specevent bootstrap finished statement finished figure a fraction of the leila grammar.
the full grammar is defined based on antlr.
each scratch sprite each clone of a sprite corresponding to the fork of a process and the stage correspond to one actor another actor is added for communicating with the environment mouse and keyboard inputs .
on the technical level an actor is formed by the list of processes that are executed concurrently dual to a process group in related work .
note that our notion of actor is slightly different from the notion used to describe actor models in that work an actor is not composed of several processes that is an actor corresponds to a single process only.
verification additions.
we added particular language features to leila that aid in analysis and verification and allow for realizing different approximations of a programs behavior see also sect.
.
.
the keyword assume can be used to specify invariants that can be assumed to always hold at particular points in a program.
in particular this is relevant for restricting possible values of variables that have been initialized non deterministically.
other features help to provide the formal specification of desired behaviors of a program asleila code on statement finished on bootstrap finished see sect.
.
and help to determine which code fragments to consider as one atomic keyword atomic program operation which must not be preempted by the scheduler the specification must not be checked in between all non control flow blocks of scratch are modeled as atomic methods .
.
control transition system after translating a scratch project to leila we use its abstract syntax tree ast and translate it into collections of control transition systems the result is a list of actor definitions with a control flow graph for each script and each method the actor defines.
this is the foundation to define the operational semantics ofleila programs and their scratch counterparts.
the control flow semantics of leila are implemented in the process of translating leila programs into lists of actor definitions with their corresponding control transition relations.
152leila program.
we formally define a leila program as a list a a of actor definitions.
one actor definition a s bm h ais a tuple consisting of a list sof scripts a set bmof method definitions and a concernh.
each actor contributes to a concern h h where hdenotes the set of all concerns.
for this work we restrict the set of concerns to h prog spec env that is it can be either theprogram concern prog the specification concern spec or the environment concern env.
the analysis procedure treats actors that are instantiated from actor definitions with the specification concern in a special way see sec.
.
.
methods and scripts.
both methods and scripts are defined based on transition systems.
a control transition system l l0 lx g consists of a set of control locations l anentry location l0 l a set of exit locations lx l and a set of control transitions g l op l. one control transition l1 op l2 ghas a predecessor location l1 a program operation to execute op and a successor location l2 that is locationl2issyntactically reachable via location l1after conducting program operation op op.
amethodm id rt bmis defined by a tuple consisting of an identifier id a list of parameters x a result variable rt x and a transition relation .
ascripts w r sis defined by a tuple consisting of an event w s s x a flagr b keyword restart which indicates whether the execution of the script should be re started from its transition relations entry location in case the event is triggered and the transition relation .
the eventw x consists of a message identifier string a string that specifies the message channel and a list of arguments xthat is passed to the script if the event is triggered the set sdenotes all possible strings expressible in leila.
we assume that the inheritance relation of actor definitions is dissolved upfront in a preprocessing step for example all methods of the ancestor actors or roles become methods of the given actor definition itself.
methods are used to define the behavior of the blocks that can be composed visually to a scratch program.
a script can invoke all methods defined for the actor.
program operations.
the set of atomic program operations opconsists of operations of various types which can manipulate or check the set of data locations x variables for example assume operations such as assume a b constructed from ifa b then are guarding statements and express conditions under that the successor location is reachable assign operations such as define xas42 assign new values to data locations.
the epsilon operation opis a special operation that does neither affect the state space nor the behavior of the program.
the termination operation halt opsignals the termination of the program.
the set oftyped data locations xis the union of the set of integer data locationsxint float locations xfloat string locations xstring and list locationsxlist.
.
concrete semantics so far we have described the formalization of a leila program as a list of actor definitions a a and their scripts and methods control transition relations now we are interested in its semantic denotation c which execution traces are feasible for a given program?
the operations on the control transitions betweenthe control locations give rise to the actual behaviors and states of aleila program the operational semantics .
in the following we describe an important subset of leila s semantics a document with the full formal semantics is left for future work.
initialization.
the execution of a leila programa a is bootstrapped by a special bootstrapping actor which is instantiated from the actor definition aboot aand orchestrates the initialization process.
the bootstrapping actor is the first active actor in the system.
it conducts the following three steps the bootstrapper first triggers thebootstrap event using the statement broadcast bootstrap to system and wait which activates the on bootstrap event handler scripts.
after all actors have handled this event it activates all handlers for the event bootstrap finished after which the system is considered initialized and all scripts that handle the event startup are activated corresponding to scratch s green flag event.
details onleila s event handling are explained later in this section.
aleila program is bootstrapped from the initial concrete state c0 p1 ... pn which is a list of concrete process states.
note that one actor see sect.
for our notion of actors is formed by a set of processes also known as a process group.
only the process that belongs to the bootstrapping actor is in the computation state running that is supposed to make state transitions.
in detail the initial concrete state is defined as follows the vertical bar corresponds to a set theoretic such that assuming that the listsaandsaare iterated from left to right c0 pid s pgroup a pc l0 pstate r pwaitfor ptime s l0 s s sa a sa a r running ifa abootelsewait .
the initial concrete state c0is the first element in all concrete execution traces of a given leila programa.
note that variables declared by the user are added to the concrete state as soon as a corresponding variable declaration statement was executed.
step.
after we have defined the initial concrete state of a leila program we define the prefix closed set of sequences of concrete states that are considered feasible for a given program.
the concrete state transition relation c cof a given leila program defines the set of traces that are considered feasible.
given a concrete stateci a concrete transition ci ci 1exists if the list of processes incithat are in the computation state pstate running and the control transitions bg l op lthey conduct lead to the concrete stateci p i ... p n by interpreting the program operations of the control transitions bg.
a tracec c0 ... c isfeasible if for all succeeding states ci ci cholds that ci ci .
in this work we restrict the number of processes that can concurrently conduct a state transition to one at a point in time and realize an interleaving concurrency.
given a concrete state c cand a concrete process state p p of a process to run a program operation op opthat leads to a successor control location l lis always interpreted in context of the process and the actor a process group it belongs to.
we therefore define the concrete successor function csucc c p op l csuch that a call csucc c p op l takes a concrete predecessor state c a processp to interpret the operation opin to get to the successor location l. this call can also be written 153ascsuccp c op l .
the function implements the actual semantics of given program operations.
we now provide a more formal definition of the concrete transition relation using the functions step c p candstep c p c. the function steptakes a concrete state and a list of concrete process states as input and computes one concrete successor state for which all processes that were in the state running conducted their state transitions.
the processes in the state running are processed deterministically from left to right.
we define c c if and only if step c c c c c where step c p p1 ... c if p step step c p1 p2 ... if p the actual interpretation of the control transitions for a particular concrete process states to reach a successor location l is initiated by the function step step c p pc l pstate r ... c ifr running c l op l gcsuccp c op l otherwise note that both stepandsteparedeterministic functions since they operate on concrete states for which none of the data locations has non deterministic values.
scheduling.
leila programs have an inherent notion of parallelism.
a scheduler determines the next process to run the process state to put in the running state after a state transition has been conducted.
for leila we propose a round robin scheduling strategy in combination with a sequentialization exactly one process conducts a state transition at one point in time steps of different processes are interleaved.
this corresponds to the green threading strategy that is implemented in the scratch vm.
this important design choice reduces the number of interleavings to consider by a model checker considerably since there is always only one process thread to conduct the next state transition.
the round robin scheduling is paused as long as a process performs computation in a code block marked with the keyword atomic.
this is important to mimic the scheduling of processes in environments like the scratch vm as well as possible.
for example the operations that implement the move n steps scratch block see fig.
must not be interrupted by other computations and are handled as one atomic unit.
another important deviation of round robin scheduling is made for observer processes with statement finished event handlers.
these types of processes implement monitors that observe whether or not the specification is still satisfied and signal a violation if not.
these monitoring handler processes become activated each time a non monitoring process finished an atomic state transition.
event handling.
scratch programs are driven by events and so areleila programs.
most events boil down to handle incoming messages.
for example the event on bootstrap translates to on message bootstrap to system and on startup translates to on message startup to system .
messages can be explicitly qualified with a channel name for example the message broadcast to system is qualified with the channel name system .
in case no channel is provided we use the default channel user .actor thingobserver i sobserver begin define atomic c h e c k b e h a v i o r s a t i s f i e d begin .
.
.
i f .
.
.
then begin f a i l u r e the thing must not ... end end s c r i p t on bootstrap finished do begin .
.
.
c h e c k b e h a v i o r s a t i s f i e d end s c r i p t on statement finished do begin c h e c k b e h a v i o r s a t i s f i e d end end figure formal specification skeleton based on leila after handling a broadcast statement all processes that correspond to scripts which are handlers for the received message are activated in the computation mode yield in case a script has the flagrestart the process s program counter variable pcis set to the initial control location of the script.
a broadcast with the postfix and wait pauses the sending process computation state wait as long as there exists an active process that was triggered by sending the given message and has not reached an exit location of its script.
.
specifying programs one goal of our work is to enable teachers students and others in writing formal programming task specifications.
we propose to use separate actors with the specification concern to monitor the state space and the program s behavior as also proposed in related work .
we extended leila with constructs that aid in the specification task event handlers for bootstrap finished are triggered after all actors have been initialized these can be used to check the base condition of the specification.
all event handlers for statement finished are triggered each time the program under analysis conducts a transfer for an actor that belongs to the program concern.
this scheduling corresponds to the activation of observer processes in related work .
handlers for this event ensure that the specification is satisfied and a failure is signaled in case of a specification violation using a particular failstatement.
figure shows a specification skeleton written in leila.
touching cat ball says caught .
serror figure timed automatontypical scratch program specifications contain both safety and bounded liveness properties.
the liveness properties are typically time bound that is expressible in some real time temporal logic such as mitl .
the timed automaton in fig.
illustrates an example property that is also expressible in leila.
.
approximations to make reasoning about scratch programs feasible we use several approximations of possible states and behaviors.
these are needed to deal with undecidable theories dependency on the real time and the execution speeds of machines the state space explosion problem that can arise due to non deterministic behavior e.g.
from the non deterministic scheduling of processes and heavily datadependent properties e.g.
the pixels shown on a screen .
154some of these approximations already happen while translating from scratch toleila programs.
we believe that the semantic differences between these languages are not relevant for typical learners tasks such that reasoning results about programs in the intermediate language can be transferred to the original scratch programs we evaluate this in sect.
.
time.
time is important for scratch programs and their specifications.
the liveness properties that are relevant in practice can often be time bound.
leila programs have access to the time that has elapsed since the program has been started.
we approximate the time that expires while executing a scratch program or a corresponding leila program by mapping a time interval to each operation in a program s control flow.
we use a time profile t op n n with n n to map an interval of microseconds to each program operation op op and use this interval to update a global time variable globaltime an example is given later that models the time that has expired since the program under analysis was started.
this allows analyses to also check real time properties formulated based on some real time temporal logic such as mitl .
the lifting operation t a a transforms a given leila programa to a new leila programat a tby taking a time profile tinto account.
that is program analysis techniques that are not time aware are applicable.
such reductions were done in the past by translating timed automata or some form of real time temporal logic in general to predicate logic.
technically we add control transitions after each control transition l op l of the original program to update the time based on the interval t op .
only actors of the program concern prog are lifted.
the added transitions are labeled with program operations that correspond to following three leila statements declare optime as integer assume optime min and optime max define g l o b a l t i m e asg l o b a l t i m e optime these statements adjust the time that is assumed to be expired after executing the operation op with minand max replaced by corresponding constants.
note that we take advantage of the fact that the variable optime has a non deterministic value which we then restrict using the assume statement in its range.
we add the control transitions only if an operation s time interval is not empty that is if max min .
by convention we assume that the last concrete state of each finite program trace in c is entered by the terminating operation with the statement halt.
we assign the time interval to these termination calls which states that the program is either restarted immediately stays terminated forever or is restarted at some time in between.
scheduling.
scratch has an inherent notion of concurrency.
a scheduling component determines the ordering of the scratch threads to run leading to an interleaved concurrency.
we do not implement all details of scratch s scheduler e.g.
particular aspects of how the scheduler deals with loops and rely purely on leila s deterministic round robin scheduling.
the differences in our scheduling strategy can influence the soundness of statements figure approximations of the shape of scratch sprites define atomic mathsin i n p u t f l o a t begin i fi n p u t .
and i n p u t .
then begin assume r e s u l t .
assume r e s u l t .
end e l s e i fi n p u t .
and i n p u t .
then assume r e s u l t .
assume r e s u l t .
.
.
.
figure excerpt from the sine approximation function we make about scratch programs.
the scheduler that is implemented in the scratch vm can lead to non deterministic schedules in some circumstances specifically in case one round in the list of processes threads takes longer than .
.
ms after which the list is processed from its first element.
resources.
a central building block of scratch applications are images and sounds.
images are used as backdrops for the stage and costumes for the sprites.
attributes of images and their relationship on a canvas are important properties of scratch programs to reason about.
for example certain behavior might be only visible if the pixels of a sprite are touching the mouse pointer or if the pixels of two sprites overlap on the canvas.
instead of considering every single pixel of every image for reasoning we approximate the shape of images.
while there are different ways to do this we use one rectangle per shape as an approximation and implement this approximation for the scratch blocks touching mouse pointer touching edge and touching monkey in our block library written in leila.
note that there are different ways to approximate the shape of sprites.
see fig.
for some shape approximations single rectangles circles multiple rectangles a perfect approximation of the sprites shapes would indicate that the two given sprites do not overlap while the presented approximations cannot detect this.
mathematical functions.
a fundamental problem that limits the applicability of elaborated analysis techniques like model checking is the undecidability of some mathematical logics such as the firstorder theories of natural and rational number multiplication.
to reduce the mathematical complexity of some of the analysis tasks in the context of scratch projects we overapproximated several of the mathematical methods and provide these approximations in the leila library as code.
in particular we applied intervalization in some of the methods.
by putting these approximations into the libraries the actual decision procedures in our analysis framework can be more generic and do not have to provide support for functions like sine or cosine.
figure shows an excerpt of the sine lookup function which takes a value between 0and2 and returns an interval that approximates the sine value.
analysis framework a central contribution of this work is bastet a framework for automatically analyzing and verifying scratch programs translated to leila.
the long term vision of bastet is to provide the foundations for implementing different program analysis techniques that aid in analyzing programs written in visual block oriented programming languages.
in particular we aim at providing the foundations for automatic test generation data flow analysis unbounded model checking based on predicate abstraction and concolic execution .
we focus on describing the framework components for implementing a software model checker to verify safety properties and bounded liveness properties.
this section therefore assumes knowledge on software model checking we refer to the literature for background information .
.
overall architecture the overall workflow of bastet for model checking scratch programs consists of three phases in the first phase task models are generated.
a verification task consists of a specification and the given program which is parsed and translated from scratch toleila.
specification and program are both transformed into the set of task actors.
in the second phase the actual program analysis is conducted which constructs for example an abstract reachability graph.
more generally for this phase bastet builds on concepts from abstract interpretation static analysis software model checking and configurable program analysis .
the program analysis consists of a set of analysis algorithms section .
where one algorithm can wrap another one as illustrated in fig.
.
analysis algorithms act on an abstract representation of a program s state space and its behaviors provided by a set of state interpreters section .
.
the last phase produces output artifacts for example error witnesses test suites or correctness proofs if a suitable analysis configuration is used.
since we aim at running program analyses while programming in a web browser we have taken a novel route and built bastet entirely on web technologies the framework is written in typescript attached smt solvers z3 are compiled to webassembly and the framework can run in nodejs or on top of a browser.
.
abstract domain to make statements about properties of programs bastet relies on abstraction which is central for constructing finite abstractions of a programs state space and to cope with the undecidability of most program analysis problems .
the abstract domain d c e provides the central operations for abstraction and for mapping between abstract states and sets of concrete states.
the set of abstract states eis arranged in a lattice e e and is partially ordered by itsinclusion relation e e b. the meet e e e join e e e top element and the bottom element are defined as usual.
the concretization function e 2cmaps an abstract state eto a set of concrete states c for example cand .
the abstraction function 2c e maps a set of concrete states to an abstract state.
widening is provided by an abstract domain with widening d d which defines an abstraction with widening e ebased on multi property feasibility reachabilitygraph control ssa dataalgorithmsstate interpreters abstract domains abstract statesfigure composed analysis procedure the set of abstraction precisions .
an abstraction precision determines the information to maintain by an abstraction computation.
different realizations of an abstract domain are possible for example based on predicate logic or based on combinations of several abstract domains .
in this work we do not evaluate an analysis that conducts any widening but consider this functionality central for the bastet program analysis framework.
.
algorithms the flow of the analysis steps is determined by several analysis algorithms where one analysis algorithm can wrap another one .
each of these algorithms operates on at least the set of reached states reached and the set of frontier states frontier also called worklist or waitlist of an abstract reachability graph the nodes of this graph are abstract states.
the following analysis algorithms are implemented in bastet for a resource bounded model checking procedure.
reachability.
the reachability algorithm based on configurable program analysis conducts the reachability analysis as shown in alg.
starting from an initial set of reached states and an initial set of frontier states both are passed as arguments to the algorithm the algorithm traverses the state space of the analysis task until either a fixed point of the reachable states was attained a target state was found or a resource budget was exhausted.
atarget state is an abstract state for that one or more properties to check were signaled to be violated.
the algorithm is implicitly parameterized with a state interpreter si which defines different operators the algorithm uses to compute abstract successor states merge abstract states or check coverage.
the state space traversal strategy is determined by the operation choose on the set frontier .
feasibility.
whenever the analysis reaches a target state the feasibility of this state has to be checked.
a target state is feasible only if it represents at least one concrete state that is reachable if the program is executed concretely for example in the scratch vm.
an abstract state can be infeasible in case the wrapped analysis computed an abstraction widening that overapproximated the set of reachable states or a decision procedure for example a smt solver was not yet invoked to check if the abstract state represents a non empty set of concrete states.
to foster a clear separation of concerns we use a separate feasibility check algorithm which can also be extended to implement a cegar loop and conduct precision refinements.
when a target state has been reached then the reachability algorithm terminates and returns to the feasibility check algorithm which might re invoke the reachability algorithm after an infeasible state was eliminated.
note that we abstracted 156algorithm reachability frontier reached si input reached 2e set of initially reached states frontier 2e initial set of frontier states si d succ widen mergeto stop target init choose output frontier reached 2e 2e frontier frontier reached reached while frontier do e choose frontier frontier frontier e for eache succ e do e widen e reached frontier reached mergeto e frontier reached if not stop e reached then frontier frontier e reached reached e iftarget e then return frontier reached return frontier reached away some details of how concrete executions are conducted in the scratch vm that is not all feasible target states might be actually feasible due to slightly different semantics see sect.
.
.
multi property.
the multi property algorithm maintains the status of all properties from the formal specification to check.
among the set of reached states and the frontier states the algorithm maintains the set unknown of properties for that no verdict was decided the set violated of properties that have been found to be violated along with a counterexample and the set satisfied of properties that were decided to be satisfied possibly paired with a proof of correctness .
the algorithm maintains a budget of resources that is left to check the different properties.
to decide a property s verdict another algorithm is invoked if budget is left.
.
state interpreters the main functionality for assigning meaning to a program s operations and producing an abstract representation of a program s state space and behaviors is provided by a set of state interpreters.
astate interpreter implements abstract interpretation and builds on the formalisms and operators that were introduced with the cpa concept .
we define a state interpreter by the tuple si d succ widen mergeto stop target init choose .
a state interpreter generalizes a configurable program analysis by allowing for more control of the process of merging the state space reflected by the operator mergeto .
it further makes the state space traversal process more explicit through the operators initand choose.
we define the following components .the abstract domain d c e determines the form of abstraction that is used to represent sets of concrete states as abstract states see sect.
.
for more details.
.the initoperator init 2e 2ereturns the initial sets of frontier and reached states.
it defines the state sets that are passed initially to the analysis algorithms as arguments.
.theabstract transfer function succ e 2eprovides the set of abstract successor states for a given abstract state.
a labelled abstract transfer succ op e 2ecomputes abstract successor states by interpreting a given program operation op op.
.the widening operator widen e 2e eis used to compute widenings of abstract states that is with e widen e .
typically the widening is parameterized implicitly with an abstraction precision resulting in widen e 2e e. .the merge to operator mergeto e 2e 2e 2e 2e can be used to merge a given abstract state into existing abstract states to keep the abstract reachability graph compact.
it is crucial for the performance of an analysis procedure.
algorithm illustrates one possible implementation of this operator which mimics the merge functionality of the cpa algorithm .
the algorithm uses the function allowmerge e e b which defines whether or not a merge is intended and the operator merge e e e which actually merges two abstract states we assume that merge is only defined for states with allowmerge e true.
the variant allowmergenever e frontier reached frontier reached never merges a given abstract state into the state space and avoids looping over the states already reached and thus reduces the complexity of the reachability analysis.
.the stop operator stop e 2e bdefines whether or not the given abstract state should be added to the sets frontier andreached .
typically this operator conducts a coverage check and is crucial for a fixed point iteration the state is only added if not yet covered by the existing set of reached states that is stopcover e r r r e r .
.the target operator target e 2sdefines the set of properties s that should be signaled to be reached or violated at the given state.
these properties can be for example trap properties of a test generation procedure or other safety properties to check by model checking.
.the choose operator choose 2e edetermines the statespace traversal strategy of the analysis it returns the next state to compute successor states for from a given set of abstract states typically the set of frontier states .
by default bastet uses the operatorchoose wam which implements the wait at meet traversal strategy.
for each control location of the transition systems of the leila program to analyze a wait at meet number is computed that ensures that all states that lead to a control location on that the control flow merges are processed before continuing to the merge location.
partitioning.
three operators in the reachability algorithm take the set of already reached states reached as argument the widening operator widen the merge to operators mergeto and the stop operator stop.
different subsets of reached might be relevant for the operators to conduct their job in a sound fashion while not sacrificing the degree of completeness.
considering only a subset of reached states can have a considerable impact on the performance and algorithmic complexity for example of alg.
of the analysis.
by default we partition the set of reached states based on the position in the control flow the different processes are in.
157algorithm mergetostd e frontier reached input e e abstract state to possibly merge frontier 2e current set of frontier states reached 2e current set of reached states output frontier reached 2e 2e remove add for eachr reached do ifallowmerge e r then e merge e r remove remove r add add e frontier frontier add remove reached reached add remove return frontier reached .
basic state interpreters in the following we describe the state interpreters that we consider to be of wider interest and which we have evaluated in our empirical study on the applicability of our framework.
figure illustrates the combination of the analysis components.
graph interpreter.
the graph interpreter sigkeeps track of the predecessor successor relation of abstract states and constructs the abstract reachability graph.
the graph interpreter uses the abstract domaindgwith the lattice uof graph states u. agraph stateu w bu uconsists of a wrapped abstract state w eand a set of predecessor graph states bu u. in its merge to operator mergetog the interpreter makes sure that whenever a state is removed from the graph because is was merged into another state also all its children are removed from the graph and also takes care of readding states to the set of frontier states frontier in case one of the removed states was in there.
note that our mergeto operator makes explicit that a merge can affect both the set of reached and frontier states which is not exemplified in the original cpa formalism .
control interpreter.
the control interpreter sictakes care of modeling the control flow of leila programs including modeling unrollings of loops keeping track of the call stack conducting message passing and including the scheduling of threads see sect.
.
.
the position in the control flow and the computation status of the different threads is modeled explicitly not symbolically .
the control interpreter wraps another interpreter and provides the labeling between on transitions that is the labeled abstract transfer of the wrapped interpreter is called.
the control interpreter uses the control abstract domain dcwith the lattice zof abstract control states z. the interpreter merges two abstract control states only if all its processes are on the same control location if they have the same call stack the same loop unrollings if all processes are in the same computation state and if also the wrapped abstract states are supposed to be merged.
ssa interpreter.
the ssa interpreter sistransforms the program operations that are passed to its labeled abstract transfer function into a single static assignment form such that wrapped interpreters can build on this.
in the context of model checking an ssa transformation cannot be done in a preprocessing step but dependson runtime information such as the number of loop unrollings or the call stack.
the ssa interpreter uses the abstract domain dswith the lattice sof ssa states s. an ssa states w sconsists of awrapped abstract state w eand a ssa map x n which maps to each data location a current ssa index.
the ssa interpreter delegates the decision whether or not to merge two abstract states to the wrapped interpreter.
in case two ssa states are supposed to be merged the merge functionality of the ssa interpreter ensures that also the ssa maps of the states are merged and synchronized that is the ssa functions applied in the merge operation.
the wrapped analysis is instructed to also synchronize the information based the function.
this clear separation of concerns is missing in some established frameworks.
data interpreter.
the data interpreter sidkeeps track of the data state of leila programs by encoding all data values of data locations on the heap and the stack into predicate logic.
we require that this state interpreter is wrapped by an ssa interpreter which ensures that all program operations that are given to the labeled transfer function are in the ssa form.
the interpreter uses the abstract domain ddwith the lattice m of abstract data states m. one data state m mconsists of a block formula in predicate logic only which encodes the full content of the heap and stack data locations.
in its standard configuration the interpreter always allows to merge two abstract data states.
that is given two abstract data statesm1 1 mandm2 2 m the result is a new abstract data state m3 m1 m2 where the join of the lattice corresponds to the boolean disjunction 1 2of the two formulas.
the labelled abstract transfer function succ opencodes the semantics of a given operation into the formula of the successor state.
pilot study to demonstrate the practical applicability of the bastet framework for analyzing scratch projects we conduct an empirical pilot study.
to make our results easy to reproduce we provide a replication package and provide the bastet framework as open source github.com se2p artifact ase2020 .
in this study we aim to answer the following research questions rq1 soundness .
to which extent does translating scratch projects toleila maintain the semantics such that both useful and sound propositions can be made?
rq2 performance .
are the typical limitations of model checking such as the state space explosion problem and undecidable theories limiting factors when applied to scratch projects?
.
study objects we conduct our empirical study based on four scratch programming exercises taken from the context of primary school programming education .
the children are given an informal specification of what the program is supposed to do and so we can compare their solutions against the specifications which we formalized in leila.
related work describes details on the setup of the course.
monkey.
this exercise uses two sprites a circus director and a monkey.
the goal is to have the circus director move continuously 158towards the monkey.
the formal specification requires that the circus director must make a step at least once every ms and that the circus director may not move away from the monkey.
elephant.
this exercise is implemented with a single sprite the elephant which has different costumes.
the goal is to create the impression that the elephant is dancing by continuously switching the costumes.
our formal specification requires that a costume change must take place at least every .
s. cat.
this exercise comprises two sprites a cat and a ball.
the goal is that the cat indicates via a speech bubble that it has caught the ball as soon as it touches the ball sprite.
the formal specification therefore states that within .
safter the sprites touch the cat sprite must say that it caught the ball see fig.
.
horse.
this exercise uses a single sprite that reacts to mouse inputs.
as long as the sprite is not touched by the mouse pointer it should continuously change its color as soon as it touches the mouse pointer it should rotate.
the formal specification requires that its color must change at least every ms or its direction must change at least every ms if the mouse pointer is touched.
the dataset consists of 279non empty solutions to these four exercises.
we automatically translated all solutions to leila and also wrote the formal specifications in leila for all four projects.
.
experimental setup bastet was used in revision aa1026a with a bounded model checkingconfiguration using a time bound of s .
all experiments were conducted on machines equipped with intel xeon e5 v2 .
ghz cpus with gib of ram.
bastet was executed within docker containers.
all processes were limited to consume at most gib of ram and were limited to at most 4cpu cores.
the measured execution wall clock time excludes the time needed to parse the given scratch project or corresponding leila program and the time for starting and initializing the nodejs environment.
.
experiment procedure we conducted the following experiments to answer our questions rq1.
to learn about the soundness of bastet we first inspected all student solutions manually and checked if they satisfy the specification.
we executed bastet on all of these 279solutions and then compared bastet results with our manually assigned verdicts.
rq2.
to make statements about the applicability of model checking toscratch projects and the resulting performance we use bastet configured as a time bound model checker and run it on the verification tasks pairs of student solutions and formal specification described earlier.
our hypothesis is that scratch programs tend to be simple and might not have the complexity of traditional programs and thus also expensive techniques like model checking seem in reach to get results efficiently.
.
rq1 results soundness table presents the comparison between the results of the manual inspection with those computed by bastet automatically.
bastet yields 3false negatives falsely reports program correctness.
the false negative for monkey is due to a lost orderingtable model checking soundness exercisetrue positivetrue negativefalse positivefalse negativemissed safemissed unsafe monkey cat elephant horse table model checking performance exercisemin timemax timemedian timemin reachedmax reachedmedian reached monkey .
cat .
elephant .
.
horse .
of the actors while translating to leila which leads to an interleaving of the script executions that hides the bug an imprecision that can be fixed in principle.
the other two false negatives were produced for the cat exercise and have the same cause they both only check whether the cat touches the ball once at the start of the program rather than in a forever loop.
since the programs do not initialize the sprites positions bastet assumes that the positions are non deterministic and thus the solutions are actually correct.
this is a good example for the value of formal specifications and the challenges of producing them.
we can also see 5true negatives where bastet was able to reach a fixed point in the state space and to actually prove the correctness of the solutions.
the evaluated configuration produced 40true positives cases where we can observe undesired behavior and 2false positives cases in which a violation was reported while the solution is correct.
the false positives were produced because we assumed the mouse position to be non deterministic as an approximation while in true program executions it can change only after handling messages from the event dispatcher loop.
the configuration we studied is conceptually only able to provide correctness proofs for programs without infinite loops.
many of the solutions contain forever loops thus we expected a high number in the column missed safe .
for 36verification tasks bastet was not able to terminate with a solution because of the undecidability of arithmetic with multiplication which is used by the atan2 function invoked by the pointtowards .. block.
in total of the violations reported were true positives.
consequently translating scratch projects into leila and interpreting them by bastet maintains the semantics in the clear majority of the studied verification tasks.
.
rq2 results performance this question addresses the performance of model checking using thebastet framework when applied to scratch projects.
table shows the performance measures for bastet in terms of time and size of the abstract reachability graphs restricted to results with the verdict false.
the median time lies between sfor the monkey exercise and s for the elephant exercise.
while the number 159of states is substantial considering the size of the programs we cannot observe dramatical explosions of the reachability graphs.
analysis of the runtime behavior of bastet suggests that large portions of the time were spent in the smt solver.
consequently while scratch programs may seem simple and playful they bear a high mathematical complexity which is due to their game like nature involving multiplication and division of natural and real numbers.
the majority of the analysis time is spent in the smt solver.
nevertheless bastet managed to identify of all bugs.
.
discussion this pilot study clearly demonstrates the practical applicability of bastet for analyzing real world scratch programs.
instead of demonstrating this based on a basic data flow analysis we demonstrated how even a heavy weight model checking procedure can be implemented on top of bastet to check learners programs.
while most of the time for running a verification task is spent in the smt solver we identified further potential for performance improvements by making use of the potential to use alternative implementations of the analysis operators for example by using versions of the operators stop andmergeto that iterate over smaller partitions of the reached states.
since leila uses a deterministic interleaving concurrency we do not face the state space explosion problem that is typical for concurrent programs with non deterministic schedulers.
note that the scheduler implemented in scratch can have non deterministic behavior.
our results indicate that this design decision does only have a minor impact on the soundness of bastet s model checking configuration.
approximations of mathematical functions such as sinandcoswere crucial to cope with some of the undecidable characteristics that are inherent to scratch program and also to deal with limitations of the smt solver theories.
related work the increasing popularity of scratch as an introductory programming environment has triggered research on analyzing the resulting programs.
in particular the observation that scratch programmers tend to develop certain negative habits while coding has led to investigations into the general quality problems in scratch programs.
it has been shown that various types of code smells are prevalent and have a negative impact on code understanding .
similar habits have been observed outside of scratch in the wider area of scenario based programming .
most existing tools for analysis of scratch programs have their roots in the hairball python script which parses scratch .
programs into a kind of abstract syntax tree.
for example the dr. scratch website includes code smell reports produced byhairball when analyzing learners programs.
further analysis tools aiming to detect code smells include quality hound andsat .
these tools mostly analyze scratch programs only by matching patterns while bastet is a full fledged and configurable program analysis framework and inherits concepts from well adopted tools like cpachecker .
a common application of program analysis in the educational domain is automated grading the itch tool translates a small subset of scratch programs to python programs textual interactions via say ask blocks and then runs tests on these programs.
thewhisker tool executes automated tests directly in the scratch ide and supports property based testing.
autograding has also been applied to the related snap!
language .
beyond grading an important application area for automated program analysis is automated hint generation for example by identifying suggested next blocks based on the evolution of similar programs .
furthermore automated refactoring has been considered as a route to helping students improve their coding skills.
bastet provides a foundational framework that can better support these activities.
furthermore bastet is implemented directly in typescript in order to support the direct integration of program analyses into educators and learners environments which are often web based.
bastet uses leila as its intermediate language which was designed to reflect the semantics of scratch as well as possible to provide constructs for program analysis and verification and to be comprehensible by teachers and learners.
the use of intermediate languages is a common approach to enable analysis and other example languages include an intermediate language for timed asynchronous systems a translation of timed csp into llvm ir the c intermediate language or a textual representation of timed state charts .
nevertheless none of them was immediately applicable to the programs we aim to analyze.
building on concepts found in established frameworks such as cpachecker bastet contributes an evolved and holistic perspective on the components of a program analysis framework.
for example we refined the cpa algorithm by providing a more general merge operator that can manipulate both the reached and the frontier states.
among the conceptual differences bastet is the first program analysis framework entirely built on web technologies.
conclusions block based programming languages are tremendously popular and their popularity leads to a need for automated program analysis.
however the game like and concurrent nature of typical programs their web based execution environments and their ad hoc semantics make this challenging.
to address this problem in this paper we introduced bastet a framework for program analysis and verification for scratch programs based on abstract interpretation and software model checking.
bastet is based on a clean definition of the semantics of scratch programs and a translation to the leila intermediate language.
a pilot study on 279real children s programs demonstrated the soundness and potential of the approach.
the pilot study also revealed that despite their playful nature and small size the programs represent fundamental challenges for verification offering potential for future work on improving the performance and capabilities of the program analysis approach.
besides principle enhancements and optimizations of bastet future work will also explore different ways to apply bastet for supporting learners and educators.
to foster research on these aspects bastet is available as open source at