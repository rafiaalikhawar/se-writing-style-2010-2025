where shall we log?
studying and suggesting logging locations in code blocks zhenhao li l zhenha encs.concordia.ca concordia university montreal quebec canadatse hsun peter chen peterc encs.concordia.ca concordia university montreal quebec canadaweiyi shang shang encs.concordia.ca concordia university montreal quebec canada abstract developerswriteloggingstatementstogeneratelogsandrecord system execution behaviors to assist in debugging and software maintenance.however decidingwheretoinsertloggingstatements is a crucial yet challenging task.
on one hand logging too little may increase the maintenance difficulty due to missing important systemexecutioninformation.ontheotherhand loggingtoomuch mayintroduceexcessivelogsthatmasktherealproblemsandcausesignificantperformanceoverhead.priorstudiesproviderecommendationsonlogginglocations butsuchrecommendations areonly forlimitedsituations e.g.
exceptionlogging oratacoarse grained level e.g.
method level .
thus properly helping developers decide finer grained logging locations for different situations remains an unsolvedchallenge.inthispaper wetacklethechallengebyfirst conductingacomprehensivemanualstudyonthecharacteristics of logging locations in seven open source systems.
we uncover six categories of logging locations and find that developers usually insert logging statements to record execution information in various types of code blocks.
based on the observed patterns we then propose a deep learning framework to automatically suggest logging locationsat theblocklevel.wemodel thesource codeatthe code blocklevelusingthesyntacticandsemanticinformation.wefind that our models achieve an average of .
balanced accuracy whensuggestinglogginglocationsinblocks ourcross system logging suggestion results reveal that there might be an implicitlogging guideline across systems.
our results show that we may accurately provide finer grained suggestionson logginglocations and such suggestions may be shared across systems.
acm reference format zhenhaoli tse hsun peter chen andweiyishang.
.whereshall we log?
studying and suggesting logging locations in code blocks.
in 35th ieee acm international conference on automated software engineering ase september21 virtualevent australia.
acm newyork ny usa pages.
introduction logsplayanimportantroleinmaintainingsoftwaresystemsand diagnosing issues that happen during runtime.
developers rely onlogsforvariousmaintenanceactivities suchasdebugging permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
testing and system comprehension .
developersinsertloggingstatementsinthesourcecodewithdifferentverbositylevels e.g.
trace debug info warn error andfatal to record system execution information and values of dynamic variables.
for example in the logging statement log.warn invalid groupingkey key the static text message is invalid groupingkey and the dynamic message is the value of the variable key.theloggingstatementisatthe warnlevel whichisthelevel for recording information that may potentially cause system oddities .
the great value of logs results from proper logging decisions thataremadebypractitionersduringsoftwaredevelopment .
theloggingdecisionsareoftenmadeinordertobalancethebenefit and cost from logs .
on one hand inserting too few logging statements may increase the maintenance difficulty due to missing important systemexecution information fordebugging and analysis .
on the other hand inserting too many logging statements may increase system performance overhead and produce excessive trivial logs which increase the difficulty of log analysis .
however such acrucial task ofmaking loggingdecisions remains challengingduetothelackofconcreteloggingspecificationand guidelines .
as a result developers have to rely on their intuitionsandexperiencestocompose review updateandevenfix logging statements in an ad hoc manner .
to address the challenge of making logging decisions prior studies provide automated recommendations on logging locations.
however there exist two main limitations in prior research such recommendations are often only for a very limited number of situations.
approaches from prior research may onlyprovidesuggestionsforexceptionhandlingblocksandmethodreturnvalues .
thelogginglocationsarerecommendedat acoarse grainedlevel e.g.
methodlevel whilepractitioners stillneedtodecidethespecificlocationtoplacealoggingstatementinside a method.
as a result in many cases practitioners often stillfacechallengeswhenmakingdecisionsonlogginglocations despite the advance from recent research outcomes.
in this paper we conduct a study to uncover guidelines and provide suggestions on logging locations i.e.
where do developers log atafiner grainedlevel i.e.
blocklevel byanalyzinglogging statementsandtheirsurroundingcode.throughamanualstudyontheloggingstatementsfromsevenopensourcesystems wefindthat thedecisionsoflogginglocationareofteninfluencedbyboththe syntacticand semanticinformationin thesource code.moreover the logging statements often record execution information related to the block in which they reside.
driven by our manual studyresults we extract syntactic e.g.
nodes in abstract syntax trees and semantic e.g.
variable names information from the source 35th ieee acm international conference on automated software engineering ase codeandproposeanautomateddeeplearningbasedapproachto suggest logging locations at the block level.
we find that our deep learningmodelsoutperformthebaseline andthesyntacticblock featureachievesthebestresults anaveragebalancedaccuracyof .
comparedtosemanticandfused afusionofsyntacticand semantic features.
moreover syntactic information of blocks may be leveraged to provide general logging guidelines across different software systems.
in summary this paper makes the following contributions we uncover six categories of logging locations which are exceptionloggingin catchblocks branchlogginginblocks associated with decision making statements program iterationlogging loggingthestartortheendofamethod and function logging in domain specific methods.
we also discuss the common types of information that is recorded in each category.
weproposeadeeplearningbasedapproachtosuggesting logginglocationsattheblocklevelbyleveragingsyntactic semantic and fused block features extracted from the source code1.wefindthatmodelstrainedusingthesyntacticfeatures have the highest balanced accuracy .
among thethree types of features.
although there are some differences in the suggestionresults among the threefeatures syntactic features can capture around of all the suggested truepositives.
our finding shows that most logging decisions may be related to the syntactic structure of the code.
the cross system suggestion results achieve an average balancedaccuracyof67.
.wealsofindthatthereisamoderate to substantial agreement among the cross system modelstrained using the syntactic features which shows that developers of different systems may follow certain implicit guidelines on deciding logging locations.
paper organization section discusses the background and relatedworkofourstudy.section3describesthesetupofourmanual study and the categories of logging locations we find.
section 4discusses how do we extract block level features and describes ourdeep learningbasedapproach.section5presentstheevaluationmetricsandtheresultsbyansweringtworesearchquestions.
section6discussesthefalsepositivesandfalsenegativesinour suggestion results.
section discusses the threats to validity of our study.
section concludes the paper.
background and related work developersinsertloggingstatementsintothesourcecodetorecord system runtime information and use the generated logs to assistin software debugging and maintenance.
for example as shown in thesimplified codesnippet fromzookeeper below thelogging statement is at the errorlevel contains the static message missing countnode forstat and recordsthe dynamicvalue ofthe variable statnode.
datanode node nodes.get statnode if node null should not happenlog.error missing count node for stat statnode return 1we share the replication package of this paper at ase2020 logging location data.the logging statement is closely related to the specific value ofthe datanode objectandrecordsanunexpectedexecutionbehaviorinan ifblockwhenthevalueofthenodeis null.helping developers decide where to log is an on going research problem.
fu et al.
studied where do microsoft developers add logging statements in their projects written in c and focused on studying the characeristics of logging in some specific code snippets i.e.
catch blocks and return value checks .
they found that develop ers often add logging statements to check the returned value of amethodandrecordexceptions.zhuetal.
furtherextended theworkbyprovidingatoolforsuggestinglogplacementinthe twoabove mentionedcases.lietal.
providesuggestions onwhetheramethodorcommitrequiresaloggingstatement.in short prior studies either only target a limited number of logging locations or provide a coarse grained suggestion.
therefore in thispaper weexplorethepotentialofprovidingafiner grainedsupportondecidinggenerallogginglocationsthroughamanualstudy sec tion and propose an automated deep learning based approach to suggest logging locations at the code block level section .
below we further discuss the related works of this paper.
studies onlogging practices.
there are several studies on characterizingtheloggingpracticesinsoftwaresystems.yuanetal.
chen et al.
and zeng et al.
conducted quantitative characteristics studies on log messages in large scale open source c c java systems and mobile applications.
chen et al.
studied the loggingutilities andzhietal.
studiedtheloggingconfigurations in java.
they found that logs are essential for debugging and maintenance.
giventheimportanceoflogs otherstudiestrytohelpdevelopers improveloggingpractices.chenetal.
foundthatdevelopers commonly make some mistakes when writing logging statements e.g.
logging objects whose values may be null and concluded five categoriesof logginganti patterns fromcode changes.hassaniet al.
identifiedsevenroot causesofthelog relatedissuesfrom log related bug reports and found that inappropriate log messages and missing log statements are the most common issues.
li et al.
uncovered potential problems with logging statements thathavethesametextmessageanddevelopedanautomatedtooltodetecttheproblems.yuanetal.
proposedanapproachthatcan automaticallyinsertadditionalvariablesintologgingstatements to enhance the error diagnostic information.
li et al.
propose the use of prediction models to suggest the log level of a newly addedloggingstatement.liuetal.
proposedadeeplearning framework to suggest the variables that should be recorded in logging statements.
different from prior studies this paper focuses on studying logginglocationsin thepurposeofprovidingsuggestionsandguidelines on the decisions of logging locations.
the findings and approaches in thispaper can complement prior studies inproviding more comprehensive logging supports to developers.
applyingdeeplearninginsoftwareengineeringtasks.
due to the advances in deep learning recent research starts to inves tigate source code representation and apply deep learning mod els in software engineering tasks.
zhang et al.
p r o p o s e da n ast based neural network for source code representation.
they evaluated their approach on several software engineering tasks 362table an overview of the studied systems.
system version loc nol lb nlb lb cassandra .
.
432k .3k .0k .0k .
elasticsearch .
.
.50m .5k .9k .0k .
flink .
.
177k .5k .4k .5k .
hbase .
.
.26m .5k .1k .1k .
kafka .
.
267k .5k .0k .0k .
wicket .
.
216k .4k .3k .1k .
zookeeper .
.
97k .2k .9k .2k .
note locrefers to the lines of code nolrefers to the number of logging statements lband nlbrefers to the number of loggedandnon logged blocks respectively lbrefers to the percentage of loggedblocks over all the blocks.
such as source code classification and code clone detection and the results outperformed existing approaches.
tufano et al.
evaluateddifferentrepresentationofsourcecode e.g.
abstractsyntaxtreeandcontrolflow graph andtheireffectonapplyingdeep learningmodelsinsetasks.huetal.
proposedadeeplearningbasedapproachtoautomaticallygeneratecommentsforjava methods.
nghi et al.
applied deep learning models to identify the programming language used in an algorithm.
different from priorstudies wefocusonextractingsourcecodefeaturestosuggest whichblocksneedtobelogged.weconductacomprehensivemanual study on the characteristics of logging locations and propose a deep learning based approach to provide automated suggestions.
studying the characteristics of logging location in code blocks to better understand developers logging decisions and provide more concrete logging suggestions in this section we manuallyinspect the logging statements and their surrounding code.
we examineifthereexistfiner grained e.g.
atcodeblocklevels implicit or explicit common characteristics of the locations where developers insert logging statements.
studiedsystems.
weconductamanualstudyonsevenlarge scale opensourcejavasystems cassandra elasticsearch flink hbase kafka wicket andzookeeper.table1showsanoverviewofthe systems.thestudiedsystemscoverdifferentdomains e.g.
message broker searchengine anddatabase havehighqualityloggingcode and are commonly used in prior log related studies .
the size of the studied systems ranges from 97k to .5m loc and they contain from .4k to .5k logging statements.
manualstudysetup.
ourgoalistomanuallyinspectthelogging statements and their surrounding code to study the characteristics of logging locations.
to prepare the data for our manual study weextracttheloggingstatementsfromthesourcecodebyimplementing a static code parser.
our parser identifies every logging statement that invokes common logging libraries e.g.
log4j and slf4j in the code.
then for each logging statement we extract its static message and dynamic variables its verbosity level itslocation i.e.
thefileandmethodthatcontainstheloggingstatement and its surrounding code i.e.
the method that contains the logging statement .
after getting all the logging statements andthe extracted information we randomly sample out of .9k loggingstatementsbasedona95 confidenceleveland5 confidenceinterval .foreachsampledloggingstatement westudy its structural informationand data flow of the surrounding code inordertoseethepotentialfactorstakingpartinthedecisionof inserting the logging statements in a block.
specifically the firsttwoauthorsofthispaper i.e.
a1anda2 followanopencodinglikeprocesssimilartopriorstudies andinvolvein the following three phases to conduct the manual study phasei a1studies100randomlysampledloggingstatements andtheirextractedinformation andrecordthecharacteristicsof theirdataflow structural andsemanticinformation e.g.
thedependencyofvariables controlflow andthebusinesslogicofthe code .a1furtherderivesadraftlistofcategoriesoflogginglocationsbasedontheinformationrecorded.thena1anda2follow thedraftlisttolabelthe100samplescollaboratively.duringthis phase the categories are revised and refined.
phaseii a1anda2independentlyassignthecategoriesderived in phase i to the rest of the sampled logging statements.
there is no new category derived in this phase.
phaseiii a1anda2comparetheassignedcategoriesinphaseii.
anydisagreementofthecategorizationisdiscusseduntilreachinga consensus.nonewcategoriesareintroducedduringthediscussion.
the results in this phase have a cohen s kappa of .
whichis a substantial level of agreement .
categories of logging locations.
in our manual study we uncoversixcategoriesoflogginglocationsthatareassociatedwith four different types of blocks i.e.
try catch branching looping andmethoddeclaration .inparticular wefindthatthreecategories areassociatedwithtry catch branching andloopingblocks and three categories are associated with method declaration blocks that record method execution information.
below we discuss each category in detail with an example.category try catch block exceptioninformationloggingincatch blocks .
.
exceptions are widely used to capture errors.developersrely onlogsfordebugginganderror diagnostics when exceptions occur .
the code snippet below shows an example of logging statements in this category.
similar to aprior study we find that a large number of sampled logging statementsresidein catchblocks.mostofthemareat error .
or warn .
level.theloggingstatementsoften recordmessagesorexecutioninformationrelatedtotheprior try block.
try listener.oncache shardid fieldname fielddata catch exception e logger.error failed to call listener on atomic field data loading e category branching block branch logging in blocks associated withdecision makingstatements .
.
wefindthatmany sampledloggingstatementsresideinblocksassociatedwithdecisionmaking statements e.g.
if elseandswitch to record the execution information in different branches.
the variable or the invoked methodintheconditionofthedecision makingstatement e.g.
theargumentsinthe ifstatement areprocessedordefinedintheprior code.among thelogging statementsin thiscategory aroundhalf of them .
record the occurrence of an unexpected execution behavior e.g.
an error or a failure with a warnlevel or above e.g.
error as shown in the code snippet below.
the remaining cases record the occurrence of a normal execution behavior with an info debug o r tracelevel for system comprehension or debugging purposes.
finaltaskid id partitionstotaskid.get tp ... 363if id !
null taskids.add id else log.error failed to lookup taskid for partition tp category looping block programiterationlogging .
.
wefindthatsomesampledloggingstatementsresideinblocksthat are associated with looping statements e.g.
code blocks thatareassociatedwith for while and do while statements .these loggingstatementsoftenrecordtheexecutionstateduringiterating e.g.
recording the ithexecution inside a forblock or variables thatareprocessedordefinedinpriorblocks.wealsofindthatno logging statements under this category are at errororfatallevel.
all logging statements are at the level of info .
debug .
or trace .
.
in short developers are more likely to add logging statements in such blocks for debugging and recording program execution.
indexstatistics stats getindexstatistics total ...for indexstatistics s stats log.info object size s.itemsize used s.usedcount category method declaration block loggingthestartofamethod .
.
wefindthatsomesampledloggingstatementsreside at the beginning of a method mostly for recording the program executionstateordebuggingpurposes.theseloggingstatements recordthestartofthemethodexecution e.g.
starttobuildtheprogram from jar file.
at the info .
debug .
ortrace .
level.differentfromothercategories wedo not find the location of logging statements in this category depend onpriorcodeinthemethod.however wefindthattheselogging statements record the execution of some methods of which the process is important to know and with some specific semantics in the code e.g.
recovery perform and queue as shown in the code snippet below.
public void perform throwsexception log.info string.format performing action rolling batch restarting of region servers int ratio list servername selectedservers selectservers queue servername serverstobekilled newlinkedlist selectedservers ... code for performing server killing related tasks... category method declaration block loggingtheendofamethod .
.
in this category the logging statements reside at the end of a method recording the successful method execution e.g.
removed job graph from zookeeper as shown in the code snippet below .
we find that most of them .
are at theinfolevel and the rest are in debug .
trace .
and warn .
level whichmayshowthatsuchlogs are mostly for debugging and recording program execution.
thelogging statement may record variable values that are declaredor modified in prior blocks when the method execution finishes.similarto category5 wefindthattheloggingstatementsinthis categorymightresideinsemanticallysimilarmethodsofwhichthe execution is important to be recorded e.g.
shutdown delete andremove .
public void removejobgraph jobid jobid throwsexception checknotnull jobid job id string path getpathforjob jobid ... addedjobgraphs.remove jobid code for removing zookeeper job graph...log.info removed job graph from zookeeper.
jobid category method declaration block functionlogging indomainspecificmethods .
.
wefindthatdeveloperssometimes insert logging statements in some domain specific methods e.g.
handling a specific request to record the execution of this method.
we also find that these methods are usually very short i.e.
within lines of code .
as shown in the example below in the method handleresponse inelasticsearch s joinhelper.java thereareonlya fewlinesoffunctionalcodestatementsbuthasaloggingstatement recordingtheexecutionbehaviorofthismethod.amongthelogging statements in this category .
are at the infolevel or below i.e.
debugortracelevel to record the methods handling normalrequests andtherest8 .
loggingstatementsare at thewarnorerrorlevel to record the methods handling abnormal situations e.g.
onfailure .
we also find that these short methods might be semantically similar based on our manual observation e.g.
share many common words such as handleandexecute .
public void handleresponse empty response pendingoutgoingjoins.remove dedupkey logger.debug successfully joined with destination joinrequest lastfailedjoinattempt.set null insummary ourfindingsshowthattheremaybeanimplicitlogging guideline that developers follow in the studied systems.
both syntactic andsemantic informationareimportantconsiderations insuchloggingguidelines.inparticular wefindthat76.
combining category1 category2 andcategory3 ofthesampled logging statementsare relatedto recording informationin blocks associated with syntactic information of the source code e.g.
trycatch branching orloopingblocks .theseloggingstatementsalso oftenrecord information e.g.
variable valuesorexecution states that isrelated to priorblocks.
we find that23.
combiningcategory category andcategory of the sampled logging statements may be inserted based on the semantic information i.e.
business logic of the method inside the method declaration block.theseloggingstatementsoftenrecordthestartandendof methodexecution orrecordtheexecutionofsomedomain specific methods e.g.
request handling or task execution .
byuncoveringsixcategoriesof logginglocations wefindthat bothsyntactic andsemantic information are important considerations in such logging guidelines.
of the sampled logging statements are related to recording exception branching and program iteration while are related to recording the start end or execution of certain methods.
automatically suggesting logging locations at the code block level aswefindinsection3 developersusuallyinsertloggingstatements torecordthebehaviororstateoftheprograminblocks e.g.
exceptionhandlingin catchblocksorbranchloggingin if elseblocks .
we also find that some logging locations may be related to the semantics of a method e.g.
recording the start of a certain method execution .hence suchsyntacticandsemanticinformationmay 364composeimplicitloggingguidelinesthatdevelopersfollowwhen decidingonlogginglocations.inthissection weseektoexplorethe potentialofautomaticallysuggestinglogginglocationsattheblock level.
such an automated approach might further assist developers inmakingloggingdecisionsandimprovingloggingpractice.below we describe our approaches that extract block features and build a deep learning model to suggesting logging locations.
.
extracting block features identifying logged blocks.
our goal is to provide suggestions ondecidingblocksthatrequireloggingstatements.wechooseto provideasuggestionattheblocklevelbecauseaswefindinsection3thatmanyloggingstatementsarerecordingthebehaviour or state of the program in blocks.
in addition blocks provide a finer grandsuggestionwhichmaybemoreactionablecompared to coarse grand suggestions e.g.
method or file level .
we analyzethesourcecodebyparsingtheabstractsyntaxtree ast of every method in the studied systems.
then we identify the ast nodesinamethodthatrepresentblocks suchastheblocknodes thatareassociated with if for and catch.hence eachmethodmay contain multiple blocks.
for the block nodes that we identified we thenlabelthemaseither loggedblockornon logged blockbyanalyzingiftheblockcontainsatleastoneloggingstatement.specifically onlytheblockthatdirectlycontainsaloggingstatementislabelledasaloggedblock.forexample asshowninfigure1 block b0 line3 islabelledasa loggedblockbecausethereisaloggingstatement in line .
block b1is labelled as a non logged block because the logging statement in line is not directly contained by block b1.
table1showsthestatisticsofblocksinthestudiedsystems.
lb referstothenumberof loggedblocks nlbreferstothenumberof non logged blocks and lb is the percentage of loggedblocks over alltheblocks.notethattheremightbemultipleloggingstatementsinablock sothenumberof loggedblockissmallerthanthenumber of logging statements in each system.
in general we find that only a small portion i.e.
.
to .
of the blocks contain logging statements.hence accuratelysuggesting logginglocations at the block level is a challenging task.
as we find in section the locations of logging statements may be influenced by either the syntactic semantic or both types of information in source code.
in order to obtain the features for trainingdeeplearningmodelsandtofurtherstudytheeffectiveness ofthesefeaturesinsuggestinglogginglocations wethenextract thesyntactic semantic andfusedblock levelfeatureswhenweare analyzing the source code of each block.
extracting block features.
in our manual study we find that logging statements often have dependencies with the preceding code in the same method.
for example the arguments in the if statementareprocessed ordefinedintheprior code asshownin section3 .asalsofoundinpriorstudies developersmay insert logging statements based on the execution flow prior to the logging point.
therefore for each identified block we analyze the source code from the start of the method in which the code block is located to the end of the block.
this could also reflect developers sequential workflow by suggesting whether or not a block needs a logging statementwhendevelopersfinishimplementingtheblock .for figure an example of how we label code blocks and ex tract the tokens for generating the features.
we illustratethe tokens extracted from code block b0.
example infigure1 forblock b0 weconsiderthecodestatements fromline1toline6.similarly forblock b1 weconsiderthecode statements from line to line .
specifically for each code blockin a studied system we find all the ast nodes from the start of themethodtotheendofthisblock.thenforeachastnode we record its type e.g.
methodinvocation variabledeclaration or catchclause theassociatedsemanticinformation e.g.
thename of the variable declared in the variabledeclaration node as wellas the location i.e.
class and method and the start line and end line .
we then extractthree types of code block featuresusing theabove mentioned information from these ast nodes.
below wediscusstheapproachesthatweusetoextractsyntactic semantic and fused block features respectively.
syntactic block features weextractthesyntacticfeaturesthat representthestructuralinformationfromtheastnodesincode blocks.
we capture the syntactic information by extracting the ast nodes that are related to the control flow of the code.
we exclude ast nodes such as simplename i.e.
identifier name and simpletype i.e.
identifiertype whichdonotcontainstructural informationofthecode.foreachblock wecounttheoccurrence ofeachastnodeintheblockandallprecedingcodeinthesame method.
at the end of the syntactic feature extraction for eachblock we obtain a vector that represents the occurrence of eachstructural ast node in the block and its preceding code.
we call eachelementinthevectorasatoken.figure1showsanexample ofthesyntacticfeaturesforthe b0block whereweextracttheast nodes from the feature scope.
semantic block features we extract the semantic features from the textual information inside the code blocks.
prior studies found that information such as variable names may capture the semantic information of the code .
therefore we process variable names and invoked methods in the block as plain text.
for each block we consider all the semantic information in the block and in the preceding code in the same method.
note that we excludeallreservedkeywordsintheprogramminglanguages such 365source code ...... ...... ...... code block features integer representation word embedding layer...... rnn layer lstm rnn cell rnn cell rnn cell......rnn cell dropout layer......output layer figure the overall architecture of our approach.
asif else and for to avoid capturing structural information.
we follow common source code preprocessing techniques splitting the words using camel case converting all words to lower case and applying stemming .
figure shows an example of the semantic block features of the b0block.
fused block features developers may add logging statements based on both the syntactic and semantic of the code.
therefore in addition tobuilding separatemodels usingthe above mentionedsyntactic and semantic features we also combine both types of information together i.e.
fused features .
to obtain fused features ofcodeblocks webuildanunifiedcorpuscontainingbothsyntactic andsemanticinformationofthesourcecodebyfollowingaprior study .specifically wemergethesyntacticandsemanticfeaturesinablocktogether whilekeepingtheoriginalordersofthose ast nodes in the source code.
then for each fused code block we obtain the vector representation similar to the process discussed in other types of features.
figure shows an example of the fused code block features of the b0block.
.
deep learning framework and implementation weformulatetheprocessofsuggestinglogginglocationsasabinary classification problem.
given a block we apply deep learning modelstosuggestwhetherornottheblockshouldcontainalogging statement.
in this subsection we discuss the overall architecture and implementation of our deep learning model.
overall architecture.
figure shows the overall architecture of our approach.
we first map our input vectors i.e.
syntactic semantic and fused features through an embedded layer.
the embeddedlayerlearnstherelationshipandsimilarityamongthe vectorsineachblockfeatureandprocesseseachvectorbasedon integer encoding to probabilistically distributed representations.
we then employ a recurrent neural network rnn layer to model the relationship between the logging decision of a block and the vectorsreturnedfromtheembeddinglayer.finally theoutputlayer of our deep learning model is a one dimension dense layer with the sigmoid activation function to suggest whether a block should be logged or not.
below we discuss the details of each layer.
embedding layer.
afterextractingthesyntactic semantic and fusedfeatures i.e.
intheformsofvectors asillustratedinfigure1 we feed them to the embedding layer.
the embedding layer capturesthelinearrelationshipsamongtokensintheinputvector and outputsasetofnewvectors calledwordembeddings .compared to simple integer encoding or one hot encoding which does not consider the relationship among the tokens word embeddings can learn the similarities among tokens and return probabilisticallydistributedrepresentationsofthewords e.g.
runandexecute might be similar in vector space .rnn layer.
since source code provides instruction on system execution there are dependencies between consecutive lines of sourcecode.forexample aswediscussedinourmanualstudy the condition variable in ifstatement may have dependency on prior source code because the variable is defined or processed priorly.hence we follow prior studies and model source codeassequentialdata i.e.
weconsidertheorderofthesourcecodetokensinthedata .weincludealayeroflongshorttermmemory lstm in the deep learning model which is a variant of rnn that includes a memory cell and gate mechanisms in the recurrent unit to preserve long term dependencies of the code .
outputlayer.
afterthepreviouslayers theblockfeaturesarestill high dimensional vectors.
in order to make a binary suggestion of whether a block is loggedornon logged we use a one dimensional dense layer with sigmoid activation function as the output layer of our approach.
this layer takes all outputs from the previous layer toitsuniqueneuron thentheneuronprovidesthefinalsuggestion i.e.
loggedornon logged of this block.
implementation and training we use keras to implement our deeplearning model.for theembedding layer we adoptskipgramfromword2vec andsetthedimensionto100 toobtain the word embeddings of each type of the three features separately.
forthernnlayer wesetthedimensionofhiddenstatesas128and attach a dropout layer with a .
dropout rate in order to reduce the potential impact of overfitting and immoderate reliance on the trainedsystem .wetrainourmodelfor100epochson each studied system and set the batch size to .
because there is a noticeableimbalancebetweenthenumberof loggedblocksand nonloggedblocks overallonly3.
to14.
blocksare loggedblocks as shown in section for each studied system and each type of code block features we apply stratified random sampling i.e.
ensuretherandomsamplehasthesamedistributionofclassesas the original data to split the block features into training set validation set and testing set .note that we remove the log related statements when we are generating the features to avoid biases in the suggestion results.
finally we upsample the loggedblock features in the training set after the splitting process to mitigate the impact of data imbalance .
evaluation in this section we evaluate our approach by introducing the evaluation metrics and answering two research questions.
.
evaluation metrics given the features of a code block as inputs our deep learning modelsuggestsifthisblockis loggedornon logged.toevaluatethe performanceofourmodel weusebalancedaccuracy precision recall and f measure as our evaluation metrics.
balanced accuracy.
balanced accuracy is widely used by prior studiestoevaluatemodelperformanceonimbalanceddata .
it calculates the average of true positive rate i.e.
how many suggestedloggedblocks are correct and true negative rate i.e.
how many suggested non logged blocks are correct .
balanced accuracy is computed as balancedaccuracy tp tp fn tn tn fp 366table the results of suggesting logging locations using syntactic syn.
semantic sem.
and fused fus.
block features.
balanced accuracy precision recall f1 systems syn.
sem.
fus.
rg.
syn.
sem.
fus.
rg.
syn.
sem.
fus.
rg.
syn.
sem.
fus.
rg.
cassandra .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
elasticsearch .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
flink .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
hbase .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
kafka .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
wicket .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
zookeeper .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
note rg.represents the result of the baseline.
for each system and for each evaluation metric the block feature that yields the best performance is marked in bold.
all the numbers represent percentage.
wheretp tn fpandfnrefertotruepositive truenegative false positive i.e.
suggestedasa loggedblockbutisactuallya non logged block and false negative i.e.
suggested as a non logged block but isactuallya loggedblock respectively.a highbalancedaccuracy means both the majority class i.e.
non logged block and minority class i.e.
loggedblock are accurately suggested.
precision.
in our study precision represents the ability of our approach to correctly suggest loggedblocks i.e.
how many logged blockssuggested byourmodelare correct .specifically precision is defined as precision tp tp fp note that only positive labels i.e.
loggedblock are considered for thismetric i.e.
theperformanceon non logged datadoesnotaffect ourcalculationofprecision .hence ahighprecisionmeansthat most of the suggested loggedblocks are indeed logged.
recall.recall representsthe abilityof finding loggedblocksfrom the data set i.e.
how many loggedblocks can be suggested by our approach .
it is computed as recall tp tp fn sameasprecision onlypositivelabelsareconsideredforthismetric.
ahigherrecallmeansthatwecanidentifymorecodeblocksthat need to be logged.
f1 score.
f1 score is a metric that considers both precision and recall.
it is computed as f1 precision recall precision recall f1 score balances the use of precision and recall and provides a morerealisticmeasureoftheperformancebyusingbothofthem.
a high f1 score means that we can both accurately and sufficiently suggestloggedblocks.
.
case study results inthissubsection wepresenttheresultsforourresearchquestions rqs .
for each rq we describe the motivation approach and results and discussions.rq1 how effective are different block features when suggesting logging locations?motivation.
deciding where to log is a challenging practice .
as we find in our manual study there exist some common characteristics of where developers insert logging statements.
logginglocation mightberelated toeitherthe syntacticinformation semanticinformationofthecode orboth.inthisrq weinvestigatetheperformanceofourdeeplearningmodelsandhoweach block feature performs in suggesting logging location.
our findingmayhelpvalidateourmanualstudyresultsthattheremaybean implicit logging guideline that developers follow and identify the important features in suggesting logging location.
specifically we split this rq into three sub rqs rq1.
what is the performance of the three block features when suggesting logged blocks?rq1.
do different block features capture different information?
rq1.
what are the suggestion accuracies for different categories ofloggedblocks?
approach.
we train our deep learning framework on the training databyfollowingtheprocessdiscussedinsection4.weconductourexperiments on the same systems that we used in our manual anal ysis.foreachstudiedsystem wetrainthreemodelsusingdifferent types of block features i.e.
syntactic semantic and fused .
finally we evaluate the model performance on the testing set using the above mentioned evaluation metrics.
note that we pre determined thetraining validation andtesting datasetbefore extractingtheblockfeatures.hence weusethesamesetofcode blocksforeachsystemwhenevaluatingthesyntactic semanticand fused blocks features.rq .
what is the performance of the three block features when suggesting logged blocks?
to evaluate the effectiveness of our models we compare the results of the models trained using three blockfeatures with a baseline.
since there is no prior study that suggests logging locations at the block level we use random guess rg as ourbaseline whichiscommonlyusedbypriorstudies .
given a block in a studied system random guess suggests whether this block should be a loggedblock ornon logged blockbasedontheproportionof loggedblockinthissystem.for example ofthecodeblocksinkafkaare loggedblockasshown in table .
then for each code block being tested there is a chance for random guess to suggest it as a loggedblock and a chance to suggest it as an non logged block.
we repeat the random guess times as suggested by previous studies for each system to reduce the biases.
we report the average values ofthefourevaluationmetricscomputedbasedonthe30timesof iterations as the result of random guess.rq .
dodifferentcodeblockfeaturescapturedifferentinformation?
tofurtherinvestigateifdifferentblockfeaturescapturedifferent information in the source code we examine the overlap and differences of the results generated from the models trained by using three block features.
for each type of block feature we collect the prediction results on the testing data of seven studied systems analyze the true positives true negatives false positives and false negatives and compute the percentage of overlap among the syntactic semantic and fused block features.
a true positive b true negative c false positive d false negative figure venn diagrams of tp tn fp and fn of the three block features.
each number represents the percentage ofthe corresponding intersecting set out of the union set.
rq .
what are the suggestion accuracies for different categories of loggedblocks?
sincethreecodeblockfeaturesmaycapturedifferent informationinthesourcecode theymighthavevariedperformance when predicting different categories of loggedblocks.
hence we further evaluate the performance of thethree block features on the different categories of logging statements section .
we report the suggestion results based on the type of blocks that the logging statement is associated with i.e.
try catch block branching block looping block and method declaration block .results and discussions.rq .
.
table presents the results of the models built using the syntactic syn.
semantic sem.
andfused fus.
codeblockfeatures and the baseline random guess rg.
.
overall for all the evaluation metrics models trained by using the block features outperformthebaseline.theprecisionofrgrangesfrom3.
to12.
recall ranges from .
to .
and the balanced accuracy ranges from .
to .
.
note that rg makes suggestion based on the distribution of training data the distribution of loggedandnonloggedblocks in the testing data is the same as the original data as shownintable1 .therefore givensufficienttrails thebalancedac curacyofrgwillbecloseto50 .wefindthatmodelstrainedusing thesyntacticblockfeatureshavethebestperformancecompared to other block features across all studied systems.
in particular the balanced accuracy of semantic and fused features ranges from .
to .
while for syntactic feature it is over .
on allthe studied systems with an average of .
.
the average precisionrangesfrom24.
to47.
whenusingsemanticandfused blockfeatures andtheaveragerecallrangesfrom33.
to58.
.
incomparison theaverageprecisionandrecallonsyntacticfeature are50.
and61.
respectively.theresultsshowthatsyntactic information might play an important role in logging decisions and may be leveraged to suggest logging locations.rq .
.
figure shows the percentage overlap on a true positive b true negative c false positive and d false negative a balanced accuracy b precision c recall d f1 figure4 the a balancedaccuracy b precision c recall and d f1 of the models trained from three block features when applied on different types of blocks.
among the models trained using syntactic semantic and fused block features.
note that red green and blue circle represents the suggestion results of syntactic semantic and fused block features respectively.
eachnumber representsthe percentageof thecorresponding intersecting data set e.g.
for tp .
represents the commonsetoftruepositiveamong syn.
sem.andfus.
outofthe entireset e.g.
fortp theentiredatasetisthesetthatcombines the tp from syntactic semantic and fused altogether across all studiedsystems .thereisa42.
overlapintpamongthethree features whilesyntacticcoversmostofthetps .
outofallthe tps comparedtosemantic .
andfused .
blockfeatures.
only .
of the tps are missed by syntactic but captured by two otherblockfeatures.fortns i.e.
correctlysuggestas non logged block almost all .
are overlapping among the three block features.theresultsshowthatthereisahighlevelofagreement among the models when suggesting the non logged blocks.
for fps thereisnoconsiderableoverlapamongthethreefeatures .
.
for fns syntactic has the lowest number of fns .
of the fns arecoveredbysyntactic comparedto80.
coveredbysemantic and .
covered by combined feature .
the results show that differentblockfeaturesmightcapturedifferentinformationfrom source code.
as semantic and fused block features still capture tps thataremissedbysyntacticblockfeature .
futureworkcould further investigate how to better combine the two sources of informationtoprovideasufficientandaccuratesuggestion.moreover wemanuallyinvestigateasampleoffpsandfns.weidentifytheir characteristics and find that many of them are not indeed fps and fns details in section .rq .
.
figure shows the a balanced accuracy b precision c recall and d f1ofthemodelswhensuggestingondifferenttypes ofblocksassociatedwiththecategoriesinsection3.overall the threeblockfeatureshaveasimilartrendfortheresultsondifferenttypesofblocks.syntacticfeatureshavethebestresultsforalltypes of blocks on all the evaluation metrics.
among the four types of 368table the results of cross system logging locations suggestion using syntactic block features.
balanced accuracy precision recall f1 fleiss kappa systems within cross ratio within cross ratio within cross ratio within cross ratio logged non logged cassandra .
.
3. .
.
.
9. .
.
.
7. .
.
.
7. .
.
mod.
.
sub.
elasticsearch .
.
4. .
.
.
11. .
.
.
5. .
.
.
7. .
.
mod.
.
sub.
flink .
.
3. .
.
.
8. .
.
.
9. .
.
.
7. .
.
mod.
.
sub.
hbase .
.
2. .
.
.
4. .
.
.
6. .
.
.
4. .
.
mod.
.
sub.
kafka .
.
4. .
.
.
4. .
.
.
6. .
.
.
3. .
.
mod.
.
sub.
wicket .
.
3. .
.
.
5. .
.
.
8. .
.
.
4. .
.
mod.
.
sub.
zookeeper .
.
2. .
.
.
6. .
.
.
5. .
.
.
5. .
.
fair .
sub.
average .
.
.
.
.
.
.
.
.
.
.
.
.
mod.
.
sub.
note withinshows the results of within system suggestion.
crossshows the average results and the standard deviation when applying the models trained using other systems.
ratioshows the percentage of crossover within.
fleiss kappa shows the degree of agreement on the suggestion result of the cross system models on loggedandnon logged blocks.mod.andsub.represent moderate and substantial agreement respectively.
blocks loggingstatementsassociatedwithtry catchblockshave the best results on all the evaluation metrics .
balanced accuracy .
precision .
recall and .
f1 for syntactic .
asalso foundinprior studies logging statementsinsuch blocks may be better defined.
we also find that logging statements associatedwithbranchingblockshaveagoodoverallsuggestion result.
incontrast the resultsof suggesting logging statementsassociated with looping and method declaration blocks are relatively lower balancedaccuracyrangesfrom63.
to69.
andf1rangesfrom .
to .
.
although the three block features have a similartrend ofresults ondifferenttypes ofblocks syntacticfeatures arebetterthantheothertwoforsuggestinglogginglocationsonall thestudied typesofblocks.moreover ourstudy showsthatthere isaclearerpatternofinsertingloggingstatementsintry catchand branching blocks i.e.
higher precision and recall .
practitionersmay prioritize reviewing and deciding the given logging suggestionsinsuchblocks.inaddition futureresearchmayinvestigate other sources of information in order to better assist in making logging decisions for looping and method declaration blocks.
all the trained models noticeably outperform the baseline.
among the three types of block features models trained using syntactic block features achieve the best results on all the evaluationmetrics.theresultsshowthatsyntacticinformation might be leveraged to suggest logging locations.
rq2 are the trained models transferable to other systems?motivation.
when working on a new system developers may encounterdifficultieswhendecidinglogginglocations.differentfrom matured systems with a long period of development and maintenancehistory developersworkingonnew systemsmaynothave sufficientknowledgeondecidingwheretolog.therefore inthis rq weinvestigatewhetherdifferentsystemssharesimilarimplicitguidelines of logging locations.
our findings may provide evidence on the existence of common logging characteristics across systems and help future research derive a universal logging guideline.
in particular we study two sub rqs rq2.
whatistheeffectivenessofcross systemloggingsuggestion?rq2.
what is the level of suggestion agreement on cross system models?
approach.
in this rq we study if loggedblocks share similar syntactic block features by a cross system transferable learning.
namely we study if a model that is trained using the syntactic featuresfromonesystemcanbeusedtosuggestlogginglocation in another system.
we choose to study syntactic block featuresbecause they are extracted from the ast nodes in the source code which are common across all java systems and they have the best performancecomparedtotheothertwoblockfeaturesasshown in rq1.
moreover since the syntactic block features capture theunderlying code structure a high cross system suggestion accuracymayshowthepotentialofderivingaloggingguideline based on code structure in future studies.rq .
what is the effectiveness of cross system logging suggestion?
foreachstudiedsystem webuildamodelusingthesyntacticblock features and apply the model on each of the other systems.
for example wetrainamodelusingthesyntacticblockfeaturesincassandra andapplythemodelonsixotherstudiedsystems.finally wecomputeandreporttheaveragebalancedaccuracy precision recall and f measure of the cross system logging suggestion.rq .
what is the level of suggestion agreement on cross system models?tostudywhetherthemodelstrainedusingdifferentsystems capture similar information i.e.
the relationship between the syntactic features and logging location we analyze the agreement levelofcross systemsuggestionresults.weseparatelyexaminethe suggestion agreement of the cross system models on loggedblocks andnon logged blocks.
namely for each studied system we apply themodelstrainedusingothersystems andstudythesuggestion results of the cross system models on the truelogged blocks and thetruenon logged blocks respectively.
in particular we compute fleiss s kappa to study the agreement among the suggestion resultsfromcross systemmodels .fleiss skappacomputesthe inter rateragreementamongafixedsetofraters i.e.
suggestion resultsfromdifferentcross systemmodels .ahigherlevelofagreement may show that the syntactic block features have very similar relationships with logged or non logged blocks across all studied systems.results and discussions.rq .
.
table3showstheresultsofourcross systemsuggestions usingsyntacticblockfeatures.ingeneral wefindthattheresultsofcross systemsuggestionsarelowerthanwithin systemsuggestions usingsyntacticblockfeatures.however theresultsarestillcomparable to within system suggestions using semantics and fused blockfeatures.forbalancedaccuracy thecross systemsuggestions achieveover80 i.e.
ratiocolumnintable3 of thecorresponding within system suggestion using syntactic block features.
onaverage the balanced accuracy ranges from .
to .
with standard deviations range from .
to .
.
for precision recall and f1 thecross systemsuggestionsachieve51.
to88.
ratioofthe within systemsuggestionresults.inshort eventhoughwefindthat theresultsofcross systemsuggestionareslightlylowerthanthose ofwithin system wemaystillachieveareasonableperformance.
369similar to rq1 we also manually study a sample of fps and fns from the results of rq2 details in section .
rq .
.table also shows the fleiss s kappa for each studied system.
for loggedblocks the agreements are moderate in six studiedsystems.theagreementlevelisfairinzookeeper butthevalueisalsoclosetothethresholdofamoderateagreement i.e.
.
.
our results show that the models trained using the syntactic block features may share certain underlying properties.
namely there aresomecommonalitiesinthecodestructureonhowdevelopers decidelogginglocationsacrossthestudiedsystems.for non logged blocks theagreementsaresubstantialacrossallstudiedsystems.
inshort ourfindingsshowthatdevelopersareratherconsistenton decidingwhichblocks donotneedloggingstatements.although there are some inconsistencies across the studied systems we may stillapplycross systemmodelstohelpsuggestlogginglocations in other systems.
wefindthatcross systemlogginglocationsuggestionachieves a reasonable performance compared to within system suggestion i.e.
ofthewithin systembalancedaccuracy .wealso findthatthecross systemmodelshavemoderateagreements onloggedblocks and substantial agreements on non logged blocks.
ourresults show that developersin different systems may follow certain implicit guidelines on deciding logging locations.
discussion as shown in the rqs our models can provide promising results of suggesting logging locations.
to further inspire future studies and betterassistpractitioners weconductamanualstudytounderstand the fps and fns in the suggestion results.
for each studied system inrq1andforeachofthethreemodels i.e.
syntactic semantic and fused simplified as syn.
sem.andfus.
we select the topfivefpsandfnsforourmanualstudy rankedbytheirsuggested probabilitiesofbeing loggedandnon logged respectively atotalof fps and fns .
for the cross system models in rq2 we also select the top five fps and fns from each system a total of fps and fns .
falsepositives.
forsyn.in rq1 we find that of the studied fps are actually tp.
the code block either contains some other types of print statements to record the execution information e.g.
system.out.print or contains only one child block and has no other code statements and the child block contains a logging statement.
for sem.
fus.
and cross system models we also find and18 35casesthatbelongtothiscategory respectively.for theremainingstudiedfps thesuggestionsaremadewhenthecode block is at the beginning of a method cases for syn.
for sem.
10for fus.
16forcross systemmodels orincomplexcodewith multiple nested blocks case for syn.
for sem.
for fus.
for cross system models .falsenegatives.
wefindthat15 35ofthestudied syn.fnsmay nottrulybefn.similartothesituationinfpthatacodeblockonly containsa loggedchildblockandhasnoothercodestatements the child block is suggested as a non logged block and thus becomes an fn.
for sem.
fused.and cross system models we find and cases that belong to this category.
we also find thatfor and of the studied fns from syn.
sem.
fus.andcross systemmodels theyareblocksthathavemanyvery similar sibling blocks nearby e.g.
many similar ifblocks having similarstructures whileonlythefncasesherecontainlogging statements.
for the remaining studied fns similar to what we find infps theylocateatthebeginningofamethod 15casesfor syn forsem.
14for fus.
14forcross systemmodels orincomplicated code structure with multiple nested code blocks case for syn.
forsem.
for fus.
for cross system models .
our findings show that the actual performance of our model may be even better due to the diverse nature of how developers write logging code.
we also find that it may be more difficult to suggest a logging statement at the beginning of a method due to the lack of prior information in the code block.
threats to validity constructvalidity.
ourapproachpresumesthatthetrainingdata has high quality source code and follow good logging practice.however there exist no industrial standards guiding developers towriteloggingstatements.inthispaper wechoosesevenlargescale well maintained systems with different sizes across various domains to conduct the study.
they are commonly used in priorlog relatedstudiesandareconsideredasfollowinggoodlogging practice .weevaluateourmodelsonthetestdataset of each studied system.
different test data set might lead to very differentresults.tomitigatethefluctuationcausedbydifferenttest dataset weapplystratifiedrandomsamplingbyfollowingprior studies tosplitthedatasetandensureeachrandomly sampled data set has the same distribution of labels as the original data.
internal validity.
weconductmanualstudiestoinvestigatethe characteristics and uncover the categories of logging locations.
to avoidbiases theauthorsexaminethedataindependently.formost of the cases the authors reach an agreement.
any disagreement is discussed until a consensus is reached with a substantial levelagreement cohen s kappa .
.
involving third party loggingexpertstoverifyourresultsmightfurtherreducethisthreat.
differentparametersusedintheneuralnetworksmightaffecttheef fectivenessofthetrainedmodels.wefollowpriorstudies to settheparametersforourdeeplearningmodels.themodelstrainedusingourapproachmightnotbeoptimalonsomeoftheevaluation metrics e.g.
an average f1 score of .
on syntactic code blockfeatures .
future study may further improve the performance of ourapproachandprovideamorecomprehensiveperspectiveofthesuggestionresultsbysurveyingsoftwareengineeringpractitioners.
we use word embeddings which is widely used by prior studies as the distributed representations of source code.
futurestudymayconsiderothercoderepresentationapproaches e.g.
code2vec toexaminetheperformanceonsuggesting logging locations.
external validity.
weconductedourstudyonlyonsevenlargescaleopensourcesystems.however weselectedthestudiedsystemsinvariousdomainsandsizes from97kto1.5mlocasshown intable1 inordertoimprovetherepresentativenessofourstudied systems.
our studied systems are all implemented in java.
the results and models may not be transferable to systems in other 370programming languages.
future studies should validate the generalizabilityofourfindingsandthetransferabilityofourmodels in systems that are implemented written in other programming languages.
conclusion inthispaper weaimtotacklethechallengesthatdevelopersmight encounterwhendecidinglogginglocationsbyfirstconductinga comprehensivemanualstudy.weuncoversixcategoriesoflogging locationsandfindthatdevelopersusuallyinsertloggingstatements torecordexecutioninformationthathappensinvarioustypesof codeblocks.weproposeadeeplearningbasedapproachtoprovide finer grained i.e.
atthecodeblocklevel suggestionsonlogging locations.
our approach achieves promising results on suggesting logginglocationsinbothwithin projectandcross projectpredictions.ourresultshighlightthepotentialofprovidingfiner grained suggestions on logging locations by leveraging syntactic informationinthesourcecode andsuchsuggestionsmaybesharedacrosssystems.futurestudiescouldexploreamoreadvancedwayofcombining syntactic and semantic information in the source code in order to provide better suggestions on logging locations.