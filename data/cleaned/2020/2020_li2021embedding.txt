embedding app library graph for neural third party library recommendation bo li swinburne university of technology melbourne australia boli swin.edu.auqiang he swinburne university of technology melbourne australia qhe swin.edu.aufeifei chen deakin university melbourne australia feifei.chen deakin.edu.au xin xia monash university melbourne australia xin.xia acm.orgli li monash university melbourne australia li.li monash.edujohn grundy monash university melbourne australia john.grundy monash.edu yun yang swinburne university of technology melbourne australia yyang swin.edu.au abstract the mobile app marketplace has fierce competition for mobile app developers who need to develop and update their apps as soon as possible to gain first mover advantage.
third party libraries tpls offer developers an easier way to enhance their apps with new features.
however how to find suitable candidates among the high number and fast changing tpls is a challenging problem.
tpl recommendation is a promising solution but unfortunately existing approaches suffer from low accuracy in recommendation results.
to tackle this challenge we propose grec a graph neural network gnn based approach for recommending potentially useful tpls for app development.
grec models mobile apps tpls and their interactions into an app library graph.
it then distills app library interaction information from the app library graph to make more accurate tpl recommendations.
to evaluate grec s performance we conduct comprehensive experiments based on a large scale realworld android app dataset containing android apps distinct tpls and app library usage records.
our experimental results illustrate that grec can significantly increase the prediction accuracy and diversify the prediction results compared with state of the art methods.
a user study performed with app developers also confirms grec s usefulness for real world mobile app development.
ccs concepts software and its engineering application specific development environments .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
third party library recommendation mobile app development applibrary graph graph neural network acm reference format bo li qiang he feifei chen xin xia li li john grundy and yun yang.
.
embedding app library graph for neural third party library recommendation.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction mobile app development has been growing tremendously fast.
for example there are over .
million mobile apps available on the google play in the first quarter of .
this leads to a very fierce market competition between app vendors developers.
to gain a first mover advantage in such a competitive market mobile app developers need to release their new apps online as soon as possible.
they then need to keep updating their apps to accommodate users rapidly evolving needs and quickly respond to user reviews.
to reduce developers implementation efforts a large number of thirdparty libraries tpls have been published and made available that offer a variety of features .
leveraging tpls is an effective way to accelerate mobile apps development and update cycles.
tpls are playing a more and more significant role in the mobile app ecosystem .
instead of developing everything from scratch using tpls can help developers accelerate development deliver new features and enhance the overall software quality .
for example compared with newly developed code many bugs and deficiencies may have already been discovered and fixed in tpls offering similar or the same functionalities .
recent studies have found that developers regularly attempt to find and use tpls for their mobile apps .
this is also evidenced by a large scale study revealing that android apps on google play are using .
tpls on average and on average of the source code of a mobile 466esec fse august athens greece bo li qiang he feifei chen xin xia li li john grundy and yun yang app comes from tpls in use .
the popularity and advantages of tpls have led to the development and publication of a large number of tpls for mobile apps.
for example a total of tpls is hosted on android arsenal2 a popular android developer portal.
however this trend means that mobile app developers are now facing significant challenges when seeking useful tpls for their mobile apps .
first given the severe time to market constraints and tremendous available tpls it is infeasible for them to manually inspect a great many tpls to evaluate their usefulness from different perspectives e.g.
functionality performance interface etc.
.
second tpls are often used by mobile apps in combinations to collectively perform specific functions .
finding appropriate tpl combinations is another time consuming process for developers .
besides the rapid evolution of tpls also contributes to the sophistication in mobile app developers search for useful tpls .
thus developers are in urgent need of help with finding useful tpls effectively and efficiently.
collaborative filtering cf has been widely and successfully applied in a variety of domains for its ability to mine latent patterns without contextual information .
it has been employed to recommend libraries for developers .
librec combines cf and association rule mining to recommend tpls for java projects .
it is one of the earliest attempts at cf based library recommendations.
nguyen et al.
proposed crossrec to recommend tpls for open source software projects .
similar to librec crossrec exploits project similarity when making recommendations.
to improve recommendation performance it adjusts the weight of each tpl based on term frequency inverse document frequency tf idf .
very recently libseek was proposed for recommending tpls specifically for mobile apps .
it makes recommendations based on matrix factorization and employs an adaptive weighting mechanism to diversify recommendation results.
however solely based on a two dimensional app library matrix cf based tpl recommendation approaches exploit only a small portion of low order app library interaction information i.e.
applibrary usage information to make recommendations.
for example given a target mobile app a librec and crossrec find a s topkmost similar apps and or similar tpls and recommend tpls that have been used by those apps but not by a. these similar apps and tpls are identified based on their similarity to ain the use of tpls.
in addition some useful high order app library interaction information that can further improve tpl recommendation accuracy is overlooked.
for example assume that app bis similar toaand appcis similar to b the app library interaction information contained in ccan also contribute to tpl recommendations fora.
however existing cf based approaches do not exploit such information and thus suffer from low recommendation accuracy.
this is an inherent limitation of existing cf based approaches.
we tackle the tpl recommendation problem from a new perspective.
we model mobile apps tpls and app library interactions as an app library graph where mobile apps and tpls are modelled as nodes3and app library interactions as edges.
apps low order app library interaction information is represented by the links to their hop neighbor library nodes in the graph.
at the same time 3in this paper we speak of apps tpls and the corresponding nodes interchangeably.high order app library interaction information can also be extracted from the graph for tpl recommendations.
take apps a b andc above for example.
over the graph there will be one or many paths betweencandathroughb.
along such paths more similar apps and tpls can be identified and high order app library interaction information can be extracted from nodes multiple hops away from a such asc over the graph to make tpl recommendations for a. to leverage both low order and high order app library interaction information we employ a graph neural network gnn to make recommendations based on the app library graph.
this is motivated by the fact that gnn is well known for its ability to mine both low order and high order information from graphs.
it can capture information for a target node from its neighbor nodes within multiple hops .
compared with a baseline and three state of the art approaches our approach grec makes more accurate and diversified tpl recommendations.
key contributions of this research includes we make the first attempt to model app library interactions as a graph.
this allows more information among apps and tpls to be captured.
using this app library graph we propose a graph neural network based approach namely grec to recommend potentially useful tpls for mobile apps.
we train grec on a large scale public dataset4that contains android apps distinct tpls and applibrary usage records.
we conduct extensive experiments and a user study to evaluate the performance of grec for recommendation accuracy and diversity.
the prototype of grec is published for the validation and reproduction of our experimental results5.
the remainder of this paper is organized as follows.
section motivates our study.
section introduces the methodology of grec.
section reports the results of experiments conducted on grec.
section reviews related work.
finally section concludes this paper and points out future work.
motivating example fig.
demonstrates an example app library graph denoted as g generated based on the interactions among five mobile apps denoted asa1 ... a and seven tpls denoted as l1 ... l .
an edge between an app and a tpl corresponds to the use of the tpl in the app.
for example the edge between a1andl1indicates that a1usesl1.
using this app library graph g given a target node in g its loworder app library interaction information can be obtained from all the nodes that connect to it via one hop in g. take mobile app a1in fig.
as an example.
a1uses three tpls i.e.
l1 l2 andl3 because they are directly connected to a1ing.
besides low order app library interaction information highorder app library interaction information can also be obtained from graphg.
for example in fig.
nodes a2 a3 anda4are connected toa1via hops measured by the number of edges between them.
these nodes also contain rich information that might be leveraged for tpl recommendation.
for example path a2 l1 a1indicates proposed in 5the source code of grec is available at 467embedding app library graph for neural third party library recommendation esec fse august athens greece a1 a2a4 a3l1 l2l3 l4l5l6 l7 a5 figure example app library graph g a1 a2a4 a3l1 l2l3 l4l5l6 l7a5 figure information useful for a1 possessed in g a1 a2a4 a3l1 l2l3 l4l5l6 l7a5figure information useful for l1 possessed in g thata2hasbehaviors similar toa1as both of them connected to l1 ing.
state of the art cf based library recommendation approaches like librec and crossrec find similar mobile apps for a1 based on such behaviors.
usually they select a small number of such similar apps for making recommendations for a target app.
this means they inevitably fail to leverage the information provided by all the apps connected to the target app via hops in gand some useful information may be overlooked.
when we take a look at apps further away from the target apps ing more information can be obtained.
nodes l4 l5 andl6are connected to a1via hops.
the information provided by l4 l5 andl6may also be useful for making tpl recommendations for a1.
for example from path l4 a2 l1 a1 we can find that l1andl4 are both used by a2.
there might be a specific correlation between them.
for example a2as well as other apps may use them together to perform a specific function like the use of facebook library and picasso library in combination by a lot of apps reported in .
thus an app such as a1 that solely uses l1might findl4 useful.
when we look further away from a1 we can see that a5 is not similar to a1in terms of tpl usage.
however a3anda5 are both connected to l4andl5because they both use l4andl5.
this indicates that a3anda5share common interests in l4andl5.
for example they may provide similar or the same functionalities or features through the use of l4andl5.
similarly a1anda3 share common interests in l2.
although a1anda5do not use any common tpls a5may still share common interests with a1 as they both share common interests with a3.
thus a5can also contribute useful information to making tpl recommendations for a1 thenl7may be recommended for a1.
however such high order information is overlooked by cf based approaches.
different nodes with the same distance from a target node may have different impacts on tpl recommendations for the target node.
for example in fig.
three node a2 a3 anda4have the same distance from a1 marked with the same color in fig.
they are all connected to a1via hops in g. however they do not contribute equally to the tpl recommendations for a1.
for example a2anda3are both connected to a1via one path each i.e.
a2 l1 a1anda3 l2 l1 respectively.
however a4is connected to a1via two paths i.e.
a4 l2 a1anda4 l3 a1.
this indicates that a4shares two common tpls with a1whilea2anda3share only one tpl with a1each.
thus a4is more similar to a1thana2and a3in their use of tpls and can contribute more information to tpl recommendations for a1thana2anda3.
the above also applies to finding similar tpls for making tpl recommendations.
take library node l2 used bya1 in fig.
asan example.
we can see that l2andl3are connected to both a1 anda4 i.e.
they are used by both a1anda4.
thus l3is similar to l2in terms of tpl usage.
similarly l5is similar to l2as they are both connected to a3anda4.
such low order information can be exploited by cf based recommendation approaches.
when we look further away from l2 we can see that l4andl5are both connected toa3anda5.
thus l4is similar to l5.
althoughl4is not similar tol2in terms of tpl usage l4is similar to l2as they are both similar tol5.
thus l4can contribute high order information to tpl recommendations for a1.
when mining the two dimensional app library matrix cf based approaches can only leverage low order app library interaction information i.e.
the direct interactions between apps and tpls to make tpl recommendations .
a new approach that can also leverage the high order app library interaction information possessed in the app library graph is needed to improve recommendation accuracy and save developers time in finding useful tpls.
grec approach inspired by the great success of neural network based recommendation approaches in various domains grec is our innovative gnn based approach for tpl recommendation.
grec employs a graph neural network to make tpl recommendations through distilling both low order and high order app library interaction information from the app library graph.
.
process overview to recommend potentially useful tpls for a target mobile app assumea1 the general process of grec consists of four phases as shown in fig.
.
its input is the app library graph gbuilt automatically by grec based on a1 s library usage records and existing app library usage records in the training set.
those app library usage records can either be gathered from developers input6or be extracted with existing tools like libpecker libscout libd and libradar similar to .
inphase representation grec creates an individual latent factor vector for each node ing including the app nodes and the library nodes.
the representations of those nodes are used as the input to phase .
in phase information distillation grec employs the gnn to distill both low order and high order app library interaction information for each node in g. this gnn has multiple layers.
the first layer is 6for example a developer can provide a list of tpls used or to be used by their mobile apps as the input to grec.
468esec fse august athens greece bo li qiang he feifei chen xin xia li li john grundy and yun yang l4... ... a1 ... ... layer layer layer n representation information distillation aggregation input r a1 l4 ... ... prediction ranked libraries a1 concatenation concatenation element wise production step step a1 a2a4 a3l1l2 l4l5l6 l7a5a1 a2a4 a3l1l2l3 l4l5l6 l7a5 a1 a2a4 a3l1l2l3 l4l5l6 l7a5 a1 a2a4 a3l1l2l3 l4l5l6 l7a5a1 a2a4 a3l1l2l3 l4l5l6 l7a5a1 a2a4 a3l1l2l3 l4l5l6 l7a5a1 a2a4 a3l1l2l3 l4l5l6 l7a5 figure general process of grec used to distill low order app library interaction information.
the other layers are used to distill high order app library interaction information.
each layer distills information from neighbor nodes with the same hops.
for example the second layer and third layer distill information for each node from its hop and hop neighbor nodes respectively.
then the captured information is aggregated inphase aggregation .
at the end of phase a new vector is generated for each node to accommodate the information captured.
finally in phase prediction grec recommends the top nrmost useful tpls that are not used by a1.
usage example bob wants to explore new tpls for enhancing his app.
without grec he has to manually find and inspect a large number of tpls on maven take a long time to read their documents and test their functionalities.
with grec bobs can specify a list of tpls currently used in his app as input.
grec will recommend a number of tpls potentially useful for his app say .
bob can inspect these tpls with priority and see if they are useful.
in summary grec makes recommendations rather than decisions for developers.
please note that grec can make recommendations for mobile apps both published or still under development.
a mobile developer can also just provide a few tpls that they prefer to use in their mobile app as the input for grec to make tpl recommendations.
during the development of a mobile app grec can be used to iteratively explore potentially useful tpls.
when the app library graph used by grec is updated grec can be easily and efficiently retrained to improve its recommendation accuracy.
this also allows grec to include emerging tpls in its recommendations.
.
phase representation similar to recommendation approaches based on matrix factorization and neural networks grec embeds both mobile apps and tpls in a d dimensional latent factor space where each mobile appaiis represented by a latent factor vector ai rd and each tplljby a latent factor vector lj rd both with random initial values.
apps and tpls are mapped to this space where similar apps and tpls in terms of their features such as functionality interface performance compatibility reliability popularity dependency security are close to each other.
the usefulness of a tpl foran app can be evaluated by their distance in this space measured based on their latent features.
accordingly vector ljindicates the degree of tpl lj s possession of each of these latent features.
vector aimodels the degrees of mobile app ai s preferences for these latent features.
grec is able to approximate the potential usefulness of a tplljfor a mobile app aiin terms of those latent features by performing the element wise product operation over their vectors as follows ri j ai lj where symbol denotes the inner product of two vectors that measures the distance between aiandljin the latent factor space.
.
phase information distillation in this phase grec distills information for each node in gfrom the latent factor vectors of its neighbor nodes.
it goes through two main steps distilling low order app library interaction information distilling high order app library interaction information.
let ai denote the latent factor vector for mobile app aiafter it is initialized in phase representation .
it becomes ai after it is updated by the first layer of the gnn and ai l after thel th layer.
similarly lj denotes the latent factor vector for library nodeljinitialized in phase representation and lj l after the l th layer in the gnn.
in g each app node aiis directly connected to a number of library nodes denoted as n ai .
similarly the set of app nodes directly connected to a library node ljis denoted as n lj .
.
.
step low order app library interaction information distillation.
in this step grec employs the first layer of gnn to distill the low order app library interaction information for each node from its hop neighbors over g i.e.
n ai for app node aiandn lj for library node lj.
take appa1and libraryl4in fig.
as example.
for mobile app a1 grec distills the low order app library interaction information from nodes l1 l2 andl3.
for tpll4 grec distills the low order app library interaction information from nodes a2 a3anda5.
given an app aiand a library lj n ai s lj ai 469embedding app library graph for neural third party library recommendation esec fse august athens greece denotes the low order app library interaction information distilled fromljforai calculated as follows s lj ai w lj w ai lj wherew w rd dare two weight matrices obtained through the gnn training process.
they collectively determine how much information will be extracted from neighbor node lj.
the superscript indicates that w w 2belong to the first layer of the gnn.
the symbol denotes the element wise product operation.
the ai lj part in includes extra information distilled from libraries that possess latent features preferred by ai.
for example a1 .
.
.
means that app aiprefers the first and the third latent features more than the second one.
let us assume that libraryl1 s latent factor vector for the first layer of the gnn is l1 .
.
.
.
this indicates that l1possesses the first and second latent features more than the third one.
with the operation there is a1 l1 .
.
.
.
it will include additional information in the calculation of s l1 a1 .
the low order app library interaction information distilled from all the libraries in n ai with eq.
is combined to calculate the overall information for ai denoted as s ai s ai lj n ai 1p n ai n lj s lj ai where1 n ai n lj is the graph laplacian norm that automatically adjusts the weight of each individual app library interaction.
for example if mobile app aiuses a large number of tpls it is connected to many library nodes in gand n ai will be large.
its corresponding graph laplacian norm will be low and each tpl inn ai will make a relatively low contribution to s ai .
the same applies to each tpl in n ai .
if libraryljis used by many apps then n lj will be large and the corresponding graph laplacian norm will be low thus its weight in eq.
will decrease.
next vector ai is obtained which contains the low order applibrary interaction information distilled by the first layer of gnn.
it is defined as follows ai leakyrelu w ai s ai where function leakyrelu is an activation function widely used in neural networks to control the amount of information transmitted between different layers of a neural network.
example.
fig.
provides an example process that distills loworder app library interaction information from tpls l1 l2 andl3 for mobile app a1in fig.
.
first grec employs eq.
to distill individual app library interaction information from the three corresponding library nodes i.e.
s l1 a1 s l2 a1 ands l3 a1 respectively.
then it combines the three pieces of information to produce s a1 with eq.
.
finally it outputs the latent factor vector a1 with eq.
as the input to step in phase and phase .
meanwhile grec distills low order app library interaction information for each library node in gin a similar manner.
eq.
eq.
l2 l3 a1 l112output a1 l1 l2 l3 s l1 a1 s l2 a1 s l3 a1 s a1 a1 eq.
eq.
eq.
figure low order app library interaction information distillation for a1 .
.
step high order app library interaction information distillation.
in this step grec distills high order app library interaction information for each node in g. it iterates the process introduced above in step using the output latent factor vectors produced by the last iteration as input to the next iteration.
in this way information can be distilled from nodes within multiple hops over gfor each node in g. for example the output vectors of step i.e.
the output vectors of the first layer of the gnn possess the low order app library interaction information distilled from hop neighbor nodes over g. taking those updated vectors as input the same process in step is performed on the second layer of the gnn.
then the output vectors possess their individual high order app library interaction information obtained from their hop neighbor nodes over g. to generalize the l th layer of the gnn can distill the high order applibrary interaction information for a node from its l hop neighbor nodes.
assuming that the gnn has a total of nlayers grec can distill high order app library interaction information for each node from its neighbors within nhops.
in thel th layer of the gnn high order app library interaction information distilled for app node ai denoted as s l ai can be recursively defined as s l ai lj n ai 1p n ai n lj s l lj ai wheres l lj ai is defined as follows s l lj ai w l lj l w l ai l lj l wherew l w l rd dare weight matrices.
ai l and lj l are vectors output by the l th layer of the gnn.
similar to step vector ai l can be obtained based on s l ai ai l leakyrelu w l ai l s l ai example.
fig.
demonstrates the way grec distills high order app library interaction information from tpl l5 i.e.
nodel5in fig.
for mobile app a1 i.e.
nodea1in fig.
along the path l5 a3 l2a1over the app library graph gwhenhop .
the latent factor vector for node l5initialized in phase is denoted as l5 .
grec distills the app library interaction information from l5 and merges it into vector a3 i.e.
the vector for node a3updated by the first layer of the gnn.
next grec merges the information distilled from 470esec fse august athens greece bo li qiang he feifei chen xin xia li li john grundy and yun yang a1 l2 a1 l1 l2 l3 a3 a4 l4 l5 ... ... ... ... original layer layer layer figure high order app library interaction information distillation for a1 vector a3 into vector l2 i.e.
the vector for node l2updated by the second layer of the gnn.
finally grec merges the information distilled from vector l2 into vector a1 .
this vector is updated by the third layer of the gnn.
in this way the high order app library interaction information possessed by node l5is transmitted to a1.
grec distills high order app library interaction information for each library node ljvia a similar process.
we denote the high order app library interaction information distilled from l hop neighbor nodes ass l lj and denote the corresponding vector of ljas lj l .
then there is s l lj ai n lj 1p n ai n lj s l ai lj wheres l ai lj is the high order app library interaction information produced from n lj forlj defined as follows s l ai lj w l ai l w l lj l ai l then we obtain vector lj l as follows lj l leakyrelu w l lj l s l lj .
phase aggregation in phase information distillation each layer of the gnn outputs an individual vector for each node in g. those vectors possess loworder and high order app library interaction information distilled from neighbor nodes within different number of hops.
in phase aggregation grec concatenates all the vectors that belong to the same node to constitute a final vector for each mobile app and tpl.
assuming a total of nlayers in the gnn the constituted latent factor vector for node aiis formulated as follows a i ai ai ai ai n where is the concatenation operation.
similarly the aggregated latent factor vector for node ljis defined as follows l j lj lj lj lj n by adjusting parameter n grec can control the scope of distillation for making recommendations.
for example n 1means only the low order app library interaction information will be distilled andn 5means both the low order and high order app libraryinteraction information within hops over gwill be distilled.
the optimalncan be experimentally obtained.
.
phase prediction as introduced in section .
vector l jmodels the degree of each latent feature possessed by tpl lj.
vector a imodels the degrees of mobile app ai s preferences for those latent features.
thus the potential usefulness of ljforai denoted by r i j can be approximated as follows ri j a i l j for example the inner product of a 1and l 4is the potential usefulness of l4for appa1.
when recommending potentially useful tpls for a mobile app say a1 grec performs the element wise product on a 1with each library s latent factor.
then it obtains the potential usefulness of each library for a1.
next it recommends the topnrtpls with the largest potential usefulness that are not used bya1fora1.
the recommended tpls can be prioritized in developers search for and evaluation of useful tpls for a1.
experimental evaluation we first introduce our experiment settings then evaluate grec s performance motivated by four research questions.
finally we discuss the threats to the validity of the evaluation.
.
experimental setup our experiments are motivated by the following research questions rq1 how does grec perform compared with existing tpl recommendation approaches?
rq2 is high order app library interaction information useful for improving grec s performance?
rq3 does the dimensionality of the latent space d have any impact on grec s performance?
rq4 are grec s tpl recommendations considered useful by realworld practitioners?
we implemented grec using ngcf the state of the art gnn based recommendation framework.
the computer used in the experiments is equipped with intel i5 7400t cpu gb ram and an nvidia tesla p100 12gb gpu accelerator running windows x64 enterprise pytorch .
.
numpy .
.
scipy .
.
and scikit learn .
.
.
our experiments are conducted on the malib dataset a public real world dataset that contains android apps distinct tpls and app library usage records.
the mobile apps in this dataset were collected from google play and the tpl usage records were manually validated.
on average each of the mobile apps in the dataset uses .
tpls.
grec is designed to recommend potentially useful tpls for developers who would like to leverage tpls to improve their mobile apps.
following the same evaluation methodology of and we select mobile apps that use or more tpls as testing apps for the experiments.
the rationale behind this is the same as and the developers of these mobile apps tend to use tpls in their mobile apps.
in total mobile apps are included in the experiments using a total of tpls extracted from app library usage records.
471embedding app library graph for neural third party library recommendation esec fse august athens greece similar to we mimic real world scenarios that developers have used a number of tpls in their mobile apps and are seeking new tpls to improve their mobile apps further.
in the experiments we employ the cross validation technique to evaluate grec and use parameters rmandnrto simulate various tpl recommendation scenarios.
parameter rmdetermines how many tpls are removed from each testing app while nrdetermines how many tpls are recommended for each testing app i.e the length of each recommendation list referred to as listhereafter .
we set rm andnr in different scenarios.
in each experiment run we randomly remove rmtpls from each of the testing app.
next we run grec to recommend a list with nrtpls for each testing app.
then we evaluate grec s performance by inspecting whether those removed tpls are recommended for corresponding apps.
in each experiment run recommendation lists are generated one for each of the testing apps.
every time a setting parameter varies we perform experiment runs and report the average results.
we employ the following five metrics for evaluating grec s recommendation performance.
for all the metrics a higher value indicates higher performance.
mean precision mp .
given a list the precision is the ratio of the correctly recommended tpls over nr i.e.
the total number of tpls in the list.
then mp is the average precision across all the lists in an experiment run.
mean recall mr .
given a list the recall is the ratio of the correctly recommended tpls in the list over all the tpls removed from the corresponding testing app.
mr is the average recall across all the lists in an experiment run.
mean f1 score mf .
f1 score conveys a balance between the precision and recall of one list.
mf is the average f1 score across all the lists in one experiment run.
mean average precision map .
given a list withnrtpls the average precision ap measures grec s ability to put removed tpls at high positions in the list.
it is calculated as follows ap 1 nr i 1cor i nr i 1 i j 1cor i i cor i whereiincreases from to nrin steps of and cor i indicates whether a library at position iis a removed one.
it returns if yes and otherwise.
map is the mean ap across all the lists in one experiment run.
coverage cov .
cov measures the diversity of grec s recommendation results.
it is the ratio of distinct tpls on all the lists in one experiment run over all the distinct tpls in the malib dataset.
it is an important performance metric for evaluating recommendation approaches in recent years which allows us to inspect whether grec sacrifices diversity for accuracy.
.
rq1 performance comparison we compare grec to four other approaches including one baseline approach and three state of the art tpl recommendation approaches.
pop this always recommends the most popular tpls not used by the testing app.
it is a common baseline for evaluating recommendation approaches .
librec this combines association rule mining and collaborative filtering cf to make recommendations for conventional java projects.
librec has been widely used as a competing approach in recent studies .
crossrec this approach was proposed very recently and employs the cf based technique to recommend tpls for target open source projects.
libseek this is the state of the art approach that was specifically designed for recommending tpls for android apps.
it employs a matrix factorization technique to find potentially useful tpls for mobile apps.
to conduct a fair comparison the parameter settings of each competing approach are exactly the same as that in and respectively.
in grec the number of layers in the gnn is i.e.
n and the layer size is .
the size of each latent factor vector is also set to i.e.
d .
table compares the average performance of all the competing approaches under different parameter settings.
we can see thatgrec achieves the highest performance under all the parameter settings indicated by its highest mp mr mf map and cov values.
it outperforms pop librec crossrec and libseek by .
.
.
and .
respectively on average across all the cases.
when rm 1andnr grec outperforms pop librec crossrec and libseek by .
.
.
and .
respectively.
when rm 5andnr it outperforms pop librec crossrec and libseek by .
.
.
and .
respectively.
compared with pop librec crossrec and libseek the average improvement of grec is .
.
.
and .
in mp .
.
.
and .
in mr .
.
.
and .
in mf .
.
.
and .
in map respectively.
this demonstrates grec s superior performance.
surprisingly grec can highly diversify its recommendation results while achieving a high recommendation accuracy indicated by its significant advantage in cov over competing approaches i.e.
.
.
.
and .
against pop librec crossrec and libseek respectively.
we find that the cov of pop is particularly low across all the cases.
the reason is that pop always recommends a few of the most popular tpls that have not been used by the testing app.
thus the other less popular tpls are seldom recommended.
this is a critical limitation as recommending only popular tpls is not beneficial to developers .
in contrast grec diversifies the recommendations by recommending both popular and less popular tpls indicated by its highest cov values in all cases.
unlike librec crossrec and libseek that use only a small portion of low order app library interaction information when making recommendations grec makes full use of the low order app library interaction information and employs also high order app library interaction information distilled from the app library graph in the recommendations.
this boosts grec s performance indicated by its highest performance in terms of both recommendation accuracy and recommendation diversity.
472esec fse august athens greece bo li qiang he feifei chen xin xia li li john grundy and yun yang table performance comparison dataset approachesnr nr mp mr mf map cov mp mr mf map cov rm 1pop .
.
.
.
.
.
.
.
.
.
librec .
.
.
.
.
.
.
.
.
.
crossrec .
.
.
.
.
.
.
.
.
.
libseek .
.
.
.
.
.
.
.
.
.
grec .
.
.
.
.
.
.
.
.
.
rm 3pop .
.
.
.
.
.
.
.
.
.
librec .
.
.
.
.
.
.
.
.
.
crossrec .
.
.
.
.
.
.
.
.
.
libseek .
.
.
.
.
.
.
.
.
.
grec .
.
.
.
.
.
.
.
.
.
rm 5pop .
.
.
.
.
.
.
.
.
.
librec .
.
.
.
.
.
.
.
.
.
crossrec .
.
.
.
.
.
.
.
.
.
libseek .
.
.
.
.
.
.
.
.
.
grec .
.
.
.
.
.
.
.
.
.
.
rq2 impact of high order app library interaction information to investigate the usefulness of the high order app library interaction information in the recommendations we vary the number of the layers in the gnn n from to in steps of and measure grec s corresponding performance.
when n grec employs only low order app library interaction information to make recommendations.
when n it employs both low order and high order app library interaction information to make recommendations.
fig.
illustrates the impact of the high order app library interaction information where three tpls are removed from each testing app i.e.
rm and the number of tpls in each list is and respectively i.e.
nr .
we find that whennincreases from to grec s performance significantly increases in all the five metrics .
this observation demonstrates the effectiveness of employing high order app library interaction information for making tpl recommendations.
for example when nr 5andn grec achieves .
.
.
.
and .
in mp mr mf map and cov respectively.
when nincreases to it achieves .
.
.
.
and .
in mp mr mf map and cov respectively i.e.
.
.
.
.
and .
higher than when n .
when nincreases to grec s performance continues to increase reaching .
.
.
.
and .
in mp mr mf map and cov respectively.
when ncontinues to increase from grec s performance decreases slightly in mp mr mf and map .
the reason is that an overly large nwill include high order information distilled from many app and library nodes far away from the testing app in gin the recommendations.
these apps and tpls may not be similar to the target app and its tpls.
the noise generated by these nodes lowers grec s recommendation accuracy.
however grec s cov value continues to increase which indicates the effectiveness of leveraging high order information to increase the diversity.
.
rq3 impact of dimensionality of latent space as introduced in section .
grec embeds mobile apps and tpls asd dimension latent factors to represent their specific features such as functionality performance and compatibility.
to study the impact of different values of don grec s performance we vary dfrom to .
fig.
shows the experimental results.
when dincreases grec s performance in all the metrics increases.
for example when nr rm andd grec achieves .
.
.
.
and .
in mp mr mf map and cov respectively.
when dincreases to grec achieves .
.
.
.
and .
in mp mr mf map and cov i.e.
.
.
.
.
and .
higher than when d .
the reason is that a higher dimensionality of the latent space allows grec to model more potential latent features that reflect the relationships between apps and tpls.
in general more latent features allow grec to model the potential usefulness of each tpl for each mobile app more precisely.
thus grec can recommend tpls more effectively with a higher d. another interesting observation is that when dincreases from to then to grec s performance increases rapidly indicated by the increment in all the metrics.
however when dcontinues to increases from to and then to grec s performance increase slows down.
in practice a proper value of dcan be identified through experiments.
.
rq4 user study our experiments are conducted on testing mobile apps to simulate real world mobile apps need for new tpls.
the tpls removed from testing apps are assumed to be useful for the corresponding testing apps.
this is the common assumption made in almost all the research on recommendations in the field of software engineering as well as many other fields.
however the tpls removed from the testing apps are not necessarily always the best ones.
in fact it is 473embedding app library graph for neural third party library recommendation esec fse august athens greece number of layers n 1a .
.
.
.
.41mp nr rm number of layers n 1b .
.
.
.
.695mr nr rm number of layers n 1c .
.
.
.515mf nr rm number of layers n 1d .
.
.
.8map nr rm number of layers n 1e .
.
.
.75cov nr rm number of layers n 2a .
.
.
.
.234mp nr rm number of layers n 2b .
.
.
.79mr nr rm number of layers n 2c .
.
.
.
.362mf nr rm number of layers n 2d .
.
.
.76map nr rm number of layers n 2e .
.
.
.85cov nr rm figure impact of high order app library interaction information vector size d 1a .
.
.
.42mp nr rm vector size d 2e .
.
.
.8cov nr rm vector size d 1b .
.
.
.75mr nr rm vector size d 1c .
.
.55mf nr rm vector size d 1d .
.
.
.85map nr rm vector size d 1e .
.
.
.8cov nr rm vector size d 2a .
.
.
.24mp nr rm vector size d 2b .
.
.
.85mr nr rm vector size d 2c .
.
.
.38mf nr rm vector dimension d 2d .
.
.8map nr rm figure impact of dimensionality of latent space impossible to identify the theoretically best tpls for the testing apps as the ground truth for the evaluation of grec.
to minimize this threat we conduct a user study with real world android app developers to answer rq4 i.e.
whether grec s recommendations are indeed useful for real world mobile apps.
we randomly select android apps from the f droid repository7 a famous open source android app repository.
then we download the source files of their latest versions as of and collect their developer information i.e.
developers names and emails.
next we manually inspect the build.gradle files of those apps in their source files and obtain all the tpls used in each mobile app.
then we run grec libseek and pop individually based on the malib dataset to generate three lists of recommended tpls for each of the apps.
then we email the lists for each app to the corresponding developers and ask them to rate for each tpl in the three lists individually to indicate how much they believe it is useful e.g.
offering useful new features and or enhancing their apps.
developers rate if they think a tpl is not useful at all and if a tpl is highly useful.
to help investigate grec s impact on different developers we also inquire about their work experiences.
we state that their personal information will be protected.
we sent out emails in total and developers responded.
however of them failed to rate all the recommended tpls and were excluded from our analysis.
finally we received ratings in total made by developers i.e.
ratings for each of the three approaches.
fig.
illustrates the distribution of those ratings.
overall grec receives the highest ratings indicated by 5s 4s 3s 2s and 1s.
.
of the tpls recommended by grec are rated or higher.
this demonstrates that most developers highly acknowledge the usefulness of grec s recommendations .
in contrast libseek received 5s 4s 3s 2s and 1s.
.
of the tpls recommended by libseek are rated or higher.
pop received the lowest ratings overall i.e.
5s 4s 3s 2s and 1s.
almost .
of the tpls recommended by pop are rated or lower.
this observation confirms that recommending only the most popular tpls is not useful for most developers.
the high ratings received by grec indicate that grec s recommendations are indeed useful for real world mobile apps.
table summarizes developers ratings for grec s recommendations according to their work experience.
a higher rating indicates higher satisfaction with a recommended tpl.
there are in total and developers in the four groups.
through table we can find that grec receives higher ratings from developers with less development experience in general.
for example .
of the developers with years work experience or less mark the recommended tpls or while only .
of the developers with more 474esec fse august athens greece bo li qiang he feifei chen xin xia li li john grundy and yun yang ratings0100200300400number of ratingsgrec libseek pop figure distribution of developers feedback table impact of development experience on ratings experience years years years years of developers rating rating rating rating rating average .
.
.
.
than years work experiences give the same ratings.
we can find that experienced developers tend to provide lower ratings overall for all the competing approaches.
this observation demonstrates that tpl recommendation is more useful for novice developers.
.
threats to validity internal validity the main threat is our conclusion on the relationship between grec s high performance and its utilization of both low order and high order app library interaction information distilled from the app library graph.
to minimize this threat we varied the number of layers n in the experiments.
it allows us to observe grec s performance when it makes recommendations with and without high order app library interaction information.
the optimalncan be experimentally obtained for grec to achieve the best performance.
external validity the main threat comes from the scale of the user study.
only mobile app developers participated in our user study.
however the results of the user study are consistent with our experimental results.
in the future to mitigate the threat we plan to perform a large scale user study.
the second main threat comes from the reuse of the malib dataset.
although it has been carefully inspected it may still contain errors.
in the future we plan to perform experiments on a larger dataset to further evaluate grec s performance.
construct validity the main threat comes from the four competing approaches used in our experiments.
these approaches leverage only limited low order app library interaction information mined from the malib dataset to make tpl recommendations.
thus their performance tend to be lower than grec.
to minimize this threat we varied rm nr hop anddto evaluate grec s performance comprehensively.
thus this threat is valid but not significant.
related work recommendation techniques have been widely used to facilitate software development .
a number of approaches has been proposed for recommending program clips or apis of particular tpls to improve development efficiency.
to name a few zheng et al.
propose an approach that recommends new apis for api replacement during software development.
thung et al.
take the textual description of a feature request as input and recommend potentially useful methods apis to help developers implement the feature .
besides they consider also the similarity between two features based on the number of similar api methods used for implementing the two features.
huang et al.
employ word embedding technique to bridge the gap between demand descriptions and structured api descriptions when recommending apis for software development .
liu et al.
propose recrank to improve the top api recommendation accuracy based on the api usage paths in the corresponding call graph .
xie et al.
distill hierarchical context information from project specific code by analyzing its call graph then recommend new apis for development .
nguyen et al.
employ app library interaction filtering cf to recommend apis for open source projects .
a major difference between grec and the above approaches is that grec recommends as a whole library rather than specific program clips or apis.
besides grec requires app library usage records to make the recommendations without the need for extra contextual information.
in recent years several approaches are proposed to help developers find potential useful tpls through mining app library usage patterns .
saied et al.
propose coupminer that employs both client based mining and library based usage mining to cooperatively mine app library usage patterns .
ouni et al.
propose a search based approach namely libfinder to detect relevant tpls for software maintenance and evolution .
specifically they employ the semantic similarity between source codes and tpl co usage relationship to mine app library usage patterns.
recently another tool named libcup is proposed by saied et al.
for mining app library usage patterns .
libcup computes the similarity between different tpls based on their usage history.
then it applies a multi layer clustering approach to categorize different tpls.
chouchen et al.
employed non dominated sorting genetic algorithm to recommend tpls by considering tpl co usage information tpl functional diversity and app ratings .
inspired by the great success of cf in a variety of recommendation domains researchers have started to employ cf to recommend tpls for software development in recent years.
the advantage of cf based approaches is that they can model app library usage patterns in a latent way.
they make recommendations based on only similar app library usage in software projects without having to explicitly model tpls functionality reliability compatibility and dependency.
librec is the first approach that employs cf to recommend tpls for java projects .
it combines association rule mining and collaborative filtering to mine app library usage patterns and then recommends potentially useful tpls for target projects.
similarly crossrec recommends tpls for open source software projects based on collaborative filtering .
libseek is the first tool specifically designed for recommending tpls for android app development .
it employs the matrix factorization 475embedding app library graph for neural third party library recommendation esec fse august athens greece technique to find potentially useful tpls and adaptively adjusts the weights of different tpls to diversify recommendation results.
however these existing tools exploit only limited low order information extracted from app library usage records which prevents them from providing highly accurate recommendations.
in this paper we propose grec which takes a giant step to advance tpl recommendation for mobile apps significantly and innovatively with a graph neural network gnn .
grec models app library interactions with an app library graph then distills both low order and high order app library interaction information with the gnn for making tpl recommendations.
its performance is compared against a baseline popularity based recommendation approach and three state of the art approaches including librec crossrec and libseek via experiments and a user study.
as described in section .
grec significantly outperforms all the competiting approaches in terms of both accuracy and diversity.
conclusion and future work we have proposed grec a novel graph neural network gnn based approach for recommending potentially useful third party libraries tpls for mobile app development.
grec can help relieve developers burden in searching for and evaluating useful tpls for improving their mobile apps.
unlike existing tools that use only limited low order app library interaction information grec models the relationships between mobile apps and tpls into an app library graph.
then it distills both low order and high order app library interaction information with a gnn to make tpl recommendations.
the experimental results on android apps and the user study demonstrate the high performance of grec.
in future we will study how to make recommendations for specific versions of tpls.
we also plan to perform experiments on a larger dataset and conduct a user study with more participants.
acknowledgement this work is partly funded by australian research council discovery projects dp180100212 dp200102491 and dp200100020.
john grundy is funded by arc laureate fellowship fl190100035.
li li is funded by arc discovery early career researcher award de200100016.
qiang he is the corresponding author of this paper.