bsan a powerful identifier based hardware independent memory error detector for cots binaries wen zhang university of georgiabotang xiao university of georgiaqingchen kong university of georgiale guan university of georgiawenwen wang university of georgia abstract this paper presents bsan a practical softwareonly memory error detector for binary code.
different from state of the art binary level detectors which rely on either the shadow memory based approach or the hardware specific feature and thus suffer from several fundamental limitations bsan adopts an identifier based approach enabling it to detect deep memory errors missed by existing detectors.
also bsan does not depend on any specific hardware features.
to reduce the high performance overhead caused by identifier propagation bsan creates a novel hybrid approach static analysis dynamic instrumentation to improve the performance without inheriting the poor reliability of static binary rewriting distinguishing it from existing detectors that simply refer to static binary rewriting for better performance.
the comprehensive evaluation demonstrates that bsan can detect more memory errors than state of the art binary level detectors.
meanwhile the performance and memory overheads of bsan are comparable to those of existing detectors.
i. i ntroduction memory errors such as buffer overflows and use after free errors have serious impacts on software reliability stability and security .
a previous study shows that around of high severity security bugs found in google chrome one of the most popular web browsers are memory errors .
this phenomenon is also observed by a security vulnerability study conducted by microsoft .
therefore detecting memory errors is of high importance for building reliable secure and sustainable software systems.
on today s commercial platforms such as microsoft windows and apple macos most software is still closed source and distributed only through executable binaries.
even on open source platforms like linux many applications depend on third party libraries without source code available.
further legacy software developed for outdated platforms often lacks complete source code copies.
in most cases although the source code is available compiling it with modern compiler toolchains may face various problems .
hence it is strongly necessary to improve the reliability and security of binaries by detecting memory errors lurking in them.
previous research work has developed several binary level memory error detectors without the need for application source code.
notable examples include retrowrite mtsan dr. memory memcheck qasan and undangle .
although these detectors have been quite successful in detecting memory errors in commercial off the shelf cots binaries they suffer from three fundamental limitations.
limitation the incapability of detecting deeply hidden memory errors.
most existing binary level detectors includ ing qasan retrowrite dr. memory and memcheck employ ashadow memory based approach to capture the status of application memory for memory error detection.
specifically before a memory access is executed the corresponding shadow memory location is checked to determine whether the access is valid or not.
although this mechanism is quite intuitive to implement for binary code it may miss both spatial and temporal memory errors due to its limited detection capability see ii for more details .
as a result deeply hidden memory errors can easily escape these detectors leading to security risks.
limitation the lack of universal applicability and practicability.
to reduce the high runtime overhead incurred by dynamic binary instrumentation several detectors including retrowrite and mtsan utilize static binary rewriting to instrument target binary code.
although static rewriting can remove the need for dynamic instrumentation it renders the detectors vulnerable to low practicability due to the notorious challenges of statically rewriting binaries caused by the inherent complexity of binary code .
for instance retrowrite only supports position independent binary code compiled with a specific compiler in a specific version.
limitation hardware dependence.
different from other software only detectors mtsan relies on the memory tagging hardware extension introduced recently by armv8.
a processors to perform memory error detection.
obviously this hinders the adoption of this detector on other commercial hardware platforms e.g.
x86 and risc v as well as plenty of arm devices without such a hardware feature available.
to address the above limitations this paper presents bsan anidentifier based memory error detector for cots binaries.
bsan assigns a globally unique identifier for each memory object and attaches the identifier to pointers that point to this object.
when a pointer is dereferenced bsan first uses the attached identifier to find the metadata of the accessed object e.g.
bounds information and then examines the metadata and the pointer to detect memory errors.
although prior work has implemented the identifier based approach at the source code level the development of bsan entails multiple unique technical challenges e.g.
how to propagate identifiers along with binary level pointer operations and how to manage the high performance overhead introduced by the propagation.
we will discuss these challenges and our solutions in iii.
compared to state of the art binary level detectors bsan has several distinctive advantages.
first bsan is able to detect more memory errors especially those that are deeplyhidden in binaries and cannot be detected using the shadowmemory based approach.
second bsan is a pure software detector and does notrely on any hardware specific features.
therefore it can be applied to binaries compiled for various hardware platforms.
finally bsan achieves universal practicability by inventing a novel hybrid approach i.e.
static analysis dynamic instrumentation to avoid brittle static binary rewriting.
this also offers an exclusive opportunity for bsan to realize slightly better runtime performance than existing dynamic instrumentation based detectors e.g.
dr. memory.
we have implemented bsan based on two widely used binary analysis and instrumentation frameworks dyninst for offline static analysis and dynamorio for online memory error detection.
to evaluate bsan we conduct comprehensive experiments covering three well recognized benchmark suites i.e.
juliet spec cpu and parsec real world memory errors as well as real world applications in various domains.
we also compare bsan with four state of the art binary level detectors including mtsan retrowrite dr. memory and memcheck.
experimental results demonstrate that bsan can achieve desirable detection results by reporting more memory errors than other detectors.
moreover the detection efficiency of bsan including both performance and memory overheads is comparable to existing dynamic instrumentation based detectors.
in summary this paper makes the following contributions.
we present bsan a powerful software only memory error detector for cots binaries.
to the best of our knowledge bsan is the very first binary level detector that adopts an identifier based detection approach.
we overcome multiple unique technical challenges to realize an effective and efficient design of bsan.
these challenges differentiate bsan from previous identifierbased detectors developed at the source code level.
we implement bsan using two popular frameworks dyninst and dynamorio to support x86 binaries.
we make the source code of our implementation publicly available1to facilitate future research on bsan.
we conduct comprehensive experiments to evaluate bsan.
experimental results show that bsan achieves desirable detection results with both performance and memory overheads in parallel with existing detectors.
ii.
b ackground and motivation this section first introduces memory errors and then describes the shadow memory based and identifier based memory error detection approaches to motivate the need for a more effective and powerful binary level detector.
a. memory errors in general there are two types of memory errors.
a spatialmemory error happens when an instruction attempts to access an address that is out of the bounds of the accessed memory object.
common spatial memory errors include buffer and underflows.
depending on where it is located the accessed address may or may not be accessible.
in the case that the accessed address is accessible e.g.
located in another object the spatial memory error may nottrigger any observable misbehavior like a crash.
as a result such memory errors are hard to find if they cannot be caught by a detector.
differently a temporal memory error occurs when a memory access instruction tries to access a memory object that is out of its liveness range.
use after free and double free errors are two representative temporal errors.
here it is worth pointing out that use after free errors can happen on both heap and stack objects.
for instance a pointer that points to a local variable in a function may be propagated to the outside of the function and dereferenced after the function returns leading to a stack use after free error also known as use after return.
b. shadow memory based detection the shadow memory based detection approach is extensively used in state of the art memory error detectors including binary level detectors such as dr. memory memcheck retrowrite and qasan as well as source level detectors e.g.
addresssanitizer .
in this approach a shadow memory region is allocated to store the metadata of the original application memory.
the metadata captures the status of the application memory e.g.
whether a specific memory location is allocated and valid for access.
the mapping between the application memory and the shadow memory is usually fixed and one to one e.g.
a single byte of the application memory is mapped to several bits of the shadow memory to limit the total size of the shadow memory and make access to the shadow memory simple and fast.
the shadow memory is updated at special events to reflect the latest status of the application memory.
for instance when a heap object is deallocated the shadow memory corresponding to the object is updated to indicate the memory region of the object is freed and thus not valid for access.
by checking the metadata stored in the shadow memory when the application memory is accessed this approach can detect memory errors.
issues.
although the idea of this shadow memory based approach is quite intuitive it has two critical issues.
first it may miss spatial memory errors.
to understand the reason let us consider the following code snippet 1void foo int idx ... int buf buf ... a buffer overflow if idx in this example the function argument idx isnotchecked before it is used to access the stack buffer buf.
as a result this access may lead to a spatial memory error.
however depending on the value of idx the accessed memory location i.e.
buf may be in the stack frame of a caller function offoo .
in that case checking the shadow metadata of buf cannot detect this memory error as the metadata indicates the address is valid for access.
the underlying reason for this problem is that checking the metadata stored in the shadow memory is insufficient to validate a memory access.second it may also miss temporal memory errors.
as discussed before a use after free error caused by the dereference of a pointer pointing to a deallocated memory object can be detected by checking the shadow metadata.
however if the memory region of the deallocated object is reused to allocate a new object as shown in the following code snippet simply checking the shadow metadata will not be able to detect the memory error because the corresponding shadow metadata is about the new object rather than the old object.
1p malloc sizeof int ... 3free p 4q malloc sizeof int reusing the memory of p p ... a use after free error to mitigate this problem existing binary level detectors often adopt a heuristic quarantine mechanism which places deallocated objects in a quarantine queue to delay the reuse of the memory.
however even with this mitigation a use afterfree error can still easily escape the detectors as memory reuse can happen when the quarantine queue is full.
our experience with existing detectors shows that this is quite common in reality especially when target applications frequently allocate and deallocate memory objects.
worse it is very challenging to apply the quarantine mechanism for stack objects at the binary code level as stack regions are naturally reused across function calls leading to missed stack temporal errors.
c. identifier based detection different from the shadow memory based approach the identifier based approach assigns a globally unique identifier e.g.
an integer to each memory object and attaches the identifier to every pointer that points to this memory object.
when a pointer is dereferenced its attached identifier is used to find the metadata of the accessed memory object which includes the bounds information and whether the object is still alive i.e.
not deallocated.
by examining the metadata this approach can detect both spatial and temporal errors.
the key feature that distinguishes the identifier based approach from the shadow memory based approach is that it maintains the metadata for each memory object and uses the object identifier rather than the object address to find the metadata.
this allows it to obtain more accurate metadata even if the same memory region may be reused for different memory objects.
because of this reason the identifier based approach can detect deep memory errors missed by the shadow memorybased approach e.g.
the two memory errors discussed before.
due to the more powerful detection capability the identifierbased approach has been implemented at the source code level e.g.
softbound and cets .
however as we will discuss in the next section developing a binary level identifierbased detector faces unique technical challenges.
iii.
t echnical challenges there are three unique technical challenges to developing an identifier based memory error detector for binary code.
how to attach object identifiers to binary pointers?
an important requirement of the identifier based approach is thatevery pointer needs to be attached with the identifier of the memory object it points to.
at the source code level this can be easily achieved e.g.
through fat pointers .
however for binary code it is very challenging as data layouts of binaries are hard to modify flexibly and arbitrarily e.g.
appending extra bits to every pointer.
considering that 64bit memory pointers only use the low bits one may think about placing object identifiers into the unused bits of pointers .
unfortunately this method cannot work either as it is challenging to differentiate augmented bit pointer values from regular bit non pointer values at the binary code level due to the unavailability of the data type information in binaries.
as a result it is hard to determine whether the high bits of a bit value should be removed or not before it can be used for an arithmetic logic operation.
to overcome this challenge our key observation is that pointers in binary code are stored in either registers ormemory locations .
therefore by attaching object identifiers to them we can effectively maintain the association between pointers and object identifiers.
note that we need to use disjoint data structures to achieve this.
see iv for more details.
how to propagate identifiers along with binary level pointer operations?
the identifier attached to a pointer needs to be propagated appropriately when the pointer is involved in pointer related operations.
for example when deriving a new pointer by adding a constant value to an old pointer the identifier attached to the old pointer needs to be propagated to the new pointer.
otherwise dereferences of the new pointer cannot be checked.
however identifier propagation at the binary code level is quite challenging as it is unclear how to propagate identifiers for different instructions.
also anyincomplete propagation can potentially cause ineffective detection resulting in missed memory errors.
to overcome this challenge we create comprehensive identifier propagation rules according to general instruction semantics.
through these propagation rules we can effectively propagate identifiers along with pointer operations.
note that the design of the propagation rules is nottied to any specific instruction sets.
see iv for more details.
how to reduce the heavy performance overhead caused by propagating identifiers?
due to the lack of the data type information in binaries we have to instrument allinstructions that may produce new pointers to realize complete identifier propagation.
for instance let us consider the x86 instructionmov rax rbx which copies the value in rax to rbx.
since it is hard to know whether or not the value is a pointer this instruction has to be instrumented for potential identifier propagation even if the value may not be a pointer.
note that this is not an issue at the source code level because with the data type information this instruction would not be instrumented if the value is not a pointer.
to overcome this challenge we propose innovative optimizations to reduce the performance overhead introduced by identifier propagation.
our key insight is that it is only necessary to propagate an identifier if the propagated identifierdetection optimization propagation optimization instrumentation optimization dynamic instruction instrumentation application binary instrumentation planobject identifier management global identifier propagation memory error detection offline analysis online detection memory error fig.
.
system overview of bsan.
is required to check memory accesses in the following code for memory error detection.
by identifying and removing unnecessary propagation our optimizations can effectively reduce the performance overhead of propagating identifiers and boost detection efficiency.
see iv for more details.
iv.
s ystem design of bsan figure shows the overview of bsan which consists of two components offline analysis andonline detection .
given an application binary bsan first conducts a series of static analyses to identify optimization opportunities e.g.
redundant memory error detection and unnecessary identifier propagation.
after the analyses bsan generates an instrumentation plan to note what work needs to be done at specific instructions e.g.
memory error detection and or identifier propagation.
under the direction of this instrumentation plan bsan next runs the binary code with dynamic instruction instrumentation to realize object identifier management global identifier propagation and memory error detection.
if a memory error is detected during the execution bsan reports it with detailed information including the error type the problematic memory access instruction and the accessed memory object to facilitate further manual analysis.
next we describe more design details.
a. object identifier management the management of object identifiers includes creating an identifier for a memory object when it is allocated collecting the metadata of the object e.g.
the bounds and liveness information and attaching the identifier to the first pointer pointing to the object e.g.
a register.
bsan creates identifiers using a global bit counter which is atomically increased by one each time after a new identifier is generated.
that is bsan never reuses previous identifiers.
to maintain the collected metadata of memory objects bsan creates a hash table called object table using the identifier as the key.
each entry of the table corresponds to a memory object and when a memory object is deallocated the corresponding entry will be updated to indicate the object is not valid for access.
heap objects typically heap objects are allocated and deallocated explicitly by invoking standard library routines e.g.
malloc andfree or system calls e.g.
mmap andmunmap on linux.
by intercepting invocations to these routines and system calls bsan can collect the metadata of allocated heap objects e.g.
starting addresses and sizes.
once a heap object is successfully allocated bsan creates a new identifier for the object and attaches the identifier return address callee saved registers allocated by subtracting a constant value from rsp... return address callee saved registers ... memory arguments rsp at the entry of the callee function stack object bounds stack object bounds low address of the stack objects of the caller function stack variables of the callee function stack variables of the callee function fig.
.
bsan collects the stack object bounds information based on the stack structure.
the left and right sides show x86 stacks without and with memory arguments respectively.
to the register that returns the pointer of the object e.g.
rax of x86 and x0of aarch64.
also bsan offers a flexible programming interface for users to specify customer memory management routines.
this allows bsan to capture application specific heap object allocations and deallocations.
stack objects different from heap objects stack objects are allocated and deallocated implicitly which renders it challenging to monitor their allocations and deallocations.
to address this issue bsan considers function calls and returns2 as indicators of allocating and deallocating stack objects respectively inspired by the observation that stack objects are typically allocated in stack frames of functions.
specifically bsan creates an identifier for stack objects at the entry of a function and attaches the identifier to the stack pointer register e.g.
rsp of x86 and spof aarch64.
the old identifier attached to the stack pointer register which was created for the caller function is saved and recovered when the current function returns.
note that due to the lack of the type information in binaries bsan only assigns a single identifier for all stack objects residing in the same stack frame.
that means bsan cannot detect intra stack frame buffer overflows.
this is a common limitation of state of the art binary level detectors including retrowrite and dr. memory.
after an identifier is created for the stack objects in a function f bsan needs to collect the bounds information for the identifier i.e.
determining the high and low addresses.
high address .
intuitively we can use the stack pointer register value vspat the entry of fas the high address.
however this may cause false alarms for memory error detection as the accesses to memory arguments passed through the stack and located in addresses higher than vsp as shown in figure will be considered as out of bounds accesses.
to solve this issue bsan uses the low address determined for the identifier created at the caller function of fas the high address.
this way bsan can include memory arguments in the bounds.
since this will also include the return address stored on the stack bsan marks down the location of the return address and reports a memory error if it is overwritten by a memory access instruction.
2in general function calls and returns can be identified through corresponding instructions e.g.
call andret of x86 .
however the tail call optimization may complicate this process.
bsan addresses this issue by detecting tail call related branch instructions using state of the art techniques and treating such branches in a similar way to function calls and returns.init x id null reg constant id nullmem constant id nullreg memoryallocation id new id reg mem id id mem reg id id reg unaryop x id id reg xbinaryop y id null id null id null reg xbinaryop y id null id null id id reg xbinaryop y id null id null id null fig.
.
propagation rules of object identifiers in bsan.
low address .
bsan determines the low address based on the observation that the stack space is usually allocated by subtracting a constant value from the stack pointer register in the prologue of a function.
the constant value indicates the actual size of the allocated stack space.
by identifying and instrumenting such a subtraction instruction in f bsan can calculate the low address.
note that it is possible that there is no such a subtraction instruction in a function because for example the function has no stack variable or all stack variables are promoted to registers by the compiler.
in that case bsan simply counts the number of callee saved registers saved to the stack e.g.
through the push instruction of x86 in the current function to calculate the low address.
in addition bsan also monitors the invocations to the alloca routine which dynamically allocates memory on the stack to adjust the low address if necessary.
global objects bsan creates a single identifier for global objects located in the data section of an executable binary which is loaded into the memory at the beginning of the execution.
bsan uses the start address and the size of the loaded data section to calculate the high and low addresses for the identifier.
bsan attaches the identifier to the program counter pc register e.g.
rip of x86 as most pointers pointing to global objects are derived from the pc register.
b. global identifier propagation bsan creates a disjoint data structure called identifier mapping table to maintain the identifiers attached to registers and memory locations that contain pointers.
after an identifier is created for an object it is initially attached to the first pointer that points to the object e.g.
rax of x86 used to return the address of an allocated heap object.
then bsan propagates the identifier in the following execution by dynamically instrumenting executed instructions.
bsan propagates identifiers according to instruction types.
in general there are two types of instructions that may produce a new pointer from an existing pointer.
first a data movement instruction that copies a pointer between two registers or a register and a memory location.
second an arithmetic logic instruction that calculates a new pointer from an old pointer through an arithmetic logic operation.
for both types bsan propagates the identifier attached to the old pointer to the new int func void int ptr null ptr malloc sizeof int ... ptr overflow ... return ptr mov 0x4 edi 117a callq malloc plt rax 0x72a0 id 117f mov rax rbx id id ... add 0x8 rbx rbx 0x72a8 128b movl 0xa rbx a heap buffer overflow is detected idlow addr high addr 10x72a00x72a4 ptr id rax rbx ... ...... ... reg reg ... c the binary code of a and the propagation of the identifier in bsan a an example with a memory error b the object table top and the identifier mapping table bottom in bsan live yesfig.
.
an example showing how bsan detects a heap buffer overflow.
pointer by updating the identifier mapping table.
note that bsan does not perform any memory error detection on the new pointer until it is dereferenced to access the memory.
in other words it is allowed to produce an invalid pointer if the pointer is never used for any memory access.
figure shows the propagation rules used by bsan.
in addition to the two types of instructions mentioned above bsan also pays special attention to other instructions that may involve pointers.
in particular if an instruction computes a result from two pointers and both of them have identifiers bsan will notpropagate any of the identifiers to the computation result.
this is inspired by the observation that the computation result is typically not a new pointer but the offset between the two pointers.
thus it should not have an identifier.
it is also worth pointing out that bsan does not need to take extra care of function call return instructions.
the reason is that for both caller saved and callee saved registers if their values need to be preserved across a function call the compiler would generate necessary instructions to spill and restore them.
hence bsan only needs to propagate identifiers for those instructions accordingly.
c. memory error detection bsan performs memory error detection before a memory access instruction is executed.
the detection process includes three steps.
bsan uses the base register or the index register in the memory operand of the instruction to look up the identifier mapping table to get the identifier attached to the register.
bsan uses the identifier to search the object table to obtain the metadata information of the corresponding object.
bsan checks the accessed memory address against the metadata to detect spatial and temporal memory errors.
if no error is detected the instruction proceeds to access the memory.
otherwise bsan will report a memory error.
figure uses an example to show how a memory error is detected by bsan.
as shown in the source code there is an out of bounds access to the heap object allocated at line .
bsan instruments the binary code and assigns the identifier to the object after it is successfully allocated i.e.
after thecallq instruction.
it also updates the identifier mappingd p i mov rdi 0x40 rax mov rsi 0x10 rax lea 0x28 rax rcx cmpl 0xfff7 rcx mov rbx rcx je label instrumentation at mov rdi 0x40 rax .
memory error detection .
rax 0x40 temporal and spatial .
rax 0x10 spatial .
object identifier propagation .
id id .
id id .
id id d opt p opt i opt instrumentation plan d p i mov rdi 0x40 rax mov rsi 0x10 rax lea 0x28 rax rcx cmpl 0xfff7 rcx mov rbx rcx je label d p i mov rdi 0x40 rax mov rsi 0x10 rax lea 0x28 rax rcx cmpl 0xfff7 rcx mov rbx rcx je label d p i mov rdi 0x40 rax mov rsi 0x10 rax lea 0x28 rax rcx cmpl 0xfff7 rcx mov rbx rcx je label fig.
.
bsan conducts three static analysis passes to generate an instrumentation plan to optimize the performance of online memory error detection.
d memory error detection p object identifier propagation i instruction instrumentation the corresponding operation is required the corresponding operation is optimized out by the static analysis.
table to indicate that the identifier attached to the register rax is as the pointer of the allocated object is returned through rax.
next when the pointer in rax is copied to rbx bsan propagates the identifier to rbx by updating the identifier mapping table.
the add instruction does not change the identifier attached to rbx.
finally when the pointer in rbx is dereferenced bsan reports a memory error as the address inrbx is not within the bounds of the object indicated by the identifier attached to rbx.
d. offline analysis to optimize the performance efficiency of the online detection part particularly the high overhead incurred by propagating object identifiers bsan conducts an offline static analysis on the target binary.
the analysis essentially runs the following three passes on the control flow graph cfg of each function in the target binary.
the detection optimization d opt pass checks the necessity of performing memory error detection on memory access instructions and removes redundant detection.
for example if a memory object has been checked at a previous instruction the checks at following instructions can be skipped if they are guaranteed to be safe.
the propagation optimization p opt pass examines the necessity of propagating identifiers for instructions based on the analysis result of the d opt pass and removes unnecessary propagation e.g.
a propagated identifier is never checked for memory error detection.
based on the analysis results of the previous two passes the instrumentation optimization iopt pass aims to minimize dynamically instrumented instructions and generates an instrumentation plan to instruct the following dynamic instrumentation.to understand this process let us consider the example in figure .
in this example without the offline static analysis bsan needs to instrument the first fiveinstructions to perform memory error detection and object identifier propagation.
to reduce the performance overhead bsan first invokes the dopt pass.
through this pass bsan can identify that the memory error detection for the cmpl instruction is redundant.
the reason is that it accesses the same object as the previous two memory access instructions and the accessed bounds are within the bounds accessed by the previous instructions.
that means if the previous instructions do not cause any memory error it will not also.
note that bsan separately determines the necessity of temporal and spatial error detection for a memory access instruction.
next the p opt pass is conducted.
with this pass bsan finds out that the identifier propagation for the lea instruction can be removed given that the destination register rcx is not used for memory error checking.
finally the i opt pass combines the remaining memory error detection and identifier propagation to produce an instrumentation plan which indicates that only the first instruction needs to be instrumented.
note that bsan also includes the address of each source instruction that requires memory error detection in the instrumentation plan for memory error reporting.
it is worth pointing out that the offline static analysis in bsan is conservative in the sense that it only removes the detection propagation for an instruction if the static analysis can completely ensure the safety of the removal.
that means bsan may miss optimization opportunities due to the natural inaccuracy of the static analysis e.g.
the aliasing between different pointers.
but it will notmiss any memory errors because of applying the static analysis.
v. e valuation we have implemented a research prototype of bsan using dyninst version .
.
for offline analysis and dynamorio version .
.
for online detection .
the prototype currently supports x86 binaries.
the source code of the prototype is publicly available on github.
experimental methodology.
our evaluation aims to answer two key questions.
detection effectiveness .
can bsan detect memory errors in binaries and outperform state of theart binary level detectors in terms of reporting more memory errors?
detection efficiency .
how much performance and memory overheads does bsan introduce and are the overheads comparable to existing binary level detectors?
to this end we conduct comprehensive experiments to evaluate bsan covering a wide range of benchmark suites and real world applications.
more specifically we evaluate the detection effectiveness of bsan using the juliet test suite and a list of real world memory errors which were found from real world applications and the common vulnerabilities and exposures cve website .
some of these memory errors were also used by previous research work for evaluation.
juliet contains a collection of test cases under different common weakness enumerations cwes .
since bsan only detectstable i detection results of juliet test cases .
for each specific memory error juliet includes two test cases with and without the error respectively .
the cases column shows the total number of test cases with and without memory errors in each cwe category .
fn false negative rate fp false positive rate .
the detection results of mts an are from the mts an paper .
cwe id description casesdr.
memory memcheck retrowrite mtsan bsan fn fp fn fp fn fp fn fp fn fp stack buffer overflow .
.
.
.
.
heap buffer overflow .
.
.
.
.
buffer underflow .
.
.
.
.
buffer over read .
.
.
.
.
buffer under read .
.
.
.
.
double free use after free .
total .
.
.
.
.
memory errors we focus our evaluation on memory errorrelated cwes.
to evaluate the detection efficiency of bsan we use the spec cpu benchmark suite for singlethreaded performance the parsec benchmark suite for multi threaded performance and a set of real world applications from different domains such as pdf reader xml language parsing image library audio processing etc.
we also compare bsan with four state of the art binarylevel detectors including dynamorio based dr. memory valgrind based memcheck retrowrite and mtsan .
since the source code of mtsan is unavailable3 we cannot evaluate it on our platform.
fortunately mtsan was also evaluated with the juliet test suite and some cve vulnerabilities used in our experiments .
thus we reuse the data presented in the mtsan paper for the comparison.
note that we cannot evaluate all bugs used in the mtsan paper because of the lack of bug triggering inputs.
for retrowrite due to the brittleness of static binary rewriting we encountered various errors when running it in our experiments though we have carefully selected the same compiler version and options mentioned in the paper .
we also contacted the authors of retrowrite but the communication did not lead to any solutions.
as a result we can only present results for experiments retrowrite can successfully run.
the experimental platform is equipped with an octa core intel i9 cpu running at .10ghz and 64gb of main memory.
the operating system is ubuntu .
with the linux kernel version .
.
.
we use gcc version .
.
to compile test programs.
the platform is occupied exclusively during our experiments.
in addition we run each program five times and use the average execution time as its final performance.
a. detection effectiveness we first present experimental results to demonstrate the detection effectiveness of bsan.
juliet table i shows the detection results of juliet test cases.
as we can see none of the evaluated detectors reports false positives.
this is because these detectors monitor 3the link in the mtsan paper is not accessible.
we also contacted the authors but did not receive any response.program execution to detect memory errors and thus have a very low chance to report false positives.
regarding false negatives bsan outperforms other detectors in four cwe categories i.e.
cwe cwe cwe and cwe127.
that is bsan can detect more memory errors than other detectors in these cwe categories.
for memory errors in the two cwe categories i.e.
cwe and cwe bsan does not miss any of them.
this aligns with dr. memory memcheck and retrowrite but is better than mtsan which misses some memory errors.
for cwe mtsan achieves the best detection result though bsan can detect more memory errors than the other three detectors.
our further study shows that mtsan tries to guess object boundaries during the fuzzing process allowing it to occasionally detect some intra buffer memory errors.
since we run each test case only once we believe that it is extremely difficult if not impossible to recover accurate object boundaries with a single run.
we also find that the major reason why the evaluated detectors including bsan cannot detect some missed memory errors is the lack of the data type information in binary code which makes it hard to detect intra heap buffer and intra stack frame memory errors.
apart from this reason dr. memory and memcheck have very limited support for detecting memory errors related to stack objects e.g.
cwe121.
due to the shadow memory based detection approach dr. memory memcheck and retrowrite can miss many memory errors e.g.
cwe cwe and cwe .
in addition retrowrite suffers from various static binary rewriting errors which can either fail the static rewriting process or produce binaries that behave differently compared to the original binaries e.g.
exhibiting infinite executions and segmentation faults.
in summary the detection results of juliet test cases show that bsan can effectively detect memory errors.
for four cwes it outperforms state of the art binary level detectors.
real world memory errors table ii shows the detection results of the real world memory errors.
as the table shows bsan successfully detects all memory errors.
in contrast state of the art detectors cannot detect many of them due to different reasons.
dr. memory and memcheck miss stackbased memory errors due to their limited support for stacktable ii detection results of real world memory errors and cve vulnerabilities .
opt c ompiler optimizaiton level binsize binary size measured in kilobytes kb dm d r. memory mc m emcheck rw r etro write mt mts an bs bs an.
sw stack out of bounds write hw heap out of bounds write hr heap out of bounds read hf heap use after free sf stack use after free f static binary rewriting failure not evaluated .
detection results of mts an are from the paper .
type opt binsize dm mc rw mt bs type opt binsize dm mc rw mt bs cve swo0 .
f cve swo0 .
o1 .
f o1 .
o2 .
f o2 .
o3 .
f o3 .
cve swo0 .
f cve swo0 .
f o1 .
f o1 .
f o2 .
f o2 .
f o3 .
f o3 .
f cve swo0 .
f fdkaac bug swo0 .
f o1 .
f o1 .
f o2 .
f o2 .
f o3 .
f o3 .
f cve hro0 .
f gpac bug swo0 .
f o1 .
f o1 .
f o2 .
f o2 .
f o3 .
f o3 .
f cve hfo0 .
f cve hwo0 .
f o1 .
f o1 .
f o2 .
f o2 .
f o3 .
f o3 .
f cve swo0 .
cve hwo0 .
f o1 .
o1 .
f o2 .
o2 .
f o3 .
o3 .
f cve swo0 .
cve hro0 .
f o1 .
o1 .
f o2 .
o2 .
f o3 .
o3 .
f cve hfo0 .
cve hro0 .
f o1 .
o1 .
f o2 .
o2 .
f o3 .
o3 .
f cve hfo0 .
vim bug hro0 .
f o1 .
o1 .
f o2 .
o2 .
f o3 .
o3 .
f cve swo0 .
cve hfo0 .
f o1 .
o1 .
f o2 .
o2 .
f o3 .
o3 .
f cve swo0 .
f ph7 bug sfo0 .
f o1 .
f o1 .
f o2 .
f o2 .
f o3 .
f o3 .
f objects though they can find most heap based memory errors.
for retrowrite it can only detect one cve vulnerability because it fails to rewrite other binaries to generate runnable binaries.
regarding mtsan we only have limited detection results as it is not available for us to evaluate.
according to the mtsan paper it fails to detect cve a stack outof bounds write because this error modifies the stack canary which causes the crashed execution of the application before mtsan can detect it.
to summarize we can conclude from the detection results that bsan is more effective than state ofthe art detectors in detecting real world memory errors.
from table ii we can also observe that bsan is insensitive to different compiler optimization levels i.e.
from o0too3.
this demonstrates that bsan does notneed to take special care of compiler optimization levels as its design is general and not specific to any optimization levels.
figure shows the simplified source code of ph7 bug a real world stack use after free bug.
in this bug the local1static ph7 hashmap node 2hashmapnodemerge ph7 hashmap node pa ... ph7 hashmap node result ptail result.pnext result.pprev ptail result ... if xcmp pa pb pcmpdata ptail pprev pa pa pnext ptail the local pointer ptail ptail pa escapes from the current pa pa pprev function via pa pnext.
... fig.
.
ph7 bug a stack use after free bug.
note that state of the art binary level detectors cannot detect this bug due to their shadow memorybased approach while bsan can successfully report this bug.
pointer ptail is initialized with the address of the local variable result at line .
however this pointer is later propagated out of the function through the pointer pa pnext at600.perlbench602.gcc .mcf .omnetpp623.xalancbmk625.x264 .deepsjeng641.leela .exchange657.xz .bwaves607.cactubssn619.lbm .wrf627.cam4 .pop2638.imagick644.nab .fotonik3d654.roms geomean255075100125150normalized execution timedr.memory memcheck bsanfig.
.
normalized execution times of spec cpu benchmarks with different detectors.
the baseline is the native execution time without any detector.
retrowrite is excluded due to the errors it has when statically rewriting the binaries.
.perlbench602.gcc .mcf .omnetpp623.xalancbmk625.x264 .deepsjeng641.leela .exchange657.xz .bwaves607.cactubssn619.lbm .wrf627.cam4 .pop2638.imagick644.nab .fotonik3d654.roms geomean1100200300400normalized execution timeno opt d opt d opt p opt d opt p opt i opt fig.
.
normalized execution times of spec cpu benchmarks with bsan using different optimizations.
the baseline is the native execution time without any detector.
no opt no offline optimization d opt applying offline detection optimization only d opt p opt applying offline detection and propagation optimizations only d opt p opt i opt applying all offline optimizations i.e.
detection propagation and instrumentation optimizations.
blackscholes bodytrack ferret fluidanimate swaptions number of threads3570105normalized execution time facesim vips raytrace freqmine x264 dr. memory memcheck bsan fig.
.
normalized execution times of parsec benchmarks with different detectors under different numbers of threads.
the baseline is the native execution time without any detector under the corresponding thread number.
retrowrite is excluded in this experiment due to its static binary rewriting errors.
line .
as a consequence a stack use after free error will happen when pa pnext is dereferenced later.
unfortunately none of the evaluated binary level detectors can find this bug because when pa pnext is dereferenced it points to a valid address on the stack rendering the shadow memorybased approach ineffective.
thanks to the identifier based approach bsan can successfully report this bug by checking the identifier attached to pa pnext which corresponds to a deallocated stack object when this pointer is dereferenced.
b. performance efficiency we next study the runtime performance of bsan and compare it with other detectors.
single threaded performance figure shows the performance efficiency of spec cpu benchmarks runningwith different detectors.
here although retrowrite is not included because it fails to perform static binary rewriting for the benchmark binaries it is worth noting that retrowrite is expected to have better runtime performance than the detectors in the figure including bsan as it eliminates the high performance overhead incurred by dynamic instrumentation.
as shown in figure bsan consistently achieves the best performance efficiency for all benchmarks among the three evaluated detectors.
this demonstrates the high performance efficiency of bsan compared to existing detectors.
on average bsan incurs .
performance slowdown while dr. memory and memcheck result in .
and .
performance slowdown respectively.
given that dr. memory and memcheck are widely adopted in practice to detect memory errors in application binary code this result shows the strongreadelfobjdumpsizefig2devxpdf soxsngrep mxml libtifffdkaac geomean020406080100normalized execution timedr.memory memcheck bsanfig.
.
normalized execution times of real world applications with different detectors.
the baseline is the native execution time without any detector.
practicability of bsan in terms of detection efficiency.
to understand the optimization effectiveness of the offline analysis in bsan we further measure its performance with different optimizations applied.
figure shows the results.
as we can see without applying any offline optimizations bsan introduces significant performance slowdown .
on average and as high as .
for600.perlbench .
this is because it needs to instrument most of the executed instructions to conduct memory error detection and object identifier propagation.
this result echoes the necessity of developing optimizations to improve the detection efficiency.
as the figure shows with more optimizations applied the performance slowdown is reduced substantially from .
to .
with d opt .
with d opt and p opt and .
with all optimizations i.e.
d opt p opt and i opt.
this demonstrates the effectiveness of the offline analysis in bsan in removing redundant detection and propagation.
multi threaded performance figure shows the performance results of parsec benchmarks running with different detectors under different numbers of threads.
again retrowrite is not included because of its static binary rewriting errors.
from the figure we can clearly see that bsan achieves better performance efficiency than the other two detectors.
overall the three detectors introduce .
dr. memory .
memcheck and .
bsan performance slowdown respectively when running the benchmarks with threads.
this shows that bsan is more applicable when detecting memory errors in multi threaded applications.
an interesting observation we can make from figure is that as the thread number increases the performance overhead incurred by memory error detection also increases for all three detectors.
a possible explanation for this phenomenon is that memory error detection may contend with application threads for limited computing resources e.g.
cpu cache which can offset the performance benefit achieved by increasing the number of threads.
real world applications figure shows the performance efficiency of the real world applications running with different detectors.
bsan again surpasses dr. memory and memcheck benefiting from its offline optimizations.
on average compared to the baseline bsan brings in a .
performance slowdown while dr. memory and memchecktable iii offline analysis times in seconds ofbsan for spec cpu benchmarks and their binary sizes inkb .
size time size time .perlbench .
.gcc .
.mcf .
.omnetpp .
.xalancbmk .
.x264 .
.deepsjeng .
.leela .
.exchange .
.xz .
.bwaves .
.cactubssn .
.lbm .
.wrf .
.cam4 .
.pop2 .
.imagick .
.nab .
.fotonik3d .
.roms .
readelfobjdumpsizefig2devxpdf soxsngrep mxml libtifffdkaac geomean01020normalized memory consumptiondr.memory memcheckbsan fig.
.
normalized memory consumption with different detectors.
the baseline is the memory size used by the native execution without any detector.
lead to .
and .
slowdown respectively.
with this result we are confident that it is practical to apply bsan for detecting memory errors in cots binary code.
c. cost analysis we finally study the analysis time of the offline analysis and the memory overhead of the online detection in bsan.
offline analysis time table iii shows the offline analysis times for spec cpu benchmarks.
as shown in the table for most benchmarks bsan can complete the offline analysis in less than seconds.
for some benchmarks e.g.
.gcc and623.xalancbmk the analysis times are longer than minutes because of their large binary sizes.
on average bsan needs .
seconds to analyze a binary application.
we further investigate the offline analysis process and find that the three optimization passes i.e.
detection propagation and instrumentation consume an average of .
.
and .
of the total offline analysis time respectively.
the remaining .
analysis time is used by the dyninst infrastructure to disassemble the binaries and construct cfgs.
since the offline analysis of bsan is a one time cost we consider the analysis times acceptable in practice.
memory overhead of online detection figure shows the normalized memory consumption of the real world applications running with different detectors.
from the figure we can clearly see that bsan incurs much less memory overhead than the other two detectors.
overall they respectively introduce .
dr. memory .
memcheck and .
bsan memory overhead.
the major reason for thetable iv the comparison between bsan and state of the art binary level detectors .
dt detection technique im instrumentation mechanism hi hardware independence .
oa offline analysis sm shadow memory hf hardware feature id object identifier dbi dynamic binary instrumentation sbr static binary rewriting .
dt im hierror type object type spatial temporal heap stack global undangle oa dbi qasan sm dbi dr. memory sm dbi memcheck sm dbi retrowrite sm sbr mtsan hf sbr bsan id hybrid high memory overhead of the other detectors is their adoption of the shadow memory based approach which requires the allocation of a large region of shadow memory and populating it with meaningful shadow bits even if the corresponding application memory is not allocated.
in contrast bsan uses the identifier based approach which allows it to allocate memory for the detection metadata on demand.
vi.
r elated work due to the high impact of memory errors and the popularity of binary code many binary level memory error detectors have been developed.
notable examples include dr. memory qasan undangle memcheck retrowrite and mtsan .
among them undangle is an offline detector which analyzes the execution traces of binary applications to detect heap use after free errors.
qasan dr. memory and memcheck are shadow memory based detectors using three different dynamic binary instrumentation frameworks i.e.
qemu dynamorio and valgrind respectively.
retrowrite uses static binary rewriting to implement a binary version of addresssanitizer which is a source level shadow memory based detector.
differently mtsan relies on the recently introduced memory tagging extension in arm processors to detect memory errors.
table iv summarizes the differences between bsan and state of the art binary level memory error detectors.
particularly bsan adopts an identifier based approach for memory error detection.
this allows it to detect more deeply hidden memory errors in binary code compared to existing shadowmemory based detectors as evidenced in our experimental results.
also it is a software only detector with no dependence on any hardware specific features.
though the identifier based approach has been implemented at the source code level bsan addresses several unique technical challenges of applying it to binary code e.g.
creatively combining offline analysis and online detection to reduce the high runtime overhead caused by propagating object identifiers.
in addition the techniques developed in bsan are notsoftware substitutions of prior hardware based solutions for mem ory safety .
for instance heapcheck assumes the availability of source code and relies on compilerbased instrumentation to leverage the unused bits in bit pointers to store pointer metadata for heap memory safety checks.
as discussed in iii this cannot work for binary code.
as another example rest modifies the instruction set to add new instructions for memory error detection and as a consequence it has to recompile program source code to generate new binaries to utilize the added instructions.
vii.
c onclusion in this paper we have presented bsan a powerful softwareonly memory error detector for cots binaries.
the distinctive feature that differentiates it from state of the art binary level detectors is the adoption of an identifier based approach.
this enables bsan to detect more deeply hidden memory errors in binary code.
the development of bsan also addresses several unique technical challenges of implementing the identifierbased approach at the binary code level.
experimental results show that bsan can achieve desirable detection effectiveness.
moreover the detection efficiency of bsan including both performance and memory overheads is comparable to existing dynamic instrumentation based detectors.
acknowledgment we would like to thank the anonymous reviewers for their insightful comments and feedback.
this work was supported in part by the u.s. national science foundation under grants cns cns and cns .
this work was also partially supported by the m. g. michael award funded by the franklin college of arts and sciences at the university of georgia and a faculty startup funding offered by the university of georgia.