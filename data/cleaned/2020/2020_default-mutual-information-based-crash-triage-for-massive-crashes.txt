d e.scf a.sc u.sc mutual information based crash triage for massivecrashesxing zhang1 jiongyi chen1 letter chao feng1 ruilin li1 wenrui diao2 kehuan zhang4 jing lei1 chaojing tang11national university of defense technology2school of cyber science and technology shandong university3key laboratory of cryptologic technology and information security ministry of education shandong university4chinese university of hong kongabstractwith the considerable success achieved by modern fuzzing in frastructures more crashes are produced than ever before.
todig out the root cause rapid and faithful crash triage for largenumbers of crashes has always been attractive.
however hinderedby the practical difficulty of reducing analysis imprecision withoutcompromising efficiency this goal has not been accomplished.in this paper we present an end to end crash triage solutiond e.scf a.sc u.sc for accurately and quickly pinpointing unique root causefrom large numbers of crashes.
in particular we quantify the crash relevance of program entities based on mutual information which serves as the criterion of unique crash bucketing and allowsus to bucket massive crashes without pre analyzing their rootcause.
the quanti f ication of crash relevance is also used in theshortening of long crashing traces.
on this basis we use theinterpretability of neural networks to precisely pinpoint the rootcause in the shortened traces by evaluating each basic block simpact on the crash label.
evaluated with programs with22216 crashes in total d e.scf a.sc u.sc demonstrates remarkable accuracyand performance which is way beyond what the state of the arttechniques can achieve crash de duplication was achieved at asuper fast processing speed .
secondsper crashing trace without missing any unique bugs.
after that it identi f ies the rootcause of unique crashes with no false negatives and an averagefalse positive rate of .
.ccs concepts security and privacy software security engineering.keywordscrash triage software security lettercorresponding author chenjiongyi nudt.edu.cn.permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro f it or commercial advantage and that copies bear this notice and the full citationon the f irst page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci f ic permission and or afee.
request permissions from permissions acm.org.icse may pittsburgh pa usa association for computing machinery.acm isbn .
.
.
.
reference format xing zhang jiongyi chen chao feng ruilin li wenrui diao kehuanzhang jing lei and chaojing tang.
.
d e.scf a.sc u.sc mutual information based crash triage for massive crashes.
in44th international conference onsoftware engineering icse may pittsburgh pa usa.acm new york ny usa pages.
introductionsoftware vulnerability is a prevailing threat in cyberspace.
todiscover and eliminate software vulnerabilities fuzzing has beenrecognized as one of the most e ective approaches by randomlyor strategically generating a large number of inputs to feed aprogram and trigger program exceptions.
for example the fuzzinginfrastructure clusterfuzz has found more than bugs ingoogle products e.g.
chrome and around bugs in over340 open source projects in september .
even though con siderable progress has made in triggering crashes the subsequentprocedure crash triage remains imprecise time consuming andlabor intensive.accuracy efficiency and generality are the major concerns ofcurrent crash triage techniques.
however there lacks a systematicsolution that can balance the trade o s and achieve accurate fast and fully automated crash triage.
for the past decade al though there has been a wealth of research into crash triage including crash deduplication and faultlocalization the efficacy of thoseapproaches signi f icantly varies based on di erent vulnerabilitytypes crash reports and running environment making them lessapplicable to general programs.
in particular a line of prior crashdeduplication approaches work at the granularity of function calllevel and fail to bucket crashes by inspecting the crashes actualroot cause which could cause critical vulnerabilities triggeredbut missed.
the other research aims to deduplicate crashes byexamining the root cause of crashes or representing root causewith the constraints on crashing paths which takes signi f icant timewhen the number of processed crashes increases.
regarding faultlocalization given that prior statistical approaches fail to capturesequence information of root cause basic blocks the accuracyof identi f ication is seriously a ected.
more importantly thoseapproaches only output suspicious scores for a set of basic blocks for example top basic blocks.
in practice this does not givesufficient guidance for analysts as they still have a set of basiccandidate blocks to examine.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
inthis paper we present an end to end crash triage solutioncalledd e.scf a.sc u.sc for rapidly de duplicating massive traces of crashesand accurately pinpointing the root cause for unique crashes.
weborrow the concept of mutual information in information theoryand treat crash triage as an information mining process.
thekey insight is that mutual information of program entities e.g.
functions and basic blocks is a measurement of their relevance tothe crash.
we leverage such crash relevance as the criteriato bucket unique crashes in crash deduplication to identifyand f ilter out irrelevant program entities for shortening traces inour neural network based fault localization.
without inspectingeach crash s root cause our approach allows crash deduplicationaccomplished within a short time without missing bugs.
in thesubsequent fault localization procedure the mutual informationabout crash relevance is used again to f ilter program entities thatare irrelevant to the crash which shortens the long execution tracesand thus facilitates the feeding of inputs to the neural network.on such a basis in the last step we utilize the interpretability ofneural networks to extract the actual root cause from the shortenedtraces.
with the ability to capture sequence information the neuralnetwork signi f icantly improves root cause identi f ication accuracycompared with the traditional approaches.we implemented a full featured prototype ofd e.scf a.sc u.sc andevaluated it with programs including cgc programs and12 real world programs.
on the one hand for crash de duplication d e.scf a.sc u.sc processed crashing traces at a speed of .
secondsper trace.
it identi f ied unique crashing traces without missingany bugs.
regarding fault localization it reports no false negativesand low false positive rate of .
which is way beyond what thestate of the art tools can achieve.contributions.the contributions of this paper are summarizedas follows.
new techniques.we propose a new approach to measurethe crash relevance of program entities based on mutualinformation which is critical for crash deduplication andfault localization.
with such an approach we design andpresent a novel end to end analysis system d e.scf a.sc u.sc thatdirectly takes crashing execution traces from fuzzers as inputand automatically pinpoints the root cause of program faults.
evaluation.we evaluatedd e.scf a.sc u.sc on programs includ ing cgc programs and real world programs.
the resultsdemonstrate thatd e.scf a.sc u.sc is both efficient and accurate.
thetool publicly available for continuous research1.roadmap.the rest of this paper is organized as follows section 2surveys the related research.
section provides the necessarybackground covering mutual information and the attention mech anism of interpretability of neural networks.
section describesthe detailed design ofd e.scf a.sc u.sc .
section presents the evaluationresults and the comparison with existing techniques.
section 7concludes this paper.1d e.scf a.sc u.sc is available at related workin this section we review the related work on crash deduplicationand fault localization for software testing.
the limitations of theexisting approaches are also summarized.
.
crash deduplicationcrash deduplication aims to cluster crashes produced by fuzzersand select a unique crash or a representative crash from eachclustered group of crashes that share the same root cause.
thesubsequent fault localization is performed on such unique crashes.with more crashes produced by fuzzing infrastructures crashdeduplication has become an urgent demand easing the burden ofsubsequent fault localization.
however existing approaches are farfrom accurate and practical as they are either coarse grained ormake certain assumptions.
below we describe the related work.call stack based deduplication.the widely used call stack based approaches measure the similarity among function callsequences function arguments or call graphs of the functions on call stacks.
in general such approaches arecoarse grained.
if a program with different vulnerabilities crashedin the same function call stack based deduplication would missunique crashes.constraint based deduplication.as the typical representative pham et al.
and podelski et al.
collect constraints on thefailing paths and passing paths and deduce their longest commonpre f ix which is further used to characterize the semantics of thefailure.
deduplication is conducted based on the unique symbolicsemantics.
however hindered by the drawbacks of symbolicexecution techniques e.g.
control f low dependence andunsolvable constraints such approaches are less scalable formassive crashes of real world programs.patching based deduplication.patching based deduplication f irst automatically f ixes speci f ic vulnerabilities e.g.
buffer over f low and null pointer dereference at crashing pointand then observes whether un f ixed crashes can be reproduced.the crashes that cannot be reproduced are clustered into the samegroup.
this approach relies on source code analysis and speci f icvulnerability types not to mention the side effect of programtransformation.
therefore it is less applicable to binary programswith unknown vulnerability types.report based deduplication.report based deduplication lever ages information retrieval techniques to analyze text informationof crash reports.
for examples wang et al.
leverage topicmodels sca e et al.
use neural networks and ye et al.
utilize sort algorithms to extract crash related information like callsequences and the history of vulnerability patching.
kim et al.
use machine learning techniques to predict the root cause for thepurpose of differentiating various crashes.
however report basedapproaches are too coarse which are typically performed upon thefunction level.
apart from that the effectiveness depends on howthe os or the debugger writes the record which may not providesufficient crash related information.636authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
fault localizationautomatic fault localization techniques leverage the statistics oftarget programs at runtime to locate program faults.
the relatedwork can be categorized as follows program spectrum based approaches.program spectrum suchas the statistics of program paths executions is a measurementof program running status.
collefello et al.
for the f irst timeleveraged program spectrum for fault localization.
by comparingthe statistics of program entities about normal exit and crash asuspicious score is given to each program entity.
generally the moreexecution time a program entity has in crash samples than normalexit samples the higher score the program entity gets.
the scores ofprogram entities can be calculated and ranked according to variousapproaches .
however allexisting approaches only consider whether a program entity existsin samples but neglect the execution times of the entities in a certainsample and the sequence of their executions.
as demonstrated insection without such sequence information program spectrum based fault localization would inevitably introduce imprecision.machine learning based approaches.machine learning basedapproaches treat program entities as input andleverage the classi f ication systems to output the probability of rootcause for each program entity.
for instance liu et al.
representthe execution f low of a program as a graph.
also they use graphmining approaches to extract sub graphs about program faults anduse svms to identify each sub graph s contributions to the crash.similarly nessa et al.
use n gram to calculate the conditionalprobability of program entities in execution traces to the crash.however similar to program spectrum based approaches thosestudies do not recover sequence information for root cause basicblocks.program slicing based approaches.program slicing techniques including static slicing and dynamic slicing are to compute aset of program statements that may affect the values at somepoint of interest.
in particular dynamic slicing is often used infault localization by analyzing program execution traces.
agrawalet al.
leverage dynamic slicing to locate program faults bycalculating the slices intersection.
wang et al.
use dynamicslicing to pinpoint program faults by analyzing data dependenceamong program entities.
zhang et al.
use dynamic slicingto extract the change of variables related to the crash to locate rootcauses.
moreover xu et al.
use backward program slicing tolocate program faults with the support of intel pt.
however due tothe control f low dependence problem a fundamental drawbackof data f low analysis the effectiveness of those approaches is notsatisfactory.
.
limitations of prior researchthough much effort has been put into the research of crash triage the existing approaches still have multiple critical limitations assummarized below.
generality.the effectiveness of crash triage techniquessigni f icantly varies with different vulnerability types crashreports and running environment making them less appli cable to general programs.
accuracy.prior crash deduplication approaches work atthe granularity of function call level and fail to bucketcrashes by inspecting the actual root cause of the crashes which may cause imprecision and miss bugs.
on the otherhand existing fault localization approaches do not considersequence information which introduces imprecision again.
time consumption.to bucket the crashes existing ap proaches examine each crash regardless of the granularity.after that a pair wise match among all crashes is unavoid able which takes signi f icant time with the number of crashesincreasing.
preliminariesthis section provides some necessary backgrounds of mutualinformation and introduces the attention mechanism of neuralnetworks.
.
mutual informationin information theory mutual information is a measure of themutual dependence between two random variables.
it can beregarded as the amount of information that one random variablecontains about the other random variable.
mutual information isan important criterion for feature selection in machine learning.the more information a feature brings to the classi f ication system the larger the value of its mutual information is.
namely such afeature is more relevant to the classi f ication.
inspired by the fact we leverage the mutual information to measure the contribution ofbasic blocks to crashes.
we use the mutual information not only incrash de duplication but also in the initial step of fault localizationby f iltering out the vast majority of program entities e.g.
functionsand basic blocks that are irrelevant to the crash.mutual information.we represent a crashing trace at basic blocklevel as a list of tuples b y1 b y1 y2 b y2 ... yt b yt whereyis the starting address of a basic block b y is itsoccurrence in traceb.
the output of a fuzzer forms a datasetd b y wherebis a set of crashing traces b1 b2 .
.
.
bt andy x1 x2 .
.
.
xt is a set of labels denoting whether a tracecorresponds a crash or a normal exit.for a given datasetu the mutual information of a basic blockyto labelxis given by m f u f u f u u f whereo x is the entropy of labelxando x y is the conditionalentropy of basic blockygiven labelx.
more speci f ically we denoteaoas the amount of non crashing traces in datasetuanda u1d453asthe amount of crashing traces in datasetu whereb a u1d453 ao .then the entropy of labelxis u u1d441 u1d45d u1d441 u1d459 u1d45c u1d454 u1d441 u1d45d u1d441 u1d441 u1d453 u1d441 u1d459 u1d45c u1d454 u1d441 u1d453 u1d441 using u1d45a u1d44e u1d465 b y to denote the max ofb y for basic blockyinallbthat belong tou we have the conditional entropyo x y u f u1d45a u1d44e u1d465 u1d45b u1d44f summationdisplay.
u1d456 0o f u1d45b u1d44f u1d456 u f u1d45b u1d44f u1d456 where u1d45d y u1d45b u1d44f u1d456 u1d456 f u1d441.637authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
additionally the conditional entropy ofxtoy u1d45b u1d44f u1d456is o x y u1d45b u1d44f u1d456 u1d450o u1d456 y u1d450 u1d456 y u1d45c.
u1d450o u1d456 y u1d450 u1d456 y u1d450 u1d453 u1d456 y u1d450 u1d456 y u1d45c.
u1d450 u1d453 u1d456 y u1d450 u1d456 y in the above formula u1d450 u1d456 y is the amount ofbinuwhenb y u1d456 u1d450o u1d456 y is the amount ofbinuwhenx andb y u1d456 and u1d450 u1d453 u1d456 y is the amount ofbinuwhenx andb y u1d456.
combiningequation and equation we can obtain the conditional entropyo x y and the mutual information u1d43c x y u f u1d45a u1d44e u1d465 u1d45b u1d44f summationdisplay.
u1d456 u1d456 f u1d441 u1d45d u1d456 f u1d456 f u1d459 u1d45c u1d454 u1d45d u1d456 f u1d456 f u1d45d u1d456 f u1d456 f u1d459 u1d45c u1d454 u1d45d u1d456 f u1d456 f m f u u1d45a u1d44e u1d465 u1d45b u1d44f summationdisplay.
u1d456 u1d456 f u1d441 u1d45d u1d456 f u1d456 f u1d459 u1d45c u1d454 u1d45d u1d456 f u1d456 f u1d45d u1d456 f u1d456 f u1d459 u1d45c u1d454 u1d45d u1d456 f u1d456 f the mutual information u1d43c x y quanti f ies the amount of infor mation obtained about a crash through observing the presenceof basic blocky.
in plain english it represents the contribution ofbasic blockyto the crash.mutual information with threshold.as can be seen from equa tion the amount of crash relevance is related to u1d45a u1d44e u1d465 b y and the statistics ofysuch as u1d450 u1d456 y and u1d450o u1d456 y .
its value can varyaccording to different u1d45a u1d44e u1d465 b y .
to fairly compare the amount ofinformation for the basic blocks with different occurrence in the ex ecution traces we use a threshold that is automatically determinedand turn the problem into a binary classi f ication problem i.e.
occurrence is smaller than or larger than a threshold assumewe have a threshold variable u1d461 uni210e u1d451whose value is a non negativeinteger with u1d461 uni210e u1d451 u1d45a u1d44e u1d465 b y .
given the threshold variable o x y can be the addition ofo x y u1d45b u1d44f u1d461 uni210e u1d451 ando x y u1d45b u1d44f u1d461 uni210e u1d451 where o x y u1d45b u1d44f u1d461 uni210e u1d451 summationtext.
.
uni210e u1d451 u1d456 u1d450o u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y u1d45c.
summationtext.
.
uni210e u1d451 u1d456 u1d450o u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d453 u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y u1d45c.
summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d453 u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y o x y u1d45b u1d44f u1d461 uni210e u1d451 summationtext.
u1d45a u1d44e u1d465 t f u1d456 .
uni210e u1d451 u1d450o u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y u1d45c.
summationtext.
u1d45a u1d44e u1d465 t f u1d456 .
uni210e u1d451 u1d450o u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y summationtext.
u1d45a u1d44e u1d465 t f u1d456 .
uni210e u1d451 u1d450 u1d453 u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y u1d45c.
summationtext.
u1d45a u1d44e u1d465 t f u1d456 .
uni210e u1d451 u1d450 u1d453 u1d456 y summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y combining equation equation equation and equation we have u1d43c x y u1d461 uni210e u1d451 o x summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y ao x y u1d45b u1d44f u1d461 uni210e u1d451 summationtext.
u1d45a u1d44e u1d465 t f u1d456 .
uni210e u1d451 u1d450 u1d456 y ao x y u1d45b u1d44f u1d461 uni210e u1d451 by iterating through u1d45a u1d44e u1d465 b y we can determine the u1d461 uni210e u1d451that maximizes u1d43c x y u1d461 uni210e u1d451 u1d44e u1d45f.
u1d45a u1d44e u1d465.
uni210e u1d451 u1d45a u1d44e u1d465 t f u1d43c x y u1d461 uni210e u1d451 in the execution trace when the occurrence of a basic blockyis larger than u1d461 uni210e u1d451 the basic block has close relevance to labelx.
inequation u1d43c x y u1d461 uni210e u1d451 represents the degree of crash relevance .filtering of basic blocks withx .a criterion basic block isa basic block that is closely related to the crash i.e.
whenx and has high value of mutual information.
such a criterion basicblock or a set of criterion basic blocks is used as the criterion inthe subsequent crash grouping procedure.
from the above analysis we know that u1d43c x y u1d461 uni210e u1d451 represents the contribution of basic blockyto labelx.h o w e v e r t h i sr e p resentation does not differentiatewhether the contribution is related to normal program exit i.e.
whenx or program crash i.e.
whenx .
namely using thebasic blocks whose u1d43c x y u1d461 uni210e u1d451 is large and related tox wouldcause false negatives in crash deduplication.
when the occurrenceofyis larger than the threshold i.e.
b y u1d461 uni210e u1d451 and the numberof normal exit samples is larger than the number of crashingsamples it indicates that with such a basic block the program isprone to exit normally.
therefore we need to f ilter out the basicblocks that have a large u1d43c x y u1d461 uni210e u1d451 and are closely related to normalprogram exit and select criterion basic blocks from the rest.
thedetailed algorithm of f iltering of basic blocks withx is shown inalgorithm .algorithm 1filtering of basic blocks withx 0require f input basic block .
uni210e u1d451 threshold off u1d45a u1d44e u1d465 t f the maximum occurrence offin the dataset u1d45d u1d456 f the amount of normal exit samples when occurrence offis u1d456 u1d453 u1d456 f the amount of crashing samples when occurrence offis u1d456 u1d441 u1d45d the amount of normal exit samples in the dataset u1d441 u1d453 the amount of crashing samples in the datasetensure whether to considerfas a criterion basic block1 if summationtext.
u1d45a u1d44e u1d465 u1d45b u1d44f u1d456 u1d461 uni210e u1d451 u1d450 u1d45d u1d456 u1d44f u1d441 u1d45d summationtext.
u1d45a u1d44e u1d465 u1d45b u1d44f u1d456 u1d461 uni210e u1d451 u1d450 u1d453 u1d456 u1d44f u1d441 u1d453then2 returnfalse3 else4 returntrue5 end if3.
attention mechanism of neural networksthe attention mechanism was initially proposed to improve the f itting of neural networks by assigning different weights to the inputsequence and minimizing the loss function .
in recent years aline of research leveraged the attention mechanismfor the interpretability of neural networks allowing us to inspectthe internal working of neural networks directly.
the hypothesis isthat the magnitude of attention weights positively correlates withhow relevant a speci f ic input region is for predicting output at eachposition in a sequence.
it can be easily accomplished by visualizingthe attention weights for a set of input and output pairs.
in thispaper we borrow this idea and leverage the attention mechanismto identify the root cause of program crash by weighing each inputbasic block s contribution to the crash.638authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
as discussed the idea of attention mechanism is straightforward.for an input vector vec u1d4651 vec u1d4652 .
.
.
vec u1d465t suppose we have vec u1d463 u1d6fc1 vec u1d4651 u1d6fc2 vec u1d4652 ... u1d6fct vec u1d465t u1d44eb u1d451 x u1d453 vec u1d463 u1d464 uni210e u1d452 u1d45f u1d452 summationdisplay.
u1d456 u1d6fc u1d456 u1d6fc u1d456 .
to functionx u1d453 vec u1d465 u1d6fc u1d456can be regarded as the contribution thatinput byte u1d465 u1d456makes tox where u1d6fc1 u1d6fc2 .
.
.
u1d6fct is also known asa weighted vector.
such a functionx u1d453 vec u1d465 is often utilized todetermine the in f luence of input bytes to the output in seq2seqnetworks.
the transition equation is as follows vec u1d6fc .
vec u1d465 vec u1d703 vec u1d463 u1d6fc1 vec u1d4651 u1d6fc2 vec u1d4652 ... u1d6fct vec u1d465t x u1d453 vec u1d463 vec u1d703 u1d464 uni210e u1d452 u1d45f u1d452 summationdisplay.
u1d456 u1d6fc u1d456 u1d6fc u1d456 vec u1d703is the parameter to be determined in the training process.
function.
vec u1d465 vec u1d703 is used to calculate the weight vector which is also knownas similarity function.
in the dataset vec u1d465 u1d456is the u1d456th sample and vecx u1d456isthe corresponding label.
the loss function with mean square erroris u1d43f u1d453 vec u1d465 vec u1d703 summationdisplay.
u1d456 u1d453 .
vec u1d465 u1d456 vec u1d703 vec u1d465 u1d456 vec u1d703 x u1d456 u1d460.
u1d461.
summationdisplay.
.
vec u1d465 u1d456 u1d703 however when using the gradient descent method to minimizeloss u1d43f u1d453 vec u1d465 vec u1d703 it is difficult to satisfy the constraint summationtext.
.
vec u1d465 u1d456 u1d703 1and get vec u1d703.
therefore so f tmaxfunction is adopted as the activationfunction of.
vec u1d465 vec u1d703 in the design of networks given that the sumofso f tmaxfunction s output equals to .
the transition equationwithso f tmaxbecomes vec u1d6fc so f tmax .
vec u1d465 vec u1d703 vec u1d463 u1d6fc1 vec u1d4651 u1d6fc2 vec u1d4652 ... u1d6fct vec u1d465t x u1d453 vec u1d463 vec u1d703 so f tmax u1d465 u1d456 u1d452 u1d465 u1d456 summationtext.
u1d457 u1d452 u1d465 u1d457 and the loss function becomes u1d43f vec u1d703 summationdisplay.
u1d456 u1d453 so f tmax .
vec u1d465 u1d456 vec u1d703 vec u1d465 u1d456 vec u1d703 x u1d456 the network that we designed as described in section .
followsthe above transition equation.
in fact equation is the corearchitecture of the attention mechanism and such an architecturecan be used to determine the relevance of the input bytes and theoutput.
in particular under this architecture we are able to getthe vec u1d703by minimizing u1d43f u1d453 vec u1d465 vec u1d703 with the gradient descent.
function.
vec u1d465 vec u1d703 or u1d453 vec u1d465 vec u1d703 could be convolutional neural networks cnn recurrent neural networks rnn or fully connected networks.while in seq2seq networks .
vec u1d465 vec u1d703 is lstm and u1d453 vec u1d465 vec u1d703 is a fullyconnected network.
design ofdefaultthe high level design of our system is illustrated in figure .
theinput is a set of crashing execution traces produced by fuzzers.those traces are fed into the crash deduplication module whichbuckets crashing traces into multiple categories according to theirroot cause and outputs one representative crashing trace with aunique root cause from each category.
then the representativecrashing trace of each category is sent to the f iltering module which consists of two f iltering steps function f iltering and basicblock f iltering.
it f ilters out the vast majority of functions and basicblocks in the trace that are irrelevant to the crash so that the neuralnetwork in the subsequent module can take the shortened tracesas its inputs.
in the end the fault localization module leverages theattention mechanism to identify a set of basic blocks that contributeto the crash.
.
crash deduplicationthere are two steps for crash deduplication f irst we group crashingtraces into multiple groups based on the calculated mutual infor mation of basic blocks then we select a representative crashingtrace from each group.
the root cause of the selected representativecrashes is different from each other2.grouping.assume that the root cause of crashing trace u1d447 u1d434includesbasic blocky u1d434 andy u1d434is not included in crashing trace u1d447 u1d435.
thus we can put those two traces into two groups one group containstraces withy u1d434 and the other contains traces withouty u1d434.
motivatedby that we separate the dataset into two groups group u1d43a u1d434is theset of crashing traces with basic block y the other group u1d43a u1d435theset of crashing traces without basic block y. the basic block yhasthe highest u1d43c x y u1d461 uni210e u1d451 in the datasetu which is believed to have asigni f icant contribution to a speci f ic crash.we repeat the above grouping step for group u1d43a u1d435until there isno crashing trace left.
after such a preliminary grouping process most of the crashing traces in a group have the same root cause.since the traces with different basic block statistics could becategorized into different groups such a grouping algorithm givesfalse positives.
nevertheless it gives no false negatives.
for instance assume that basic blocky in trace u1d447 u1d436and basic blocky u1d451in trace u1d447 u1d437are relevant to the same root cause namely trace u1d447 u1d436and trace u1d447 u1d437share the same root cause buty andy u1d451have different occurrences.this happens when the root cause leads to different crashing pointsin the program.
as a result our algorithm would put trace u1d447 u1d436andtrace u1d447 u1d437into two different groups.
fortunately although moregroups are produced than the ground truth the over categorizationwould not miss any root cause of the crashing traces produced byfuzzers.
we show the complete grouping algorithm in algorithm .selecting representative crashing traces.within a group whena crashing trace contains a criterion basic block yand another basicblocky1which is the root cause of another unique crash thiscrashing trace cannot represent this group.
it would lead to falsepositives and false negatives in subsequent steps.
therefore torepresent this group we need to select a crashing trace whose root cause basic blocks only include a criterion basic block y without2our approach does not guarantee that the crash de duplication module gives uniquecrashes.
we only found that there are no false negatives in the evaluation.639authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
udvk h xsolfdwlrq0rgxoh udvk udvk udvk8qltxh udvk 8qltxh udvk5hsuhvhqwdwlyh udvklqj 7udfh lowhulqj 0rgxoh udvk 8qltxh udvk 1hxudo 1hwzrun0rgxoh6kruwhqhg udvklqj 7udfh5rrw dxvh x lqj qiudvwuxfwxuh figure overall design ofd e.scf a.sc u.sc .algorithm 2mutual information based groupingrequire b u1d453 set of crashing tracesb b u1d45d set of non crashing tracesbensure cc set of grouped crashing traces criterion set of criterionbasic block of each group1 cc criterion d b u1d453 b u1d45d calculate mutual information for each basic block ind5 selectfthat is related to and has the largest mutual informationvalue6 if summationtext.1 u1d461 uni210e u1d451 u1d456 u1d453 u1d456 f 0then7 cc.
u1d44eoo u1d452t u1d451 u1d435 u1d453 criterion.
u1d44eoo u1d452t u1d451 f returncc criterion10 else11 t u1d452 u1d464b u1d453 b b b u1d453 f b t f .
uni210e u1d451 cc.
u1d44eoo u1d452t u1d451 b u1d453 criterion.
u1d44eoo u1d452t u1d451 f b u1d453 b b uni2209t u1d452 u1d464b u1d453 b b u1d453 goto line end ifthe basic blocks of other unique crashes.
to this aim we rank thecrashing traces within a group according to the occurrence of allcriterion basic blocks.
a crashing trace obtains higher score if it hasmore occurrences of criteria basic blocks.
in the end we select thecrashing trace with the least score to represent its group meaningthat the crashing trace is more pure .
the algorithm is describedin algorithm .
.
filteringonce the representative crashing trace is selected the f ilteringmodule shown in figure performs preliminary f iltering to f ilterout functions and basic blocks irrelevant to the crash.
it can vastlyshorten the length of crashing traces and facilitate the neuralnetwork module to process the shortened traces.constructing datasets.to cover more basic blocks and compre hensively assess how the executions of different basic blocks affecta crash we construct a dataset that is bred from a unique crashingtrace.
we use a f l fuzz to mutate a single crashing input and breedalgorithm 3selection of representative crashing tracerequire cc groups of crashing traces criterion the set of criterionbasic blocksensure unique the set of crashing traces after selection1 unique u1d446 u1d45c u1d45f u1d452 score dictionary3 for u1d435 ccdo4 forf u1d435do5 for.
criteriondo6 if.
f t .
.
uni210e u1d451then7 u1d446 u1d45c u1d45f u1d452 u1d446 u1d45c u1d45f u1d452 end if9 end for10 end for11 f u1d45a u1d456t u1d446 u1d45c u1d45f u1d452 unique.
u1d44eoo u1d452t u1d451 f end for14 returnuniqueinputs that explore different basic blocks.
the output of a f l fuzzcan be categorized into crashing inputs and non crashing inputs.note that in extreme cases for example when a f l fuzz triggers newcrashes the follow up procedures would not be affected.
the non crashing inputs are obtained by randomly mutating the crashinginputs.
in this way a large portion of the basic blocks in crashingtraces would also appear in the non crashing trace and those basicblocks are not related to the crash.
consequently in the dataset thestatistics of those overlapped basic blocks are signi f icantly differentfrom the statistics of the crash related basic blocks.
it helps toform a dataset with differentiable and adequate samples.
note thatthis dataset also serves for the training of the neural network insection .
.filtering out irrelevant functions.in the program there existsome low level functions like data copy functions operationfunctions of linked lists and constructors destructors of structsor objects.
when those functions are invoked near the root cause the mutual information of those functions basic blocks would bevery close to the mutual information of the actual root cause whichbrings false positives to the results.
therefore we calculate mutual640authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ixqf ixqf ixqf ixqfq ixqf rffxu 7udfh dw ixqfwlrq ohyho dehov dofxodwlrq ri0xwxdo qir 7udfh dw edvlf eorfn ohyhoee ee ee eeq e e rffxu dehov dofxodwlrq ri0xwxdo qir 5hvwruh 7udfh rup 5hvwruh 7udfh rup6kruwhqhg h hfxwlrq wudfhfigure illustration of f iltering.information at the function level to f ilter out the irrelevant functionsto the actual root cause.the dataset is composed of execution traces at function levelwith their corresponding labels d f y .
in the dataset u1d439 u1d456is the u1d456th trace offwhere u1d439 u1d4531 u1d4532 .
.
.
u1d453 u1d441 u1d453 is a sequence offunctions in that trace andx u1d456represents whether the executiontrace corresponds to a crash.
we calculate the mutual informationof function u1d453 u1d456to labelx to represent u1d453 u1d456 s contribution to labelx u1d43c x u1d453 u1d457 u1d461 uni210e u1d451 o x summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 u1d453 u1d457 ao x u1d453 u1d457 u1d45b u1d453 u1d457 u1d461 uni210e u1d451 summationtext.
u1d45a u1d44e u1d465 t u1d453 u1d457 u1d456 .
uni210e u1d451 u1d450 u1d456 u1d453 u1d457 ao x u1d453 u1d457 t u1d453 u1d457 .
uni210e u1d451 whereais the amount of samples in the dataset o u1d44c is theentropy of labelx u1d450 u1d456 u1d453 u1d457 is the amount of samples where u1d453 u1d457 soccurrence is u1d456 o x u1d465 is the conditional entropy and u1d461 uni210e u1d451is u1d461 uni210e u1d451 u1d44e u1d45f.
u1d45a u1d44e u1d465.
uni210e u1d451 u1d45a u1d44e u1d465 t u1d453 u1d457 u1d43c x u1d453 u1d457 u1d461 uni210e u1d451 after f iltering function u1d453 u1d456 s contribution to labelxcan beregarded as u1d45f m u1d453 u1d456 .
uni210e u1d451 u with u1d45f where u1d43c x u1d453 u1d457 u1d461 uni210e u1d451 is the mutual information ando x is the entropy of labelx.
when u1d45f we can infer that an execution trace is a crashing trace byobserving that u1d453 u1d456appears in the trace.
similarly when u1d45fapproaches0 the non existence of u1d453 u1d456has little impact on whether an executiontrace is a crashing trace or not.
therefore we f ilter out the functionswhose u1d45fis smaller than .53and obtain the traces with selected3the f iltering threshold u1d45fis empirically set to .
.
we found that the following modulesproduced satisfactory results with this value.functions u1d439 u1d460 u1d453 u1d453 u1d439 u1d43c x u1d453 u1d461 uni210e u1d451 o x .
filtering out irrelevant basic blocks.after the f iltering ofirrelevant functions the next step is to f ilter out irrelevant basicblocks.
we denote the dataset asd b y wherebis theamount of samples b b1 b2 .
.
.
bt is a set of execution tracesat basic block level andy x1 x2 .
.
.
xt is the set of labels forthe execution traces.
after the f iltering of irrelevant functions in thedataset the f iltered execution trace becomes u1d435 u1d45f y u1d45f1 y u1d45f2 .
.
.
y u1d45f u1d45b wherey u1d45f u1d456is a basic block.
by calculating the mutual information ofy u1d45f u1d457to labelx we can select the set of basic blocks that contributemore to the crash.
the mutual information of basic blocky u1d45f u1d457tolabelxis given by u1d43c x y u1d45f u1d457 u1d461 uni210e u1d451 o x summationtext.
.
uni210e u1d451 u1d456 u1d450 u1d456 y u1d45f u1d457 ao x y u1d45f u1d457 u1d45b u1d44f u1d45f u1d457 u1d461 uni210e u1d451 summationtext.
u1d45a u1d44e u1d465 t f u1d45f u1d457 u1d456 .
uni210e u1d451 u1d450 u1d456 y u1d45f u1d457 ao x y u1d45f u1d457 t f u1d45f u1d457 .
uni210e u1d451 where u1d461 uni210e u1d451is u1d461 uni210e u1d451 u1d44e u1d45f.
u1d45a u1d44e u1d465.
uni210e u1d451 u1d45a u1d44e u1d465 t f u1d45f u1d457 u1d43c x y u1d45f u1d457 u1d461 uni210e u1d451 we then f ilter out the basic block that are closely related tolabelx .
similar to function f iltering we calculate the ratio u1d45f m f u1d45f u1d457 .
uni210e u1d451 u and f ilter out basic block whose u1d45fis less than0.
.
the u1d45fvalue is set higher than the u1d45fof function f iltering becausethe selection on basic blocks is more f ine grained.
in the end weobtain the trace with selected basic blocks u1d435 u1d463 y u1d4631 y u1d4632 .
.
.
y u1d463 u1d441 u1d463 where y u1d463 y y u1d435 u1d45f u1d43c x y u1d45f u1d457 u1d461 uni210e u1d451 o u1d44c .
.
fault localizationafter f iltering irrelevant functions and basic blocks the size oftraces has been largely reduced which becomes suitable to feedneural networks.
in the fault localization module we leverage theneural network to identify the root cause s basic blocks.
the basicblocks in the short traces have a high value of mutual informationto labelx .
however so far they still cannot be regarded as theroot cause because some basic blocks that are not the root causebut near the root cause also get high mutual information values.the fundamental cause is that basic blocks statistical informationdoes not contain sequence information in its execution trace.
withall existing approaches fail to recover the sequence information inexecution traces especially when handling the dependence in longsequences we leverage lstm with the attention mechanism tomodel and capture the sequence information about the root cause.more speci f ically we have the datasetd b u1d463 y whereb u1d463isthe set of execution traces composed of sequences of selected basicblocks andyis the set of corresponding labels.
this module utilizesthe neural network to calculate the relevance score of each basicblock to the crash.
the root cause is the basic blocks that contributeto the crash which is indicated by the relevance score i.e.
the641authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
higher relevance score of a basic block indicates more contributionto the crash .input and output of neural network.the data used for trainingthe network are the shortened basic blocks.
the positive samplesare the shortened crashing traces and negative samples are theshortened non crashing traces.
we use one hot vectors to encodethe input denoting the number of basic blocky u1d463 u1d456in trace u1d435 u1d463asbf.then basic blocky u1d463 u1d456 u1d435 u1d463is represented as vec u1d465 u1d456with vec u1d465 u1d456 t u1d44fand summationtext.1t u1d44f u1d457 u1d465 u1d456 u1d457 .
the input is vec u1d44b vec u1d4651 vec u1d4652 .
.
.
vec u1d465t .
since thelength of the input varies we choose the longest u1d435 u1d463as the inputlength and pad the short inputs with zero vectors whose magnitudeisbf.
every basic block is independent with each other in the input.the sequence information about root cause among basic blocksneeds to be recovered through weight assignment of the neuralnetwork.
the output of neural network is the boolean value thatrepresents whether a crash is triggered or not.
besides we usethe up sampling to balance the negative samples and positivesamples in the dataset.network structure.the network structure is the classic lstmnetwork with attention mechanism.
after one hot encoding wesend execution trace u1d435 u1d463to the lstm network the output of thelstm network is u1d45c u1d43f u1d446 u1d447 u1d440 u1d456 u1d453 u1d43f u1d446 u1d447 u1d440 vec u1d465 u1d456 u1d45c u1d43f u1d446 u1d447 u1d440 u1d456 .
in the output of thelstm network the u1d456th element is related to all the previous u1d456 1elements.
we then send vec u1d45c u1d43f u1d446 u1d447 u1d440to the u1d460 u1d45c u1d453 u1d461 u1d45a u1d44e u1d465layer and get u1d6fc u1d456 u1d452 u1d45c u1d43f u1d446 u1d447 u1d440 u1d456 summationtext.1t u1d457 u1d452 u1d45c u1d43f u1d446 u1d447 u1d440 u1d457 in the end we multiply vectors vec u1d6fcand vec u1d44bin the fully connectedlayers and get the f inal output u1d45c u1d462 u1d461 u1d45d u1d462 u1d461 u1d453 u1d451 u1d452t u1d460 u1d452 vec u1d463 vec u1d463 u1d6fc1 vec u1d4651 u1d6fc2 vec u1d4652 ... u1d6fct vec u1d465t in the u1d460 u1d45c u1d453 u1d461 u1d45a u1d44e u1d465layer we have summationtext.
u1d456 u1d6fc u1d456 and u1d6fc u1d456 .
also theoutput is of the formx u1d453 u1d6fc1 u1d4651 u1d6fc2 u1d4652 ... u1d6fct u1d465t .
thus vec u1d6fcis the relevance score vector i.e.
the weight vector and u1d6fc u1d465 u1d456represents the contribution of u1d465 u1d456to the outputx.calculation of relevance score.after network training we getthe relevance score vector vec u1d6fc u1d456for positive sample u1d435 u1d463o u1d456in the dataset.the relevance score of basic blocky u1d463 u1d457in u1d435 u1d463o u1d456is u1d45f u1d457 summationtext.
u1d456 u1d6fc u1d456 u1d463 u1d457.
for allthe basic blocks in the positive samples we need to categorize theminto two groups one group includes basic blocks that are believedto be the root cause the other group includes the rest of the basicblocks.
the criterion for categorization is that in each group thevariance of relevance scores of basic blocks is the smallest.
thedetailed algorithm is described in algorithm .
evaluationwe implemented a full featured prototype ofd e.scf a.sc u.sc .
to evaluateits efficacy and performance we conducted comprehensive real world experiments.
in this section we present and discuss thecorresponding experiment results.algorithm 4selection of root cause basic blocksrequire u1d45f u1d457 relevance score of basic blockf u1d463 u1d457t amount of basic blocks u1d707 varianceensure u1d460 u1d45c u1d45f u1d452 threshold of relevance score1 u1d460 u1d45c u1d45f.
vec u1d45f u1d45a u1d456t u1d707 u1d45f0 u1d707 u1d45f1 .
.
u1d45f u1d45b u1d460 u1d45c u1d45f u1d452 u1d45f04 for u1d456 n do5 .
u1d45ao u1d707 u1d45f0 .
.
u1d45f u1d456 u1d707 u1d45f u1d456 .
.
u1d45f u1d45b if.
u1d45ao u1d45a u1d456tthen7 u1d45a u1d456t .
u1d45ao8 u1d460 u1d45c u1d45f u1d452 u1d45f u1d4579 end if10 end for5.
experimental settingtarget programs and testing environment.we evaluated ourtool with programs including cgc programs and real world programs.
to reasonably choose the programs we selectthe programs that have known crashes4and belong to differentsoftware categories from the cgc program repositories and thecve list without examining the details of crash and programinternals.
the functionalities of the programs include imageprocessing document parsing compilation and audio processing.the experiments run in ubuntu .
with intel i9 7900x 48gbddr4 and rtx 2080ti 11gb vram .
the version of afl is .52b.tensorflow and keras are used for neural network training.triggering crashes.the crashing inputs are produced with a f l fuzz.
with sufficient fuzzing time one week a f l fuzz reproducedcrashes in all cgc programs that weselected.
however wealso selected real world programs and a f l fuzz only reproducedcrashes in of them with some initial seed inputs .
on average each program contains .
faults.
after fuzzing the averageamount of crashes is .
for each program fault.neural network setup.the parameter of the neural network lstm units with attention mechanism.
the mean squareerror is used as the loss function and the adam optimizer is usedwith an initial learning rate .
we stop the training when the f itting rate becomes or when the iteration round reaches .ground truth.to obtain the ground truth we manually inspecteach crashing trace backward from the crashing point to the rootcause and record the crashing point one single basic block andthe root cause multiple basic blocks by debugging and reverseengineering.
speci f ically for crash de duplication we used scriptsto determine whether a crashing input would satisfy the constraints that we manually written after examining the root cause to triggerthe bug.
for fault localization we manually determined the root cause basic blocks after manual inspection.
the root causes of cgcprograms are publicly available.
for the real world buggy software we also refer to the bug report from the cve reference.
if the rootcause of two different crashing traces is equivalent we categorizethem into the same group no matter how diverse are their crashingpoints.4for real world programs the crashes have been f ixed in new versions.642authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a false positive rates in crash deduplication b time cost in crash deduplicationfigure accuracy and performance of crash deduplication.
a false positive rate for fault localization b time for fault localizationfigure accuracy and performance of fault localization.
.
crash deduplication efficacy and accuracycomparison with existing tools.regarding crash deduplication we compared our approach withsemantic crash bucketing scbfor short a f l fuzz s deduplicator and honggfuzz sdeduplicator .
in particular scb achieves crash deduplication byautomatically f ixing bugs which identi f ies crashes belonging to thesame bug.
this approach is relatively accurate but only targets twotypes of bugs namely buffer over f lows and null pointer dereference which is less applicable to general bugs.
a f l fuzz s deduplicator iscommonly used in industry.
it f irst reduces the crashing trace usinga f l tmin and then calculates the hash of the crashing path.
crashbucketing is achieved by comparing the similarity of the hashes.
onthe contrary honggfuzz s deduplicator compares the similarity ofcall stack hashes working at function call level.
in the experiment since a f l tmin s reduction on a single crashing trace introduces timeoverhead we run a f l tmin in parallel with cores.false negatives.as can be seen from table there is no falsenegative given byd e.scf a.sc u.sc .
neither scb nor a f l fuzz s dedupli cator produces any false negatives.
however after investigatinghonggfuzz s deduplication results we still found one case of falsenegative in the softwarelistswf when multiples root causes existin the same function their execution traces are the same at thefunction level.
given that honggfuzz s deduplication categorizescrashes based on the execution traces at the function call level it isunable to identify and differentiate two different kinds of the rootcause that occur in the same function and therefore misses somecrashes that have been triggered by the fuzzer.false positives.we show the false positive rate of all the tools infigure 3a.
overall d e.scf a.sc u.sc outperforms all three tools by givingless false positives on cases.
scb s high false positive rate canbe attribute to its limited support of bugs namely buffer over f lowsand null pointer dereference.
for a f l fuzz s deduplication giventhat a f l tmin s reduction cannot completely remove redundantpaths and one single bug can be triggered from multiple paths a f l fuzz also gives high false positives.
similarly when a bug can betriggered from multiple paths the call stack hashes are also different.therefore honggfuzz s deduplicator also gives false positives.particularly for case and case whered e.scf a.sc u.sc gives falsepositives the crashes are caused by use after free vulnerabilities.the root cause of the vulnerabilities is typically the misuse offree operation while the crashing point could be large variantbased on different runtime memory layouts.
since the use after free vulnerabilities are triggered but do not cause any crashes insome positive samples the basic blocks of root cause also appearin positive samples which leads to low mutual information valuesand causes false positives.
.
crash deduplication performancethe number of crashing trace for each program is on average.processing traces takesd e.scf a.sc u.sc seconds.
with the sameworkload scb a f l fuzz and honggfuzz takes seconds 595seconds and seconds respectively.
the time cost ofd e.scf a.sc u.sc isonly .
.
and of that of scb a f l fuzz and honggfuzz respectively.the comparison ofd e.scf a.sc u.sc and other three tools s time cost isshown in figure 3b.
as can be seen to process execution traces a f l fuzz s deduplicator takes much more time thand e.scf a.sc u.sc .
the mainreason is that a f l fuzz s deduplication is based on the comparisonamong execution traces.
the time cost increases exponentiallyas the amount of the traces grows because each trace needs tobe compared with all other traces.
on the contrary d e.scf a.sc u.sc analyzes the statistics of basic blocks and the computation ofmutual information values only involves some of the basic blocks.the values of mutual information are stored and indexed from hashtables.
as such it takes much less time ford e.scf a.sc u.sc .
.
fault localization efficacy and accuracyassessment of e ectiveness.traditional program spectrum based fault localization relies on the exam curve to assesseffectiveness.
a point u1d465 x in the exam curve represents thesuspicious score of a basic block.
however such measurement643authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table overall resultsidprogramuniquecrashby afl d e.scf a.sc u.sc scb barex barex barexafl fuzz barex barex barexhonggfuzzauroracrash deduplicationfault localizationcrash deduplicationfault localizationtime s groups groundtruthf.p.f.n.time s basicblocks groundtruthf.p.f.n.time s of groupsf.p.f.n.time s basicblocks f.p.f.n.1c f low44120220 barex barex barex467 barex barex barex402 barex barex barex9 barex barex barex420 barex barex barex7 barex barex barex40 02mp3again32922220 barex barex barex387 barex barex barex322 barex barex barex8 barex barex barex210 barex barex barex6 barex barex barex19 03jhead4088110 barex barex barex365 barex barex barex121 barex barex barex12 barex barex barex320 barex barex barex11 barex barex barex31 04listswf157214550 barex barex barex867 barex barex barex32117 barex barex barex33 barex barex barex12112 barex barex barex28 barex barex barex4 05graphicsmagick76019220 barex barex barex687 barex barex barex21243 barex barex barex21 barex barex barex23241 barex barex barex19 barex barex barex21 06jasper47923110 barex barex barex398 barex barex barex16479 barex barex barex15 barex barex barex33478 barex barex barex14 barex barex barex32 07pdftopng xpdf barex barex barex431 barex barex barex213 barex barex barex12 barex barex barex232 barex barex barex11 barex barex barex22 08nasm371325110 barex barex barex981 barex barex barex311 barex barex barex34 barex barex barex420 barex barex barex33 barex barex barex41 09latex2rtf178734220 barex barex barex871 barex barex barex342 barex barex barex15 barex barex barex220 barex barex barex13 barex barex barex20 010mruby88743211 barex barex barex432 barex barex barex231 barex barex barex9 barex barex barex110 barex barex barex8 barex barex barex10 011tiffcp libtiff barex barex barex562 barex barex barex24342 barex barex barex18 barex barex barex15339 barex barex barex15 barex barex barex12 012pdfrescurrent6828431 barex barex barex442 barex barex barex17112 barex barex barex12 barex barex barex27109 barex barex barex9 barex barex barex24 013filesys123113110 barex barex barex872 barex barex barex241231 barex barex barex1 barex barex barex181230 barex barex barex0 barex barex barex17 014street mapservice76223220 barex barex barex365 barex barex barex184 barex barex barex3 barex barex barex122 barex barex barex2 barex barex barex10 015kaprica scriptinterpreter120815660 barex barex barex762 barex barex barex23152 barex barex barex17 barex barex barex12146 barex barex barex11 barex barex barex5 016simple integercalculator108213440 barex barex barex671 barex barex barex20365 barex barex barex9 barex barex barex22361 barex barex barex5 barex barex barex17 017cgcrpc server187622110 barex barex barex812 barex barex barex291 barex barex barex2 barex barex barex30 barex barex barex1 barex barex barex2 018shortest pathtree calculator36516110 barex barex barex231 barex barex barex18365 barex barex barex10 barex barex barex13364 barex barex barex9 barex barex barex12 019solfedge176324220 barex barex barex761 barex barex barex33564 barex barex barex8 barex barex barex6562 barex barex barex6 barex barex barex4 020user manager79813220 barex barex barex541 barex barex barex13798 barex barex barex6 barex barex barex11797 barex barex barex5 barex barex barex10 0does not make sense in practice as analysts would wish a tool tooutput exact results rather than the topbsuspiciousness rank ofthe basic blocks.
for example when the root cause is ranked and10 within the top suspicious basic blocks analyzing the f irst8 basic blocks does not help.
as such in our evaluation we useaccuracy and false positive rate as indicators.
for a given binaryprogram and a crashing input the number of false positives is u1d439 a u1d462 u1d45a u1d442 a u1d462 u1d45a u1d442 u1d434 where u1d442is the set of basic blocksreported byd e.scf a.sc u.sc and u1d434is the set of basic blocks of the rootcause.
the accuracy and the false positive rate are de f ined as u1d453 u1d45d u1d439 u1d434 and u1d453b u1d439 u1d441 u1d462 u1d45a u1d442 respectively.false positives.we compared e.scf a.sc u.sc withaurora a recentwork that is based on analyzing the statistics of execution paths.auroraoutputs top basic blocks as its results of root causeidenti f ication.
on the whole d e.scf a.sc u.sc demonstrates relatively lowfalse positive rates in fault localization the average false positiverate on crash cases is .
.
note that no false negative occursin bothd e.scf a.sc u.sc andaurora.
figure 4a shows the false positiverate on crash cases in detail.
the average number of basic blocksthat are reported as false positives is .
.
the presence of use after free vulnerabilities causes false positives but no crash is triggered.namely in the presence of a use after free vulnerability when thereis no memory operation on the piece of memory that is freed nocrash would be triggered.
the behaviors of the root cause and thatof the crash point are the same which causes false positives on thereported results.
.
fault localization performanceon average the time cost ofd e.scf a.sc u.sc to locate each root cause is37 minutes.
for the mutual information based f iltering the timeconsumption is highly related to the scale of execution trace including the length of execution trace and the amount of differentbasic blocks.
a longer execution trace with a large amount ofdifferent basic blocks takes more time to process.
for the neuralnetwork module the time cost is related to the size of the trainingdataset network input size and the number of parameters.
with644authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the attention mechanism and the high performance gpu trainingtime and localization time are controlled within .
minutes onaverage.
by that time is mostly spent on recording execution traces.figure 4b shows the comparison of time cost ford e.scf a.sc u.sc andaurora.
discussionthe proposed approach locates root cause at control f low leveland relies on the sequence information of execution traces andwhether the dataset contains rich samples.
as such our approachis less effective when execution trace is relatively short and whentriggering the vulnerability depends on data f lows.
fortunately theroot cause of such vulnerabilities can be effectively identi f ied withtaint analysis .
on the other hand d e.scf a.sc u.sc is not applicablewhen triggering the vulnerabilities requires to solve complicatedconstraints on their paths especially for the programs with cryp tographic algorithms or checksum functions.
the branches withcomplicated constraints cannot be easily reached with the fuzzer ssimple mutation strategies.
this results in the fact that the inputs areless explosive which affects the accuracy of the neural network s f itting.
to this end as long as more diverse and adequate positivesamples are provided more paths are explored the network canassign accurate weights to each basic block.
therefore to improvethe f itting accuracy the trade offis to spend time and sufficientlymutate and produce samples to train the network.
conclusionin this paper we have presentedd e.scf a.sc u.sc an end to end solutionfor crash triage of general programs.
the core insight of our solutionis to leverage mutual information of basic blocks to represent crashrelevance .
implementing the insights also involves a set of newalgorithms.
in the evaluation we comparedd e.scf a.sc u.sc with state of the art solutions which demonstrates considerable time efficiencyand accuracy in both crash de duplication and fault localization.
acknowledgementswe thank the anonymous reviewers for their insightful comments.wenrui diao was partially supported by national natural sciencefoundation of china grant no.
and qilu young scholarprogram of shandong university.