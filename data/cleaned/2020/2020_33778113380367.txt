low overhead deadlock prediction yan cai state key laboratory of computer science institute of software chinese academy of sciences beijing china ycai.mail gmail.comruijie meng state key laboratory of computer science institute of software chinese academy of sciences and university of chinese academy of sciences beijing china mengrj ios.ac.cnjens palsberg university of california los angeles usa palsberg cs.ucla.edu abstract multithreaded programs can have deadlocks even after deployment so users may want to run deadlock tools on deployed programs.
however current deadlock predictors such as magiclock and undead have large overheads that make them impractical for enduser deployment and confine their use to development time.
such overhead stems from running an exponential time algorithm on a large execution trace.
in this paper we present the first lowoverhead deadlock predictor called airlock that is fit for both in house testing and deployed programs.
airlock maintains a small predictive lock reachability graph searches the graph for cycles and runs an exponential time algorithm only for each cycle.
this approach lets airlock find the same deadlocks as magiclock and undead but with much less overhead because the number of cycles is small in practice.
our experiments with real world benchmarks show that the average time overhead of airlock is .
which is three orders of magnitude less than that of magiclock and undead.
airlock s low overhead makes it suitable for use with fuzz testers like afl and on the fly after deployment.
ccs concepts software and its engineering deadlocks.
keywords deadlock detection multithreaded programs lock reachability graph acm reference format yan cai ruijie meng and jens palsberg.
.
low overhead deadlock prediction.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction multithreaded programs are error prone due to unexpected thread interleavings that can cause various concurrency bugs.
one such kind of bug is deadlocks that can happen because of incorrect co first author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
among multiple threads.
a deadlock occurrence prevents an execution from making further progress.
a deadlock occurs when a set of threads hold a set of locks and they mutually wait for other locks held by the same set of threads .
in this paper we focus on resource deadlocks only another kind of deadlock is known as communication deadlocks .
like other kinds of concurrency bugs deadlocks are difficult to detect due to non determinism of multithreaded executions.
in particular even if a program has a reachable deadlock the deadlock may occur in just a small number of executions.
however unlike other kinds of concurrency bugs if a deadlock occurs it can be easily detected at run time.
as deadlocks are caused by non determinism of thread interleavings in house testing is unlikely to detect all of them1.
even after a multithreaded program is released deadlocks can still occur.
hence it is still critical to detect deadlocks in released software e.g.
at end users.
in such scenarios low overhead on the fly detectors should be the first choice.
unfortunately to the best of our knowledge existing deadlock detection techniques are not suitable for on the fly detection.
they incur a large time overhead that can be 1000x which prevents them from being applied by end users as the maximum acceptable time overhead there is usually less than .
in detail a predictive tool analyzes an execution trace and predicts whether deadlocks may occur in alternative executions .
as outlined in figure these approaches map an execution trace into a large data structure and apply an exponential time algorithm2to it to detect cycles as deadlocks.
the earliest work is the goodlock algorithm that maps an execution trace into a lock order graph where locks are nodes lock orders are edges and edge weights are thread identifiers and other execution information.
next goodlock searches for cycles in the graph as potential deadlocks.
goodlock adopts the depth first search dfs algorithm on the lock order graph.
during dfs edge weights are frequently checked against those of all edges in the current path to see if they satisfy the deadlock definition.
its searching cost increases exponentially with the increasing number of lock acquisitions.
there have been several works to improve the practical efficiency of goodlock such as multicoresdk and igoodlock .
the two latest works are magiclock and undead .magiclock introduces several 1in theory although model checking based techniques and other synchronization coverage ones can explore all thread interleavings they usually scale poorly to such programs as mysql that have millions of lines of codes .
2given a graph g v e it requires 2eoperations to find all cycles in gin the worst case corresponding to 2ecycles .
ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea yan cai ruijie meng and jens palsberg core of the previous algorithms .
map an execution trace to a large data structure .run an exponential time algorithm on the data structure to find cycles as deadlocks.
core of the airlock .map an execution trace to a set of small data structures and a lock reachability graph .run a polynomial time algorithm on the reachability graph to report either an existence of some cycles a small percentage or an absence of any cycle a large percentage .for the existence case run an exponential time algorithm on a small subset of the reachability graph to find cycles and construct deadlocks for each cycle.
figure the core algorithms of previous detectors and airlock.
strategies to prune locks and edges that cannot participate in any cycles as well as identifying equivalent edges.
undead is a simplified version of igoodlock with some optimizations adopted from magiclock i.e.
discarding equivalent edges that compromise the ability to detect concrete deadlocks .
a difference among them is that undead tries to keep traces in memory so that it can begin detection once an execution terminates whereas the previous ones keep traces in external storage.
nevertheless these works target offline deadlock detection.
they become inefficient when used for on the fly deadlock detection as we show experimentally in section .
in this paper we present a new deadlock detection algorithm called airlock.
it does on the fly predictive deadlock detection with low overhead and it can be applied to both in house testing by developers e.g.
in fuzzing testing and deployed products.
the idea of airlock is to use an on the fly algorithm instead of the offline algorithms in previous works.
the core algorithm of airlock is shown in figure .
it collects an execution trace into a set of small data structures and a predictive lock reachability graph that reflects the relationship of every two locks without any execution information .
next it runs a polynomial time algorithm on the reachability graph to conclude whether the trace has some cycles.
if so it runs an exponential time algorithm on a small subset of its lock reachability graph to find all cycles and constructs all deadlocks.
airlock is based on the following observations about large benchmarks most pairs of locks are acquired in consistent orders and they do not form any cycle and only a few pairs of locks are acquired in reversed orders which may cause deadlocks.
hence it is unnecessary to directly apply a heavy algorithm to a large trace as done by existing works .
instead the strategy of airlock is to identify the existence of cycles and then to detect them.
additionally airlock reduces the reachability graph onthe fly without missing any cycles.
this design makes airlock a low overhead deadlock predictor.
we have implemented airlock on top of the pin framework and evaluated it on a set of seven real world benchmarks.
these benchmarks contain six unique deadlocks that are helpful for evaluating the effectiveness of airlock.
we configured the benchmarkswith inputs that make them run for to seconds to evaluate efficiency.
we also compared airlock with both magiclock andundead.
the experimental results show that all three tools reported the same predictive deadlocks.
however on efficiency airlock only incurred an average of .
time overhead whereas magiclock andundead incurred an average of 31x and 371x time overhead respectively.
to further evaluate the efficiency of airlock we configured it to detect cycles at different frequencies i.e.
every iseconds i on two large scale benchmarks mysql and firefox .
the results show that at any of these frequencies airlock incurred less than time overhead.
the results demonstrate that airlock is an efficient on the fly predictive deadlock detector applicable for both in housing testing and deployed products at end users.
the low overhead of airlock also makes it work well with fuzz testers like afl.
in summary the contributions of this paper include a novel on the fly predictive deadlock detection approach based on the insight that most lock acquisition orders do not form any deadlock which can be concluded by a polynomialtime algorithm the tool airlock that implements the above insight for onthe fly predictive deadlock detection an evaluation of airlock that shows that airlock only incurred on average .
time overhead on large scale programs.
even under frequent deadlock detection per or more seconds it only incurred less than time overhead less than time overhead when the detection period of 5seconds .
motivating example in this section we begin with introducing some notations that we will use throughout the paper and then we walk through an example of how airlock predicts deadlocks.
.
preliminaries a multithreaded program has a set of threads and a set of locks.
during execution a lock lcan be acquired and released by at most one thread tat a time denoted as acq l andrel l respectively.
a thread can acquire additional locks before it releases any acquired locks and the set of all these locks held by a thread tis called a lockset denoted as ls t .
a lock lcan be destroyed denoted as des l and the destroyed lock lcannot be acquired and released again.
to be consistent with previous works we also adopt the concept of the lock dependency in our analysis.
a lock dependency is a triple d t l ls t indicating that during an execution a thread tacquires a lock lwhen it holds a set of locks in ls t .
a trace is a set of dependencies.
notice that our notion of trace is a set rather than a list this is because a set is sufficient for our purposes.
two ordered locks have the following reachability relationship direct reachability andindirect reachability d .
a lock l1directly reaches a lock l2if there is a lock dependency t l2 ls t such that l1 ls t and we say that there is a direct edge from lock l1to lock l2 denoted as l1 l2.
a lock l1indirectly reaches a lock lkif there are a sequence of locks l2 ... lk 1such that li 1299low overhead deadlock prediction icse may seoul republic of korea part i part iiipart iian execution lock acq.
and rel.lock des.deadlocks reachability graphtrace cycles on demanddetect cyclesconstruct deadlocksmaintain reachability reduce reachability figure an overview of airlock.
li for i k and we say there is an indirect edge from lock l1to lock lk denoted as l1dlk.
for example as shown in figure when thread t1calls function f thd open it forms a direct edge thd open .
similarly thread t2forms a direct edge open kern .
both direct edges thd open open kern together form an indirect edge thddkern .
from above definition we see that there can be both direct and indirect edges between two locks a dependency can produce multiple edges and an edge can be represented as a lock dependency and the same edge can be produced by different lock dependencies.
we introduce two edge sets frandtoto describe edges.
given a lock l fr l denotes a set of locks that lock ldirectly or indirectly reaches and to l denotes a set of locks that can directly or indirectly reach lock l. obviously given two locks l1andl2 if l2 fr l1 then we have l1 to l2 .
now we define a predictive lock reachability graph over a set of locks vto be r v e where e l1 l2 v v l2 fr l1 .
obviously ris the transitive closure of the directed graph go v eo where eois the set of all direct edges.
in the above definition of indirect edge if the lock lkalso directly reaches the lock l1 we say that the sequence of edges l1 l2 ... lk lk lk l1 forms a direct cycle .
an indirect cycle is defined similarly except that at least one edge is an indirect edge.
asimple cycle is defined to be a direct or an indirect cycle of two locks.
note in the definition of cycles we only consider the reachability among locks but exclude aspects such as their forming threads and locksets.
this is different from the cycles defined in previous works like .
to restrict our approach to report exactly the same predictive deadlocks as previous works we follow the same definition of deadlocks a sequence of mlock dependencies d0 ... dm where di ti li ls ti for i m forms a deadlock if for0 i m li ls t i mod m and for0 i j m ls ti ls tj .
the definition requires that each thread of the set should hold a set of locks and mutually wait for another lock held by a different thread and at the same time no two threads hold the same lock.
given a direct cycle its corresponding set of deadlocks can be constructed by first replacing each edge with every lock dependency that produces the edge and then check the set of lock dependencies against the deadlock definition.
function f m n acq m acq n rel n rel m deadlocks form a direct edge m n. program thread t1 f thd open thread t2 f open kern des open thread t3 f kern thd thd kern t t t open figure a motivating program adapted from mysql bug id .
.
overview and illustration figure shows an overview of airlock consisting of three parallel on the fly parts to detect deadlocks.
part i builds a reachability graph on lock acquisitions and it also records a trace.
part ii detects cycles from the lock reachability graph and constructs deadlocks from the trace.
and part iii reduces the lock reachability graph when a lock is destroyed and detects cycles involving the destroyed locks.
figure shows a motivating program adapted from a deadlock in mysql2 bug id which is one of our benchmark programs.
it has three threads t1 t2 t3 and three locks thd open kern .
each thread calls function f to acquire two locks and thread t2further calls function des to destroy lock open .
note originally in mysql2 the lock open is not destroyed at the end of thread t2but at the program exit point we made the change to illustrate the correctness of airlock s reduction.
suppose that the three threads are executed in the order shown in the first column of figure .
the corresponding execution trace is a set of three dependencies t1 open thd t2 kern open t3 thd kern .
obviously this example has a deadlock where thread t1holds lock thdand waits for lock open thread t2holds lock open and waits for lock kern and thread t3 holds lock kern and waits for lock thd and no two threads hold the same lock .
figure illustrates the on the fly deadlock detection process of airlock.
the second major column shows the maintained lock reachability graph i.e.
the edge sets frandto which is also depicted.
note in each edge set the elements before and after a slash are locks involved in direct and indirect edges respectively.
for example the value open kern under fr thd indicates two edges one direct edge thd open and one indirect edge thdd kern .
the last column shows edges moved from memory to disk as we will explain below .
assume that airlock is configured to detect deadlocks at the program exit point.
initially after thread t1executes airlock produces one direct edge thd open which is reflected under both sub columns fr thd andto open .
next after thread t2calls function f open kern a new direct edge open kern is formed and is reflected under both sub columns fr open andto kern .
considering this edge and the previous edge i.e.
thd open they produce an indirect edge thd dkern .
so airlock updates the reachability graph to reflect this indirect edge.
next after thread t2destroys lock open airlock first detects cycles involving lock open on the current reachability graph but no one is detected.
it then deletes the lock from the reachbility graph.
however now two particular kinds of locks exist i.e.
a lock thd 1300icse may seoul republic of korea yan cai ruijie meng and jens palsberg execution orderlock reachability graphdepicting graphmoved edges thd fr thd to thd open fr open to open kern fr kern to kern t1 f thd open t2 f open kern t2 des open t3 f kern thd open open kern kern kern kern kern thd thd thd open thd thd thd thd open open kern on exit thd kern thd open thd open kern thd kern thd kern thd open kern figure an illustration of airlock on the motivating program.
that reaches lock open and a lock kern that is reachable from lock open airlock moves these direct edges into an additional storage e.g.
an external storage as depicted indicating that these edges may participate in a cycle that is produced later.
finally after thread t3executes f kern thd a new direct edge kern thdis produced and the reachability graph is updated accordingly.
however no new indirect edge is produced because there are no other locks except the two locks themselves that reach lock kern or can be reached from locks thd.
at the execution exit point airlock detects cycles on the reachability graph resulting in an indirect cycle kern thd thdd kern .
based on this indirect cycle airlock performs a dfs search of the edges that are only from and to lock thdand lock kern including the corresponding moved edges in the column moved edges .
this results in a direct cycle of three locks kern thd thd open open kern .
based on the trace of the execution a predictive deadlock with thread ids and locksets of the cycle is reported.
our approach airlock this section presents the three parts of airlock namely lock reachability graph maintenance cycle detection and deadlocks construction and reachability graph reduction.
.
part i maintain reachability graph part i of airlock tracks lock acquisitions and releases to maintain a lock reachability graph i.e.
to build frandto .
the key here is to ensure that the reachability graph precisely reflects all direct edges and indirect edges.
it requires to not only record the direct edges produced on lock acquisitions but also compute all indirect edges due to the insertion of the direct edges.
we show part i in algorithm .
given a lock acquisition airlock records dependencies in a trace and records direct edges produced by the acquisition.
due to the insertion of the new direct edges airlock propagates reachability of any affected locks.
note the edge sets frandtoconsist of both direct edges and indirect edges.
to distinguish them we introduce two functions colordir m andcolorind m to mark a lock mwhen it is added intofr l orto l indicating that the edge from ltom or from mtol is a direct edge or an indirect edge.
record dependencies.
as outlined in core algorithm in figure airlock arranges a trace into a set of small data structures.
inalgorithm maintain a lock reachability graph 1lsmaps a thread tto its lockset.
2trmaps an edge m lto a sequence of dependencies.
3frandtoare the two edge sets.
4colordir andcolorind two functions that mark each lock with different colors.
5function onacq t l foreach m ls t do tr m l tr m l t ls t m dependency ifcolordir l fr m then fr m fr m colordir l direct edges to l to l colordir m direct edges callpropagatereach m l .
propagate reachability ls t ls t l 13function onrel t l ls t ls t l 15function propagatereach m l update reachability graph dued to the direct edge m l. foreach m to m do fr m fr m transind fr l colorind l foreach l fr l do to l to l transind to m colorind m fr m fr m transind fr l to l to l transind to m detail it indexes a sequence of dependencies by an edge that can be produced by any indexed dependency.
hence in algorithm on a lock acquisition onacq t l airlock records the dependency into the map tr m l line .
our trace is different from previous works that arrange dependencies of a trace to one set or multiple thread specific sets .
record direct edges.
each lock acquisition onacq t l produces a set of direct edges m lform ls t .
all these direct edges are added into the two edge sets fr m andto l line and .
and the lockset of thread tis updated to include lock l which is excluded on the paired release onrel t l .
propagate reachability.
when a new direct edge m lis inserted to frandto the reachability of locks from land to m has to be updated as illustrated in figure .
considering that our reachability graph is a transitive closure of a graph consisting of all direct edges the existing algorithms for maintaining 1301low overhead deadlock prediction icse may seoul republic of korea m m l l new reachability new reachability m to m l fr l figure update reachability given a new direct edge m l. the transitive closure of a dynamic graph can be adapted.
this is implemented in propagatereach m l in algorithm where we introduce a function transind set to copy all of the edges in set as indirect edges.
.
part ii detect cycles and construct deadlocks part ii detects cycles from the lock reachability graph and constructs corresponding deadlocks.
instead of directly applying an exponential time searching algorithm on a large trace as adapted in previous works airlock splits the cycle detection in two phases as outlined in figure step and step .
first it only iterates on the reachability graph once which is enough to identify all simple cycles including both direct cycles and indirect cycles.
this algorithm detect cycles 1c a set to keep all direct cycles.
2indc yclelocks a set to keep locks in indirect simple cycles.
3indc ycledirfr a set to map a lock lto its directly reachable locks such that any lock in the mapped set indirectly reaches lock l. 4function detectcycles foreach lockldo foreach m fr l do ifcolordir m fr l colordir l fr m then a direct simple cycle l m m l c c l m m l .
ifcolordir m fr l colorind l fr m then an indirect simple cycle l m mdl indc ycledirfr l indc ycledirfr l m indc yclelocks indc yclelocks l .
visited l false for each lock l indc yclelocks s a stack structure for dfs foreach lockl indc yclelocks do visited true call dfs l visited false .
16function dfs l ifs lthen a direct cycle of three or more locks c c s s ... s s k s return.
push lintos.
form indc ycledirfr l externalfr l do only traverse a direct edge l m. ifvisited false then visited true call dfs m visited false .
poplfrom s.concludes whether the trace contains cycles.
for any indirect cycle airlock detects the corresponding direct cycles via a dfs algorithm.
it then constructs deadlocks for every direct cycle.
we present its detection algorithm algorithm and then discuss the benefit of such a design.
detect simple cycles.
to detect all simple cycles airlock only needs to traverse the edge set fronce as shown in lines .
given a lock l it traverses all locks in fr l .
for any m fr l if the lock lis also in fr m a direct cycle l m m l or a indirect cycle l m mdl is detected.
for efficiency purpose in the later detection we introduce two data structures indc ycledirfr andindc yclelocks for indirect cycles.
the structureindc ycledirfr l having the same structure as fr keeps all identified direct edges in indirect cycles line the edge l m .
the structure indc yclelocks keeps all locks in indirect cycles like the keys of indc ycledirfr .
m indcycledirfr l l m l m l1ln a an indirect cycle.
b a corresponding direct cycle.
figure an illustration on indirect cycles.
detect corresponding direct cycles.
for an indirect cycle there must exist a direct cycle as illustrated in figure .
given a set of indirect cycles as locks in indc ycledirfr and a set of all locks in all indirect cycles airlock searches a corresponding direct cycle for each indirect cycle based on a dfs algorithm lines .
note in line algorithm also considers edges externalfr l kept in disk due to the reachability reduction see section .
.
construct deadlocks.
as explained in section .
a direct cycle detected by airlock is different from the one detected by previous works e.g.
where airlock only considers the reachability of locks without any execution information e.g.
thread ids and lockset .
however airlock also records all dependencies as a trace i.e.
trin algorithm for constructing all deadlocks resulting in exactly the same deadlocks as those reported by previous works.
in detail given a direct cycle airlock checks all sequences of dependencies indexed by all edges of this cycle.
a direct cycle will correspond to a set of permutations i.e.
a set of dependencies one from each indexed trace .
each permutation will be checked against the deadlock definition and the satisfied ones are finally reported.
this process is efficient by taking the concept of equivalent dependencies such that only permutations consisting of non equivalent dependencies from each indexed sequence of dependencies are checked.
discussion.
letebe the all edges in fr.
the time complexity of the first phase i.e.
lines is roughly a polynomial time complexity o e2 as the algorithm implicitly checks every pair of edges in fr.
the second phase lines is still an exponentialtime dfs algorithm.
however from line the dfs algorithm traverses all direct edges in indirect cycles.
considering our insight that most of nested lock acquisitions do not participate in any cycle there will be a small number of simple cycles.
this results in a much smaller searching space than that by previous works 1302icse may seoul republic of korea yan cai ruijie meng and jens palsberg which have to explore much more paths where most of them do not finally form cycles.
hence algorithm is very efficient in practice.
.
part iii reduce reachability graph the first two parts work well in terms of detecting all direct cycles.
however a multithreaded program usually creates numerous locks and edges.
during an execution the cumulative number of locks could be very large bringing increasing memory and time consumption.
one straightforward solution is to remove all destroyed locks and related edges during an execution.
however this brings a challenge on how to guarantee the correctness i.e.
not to miss any cycle after reduction.
it is because a destroyed lock may also participate in a cycle that is formed later.
for example in our example figure when the lock open is destroyed we delete all edges involving the lock.
then no cycle will be reported as the two edges formed by threads t1andt2 have been deleted.
we propose a reachability reduction algorithm with guarantees on the reduction correctness as shown in algorithm .
basically when a lock is destroyed airlock tries to ensure its reduction correctness.
if the correctness cannot be immediately determined it splits all related edges from the reachability graph e.g.
to keep algorithm reduction and cycle detection 1function ondestroylock l ifinde ree l outde ree l 0then case .
foreach m fr l do to m to m colordir l colorind l deletealled es colordir l colordir m .
ifinde ree l outde ree l 0then case .
foreach m to l do fr m fr m colordir l colorind l deletealled es colordir m colordir l .
ifinde ree l outde ree l 0then case foreach m fr l do to m to m colordir l colorind l ifcolordir m fr l colordir l fr m then a direct simple cycle l m m l c c l m m l .
ifcolordir m fr l colorind l fr m then an indirect simple cycle l m mdl indc ycledirfr l indc ycledirfr l m indc yclelocks indc yclelocks l .
foreach m to l do fr m fr m colordir l colorind l ifcolordir m to l colorind m fr l then an indirect simple cycle m l ldm indc ycledirfr m indc ycledirfr m l indc yclelocks indc yclelocks m .
only save direct edges in fr l andt o l .
foreach colordir m fr l do externalfr l externalfr l colordir m foreach colordir m to l do externalfr m externalfr m colordir l fr l to l into external disk for later cycle detection.
in such a way the reachability graph e.g.
in memory is always for live locks.
we present our reduction algorithm and then give an informal analysis on its correctness.
reduction.
on destroying lock l there are three reduction cases according to whether the indegree or and the outdegree of this lock is zero3 case both indegree and outdegree of lock lare zero case only one of them is zero and case both of them are nonzeros.
for case nothing should be taken because this lock does not reach any other locks and vice versa.
for case obviously this lock is not involved in any cycle hence all its information should be removed.
besides if the indegree of lock lis zero case .
for any other lock m i.e.
m fr l that is directly or indirectly reachable from lock l we remove edge l mas well as all dependencies in the trace indexed by this edge see line .
if the outdegree of lock lis zero case .
we perform the similar action.
for case since there are locks both reachable from and to lock l lock lmay be involved in some cycles.
hence we first perform a cycle detection.
however we only detect all simple cycles involving lockl lines and .
after that we move all direct edges infr l andto l into disk.
these edges are known as external edges i.e.
externalfr in the algorithm and are searched during detection of all direct cycles in algorithm .
reduction correctness.
we briefly show the correctness analysis based on the mathematical induction manner before and after reduction of klocks and all edges involving these locks airlock detects the same set of cycles.
l m l m formed after destroying lock l.lm1 m2 b m1 m2 a figure correctness illustration for reduction.
base case i.e.
k before and after reduction of the first lock sayl the above claim holds.
let s analyze the three reduction cases for cases and obviously the lock cannot participate in any cycle.
hence reducing the lock does not affect any cycles to be detected.
our claim holds.
recall that case is the lock lhas both incoming and outgoing edges.
before reduction the lock can only participate in two kinds of cycles cycles already formed and cycles formed later as shown in a and b respectively.
for already formed cycles algorithm can detect them before reducing the lock.
for any cycles to be formed later there must exist two lock m1andm2that form two edges m2 l andl m1as shown in figure b such that the edge m1 m2is formed after destroying lock l. hence there must be an indirect edge m2dm1 see how algorithm updates reachability .
this results in that after remove lock land edges m2 landl m1 an indirect cycle m1 m2 m2 3note we do not explicitly maintain either indegree or outdegree for each lock as we only need to know whether the value is zero or not.
this can be easily analyzed from the keys of the edges sets frandt oin implementation.
1303low overhead deadlock prediction icse may seoul republic of korea dm1 can be detected after the edge m1 m2is formed.
besides during reduction algorithm also keeps all direct edges from and to lock lin disk i.e.
externalfr .
when detecting all direct cycles of the indirect cycle m1 m2 m2 dm1 by searching edges in disk algorithm can detect the direct cycle involving lock l. note the edges from m2 tol from ltom1 and from m1tom2can be either direct or indirect ones which does not affect the analysis.
therefore for case after reducing lock land edges involving l our claim holds.
now assume that after reducing the first klocks and all edges from to them the same set of cycles can be detected.
let s show that reducing the k thlock our claim still holds.
note the k thlock can have incoming or and outgoing edges before reducing some of the klocks.
but here we only consider the current state whether any cycles can be missed by reducing the k th lock.
obviously by repeating the steps in the base analysis no cycle can be missed from the current state by removing one lock and edges involving in this lock.
a more detailed analysis can be done by split the execution into two executions at the point right before reducing the k thlock and apply base analysis on the second execution.
thus we can see that our claim still holds by reducing the k thlocks.
combining the two analyses above our claim holds.
that is our reduction guarantees not to missing any cycle while reducing locks and their corresponding edges.
.
frequent deadlock detection existing predictive deadlock detectors only detect deadlocks after a program exits or is about to exit.
they cannot immediately report deadlocks whenever they are formed especially for long running programs e.g.
server programs or non terminating executions.
unlike these airlock i.e.
part ii can be configured to run whenever there is a detection need e.g.
periodically or on user demand .
it can detect deadlocks at runtime.
in our experiments section .
we show that airlock is scalable to detect deadlocks per second during runtime with less than time overhead on two programs running for and seconds respectively.
discussion of airlock in this section we briefly discuss airlock and other similar works in terms of maximality and soundness on reported deadlocks.
maximality.
given the same trace and the same deadlock definition i.e.
the one in the last paragraph of section .
airlock can detect the same set of predictive deadlocks as that by previous works including igoodlock magiclock and undead.
this set of deadlocks is maximal with respect to the trace because all approaches consider all permutations of lock acquisitions and filter out those not satisfying the deadlock definition.
soundness.
all approaches above including airlock are unsound by reporting false positives.
to the best of our knowledge dirk is the latest work on sound deadlock prediction.
however like sound data race prediction it needs to track additional events and relies on constraint solvers bringing heavy performance challenges.
these make them unsuitable for efficient on the fly deadlock prediction.
experiments in this section we present a set of experiments to demonstrate the effectiveness and the efficiency of airlock as an on the fly predictive deadlock detection tool and its scalability on high frequency deadlock detection.
we also conducted a self comparison on the two strategies i.e.
cycle detection and reachability reduction of airlock.
.
benchmarks we collected a set of seven real world c c benchmarks including hawknl sqlite two different versions of mysql database servers two browsers firefox and chromium and thunderbird.
they contain six unique deadlocks that are similar in number to previous work .
all these benchmarks and deadlocks have been extensively studied in previous works .
we excluded one benchmark mysql .
.
in the papers of magiclock andundead because mysql .
.
uses customized synchronization primitives not standard pthreads.
in table we show the statistics of these benchmarks including their names versions bug id source lines of code sloc no.
of threads no.
of locks total number of locks max number of live locks a summary of inputs or deadlock descriptions the time cost of their native executions and the number of predictive deadlocks reported by three techniques all unique real .
the last column shows the number of locks in each direct cycle.
.
implementation and experimental setup airlock was implemented on top of the pin framework for c c programs with pthread.
it works under the probe mode of pin which itself incurs almost zero overhead.
we have reviewed a list of tools on deadlock detection to identify potential competitors for comparison.
undead is the only online predictive detector that we have found.
magiclock sherlock and wolf are listed as state of the art deadlock detection tools published in where both sherlock and wolf focus on soundness.
conlock and conlock focus on triggering real deadlocks reported by magiclock.
dirk is a heavy weight detector to detect sound deadlocks.
additionally picklock focuses on soundness and was evaluated on a set of small java programs.
finally we selected the two representative deadlock detectors magiclock andundead for comparison purpose.
other predictive tools like igoodlock and multicoresdk have been compared with magiclock in previous works and undead is also based on igoodlock with additional dependency pruning strategies.
formagiclock we used its implementation provided by the author .
the original undead release is available online it contains two parts deadlock detection and deadlock tolerance.
we evaluated its detection part.
we conducted the experiments on a dell precision with a .
ghz i7 7700hq processor ubuntu .
x64 and gcc .
.
we ran each benchmark ten times to collect data and compute averages.
we set each execution time to be at most hours.
1304icse may seoul republic of korea yan cai ruijie meng and jens palsberg benchmarksbug idsloc k thd locks summary of inputsnative time cycles all unique real locks in cycles undead magiclock airlock hawknl .6b3 n a .
deadlock in nlshutdown andnlclose .1s sqlite .
.
.
deadlock in sqlite3unixentermutex andsqlite3unixleavemutex .3s mysql1 .
.
.
show innodb status deadlocks if lock thd data points lock open .8s mysql2 .
.
.
puge binary log acquires two locks in the wrong order .1s firefox .
n a .
open web pages .9s chromium .
n a .
open web pages .1s thunderbird .
.
n a .
fetch e mails from a gmail.com account .8s table basic statistics of the benchmarks.
.
.
.
.
.
.
.
.
.
.
.
.
.
undead magic lock airlock .
.
.
.
.
.
.
.
.
.
.
figure time overhead.
050100150200250300undead magic lock airlock .
.
050100150200250300undead magic lock airlock .
.
figure memory consumption megabytes .
.
effectiveness and efficiency .
.
overall analysis.
from the penultimate column of table we see that the three techniques detected the same number of deadlocks.
figures and show the time overhead and memory consumption respectively for each benchmark as well as their averages.
note magiclock is an offline technique and we collected its costs on time and memory from its offline detection phase.
on time overhead it is obvious that airlock significantly outperformed both magiclock andundead.
it only incurred .
to .
overhead.
however undead incurred .
to .
overhead on two benchmarks on remaining benchmarks it incurred .9x to 1023x overhead.
actually undead did not finish on firefox and chromium after running for hours i.e.
our time limit .
magiclock incurred .
to .
overhead on three benchmarks.
however on remaining benchmarks it incurred .5x to 159x overhead.
on average airlock only incurred .
overhead but undead andmagiclock incurred 371x and 31x overhead respectively.
4variable system load can affect execution time yet any system load affects both airlock and the execution itself.
we speculate that this may bring proportionalthe above results confirm that analyzing and reducing the lock reachability graph before detecting cycles and deadlocks leads to efficient deadlock analysis.
besides the optimization of magiclock may be effective on some benchmarks but may also be ineffective on other benchmarks e.g.
mysql2 .
however considering the total detection time of magiclock it is acceptable as an offline deadlock detector for development.
undead is based on the igoodlock algorithm which has been shown to be inefficient .
on memory consumption figure shows that there is no large difference.5on average memory magiclock andairlock used almost the same amount and undead took about twice.
hawknl sqlite mysql1 mysql2 firefox chromium thunderbird moved .
.
.
.
mem .
.
.
.
.
t races .
.
.
.
.
.
.
table external storage consumption and reduced memory consumption by airlock in megabytes .
airlock adopts the strategy that may move edges from memory to external disk when a lock is destroyed besides tracking an execution trace for deadlock construction.
therefore we also collected its external storage consumption for moved edges moved its reduction to memory consumption mem .
and the sizes of traces traces as shown in table .
from the table airlock consumed to .
mb external storage and reduced to .
mb memory consumption.
it seems that moving edges into external storage can have little effect in terms of memory consumption.
we will present further analysis in the next subsection.
from the last row we see that airlock kept an acceptable size of execution traces for each execution.
.
.
detailed comparisons.
besides the overall comparison we introduced one more comparison point the trend of runtime data including the number of edge sets for airlock and the numbers of dependencies for undead andmagiclock.
we collected such data every two seconds during execution.
for magiclock we saved a copy of its trace every two seconds and calculated the data.
increases resulting in an overhead percentage similar to what we reported.
in effort to deal with variations we repeated our experiment times and computed the average.
5from figure airlock consumed more memory than that by magiclock.
airlock keeps a trace in memory and has a steady memory consumption which varies across programs.
in figure we see that the trend for the number of edges is increasing for magiclock but steady for airlock.
so we estimate that for longer execution time airlock will consume less memory than magiclock.
1305low overhead deadlock prediction icse may seoul republic of korea hawknl sqlite mysql1 mysql2 firefox chromium thunderbirdundead magic lock airlock edges depedencies .
edges edgesets direct edges .
.
.
.
.
edges depedencies figure trends on memory consumption in terms of the number of edges dependencies and edge sets where the x axis shows the execution time seconds and the y axis shows the numbers .
to compare the three tools directly we further converted the two kinds of data to the number of edges as follows we transformed each edge set or each dependency into multiple direct edges according to the size of each edge set or the size of the lockset in each dependency.
note airlock only keeps edge sets for live locks for any destroyed lock its edge sets are deleted or moved out of memory see algorithm hence the number of edge sets also reflects the number of live locks.
in each subfigure of figure thex axis shows the execution time e.g.
istands for i 2seconds and the y axis shows the number of periodically collected data.
figure clearly shows that airlock maintained a stable number of edges and a stable number of edge sets after executing for several seconds however both undead andmagiclock incurred obvious increasing numbers of edges and dependencies.
this confirms the insight behind the design of airlock most locks are dynamically created and destroyed and the total number of live locks i.e.
the number of edge sets keeps stable during executions.
summary.
from the overall results in table and in figures and as well as the detailed data in figure airlock is applicable to on the fly deadlock detection while magiclock is acceptable for offline deadlock detection for development.
.
scalability under high frequency detection airlock is designed as an on the fly deadlock detector whose detection can be frequently conducted.
to evaluate this feature we conducted another experiment.
we selected two benchmarks mysql1 and firefox where we are able to increase the sizes of inputs such that they can run for a longer time.
in detail for mysql1 we configured a stress testing tool sysbench6to send 108sql queries to it for firefox we configured it to open pages note these workloads are different from those used to measure native time in table .
under the two configurations mysql1 was able native undead magiclock airlock mysql1 .8s hours .0s .
.1s .
firefox .4s hours .7s .
.0s .
b overhead of airlock on firefox with periodical detections a overall results time and overhead of three techniques c overhead of airlock on mysql1 with periodical detections2 period seconds period seconds figure scalability of airlock to run for seconds and firefox was able to run for seconds.
during their executions we configured airlock to detect deadlocks periodically.
we set different periods from second to seconds.
that is for every period of iseconds airlock detects deadlocks once.
for each configuration we collected the overall time overhead.
for comparison we also run airlock with the default configuration i.e.
one deadlock detection at the execution exit point and undead andmagiclock under the same inputs on two benchmarks.
figure shows the overall results.
in figure a we show the detailed data on two benchmarks including their native execution time the time cost of each technique as well as the corresponding overhead.
in figures b and c we show the time overhead of airlock with different deadlock detection periods from second to seconds .
figure a shows the similar result on time overhead as the previous one in figure .
that is when both benchmarks run for about .
or .
seconds both undead andmagiclock incurred 1306icse may seoul republic of korea yan cai ruijie meng and jens palsberg hawknl sqlite mysql1 mysql2 firefox chromium thunderbird airlock al1 al2 al3 figure evaluation on efficiency of airlock s strategies the y axis is the time overhead of airlock and its three variants al1 al2 and al3 .
larger overhead than airlock.
in details undead failed to finish detection in hours magiclock incurred 1x to 3x time overhead.
airlock incurred at most .
time overhead.
forairlock as shown in figure b and c even with a detection period of second it incurred less than time overhead.
with the increasing detection period from second to seconds its time overhead decreased gradually.
when the detection period is 5seconds airlock incurred less than .
time overhead on both benchmarks.
in practice such detection period is already highly frequent for long running programs.
summary.
from the above analysis airlock can scale up to intensive deadlock detection on the fly.
this makes it applicable to be integrated with multithreaded programs to provide anytime deadlock detection service.
.
self comparison of airlock airlock consists of three parallel parts where parts ii and iii implement efficient cycle detection including two strategies detecting simple cycles lines in algorithm first before a dfs search and reduce the reachability graph in algorithm .
we built three tools al1 al2 and al3 and conducted an additional experiment to answer what extent the two strategies accelerate cycle detection.
al1 is based on airlock by disabling its detection of simple cycles i.e.
to directly use dfs for cycle detection among all edges al2 is based on airlock by disabling the reachability reduction and al3 is based on airlock by disabling both.
all three tools were configured to detect deadlocks once at the execution exit point.
the result is shown in figure where we also show the overhead of airlock from figure for comparison purpose.
from the figure we see that on three benchmarks hawknl sqlite and mysql2 airlock compromised its overhead by less than .
however on the remaining four benchmarks the overhead is compromised significantly by .6x to 676x.
such an overhead is even much larger than that by magiclock andundead.
besides we also collected the data on the ratio of inconsistent lock acquisition orders out of all.
it shows that only .
.
on average of lock acquisitions exhibit inconsistent lock orders.
the exception is mysql2 for which the percentage is .this above result further confirms the efficiency of the strategies inairlock.
related works .
deadlock detection besides dynamic approaches deadlocks can also be detected by static approaches .
like dynamic approaches static ones can analyze program code to construct lock order graphs.
they are scalable to the whole program and do not suffer heavy overhead.
however they usually report many false positives due to imprecise static analysis techniques as well as lack of runtime information such as happens before relation .
there are some sound static deadlock analyses which are usually restricted to certain languages for example for c programs for c programs or for barrier synchronizations .
they may rely on other techniques to guarantee soundness e.g.
pointer analysis .
predictive deadlock detection usually produces false positives .
there are two kinds of approaches to isolate real deadlocks.
one is to trigger real deadlocks out of all detected ones.
deadlockfuzzer adopts a straightforward scheduling i.e.
pause a thread right before it acquires its second lock and waits for all other threads to go into the same state to trigger deadlock occurrences.
it is known that such a scheduling can produce thrashing as pausing a thread may prevent other threads from making progress resulting in a low probability to trigger deadlock occurrences.
there are already a sequence of works trying to improve the probability by identifying a set of constraints and satisfy these constraints.
ourairlock focuses on predictive deadlock detection it can be integrated with these tools to isolate real deadlocks.
another kind of works aims to directly detect real deadlocks i.e.
without producing false positives during detection .
the most recent one is the dirk where the similar idea is also adopted in rvpredict on sound data race detection.
this approach unlike many previous deadlock detection tools further monitors memory accesses and then extracts various constraints from memory accesses and from synchronizations .
by solving these constraints it detects deadlocks that are deemed to really occur if all constraints are satisfied.
airlock focuses on on the fly predictive deadlock detection it is challenging to analyze memory accesses on the fly without incurring heavy time overhead.
airlock is an on the fly predictive deadlock detector.
there are works on detecting deadlocks with a subsequent deadlock prevention healing .
gadara statically inserts code to prevent deadlocks.
dimmunix tries to bring deadlock immunity to a software product.
it detects deadlock occurrences and prevents their second occurrences in later executions.
undead as discussed in this paper further tries to detect predictive deadlocks and to fix both real deadlocks and predictive deadlocks.
both dimmunix and undead may report false positives undead may further introduce other concurrency bugs due to its incomplete fixing strategy .
there are also some works targeting on preventing deadlocks in certain types of applications e.g.
database applications .
deadlocks occur under certain thread interleaving and certain concurrent test cases.
there are works that schedule threads 1307low overhead deadlock prediction icse may seoul republic of korea and generate additional concurrent test cases .airlock can be integrated into them to detect deadlocks efficiently.
.
lightweight online data race detection predictive deadlock detection was not suitable for on the fly detection before airlock.
however there are several works aiming at on the fly data race detection.
data race occurrences involve memory accesses and their detection usually incurs heavy overhead e.g.
up to 100x on c c programs .
fasttrack introduces the epoch concept together with optimization it reduces overhead to 8x for java programs.
however this overhead level is still high.
there are different kinds of works on reducing overhead for data race detection.
the first kind is based on the crowd sourced approach.
racemob adopts static analysis to firstly identify all potential data races even with false positives .
it distributes a small set of potential data races to each end user aiming at confirming the reality of them.
as it requires that only one potential data race can be confirmed in each execution its overhead is extremely low.
the second kind is based on sampling .
by sampling a small set of memory accesses per execution one can reduce overhead per execution.
literace is based on a cold region hypothesis data races are more likely to exist in cold region.
it adaptively samples cold regions functions only removing overhead on monitoring hot regions.
pacer is based on a short distance hypothesis.
it periodically samples an execution and fully tracks memory accesses in sampled periods.
during non sampled periods it only checks for data race occurrences without updating tracking data.
pacer incurs an overhead proportional to a sampling rate.
the third kind is based on hardware .
datacollider takes full advantage of data breakpoints.
it samples a first memory access and then traps a second one by setting a data breakpoint on the same memory address.
crsampler proposes clock race which can be sampled via data breakpoints like datacollider but does not need to pause any thread unlike datacollider to trap a second memory access.
compared with these sampling approaches airlock fully tracks executions and does not miss any deadlock while incurring low overhead.
conclusion this paper presents a novel low overhead on the fly predictive deadlock detection approach airlock.
the main novelty is that airlock maintains the lock reachability graph involving locks only and efficiently detects cycles on it.
for each detected cycle it then constructs a predictive deadlock.
the experiments on seven real world programs demonstrated that airlock was significantly more efficient than existing works by incurring about .
time overhead on average making it suitable for on the fly deadlock detection even under high frequency e.g.
per five seconds deadlock detection.