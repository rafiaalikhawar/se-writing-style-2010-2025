c2s translating natural language comments to formal program specifications juan zhai juan.zhai rutgers.edu rutgers university usayu shi shi442 purdue.edu purdue university usaminxue pan mxp nju.edu.cn nanjing university china guian zhou mf1832267 smail.nju.edu.cn nanjing university chinayongxiang liu liuyongxiang smail.nju.edu.cn nanjing university chinachunrong fang fangchunrong nju.edu.cn nanjing university china shiqing ma shiqing.ma rutgers.edu rutgers university usalin tan lintan purdue.edu purdue university usaxiangyu zhang xyzhang cs.purdue.edu purdue university usa abstract formal program specifications are essential for various software engineering tasks such as program verification program synthesis code debugging and software testing.
however manually inferring formal program specifications is not only time consuming but also error prone.
in addition it requires substantial expertise.
natural language comments contain rich semantics about behaviors of code making it feasible to infer program specifications from comments.
inspired by this we develop a tool named c2s to automate the specification synthesis task by translating natural language comments into formal program specifications.
our approach firstly constructs alignments between natural language word and specification tokens from existing comments and their corresponding specifications.
then for a given method comment our approach assembles tokens that are associated with words in the comment from the alignments into specifications guided by specification syntax and the context of the target method.
our tool successfully synthesizes specifications for methods of classes in different projects substantially outperforming the state of the art.
the generated specifications are also used to improve a number of software engineering tasks like static taint analysis which demonstrates the high quality of the specifications.
ccs concepts software and its engineering corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
formal specification comment natural language processing acm reference format juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan and xiangyu zhang.
.
c2s translating natural language comments to formal program specifications.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
https introduction formal specifications are vital for many software engineering tasks.
program verification requires procedure specifications to verify properties of interest especially when the source code is unavailable or too complicated to analyze.
synthesis techniques need specifications to synthesize unknown expressions .
software testing demands specifications to generate test oracles .
program debugging requires specifications to locate root causes .
as such a lot of work has been devoted to designing formal languages for specification composition.
java modeling language jml is one of such specification languages and widely used by developers e.g.
to provide specifications for jdk library methods .
however manually composing formal specifications is not only time consuming and error prone but also requires substantial expertise.
this motivates us to develop an automatic approach to synthesize program specifications.
modern software projects have abundant natural language nl documentation which provides a wealth of semantic information about code properties and behaviors.
for example in the linux kernel freebsd open solaris mysql firefox and eclipse .
.
.
.
million lines of their code bases are code comments .
j2se s javadoc is a representative example document.
it contains rich information such as properties of parameters and desired behaviors of methods.
such comments are in natural language and describe program semantics informally.
recently natural language processing nlp techniques have achieved enormous esec fse november virtual event usa juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan xiangyu zhang progress and have been adopted in many software engineering tasks showing fairly promising results .
this inspires us to utilize nlp techniques to address the automatic specification generation challenge.
there are existing techniques that generate specifications from code comments including tcomment toradocu and jdoctor .
they firstly manually define a set of patterns.
each pattern specifies a template for nl comments and a corresponding template for specifications.
then they match a given nl comment against the patterns to generate specifications.
however such pattern matching based techniques require many manual efforts and can hardly handle the flexibility and the diversity of natural languages which results in limited generality.
specifically tcomment infers null value related properties to detect comment code inconsistencies.
it cannot handle cases related to other properties such as throws nosuchelementexception if this deque is empty .
toradocu generates conditional expressions from exception related comments to create test oracles for exceptional behaviors.
the conditions they support include something is are positive negative true false null .
such patterns are still limited and they cannot handle the aforementioned typical comments.
based on toradocu jdoctor derives specifications from return value related comments in addition to exception conditions showing very promising results and representing the state of the art.
however since it still relies on patterns we found that many comments cannot be handled as they are not covered by the patterns such as returns the first element in this list .
in addition jdoctor is incapable of generating specifications to describe the main functions of void methods.
for example jdoctor cannot generate any specification for the void method clear whose comment is removes all of the elements from this set .
finally existing work cannot generate specifications to describe normal functional behaviors except return value related behaviors which are prevalent in comments.
hence our goal is to develop a general approach that can automatically synthesize specifications from different kinds of comments.
in this paper we propose c2s an automatic approach of translating nl comments of a target method to formal program specifications by assembling primitive tokens guided by the specification syntax and the context of the target method method properties such as parameters .
the primitive tokens are automatically extracted from existing jml specifications written for jdk library methods.
specifically we regard nl comments and jml specifications as two languages expressing the same semantics and formulate the specification translation task as a syntax guided synthesis problem.
we automatically couple nl comments and corresponding jml specifications to build a bilingual corpus to construct alignments between nl words and specification tokens.
existing jml specifications contain information specific to their methods.
such information is abstracted away to achieve generality.
then for the target method with comments we extract the generalized tokens that are associated with the words contained in an nl comment from the alignments and assemble them to synthesize program specification candidates guided by the specification syntax and the concrete context of the method.
the aforementioned generalized tokens used in the candidates are substituted with concrete ones for each target method after the synthesis process.
testing is further used to filter out incorrect candidates.we make the following contributions we propose a novel search based technique to automatically translate nl comments to formal program specifications that specify the expected set ups preconditions of using a method and the effects of executing a method postconditions for both exceptional behaviors and normal behaviors .
our approach avoids the manual and error prone efforts of defining patterns.
we develop a prototype c2s based on the proposed idea and evaluate it on methods of classes in different projects.
the applications of these specifications in dynamic testing and android app static taint analysis demonstrate that these specifications precisely represent the method behaviors and improve the efficiency and effectiveness of various analysis and testing applications.
motivation instead of using formal program specifications to convey code semantics developers tend to use natural language comments to informally describe semantics.
fig.
k demonstrates a real world method whose semantics are explained using three natural language sentences.
line describes that the main functional behavior is to remove the first element from this list and also return this element which is a post condition of normal behavior.
line points out that if this list is empty nosuchelementexception will be thrown which is a post condition of exceptional behavior.
line specifies the return value.
there are existing efforts in analyzing nl comments to generate formal program specifications.
however no existing work can infer specifications from the three comments in fig.
k .
the existing approaches all rely on patterns summarized manually from comments to derive specifications which requires substantial manual work and the patterns can only work on very limited comments.
moreover an nl comment can be interpreted differently in different contexts.
for example the first in returns the first component line in fig.
g means the first component in the receiver object before after executing the method the method execution does not change the receiver object while the first in returns the first element line in fig.
k means the first component in the receiver object before executing the method the method execution removes the first element in the receiver object .
the existing work generates the same specification for a given pattern without considering contexts which may induce errors.
we showcase how our approach can address these limitations using the examples in fig.
.
jml is a program specification language designed to specify desired properties behaviors of java classes and methods.
fig.
b shows an excerpt of jml specification for method remove int of class java.util.arraylist .
jml can specify both exceptional behaviors lines and normal behaviors lines .
there are some existing jml specifications which can be associated with corresponding nl comments.
this motivates us to design an approach to leverage both nl comments and existing jml specifications to automatically infer specifications from comments.
given that the dataset of existing specifications is minuscule we resort to the search based technique rather than machine learning techniques which have the overfitting problem.
26c2s translating natural language comments to formal program specifications esec fse november virtual event usa removes the element at the specified position in this list.
throws indexoutofboundsexception if the index is out of range index index size paramindex the index of the element to be removed returns the element that was removed from the list 06publicobject remove intindex ... a java documentation of method arraylist.remove int id naturallanguagecomment formalprogramspecification iremoves the element at the specified position in this list forall int i index i i old this.size this.get i null old this.get i null this.get i .equals old this.get i iireturns the element that was removed from the list result old this.get index iiithrows indexoutofboundsexception if the index is out ofrange index index size index index this.size throw indexoutofboundsexception ...... ... i comment specification pairs word token remove forall equals old get ... return result old this get ... element this null equals get p1 int ... if throw !
... add contains this result true p1 e ... empty isempty this size ... first this get old ... ... ... j word token pairs removes and returns the first element from this list.
throws nosuchelementexception if this list is empty return the first element from this list publice removefirst ... k java documentation of method linkedlist.removefirst a b c dthis.isempty throw nosuchelementexception result this.get result old this.get forallint i i i old this.size this.get i null old this.get i null this.get i .equals old this.get i ... m specification candidates of linkedlist.removefirst e f gthis.isempty throw nosuchelementexception result old this.get forallint i i i old this.size this.get i null old this.get i null this.get i .equals old this.get i ... n specifications of linkedlist.removefirst adds the specified vertex to this graph if not already present.
param v vertex to be added to this graph.
returns true if this graph did not already contain the specified vertex.
publicboolean addvertex vv ... l java documentation of method directedacyclicgraph.addvertex v hthis.contains p1 e ... o ir of directedacyclicgraph.addvertex v adds the specified element to this set if it is not already present.
param e element to be appended to this list returns true if this set did not already contain the specified element publicboolean add e e ... c java documentation of method hashset.add e public normal behavior ensures this.contains e ensures result !
old this.contains e 34publicboolean add e e ... d jml specifications of method hashset.add e public exceptional behavior requires index index this.size signals only java.lang.indexoutofboundsexception public normal behavior requires index index this.size ensures result old this.get index ensures forall int i index i i old this.size this.get i null old this.get i null this.get i .equals old this.get i 18publicobject remove intindex ... b jml specifications of method arraylist.remove int ithis.containsvertex v ... p specification of directedacyclicgraph.addvertex v creates anempty stack.
publicstack ... e java documentation of method stack.stack public normal behavior ensures this.isempty 53publicstack ... f jml specifications of method stack.stack returns the first component of this vector.
returns the first component of this vector.
publicefirstelement ... g java documentation of method vector.firstelement public normal behavior ensures result this.get 73publice firstelement ... h jml specifications of method vector.firstelement figure motivating examples fig.
a fig.
c fig.
e and fig.
g are four documentation samples where nl comments are annotated using different tags like returns to describe different aspects.
fig.
b fig.
d fig.
f and fig.
h separately show the corresponding jml specifications composed by developers.
the specifications are annotated using different tags to specify different kinds of behaviors.
for example a specification annotated by ensures specifies a post condition which is a property held by a method when the method finishes execution normally.
in the first stage of our technique we automatically couple each specification with the corresponding comment based on annotations.
by respectively coupling comments and with specifications and we get the three commentspecification pairs shown in fig.
i .
then comments and corresponding specifications are automatically pre processed and split to obtain alignments between nlwords and specification tokens shown in fig.
j .
the first column lists nl words and the second column lists all the tokens associated with each nl word.
tokens associated with words in a method comment are used to assemble specifications for the method.
notice that we have a token p intin fig.
j but it does not occur in any jml specification.
here p intis a parameter placeholder used to substitute the first parameter index with the data type intfor method remove int index .
also we have method names likegetand contains .
these are pure methods i.e.
methods that do not have side effects used in the collected jml specifications to encapsulate primitive actions.
we directly use these methods as our method placeholders.
our system substitutes information specific to existing methods with placeholders to derive generalized representations making our approach more general and more efficient.
we refer to each processed specification as an intermediate 27esec fse november virtual event usa juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan xiangyu zhang representation ir of the specification.
each ir is an ast which contains the syntax information of the specification.
such syntax information is essential to assembling tokens.
given a target method with comments fig.
k we first preprocess each comment into a bag of words and then retrieve the potential ir tokens from the word token pairs fig.
j .
considering the comment in line we can retrieve tokens like isempty and this given the nl word empty and tokens like given the nl word if .
with these tokens we leverage grammar rules of specifications to synthesize potential irs shown in fig.
m .
this is feasible since the irs have a limited number of tokens and syntactic structures e.g.
a method only accepts parameters of fixed types .
next we instantiate irs into specification candidates.
take the irh in fig.
o as an example the instantiation consists of several steps like replacing the parameter placeholder p1 e first parameter with generic type e with the formal parameter name v and substituting the method placeholder contains h in fig.
o with the concrete method name containsvertex i in fig.
p depending on the context of the target method.
the last step is to filter out incorrect candidates via testing and the result are shown in fig.
n in which the candidates like b in fig.
m are filtered out.
notice that we generate two specification candidates b and c for the comment returns the first element from this list line in fig.
k .
specification b specifies the return value is the first element in the receiver after executing the target method which is the case for line in fig.
g .
specification c specifies the return value is the first element in the receiver before executing the target method which is the case for line in fig.
k .
we leverage testing to prune out the wrong one to provide the context aware generation.
improving testing.
normally it is difficult for automatic testing tools to have a general way to generate test cases to cover diverse non exceptional behaviors.
however our derived specifications can be used to generate more accurate and more effective tests.
consider the method addvertex v in fig.
l .
the test cases generated by randoop only check whether the return value is true or false which cannot check the core behavior of adding a vertex.
in contrast we can use our generated specification box i in fig.
p to guide a testing tool to check whether the input vis successfully added.
as we will show in section the generated specifications can be used in generating new test oracles reducing false alarms in automated testing and improving static taint analysis.
design fig.
gives the design of our approach which includes the search space preparation phase left and the synthesis phase right .
the inputs of the first phase are nl comments collected from java documentation and corresponding jml specifications collected from jml website .
we begin by using the association engine to automatically couple each specification with an nl comment and the generated comment specification pairs are fed into the tokenizer to build word token pairs which will be used to synthesize specifications in the second phase.
for each comment the pre processor cleans it and splits it into individual words.
for each specification the ir translator substitutes the concrete subjects e.g.
parameter names specific to the subject method with placeholders to obtain javadoc jmlir synthesizer specificationsspecification generator specification checkerinput method with comments pre processor association engine word token pairs ir translator pre processor tokenizer commentspecification pairsfigure overview of c2s a general specification and builds an ast from the generalized specification.
after that nl words are coupled with ast tokens that will be used as the search space for synthesis.
the goal of the second phase is to generate specifications for a target method with nl comments.
firstly we obtain nl words from a cleaned nl comment using the pre processor.
then the ir synthesizer generates ir candidates by obtaining ast tokens that are associated with the nl words from the word token pairs and assembling the tokens into candidates based on grammar rules and the context of the method.
after that the specification generator instantiates each ir candidate with the context of the target method e.g.
parameters of the method to obtain a formal specification.
specifically candidates are generated from tokens extracted from existing specifications and thus parameter placeholders and method placeholders used in the candidates are specific to the original data.
as such they need to be separately instantiated with formal parameters of the target method and concrete java methods in the class superclass containing the target method.
lastly the specification checker leverages existing developer test cases to filter out incorrect specifications.
.
specification language jml specifications are used to specify properties and behaviors of java methods.
we simplify and formalize the specification language and present the abstract language model in table .
our approach generates both normal specifications and exceptional specifications for a given method.
normal specifications specify preconditions and post conditions when a method terminates execution without throwing an exception.
exceptional specifications specify a specific exception is thrown under a certain condition.
logical expressions le lists different types of specifications that can be used to describe normal specifications.
throw expression te specifies when a certain conditional expression ce is true a specific exception el will be thrown.
specifications cannot have side effects on objects otherwise the program state may be changed.
therefore expressions like assignments and increments are not allowed in the specification language.
also only methods that have no side effects on a program state can be used in specifications.
in addition to the logical expressions supported by java forall expressions fe and implication expressions ie are introduced to describe program states after executing a method.
fe represents universal quantification expressions.
for example the specification 28c2s translating natural language comments to formal program specifications esec fse november virtual event usa table specification language model specification s le te logical expression le ce fe ie ce lop le throw expressin te ce throw el if ce is true throw exception el implication expression ie ce ce ce fe forall expression fe forall int id ce ce conditional expression ce ne ne lop ce negation expression ne lep !lep logical expression primitive lep bc re mi result the type of result is boolean relational expression re ae rop ae ae eop ae ae eop null arithmetic expression ae aep aep aop aep arithmetic expression primitive aep ic id aa mi result the type of result is int method invocation mi obj.id pl?
mi.id pl?
old mi arithmetic operator aop equality operator eop !
logical operator lop relational operator rop array access aa obj.length object obj id this result the type of result is non primitive integer constant ic boolean constant bc true false exception literal el nullpointerexpcetion indexoutofboundsexception illegalargumentexception nosuchelementexception arrayindexoutofboundsexception parameter list pl identify id f orall int i i i a.len th a null means for each i in the range from inclusive to the length of the array a exclusive the i th element is null .
an ie in the form p qmeans ifpis true then qmust also be true for p qto be true and if pis false then p qis always true .
the method old is introduced to describe properties that involve program states before calling a method.
this enables us to describe the changes that a method invocation induces.
considering the program statement list.remove i we can use old list .
et i to represent the element previously at the position iof the receiver listwhen the method remove has not been called .
in order to represent the return value of calling a method the keyword result is introduced.
the data type of result depends on the return type of the method.
with result we can have the specification result old list .
et i for the above mentioned example to convey that the method remo ve int is expected to return the element previously at the position iof the receiver list before being modified by the method invocation .
.
association engine the association engine automatically couples specifications with corresponding comments based on annotations to prepare commentspecification pairs.
in documentation a method has comments for method parameters exceptional behaviors and normal behaviors.
as shown in fig.
a a parameter comment annotated by param e.g.
line gives a brief parameter description.
in some cases a parameter comment may describe the condition that the parameter should satisfy in order not to make the method execute exceptionally.
for example method subtract iterable a iterable b of class collectionutilsin project apache commons collections has a parameter comment amust not be null which indicates a precondition.
an exceptional behavior comment annotated by throws e.g.
line describes the condition that triggers an exception of a specific type.
for normal behaviors the first sentence e.g.
line of the comments of a method is a concise but complete description of what themethod does and the comment annotated by returns e.g.
line describes the return value of the method.
similarly a method has both exceptional behavior specifications and normal behavior specifications which also can be distinguished by their annotations.
take fig.
b as an example in exceptional behaviors the specification index index this .size annotated by requires line specifies the condition of throwing exception java.lang.indexoutofboundsexception line annotated bysignals only .
based on the exception type we can associate the specification in line with the comment if the index is out of range index index size in line pair iii in fig.
i .
in normal behaviors when the precondition annotated by requires in line is met the method will terminate the execution normally in a program state that satisfies the post conditions annotated by ensures lines .
the specification in line is an equality expression with one operand as result meaning the specification describes the return value.
and hence we associate such specifications with comments annotated by returns pair ii in fig.
i .
other types of post conditions describe execution effects of a method and they are associated with the first sentence that summarizes the method pair i in fig.
i .
.
tokenizer the tokenizer accepts a comment specification pair and transforms it into pairs of nl words and ast tokens.
for each input pair the pre processor is leveraged to clean the nl comment and split it into separate words and the ir translator is leveraged to convert the specification into an ast.
then the tokenizer constructs pairs of nl words and ast tokens by coupling each word in the cleaned comment with each leaf node in the ast.
.
.
pre processor.
to acquire more general comments by removing unnecessary information and normalizing texts the preprocessor mainly performs three tasks removing stop words common words appearing frequently like the reducing derived words to their word stem namely root form by applying the porter stemming algorithm .
for example the word inserts is transformed into insert and lowercasing all the words.
after the cleaning each comment is split into individual words by space.
.
.
ir translator.
the ir translator generalizes a jml specification in the text form to an abstract form and parses the abstracted specification to an ir represented using ast.
each generalized specification is called an ir with the semantics preserved.
there are two main reasons for using irs.
the first one is to reduce the search space for the synthesis process and the second one is to facilitate the instantiation of the synthesis results with concrete information belonging to the target method i.e.
the method whose specifications are being synthesized .
we will use the specification this .contains e of method add e e in fig.
d to demonstrate the reasons as well as the process.
firstly we substitute all concrete parameter names with parameter placeholders in the form of pi t the i th parameter with type t .
such substitution enables us to achieve better generality and higher efficiency.
for example assume the parameter eis not generalized and hence becomes part of the token set that would be used to synthesize a specification.
however it is very likely a target method 29esec fse november virtual event usa juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan xiangyu zhang algorithm synthesizing ir candidates from a nl comment input comment c parameters p return type t word token pairs m output a set of ir candidates s procedure synthesizeir c p t m wordset preprocess c tokenset extractt okens wordset m s f iltert okens tokenset p t while truedo remo veset oldset s set1 s set2 s for each ast1 set1do for each ast2 set2do s s assemble ast1 ast2 p t ifs oldset then remo veset remo veset ast1 ifs oldset then break s s remo veset return f ilter s with similar specifications does not have a parameter e. as such the generated specification is invalid.
it would be very difficult to replace it with some other parameter name as we do not know what erepresents.
however with p1 e we know that it is the first parameter with a generic type and thus finding a replacement is much easier.
another benefit of using placeholders is to reduce the search space by decreasing the number of tokens used to construct specifications since parameter names can be diverse.
pure methods which do not have side effects are used in jml specifications to encapsulate primitive actions.
for example the method contains in the specification this .contains e is a pure method.
we use the pure methods as method placeholders in our irs and they will be substituted with concrete methods when irs are instantiated into specifications for a target method section .
.
after generalization ir translator parses a specification to an ast.
the parser performs lexical analysis and syntax analysis which is very similar to that in a compiler .
asts .
we represent irs using asts and use leaf nodes to represent tokens and non leaf nodes to represent the ir s grammatical terms.
as shown in fig.
leaf nodes like result and are tokens used to constitute an expression and a non leaf node like equality expression represents a term having its inner structure.
.
ir synthesizer in this section we introduce our search based approach of synthesizing irs for a method with nl comments.
the process of synthesizing irs is presented in algorithm .
it takes a method comment c the parameters with type information p the return type t and the word token pairs mas inputs and the output is a set of ir candidates denoted as s. given a method comment we first obtain the initial token set from word token pairs mbased on words of the pre processed comment lines .
then we leverage the parameter data type s pand the return type tof the target method to eliminate some tokens from the initial token set line .
for example if the target method has no parameters then the token p1 intshould be removed from the token set.
the result set of tokens is stored in sto be used to synthesize irs.
with the token set the main procedure iteratively assembles two asts in the set sinto a larger ast based on the specification language model shown in table .
when a fixed point is reached we implication expression equality expressionmethod expression object equality operatorinteger constantimplication operator negation operatormethod invocation object idparameter list result !
this contains p1 objectid1 result !this.contains p1 object a ir candidates result !
get !
null this contains p1 object b tokens used for synthesis figure synthesis example terminate the assembling process.
the assembling procedure in line treats the two input asts i.e.
ast1andast2 as siblings to form a new ast.
note that the assemble procedure only generates an ast with correct syntax.
in addition to the syntax rules in table we also check the syntax based on the following properties of the target method the number of parameters the data type of each parameter and the return type.
suppose that we have two asts separately for result and null the ir result null is not generated for a target method whose return type is intalthough it is a correct ir for some methods.
note that two different asts may have the same semantic such as asts of result null and null result .
such asts are regarded as duplicated and they will not exist simultaneously in the set s. line checks whether a new ast is produced in the loop lines .
if not it is highly possible that no new asts can be constructed from ast1in the following iterations and thus we add it to remo veset and remove it from sin line .
consequently ast1will not be used to synthesize irs in later iterations.
after the assembling process we get an ast forest which may contain incomplete asts e.g.
a relational expression missing one operand and complete asts that do not denote logic assertions e.g.
this .size whose value is not boolean .
we eliminate such asts and return the remaining ones as ir candidates line .
example.
fig.
a presents some ir candidates assembled from the tokens listed in fig.
b .
some non leaf nodes are omitted for the limitation of space.
in the first iteration asts and are constructed.
then based on the initial tokens in fig.
b and the asts created in the first iteration and are assembled in the second iteration.
after that the third iteration produces and .
finally the whole tree in fig.
a is built in the fourth iteration.
in addition to the whole tree three other complete logical specifications are synthesized in this process namely and .
all the four irs are returned by the synthesis algorithm and the ones that do not specify the desired behaviors of the method will be eliminated by the specification checker in section .
.
other synthesized irs like result this .
et result null this .
et result .equals p1 object are omitted here.
.
specification generator the specification generator translates an abstract ir to a concrete specification leveraging the contextual information of the target 30c2s translating natural language comments to formal program specifications esec fse november virtual event usa method.
the placeholders that need to be instantiated include parameters and methods.
for each parameter placeholder we directly substitute pi t with the i th parameter of the method being specified.
for each method placeholder we need to find the matching concrete method in the class that contains our target method.
the initial concrete method candidates include all the methods that can be invoked by this class or by an instance of this class.
we first leverage the number of parameters and parameter types to select the candidates.
suppose that a parameter of the abstract method in the ir is of the type int.
if a method candidate does not contain a parameter with type int it is discarded.
if the abstract method does not have any parameter then no candidate is discarded in this step.
in the remaining candidates we use word embeddings to measure the similarity between the concrete method name and the abstract method name.
we use the value as a threshold for the similarity.
the value is picked based on our experimental results.
if no concrete method name has a similarity higher than the threshold it is highly likely that there is no concrete method having the behavior specified by the abstract method and hence we do not generate any specification for this ir.
otherwise the one with the highest similarity is selected to instantiate the abstract method.
the embedding of a camelcase method name is calculated as the average of word vectors of individual words.
notice that overloaded methods with the same method name have already been pruned out in the first step.
take the target method addvertex v v of class directedacyclicgraph in project jgrapht in fig.
l as an example.
one synthesized ir is this.contains p1 e h in fig.
o .
after parameter instantiation the ir is transformed into this .contains v e and v here are generic types and they are the same .
then c2s uses the parameter type vto select potential concrete methods in the concrete class.
any method that does not have parameters and any method whose first parameter type is not vare eliminated.
then we compare the word vector of the abstract method name contains with the word vector of each concrete method name and the one that has the highest similarity greater than the threshold is the method containsvertex .
by instantiating the method placeholder contains with the concrete method containsvertex the final specification this .containsvertex v is generated i in fig.
p .
.
specification checker the goal of the specification checker is to eliminate invalid specification candidates.
it works by first transforming the specification candidates into test oracles and then adding these oracles to existing project test cases written by developers.
here we trust these project test cases as they were the ones used in unit testing and regression testing.
as such any specification candidates that trigger violations in these tests are deemed invalid.
the specification checker consists of two main steps.
the first step is to instantiate a specification by substituting general information e.g.
formal parameters with concrete information e.g.
actual parameters .
the second step is to instrument existing test cases with assertions generated from instantiated specifications and necessary java statements.
.
.
specification instantiation.
general information in specifications is instantiated in this step.
recall that our specifications arealgorithm instantiating a specification for a method invocation statement input method specification s method invocation statement st method m output an instantiated specification specific to statement st procedure instantiatespecification s st m switch sdo case result return etretv alue st caseparm parm is one formal parameter of m return etactualparameter parm st m casethis return etrecei ver st m get the receiver of minst case old e e instantiatespecif ication e st m r etrecei ver st m return e r is a clone of rbefore executing st default newspec s for each operand sdo newopnd instantiatespecif ication operand st m newspec updateoperand newspec operand newopnd return newspec generated for individual method.
these specifications use formal parameters thisand result to respectively represent inputs the receiver and the return value of a method which has to be instantiated in order to generate test oracles.
for a statement in a project test case that invokes the target method the specification checker automatically instantiates them by using values in the method invocation statement.
notice that these concrete values are also used to generate assertion statements for the test case section .
.
.
this instantiation process is shown in algorithm .
it takes a specification sof the method m a statement stthat invokes the method mas well as the method mas inputs and returns the instantiated specification that is specific to the input statement st. we will use the example in fig.
to show how it works.
fig.
a gives a statement from an existing test case which invokes method remove int index with two generated specifications listed in fig.
b .
the instantiatespecification procedure defined in line recursively calls itself to do substitution.
it has three base cases separately for return value parameters and receiver.
when the expression result is found line we call the procedure getretvalue in line to get the actual return value of the given statement st. for example the statement in fig.
a uses variable retto store the return value and thus retis used to substitute result to3 .
when one linkedlist oldlist list.clone string ret list.remove 03org.junit.assert.asserttrue ret oldlist.get boolean flag true 05for inti i i i flag flag list.get oldlist.get 07org.junit.assert.asserttrue flag 3ret oldlist.get forall int i i i list.get i oldlist.get i java.util.linkedlist remove int index result old this.get index forall int i i i index this.get i old this.get i string ret list.remove a a statement calling remove int in b from a test case b specifications of method remove int c instantiated specifications based on a and b d test oracle generated based on specifications in b figure test oracle translation example 31esec fse november virtual event usa juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan xiangyu zhang formal parameter parm of method mis found line the procedure getactualparameter in line is called to retrieve the corresponding actual parameter.
for example the formal parameter index in fig.
b is substituted with the actual parameter 2in fig.
c to3 and to4 .
when the keyword thisis found line we substitute it with the actual receiver of method mreturned by the procedure getreceiver line .
the statement in fig.
a has listas the receiver and thus thisis substituted by list.
to express the semantics of old we propose to save the program state i.e.
the state of the receiver in java before executing a statement into a new variable rc a clone of the receiver and later retrieves from rc.
more specifically when the expression old e is found line we recursively call the procedure instantiatespecificationto substitute the aforementioned general information in eand store the substituted expression to e line .
then we substitute the receiver of minst rin line in e with our cloned receiver rc line .
consequently we can retrieve the program state before executing stfrom rc.
for example in fig.
d we can get the third element in the original linked list i.e.
before calling remove int in line from receiver oldlist cloned in line .
the previous third element cannot be obtained from the receiver listin line since it has been removed by calling remove int in line .
for other expression types each operand is substituted by recursively calling the procedure instantiatespecification to get the whole expression instantiated lines .
.
.
assertion instrumentation.
after deriving instantiated specifications the specification checker instruments test cases with assertions and related code .
the rules of instrumenting assertions and code into existing test cases are shown in fig.
.
the instrumentation process works recursively and is named as generateoralce .
the first column lists the instantiated specifications and the transformed test cases are boxed in the third column.
the statement sthere calls a target method for which we have synthesized specifications namely the input parameter stin algorithm .
rule separately generates an oracle for each operand of the implication operator and then generates an assertion based on the definition of the implication expression.
similarly we have rule rule and rule for conditional expressions in our specification language model.
rule is used to generate test oracles from universal quantification specifications with a forloop.
for example we can use rule to transform the specification in fig.
c into the oracle in lines of fig.
d in which the initial value value in rule of the loop control variable is obtained from the condition i i index of4 .
rule shows how to instrument a test case based on an instantiated specification containing the cloned receiver rc.
firstly we insert a code snippet to clone the receiver of the target method instasrcbefore st. then the specification is treated as others.
considering the example in fig.
d line is inserted before line to clone the receiver list and the specification is transformed to the oracle in line .
evaluation we have implemented a prototype c2s and empirically evaluated c2s to address the following questions table specifications generated project class method pre except post nor post jdk .
commons collections .
guava graphstream .
jgrapht .
.
total rq1 how effective is c2s in synthesizing formal program specifications from nl comments?
rq2 how does c2s compare with state of the art approaches in improving dynamic testing?
rq3 how useful is c2s in improving static taint analysis?
the evaluation was conducted on a machine with intel r core tm i5 8259u cpu .30ghz and 8gb main memory.
the operating system is macos high sierra .
.
and the jdk version is .
.
data collection to prepare the search space of tokens for synthesizing specifications we collected all available jml method specifications and their corresponding nl comments.
all the specifications are composed for the project jdk .
in total we have couplings between comments and specifications.
on average each nl word is mapped to ir tokens.
the time used to synthesize specifications for each comment is on average .40s.
.
effectiveness in specification generation to answer rq1 we synthesize specifications for frequently used java libraries with well maintained documentation namely jdk apache commons collections guava graphstream and jgrapht the results are shown in table which presents the project column the number of classes methods columns that are analyzed and the number of generated preconditions exceptional behavior post conditions normal behavior postconditions columns .
note that the search space of ir tokens used in c2s is collected only from project jdk.
however specifications for other projects can be generated using c2s meaning that c2s is cross project.
from table we make a few observations.
firstly the number of normal post conditions is a bit more than the number of methods.
this is because executing one method can lead to multiple effects.
take method add int index object element of class arraylist as an example.
if it executes normally it would achieve at least the following two effects the receiver list contains the parameter element and the element at the position specified by the parameter index equals to the parameter element .
c2s generates a specification for each effect.
secondly the number of preconditions is less than that of exceptional post conditions except for project apache commons collections .
based on our analysis on these comments we observe that in many projects developers rarely comment on preconditions although normally the negation of the exception triggering condition could be considered as essentially a precondition.
to further answer rq1 we measure precision and recall of c2s in synthesizing specifications.
like other projects of deriving specifications from comments there is no ground truth for 32c2s translating natural language comments to formal program specifications esec fse november virtual event usa e1 e2 1st 2boolean f la 1 enerateoracle e1 3boolean f la 2 enerateoracle e2 4assertt rue f la 1 false f la 2 true f la 2 true note st a statement which calls a method mwith specifications e e1 e2 a specification after instantiation using algorithm r receiver the object on which the method mis called in st rc a clone of the receiver rbefore executing st f rc a instantiated specification that contains cloned receiver rce1 e2 1st 2boolean f la 1 enerateoracle e1 3boolean f la 2 enerateoracle e2 4assertt rue f la 1 f la 2 e1 e2 1st 2boolean f la 1 enerateoracle e1 3boolean f la 2 enerateoracle e2 4assertt rue f la 1 f la 2 !e 1st 2boolean f la enerateoracle e 3assertt rue !f la e 1st 2assertt rue e forall intx e1 e2 1st 2boolean f la true 3for intx initalv alue e1 x f la f la e2 4assertt rue f la f rc 1type rc clone r 2st 3boolean f la enerateoracle f rc 4assertt rue f la figure transformation rules ideal specifications.
we follow a similar evaluation method to existing work which manually checks generated specifications.
we asked developers graduate students and developers from industry to participate in the manual checking.
all the developers had at least four years of programming experience and were acquainted with program comments.
in the process all specifications are checked against source code with the help of corresponding comments.
there are two main reasons specifications are expected to specify code behaviors and one nl sentence may express different meanings in different contexts e.g.
returns the first component in fig.
g and in fig.
k introduced in section .
as we manually check specifications it is inevitable to introduce subjectivity.
to minimize such subjectivity we utilized cross verification by assigning each specification to two different developers.
when a disagreement occurs all the developers would involve to have an open discussion to resolve it.
moreover we mix our synthesized specifications and specifications generated using the other three approaches and thus the developers are unaware of whether a specification is generated using our approach or not.
note that tcomment aims at detecting comment code inconsistencies meaning that it does not assume the correctness of source code.
in order to have a fair comparison during the study the users were instructed to preclude cases in which specifications are inconsistent with code due to inconsistencies between comments and code.
if a specification is inconsistent with the source code it is considered as false positive.
if we fail to generate a specification for a comment we consider there is a false negative.
note that there are comments that do not have corresponding specifications e.g.
those explaining time authors and implementation details .
we preclude such comments.
specifically a specification is correct c when it is consistent with the corresponding source code it is wrong w when it is inconsistent.
for example the specification this .containsvertex sourcevertex is generated for method table specification synthesis precision and recall toolpre except postnormal postoverallreturn non return p r p r p r p r p r tcomment .
.
.
.
n.a.
.
n.a.
.
.
.
toradocu n.a.
.
.
.
n.a.
.
n.a.
.
.
.
jdoctor .
.
.
.
.
.
n.a.
.
.
.
c2s .
.
.
.
.
.
.
.
.
.91addedge v sourcevertex v targetvertex e e in class edgereversedgraph of project jgrapht .
however method addedge is to add an edge which goes from the sourcevertex rather than adding the parameter sourcevertex .
such wrong specifications are generated because c2s does not analyze the semantic of a natural language comment.
a specification is missing m when no specification is generated for a comment or when a comment describes two or more behaviors but c2s fails to synthesize specifications for all of them.
consider the comment throws illegalargumentexception if collection is empty or contains more than one element of method extractsingleton collection e collection in class collectionutils of project apache common collections .
c2s can generate a specification for collection is empty but cannot generate for the later part due to the incompleteness of the word token pairs.
we define precision as the ratio between the number of correct specifications and the total number of generated specifications namely c c w and recall as the ratio between the number of correct specifications to the total number of correct specifications that are expected to be generated namely c c m .
note that our manual validation efforts are only needed for evaluating precision and recall not during deployment.
for example in real deployment of using our specifications to improve testing we will simply utilize all the generated specifications and report all test failures.
the developers will manually go through such failures.
some failures may be due to incorrect specifications but our precision and recall results indicate that such cases are very rare.
table reports precision and recall of tcomment toradocu jdoctor and c2s on the target methods of table .
the columns p andrseparately show precision and recall.
as mentioned in introduction tcomment does not handle normal post conditions i.e.
post conditions for normal behaviors toradocu cannot generate preconditions or normal post conditions and jdoctor does not handle normal post conditions that are unrelated to return value as n.a.shown in the table .
the data shows that the precision of c2s is comparable with the state of the art approaches while the recall of c2s is substantially higher.
for the return related normal post conditions jdoctor s precision and recall are much lower than those of c2s since return comments are too complicated for pattern matching and lexical similarity to work well.
33esec fse november virtual event usa juan zhai yu shi minxue pan guian zhou yongxiang liu chunrong fang shiqing ma lin tan xiangyu zhang c2s is the only technique capable of generating non returnrelated normal post conditions.
for example c2s can generate the desired specification this .
et index object for the comment sets the value at the specified index avoiding duplicates.
.
finally we want to point out that there are still comments beyond the capabilities of c2s.
for example c2s cannot handle the comment returns the n th item down zero relative from the top of this stack without removing it.
limited by the incompleteness of existing specifications.
the overall precision of .
and the recall of .
illustrate that c2s is more effective in translating nl comments to formal specifications than the state of the art approaches.
our generated specifications are publicly available .
.
improving automatic test case generation to answer rq2 we conduct an experiment to show how our specifications improve automatic test cases generation by randoop compared with jdoctor s specifications.
we choose jdoctor because of its diverse specification types.
for example tcomment and toradocu cannot generate post conditions for normal behaviors while jdoctor can.
to make a comprehensive comparison we choose to compare c2s with jdoctor.
this experiment follows jdoctor s experiment setup.
randoop is an automatic testing tool that explores method sequences randomly for a given class and checks whether executing these sequences would violate default specifications as well as userprovided specifications that describe expected behaviors.
randoop outputs two types of test cases namely failing ones that reveal potential bugs and passing ones that are used as regression tests.
randoop has limitations in supporting our generated specifications.
to address this we enhance randoop in three aspects and we refer to our enhanced randoop as c2srandoop.
firstly c2srandoop allows adding oracles between program statements whereas randoop only adds oracles after the last statement making it impossible to check some properties before that.
for instance the property list.isempty holds after executing the statement list.clear and we need to add this oracle after the invocation.
otherwise listmay be updated by following statements like list.add paper and it would become invalid to test the property isempty after the last statement.
secondly we modify randoop to generate oracles for void methods whose specifications are skipped.
for example randoop does not generate assertions to test the voidreturn method add int index e element of class arraylist and thus its properties like this .contains element cannot be checked.
thirdly randoop does not accept some of our specification types including implication expressions forall expressions and expressions containing keyword old.
based on the rules shown in fig.
introduced in section .
c2srandoop can generate oracles from these specifications to test target methods.
we use c2srandoop to generate test cases based on jdoctor s specifications and our specifications and the time limit is set as minutes.
table summarizes the comparison results.
the first column lists the projects.
the columns fc ta faand respectively show the number of failing cases the number of true alarms the number of false alarms and the ratio between false alarms and the number of failing cases.
as we manually check thetable test case generation improvement projectjdoctor c2s fc ta fa no fc ta fa no jdk .
.
.
collections .
.
.
guava .
.
graphstream .
.
.
jgrapht .
.
.
.
total .
.
failing test cases subjectivity might be introduced.
to reduce such subjectivity we mix failing test cases from jdoctor and c2s and developers are unaware of whether test cases belong to jdoctor or c2s.
moreover false alarms are checked by multiple developers independently.
when a disagreement occurs all developers involve to discuss to resolve it.
from the results we can see that jdoctor s specifications lead to a much higher false alarm than our specifications do .
vs. .
on average .
this results from two main reasons.
the first one is that jdoctor s pattern matching and lexical similarity to identify subjects e.g.
parameters in comments are relatively inaccurate.
the second one is that jdoctor does not have an automatic approach to eliminate wrong specifications.
by contrast we leverage our specification checker to automatically prune out incorrect specifications.
the columns no shows the number of new oracles generated based on specifications.
multiple test cases may be generated for a method using the same oracle.
such cases are only counted as one oracle.
note that the number of new oracles generated using our specifications is much higher than that of jdoctor beacause c2s can generate much more normal post conditions than jdoctor.
.
improving identifying leak paths to answer rq3 we leverage flowdroid to conduct taint analysis on android applications to detect undesirable information leak paths.
flowdroid does not analyze library functions.
instead it accepts taint wrappers to model the information flow of library methods to achieve more precise results.
consider the method remove int of class arraylist we can specify the flow from the first parameter of remove int to the return value and thus flowdroid can use the flow to analyze code that invokes remove int without analyzing the body of the method.
our specifications describe relations between parameters and the return value and thus can be utilized to extract information flow model of a library method.
we limit the sinks to internet access and files writing and set a minutes timeout for each app in our experiments.
we ran flowdroid on android apps in three modes without using any taint wrapper with taint wrappers containing data flow information extracted from jdoctor s specifications and with taint wrappers from our specifications.
we compare the number of reported information leak warnings and the performance which are summarized in table .
the first column lists the apps among which some are from the droidbench micro benchmark suite such asarrayaccess1 and they are selected since they use library methods.
in order to demonstrate our specifications are beneficial to identify leak paths for different kinds of applications including open source and commercial software benign applications and malwares we classify applications that use these library methods 34c2s translating natural language comments to formal program specifications esec fse november virtual event usa table static taint analysis comparison result apkno tw jdoctor tw c2s tw p t p t atp p t atp arrayaccess1 .
.
.
alipay .
.
.
broncos news .
.
.
opentable .
.
.
wikipedia .
.
.
tencentnews .
.
.
droidkungfu .
.
.
santander .
.
.
enriched1 .
.
.
avira antivirus security .
.
.
total into the aforementioned categories and randomly pick some out of each category.
the number of leak paths and the time in seconds used to do the analysis in the three experiments are shown in columns pand t. the atp columns and present the additional number of true leak paths that are identified using jdoctor s specifications and our specifications but cannot be identified when no taint wrapper is used.
in summary the results illustrate that with our specifications more leak paths can be identified for apps within an acceptable time that is comparable to the analysis time when no taint wrapper is used while only more leak paths can be identified for apps using jdoctor s specification.
discussion .
threats to validity one threat to external validity is that it is possible the space of tokens that compose specifications collected from jdk would cause low accuracy when synthesizing specifications for other projects.
to mitigate this we introduce an intermediate representation to capture the expected behaviors of a method which can be instantiated into a concrete specification for a target method.
another threat lies in that our subject projects and classes might not be representative of true practice.
to minimize this we conducted the evaluation on representative projects that provide diverse functionalities from graph handling to efficient data structures.
the threat to internal validity is the accuracy of our c2s in synthesizing specifications.
to alleviate this we verified the correctness of each generated specification by running developer written test cases.
in addition as part of our evaluation each specification was manually checked against source code by two developers.
.
generality our technique assumes good quality comments.
empirical studies on comments documentation like have demonstrated over comments documentation are of good quality and useful in practice.
furthermore such assumption limitation is general for most existing work that extracts information from comments like .
despite such limitation these existing efforts and c2s have shown that comments in existing projects can be used to improve various aspects of software engineering.
the value of c2s lies in generating specifications for methods whose specifications do not exist or are incomplete.
it achieves the goal by learning from a small number of existing specifications for alignments .
our technique is general in principle and it is a valuable step towards automated specification generation which isdifficult in general.
although we did not present in the paper c2s works well for c documentation and we believe it can be applied to derive specifications for other programming languages.
related work there are many efforts of generating specifications from source code or natural language comments based on static analysis techniques dynamic analysis approaches mining large scale repositories and nlp techniques .
our work is closely related to approaches that infer specifications by analyzing comments written in a natural language.
these approaches extract specifications from comments by matching handcrafted patterns.
specifically builds an automaton based on the predefined specification template to infer a resource specification to detect bugs.
alics generates procedure pre post conditions that are relevant with strings integers null return and exceptions.
icomment extracts usage rules i.e.
lock related and call related rules to detect bugs or bad comments.
similarly generates parameter constraints to detect directive defects.
acomment generates interrupt related annotations to detect concurrency bugs.
tcomment infers null value related properties of method parameters to detect comment code inconsistencies.
toradocu synthesizes conditions that can trigger exceptions to create test oracles for exceptional behaviors and jdoctor translates code comments to procedure specifications to generate better test cases.
unlike these textual pattern matching approaches our work does not require predefined patterns that demand manual efforts and may be incomplete.
there are other approaches that combine nlp and ml techniques to analyze comments.
in researchers use statistical machine translation techniques to translate exception related documentation to code.
our work leverages alignments which is part of statistical machine translation techniques but we focus on formal specifications and we generate specifications of various perspectives in addition to exceptions.
conclusion we propose an automatic technique to derive formal program specifications from method nl comments by assembling primitive tokens guided by specification syntax and properties of the target method.
we develop a prototype c2s.
our experiments show that c2s can derive specifications efficiently and effectively with .
precision and .
recall substantially outperforming the state ofthe art like jdoctor.
we leverage the generated specifications in a number of software engineering tasks including static taint analysis.
the results show our specifications can improve these tasks.