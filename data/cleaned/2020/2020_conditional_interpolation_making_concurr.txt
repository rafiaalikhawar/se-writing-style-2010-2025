conditionalinterpolation makingconcurrentprogram verificationmoreeffective jie su icttand isn laboratory xidian university xi an p.r.
china jsu 3 stu.xidian.edu.cncongtian icttand isn laboratory xidian university xi an p.r.
china ctian mail.xidian.edu.cnzhenhua duan icttand isn laboratory xidian university xi an p.r.
china zhhduan mail.xidian.edu.cn abstract due to the state space explosion problem efficient verification of real world programs in large scale is still a big challenge.
particularly threadalternationmakestheverificationofconcurrent programsmuchmoredifficultsinceitaggravatesthisproblem.in thispaper anapplicationofcraiginterpolation namelyconditional interpolation is proposed to work together with cegar based approachtoreducethestate spaceofconcurrenttasks.specifically conditional interpolation is formalized to confine the reachable region of states so that infeasible conditional branches could be pruned.furthermore thegeneratedconditionalinterpolantsareutilized to shorten the interpolation paths which makes the time consumedforverificationsignificantlyreduced.wehaveimplemented theproposedapproachontopofanopen sourcesoftwaremodel checker.
empirical results show that the conditional interpolation iseffectiveinimprovingtheverificationefficiencyofconcurrent tasks.
ccs concepts theoryofcomputation verificationbymodelchecking .
keywords softwaremodelchecking concurrentprogramverification statespacereduction conditional interpolation cegar acmreference format jie su cong tian and zhenhua duan.
.
conditional interpolation makingconcurrent programverificationmore effective.in proceedingsof the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 23 28 athens greece.
acm new york ny usa 11pages.
introduction program verification can significantly improve the quality of a program therefore it is widely used in various scenarios.
as an automated verification approach model checking provides an accurateandpath sensitiveanalysistopromisethecorrectnessofa permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
w.r.t.
certain properties.
however due to the exponential growth of paths this approach usually suffers from the state space explosionproblem.particularly verifyingconcurrentprogramis more challenging since thread alternation aggravates this problem.
in orderto reduce the state spaceeffectively abstract interpretationtechnique predicateabstraction inparticular whichmapsaconcreteprogramontoanabstractmodelhasbeen widelyusedinprogramverification.withthisapproach onecan concludethatthereisnoerrorintheconcreteprogramiftheabstractionisconservativeandthereisnoerrorintheabstractmodel .
however over approximation mapping may introduce spurious counterexamples i.e.falsepathswhichviolatethegivenproperty do not correspond to any concrete executions .
to eliminate spuriouscounterexamples counterexample guidedabstractionrefinement cegar approachis proposedtolearn predicatesfrom theexploredfalsepaths whichmakesitpossibletorefinetheabstract modeliteratively .
aninterpolationtechnique specificallycraiginterpolation is often used for generating new predicates to adjust the precision of abstract models .
through utilizing these generated predicates certainpaths willbe pruned and the explorationspace canbefurtherreduced.severalinterpolationapproacheshavebeen proposedtoimprovetheverificationefficiency.forinstance universal safety interpolant andexistential error interpolant are proposedtodeterminewhetherallthepathsemanatingfromastate aresafeornot.however theseinterpolationmethodsarelimitedin performance improvement when verifying concurrentprograms.
in this paper we focus on one of the most challenging tasks proving that a concurrent program satisfies certain reachability properties.
we propose conditional interpolation which can effectively reduce the state space to be explored in the concurrent verification tasks.
specifically we construct the control flow graph cfg ofaconcurrentprogramandunwindittoobtaintheabstract reachability tree art .
during the unwinding process predicates learned from spurious counterexamples are utilized to refine the abstract model.
in addition to the interpolant reachability interpolantfor clarity for parsimonious abstraction a new kind of interpolant namely conditionalinterpolant isintroducedtoeffectively prune redundant paths in art.
different from most of the abstraction refinementapproachesthatpredicatesaregenerated onlywhenerrorlocationsarereached weimmediatelycompute theconditionalinterpolantsateachchoicepointtoavoidexploring infeasible paths.
the generated conditional interpolants are further utilizedto shorten the interpolation paths and thissimplification in return reduces the time consumption for generating otherinterpolants withoutperformance degradation.
144esec fse august 23 28 athens greece jiesu congtian andzhenhua duan.
a a x x b if x c x x p1a intm x b if x c error p2example.cintx b l1 l2 l3 l4 l5 gp1l6a x x b c x x 2d l1 l2 l3 l4 l5 gp2l6a m x b c error d l0 l1 l2 l3 l4l5 l6 l7 l8l9 l10 l11 l12l13 l14 l15 l16 gpx a b ca b ca b ca b ca b ca b ca b ca b c c figure1 a aconcurrentprogramwithtwothreads b eachthreadisrepresentedbyasub cfg dandddenotetheimplicit conditional branches c the cfgofthisconcurrentprogram for thesake ofsimplicity we omitthe branch dandd .
wehaveimplementedtheaboveapproachonthebasisofcpachecker and carried out experiments on the latest concurrency track of sv comp.
empirical results show that compared with otherinterpolationmethods conditionalinterpolationiseffectivein improving the verification efficiency of concurrent tasks.
through conditional interpolation the number of explored states is reduced to .
on average and the number of programs that could be verifiedincreasesby17.
.
the rest of this paper is organized as follows.
section ii introduces the preliminaries.
section iii presents the proposed conditionalinterpolationapproach.insectioniv wepresentanempirical evaluationofourapproach.finally sectionvreviewstherelated work andsection vi concludes the paper.
preliminaries this section presents useful notionsinvolvedinthis paper.
.
control flowgraphsandabstract reachability tree we considera concurrent program pcomposedof multiplethreads thatcommunicatethroughsharedvariables.we extendthedefinitionofcontrol flowgraph ofsequentialprogramstoconcurrent programs as follows definition .
control flow graph cfg let pbe a concurrent program containing n 1threads.
the cfg gp lp tp l0p fp ofpisdefinedastheproductofthesub cfg gpi lpi tpi l0pi fpi of each thread pi i n .
specifically lpirepresents the set of locationsof pi andtpi lpi i lpiisthreadtransition where irepresentstheinstructionsetof pi.notethat forall t tp only onethread pimigratesfromonelocationtoitsdirectsuccessor.the locationsforallotherthreadsremainunchanged.finally l0pi lpi represents the initial location of piandfpi lpidenotes the set of finallocations of pi respectively.
as an example two sub cfgs gp1andgp2of the simplified concurrent program pwhich contains two threads p1andp2as showninfig.
a aredepictedinfig.
b andtheoverallcfg gp isshowninfig.
c .forsimplicity weuseasubscript itouniquelyrepresent a combination of thread locations e.g.
in fig.
c l2 indicates that p1andp2are locatedat l1andl2 respectively .
by unwinding a cfg gp anabstract reachability tree art could be generated.
specifically an art ap s e consists of asetsofabstractstatesandaset eofedges.eachabstractstate s sis a triple s ls cs ps wherels lpis a location in gp csisthecurrentcallstackthatmodelsasequenceoffunction returnaddresses and psisthesetofpredicatesthatconfinesthe reachable region rsof variables.
here rs logicalandtext.
i dotaccps irepresents the reachableregionofabstractstate s and dotaccps irepresentstheevaluation ofpredicate ps i psatstates i.e.
ps ior ps i .forexample if x1 atstates wecanuse rs dotaccps dotaccps x1 x1 toconfine its reachable region where ps ps x ps x .
note that rs truewhenpsis empty.
in addition an edge e eis also a triplee s t s wheresands are abstract states in s t tp is a thread transition where the transition formula tfis encoded accordingtotheinstruction oft.giventwostates sands wesaysiscoveredbys ifls ls cs cs andrs rs .intuitively if statesis covered by s and all the successors of s have been explored wedonotneedtoexplorethesuccessorsof ssinceallthe computationsalong swillbe the same as thosealong s .
a path s0 e0 ... en sn of an art is a finite alternating sequence of states and edges and the conjunction of transition formulas f logicalandtext.1n q 0tqfof is called a path formula .
note that every variable occurring in fis only assigned once i.e.
every formulain fisexpressedintheformofstaticsingleassignment ssa andweintroduceanewsubscripttoavariablewhenitis newlyassigned.finally aconcurrentprogram pissafew.r.t.certain reachability properties if all the error locations l lp e.g.
l4in fig.
c are unreachable.
.
craiginterpolation given two formulas and such that is unsatisfiable if anotherformula satisfiesthefollowingthreeconditions isunsatisfiable and3 everynon logicalsymbolin occurs inboth and wesaythatformula isacraiginterpolant of formulas and andwedenotethisas craig .intuitively isarelaxationof but isstillinconsistentwith .
145conditional interpolation makingconcurrentprogram verification more effective esec fse august 23 28 athens greece s0l0 s1 l1 s2l5 s3l17 s4l18 s5l19 s6 l20 1cb s7 l21dad s8l9 s9l13 s10 l14 s11 l15 s12 l16 2cb s13 l22dac s14 l10ab s15 l6aa s16l2 s17l6 s18 l18 s19 l19 s20 l20 3cb s21 l21dd s22 l10b s23l7 s24 l8 4cb s25 l23da s26 l24d s27l3 s28 l4 5c s29l7abax figure2 theartofexample.cconstructedbyreachabilityanalysisovertheemptypredicateset p.andforthesakeofsaving space we omitthesuccessors ofsquare states.
.
reachability analysis reachability interpolant byusingfirst orderformulas wedefineaglobalset pofpredicates overthesetvofvariablesinaquantifier freetheory.whenexploring an art a finite subset ps pof statesconfines the reachable region of variables in v. if a transition formula tfconflicts with thereachableregion rsofprecursorstate s itsdirectsuccessor s is unreachable.formally foranyedge e s t s e s isreachable only if formula rs tfis satisfiable.
further if s is reachable then the predicate set ps and the reachable region rs are updated by choosing the predicates ps pthat have common variables with the formula rs tf and computing the reachable region rs logicalandtext.
i dotaccps i ps i ps where dotaccps i ps iifrs tf ps iisunsatisfiable ps iifrs tf ps iisunsatisfiable or trueotherwise ps iwillnot be placedin ps .
in fact this update operation builds an relaxation rs ofrs tf i.e.
rs tf rs over the predicates in p. initially the predicate set pis empty.
in order to expand it the interpolation aided cegar approach utilizes spurious counterexamplesto generate interpolants.specifically thereachability interpolant isdefinedas follows definition .
reachability interpolant r intp let s0 e0 ... en sn be a spurious path in an art i.e.
fis unsatisfiable .
for each0 i n the path can be split into two parts a s0 e0 ... si and b si ei ... sn .
then the reachability interpolant of these two parts is pi craig af bf .
meanwhile the predicatesetpcanbeupdated byp p uniontext.1n i pi .
conditionalinterpolation inthissection conditionalinterpolation isintroducedtopruneredundantconditional branchesthatfrequentlyoccurinconcurrent verificationtasks.foreaseofunderstanding weuseamotivating example to illustrate the approach.
.
a motivating example we consider a simplified concurrent program pthat consists of two threads p1 p2 and a global variable xas shown in fig.
a .
it will be regarded as an unsafe program if thread p2could reach the locationl4ofgp2.
initially all the states in fig.
2are reachable because their reachable region rsdefaultsto true.
by depth firstsearch dfs thread p2firstly reaches theerrorlocation l4inpath 1. however 1isa spuriouscounterexamplesincethepathformula 1f x0 x1 x0 x1 m0 x1 x1 trueisunsatisfiable.thus two predicates p0 x andp1 x are generated by applying r intp on 1 and then the algorithm re explores the art from theinitialstate s0.thereafter byreachabilityanalysis weobtain that the predicate set of state s2isps2 p0 p1 and the reachable regionisrs2 x1 x1 .therefore thestate s3isunreachablesincethetransitionformula x1 violatesrs2.similarly afterseveralroundsofabstraction refinement threereachability interpolants p0 x p1 x andp2 x are generated.
all the error locations in this art are unreachable.
hence this concurrentprogramissafew.r.t.theexpectedreachabilityproperty.
in the above verification process the following facts can be observed due to the lack of predicates the conditional branch d x1 in path 1is explored in the initial exploration.
actually d x1 in 1is infeasible since x1 atl5.
thus insufficient predicates may cause redundant exploration.
when checking the feasibility of path 1 the portion that makesthepathformula 1funsatisfiablemainlycomesfrom the conditional branch d x1 orb x1 .
hence conditionalbranchisthekeypointtoavoidredundantexploration.
with thread alternation there are conditional branches departing from location l6.
while in sequential verification tasks each location in an art departs at most conditional branches.
therefore thread alternation makes the occurrence ofconditional branchmore frequent.
146esec fse august 23 28 athens greece jiesu congtian andzhenhua duan.
.
conditional interpolation tosumup thetraditionalabstraction refinementiterationislowin efficiencybecauseanumberofinfeasibleconditionalbranchesmay be explored when predicates are insufficient.
particularly when verifyingconcurrentprograms threadalternationwilllargelyincrease the frequency aconditional branch occursinthe art.
this willaggravatetheredundancyexplorationproblem.thissection proposesconditionalinterpolationtoeffectivelypruneinfeasible conditional branches throughout the verification.
definition .
conditional interpolant c intp let s0 e0 ... en sn beaprefixpathinanart.supposethattherearemultiple immediate conditional branches departing from state sn and the transitionscorrespondingtotheseconditionalbranchesformtheset csn.
then the conditional interpolants at state snis a setpsnof predicates whereeach predicate pc psnis computed by pc braceleftbiggcraig f tf if f tfis unsatisfiable true otherwise.
here tfis thessaformulaoftransition t csn.
intuitively a path that contains infeasible conditional branch is aformofspuriouspathwhichdoesnotcorrespondtoanyconcrete execution.
by conditional interpolation additional constraints are introducedintothe reachableregionto eliminatecertainpaths.
algorithm1 c intp sn input the state snthat needto be explored.
psn create the successor transitionset csnofsn.
csn t tisconditional transitionat state sn compute the conditional interpolants.
fort csndo constructthe path froms0tosn.
s0 e0 ... en sn if f tfisunsatisfiable then pc craig f tf updatepsn.
ifpc true and p c falsethen psn psn pc end if end if end for updatethe reachableregion.
p p psn psn psn psn rsn logicalandtext.1k i dotaccpsn i algorithm 1shows the details of generating conditional interpolantsateachstate.thisalgorithmiteratesovertheconditional branches t csn.
if the conjunction of the path formula fand transitionformula tfisunsatisfiable anewconditionalinterpolant pcis generated by applying the craig interpolation to these two parts.thereafter theglobalpredicateset p andthereachableregionrsnatstatesnareupdatedaccordingly.noticethat different from the existing abstraction refinement approaches where predicates are generated only if error locations are reached the proposed approach immediately computes sufficient amount of predicatesateachchoicepoint.therefore moreattentioncanbe paid to the explorationof feasible paths.
reconsidertheconcurrentprogram example.c infig.
a the art constructed by utilizing conditional interpolant is depicted in fig.
.atstates2 thetransitionformula x1 correspondingto theconditionalbranch dmakesthepathformula x0 x1 x0 unsatisfiable.thus anew interpolant p0 x 1canbegenerated by applying c intp at this state.
thereafter the reachable region rs2 trueisupdatedto rs2 x1 andthestate s3isunreachable sincers2 x1 isunsatisfiable.
similarly anewconditional interpolant p1 x is generated at state s10.
eventually two conditionalinterpolants p0 x 1andp1 x aregenerated and a number of redundant states in the art are avoided from being explored.
theorem1.
conditionalunreachable byutilizingconditional interpolants thestatesgeneratedalonginfeasibleconditionalbranches areunreachable.
proof.let s0 e0 ... sm em sm ... sn beapath.suppose thattheformula tmfw.r.t.thefirstconditionaltransition tmmakes thepathformula logicalandtext.1m q 0tqf tmfunsatisfiable.fromline9ofalgorithm1 theconditionalinterpolant pcgeneratedatstate smispc craig logicalandtext.1m q 0tqf tmf andformula dotaccpc tmfisunsatisfiable.therefore the new reachable region of smisrsm logicalandtext.1k i dotaccpsm i dotaccpc we assumethattheoriginalpredicateset psmcontainsk 1predicates .
according to the reachability analysis described in sub section .
thestatesm 1isunreachablesince rsm tmf logicalandtext.1k i dotaccpsm i dotaccpc tmf isunsatisfiable.hence allthesuccessorstatesof smareunreachable.
according to theorem infeasible conditional branches will not be considered.
hence the state space to be explored will be reducedcorrespondingly.
.
simplifying interpolationpaths inalgorithm bothsatisfiabilitycheckingandcraiginterpolation are time consuming i.e.
lines .
in order to generate conditionalinterpolantsmoreefficiently webuild theshortestconditional interpolationformulachain tofurtherreducetheoverheadofthe above two processes.
the key idea is that at each choice point we trace back along the interpolation path and just preserve the formulas that affectthe decision making.
to start with we use the example program in fig.
a to intuitivelyshowtheapproach.atstate s2infig.
weassumethat theinterpolant p0 x 1hasalreadybeengenerated.thereafter atthechoicepoint s10 weneedtoderivethevaluerangeofvariablex2to determine the feasibility of branch b x2 .
in its prefix path formula f x0 x1 x0 x1 x2 x1 m0 x2 the formula a m0 x2 does not affect the evaluation of x2.
meanwhile all the conditional branches in fare only used for guiding the direction of exploration.
they are redundantfortheinterpolationstep thustheconditionalformula x1 can be removed.
furthermore the first two formulas are redundant because we have already know that x1 at state s2 i.e.
x0 x1 x0 x1 .therefore wecaneasilyobtain 147conditional interpolation makingconcurrentprogram verification more effective esec fse august 23 28 athens greece s0l0 s1 l1 s2l5 x1 s3l17 s4l18 s5l19 s6 l20 1cb s7 l21dad s8l9 s9l13 s10 l14 x2 x2 3 s11 l15 s12 l16 2cb s13 l22dac s14 l10ab s15 l6aa s16 l2x0 x0 s17l6x1 x1 s18 l18 s19 l19 s20 l20 3cb s21 l21dd s22 l10b s23l7 s24 l8 4cb s25 l23da s26 l24d s27l3 s28 l4 5c s29l7abax figure3 theartconstructedbyutilizingtheconditionalinterpolation wheretheblueformulaaroundastate sisthereachable region rs andthegray nodes are regarded as redundant.
thatx1 x2 x1 x2 and the reduced interpolation pathformulais x1 x2 x1 x2 .essentially theabove approach preserves a reference chain of the decision making variablex2whichisusefulinreducingtheconsumptionofsatisfiability checking andcraiginterpolation.
now we formalize the above discussion.
formula is called a simpleformula ifitdoesnotconsistofdisjunctionorconjunctionof otherformulas.let fabethesetofatomicformulas.
faiscalled anatomic formula if it contains a single variable an assignment formulaif it corresponds to an assignment instruction and an assumption formula ifitcorrespondsto anassumption instruction.
definition .
formula affection pair let asgandasube the set of assignment formulas and assumption formulas respectively.
forasimpleformula theformulaaffectionpair a is a braceleftbigg al ar if asg ac if asu here al andar representthesetofvariablesontheleft and right side of the assignment operator of respectively and ac isthevariablesetof .asanexample for x1 x0 ithas a x1 x0 .forconvenience weuse la andra torepresent thefirstand thesecond element of a .
intuitively thevariablesin ra affecttheevaluationofthevariablesin la .therefore wesay that formula affects thevariables in la and is affected by the variables in ra .
forapairofsimpleformulas wecancomputethevariables in that directlyorindirectly affect e.g.
variable x1in x2 x1 affects the truth value of x2 .
formally we use the following functionto compute thesevariables.
definition .
affection transitive function given a simple formula pair where orders before the affection transitivefunction i a a a is defined as i a a asu braceleftbigg la la ra ifla la la ifla la i a a asg braceleftbigg ra la ra ifra la ra ifra la here asuis an implicit assumption formula i.e.
ra .
andwesay affects ifthe rule or3 is applied.
infact if affects theabovefunctionremovesthecommon variables they referenced in la and addsvariables thataffect to maintainthereferencerelationofvariables.asaresult thevariables inla affect .forexample giventwoformulas x1 x0 1and x1 weobtainthat a x1 x0 anda x1 .by applyingtherule i.e.
affects wehave i a a x0 .
forasimpleformulachain 1 ... n wereverselytraverse toextract theformulas iin that affect n.together with n aderivationchain ... m n canbeobtained.notethat the order of the formulas in is the same as in .
formally is aderivation chain of if no variable affects nafter a finite applicationoftheaffectiontransitivefunctionon i.e.
i wherei im a im ... i1 a m a n and2 doesnotcontainanyno effectformula i.e.
onlytherules and3 areapplied ini .
it is emphasized that the formulas corresponding to nondeterministic statements e.g.
intx verifier nodet int aretrue.thatis itispossiblethatwecannotfindaderivationchain of that satisfies i .
in addition for easily tracking the reference relation of variables the derivation of i relies on relatively simple paths whereas the paths that need to analyze complex structures e.g.
pointers are ignoredconservatively.
conceptually theapproachofconstructingaderivationchain slices the formula chain .that is containsthe formulas thataffect n.nevertheless interpolationwith isnotefficient enough.
for example in fig.
the derivation chain of x0 x1 x0 x1 x2 x1 m0 x2 x2 corresponding totheprefixpath atstates11is x1 x2 x1 x2 wheretheassumptionformula x1 3isuselessforinterpolation since it is just for guiding the direction of exploration.
further the conditionalinterpolant p0 x 1atstate s2isnotfullyusedinthe derivationchain.asamatteroffact x1 x2 x1 x2 is enough for the interpolation.
with this in mind the shortest conditionalinterpolationformulachain isdefined.
definition6.
theshortestconditionalinterpolationformula chain let s0 e0 ... sj beafeasibleprefixof s0 e0 ... sj ej sj ... sn tjfbe the assumption formula corresponding to the conditional branch ej andfc dotaccpsic psic psi fa i j 148esec fse august 23 28 athens greece jiesu congtian andzhenhua duan.
be the atomic formula set of conditional interpolants along .
by combiningthesetfcandformulasin f weobtaintheformulachain dotaccps0c t0f dotaccps1c ... tj 1f dotaccpsj c tjf .
is the shortest conditional interpolationformulachain of if is aderivationchain doesnotcontainanyassumptionformulathatoccursin any variable in corresponds to one atomic formula at most.
algorithm2 simplifyintppath sn tn input an abstract state sn and the conditional transition tnatsn.
output theprefixformula foftheshortestconditionalinterpolation formula chain .
fd buildthe pathfrom s0tosn.
s0 e0 ... en sn constructthe formula chain.
fc dotaccpsic psic psi fa i n dotaccps0c t0f ... tn 1f dotaccpsnc tnf number eachformula in for convenience.
1 ... 2n 2n 2n generate the shortest c intpformula chain .
a a 2n for i 2n i i i do ifla and ra then break end if if i asu fcthen remove redundant c intpformulas.
fd fd fd fcand la la i backwardderivation.
a i a i a ifusedrule or3 then fd fd i end if end if end for ifla and ra then sortformulas in fdinthe order as they occur in .
... m tnf else existnon deterministic variable.
true end if f logicalandtext.1m i 0 i return f the above definition ensures that contains the core formulas that affect the decision making.
meanwhile all the assumption formulas in which are unnecessary for the interpolation are removed.theredundantatomicformulas mostofthemaretheformulas corresponding to conditional interpolants are also removed.
different from predicate based slicing that uses predicates as indicators forprogramstatementselection conditionalinterpolants as constraints of variables are directly involved in the construction offormula chain.in algorithm we build the initial interpolation chain and construct the shortest c intp formula chain .
thereafter the path formula fin lines of algorithm 1is replaced by the global formula f. to generate we remove the formulas that are redundant forthe interpolation i.e.
lines and search the formulas ithat affect tnf.
after that if a complete variable referencechainisbuilt couldbereconstructedbysortingthe formulas infdin the orderas they occur in and adding the last conditional formula tnf.
note thatfdpreserves thecore formulas.
backtotheexampleprograminfig.
a atstate s10offig.
we havefc dotaccps2c x1 and x0 x1 x0 x1 x1 x2 x1 m0 x2 x2 .
by applying rules and1 it hasfd x2 x1 anda x1 .thenweskiptheuseless assumption formula x1 and apply rule again the shortest conditional interpolation chain x1 x2 x1 x2 is obtained and f x1 x2 x1 .
thereafter by applying craig f x2 a new conditional interpolant p1 x is generated.
compared with the interpolation chain the length of the newchain isshortenedbyhalf.
.
verification with conditional interpolation nowweshowhowthereachabilityinterpolationandconditional interpolation work togetherto effectively verify reachabilitypropertiesofconcurrentprograms.
start inputp buildgp unwindgp buildap s e exist new statessafeproduce reachable state s adds ins explore state s l c p r intpsis coverd computeconditional interpolants and update simplifyinterpolation path lis an error loc.spurioushave cond.
braches unsafeno yesno yes yesyes noyesno no figure the verification flowchart that combines the conditional interpolation and reachability interpolation.
the parts in red dashed rectangle is the proposed c intp approach.
as shown in fig.
the verification process of a concurrent programpstarts from the construction of gp.
then through unwinding the cfg gpfrom the initial state s0 l0 an art ap 149conditional interpolation makingconcurrentprogram verification more effective esec fse august 23 28 athens greece table concurrentbenchmark no.packages files kloc 1goblint regression .
2ldv linux .
races .
3ldv races .
4pthread .
5pthread atomic .
6pthread c dac .
7pthread complex .
8pthread divine .
9pthread driver races .
10pthread ext .
11pthread lit .
12pthread nondet .
13pthread wmm .
total .9table experimentalresults no.r interpchecker r c cor.
inc. unk.
cor.
inc. unk.
cor.
inc. unk.
total rveri .
.
.
isconstructedgradually.duringtheunwindingprocess ifanew states l c p is located at an error location then a counterexample path s0 e0 ... s is constructed from the initial state s0.
ifthiscounterexampleisnotspurious weconcludethattheconcurrent program pviolates the reachability property.
otherwise the r intp will be performed on path to generate reachability interpolants.ifstate shasimmediateconditionalbranches thenthe shortestconditional interpolation formula chain isconstructed by simplifying the interpolation path.
the conditional interpolants and reachable region are generated and updated respectively by utilizing .subsequently ifstate siscoveredbysomestateswhich are visited previously then we do not need to explore its successors.otherwise thereachablesuccessorsofstate saregenerated.
theabove explorationstepswill stop if no new state shouldbe explored or2 areal counterexample isfound.
theabstract modelconstructed throughthe aboveverification process is conservative i.e.
the property is proved when the verificationprocessterminatesandnoerrorpathisfound.whenitgives the unsafe answer a real counterexample is returned.
otherwise itgivesthe safe answer andtheconstructedartformsaproof ofthe reachabilityproperty.
experiments wehaveimplementedtheproposedconditionalinterpolationontop of the open source model checker cpachecker which supports thereachabilityinterpolationaidedcegaralgorithm.cpachecker provides an efficient analysis frameworkfor program verification and our tool augments it with the proposed conditional interpolation.
the smt solver mathsat5 is employed to efficiently compute the craig interpolants and perform satisfiability checking.
meanwhile cartesian abstraction sbe configuration is applied to compute the reachableregionofeachstate.
the concurrency track of sv comp1is adopted as the benchmark for evaluating our approach.
the properties that a task need tobeverifiedarespecifiedinthetask definitionfile i.e.
intheform .yml .
there are packages with totally verification tasks in this benchmark where of them are used for reachability property verification.
as shown in tab.
the second column presentsthenameofeachpackage thethirdcolumndenotesthe amountoftheprogramsineachpackage andthefourthcolumn givesthetotallinesofcodeineachpackage.alltheexperimentsare performedonaserverrunningtheubuntu18.04ltssystemwitha .6ghzcpuand735gbram.wesetthetimeboundandmemory limitationfor eachtaskto minutesand14 gb respectively.
ourworkfocusesonthechallengeofprovingwhetheraconcurrentprogramsatisfiescertainreachabilityproperties whilemost of the tools e.g.
the gold medal winner lazy cseq in the latestsv comparebugfinders.toexaminetheimprovementof verificationefficiencywithotherinterpolationapproaches wecompare the experimental results of the reachability interpolant aided cegar algorithm r the work in interpchecker and the conditional interpolant aided cegar approach r c where r and c represent r intp and c intp respectively.
it is worth noting that alltheinterpolationapproachesareimplementedonthesame abstraction refinement basis i.e.
the cegar approach and the same verification framework i.e.
the cpachecker .
therefore the followingexperimentseliminatetheinfluenceofotherfactorson the validation efficiency of different interpolation methods.
meanwhile the standard benchmarking tool benchexec2is utilized to carry out accurate and reliable experiments of the above interpolationapproaches.onaccountofthatbenchexeccouldnotcurrently exhibit certain information e.g.
the number of explored states the length of interpolation path etc.
we make statistics on the intermediate results generatedbybenchexec.
.
overallexperimentalresults tab.2shows the overall experimental results.
column cor.
represents thenumber of theprograms whose verificationresults are correctlyreported.column inc.givesthenumberoftheprograms whoseverificationresultsareincorrectlyreported i.e.
thereported 150esec fse august 23 28 athens greece jiesu congtian andzhenhua duan.
table comparisonsoveridenticalprograms that are correctlyreported no.r interpchecker r c state refine time state refine time state refine time .
.
.94s .
.
.93s .
.
.35s .
.
.31s .
.
.20s .
.
.51s .
.
.04s .
.
.30s .
.
.77s .
.
.79s .
.
.18s .
.
.93s .
.
.51s .
.
.37s .
.
.56s .
.
.81s .
.
.87s .
.
.82s .
.
.73s .
.
.21s .
.
.93s avg.
.
.
.38s .
.
.09s .
.
.59s resultsareinconsistentwiththetasklabels includingfalsepositivesand false negatives.
column unk.representsthe numberof theprogramswithunknownverificationresults i.e.
theresultsare not given within the time bound or there exist program structures whichcannotbehandledbycpachecker.
rveri ncor ntotaldenotes the percentage of the programs that are correctly verified within the time bound.
here ncorcorresponds to the values in column cor.
and ntotal 1130isthenumberofverificationtasks.
from the experimental results we observe the following facts comparedwithr interpchecker canimprovetheverificationefficiencyofconcurrentprograms howevertheimprovementeffectislimited only .
.
r cisthemostefficientapproach.comparedwithr more concurrent programs .
could be verified by using the conditional interpolants.
whenverifyingaconcurrentprogram interpchecker generates predicates only when it reaches error locations.
if the predicates areinsufficient thereachableregionoftheabstractstateinanart is not precise enough to rule out infeasible paths.
whereas our approach eagerly computes the conditional interpolants at each choice point so that the process of generating predicates does not needtobedelayeduntilspuriouscounterexamplesarefound.thus asufficient amountof predicatescan be generatedefficiently and more attention can be paid to the analysisoffeasible paths.
in tab.
only a few number of packages show that the r c approachverifiesmoreprogramsthanothers.thereasonsareas follows someofthepackages e.g.packagespthread c dacand pthread complex onlycontainafewnumberofprograms.thus the improvementeffectof r conthenumberofverifiedprograms may not significant.
many programs in the first packages cannot becorrectly handledby cpachecker.
hence we select identicalprograms to make performance comparison more clear.
.
comparisonsofcommonly andcorrectly reportedprograms nowwe present theexperimentalresults on the identicalprograms which are correctly reported by the three approaches.
intab.
the column state indicatesthe average numberof explored states the column refine denotes the average times of performed refinement the column timerepresents the average verification time and the row avg.
contains the average values of the three evaluationindexesonthe380correctlyverifiedprograms.thesymbol inthistableindicatesthatnoidenticalprogramsarecorrectly reported by these three approaches and bold values represent betterresults.fig.
5clearlydepictsthequantileplotoftheseresults where x axisdenotes the order ofthese results on thecorresponding evaluation index and y axis represents the time or memory consumption.
from tab.
3andfig.5we can observe that compared with r our approach runs .59s on average whichis87.79sfasterthanthatofr andtheaveragenumber oftheexploredstatesandrefinementtimesarereducedto .
and20.
respectively.
comparedwith interpchecker r cis66.50sfasteronaverage and ourapproachperformsbetteron5 packages.
meanwhile theaveragenumberoftheexploredstatesarereduced to .
.
according to the area under each curve r cneeds less time andmemory onthese380programs.
we also observe that r cperforms worse than interpchecker on package and .
the main reason for this anomaly is that predicates are excessively computed which makes too many predicatesconsideredwhencomputingthereachableregionofsuccessor states.
.
the effect ofpathsimplification on the speed ofc intp we also investigate the effect of simplifying the interpolation path on the speed of c intp.
in tab.
r c represents the c intp with no path simplification i.e.
at each choice point we build a full formula chain from the root state .
the column time here onlydenotestheaveragetimecostontheconditionalinterpolation whichdoesnottakeotheroverheadsintoaccount.column len.
indicates the average length ofinterpolation path.
notethat the lengthoftheprefixesintroducedbyunusedsymbolsinheaderfiles 151conditional interpolation makingconcurrentprogram verification more effective esec fse august 23 28 athens greece nthfastest correct resultcputime s r interpchecker r c nthsmallest correct resultmemory mb r interpchecker r c figure the quantileplot oftimeandmemory consumptioninlinear scale.
isnot included.
row avg.
contains theaveragevaluesof the two evaluation indexes on the identical programs that are correctly reported.
table comparisons of the effects of path simplification on time consumption lengthreduction no.r c r c time len.
time len.
.42s .
.27s .
.27s .
.78s .
.94s .
.76s .
.30s107.
.05s .
.88s .
.31s .
.05s .
.00s .
.90s .
.52s .
.81s .
.49s .
.20s .
.22s .
.16s .
.86s .
avg.
.02s .
.37s .
averagely r c andr cexplores .
and .
states and consumes .81s and .09s respectively.
compared withr c pathsimplificationmakes r capproachabout9.
times faster and the average length of interpolation path are reduced to .
.
in other words only a small portion of formulas in apathneedstobeconsideredwhenperformingc intp.asanaside with no path simplification i.e.
use r c only programs canbeverified.therefore pathlengthisoneofthemajorfactors in limiting the performance of c intp.
in addition over the identicalprograms whicharecorrectlyreportedbyr r c and r c .
.
and .
predicates are generated averagely.
it meansthat morepredicatescouldbegeneratedbyc intpapproach for pruning redundantbranches.
.
otherexperiments the above experiments are carried out on the set of concurrent programs andwealsoappliedthec intpapproachonsequentialprogram verification tasks.
we select packages with totally sequential programs which constitute the subcategory device driverslinux64 ofsv comp andallthesetupsarethesameas the previous experiments.
inthisexperiment r interpchecker andr cverify1158 and1172programsrespectively.tab.
5showsthesequentialbenchmark and the comparison results over the commonly and correctlyreportedprograms andboldvaluesrepresentbetterresults.wenoticethat although r ccanverifymoreprograms the improvement onsequentialverification tasksisnot significant.
the main reason for this phenomenon is that sequential programsare not effected bythread alternation.hence there are less conditionalbranchesandstatesforconditionalinterpolation.meanwhile theoverhead ofthec intpsometimes does notbalancethe pruning gains.
this situation is more common in sequential programswithfewer conditional branches.
related work thestate spaceexplosionproblem aggravatedbythreadalternation is one ofthe mostsignificantchallengesin program verification.
how to alleviate the exponential growth of state space has beenahot spottopic.inthepastdecades manyefficienttechniques have been emergedto moderatethis problem.
.
abstractionrefinementbasedmethods abstract interpretation technique specifically predicate abstraction is efficient in reducing the state space of verification tasks.
the work presented in utilizes craig interpolation to effectively construct a parsimonious abstraction.
infeasible error traces i.e.
cannotbeconcretized willberefutedbythisabstraction.
the approach in continuously builds and refines a single abstract model on demand and after several rounds of abstractcheck refinesteps asetofinterpolantsisgeneratedaccordingto some spurious counterexamples.
whereas in our approach the conditional interpolants can be generated before error locations arereached.ifaninfeasibleconditionalbranchisdiscovered the newly generated conditional interpolant prunes it automatically andmoreattentioncanbepaidtofeasiblepaths.therefore different from most of the abstraction refinement approaches that generate only a few number of interpolants at the end of each iteration 152esec fse august 23 28 athens greece jiesu congtian andzhenhua duan.
table sequentialbenchmark comparisonsoveridenticalprograms that are correctlyreported no.packages files klocr interpchecker r c state refine time state refine time state refine time 1ldv challenges .
.
.
.06s .
.
.06s .
.
.89s 2ldv commit tester .
.
.
.13s .
.
.67s .
.
.43s 3ldv consumption .
.
.
.28s .
.
.34s .
.
.99s 4ldv linux .
.
.
.
.67s .
.
.83s .
.
.11s 5ldv linux .
rc1 .
.
.
.17s .
.
.15s .
.
.26s 6ldv linux .
.
7ldv linux .
rc1 .
.
.
.73s .
.
.71s .
.
.99s 8ldv linux .
simple .
.
.
.26s .
.
.50s .
.
.95s 9ldv linux .
.
.
.
.
.22s .
.
.78s .
.
.26s 10ldv linux .
rc1 mav .
.
.
.41s .
.
.09s .
.
.19s 11ldv linux .
rc1 .
.
.
.78s .
.
.56s .
.
.97s 12ldv validator v0.
.
.
.
.94s .
.
.86s .
.
.65s 13ldv validator v0.
.
.
.
.12s .
.
.50s .
.
.13s total avg.
.
.
.
.25s .
.
.11s .
.
.54s ourapproachcaneffectivelygeneratesufficientamountofconditional interpolantswithinasingleroundof iteration.
thus many infeasibleconditional branches are avoidedfrom being explored.
.
interpolationbasedmethods the work proposed in utilizes interpolants computed by craig interpolationtoobtainacompletemethodforfinite statereachability analysis.
through combining lazy abstraction paradigm an extension work applies decision procedure to individual paths leading to error locations.
this makes it possible to verify infinite state sequentialprograms.themostrelatedworktoours isgivenin whichintegrateslazy abstractionand interpolation based refinement into an explicit value analysis.
this approach determines a location specific precision that is strong enough to refute the false paths in the future explorations.
the follow up work integratestwokindsofinterpolants namelyuniversal safetyinterpolantsandexistentialerrorinterpolants intothecegarapproachtodeterminewhetherallpathsemanatingfroma state are safe or not.
however the above two approaches generate interpolants only when counterexamples are found.
they rarely considerthe infeasibleconditional branches that occur frequently inconcurrentvalidationtasks.thus whenpredicatesareinsufficientorsomeinfeasiblepathsactuallycannotreacherrorlocations redundantstateswillbeexplored.asshownintheexperimental results the universal safety interpolants and existential error interpolantshavelimitedperformanceimprovementinconcurrent programverificationtasks.incontrast ourapproachperformsconditional interpolation at conditional branches which effectively avoids the exploration of a large number of infeasible paths in anart.hence ourapproachimprovesthescalabilityofcegar algorithm inconcurrentvalidation tasks.
.
boundedmodel checking based on the observation that many bugs in real applications have beenfoundtobeshallow boundedmodelchecking which limits the search depthis oftenadopted.esbmc combines symbolicmodelcheckingwithexplicitstate spaceexploration.ittraverses a reachability tree derived from the given system and callsthesmtsolverwheneveraleafnodeisreached.incontrast ourapproach calls smt solver when it finds a counterexample or reaches the states that have conditional branch successor.
to eliminate the uncertainty of thread alternation mu cseq and lazy cseq translate concurrent programs into equivalent sequential programs and bound the times of context switches between different threads.
then the converted programs are verified by the tools for verifying sequential programs.
however all of these approaches can only guarantee the safety property within a given analysis bound.
that means the verification result is imprecise when these approaches give safe answer.
while our verification process will be stopped only when a real counterexample is found or no new statecanbegenerated.theconstructedabstractmodelisconservative i.e.
the property is proved when the verification process terminatesandnoerrorpathisfound.whenourapproachgives safe answer the constructed art forms a proof of a given verification property.
.
othereffectivetechniques by focusing on selected aspects of semantics program slicing technique caneffectivelysimplifyprograms.moststaticslicing approachesutilizeflowgraphasthecoarseabstractprogrammodel which results in an imprecise program slice.
in contrast our approach slices the paths in art and the conditional interpolants make the sliceof interpolation path more accurate.
different from the predicate based slicing where predicatesdo not appear in theconstructedpath conditionalinterpolants astheconstraintsof variables are directly involved in the process of path construction.
the newly generated interpolants along a path are closely related to the conditional interpolants inthis path.
conclusion futurework inthispaper wefocusononeofthemostchallengingtaskofproving whether a concurrent program satisfies certain reachability properties.
at each choice point we apply the proposed conditional interpolation to avoid the exploration of infeasible conditional branch.
compared with other interpolation approaches the proposedapproachcaneffectivelypruneextraconditionalbranches 153conditional interpolation makingconcurrentprogram verification more effective esec fse august 23 28 athens greece and greatlyreduce the state spacein concurrent verification tasks.
experimental results show that more concurrent programs can be verifiedwithinthegivenvalidationtime limitbyapplyingconditionalinterpolation.
in the near future we will further study other interpolation approachestoimprovevalidationefficiency.meanwhile weplanto integrate the partial order reduction technique por into our verification processto avoid the explorationofredundantpaths.