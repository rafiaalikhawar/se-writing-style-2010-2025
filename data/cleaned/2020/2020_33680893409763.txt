detecting critical bugs in smt solvers using blackbox mutational fuzzing muhammad numair mansur mpi sws germany numair mpi sws.orgmaria christakis mpi sws germany maria mpi sws.org valentin w stholz consensys germany valentin.wustholz consensys.netfuyuan zhang mpi sws germany fuyuan mpi sws.org abstract formal methods use smt solvers extensively for deciding formula satisfiability for instance in software verification systematic test generation and program synthesis.
however due to their complex implementations solvers may contain critical bugs that lead to unsound results.
given the wide applicability of solvers in software reliability relying on such unsound results may have detrimental consequences.
in this paper we present storm a novel blackbox mutational fuzzing technique for detecting critical bugs in smt solvers.
we run our fuzzer on seven mature solvers and find previously unknown critical bugs.
storm is already being used in testing new features of popular solvers before deployment.
ccs concepts software and its engineering software testing and debugging.
keywords automated testing blackbox fuzzing smt solvers acm reference format muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang.
.
detecting critical bugs in smt solvers using blackbox mutational fuzzing.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa 12pages.
introduction thesatisfiability modulo theories smt problem is the decision problem of determining whether logical formulas are satisfiable with respect to a variety of background theories.
more specifically an smt formula generalizes a boolean sat formula by supplementing boolean variables with predicates from a set of theories.
as an example a predicate could express a linear inequality over real variables in which case its satisfiability is determined with the esec fse november virtual event usa copyright held by the owner author s .
acm isbn .
of linear real arithmetic.
other theories include bitvectors arrays and integers to name a few.
smt solvers such as cvc4 and z3 are complex tools for evaluating the satisfiability of smt instances.
a typical smt instance contains assertions of smt formulas and a satisfiability check see figs.
2and3for examples .
smt solvers are extensively used in formal methods most notably in software verification e.g.
boogie and dafny systematic test case generation e.g.
klee and sage and program synthesis e.g.
alive .
due to their high degree of complexity it is all the more likely that smt solvers contain correctness issues and due to their wide applicability in software reliability these issues may be detrimental.
tab.
1shows classes of bugs that may occur in smt solvers.
we restrict the classification to bugs that manifest themselves as an incorrect solver result.
for bugs in class a the solver is unsound and returns unsat i.e.
unsatisfiable for instances that are satisfiable.
these bugs are known as refutational soundness bugs in the smt community.
class b refers to bugs where the solver returns sat i.e.
satisfiable for unsatisfiable instances.
a solver is incomplete when it returns unknown for an instance that lies in a decidable theory fragment.
we categorize such bugs in class c. finally bugs in class d indicate crashes where the solver does not return any result.
we call bugs in class a critical for two main reasons.
first such bugs may cause unsoundness in program analyzers that rely on smt solvers.
as an example consider a software verifier e.g.
dafny or a test case generator e.g.
klee that checks reachability of an error location by querying an smt solver.
if the solver unsoundly proves that the error is unreachable e.g.
returns unsat for the path condition to the error then the verifier will verify incorrect code and the testing tool will not generate inputs that exercise the error.
second it is much harder to safeguard against bugs in class a than bugs in other classes.
specifically consider that when an instance is found to be sat the solver typically provides a model that is an assignment to all free variables in the instance such that it is satisfiable.
therefore bugs in class b could be detected by simply evaluating the instance under the model generated by the solver assuming that the model is correct .
if this evaluation returns false then there is a b bug.
bugs in class c are detected whenever the solver returns unknown for an instance that lies in a decidable theory fragment and bugs in class d are detected when the solver crashes.
related work .early work on testing smt solvers presented fuzzsmt a blackbox grammar based fuzzer for generating 701this work is licensed under a creative commons attribution international .
license.
esec fse november virtual event usa muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang table classes of bugs in smt solvers.
gt stands for ground truth and sr for solver result.
gtsrsat unsat unknown crash sat a c d unsat b c d syntactically valid smt instances from scratch for bitvectors and arrays.
since the satisfiability of the generated formulas is unknown the main goal of this fuzzer is to detect crashes in solver implementations class d .
critical bugs class a may only be detected with differential testing when multiple solvers disagree on the satisfiability of a generated smt instance.
the above idea was recently extended to enable fuzzing string solvers by a tool called stringfuzz .
similarly to fuzzsmt stringfuzz generates formulas from scratch.
in addition it can transform existing string instances but without necessarily preserving their satisfiability.
consequently critical bugs in a single string solver cannot be detected given that the satisfiability of the formulas is not known a priori differential testing would again be needed.
even more recently there emerged another technique for testing string solvers which synthesizes smt instances such that their satisfiability is known by construction.
this ground truth is used to derive test oracles.
violating these oracles indicates bugs of classes a and b. note that finding bugs in classes c and d does not require knowing the ground truth.
as a result any of the above techniques can in principle detect such bugs as a by product.
our approach .in this paper we present a general blackbox fuzzing technique for detecting critical bugs in any smt solver.
in contrast to existing work our technique does not require a grammar to synthesize instances from scratch.
instead it takes inspiration from state of the art mutational fuzzers e.g.
afl and generates new smt instances by mutating existing ones called seeds .
the key novelty is that our approach generates satisfiable instances from any given seed.
as a result our fuzzer detects a critical bug whenever an smt solver returns unsat for one of our generated instances.
we implement our technique in an open source tool called storm which has the additional ability to effectively minimize the size of bug revealing instances to facilitate debugging.
contributions .our paper makes the following contributions we present a novel blackbox mutational fuzzing technique for detecting critical bugs in smt solvers.
we implement our technique in an open source fuzzer1that is already being used for testing new features of solvers before deployment.
we evaluate the effectiveness of our fuzzer on seven mature solvers and logics.
we found previously unknown critical bugs in three solvers or nine solver variants and different logics.
.the next section gives an overview of our approach.
sect.
explains the technical details and sect.
describes our implementation.
we present our experimental evaluation in sect.
discuss related work in sect.
and conclude in sect.
.
overview to give an overview of our fuzzing technique for smt solvers we first describe a few interesting examples of storm in action and then explain what happens under the hood on a high level.
in action .one of the critical bugs2found by storm was in z3 s qf lia logic which stands for quantifier free linear integer arithmetic.
we opened a github issue to report this bug which resulted in an eight comment discussion between two z3 developers on how to resolve it.
note that eight comments or in fact any discussion on how to fix a bug is typically uncommon.
from the github issues we have seen developers simply acknowledge an issue or additionally ask for a minimized smt instance.
the issue was closed but re opened a day later with more comments on what still needs to be fixed.
the issue was closed for the last time three days after that.
based on our understanding and explanations by the developers this bug was triggered by applying gomory s cut on an input that did not satisfy a fundamental assumption of the cut.storm was able to generate an instance that violated this assumption and led to misapplying gomory s cut.
the fix in z3 included changing the implementation of the cut.
storm detected another critical bug3in z3 s z3str3 string solver .
according to a developer of z3str3 the bug existed for a long time before storm found it.
during this time it remained undetected even though z3str3 was being tested with fuzzers exclusively targeting string solvers .
a simplified version of the smt instance that revealed the bug is shown on the right of fig.
.
we will discuss it in detail later in this section.
a third critical bug4was found in z3 s tactic for applying dominator simplification rules.
the instance that was generated by storm and revealed the bug spanned lines.
the minimization component of storm reduced this instance to lines.
a simplified version of the instance is shown on the left of fig.
.
we discuss it later in this section.
a developer of the buggy tactic asked us which application generated this instance thinking that it was a tool he developed during his phd thesis.
when we mentioned that it was storm he replied what?
your random generator could have done my phd thesis??
you should have told me sooner .
this demonstrates storm s ability to generate realistic smt instances that can be difficult to distinguish from instances produced by client applications of smt solvers.
in sect.
we describe in more detail our experience of using storm to test both mature solver implementations as well as new features before their deployment.
under the hood .we now give a high level overview of our fuzzing technique which operates in three phases.
fig.
depicts each of these phases.
702detecting critical bugs in smt solvers using blackbox mutational fuzzing esec fse november virtual event usa assert f check satphase seed fragmentation seed s f1 f2 f3 formula ff1 ff2 ff3 tf f initial poolphase formula generation f1 tf2 f3 f construction pool f1 f3 t f1 f2 tassert f2 assert f1 f3 check satphase instance generation new instance f2 t f2 f3 t figure overview of the three storm phases.
declare const sstring assert str .in.re s re .
re.
allchar re .
str .to.re re .
re.
allchar str .to.re aa assert not str .in.re s re.
union re.
allchar str .to.re x jafa check sat declare const sstring assert let a str .in.re s re .
re.
allchar re .
str .to.re re .
re.
allchar str .to.re aa let b not str .in.re s re.
union re.
allchar str .to.re x jafa let c and not b not a not c check sat figure original seed instance from smt comp on the left and simplified instance revealing critical bug in z3 s z3str3 string solver on the right.
declare fun a bool declare fun b bool assert not b assert not and not a b assert a check sat using dom simplify declare fun a bool declare fun b bool assert and not b a check sat using dom simplify figure simplified instance revealing critical bug in z3 s dom simplify tactic on the left and logically equivalent instance not revealing the bug on the right.
the first phase seed fragmentation takes as input a seed smt instances.
for instance imagine an instance with multiple assertions.
each assertion contains a logical formula such as fin the figure potentially composed of boolean sub formulas i.e.
predicates such as f2 f3 f1 f2 andf3in the figure.
initially storm generates a random assignment of all free variables in the formulas ins.
then storm recursively fragments the formulas in sinto all their possible sub formulas.
for example fis broken down into f1 andf2 f3 each of these is in turn broken down into its boolean sub formulas and so on.
the valuation i.e.
truth value of each sub formula torf is computed based on the random assignment.
all formulas together with their valuations are inserted in an initial pool as shown in the figure.
the second phase formula generation uses the formulas in the initial pool to build new formulas.
the valuation of each new formula is computed based on the valuations of its constituent initial formulas.
all new formulas with their valuations are inserted in a construction pool as shown in the figure.
for instance initial formulasf2andf3are used to construct a new formula f2 f3.
the third phase instance generation uses formulas from both pools to generate new smt instances.
the reason for having the two pools is to be able to control the frequency with which initial and constructed formulas appear in the new instances.
instancesgenerated during this phase have a different boolean structure than the seeds.
however their basic building blocks that is the initial formulas that could not be fragmented further remain unchanged.
this is what allows storm to generate realistic instances.
in addition all new instances are satisfiable by construction.
therefore a critical bug is detected whenever an smt solver returns unsat for a storm generated instance.
in such a case storm uses instance minimization to minimize the size of the instance revealing the bug.
examples .the left of fig.
shows a seed instance from the international smt competition smt comp .
starting from this seed storm generated the simplified instance on the right which revealed the critical bug in z3str3 described above.
z3str3 derives length constraints from regular expression membership predicates.
the bug that storm exposed here is that such a length constraint which is implied by membership in a regular expression was not asserted by the string solver.
it is easy to see that the first asserted formula on the left corresponds to variable aon the right while the second asserted formula on the left corresponds to variable bon the right.
therefore the seed essentially checks for satisfiability of a b. on the right c 703esec fse november virtual event usa muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang is equivalent to a b and the instance checks for satisfiability of c thus of a b. this shows that even small mutations to the boolean structure of a formula can be effective in revealing critical issues in solvers.
in fact such mutations can result in triggering different parts of a solver s implementation e.g.
different simplifications heuristics or optimizations.
this is also evidenced by the example in fig.
.
the instance on the left reveals the critical bug in z3 s dom simplify tactic described earlier.
it essentially checks the satisfiability of b a b a which is logically equivalent to b a. observe however that the logically equivalent formula shown on the right of fig.
does not trigger the bug.
consequently the benefit of fuzzing the boolean structure of seed instances is two fold.
first it is effective in detecting critical issues in solvers.
such issues are by definition far more serious and complex than other types of bugs such as crashes since they can for instance result in verifying incorrect safety critical code.
second fuzzing only the boolean structure of seeds helps generate realistic smt instances.
this is confirmed by the above comments on the tactic bug from the z3 developer who thought that the storm instance was generated by his own phd tool.
this was also confirmed by other solver developers with whom we interacted.
our approach in this section we describe our fuzzing technique and how it solves two key challenges in detecting critical bugs in smt solvers how to generate non trivial smt instances and how to determine if a critical bug is exposed.
the latter demonstrates how storm addresses the oracle problem in the context of soundness testing for solvers.
finally we describe how we minimize bug revealing instances to reduce their size.
this step is crucial for solver developers as it significantly facilitates debugging.
.
fuzzing technique given an smt instance as seed input our fuzzing approach proceeds in three main phases seed fragmentation formula generation and instance generation.
seed fragmentation extracts sub formulas from the seed.
these will be used as building blocks for generating new formulas in the second phase.
lastly instance generation creates new satisfiable smt instances based on the generated formulas invokes the smt solver under test on each of these instances and uses the solver result as part of the test oracle to detect critical bugs.
alg.
describes these three phases in detail.
function fuzz takes the initial seed sand several additional parameters that bound the fuzzing process explained below .
as a first step the function populates an initial pool pinitof formulas line with formula fragments of the seed s. to this purpose function populateinitialpool extracts all assertions in the seed and generates a random assignment m i.e.
an assignment of values to free variables.
in our implementation we use a separate smt solver i.e.
different from the one under test to generate a model for the assertions or their negation if the assertions are unsatisfiable .
next we iterate over all predicates i.e.
tree shaped boolean sub formulas as in fig.
in the seed.
we use assignment mto evaluate those predicates for which the treealgorithm core fuzzing procedure in storm .
1procedure populateinitialpool s dmax a getasserts s m randassignment a p emptypool 5foreach pred s if exceedsdepth pred dmax then v istrue m pred p add p pred v 9returnp 11procedure fuzz s nc nm dmax amax phase seed fragmentation pinit populateinitialpool s dmax phase formula generation pconstr emptypool while size pconstr ncdo f1 v1 randformula pinit pconstr op randop ifop and then f2 v2 randformula pinit pconstr f and f1 f2 v v1 v2 else f not f1 v v1 if exceedsdepth f dmax then pconstr add pconstr f v phase instance generation b emptylist m while m nmdo number of generated assertions ac randint amax a emptylist while acdo f v randformula pinit pconstr if vthen negation of fto guarantee assertion satisfiability f not f a append a f ac ac invocation of smt solver under test r checksat a test oracle ifr unsat then b append b a m m returnb depth does not exceed a bound dmax.
this valuation vis crucial for subsequent phases of the fuzzing process and we add both the formula pred andvto the initial pool which is essentially a map from formulas to valuations.
note that by fragmenting the seed the initial pool already contains a large number of non trivial formulas that would be difficult to generate from scratch e.g.
with a grammar based fuzzer .
704detecting critical bugs in smt solvers using blackbox mutational fuzzing esec fse november virtual event usa algorithm depth minimization procedure in storm .
1procedure minimizedepth s nc nm dmin dmax amax 2ifdmax dminthen returns d dmin dmax b fuzz s nc nm d amax 6if0 size b then smin selectseedwithsmallestdepth b return minimizedepth smin nc nm dmin d amax 9return minimizedepth s nc nm d dmax amax in the second phase we populate the construction pool pconstr by adding ncnew formulas of maximum depth dmax.
these formulas are generated randomly by selecting one of two boolean operators logical and lines and not lines .
note that this set of operators is functionally complete thus allowing us to generate any boolean formula.
we construct a new formula fby conjoining two existing formulas f1andf2with valuations v1and v2 in the case of and and negating an existing formula f1with valuation v1 in the case of not .
existing formulas are randomly selected from the pools.
before adding the resulting formula fto the construction pool we derive its valuation vfrom the valuations of its sub formulas lines and .
in essence the second phase enriches the set of existing formulas by generating new ones without requiring a complete grammar for all syntactic constructs.
instead we use a minimal but functionally complete grammar for boolean formulas .
this significantly simplifies formula generation without sacrificing expressiveness.
note that a separate pool for newly constructed formulas allows having control over how many of them are used in the instances generated in the third phase.
on the right of fig.
this step is responsible for generating the formulas on lines and that ultimately amount to checking the satisfiability of a b. once the two pools are populated we use them to generate nm smt instances that we feed to the solver under test.
to assemble a new instance a we create up to amaxassertions acon line by randomly picking formulas from the pools.
if the valuation of a selected formula is true we directly assert it otherwise we assert its negation.
this ensures that all assertions are satisfiable.
of course the same holds for instance aconsisting of these assertions in addition to a satisfiability check.
we now leverage this fact when feeding the smt instance to the solver under test line .
the oracle reveals a critical bug if the solver returns unsat .
.
instance minimization in practice our fuzzing technique often generates bug revealing instances that are very large containing deeply nested formulas and several assertions.
this can considerably complicate debugging for solver developers.
adapting established minimization techniques based on delta debugging might seem like a natural fit for this use case.
however the special nature of critical bugs complicates this task in comparison to other classes of bugs such as crashes.
for minimizing crashing instances it is sufficient to minimize the original instance e.g.
by dropping assertions while preserving the crash .
in contrast for instances that exhibit a critical bug the behavior thatshould be preserved is more involved that is the instance should be minimized such that the buggy solver still returns unsat while the ground truth remains sat.
this requires either satisfiabilitypreserving minimizations or a trusted second solver that can act as a ground truth oracle by rejecting minimizations that do not preserve satisfiability.
unfortunately the only state of the art delta debugger for smt instances ddsmt does not preserve satisfiability.
note that ddsmt is the successor of deltasmt which was used to minimize instances generated by fuzzsmt .
moreover a second trusted solver is not always available e.g.
for new theories or solver specific features and extensions .
to overcome these limitations we developed a specialized minimization technique that directly leverages the bounds of our fuzzing procedure to obtain smaller instances see alg.
for depth minimization .
by repeatedly running the fuzzing procedure on a buggy seed instance this algorithm attempts to find the minimum values fordmaxand amaxthat still reveal a critical bug.
it uses binary search to first minimize the number of assertions analogous to minimizedepth in alg.
and subsequently the depth of asserted formulas.
note that the fuzzing procedure may report multiple bug revealing instances and we recursively minimize the smallest with respect to the bound being minimized line .
our evaluation shows that this technique works more reliably than leveraging ddsmt and a second solver see sect.
.
.
implementation seeds .storm uses the python api in z3 to manipulate smt formulas for generating new instances.
it can therefore only fuzz instances within the logics supported by z3.
in practice this is not an important restriction since z3 supports a very large number of logics.
moreover storm requires seeds to be expressed in an extension of the smt lib v2 input format supported by z3.
note that smt lib is the standard input format used across solvers.
random assignments .storm uses z3 to generate a random model for a given seed line of alg.
.
note however that bugs in z3 resulting in a wrong model do not affect our fuzzer.
in fact given any assignment our technique just requires correct valuations for predicates in the initial pool.
in theory computing these valuations is relatively straightforward since the assignment provides concrete values for all free variables simply substituting variables with values should be sufficient for quantifier free predicates.
in practice we use z3 to compute predicate valuations and have not encountered any bugs in this solver component.
random choices .our implementation provides concrete instantiations of functions randop andrandformula from alg.
as follows.
randop returns and with probability and not otherwise.
function randformula selects a formula from one of the pools uniformly at random but with probability from the initial pool and from the construction pool otherwise.
incremental mode .many solvers support a feature called incremental mode .
it allows client tools to push and pop constraints when performing a large number of similar satisfiability queries e.g.
checking feasibility of paths with a common prefix during symbolic execution .
to efficiently support this mode solvers typically use dedicated algorithms that reuse results from previous queries 705esec fse november virtual event usa muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang in fact smt comp features a separate track to evaluate these algorithms.
to test incremental mode storm is able to generate smt instances that contain push and pop instructions in addition to regular assertions.
experimental evaluation in this section we address the following research questions rq1 how effective is storm in detecting new critical bugs in smt solvers?
rq2 how effective is storm in detecting known critical bugs in smt solvers?
rq3 how do the assertion and depth bounds of storm impact its effectiveness?
rq4 how effective is our instance minimization at reducing the size of bug revealing instances?
rq5 to what extent do storm generated instances increase code coverage of smt solvers?
we make our implementation open source5.
to support open science we include all data source code and documentation necessary for reproducing our experimental results.
.
solver selection we used storm to test seven popular smt solvers which support the smt lib input format and regularly participate in the international smt competition smt comp .
specifically we selected boolector cvc4 mathsat5 smtinterpol stp yices2 and z3 .
in addition to the above mature implementations storm was also used to test new features of solvers.
in particular the developers of yices2 asked us to test the new bitvector theory in the mcsat solver of yices2 which is based on the model constructing satisfiability calculus .
mcsat is an optional component of yices2 which is dedicated to quantifier free non linear real arithmetic.
storm did not find bugs in this new theory of mcsat and the theory was integrated with the main version of yices2 shortly after.
in our experimental evaluation it is therefore tested as part of yices2.
moreover the developers of z3 asked us to test a new arithmetic solver let us refer to it as z3 as which they have been preparing for the last two years.
it comes with better non linear theories and has just replaced the legacy arithmetic solvers in z3.
according to the z3 developers storm could help expedite the integration of this new feature by finding bugs early which it did.
since z3 as has just now been integrated with the current version of z3 and we have only been testing it independently we include it separately in our evaluation.
due to the success of storm in detecting intricate critical bugs in z3 as the z3 developers described our fuzzer as being extremely useful and have now asked us to test z3 s current debug branch let us refer to it as z3 dbg .
z3 dbg implements a variety of new solver features in which storm has already detected a critical bug see sect.
.
.
finally the developers of the z3str3 string solver asked us to provide them with storm generated string instances.
they aware of storm since it detected several critical issues in z3str3 which we reported.
note that z3str3 is developed by the same group of people as stringfuzz .
we therefore suspect that storm found bugs in z3str3 that stringfuzz could not find especially since stringfuzz does not target critical bugs.
the storm generated instances that we provided in addition to the bug revealing ones that we reported were used as a regression test suite during the development of performance enhancements in z3str3.
according to a developer of z3str3 our instances helped reveal critical bugs introduced by these enhancements.
most of these bugs were due to missing or incorrect axioms in z3str3.
.
logic selection in our experimental evaluation for each solver we identified well supported logics based on its participation in smt comp .
in certain cases we also added logics identified as error prone by the solver developers such as qf fp .
in general however storm can handle the intersection of all logics supported by the smtlib v2 input format and all logics supported by z3.
the latter constraint emerges because our implementation relies on z3 s apis for generating the mutated smt instances see sect.
.
tab.
shows the tested logics for each solver.
the second column and second to last row of the table should be ignored for now.
the logic abbreviations are explained in the smt lib standard but generally speaking the following rules hold.
qfstands for quantifier free formulas afor arrays axfor arrays with extensionality bvfor bitvectors fpfor floating point arithmetic ia for integer arithmetic rafor real arithmetic irafor integer real arithmetic idlfor integer difference logic rdlfor rational difference logic lbefore ia ra orirafor the linear fragment of these arithmetics nbefore ia ra orirafor the non linear fragment uf for the extension that allows free sort and function symbols sfor strings and dtfor datatypes.
.
benchmark selection for our experiments we used as seeds all non incremental smtlib instances in smt comp .
we also used all smt lib instances in the regression test suites of cvc4 yices2 and z3.
the second column of tab.
shows how many seeds correspond to each tested logic.
the second to last row of the table unsp.
refers to instances in which the logic is unspecified the solver may use any.
in general we only tested each solver with logics and thus instances it supports.
for seeds without a specified logic we only generated mutations of those that each solver could handle.
.
experimental setup for our experiments we used the following setting for storm unless stated otherwise dmax amax ncbetween and and nmbetween and see alg.
.
both ncand nmwere adjusted dynamically within the above ranges based on the size of the initial pool.
the goal was to use larger values for larger initial pools and thus larger seeds.
we performed all experiments on a core intel xeon e52667 v2 cpu .30ghz machine with 256gb of memory running debian gnu linux buster .
706detecting critical bugs in smt solvers using blackbox mutational fuzzing esec fse november virtual event usa table the tested logics per solver and the number of seed instances per logic.
smt solvers logic seeds boolector cvc4 mathsat5 smtinterpol stp yices2 z3 alia aufnia lra qf alia qf aufnia qf dt qf lra qf rdl qf ufidl qf ufnra ufdtlia aufdtlia aufnira nia qf ania qf ax qf fp qf nia qf s qf uflia uflia auflia bv nra qf aufbv qf bv qf idl qf nira qf uf qf uflra uf uflra auflira lia qf abv qf auflia qf bvfp qf lia qf nra qf ufbv qf ufnia ufdt ufnia unsp.
total comparison with state of the art .except for a single tool all existing testing tools for smt solvers do not use oracles to detect critical bugs.
they therefore require differential testing of multiple solvers to identify such bugs.
in rq2 we evaluate the effectiveness ofstorm at detecting existing critical bugs including the publiclyreported bugs found by the most closely related tool .
recall that this tool supports only the theory of strings.
707esec fse november virtual event usa muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang table previously unknown unique and confirmed critical bugs found by storm in the tested smt solvers.
smt incrementallogicscritical solver mode bugs mathsat5qf fp2qf bvfp yices2qf ufidl2qf uf yices2 qf ufidl2qf uflra z3qf uflia 8qf bv uf lia qf bvfp qf lia z3 qf fp3qf s z3str3 qf s z3 asaufnira 4qf nia auflira qf nra z3 as aufnira z3 dbg qf nia .
experimental results we now discuss our experimental results for each of the above research questions.
rq1 new critical bugs .tab.
shows critical bugs found by storm in the smt solvers we tested.
the first column of the table shows the solvers.
we list z3str3 separately as it is not the default string solver in z3.
the second column denotes whether bugs were found in the incremental mode of a solver which essentially corresponds to a different solver variant.
the third column lists the logics in which bugs were found and the last column shows the number of bugs.
overall storm found critical bugs in three mature solvers or nine solver variants and different logics.
all of these bugs are previously unknown unique and confirmed by the solver developers.
out of the critical bugs have already been fixed in the latest solver versions.
note that the bugs were only detected by storm generated instances i.e.
none were detected by the seeds.
in addition to the bugs in the table storm was also able to detect known bugs as well as other issues i.e.
of classes c and d as a by product which we do not report here.
the feedback from solver developers is very positive and we have been discussing it throughout the paper.
as another example a yices2 developer told us that storm found real bugs and that it is especially useful to have the ability to test the incremental mode of solvers.
he also mentioned that they used to run fuzzsmt on all theories and that now this fuzzer runs continuously on newtheories generating infinite instances.
fuzzsmt however does not target critical bugs and for this reason they run votesmt to differentially test solvers and detect incorrect yices2 results.
despite this storm detected four new critical bugs in yices2.
another yices2 developer commented on the severity of two of the bugs that storm found.
he mentioned that one was in the pre processing component and easy to fix and an obvious mistake in retrospect but it was in a part of yices that had probably not been exercised much .
the other one was much more tricky to trace and fix it was related to a combination of features and optimization in the e graph not localized to a single module .
rq2 known critical bugs .in this research question we evaluate the effectiveness of storm in reproducing known critical bugs.
we therefore collected all critical bugs that were reported for the solvers under test during the three month period between nov and feb .
we focused only on bugs with a subsequent fix i.e.
closed issues on github .
out of the seven solvers we exclude mathsat5 because it is closed source and bugs may only be reported via email.
we also exclude boolector smtinterpol and stp because no critical bugs were reported for these solvers during the above time period.
for the remaining three solvers cvc4 yices2 and z3 there were and critical bugs with a fix respectively after excluding all the bugs that we reported.
we ran storm on the solver version in which each bug was found.
since developers typically add fixed bugs to their regression tests we removed all seeds that revealed any of these bugs without being mutated .
we collected all generated instances for which each solver incorrectly returned unsat .
to ensure that storm actually found the reported bug and not a different one we ran all bug revealing instances against the first solver version with the corresponding fix.
if the solver now returned satfor at least one of the instances we counted the bug as reproduced.
for each of the three solvers storm was able to reproduce cvc4 yices2 and z3 critical bugs so out of a total of .
therefore ifstorm had run on these solver versions it would have prevented approximately of the critical bug reports in a three month period.
given that during this period we reported additional bugs detected by storm in these solvers it is possible that our fuzzer would have been able to reproduce more bugs if it had run longer or if it was being run continuously.
we also ran storm on the publicly reported critical bugs found by bugariu and m ller regardless of when they were reported .
storm was able to reproduce them.
rq3 fuzzing bounds .to evaluate the effect of the fuzzing bounds of storm we only considered closed bugs.
we used all closed bugs reported by us from rq1 except for those in z3 as the original commits could not be retrieved due to a rebase in the branch for a remaining of bugs.
in addition we used all reproduced bugs from rq2 for a total of bugs.
for each of these bugs we randomly selected a seed file that had allowed storm to detect the bug in rq1 or rq2.
we performed eight independent runs of storm with random seeds different from the ones used in rq1 and rq2 to avoid bias to evaluate the effect of the different fuzzing bounds.
storm was unable to reproduce one yices2 bug from rq1 with any of the eight random seeds we therefore do not include it in the results shown in fig.
.
708detecting critical bugs in smt solvers using blackbox mutational fuzzing esec fse november virtual event usa .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
assertion bound amaxnumber of iterations to bugdepth bound dmax figure median number of iterations to find bugs with different configurations of storm .
each bar corresponds to a configuration with a certain depth and assertion bound.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
assertion bound amaxtime to bug in seconds depth bound dmax figure median time in seconds to find bugs with different configurations of storm .
each bar corresponds to a configuration with a certain depth and assertion bound.
for the assertion and depth bounds amax anddmax we used five different settings and .
fig.
shows the median number of iterations i.e.
generated instances until the bug was found for different combinations of these settings.
we can observe thata large assertion bound reduces the number of iterations significantly e.g.
up to 12x for dmax .in contrast the trend for the depth bound is less clear which suggests that it has a less significant effect and is mostly useful for minimizing instances.
we can observe very similar trends when comparing the median time to find the bug see fig.
.
rq4 instance minimization .we now evaluate the effectiveness of our instance minimization.
to this end we collect all instances revealing the bugs of rq3 that are generated by storm with its default configuration sect.
.
.
the results of minimizing these instances using binary search bs and delta debugging ddsmt are shown in tab.
.
we perform eight independent minimization runs and report median results.
instance size is measured in terms of the number of bytes the number of assertions and the maximum formula depth in an assertion.
a dash for ddsmt means either that the instance could not be minimized or that ddsmt does not support a construct in the instance.
as outlined in sect.
.
we had to adapt ddsmt for this use case by invoking a second solver to reject minimizations that would not preserve satisfiability we used the version of the solver that fixed the corresponding bug for this purpose.despite these adaptations we observed that ddsmt could not minimize the instances for bugs and .
we suspect that its search space of possible minimizations might not contain more complex transformations that would be required to both preserve satisfiability andthe bug.
we observed the same outcome when running ddsmt on instances that were first minimized using binary search.
for bugs and ddsmt does not support str .to.re andstr .at which are supported by z3str3.
for bugs and ddsmt does not support check sat using which is supported by z3.
recall that storm accepts seed instances expressed in the extension of the smt lib format that is supported by z3 sect.
whereas ddsmt only supports the standard.
overall this experiment shows that our minimization procedure works more reliably and is able to significantly reduce buggy instances median reduction of .
.
however for the cases where both procedures produced results the ddsmt based minimization procedure was able to produce smaller instances.
this is not entirely surprising given that bs uses the fuzzer which treats predicates not containing other predicates i.e.
ground or leaf predicates as atomic building blocks.
for instance for bug the instance that was minimized with bs contains several complex ground predicates that ddsmt is able to minimize further.
we expect that more involved combinations of the two approaches could produce even better results.
709esec fse november virtual event usa muhammad numair mansur maria christakis valentin w stholz and fuyuan zhang table size of original and minimized bug revealing instances.
instance size is shown in terms of the number of bytes number of assertions maximum formula depth.
bug unminimized minimized minimized id instances by bs by ddsmt rq5 code coverage .a yices2 developer mentioned that they use fuzzer generated instances to enrich their regression tests such that they achieve higher coverage.
in this research question we therefore evaluate whether storm is able to increase coverage.
we selected one of the solvers z3 and four random logics in which we found bugs qf uflia aufnira uf lia .
we then computed the line and function coverage when running z3 on all the instances from smt comp for these logics seeds .
the result is shown in the first row of tab.
.
at the same time we randomly selected instances from each logic and ran storm withnm 500and a single new random seed to generate exactly new instances for each of the seed instances.
tab.
shows that as more instances are generated coverage increases noticeably more lines and more functions after only generated instances .
this demonstrates that running storm on only a small number of seed instances is able to result in a noticeable coverage increase over a large number of instances from a well known benchmark set.
.
threats to validity we identify the following threats to the validity of our experiments.
selection of seeds .storm requires seed instances as input and our results do not necessarily generalize to other seeds .
however we selected as seeds instances from smt comp as well as regression test suites of solvers.
we believe that our selection is sufficiently broad to mitigate this threat.
in addition we make our tool open source so it may be run with different seeds.table code coverage increase as more instances are generated by storm .
generated line function instances coverage coverage selection of solvers .the bugs found by storm depend on the solvers and logics that we tested.
however we selected a wide range of different mature solvers and logics to mitigate this threat.
randomness in fuzzing .a common threat when evaluating fuzzers is related to the internal validity of their results.
to mitigate systematic errors that may be introduced due to random choices of our fuzzer we used random seeds to ensure deterministic results and performed experiments for eight different seeds.
related work smt solvers are core components in many program analyzers and as a result their reliability is of crucial importance.
although it is feasible to verify sat and smt algorithms it is challenging and time consuming to verify even very basic sator smt solver implementations .
verifying state of the art highperformance solver implementations such as cvc4 and z3 is completely impractical.
for these reasons there is a growing interest in testing such solvers alongside related efforts that focus on testing entire program analyzers.
testing sat and smt solvers .fuzzsmt focuses on finding crashes of smt solvers for bitvector and array instances.
it uses grammar based blackbox fuzzing to generate crash inducing instances and minimizes any such instances with delta debugging .
brummayer et al.
extend this line of work to sat and qbf solvers.
in contrast storm performs mutational fuzzing and its minimization procedure leverages the fuzzer and its bounds regarding the number of assertions and the formula depth.
stringfuzz targets testing of string solvers.
in addition to randomly generating syntactically valid instances using a grammar it is also able to mutate or transform formulas in existing instances.
however since not all of its transformations preserve satisfiability it is not easily possible to leverage metamorphic testing to detect critical bugs.
in contrast to both fuzzsmt and stringfuzz the satisfiability of all storm generated instances is known.
recently bugariu and m ller proposed an automated testing technique that synthesizes smt instances for the string theory.
the true satisfiability of the generated instances is derived by construction and used as a test oracle.
in contrast storm performs mutational fuzzing and supports a wide range of theories.
unlike the above approaches that fuzz the input instances of solvers artho et al.
and niemetz et al.
develop model based api testing frameworks for sat and smt solvers.
these focus on testing various api parameters and solver options.
710detecting critical bugs in smt solvers using blackbox mutational fuzzing esec fse november virtual event usa testing program analyzers .kapus and cadar combine random program generation with differential testing to find bugs in symbolic execution engines.
their technique is inspired by existing compiler testing techniques e.g.
csmith and used to test klee crest and fuzzball .
cuoq et al.
use randomly generated programs to test the frama c static analysis platform .
bugariu et al.
present a fuzzing technique for detecting soundness and precision issues in implementations of abstract domains the core components of abstract interpreters .
they use algebraic properties of abstract domains as test oracles and find bugs in widely used domains.
recently taneja et al.
proposed a testing technique for identifying soundness and precision issues in static dataflow analyses by comparing results with a sound and maximally precise smt based analysis they rely on the smt solver to provide correct results.
zhang et al.
develop a practical and automated fuzzing technique to test software model checkers.
they focus on testing control flow reachability properties of programs.
more specifically they synthesize valid branch reachability properties using concrete program executions and then fuse individual properties of different branches into a single safety property.
klinger et al.
propose an automated technique to test the soundness and precision of program analyzers in general.
their approach is based on differential testing.
from seed programs they generate program analysis benchmarks on which they compare the results of different analyzers.
conclusion in this paper we have presented a novel fuzzing technique for detecting critical bugs in smt solvers key components of many stateof the art program analyzers.
conceptually storm is a blackbox mutational fuzzer that uses fragments of existing smt instances to generate new realistic instances.
its formula generation phase takes inspiration from grammar based fuzzers it leverages a minimal but functionally complete grammar for boolean formulas to generate new formulas from fragments found in seeds.
finally it solves the oracle problem by generating instances that are satisfiable by construction.