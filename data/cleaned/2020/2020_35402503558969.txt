what did you pack in my app?
a systematic analysis of commercial android packers zikan dong beijing university of posts and telecommunications beijing chinahongxuan liu peking university beijing chinaliu wang beijing university of posts and telecommunications beijing china xiapu luo the hong kong polytechnic university hong kong chinayao guo peking university beijing chinaguoai xu beijing university of posts and telecommunications beijing china xusheng xiao case western reserve university cleveland united stateshaoyu wang school of cse huazhong university of science and technology wuhan china abstract commercial android packers have been widely used by developers as a way to protect their apps from being tampered with.
however app packer is usually provided as an online service developed by security vendors and the packed apps are well protected.
it is thus hard to know what exactly is packed in the app and few existing studies in the community have systematically analyzed the behaviors of commercial app packers.
in this paper we propose packdiff a dynamic analysis system to inspect the fine grained behaviors of commercial packers.
by instrumenting the android system packdiff records the runtime behaviors of android apps e.g.
linux system call invocations java api calls binder interactions etc.
which are further processed to pinpoint the additional sensitive behaviors introduced by packers.
by applying packdiff to roughly apps protected by seven commercial packers we observe the disappointing facts of existing commercial packers.
most app packers have introduced unnecessary behaviors e.g.
accessing sensitive data serious performance and compatibility issues and they can even be abused to create evasive malware and repackaged apps which contradicts with their design purposes.
ccs concepts security and privacy software and application security software security engineering .
co first author.
haoyu wang is the corresponding author haoyuwang hust.edu.cn .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
commercial android packers dynamic analysis privacy leakage acm reference format zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang.
.
what did you pack in my app?
a systematic analysis of commercial android packers.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
https introduction android apps can be easily decompiled hacked and repackaged by adversaries.
thus repackaged apps and malware are long lasting issues in the mobile app ecosystem.
these attacks pose a serious hazard to both developers and users.
to protect apps from being hacked many security vendors have introduced app security enhancement services i.e.
app packers which usually apply encryption obfuscation and other protections to prevent the app from being analyzed by reverse engineering tools e.g.
apktool and ida .
additionally these services adopt runtime protection to impede the dynamic analysis and unpacking of packed apps.
when a packed app is launched the packers code will be executed before the other part of the code.
in particular the packer s code will first verify the integrity of the app and confirm the secure running environment.
then the app s code can be decrypted and executed.
to hide the technical details i.e.
protecting the packed apps from being unpacked the app packer is usually provided to developers as a black box i.e.
in the form of an online service.
developers upload apps to the android packing service website and the app will be packed by the packing service in the background.
after the packing is completed developers download the packed apps and re sign them.
during the whole process developers do not have direct access to the android packer except the packed app.
thus developers have no way to know what the packing service pack in their apps and what kinds of side effects e.g.
unexpected behaviors and performance issues are introduced by the packing service.
esec fse november singapore singapore zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang indeed there is increasing evidence that commercial packers can introduce undesired behaviors to the original apps.
for example it was reported that qihoo packer once embedded advertisement services in packed apps without the consent of app developers .
besides unwanted side effects app packers can be abused by attackers.
in particular packing services have been exploited to prevent malware from being analyzed as shown in the recent works on android packers .
to study the packed malware and investigate their malicious behaviors these works focus on how to unpack the packed apps i.e.
extracting the original dexfiles from the packed app.
most of these works are based on dynamic analysis i.e.
unpacking the app by modifying the dalvik runtime or art android runtime or relying on emulators .
with the development of unpacking techniques app packers also evolve their packing services to impede these unpacking techniques.
it s an arms race between packing and unpacking techniques.
to the best of our knowledge while there exist studies on unpacking the packed apps few existing studies in the community have systematically analyzed the behaviors of commercial app packers and their side effects.
this however should be more transparent to app developers who definitely have the right to know what has been packed in their own apps.
this work.
in this paper we propose packdiff a comprehensive analysis system to inspect the fine grained behaviors of commercial app packers.
by instrumenting the android system packdiff records the runtime behaviors of android apps including linux system call invocations java api calls binder interactions app component creation and thread activities.
the instrumentation is done via hooking the functions in the linux kernel android runtime and android framework.
as packdiff works on the android system directly app packers cannot easily detect the presence ofpackdiff during the execution of the app and thus packdiff can bypass the runtime protection measures e.g.
sandbox or emulator checking of the packers.
by comparing the app behaviors before and after packing we can accurately pinpoint the additional behaviors introduced by app packers.
by applying packdiff to packaged apps protected by seven commercial android packers packer versions in total we show thatpackdiff can analyze the fine grained behaviors of commercial android packers rq1 including sensitive data access network interactions system information collection additional created app components e.g.
services background resident executions and anti dynamic analysis checks.
we further show that the runtime performance and the compatibility of original apps can be affected by the commercial packers greatly rq2 .
furthermore we investigate whether the commercial packers can be easily abused by adversaries.
the result is disappointing most commercial packers can be abused to help create evasive malware and repackaged apps which suggests that existing security vendors do not have much regulation on the proper usage of app packers rq3 .
this paper makes the following major contributions we proposed packdiff a dynamic analysis system to inspect the behaviors of android packers comprehensively.
taking advantage of system instrumentation packdiff can bypass the runtime checking of packers and compare the behavior difference between the packed app and the originalone.
we have applied packdiff to apps protected by seven commercial app packers and their historical versions and observe that most app packers have introduced unnecessary behaviors including accessing sensitive data collecting device information and network interaction etc.
we measured the impact of android packers on the runtime performance and compatibility of apps.
we show that the average runtime performance overhead introduced by app packers is to for the first start up time and to for memory consumption.
worryingly most packers would introduce serious compatibility issues.
we revealed the dark side of app packers that they can be easily abused to help create and deliver evasive malware and repackaged apps which contradicts with its design purpose i.e.
protecting apps from being hacked .
to boost further research we release packdiff along with dataset used in this paper to the research community.
background .
reverse engineering of android apps android apps are built with java and c c native code.
the code is formed in the apk android application package file structure which is a self signed app.
the dalvik bytecode can be easily statically restored to source code or equivalent expression using decompilers such as baksmali dex2jar and jadx .
for native libraries written in c c language there are many existing mature static analysis tools for analyzing c c binary files including capstone and ida android apps can also be dynamically analyzed in many ways.
linux provides the system call ptrace for dynamic tracking and debugging process running in the system.
by manually debugging the app the implementation of the app can be inspected.
if only a cursory examination of the app is required method profiling or inspection of certain function parameters and return values can be implemented through dynamic binary instrumentation techniques such as frida and xposed framework .
therefore taking advantage of existing app analysis techniques android apps can be easily decompiled analyzed hacked and repackaged by adversaries.
.
android app packer due to the large amount of plagiarism and repackaging in the android ecosystem android app packing technique was introduced and android packers were adopted by a large number of developers as an effective means to protect their apps.
in general the android packers usually protect the apps from three aspects including improving the bar of static analysis protecting apps at runtime and preventing apps from being tampered with.
to impede static analysis android packers protect both dexfiles andsofiles.
the original dexfiles of the apps are usually protected through encryption dynamic releasing i.e.
dynamically releasing the protected data into the memory for execution during the runtime dynamic modification i.e.
modifying dexfiles in the memory when the app is running obfuscation and reimplementing with native code.
furthermore some packers adopted virtual machinebased protection techniques which translate dalvik bytecode to 1431what did you pack in my app?
a systematic analysis of commercial android packers esec fse november singapore singapore another customized type of bytecode and embed a customized virtual machine to interpret them when the packed app runs on a device.
for sofiles android packers protect them using elf file packer or obfuscation tools like obfuscator llvm .
to protect apps at runtime android packers first examine the running environments to prevent the packed apps from running on the emulator which is leveraged by many unpacking techniques to carry out dynamic analysis or environments with root privileges.
on the other hand android packers will check if the app is being debugged or hooked by tools such as frida and xposed frameworks .
additionally android packers usually occupy the debugging interface or detect tool specific features to protect dex files from being dumped from memory.
to prevent apps from being tampered with android packers usually adopt file verification mechanism.
android packers generate a fingerprint for each code file configuration file and resource file.
then they calculate the file fingerprint at application startup and compare it with the original file fingerprint previously calculated.
if the two fingerprints match the app continues to execute.
android packers are widely adopted by existing apps especially malicious apps.
even some third party markets require app developers to pack apps before they are published to the market .
since android packers provide a lot of protection for apps and different security vendors implement their commercial android packers in different ways it is difficult to analyze the detailed behaviors of packed apps directly using traditional app analysis techniques.
.
android system the android system is a hierarchical structure that can be roughly divided into the linux kernel hardware abstraction layer android runtime native c c libraries and java api framework.
next we will introduce the parts that are relevant to our work.
the foundation of the android platform is the linux kernel.
the android runtime relies on the linux kernel for underlying functionalities such as threading file management and low level memory management.
the kernel provides functionalities for apps through system calls.
each system call is assigned a unique system call number and distributed to the corresponding handler according to the system call number in the kernel.
android runtime consists of the art runtime and a set of core runtime libraries.
for devices running android .
or higher each app runs in its own process and with its own instance of the art runtime which is proposed to improve the performance of the android system.
art runtime introduces ahead of time aot compilation.
when the app is installed the dexbytecode of the app is compiled to native code which results in an elf format oat file.
when the app is running the generated oat file is loaded into memory and art runtime can find the native code corresponding to the method of any class to execute according to the segment information stored in the oat file.
in addition android also includes core runtime libraries that provide most of the functionalities of the java programming language such as the ojluni which stands foropenjdk java.lang java.util java.net andjava.io .
java api framework provides the entire feature set of the android os through its apis written in java language.
these apis form the building blocks that developers need to create androidtable an overview of system instrumentation collected information modified system level behavior java api call android runtimesensitive data access anti dynamic analysis check binder interaction android framework sensitive data access linux system call invocation the linux kernelinternet interaction system information collection anti dynamic analysis check component creation android framework additional component creation thread activity android framework background resident execution apps with rich features by simplifying the reuse of core modular system components and services which include content providers view systems and many managers such as the package manager location manager and telephony manager.
android system services provide interfaces for apps to call their functions.
since apps and system services run in different processes android provides an inter process communication mechanism i.e.
binder for apps to interact with both java system services and native system services.
overview of packdiff .
the need of system instrumentation to perform a systematic investigation of android packers we focus on six types of behaviors related to packers including sensitive data access network interaction system information collection app component creation background resident execution and anti dynamic analysis check.
these are all possible behaviors we could enumerate to characterize the packers.
however since commercial android packers provide many protection measures to prevent apps from being analyzed it is difficult to investigate the behaviors of packed apps directly using existing static or dynamic techniques .
to bypass the protection measures we take advantage of system instrumentation to monitor the runtime behaviors of packed apps.
system instrumentation technique refers to directly inserting our customized monitoring code into the system which allows us to monitor app behaviors and is difficult for packers to detect.
thus we need to select the proper instrumentation points to get a comprehensive analysis of the packers.
first the app obtains sensitive data through specific java apis which need to interact with system services through binder and retrieve sensitive data.
second unlike sensitive data some system information that is not relevant to the user is stored in certain system files and apps can obtain system information by accessing these files.
third apps usually transfer data externally via files or networks and there are many ways to access files and networks either through java or native code.
but whichever method is adopted it will eventually be processed by the kernel through system calls.
fourth for additional component creation and background resident execution apps also need to call related java apis.
at last security vendors can provide different anti dynamic analysis mechanisms and most of them need to rely on specific apis or system calls.
therefore through the recording of java api invocation binder interaction linux system call invocation component creation and thread activity we can achieve the aforementioned analysis.
1432esec fse november singapore singapore zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang original app packing service websitepacked app android runtime the linux kernelandroid frameworks core library log of packed applog of original applog processingandroid packers behavior device with packdiffbehavior comparison call stack backtracesensitive data access internet interaction system info collection additional component creation background resident execution anti dynamic analysis check kernel logging modulesystem calls recordsensitive api recordjava logging module art java api callcomponent creation binder interactionthread activity figure the overall architecture of packdiff .
.
overview the overall architecture of packdiff is shown in figure .
we instrument the linux kernel android runtime and android frameworks to collect information on linux system call invocation java api call binder interaction component creation and thread activity.
we monitor the detailed runtime behaviors of the packed app and the original one using packdiff and the generated log information is processed for comparison in the log processing module.
in this way we can accurately pinpoint the additional behaviors introduced by packers.
table summarizes our modifications to the android system the collected information and the corresponding behaviors we can infer.
the details of packdiff in this section we depict each part of packdiff in detail.
.
linux kernel instrumentation we aim to record all necessary system calls invoked by the app by instrumenting the linux kernel.
to this end we first need to identify the threads of the target app and only record the system calls of the corresponding threads.
when a system call is invoked by the target app packdiff records the system call name parameters and return values.
the parameters and return values can be leveraged to capture the behaviors of the apps.
in addition we record the call stack of each system call to distinguish the behaviors of android packers.
during log processing we use system call records to maintain the file descriptor table and memory mapping supplement the call stack and file related behaviors of apps.
.
.
flagging target threads.
as many apps are running simultaneously in android system we flag the threads of the target app in the linux kernel to reduce performance overhead when it starts.
our system instrumentation should only be activated for the flagged threads.
for this purpose we customize a tag for the target threads and obtain their records of system calls.
in the linux kernel each thread is represented as a task struct structure which provides a member variable flags to tag the threads.
this helps us identify all threads of the target app by specifying the customized tag.
after the target app s main thread is started our customized tag would betable the tag of parameters and return values type description resolve at runtime resolve in log processing fd identifier for a file pid process identifier addr memory mapped address path file path string data structure parameters argv parameter list of execve set in the task struct structure through system call prctl which can manipulate various aspects of the behavior of the calling thread and determine the action to be performed based on its option parameter.
specifically we add a branch supported by the option parameter and use this branch to flag the main thread of the target app and start tracing.
after that each time a thread is created by system calls e.g.
fork the entire task struct structure is copied and inherits our customized tag.
as a result all child threads are flagged and traced by packdiff .
.
.
recording system call invocation.
to record the invocation of system calls we leverage the debugging interface for system calls provided by the kernel.
the kernel relies on tif syscall work to determine which threads need to be debugged.
when a thread s tag matches tif syscall work linux kernel will call function syscall trace enter andsyscall trace exit before and after the execution of system calls respectively and we can access the information of the invoked system calls in both functions.
thus we set our customized tag to tif syscall work to activate the functions in the target thread and modify the functions to record the invocation of system calls.
.
.
resolving system call parameters.
the parameters of some system calls can provide useful information regarding the behaviors of packed apps.
thus we seek to resolve these parameters e.g.
mapping the file descriptor to the opened file name.
we mainly retrieve six types of parameters and return values as shown in table .
for the consideration of system performance we put most of the resolution in the log processing phase.
particularly for some parameters and return values of pointer type i.e.
path data and argv it is necessary to parse the content at runtime.
for parameters of type fd i.e.
an identifier for a file we need to know the state of the file description table which records the mapping between file descriptors and opened file names when 1433what did you pack in my app?
a systematic analysis of commercial android packers esec fse november singapore singapore each system call is invoked.
to eliminate potential performance overhead packdiff records the initial state of the file descriptor table at runtime and further maintains the table information in the log processing phase after the test is completed.
to be more specific if a system call is found to create a file descriptor we add it to the maintained file descriptor table if the invoked system call is used to release a file descriptor we delete the corresponding item in the table.
by maintaining the file description table we can know every file that the app touches.
for parameters of type addr i.e.
memory mapped address memory mapping maintenance is completed similar to file descriptor maintenance in which the initial state is first recorded and we continue to maintain during the log processing based on record of system call mmap andmunmap .
.
.
log call stack.
after retrieving the above system calls packdiff uses the system call stack backtrace to determine whether a system call is invoked by the packer.
using the address in each call stack and maintained memory mapping the invoker of the system call can be obtained.
for invocations of system calls that exist only in the record of packed apps we consider them to be behaviors from the packer.
to perform call stack backtrace in arm architecture the frame pointer needs to be activated during android building phase.
figure illustrates the structure of the call stack in 32bit arm architecture after the frame pointer is active.
r7register stores the frame pointer which points to the frame pointer of the last stack and the return address is stored in lrregister.
lr r7 ...... lr r7 ...... small addressbig address figure the structure of call stack in 32bit arm during the system call stack backtrace we determine if the backtrace should be ended by checking whether the frame pointer is still in the stack and whether the address pointed to by the frame pointer is increasing.
.
.
logging module in the linux kernel.
we next introduce the logging module which records the logs from the kernel.
in the linux kernel the log messages are generally output by the function printk .
however function printk does not support the output of large amounts of logs.
first the max buffer size is limited to 2mb and anything over 2mbwill overwrite the previous logs.
second when logs are output at a high frequency in a short period part of the logs will be discarded.
therefore packdiff implements an additional logging module in the linux kernel.
as the size of logs grows the cache size is dynamically extended and a new file where the logs are output is added to the proc filesystem.
.
android runtime instrumentation to record java apis called by the app we set instrumentation in the art runtime and core runtime libraries in android runtime.
.
.
art runtime.
we instrument the entry point of the java api calls in art runtime to record all java apis called by the app.
the art runtime has two execution modes one using the interpreter to execute the java code and the other executing native code generated by ahead of time compilation.
there are two entry points when art runtime executes a java method.
when an app calls a compiled java method art runtime executes the method through method artmethod invoke inart method.cc .
when an app calls a method in java code art runtime interprets the method through function docall ininterpreter common.cc .
based on the instrumentation we can identify api calls related to sensitive data access and anti dynamic analysis.
.
.
core libraries.
to monitor some specific behaviors of the app e.g.
encryption and system command operation in detail we set instrumentation in related runtime libraries.
android includes a set of core runtime libraries that provide most of the functionalities that the java api frameworks use including functions for encryption and system command operation.
we record the corresponding data in these functions e.g.
invoked system commands .
additionally we implement a logging module within package java.util to output information from core libraries and android frameworks which enables code in core libraries and android frameworks to directly import the class of logging system.
.
android framework instrumentation we next instrument the android frameworks to collect information on binder interaction thread activity and component creation.
.
.
binder.
since apps and system services run in separate processes android provides binder an inter process communication mechanism for apps to interact with system services.
as shown in figure android frameworks use native library libbinder to access binder and libbinder invokes ioctl to access the linux kernel through dev binder .
finally the binder driver in the linux kernel completes the interaction between apps and system services.
to record the behaviors of the app using binder we instrument the library libbinder .
we modify the method bpbinder transact in which we can record the accessed system service called system function and the corresponding parameters.
android app android service binderproxy binder servicemanager bpbinder bbinder binder driver dev binderioctl ioctlandroid framework native kernel figure the binder architecture in android .
.
thread.
to analyze the thread activities and the background resident execution behavior of apps packdiff monitors the creation and completion of threads.
we record thread creation via the instrumentation of thread class.
android allows an app to start a thread through a new instance of the java class thread and calling method thread.start .
we record the ownership of new threads in method thread.start .
the created thread will execute the code 1434esec fse november singapore singapore zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang in method thread.run after it starts.
in one case the caller overrides method thread.run .
in the other case a runnable object is passed to thread constructors by the caller.
so we record the actual type of the class thread in runtime and the type of the parameter runnable before the execution of the new thread starts.
to monitor the running threads we add a timer in android frameworks which starts after the app is launched and invoke the method thread.getallstacktraces every seconds.
when a thread disappears from the running thread list we consider the thread finished.
furthermore we can figure out the threads which reside in the background for a long time.
.
.
android app components.
packdiff also monitors the behaviors related to app components.
android provides four different types of app components i.e.
activity service broadcast receiver and content provider which serve distinct purposes.
three components in android must be statically registered in the file androidmanifest.xml while the broadcast receiver can be registered dynamically through the method context.registerreceiver.
thus we instrument this method to capture the dynamic registration of broadcast receiver.
.
.
app launch process.
to start packdiff s monitoring of the target app we activate our instrumentation during the app launch process which can be roughly divided into the following steps step thezygote process creates an app process by executing fork through function forkandspecialize .
step the new process initializes its environment and art runtime and then executes the method activitythread.main .
step activitythread object performs java related initialization and sends a message bind application to the message queue by calling method bindapplication .
step activitythread object processes the message through method handlebindapplication and completes the launch process.
we determine whether the starting app is the target app according to the package name information in forkandspecialize and handlebindapplication function.
we turn on the record switch in the linux kernel through system call prctl after zygote executes fork and turn on the record switch for android runtime and android framework in method handlebindapplication .
evaluation setup .
dataset for a systematic evaluation of android packers we select seven real world commercial android packing services currently available for individual developers including baidu bangcle ijiami qihoo naga manxi and tencent .
these are popular app packing services that serve millions of app developers.
as aforementioned these app packers are black boxes and they can always be updated to deal with increasingly powerful unpacking techniques over time.
to investigate whether the behaviors of these commercial android packers will also change over time we collect apps that are packed by historical versions of commercial packing services from previous research .
besides to examine the service s capability of inspecting the uploaded app we prepare some repackaged apps and malicious apps for evaluation.table summary of our dataset.
android packer dataset2017 dataset2020 dataset2022 datasetmix baidu 2017 qihoo 2017 baidu 2020 bangcle 2020 ijiami 2020 qihoo 2020 tencent 2020 baidu 2022 bangcle 2022 ijiami 2022 manxi 2022 naga 2022 qihoo 2022 qihoo 2022 tencent 2022 malicious app fake app total packed original table summarizes the datasets used in our experiments.
in total we have compiled a list of apps including packed apps original apps and apps used for evaluating whether these commercial services can be abused by adversaries.
.
.
dataset2017.
we collect apps from each of which was packed by two commercial packing services i.e.
baidu and qihoo in april .
thus dataset2017 has a total of packed apps protected by historical versions of packers and original apps.
it is worth noting that these apps declare different permissions which will have a great impact on the behaviors of the packers and we further discuss this in detail in section .
.
.
dataset2020.
we collect the same apps as dataset2017 from each of which was packed by five commercial packing services including baidu bangcle ijiami qihoo and tencent in january .
thus dataset2020 has a total of historical versions of packed apps corresponding to the original apps.
.
.
dataset2022.
dataset2022 is created by interacting with the latest packing services in april including all the seven accessible packing services aforementioned.
on the basis of the same original apps as the first two sets we collect another opensource apps from f droid to expand the dataset.
then we seek to pack these apps using each of the packing services.
as a result we successfully packed all the apps using six of them except for naga where only apps were successfully packed since it allowed us to pack self developed apps only.
besides we notice that qihoo supports additional user selected packing options e.g.
x86 platform support signature verification etc.
we thus tried to check all the options to obtain an alternative version of the packing service marked as qihoo .
however some packing options require specific permissions declared by the app to take effect which prevents many apps from being packed in this way.
at last we have apps successfully packed in this way i.e.
by qihoo .
as a result dataset2022 consists of versions of packed apps from original apps in total using current packing services.
to distinguish between different versions of the packing services for the same app we mark the apps in dataet2017 dataset2020 and dataset2022 in the form of packing service name packing time like qihoo 2017 baidu 2020 manxi 2022 .
1435what did you pack in my app?
a systematic analysis of commercial android packers esec fse november singapore singapore .
.
datasetmix.
to explore whether the commercial app packing services can be abused by adversaries we prepare a set of malicious apps and fake apps that counterfeit well known ones e.g.
fake facebook and wechat apps and intend to upload them to the packing services and check whether these commercial services have strict regulations on the uploaded apps e.g.
malware checking or developer identify checking.
specifically we collected malicious apps from malware families in the most widely used malgenome dataset .
we collected well known apps from google play and baidu app markets which were then resigned by us to create some fake apps.
.
research questions for a systematic summary of the commercial packing service we investigate three main research questions rq1 what behaviors will the packing services add to the app?
rq2 what side effects e.g.
performance and compatibility issues will the android packers bring to the app?
rq3 do the packing services strictly inspect the app before they pack the app?
to answer rq1 we leverage packdiff to analyze the behaviors of packed apps in dataset2017 dataset2020 and dataset2022 and compare them with the behaviors of original apps to pinpoint the difference.
to answer rq2 we test the impact of android packers on app performance through the comparison of the performance difference between the original apps and the packed apps.
for compatibility comparison we purchased commercial compatibility tests on various kinds of real world android devices to aid our study.
to answer rq3 we upload the malicious apps and fake apps in datasemix to the packing service website and check whether we can successfully pack them.
.
experimental environment we conduct the experiments mainly on android .
.
with packdiff and the linux kernel version in android is .
.
.
particularly due to the compatibility issue of apps in dataset2017 we test these apps on android .
.
with packdiff .
in addition to maintain the consistency of the experimental environment all app performance tests were conducted in the unmodified android .
.
on the same smartphone.
all the experiments are carried out on google pixel.
evaluation results .
rq1 inserted behaviors methodology.
we apply packdiff to test every packed app in dataset2017 dataset2020 and dataset2022 as well as their original ones before packing to make pairwise comparisons.
the testing process goes through five steps reboot the device and reset the experimental environment install the app and grant all app requested permissions activate monitoring of apps and start to collect logs launch the app and perform the automated clicks using automation testing tool uiautomator2 after the automated test has lasted five minutes we stop the testing.
finally we process the logs to analyze and compare the behaviors of each app pair.
note that for each app pair we manually devise a testing script to trigger the main functionalities of the app which is usedin step .
we next present our experimental results in terms of six types of behaviors added by app packers.
.
.
sensitive data access.
as shown in table we observe that some commercial packers show sensitive behaviors without consent from app developers including declaring new permissions dynamically checking permissions and calling sensitive apis.
declaring additional permissions.
android packers that provide protections for apps such as encryption and verification should be able to complete without using any additional permissions.
however baidu 2022 and baidu 2020 add new permission declarations toandroidmanifest.xml including access network state internet read phone state access wifi state receive boot completed get tasks and read external storage.
with these permissions android packers can obtain the user s imei phone number sim card information ip address and mac address etc.
and leak sensitive data through the internet.
these permissions are not necessary for the functionalities of packers which should be more transparent to developers.
note that qihoo packer explicitly declares that it needs apps with permissions including access network state read phone state and internet to make the additional function full time crash monitoring work.
the permissions should be declared by developers thus we do not regard it as additional permission declaring.
dynamically checking permissions.
besides declaring new permissions some app packers can also make use of the permissions requested by the app to collect sensitive data stealthily.
in general the app packers first check whether the app has a certain granted permission at runtime.
our experimental results show that baidu 2020 baidu 2022 and qihoo 2017 performed dynamic permission checks through related apis.
it is worth noting that qihoo 2017 does not add any new permission declarations but it checks for permissions when the app runs.
if the app requests some permissions and users grant them at runtime qihoo 2017 uses these permissions to perform the sensitive behaviors.
calling sensitive apis.
after the packed app has been granted sensitive permissions packers can use the permissions to access the corresponding sensitive data.
our experimental results show that baidu 2020 baidu 2022 qihoo 2017 qihoo 2022 and tencent 2020 have additional sensitive api calling behaviors compared with the original apps.
such sensitive behaviors include obtaining imei phone number and sim card information obtaining network information obtaining wifi information and obtaining location information which are not directly related to their main functionalities.
we further analyze the behaviors of the packers in the absence of user interactions and demonstrate that there are no specific trigger conditions for these sensitive behaviors.
.
.
internet interaction.
we observe that some packers perform additional network interaction behaviors.
we query the destination ip address of their network connection from the log and find that baidu 2020 baidu 2022 qihoo 2017 qihoo 2022 and tencent 2020 will frequently communicate with the server of the packing service provider.
for example through analyzing the behavior logs of encryption related apis we find that baidu packer encrypts and encodes the information including the device model system version app version and device mac address and then transmits it to the server belonging to baidu.
1436esec fse november singapore singapore zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang table summary of sensitive data access behavior of commercial android packers android packer declaring new permissionsdynamically checking permissions calling sensitive apis network wifi bluetooth internet audio settings phone telephony wifi connectivity location baidu 2020 baidu 2022 qihoo 2017 qihoo 2022 tencent 2020 table system information accessed by android packers file path file content qihoo 2020 qihoo 2022 qihoo 2022 baidu 2022 tencent 2020 proc cpuinfodevice cpu info proc meminfodevice memory info proc versionlinux kernel compile info proc net tcptcp connection info system build.propandroid compile info .
.
system information collection.
android packers can obtain android device information by accessing system files which contain basic system information such as cpu and memory information android version linux kernel version etc.
table shows the system files accessed by android packers which are mainly used to check whether the app is running on the emulator.
some system information can also be obtained through external processes.
for example ijiami 2020 and tencent 2020 get system properties through command getprop while baidu check whether selinux is enforced by command getenforce .
.
.
app component creation.
we observe that some packers created new app components as listed in table .
by inspecting the androidmanifest.xml we find that baidu 2017 baidu 2020 qihoo 2017 and bangcle 2022 add new components to apps in the file.
further our instrumentation in method context.registerreceiverrevealed that baidu 2022 qihoo 2022 qihoo 2022 and tencent 2020 create broadcast receiver dynamically and listen for system event connectivity change and baidu 2020 registers broadcast receiver for system event screen on screen off and package removed.
these additional app components are supposed to serve the packing functionality but our system monitoring suggests that some of them are not quite related to the packing function.
taking broadcast receiver as an example monitoring system events like connectivity change and screen on is obviously not a necessary behavior for app packing.
table android components added by android packers activity service content provider broadcast receiver baidu 2017 baidu 2020 baidu 2022 bangcle 2022 qihoo 2017 qihoo 2022 qihoo 2022 tencent 2020 .
.
background resident execution.
some android packers show background resident execution behavior.
by tracing the thread operation we find that baidu 2022 baidu 2020 and tencent 2020 create additional threads and keep running in the background after the app is launched.
these packers interact with their servers in separate threads.
in addition bangcle 2022 and tencent 2020 alsocreate new threads where they detect if some important files e.g.
the app s internal storage directory and anr application not responding trace file directory are modified during app running.
.
.
anti dynamic analysis checking.
to prevent the app from being dynamically analyzed the packers perform a set of antidynamic analysis checking to protect the app and the results are shown in table .
packdiff can detect the security checks that depend on the access to key functions or files including detecting java debugging through java api debug.isdebuggerconnected .
detecting whether the key file has been read modified or created via the system call inotify .
detecting manual debugging by calculating execution time using system call clock gettime .
detecting ptrace debugging by checking the tracepid field in proc pid status .
determining if the app is running in an emulator through checking for the existence of virtual machine specific files like dev qemu pipe .
determining if the app is running in the device with root privilege through checking for the existence of feature files like system bin su .
table anti dynamic analysis methods used by packers detect jdb debuggercalculate execution timeprotect filedetecting emulatordetecting ptracedetecting root baidu 2017 baidu 2020 baidu 2022 bangcle 2020 bangcle 2022 ijiami 2020 ijiami 2022 manxi 2022 naga 2022 qihoo 2022 qihoo 2022 tencent 2020 .
.
the evolution of android packers behaviors.
by comparing the behaviors of android packers with multiple versions i.e.
versions and we can see that the inserted irrelevant behaviors from the packing services are gradually decreasing.
among the latest packing services only baidu still accesses sensitive data without the developer s knowledge.
answer to rq1 experimental results show that packdiff can effectively analyze the behaviors of packed apps.
we observe that some commercial packers would involve behaviors that are unnecessary to their main functionalities e.g.
collecting sensitive information.
these behaviors however should be more transparent to developers who use these services to pack their own apps.
1437what did you pack in my app?
a systematic analysis of commercial android packers esec fse november singapore singapore .
rq2 side effects methodology.
we analyze the side effects introduced by android packers by comparing each app pair i.e.
the packed app and the original one in terms of performance and compatibility.
for each tested app we start and stop the app times continuously after installation on the same device with unmodified system1 and record the first start up time average start up time and memory consumption through activitymanager anddumpsys tools.
in addition we purchased an app compatibility testing service with various kinds of real android devices to evaluate app compatibility.
we choose wetest which is a popular app testing platform that helps developers identify compatibility issues such as installation failure crashes and app not responding issues using dynamic analysis on real devices.
it costs about for compatibility tests i.e.
testing one app on one specific device is a test .
note that due to financial constraints we were not able to test all the packed apps on all kinds of devices.
thus we selected apps from our dataset which contain all packing service versions we considered and the testing devices covered the major smartphone manufacturers and all system versions from the minimum supported android version to android .
this comprehensive testing enables us to study the compatibility issues introduced by packers.
original baidu 2017qihoo 2017baidu 2020bangcle 2020ijiami 2020qihoo 2020tencent 2020baidu 2022bangcle 2022ijiami 2022manxi 2022qihoo 2022tencent 202202004006008001000120014001600start up time ms first time non first time figure an analysis of the start up time.
.
.
the impact on app performance.
we analyze the impact of packers on app performance from two aspects start up time and memory consumption .
since packers need to perform protection measures when app starts it inevitably takes longer time for startup than the original app and consumes more hardware resources.
start up time.
figure shows the average start up time andfirst start up time of packed apps and original apps the first column .
app packers can introduce significant performance overhead.
the overhead of average start up time ranges from to and the overhead of first start up time ranges from to .
among all the packing services qihoo 2017 ijiami 2020 and ijiami 2022 are the ones that introduce the largest startup time overhead.
more specifically the average start up time of original apps is 303ms while the average start up time of qihoo 2017 ijiami 2020 and ijiami 2022 are 532ms 461ms and 458ms respectively.
qihoo 2017 1the unmodified system refers to the original android system without packdiff in order to prevent our modifications to the system from compromising performance of the app.table compatibility issues caused by android packers packer version baidu 2017 qihoo 2017 ijiami 2020 bangcle 2020 tencent 2020 baidu 2022 naga 2022 manxi 2022 notes stands for all packed apps crash stands for part of packed apps crash stands for part of packed apps are not responding stands for part of packed apps fail to install.
performs a lot of file operations during the app startup and ijiami performs a lot of string manipulation and file operations which may be the reason for the slow start of the packed apps.
it is worth noting that for all packing services except ijiami 2020 and ijiami 2022 the non first start up time is significantly shorter than the first start up time.
the reasons might be that there are some one time operations and they further perform caching operations for speeding up.
memory consumption.
the average memory consumption overhead introduced by packers ranges from to .
qihoo 2017 and baidu 2020 introduced the largest overhead while tencent showed the least impact on memory usage .
.
.
the impact on app compatibility.
to our surprise most of app packers would introduce compatibility issues as shown in table .
it is worth noting that all original apps were able to pass the compatibility tests.
we can understand that historical versions of packing services are prone to have compatibility issues as they did not consider the newer android versions by design.
however we observe that the latest versions of baidu naga and manxi packers can also cause serious compatibility issues.
for example an app mobi.maptrek cannot be installed on any android versions after it was packed by baidu a self developed app com.rampage.complex packed by naga have no responding issue that we can not access its main ui and a game app app.crossword.yourealwaysbe.forkyz packed by manxi has been found crash issues on android .
answer to rq2 unfortunately most of the commercial packers would introduce serious performance overhead and compatibility issues to the original apps.
even the latest versions of app packers can cause issues including failing to install app crash etc.
app developers should pay special attention to such issues when they are using these commercial packers.
sadly these issues might be hard for developers to fix.
.
rq3 abusing of app packers methodology.
as aforementioned we aim to investigate whether app packers can be used to facilitate the creation of evasive malware and repackaged apps i.e.
whether they will check the submitted apps.
note that we only test five commercial packers in this experiment due to the limitation of naga and manxi packers i.e.
strict manual inspection and restricted usage times thus we did not include naga and manxi in this experiment.
result.
disappointingly we find that most services do not have strict inspections on user uploaded apps which helps the spread of repackaged apps and malicious apps.
1438esec fse november singapore singapore zikan dong hongxuan liu liu wang xiapu luo yao guo guoai xu xusheng xiao and haoyu wang table evaluation results of packing malware and fake apps baidu qihoo ijiami tencent bangcle malware fake app notes all apps can be packed part of apps can be packed.
for the selected malware samples all of them can be successfully packed using baidu and ijiami packers without showing any warning messages.
as a comparison qihoo and tencent can detect the presence of security risks in malware and refuse to pack all the malware samples.
as to bangcle we can successfully pack malware samples.
it suggests that baidu and ijiami packing services did not perform any security checks on the submitted apps while qihoo and tencent have the strongest security checking ability.
as to the fake apps resigned from well known ones baidu qihoo and bangcle did not show any warning and the apps can be successfully packed.
ijiami and tencent can identify a part of them and refuse to pack the apps with messages like the app is not developed by the user .
it suggests that ijiami and tencent may have maintained a database of well known apps and their corresponding developer signatures and they will check the authorship of the submitted well known apps.
answer to rq3 our exploration suggests that these commercial packing services can be indeed abused by adversaries to create evasive malware or repackaged apps.
discussion implications.
all the seven commercial packers we studied in this paper are widely used services adopted by millions of apps.
however we have revealed the disappointing facts that they would introduce serious issues regarding user privacy app performance and compatibility issues and even can boost the creation of malware.
all of these commercial packers are designed by security vendors we argue that they should pay more attention to issues about user privacy service side effects and service regulation.
further for the unsuspecting app developers who have adopted app packers in their apps they should pay special attention to the potential side effects the packers introduced and seek measures to eliminate the impacts.
third for security researchers we believe there is much room for analyzing and optimizing existing mobile app services including app packers and other app enhancement services.
as a result we will release all the artifacts used in this paper to the research community.
limitations.
despite the encouraging contributions this work has three limitations.
first packdiff can only be deployed on the aosp system and google supported devices.
through system instrumentation we can easily bypass the detection provided by android packers and record the information we need.
however implementation based on the system instrumentation can also be undesirable.
for example we cannot make modifications to customized android os without open source code.
thus we cannot deploy packdiff to devices that are not supported by aosp.
second packdiff can only record the app s invocation behaviors but cannot analyze the execution flow inside the function.
for example after the android packers obtain the private data the transfer process of the private data within the process cannot be recorded by packdiff .
third dueto the limited financial budget we only focus on free versions of the commercial packing services.
we will try to analyze the behaviors of the paid versions of the packing services in the future.
related work android unpacking.
android unpacking techniques have attracted the attention of many researchers .
if android packers can be cracked and the dexfiles are extracted from the packed app the original app can be further analyzed using existing static analysis tools.
kisskiss attached the app process using ptrace and searched for dexfiles or odex file header tags in the memory of the packed app process.
then kisskiss dumped the dexbytecode from memory.
dexhunter modified both art and dalvik virtual machine read the temp path of dexfiles from the virtual machine through method hook when the packers call the corresponding apis to load the decrypted dexcode into the virtual machine.
similar to us droidunpack is an android packing analysis framework based on a whole system emulation.
droidunpack mainly focuses on packing related behaviors while our work focuses more on the unnecessary behaviors introduced by android packers and their side effects.
in addition droidunpack relies on emulators which are easily detected.
packdiff is an on device system and is more invisible to packers.
system modifications.
there are many studies that adopt a system modification approach.
modifying the system allows researchers to operate at the low level of the system.
taintdroid implemented a dynamic taint analysis framework by modifying the data structure of the dalvik virtual machine and adding its taint markers.
the flow of private data can be tracked at multi levels and thus behaviors that leak private data can be found.
vpdroid implemented a transparent android os level virtualization platform tailored for security testing based on a customized android system.
it allowed security analysts to customize different device artifacts in a virtual phone without user level api hooking.
toller implemented a tool to provide efficient infrastructure support for ui hierarchy capturing and ui event execution to android ui testing tools based on modifications of android frameworks.
conclusion in this paper we perform a systematic study of commercial android packers.
by instrumenting android system we implement packdiff a dynamic monitoring framework for app packer analysis.
we design a series of experiments to investigate the behaviors and side effects introduced by app packers and reveal a number of disappointing facts.
we advocate the community to pay more attention to app packers and the android packing services should insert as few unnecessary behaviors as possible to protect users privacy reduce the negative impact on apps and enforce regulations on the proper usage of app packers.