understanding solidity event logging practices in the wild lantian li shandong university lilantian mail.sdu.edu.cnyejian liang shandong university yejianliang mail.sdu.edu.cn zhihao liu shandong university zhihaoliu mail.sdu.edu.cnzhongxing yu shandong university zhongxing.yu sdu.edu.cn abstract writing logging messages is a well established conventional programming practice and it is of vital importance for a wide variety of software development activities.
the logging mechanism in solidity programming is enabled by the high level event feature but up to now there lacks study for understanding solidity event logging practices in the wild.
to fill this gap we in this paper provide the first quantitative characteristic study of the current solidity event logging practices using popular solidity projects hosted on github.
the study methodically explores the pervasiveness of event logging the goodness of current event logging practices and in particular the reasons for event logging code evolution and delivers original and important findings.
the findings notably include the existence of a large percentage of independent event logging code modifications and the underlying reasons for different categories of independent event logging code modifications are diverse e.g.
bug fixing and gas saving .
we additionally give the implications of our findings and these implications can enlighten developers researchers tool builders and language designers to improve the event logging practices.
to illustrate the potential benefits of our study we develop a proof of concept checker on top of one of our findings and the checker effectively detects problematic event logging code that consumes extra gas in popular github projects and project owners have already confirmed the detected issues.
ccs concepts software and its engineering maintaining software language features general and reference empirical studies .
keywords solidity ethereum event logging empirical study acm reference format lantian li yejian liang zhihao liu and zhongxing yu.
.
understanding solidity event logging practices in the wild.
in proceedings of the 31st zhongxing yu is the corresponding author of this work and the first three authors lantian li yejian liang and zhihao liu contributed equally to this work.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa association for computing machinery.
acm isbn x xxxx xxxx x yy mm.
.
.
.
joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
nnnnnnn.nnnnnnn introduction ethereum is widely recognized as a distributed single state world computer which innovatively combines the computing architecture of a typical general purpose stored program computer with a decentralized blockchain .
in particular the ethereum platform features the execution of arbitrary programs termed smart contracts which are registered immutably on the blockchain and have their correct executions enforced by the consensus protocol .
as smart contracts are programmable decentralized and transparent they promise to renovate plenty of areas e.g.
financial institutes supply chains and government governance and recent years have witnessed a snowballing application on these areas .
smart contracts are essentially turing complete programs that run in a highly constrained and minimalistic execution environment named ethereum virtual machine evm which runs a particular kind of low level programming language code called evm bytecode .
while in principle any high level programming language could be adjusted to write smart contracts it is extremely cumbersome to adapt an arbitrary language for compliance with evm bytecode.
consequently smart contracts in practice are programmed by a few languages specifically designed for writing smart contracts including for example solidity vyper serpent .
among these languages solidity is up to now the most popular and even widely perceived as the de facto language of ethereum .
solidity features theimperative programming paradigm and its syntax resembles that of javascript c or java.
a solidity contract is first compiled into evm bytecode and then executed by evm on the blockchain.
as smart contract issues can literally cost money the contract code is extremely expensive if not impossible to change after deployment and the whole program state of smart contracts is transparent to everyone it is of vital importance to develop high quality smart contract programs.
however the present quality of solidity programs is far from satisfactory and the literature has reported a variety of issues about even deployed solidity contracts.
we argue that one fundamental reason for this bad status lies in that developers are not adequately acquainted with solidity language features.
being a new programming language solidity offers some new counter intuitive high level language features which are unfamiliar to developers who are even quite adept at programming with other languages of longer history.
as an example solidity features exceptions like many other languages but with a peculiar behavior.
when an exception is thrown it cannot be caught arxiv .12788v1 aug 2023esec fse december san francisco ca usa lantian li yejian liang zhihao liu and zhongxing yu the execution stops and all the side effects including transfers of ether are reverted.
security problems like gasless send can arise because of this.
moreover the formal specification of solidity language features is absent and the current documentation about these features is ambiguous and incomplete.
to ameliorate this issue an effective solution is gathering empirical evidence about thepractices applied by solidity developers when using language features and using the evidence to impact at least four audiences researchers are informed about the real unsolved issues faced by the solidity developers and hence set research agenda to advance the present state of the art.
language designers are aware of whether the language features they design are correctly used by the solidity developers or are instead misused or underused.
tool builders realize how to customize their tools e.g.
coding assistants to the real needs and practices of the solidity developers.
developers understand both the good and bad practices concerned with the use of solidity language features and consequently improve the quality of the written code.
writing logging messages is a well established programming practice and it plays an extremely important role in various software development activities including for example failure diagnosis auditing and profiling.
the logging mechanism in solidity programming is enabled by the highlevel event feature which is an abstraction on top of the logging primitives of evm.
compared to conventional logging solidity event logging features a few distinctions.
first event logging prints the logging message to ethereum blockchain instead of the console or file routinely done by conventional logging.
second while the target application scenario of conventional logging mainly revolves around failure diagnosis the target application scenario of event logging is not well established and varies.
event logging in principle can have a wide variety of application scenarios and the reported scenarios include for example alternative cheaper storage venues and debugging .
given these distinctions it is of vital importance to study how solidity developers use event logging in practice and thus positively impact researchers language designers tool builders and developers to improve the event logging practices.
to fill the gap we in this paper conduct a large scale empirical study about solidity event logging practices in the wild.
in particular we aim to shed light on these three questions rq1 pervasiveness of event logging how common is event logging?
this question aims to explore whether event logging feature is indeed widely used by developers in practice.
rq2 goodness of event logging practice is current event logging practice good enough ?
this question aims to study whether developers use event logging feature in a right way.
rq3 reasons for event logging code modifications why do developers modify event logging code?
this question aims to understand the specific reasons for developers modifications to event logging code.
to answer these questions we choose popular open source solidity projects on github as subjects.
for rq1 we explore the density of event logging instruction in source code.
for rq2 we first study the churn rate according to the code revision history and then separate those event logging code modifications that aretruly modifying event logging code as after thoughts from those that are solely consistency updates along with other non event logging code changes.
we hereafter term the former and latter modifications as independent and dependent event logging code modifications respectively.
by after thought we here emphasize that independent event logging code modifications arise because event logging code is not written right by developers at the first attempt they later detect the problem and modify the event logging code accordingly.
unlike dependent event logging code modifications which are unlikely to reflect much developers concerns over the event logging code itself independent event logging code modifications are prone to reflecting more directly developers concerns over the event logging code.
we thus focus on independent event logging code modifications in this paper.
for rq3 we randomly sample independent event use code modifications and divide them into different categories.
moreover we investigate the details of them to understand the underlying reason for each category.
our large scale study enables us to deliver original and important findings.
in short the findings include the average value of event logging code per project and per line of code loc is .
and .
respectively yet the maximal values can be exceptionally large the average churn rate of event logging code is nearly the same as that of the entire code and a significant percentage with lower bound being .
of event logging code modifications are independent ones within independent event logging code modifications three major change categories include parameter change of event logging code addition of new event logging code and deletion of existing event logging code.
the underlying reasons for these change categories are diverse and notably are related with bug fixing gas saving and debugging support.
we additionally give the implications of our findings and these implications can enlighten developers researchers tool builders and language designers to improve the practices of event logging.
to illustrate the potential benefits brought by our study we develop a proof of concept checker to detect problematic event logging code that consumes extra gas by using storage type variable instead of memory type variable inspired by our finding .
for the top popular github solidity projects our checker detects that projects suffer from this issue in the latest versions of their code with problematic event logging instructions in total .
the owners of projects have confirmed the detected problems and some of them commented that our finding is extremely interesting and can be integrated into the compiler optimization process.
the result certifies that our findings are truly beneficial to tool builders for improving the quality of solidity event logging instructions.
this paper makes the following major contributions we conducted the first large scale and systematic empirical study about solidity event logging practices on popular opensource solidity projects hosted on github.
we presented original and important empirical findings about solidity event logging practices.
we additionally presented implications from our findings and these implications are beneficial for researchers language designers tool builders and developers in order to improve all facets of solidity event logging.
we developed a checker to detect problematic event logging code that consumes extra gas by using storage type variable insteadunderstanding solidity event logging practices in the wild esec fse december san francisco ca usa of memory type variable and the usefulness of the checker has been confirmed.
background .
ethereum basics unlike bitcoin with a quite constrained scripting language ethereum has been designed as a general purpose turing complete programmable blockchain that runs the evm capable of executing smart contracts of arbitrary complexity .
smart contracts will execute transactions automatically in case certain conditions have been met and can invoke other contracts during the execution of transactions initiated by external users.
being a turing complete computing model to ensure that denialof service attacks or transactions that consume excessive resources are avoided ethereum introduces a metering mechanism called gas to control the use of resources by transactions.
more specifically gas measures the computational and storage resources required for different evm instructions and it has an exchange rate relationship with ether the native ethereum cryptocurrency .
the required gases for different evm instructions vary greatly depending majorly on where the associated data reside.
evm can store data in three different places storage memory and stack.
while most instructions cost gas storage usage instructions like sstore can cost as much as gas because storage data are persistent on the blockchain similar to hard drive of computer .
to prevent malicious infinite loops and other forms of computational waste the creator of each transaction needs to set a limit on the amount of gas that they are willing to pay for transaction execution.
if the resource consumption during the execution exceeds the gas limit specified the evm will terminate the execution of the contract.
beyond the initial vision of being a general purpose blockchain the vision of ethereum has rapidly expanded to become a platform for programming dapps i.e.
decentralized applications .
in a dapp smart contracts serve as the backend and are employed to store the business logic program code and the related state of application but the frontend can make use of standard web technologies including typically html css and javascript.
.
solidity event definition and use the message logging in solidity code is achieved by the highlevel event feature which in turn will be compiled into evm logging primitives.
evm has logging primitives log0 log1 log2 log3 and log4 and these primitives can be used to create log records that describe an event within a smart contract.
each log record consists of two parts topic anddata .
the topic part is used to describe what s going on in an event and the data part is the payload value of the event.
the evm logging primitives differ in the number of topics that need to be included in the log record and logi will include itopic s .
the use of topics makes it efficient to find logs by matching topics.
to declare a solidity event we begin with the keyword event then give the identifier and lastly give a list of typed parameters.
in particular we can add the attribute indexed to certain parameters which will make them become the topic parts of the log records produced by evm logging primitives instead of the data parts.
in other words parameters with keyword indexed are searchable.fig.
gives an example of event definition.
for the defined event deposit parameters from and id are searchable.
to use the defined event we begin with the emit keyword then we give the name of the event and finally we provide the arguments if any in parentheses.
fig.
also gives an example of the use of the event deposit .
after the event has emitted the passed arguments are stored alongside the blockchain to allow retrieving them.
more specifically they are stored in the log entries of the transaction receipt which is produced when a transaction completes.
these logs are connected with the contract address and will be incorporated into the blockchain and stay there provided that a block is accessible.
note that an event generated is not accessible from within contracts not even the one which has created and emitted them.
our goal in this paper is to reveal issues with using the event that is defined in a suitable manner we thus concentrate on studying event use for a certain defined event and hereafter event logging code refers to event use code and we use them interchangeably.
.
solidity event applications while conventional logging is mainly used for failure diagnosis the application scenario of solidity event logging varies.
event logging in principle can have various application scenarios and the reported typical scenarios include the following .
execution monitoring to update client front end.
once events are emitted they can be listened for by subscribing to catch these events using ethers.js a complete and compact library for ethereum.
as a result dapps or other light clients can monitor particular events and act accordingly.
in particular the client front end can thus be updated automatically.
alternative cheaper storage venue.
storing data in permanent storage area is extremely expensive in ethereum dominating the gas cost of a typical transaction.
storing the data in log record instead is much cheaper.
thus event logging can serve as an alternative cheaper storage venue.
debugging during development.
events can be used to record specific activities or states that may occur during the execution of a smart contract and thus provide an invaluable source of information into the operation of a smart contract.
by regularly tracking and auditing the log entries generated after events have emitted of the transaction receipt developers can check whether the smart contract is running as expected and quickly identify any potential bugs or security issues that may arise.
methodology .
subjects and data used in our study we use popular solidity projects hosted on github as the study subjects.
borges and valente found through a survey with stack overflow users that the stargazers counts are viewed by practitioners as the most useful measure of popularity on github.
we figure example of event definition and use.esec fse december san francisco ca usa lantian li yejian liang zhihao liu and zhongxing yu figure boxplots for some metrics about the dataset.
thus focus on solidity projects hosted on github with relatively larger stargazers counts.
smaller stargazers counts represent lower popularity and the corresponding projects are more likely written by novice developers and studying these projects will less likely reveal current event logging practices by solidity developers.
as solidity is a relatively new programming language we find that the stargazers counts for solidity projects are small compared to that for other older languages such as java and c .
finally we retrieve all non fork non private solidity repositories whose stargazers counts are larger than at the time of our data collection date september as the study subjects.
the threshold of star is chosen as follows.
we initially crawled solidity repositories hosted on github and randomly sampled repositories to study their features by checking the accompanied project descriptions andreadme files.
the first author conducts the check and reports sample projects e.g.
teach how to write your first solidity program among the repositories and the second author confirms that the reported repositories truly are sample projects.
the stargazers counts for the projects are all less than or equal to .
we thus conjecture that for those projects whose stargazers counts are less than or equal to quite a few are sample projects and there exists serious homogeneity among them.
figure shows boxplots with the distribution of stargazers counts the age in number of months number of contributors and number of lines of code loc exclude the comments and empty lines for the projects in the dataset outliers are omitted .
the average value is respectively .
.
.
and .
for stargazers counts age number of contributors and number of lines of code.
while the code line numbers of the studied projects are typically smaller than that of popular projects written in other languages solidity projects of the studied size are complex and might take much time and effort to audit .
to study the churn rate and evolution of event logging code we need to explore the evolution history.
as the ages of the considered projects are relatively young see figure2b we account for the full evolution history for each project.
in particular we use the rest api to get all non merged commits for each project and further the author name commit log and involved files for each commit.
.
study methodology we investigate numerous aspects of the practices of event logging.
to investigate the density of event logging code we count the loc of the event logging code as well as the loc of the whole program.
to achieve this purpose we develop a small utility which only counts the actual lines of source code and excludes the comments and empty lines.
to recognize the event logging code we make use of the regular expression s emit s w s ?
s .to study the goodness of event logging practice we first contrast the churn rate of event logging code with that of the entire code.
code churn is a metric that indicates how often a given piece of code gets edited.
if a given piece of code receives changes too often that s usually a bad sign.
the code churn rate is calculated aschurned loc total loc where churned loc consists of added modified or deleted code lines.
likewise we measure churn rate for event logging code as churned event use total event use where churned event use consists of event use lines added modified or deleted.
our developed utility parses each revision in the considered commit history to establish the churned code lines and event use lines and then the churn rate is calculated accordingly.
the calculated churn rates for all revisions of a certain project are finally averaged to get the final churn rate for this project.
we further establish the percentage of independent event logging code modifications.
within the studied commit history there are in total event logging code modifications.
within these modifications there exist two kinds some are solely consistency updates along with other non event logging code modifications e.g.
bug fix within the same revision and others are modifications that modify the event logging code as after thoughts.
the same modification categories have been employed to investigate conventional logging code changes and annotation changes .
to distinguish these two kinds one conservative policy is to examine whether the revisions only include changes solely to event use code but not to other non event use code.
using this policy we can get event use code modifications.
these event use code modifications are absolutely independent event use code modifications and account for .
of all event use code modifications.
however the policy above is too conservative as developers are inclined to batch multiple code changes into one revision.
during our analysis of the event logging code modification we made one observation if the variables involved in event logging code modification are not affected by other code changes within the same revision then this event logging code modification is likely to be independent of other code changes.
for instance given the event logging code modification emit send msg.sender id1 emit send msg.sender id2 where send is the name of an event and id1 andid2 are identifiers of two variables the changed variable is id1 and this modification is likely to be an independent modification if id1 is not affected by other code changes within the same revision.
this makes sense because if the values of the involved variables have not changed then the reason for event use code change is very likely that we have not appropriately used the event logging feature at first.
to determine whether a variable is affected we conservatively check whether it is redefined or passed as an argument of a function call within the revision.
on top of this observation we can get independent event logging code modifications which account for .
of all event logging code modifications.
as the result based on this observation can possibly be inaccurate we further randomly sample modifications and manually verify our analysis results on them to see the accuracy of our analysis.
this manual verification step is done by two distinct authors and we deem a checked modification as true independent event logging code modification only when both of the authors have agreed with it.
the manual verification suggests that the accuracy of our analysis is .
the cohen sunderstanding solidity event logging practices in the wild esec fse december san francisco ca usa a event use by project b event use by loc figure density of event use by project and loc.
kappa coefficient is .
for this manual verification indicating a good agreement rate.
there are majorly two sources for the false positive the event logging code modification is on the string text description and the text description is related with changes of other non logging code the event logging code is dependent on a condition and the modifications on the condition result in the event logging code modification.
to understand the underlying reasons for independent event logging code modifications we randomly sample modifications from the absolute independent event logging code modifications which achieves confidence level and confidence interval and investigate their details.
for these sampled modifications we examine developers commit messages about the modifications relevant source code code comment and together with the specific event logging code modifications to understand the modifications.
to minimize our own subjective judgment each modification is checked independently by two authors of the paper.
if they cannot clearly understand the reason or have disagreements with the reason for some modifications we always conservatively classify them into the unknown category when our results are presented.
the cohen s kappa coefficient is .
for this manual check suggesting the agreement rate is good.
the above two manual studies in particular consist of three phases.
in phase one the first two authors of the paper independently derive an initial list of the categories whether or not a modification is independent one for the first study and the reason behind the independent modification for the second study .
in phase two the two authors compare the derived categories and discuss the disagreements and make refinements to their established categories according to the discussion results.
in phase three the cohen s kappa coefficient is calculated based on the refined categories.
similar process has been employed by other works .
rq1 pervasiveness of event logging to begin with we want to see whether event logging feature is indeed widely used by solidity developers in practice.
it is observed that there are event uses in total for the latest versions of the studied projects in this paper.
figure 3a displays the density plot of the event use numbers for the projects.
we can see from the figure that a majority of projects make use of a moderate number of event logging features but a couple of projects make use of an exceptionally large number of event logging features.
in particular the average number of event logging uses per project is .
.
on the whole it can be concluded that the use of event logging feature is pervasive in solidity programming by developers.a potential concern that will arise from figure 3a is whether developers will overuse event logging feature in practice.
by overuse we here hypothesize that event logging feature is used frequently with the value of event use per loc larger than .
and is used in a way that consumes unnecessary more gas.
to check this for each studied project we additionally calculate the value of event use per loc.
the density plot of the calculated value across all the considered projects is shown in figure 3b.
we can see that the value is small for majority of projects yet can be greater than .
or even close to .
for certain projects.
the minimum 1st quartile median 3rd quartile and maximum value is .
.
.
.
and .
respectively and the average value is .
.
in particular among the projects the value is larger than .
for projects.
if the value is greater than .
it suggests that there is an event use for every less than lines of code.
from these data we can see that while majority of the projects have a reasonable value of event use per loc a few projects have an exceptionally large value of event use per loc and thus potentially suffer from the problem of overuse of event logging feature .
we further manually check the projects for which the value of event use per loc is larger than .
.
we find that a major reason for the high value is that developers use several separate events to record transaction related information while the general case is that developers use a single event or at least fewer events to record the information.
as an illustration it can be that the specific event event0 x y z to record transaction related information is replaced by three separate events event1 x event1 y and event1 z .
the recorded information are essentially the same for these two event use cases but using more events will cost more gas.
thus overuse of event logging raises the potential question of whether the corresponding event definitions are appropriate and if not whether refactorings are needed.
finding the average value of event use per project and per loc is .
and .
respectively yet the maximal values can be exceptionally large for both of the two metrics.
for projects with exceptionally high value of event use per loc one major reason is that developers use several separate events instead of a single event to record transaction related information.
implication solidity event logging feature is used pervasively in practice but can be overused occasionally.
ide can warn developers if event logging feature is overused and the numerical data summarized here and detailed online can be referred to set the thresholds.
in addition to save gas when the event is used it is preferable that developers define event in a way that contains more parameters.
these parameters correspond to different aspects of a certain subject to be logged e.g.
the different addresses involved in a transaction .
rq2 goodness of event use practice we first want to check whether event use code is actively maintained.
among all the commits in the studied commit history we find that .
of them involve modifications to event use code.
this suggests that despite the relatively small density of event use code compared to the entire code event use code takes an exceptionally important part of code evolution.
we also compare the code churn rate of the event use code with that of the entire code asesec fse december san francisco ca usa lantian li yejian liang zhihao liu and zhongxing yu figure code churn rate for event use and entire code.
detailed in section .
and figure shows the result.
the average value of code churn rate for entire code and event use code is .
and .
respectively.
thus there is no significant difference between these two code churn rates.
overall we see that event use code has been actively and continuously modified suggesting that solidity developers are actively maintaining event use code for software functionality like they maintain other code.
finding event use code is modified in a significant number .
of all the committed revisions and its average churn rate is nearly the same as that of the entire code.
implication event use code is being actively and continuously maintained by developers and it takes an exceptionally important part of code evolution despite its relatively small density.
as detailed in section .
some event use code modifications are dependent ones and others are independent ones.
for all the event use code modifications we establish a percentage .
of absolute independent event use code modifications using the conservative policy.
moreover we identify a percentage .
of independent event use code modifications using an automatic analysis procedure on top of one observation.
given the accuracy of the automatic analysis is it can be deemed that the automatic analysis identifies a percentage .
.
.
of independent event use code modifications.
considering that other independent event use code modifications can be neglected by our automatic analysis it can be deemed that an absolute lower bound .
and a relaxed lower bound .
of independent event use code modifications have been established.
overall there exists a non neglectable percentage with lower bound being .
of independent event use code modifications.
for these modifications event use code is not written right by developers at their first attempt and developers later detect the problem and modify the event logging code accordingly.
the large percentage of this kind of independent event use code modifications suggests that the current developer practice of using solidity event feature is not good enough and some developers are inclined to use event logging feature in an arbitrary and subjective way.
after detecting the event use problems solidity developers take time and efforts to address them as after thoughts.
by good enough we here mean that if developers use event logging feature in a principled and correct way nearly all of the changes to the event logging code ideally should be consistent updates.
in other words besides consistent updates no or few modifications are needed on the event use code.
thus use of solidity event logging feature good enough will make the percentage of independent event logging modifications very low.
in particular we deem the use of solidity event logging feature as good enough if the percentage of independent event logging modifications is below .
.finding there exists a significant percentage with lower bound being .
of event use code modifications that are independent of other non event logging code changes.
implication the current practice of using event logging feature is not good enough introducing issues to the quality of event logging that developers will address as after thoughts.
tools that support the systematic testing of event logging behaviours would be helpful.
besides the solidity event logging feature should be more extensively discussed in books and tutorials so that developers can make better informed implementation decisions.
6rq3 reasons for event logging code modifications in this section we give the results of our manual analysis of the randomly sampled independent event use code modifications.
overall the modifications can be divided into categories as shown in table .
the particular meanings of the categories are as follows the category parameter change means that the parameters of event use code have changed but the name of the used event does not change the category addition refers to adding an event use the category deletion refers to the deletion of an event use the category move means that the location of the event use code has been moved but its parameters and name remain the same and finally the category replacement means that the name of the used event is modified without modifying the parameters.
for three modifications they change both the name and parameters of the used event so we do not classify them into any category.
we can see from the table that the instances for categories parameter change addition and deletion are most dominating accounting for .
of all sampled modifications.
having tools to help check for problematic event parameters i.e.
event parameters that should be substituted by other parameters for better logging quality missing use of events and unnecessary use of events can thus help developers better use events the first time they write code reducing subsequent event use changes.
in particular the high percentage of parameter change andaddition instances is in line with existing studies on conventional logging and the explored automatic logging support for what to log and where to log is also invaluable for solidity event logging .
by contrast the instances for categories move andreplacement are relatively limited.
finding within independent event use code modifications developers spend significant efforts in changing parameters adding a new event use and deleting an existing event use accounting for .
of all modifications .
they seldom move an event use or replace an event use with another one.
implication tool builders should focus on developing tools for helping developers to detect and fix issues related with problematic event parameters missing event use and unnecessary event use.
the explored automatic logging support about what to log and where to log for conventional logging is also invaluable for solidity event logging and a viable solution is using the learn to log principle on top of high quality training data.
we next give a detailed analysis of the reasons for the modifications in the categories.understanding solidity event logging practices in the wild esec fse december san francisco ca usa table category of independent event use code changes change type instance percentage parameter change .
addition .
deletion .
move .
replacement .
.
parameter change category parameter change is most common according to our data with a percentage of .
and its specific reasons are also the most diverse.
.
.
unintended wrong usage.
.
instances of modifications in this category arise because unintended wrong value related with a certain non address variable has been recorded by event use.
the wrong value emerges due to typical programming errors related with variables.
among the instances there are and instances that fall into change kind replace a variable with another variable that is in scope arithmetic error change replace a wrapped method call for a variable with another method call that is similar in identifier name and wrap unwrap a variable with a method call respectively.
as the search space for these change kinds is relatively small there exists the prospect of well designed tools to automatically conduct these changes.
given much progress has been made in recent years towards automatically detecting and fixing relatively simple bugs this prospect is huge.
an example is shown in fig.
a where the parameter referrer is wrapped with method call plasmaof in the new version.
according to the definition of plasmaof depending on a condition the return value of it may or may not be the argument passed in the referrer in this case .
according to the change what needs to be logged is the return value of the function for an argument but not the argument itself so the direct use of argument referrer is unintended and wrong.
.
.
mixed use of addresses.
.
instances of modifications in this category are related with mixed use of addresses.
it is a common practice to use event to record transaction related information in solidity programming and the information in general will include the addresses involved in the transaction i.e.
the addresses of the recipient and sender .
however when using event to record information addresses are often mixed and the most common one is mixing the sender s address with that of the caller.
for example given a scenario where contract acalls contract bto transfer xtokens in account cto account d then account cis the actual token sender and account dis the actual token recipient.
in event logging we then should record the addresses of account c and account d. however a mistake that many developers are prone to making is to record msg.sender as the actual token sender that is record aas the actual token sender.
in other words the address for caller of the contract is mixed with that for the actual token transferer.
fig.
b gives a real example where src is the actual token transferer.
however developer mistakenly records the contract caller msg.sender as the token transferer.
.
.
improving string description.
.
instances of modifications in this category are improving string description makingthe content in the string easier to understand or closer to what the developer wants to express.
besides logging value event logging feature can also be used to log one or several string descriptions for explaining what value has been logged or the purpose of the logged value.
however developers may not pay enough attention to the string description at the beginning and they gradually improve it.
an example is shown in fig.
c where the initial string description mint b is much less informative than the new string description initoptinotoken .
.
.
gas saving.
.
instances of modifications in this category are related with gas saving which replaces storage type variable with memory type variable to save gas.
the reason is after compiling the event use to evm bytecode an extra sload evm operation would be needed to access the variable if it is storage type and the sload operation costs gas since it deals with data in storage area.
thus when we use event to store the value of a certain variable in transaction log local memory type variable would be preferable to storage type variable if they hold the same value.
fig.
d gives an example the original variable delay is a global variable and the new variable delay is a function parameter which will respectively be storage type and memory type in solidity.
since their values are the same for event delayset using memory type variable delay can save gas.
given the utmost relevance of reducing the gas costs of smart contracts in the blockchain ecosystem it would be extremely worthwhile to investigate the gas impact of this kind of variable replacement on the whole ethereum net in the future.
for the remaining .
instances in this category we are not clear or have not agreed with the underlying reasons.
finding for changes that change parameters of event use four key reasons are unintended wrong variable related value has been recorded .
mixing addresses of transaction sender transaction recipient and contract caller .
improving string description .
and gas saving .
.
for wrong variable related value the wrong value emerges due to typical programming errors related with variables such as arithmetic error and forgetting to wrap the variable with a method call.
for gas saving developers replace storage type variable with memory type variable that has the same value.
implication testing event logging behaviours is important and testing efforts should pay special attention to typical programming errors related with variables and the addresses involved in event use.
with regard to wrong variable related value there exists the prospect of well designed tools to automatically conduct changes to correct the value as the change space is relatively small.
with regard to gas saving tools can automatically help developers conduct the change from storage type variable to memory type variable and compilers can do this gas optimization during the optimization process.
besides developers should take the string description in event use seriously making it as informative as possible.
.
addition category addition accounts for a significant percentage .
of the modifications and the underlying reasons are as follows.esec fse december san francisco ca usa lantian li yejian liang zhihao liu and zhongxing yu .
.
recording transaction related information.
.
instances of modifications in this category are post transaction additions which add an event use after the asset transfer code to record transaction related information.
the information typically include the addresses involved in the transaction the amount the balance etc.
if event logging is employed to record transaction related information the ethereum platform will notify the client of the occurrence of the transaction.
as a result there is no need to continuously check the ethereum ledger to determine whether the transaction exists.
an example is shown in fig.
a .
the newly added transfer event records the addresses user andaddress of the two parties involved in the transaction as well as the number of transferred tokens value .
.
.
debugging support.
.
instances of modifications in this category are related with facilitating debugging.
solidity does not provide developers with language level debugging facilities typically found in other languages e.g.
print .
the difficulty of debugging is thus increased and developers can use event logging to facilitate debugging.
there are various ways in which developers can use event logging to help with debugging including logging the value of an intermediate variable logging string information related to debugging using empty events without parameters note in this case transaction logs will still have information related with event such as its identifier etc.
an example is shown in fig.
b where orderstart is an empty event and the trimmed commit message confirms that this modification is for debugging.
figure example of parameter change.
figure example of addition change.
.
.
monitoring variable value change caused by assignment.
.
instances of modifications in this category are postassignment additions where the assignment includes not only the direct variable to variable assignment but also the assignment of results of typical operations such as function call and math operation but excluding transaction operation to variables or elements of more complex data structure such as array.
event logging in this case can typically be used to monitor the value change for variables of interest updating front end of light clents and dapp services accordingly.
an example is shown in fig.
c .
after using an assignment enabled true to change the value ofenabled the event use tokenadded token is employed to indicate that now the account with address token is allowed to participate in something such as a transaction.
the use of event logging after transaction and assignment operations is of great significance in particular for dapps.
the high percentage of post transaction and post assignment additions suggests that developers frequently forget to use event logging after transaction and assignment operations and the commit messages for most of these modifications clearly explain that the developers forget to use events at the beginning.
thus dedicated tools could offer support for recommendations of event uses for these operations.
for the remaining .
instances in this category we are not clear or have not agreed with the underlying reasons.
finding for changes that add an event use three major reasons are recording transaction related information by posttransaction additions .
debugging support .
and monitoring variable value change caused by assignment by postassignment additions .
.
implication research on providing automatic where to log support could focus on transaction and assignment operations and more systematic work is needed for exploring in detail the specific types of transaction and assignment operations for which event logging is highly desired.
besides it is worthwhile to further explore the attributes of code snippets for which event logging is added to support debugging.
.
deletion category deletion accounts for a large percentage .
of the modifications and the underlying reasons are as follows.
.
.
debugging removal.
.
instances of modifications in this category are related with removing event logging previously used for debugging.
as these event debugging removals are independent of other non logging code changes so these event debugging removals in principle can actually also be done in last commit or earlier commits more specifically at the code version for which the use of a certain event for code debugging has finished .
thus the high percentage of modifications in this category suggests that developers often do not delete events that are no longer needed in a timely manner after using event feature for debugging negatively impacting code readability and increasing gas cost.
however it is typically impossible to analyze whether the developer has finished debugging from the code only.
the first author checks the event debugging removals and finds that there are three common formsunderstanding solidity event logging practices in the wild esec fse december san francisco ca usa of event logging debugging.
the second author confirms the result and the three forms are as follows log one informative string or use an empty event.
in this case developer uses event logging to log a string description that may have special meaning for himself or use an empty event as exemplified in category addition .
fig.
a1 gives an example of this form.
log one or several variables and one informative string.
in this case developer uses event logging to log the value of one or several variables and one informative string that is typically related with the variable name s .
the purpose is to judge whether the variable value is consistent with the expected value.
fig.
a2 gives an example of this form.
use same event to log one or several variables multiple times but in different locations.
in this case developer uses same event multiple times to see whether the value change of a certain variable is expected facilitating debugging.
fig.
a3 gives an example of this form.
given these common forms of event logging debugging tools can check them and inform developers to delete them in case debugging has already finished.
.
.
redundancy removal.
.
instances of modifications in this category are removing redundant event logging code.
that is if the recorded content by a certain event use is the same as or already included in the recorded contents by some other event uses then the event use can be deleted to save gas.
fig.
b gives an example of this change type.
since the value of the parameter amount is logged by both events burn andtransfer one of them is deleted.
.
.
useless removal.
there are two additional instances .
in this category that arise for removing useless event logging code.
if event logging records something that is unnecessary or not used at all then it should be deleted since evm logging primitives cost gas.
in general it is hard to determine whether the developer has used useless event logging code from the source code only.
we need to also consider the commit message if available.
fig.
c gives an figure example of deletion change.example where the commit message clearly says the purpose of the deletion.
note that the underlying reasons for the above change instances can be viewed more generally as gas saving in a way.
for the remaining .
instances in this category we are not clear or have not agreed with the underlying reasons.
in particular we are not aware of any deletion instances of dead event logging code in our sample.
it can be that such change instances will nearly always be consistency updates and further work needs to be conducted to investigate this problem.
finding for changes that delete an event use two major reasons are remove no longer needed event logging previously used for debugging .
and remove redundant event logging .
.
the event logging used for debugging typically has three forms log one informative string or use an empty event log one or several variables and one informative string and use same event to log variable s multiple times in different locations.
implication developers often do not delete event uses that are no longer needed in a timely manner.
based on the common forms of event logging debugging dedicated tools can check them and remind developers to delete them if debugging has finished.
also by conducting advanced analysis e.g.
alias analysis dedicated tools can check whether there exist redundant event uses that record the same content and suggest the redundancy removal.
.
move category move accounts for a relatively small percentage .
of the modifications.
the reasons for changes in this category cannot be easily determined.
we list the types of move below and try to give reasons for some of them.
figure example of move change.
.
instances of modifications in this category are moving the event use code from before an operation such as transaction assignment authorization etc.
to the after of the operation.
an example is shown in fig.
a .
this change type is in line with common sense that is finish things first and then record the completed things .
it is also compatible with the significant number of posttransaction and post assignment additions of event use in category addition .
the high percentage of this type of changes suggests that it is desirable for ide to warn developers if they put event logging code before an operation.
.
instances of modifications in this category are moving the event use code from the inside body of conditional statement or loop statement to outside or vice versa.
an example is shownesec fse december san francisco ca usa lantian li yejian liang zhihao liu and zhongxing yu in fig.
b .
we can see from the commit message that developer has changed the conditions for the event logging to trigger.
for the other instances of this type the commit messages do not have a clear explanation for the change but we surmise that the reason for this type of change is either the condition for triggering event logging has changed or the original triggering condition is wrong.
there are change instances in this category which instead move the event logging code from after an operation to the before of the operation.
this change type is anti intuition and relatively rare and there are usually special reasons behind it.
for one change instance commit 33de75b the developer s commit message is this triggered a warning when static analysis tools were used because emitting an event is considered a state change.
so the change aims to avoid triggering warnings from static analysis tools.
for the other change instance commit 3cc7b64 the developer s commit message is moved the createpool event before the addliquidity event for cleaner subgraph code so the purpose of the change it to clean code.
due to the small number of occurrences there is little commonality in the reasons.
finding for changes that move an event use developers frequently move an event use from before an operation such as transaction assignment authorization etc.
to the after of the operation .
.
in addition they also often move the event use from the inside body of conditional statement or loop statement to outside or vice versa .
.
implication developers are conservative in moving event use code.
given event use in general is placed after an operation dedicated tools can check whether event use is placed before an operation and warn developers about this abnormal behaviour.
.
replacement category replacement accounts for a very small percentage .
of the modifications note for changes in this category even though the recorded value has not changed but the names of the two events are different and this will be reflected in transaction logs and it arises as the wrong event is used at the beginning or there is an event that is more suitable for recording the needed information.
with regard to the reason it is speculated that developer defines too many events or the locations of the event definitions are scattered so they forget which events have been defined.
it is in general impossible to determine whether a certain event use should be replaced by another event use but we can justify some of these modifications by analyzing whether the name of the function where the event use is located has a corresponding relationship with the name of the event.
an example is shown in fig.
.
in this example the developer uses the escrowwithdrawn event in the refund function which is later changed to the escrowrefunded event.
it can be seen that the name of the event used at the beginning does not match with the name of the function where it is located.
figure example of replacement change.
problematic event logging parameter checker for gas saving to demonstrate the possibility of automatic event logging support on top of our findings we design a simple parameter level checker to detect a particular type of problematic event logging code which consumes extra gas than needed.
the checker is motivated by the non neglectable number of parameter changes that replace storage type variable with memory type variable finding and contributes to saving gas.
our observation is that when we use event logging to store the value of a certain variable in transaction log memory type variable would be preferable to storage type variable if they hold the same value.
note that both the storage type variable and memory type variable are already declared elsewhere in the code we are not changing their definitions and we just reference them as event parameters.
since these two variables share the same value the stored value in the transaction log will be the same.
since we are not changing the definitions and value of storage type variables the persistence of storage type variable on the blockchain will not be impacted.
thus changing the parameter of an event use from a storage type variable to another memory type variable when these two variables share the same value will not impact code semantics.
the checker is implemented in approximately lines of python excluding dependencies comments and empty lines and is built uponpython solidity parser which can partially compile solidity code snippet.
in particular the checker relies on the parsed ast to work.
it takes the path of the contract or the project directory as an input and then analyzes whether each contract in the directory has gas optimization opportunities and outputs the following information if so the contract line number for which the gas can be optimized the specific event use in the line to optimize the specific storage type variable of the identified event use the specific memory type variable to replace the identified storage type variable.
in particular the checker contains two major phases.
first it identifies all event use code in the contract whose parameters involve a certain storage type variable.
then it checks whether there exists an in scope memory type variable whose value is the same as the storage type variable.
to investigate the effectiveness of the tool on the most popular projects we applied the checker to the top in terms of stargazers counts github solidity projects.
the checker detected that projects suffered from this issue for their latest versions of code.
in total there are problematic event logging uses.
for each of the projects we opened an issue which includes the following information a short message explaining the purpose of our study the explanation of our finding about gas saving opportunities involving memory and storage type variables the exact code line s and variable s for which gas can be optimized based on our finding with the code snippet embed a question about confirmation of the detected problem.
the owners of projects have already confirmed the detected problems confirming problematic event logging uses in total and most of them have merged the changes into the code base.
we have received very positive feedback from solidity developers.
one developer said this is interesting thanks a lot for taking the time to identify this optimization .
this result suggests that on top of our findings even a simple understanding solidity event logging practices in the wild esec fse december san francisco ca usa proof of concept checker can effectively contribute to improving the quality of solidity event logging instructions.
in particular the result confirms that to obtain systematic and automatic assistance for better event logging the first essential step is to understand the current manual efforts involved with event logging.
threats to validity external validity.
first our study uses solidity projects hosted on github and these projects may not be sufficiently diverse or representative.
thus whether the results can be generalized to other solidity projects e.g.
hosted on bitbucket is a potential issue.
to mitigate this threat our study accounts for a considerable number of popular solidity projects on github and the existing study suggests that popular solidity projects on github will cover diverse application domains like auctions and tokens .
second we sample certain independent event logging code modifications to understand the underlying reason.
to reduce the sampling bias we have ensured that the results fall under the confidence level of with a confidence interval of .
third while we use stargazers counts to select popular projects and previous works have suggested the existence of many popular deployed projects on github it is possible that sample not deployed projects sneak into our dataset.
finally the proof of concept checker is evaluated only on the top popular github projects and more evaluations need to be conducted to see its effectiveness in a more general sense.
internal validity.
our study methodology in section .
involves two manual processes and bias can possibly be introduced.
to mitigate this threat each manual analysis will involve two distinct authors of the paper.
they independently conduct the analysis and the analysis results will be compared.
in particular for the manual examination of the characteristics of the sampled independent event logging code modifications we examine developers commit messages source code together with the event logging code modifications to reason about the modifications.
construct validity.
for all of our developed programs in particular the utility to calculate loc and the proof of concept checker we have performed thorough testing to ensure their correctness.
related work empirical study on smart contract.
the transaction reverting statement can effectively protect smart contracts against abnormal or malicious attacks.
to explore how developers can enhance transaction reverting statements liu et al.
analyze the security implications of transaction reverting statements.
mariano et al.
conduct an empirical study of loops in ethereum smart contracts and they cluster smart contract loops according to their semantic features.
durieux et al.
conduct an empirical study to analyze and compare several state of the art smart contract analysis tools.
to our knowledge our work is the first to explore solidity event logging feature and gives a systematic study about density and in particular evolution of solidity event logging code.
smart contract analysis and verification.
as vulnerabilities in smart contract can potentially be exploited recent years have witnessed a surge of proposed approaches to ensure that smart contracts are free of vulnerabilities.
securify and ethainter leverage the rewriting system datalog to detect vulnerabilitiesthrough pattern matching.
luu et al.
present an approach which uses symbolic execution to find potential security bugs in smart contracts.
rodler et al.
design a framework for on the fly automatic patching of faulty smart contracts.
ren et al.
design a security enhanced code suggestion module on top of a bidirectional lstm network.
compared to these approaches our work instead aims to uncover the practical issues faced by solidity developers when using the event feature and inspire the development of analysis and verification methods to alleviate the issues.
research on logging.
in general logging messages can improve program comprehension and reduce maintenance costs.
yuan et al.
conduct a series of studies about logging in system software covering characteristics study tool design for log enhancement etc.
chen and jiang conduct the first large scale empirical study of the use of java log tools in the wild.
kim et al.
propose a log analysis system on top of log history.
the system uses statistical text mining techniques to calculate significance and noise scores for each log line and then highlights abnormal log lines based on the calculated scores.
le et al.
propose a log based anomaly detection method that does not demand parse of log messages.
solidity event logging features a few important distinctions compared to conventional logging as given in section and thus it is important to study how solidity developers use event logging in practice.
we in this paper fill the research gap by conducting a large scale empirical study about solidity event logging practices in the wild.
conclusion we provide the first quantitative characteristic study of the current solidity event logging practices using solidity projects hosted on github.
the study methodically investigates the pervasiveness of event logging the goodness of event logging practice and in particular the reasons for event logging code evolution and delivers original and important findings.
we additionally give the implications of our findings and these implications are beneficial for researchers language designers tool builders and developers in order to improve all facets of solidity event logging.
based on one of our findings we develop a proof of concept checker and effectively detect problematic event logging code that consumes extra gas in popular github projects and project owners have confirmed the detected issues.
for future work we would like to develop tools that conduct systematic testing of event logging behaviours based on our findings.
we are also passionate about building an advanced tool on top of our findings which can effectively support automatic code transforms related with solidity event logging including bug fixing refactoring and optimization.
data availability our replication package including code dataset etc.
is available at