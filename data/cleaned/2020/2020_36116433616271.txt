copilotingthe copilots fusing largelanguagemodels with completion engines forautomated program repair yuxiang wei universityof illinois urbana champaign usa ywei40 illinois.educhunqiusteven xia universityof illinois urbana champaign usa chunqiu2 illinois.edulingming zhang universityof illinois urbana champaign usa lingming illinois.edu abstract during automated program repair apr it can be challenging to synthesize correct patches for real world systems in generalpurposeprogramminglanguages.recentlargelanguagemodels llms have been shown to be helpful copilots in assisting developers with various coding tasks and have also been directly appliedforpatchsynthesis.however mostllmstreatprogramsas sequencesoftokens meaningthattheyareignorantoftheunderlyingsemanticsconstraintsofthetargetprogramminglanguage.this resultsinplentyofstaticallyinvalidgeneratedpatches impeding thepracticalityofthetechnique.therefore we propose repilot a general code generation framework to further copilot the ai copilots i.e.
llms by synthesizing more validpatches during the repairprocess.ourkeyinsightisthatmanyllmsproduceoutputs autoregressively i.e.
tokenbytoken resemblinghuman writing programs whichcanbesigni f icantlyboostedandguidedthrougha completion engine.
repilot synergistically synthesizes a candidate patchthroughtheinteractionbetweenanllmandacompletion engine which1 prunesawayinfeasibletokenssuggestedbythe llmand2 proactivelycompletesthetokenbasedonthesuggestions provided by the completion engine.
our evaluation on a subset of the widely used defects4j .
and .
datasets shows that repilot outperforms state of the art techniques by f ixing and morebugs respectively.moreover repilotproducesmorevalid andcorrectpatchesthanthebasellmwiththesamebudget.while we focus on leveraging repilot for apr in this work the overall approach isalsogeneralizable to othercode generationtasks.
ccs concepts softwareanditsengineering softwaretestinganddebugging automatic programming .
keywords program repair largelanguagemodel completionengine acmreference format yuxiangwei chunqiustevenxia andlingmingzhang.
.copiloting the copilots fusinglargelanguage models withcompletionengines for automatedprogramrepair.in proceedingsofthe31stacmjointeuropean permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forpro f itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe f irstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeci f icpermission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
engineering conference and symposium on the foundations of softwareengineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 13pages.
introduction automated program repair apr seeks to reduce the manual bug f ixingeffortofdevelopersbyautomaticallysynthesizingpatches given the original buggy code .
state of the art traditional apr tools are mainly based on handcrafted repair templates to match the buggy code patterns and apply the corresponding code changes .
although outperforming other traditional techniques such tools can only f ixthe bug types within the preset templates and cannot generalize to new bug types.
with the development of deep learning dl techniques researchers build learning based apr tools based on neural machine translation nmt architecture.
they train nmt models to translate buggy code into correct code by learning from pairs of buggyand f ixedcodescrapedfromopen sourcecommits.however as discussed in prior work the training sets of these tools can be limitedinsize andalsocontain irrelevantornoisycommits.
morerecently researchershaveleveragedthegrowthinthe f ield ofnlptodirectlyuselarge languagemodels llms for apr .llmsnotonlyachieveimpressiveperformanceon manynlptasks butarealsoshowntobereliable copilots 1in assistingdeveloperswithvariouscodingtasks .thereason isthatmodernllmsoftenincludelargeamountsofavailableopensource code repositories as part of their training dataset.
recognizingthepowerofllms researchershaverecentlyappliedllmsfor apr instead of translating buggy code into correct code llms are directly used to synthesize the correct patch from the surrounding context.
alpharepair reformulates the apr problem as a cloze orin f illing task it f irst replacesthe buggycodesnippets with masked tokens and then uses codebert to f ill correct code ingiven the surrounding context.
otherstudies on llmsfor aprhaveappliedevenlargerllmswithdifferentrepairsettings includinggeneratingcomplete patch functions .
while prior llm for apr techniques achieve state of the art bug f ixing performance they use llms in a black box manner where the underlying llm generate programs according to thetoken distribution without any structural or semantic understanding ofthecode.tohighlightthelimitationswithcurrentllmsforapr tools in figure 1we show scenarios where llm can generate incorrectpatches.
1generatinginfeasibletokens .infigure .
thellmhasahighprobability ofgenerating stringtocomplete the asstring method.
however asstring is not a valid f ield accessfortheobject tandisalsonotpartofthescopeofthecurrent 1one popular aipairprogrammer tool based oncodex is named copilot .
esec fse december3 san francisco ca usa yuxiang wei chunqiu stevenxia andlingming zhang string name t.asend tag name tag ... asendtag !
hard to generate rare tokens2 final endtag asendtag ... string name t.asendtag .
name normalname tostring name !
...tostring no explicit consideration of types3 string name t.as asendtag asstarttag ascomment asdoctype ascharacter !
string name !
end !
.
...language model predictions completions generating infeasible tokens1 figure limitationsofexisting llm based aprapproaches.
buggy method.
in this case the patchs generated using asstring will never be correct as it cannot compile.
by directly using the model probabilities llms are likely to generatemanypatchesusing invalid tokens and decrease the likelihood of generating the correctpatchwith end .
.
2hardtogenerateraretokens .
llms usually cannot generate a complete identi f ier name in one stepsinceitusessubwordtokenization tobreakuncommon words into smaller subwords.
these uncommon words manifest asrareidenti f iersincode whereidenti f iernamesarecamelcase or underscore combinations of multiple words e.g.
asendtag in figure1.
.assuch llmsneedtogeneratetheseidenti f iersstep by step needing not only multiple iterations but also accurate outputineachstep.sincepriorapproaches samplebasedon probability thelikelihoodofcompletingararetokento f ixabug can be extremelylow.
3no explicit consideration of types .in addition topotentiallygeneratingout of scopeidenti f iers llms do nothave accesstovarioustype informationthat giveshints to the valid identi f iers.
in figure .
the return type of asendtag is endtag whose de f inition is not explicitly given to the llm in its immediatecontext.assuch llmsdonotknowthecorrectmember f ieldsof endtagandmaygenerateinvalidpatchescontaining identi f iersthatdonot f ittherequiredtype.onthecontrary acompletionenginehasfullaccesstotheprojectandcaneasily f igure out the return type of asendtag through static analysis on the abstractsyntaxtreeoftheprogram.bytreatingcodeasasequence oftextual tokens the importanttype information isnot encoded.
to address the aforementioned limitations we propose repilot a framework to further copilot the ai copilots i.e.
llms via fusing llms with completion engines to synthesize more valid patches.
completionengines canparse incompleteprograms andreasonaboutthesemanticsinanerror tolerantmanner.our keyinsightis tolikenllmautoregressivetokengenerationasahumandevelopercodewriting wherethecompletionenginecanprovide real time updates to check if the human llms written partial code is valid.
repilot f irst uses the llm to provide the probabilities of generatingthenexttokeninthepatchandthenqueriesthecompletion engine to modify the probability list by dynamically zeroing the probabilitiesofinvalidtokens.wecanthensamplefromthenew probabilitylisttoselectthenexttoken.furthermore recognizing the ability for completion engines to suggest completions we use this feature whenever there is only one possible identi f ier suffix tocompletethecontext.thisnotonlyallowsrepilottogenerate patches with valid rare and long identi f iers but also reduces the work of llms needed to iteratively generate long identi f ier names.
for example repilot directly prunes the stringandnametokens in figure .
as they are infeasible according to the completion engine but still accepts the correct endtoken.
in figure .
thecompletion enginerecognizes that asendtag istheonlyvalid continuationtothepre f ix asend sorepilotdirectlycompletesthistoken without querying the llm.
to combat the time cost of completion engine weimplementseveraloptimizationtechniquestominimize theoverhead.notethattherecent synchromesh work alsoemploys a completion engine for reliable code generation with llms.
however it relies on expert designed constraints and only targets domain speci f ic languages e.g.
sql .
repilot directly works for general purposeprogramminglanguageswhileintroducingminimal overhead and can proactively complete the current generation using the completionengine withoutqueryingthe llm.
to demonstrate the generalizability of repilot we instantiate repilot with two llms having distinct architectures and sizes codet5 large anencoder decoderllmwith770millionparameters and incoder .7b a decoder only llm with .
billionparameters bothcapableofcodein f illingfrompre f ixand suffixcontext.wefurtherimplementajavacompletionenginefor repilotbasedontheeclipsejdtlanguageserver sinceit provides various semantics based analyses through a consistent language server protocol .
we evaluate repilot on a subset of thewidelystudieddefects4j1.2and2.0datasets anddemonstrate state of the art results in both the number of correct f ixes and compilation rate the percentage of the generated patches thatcanbesuccessfullycompiled.furthermore whileweevaluated repilotforaprinthiswork webelievetheoverallframeworkcan be easily applied to other code generation tasks including code completion program synthesis and test generation .
in summary we make the following contributions direction.
we open a new direction for fusing llms with completionengines for more powerful apr and beyond.
compared to prior techniques which either perform post processing to f ix invalid generations or use simple static methods to approximate thesevalidtokens ourapproachleveragesapowerfulcompletion enginetodirectlyprovideaccuratefeedbackonpartialprograms to avoid invalidtoken generations.
technique.
weimplementrepilot anllmforaprapproach instantiatedwith the codet5 and incoder modelsto perform cloze style repair combined with our modi f ied eclipse jdt language server as the completion engine.
in repilot we use the completion engine to systematically prune invalid tokens generated by llms and to directly complete code given the current pre f ix.
furthermore we implement optimizations to signi f icantlyreducetheoverheadof repilot.wehaveopen sourced our toolat .
study.wecomparerepilotagainststate of the artaprtoolson defects4j .
and .
.
repilot is able to achieve new state of theart results of defects4j .
single hunk bugs and defects4j 173copilotingthe copilots fusing large languagemodelswithcompletion enginesforautomatedprogram repair esec fse december3 san francisco ca usa .
single line bugs f ixed respectively with more combined f ixesacrossbothdatasetscomparedtothepreviousbestbaseline.
our further evaluation shows that repilot consistently improves the validity and correctness of the generated patches with a limitedoverhead for codet5 andnegligiblefor incoder .
backgroundand related work .
large language models forcode recentadvancesinnaturallanguageprocessing nlp haveempowered the idea of using large language models llms that are pre trained on enormous corpora of natural language and code for various code related tasks .
llms are based on the transformerarchitecture thatcanbecategorizedinto encoderonly decoder only andencoder decoder .
encoder only models use only the encoder component by training using masked language modeling mlm objective where a small percentage e.g.
ofthetokensaremaskedon.thegoalofmlmistorecoverthesemaskedtokensgiventhesurroundingcontext.encoderonly models such as codebert and graphcodebert are designedtoprovidearepresentationoftheinputcodetobeusedfor downstream tasks such as code classi f ication .
decoder only models on the other hand aim to autoregressively generate tokensbasedonallpreviouslygeneratedtokens.codegen codex andpolycoder areexamplesofdecoder onlyllms where they can be used for code autocompletion tasks.
different from encoder and decoder only llms encoder decoder models e.g.
codet5 and plbart combine both encoder and decoder together and jointly train both components together.
a commonly used pre training objective for encoder decoder models is masked span prediction msp where random spans multiple consecutivetokens arereplacedwithsinglemaskedtokensandthe modelslearnto f illinthemaskedspanwiththecorrectsequenceof tokens.furthermore decoder onlymodelslike incoder can also objective.
instead of using thedecoder topredict the nexttoken in the original training data similar to msp incoder also replaces random spanswith masked spantokens.
during training incoder learns toautoregressivelyrecovertheoriginalspans.withthistraining strategy incoder can perform in f illing with bidirectional context similar to encoder decoder models enabling cloze style repair.
.
codecompletion code completion is one of the most frequently used features in integrateddevelopmentenvironments ides .itsubstantiallyalleviatesthecomplexityofsoftwaredevelopmentbyinteractively suggesting program constructs after the user s caret position while programmers are typing including identi f ier names and library apis.
code completion is now an indispensable infrastructure of the most widely used programming languages and can be easily integrated into most modern text editors thanks to the presence of the language server protocol which standardizes the communicationbetweentoolsandlanguageservices.traditionally a semantics based completionengine isimplementedontopofaseries of complex incremental syntactic and semantic analyses of the target programming language since it needs to understand partially written programs and provide real time feedback.
thecompletionenginehasfullaccesstoaprojectrepositoryanditsdependencies and can produce suggestions according to its semantic understanding.
recent advances in llms demonstrate the capabilityofgeneratinglongandcomplicatedcompletions.however they may produce unreasonable programs due to the limitation in the code context size and the loss of program analysis by simply treating programs as token sequences.
in this paper we use the term completion engine to refer to the semantics based one.
we formally de f ine the expected properties of a completion engine in our framework inde f inition .
.
.
automated programrepair automatedprogramrepair apr aimstogeneratepatchesgiven thebuggycodelocationandthebug exposingtests.traditionally aprapproachcanbecategorizedasconstraint based heuristic based and template based .
among these classic techniques template based tools have been shown to achieve the highest number of bug f ixes by using handcrafted repair templates to target speci f ic bug patterns .
however thesehandcraftedpatternscannotcoveralltypesofbugs thatexistandassuch template basedtoolscannot f ixbugsoutside oftheirpre determinedtemplates.
to address the issue faced by template based apr tools researchersresorttoneuralmachinetranslation nmt todevelopnmt basedaprtools .nmt basedapr tools train an nmtmodel to translatethe inputbuggy code into the correct code through bug f ixing datasets containing pairs of buggy and f ixed code.
however these bug f ixing datasets may containonlyasmallnumber typesofbug f ixes especiallycompared to a large amount of available open source code snippets due to the difficulty in obtaining bug f ixing commits .
additionally the datasets can fail to f ilter out unrelated commits such as refactoring whichaddsnoisetothetrainingdatasets.duetothis reliance on training using bug f ixing datasets these nmt based tools alsocannot generalizeto bug typesnot seenduringtraining.
recently researchers begin to directly apply llms for apr .
alpharepair is the f irst to directly use llms for cloze style or in f illing style apr it masks out the buggy code snippet and thenusescodebert todirectly f illinthecorrectcodegiven the surrounding context.
while alpharepair demonstrates the potential to use encoder only models for cloze style apr other studies have looked into applying all three types of llm architecture.fitrepair furtherimprovesalpharepairviadomainspeci f ic f ine tuningandpromptingstrategiesleveragingtheplastic surgeryhypothesis .evenmorerecently researchershaveapplied dialogue based models for apr .
for example chatrepair proposesafullyautomatedconversationalapr approach by learning from prior patching attempts including both patch code andtest failure information.
compared to traditional and nmt based apr techniques llmbasedtechniquesareabletoachievenewstate of the artbug f ixing results .whiletheperformanceisimpressive oneparticular limitation of these techniques is the lack of guidance in patch generation.
prior work mainly treats thellm as a black box and only queriesthemodelviabeamsearch orsampling .this 174esec fse december3 san francisco ca usa yuxiang wei chunqiu stevenxia andlingming zhang means llms while powerful may still generate invalid patches given the currentcode context.
in this work we address these limitations by using a semanticsbasedcompletionenginetoguideandprunethellmsearchspace.
ourapproachisorthogonaltorecentllm basedaprtechniques and can be easily combined with them.
in fact nmt based apr techniques have alsoattempted to tackle this problem.
cure f irststaticallyobtainsthevalididenti f iersandforcesthenmtmodel toonlyselectfromvalididenti f iersduringgeneration.recoder builds an edit based nmt model to enforce syntax correctness and introduce placeholder tokens and then as a post processing step recoder will replace placeholder tokens with statically determined valid identi f iers.
rewardrepair on the other hand attempts to increase the number of compilable patches by penalizing uncompilable patches during training.
compared to these prior techniques repilot is more general andeffective.repilot doesnot require any domain speci f ic training and leverages the incremental analysis of off the shelfcompletionenginestoenforceguaranteedconstraints to guide llmsonthe f ly.
preliminaries in this section we f irst de f ine concepts about programming languagesusedthroughoutthepaper .
.thenwediscussthe formal abstractions of the two key components used in our repilot framework completionengine .
andlargelanguagemodel .
.
these two abstractions are crucial in that each of them describes a collection of f itting implementations which forms the reason why repilot isageneralizable framework.
.
languages with static checking wenowintroducetheconceptofprogramminglanguagesequipped with static checking and de f ine the feasibility of a partial program before the formulation ofthe completionengine de f inition .
.
de f inition3.
programminglanguagewithstaticchecking .
a programming language with static checking is de f ined as a pair of itscharacterset planditsstaticspeci f ication plasaunary relation on pl.
pls pl .
givenaprog pl thenotation prog orprog statesthat progis a statically valid program in this language.
for staticallytypedprogramminglanguageslikejava thecompilationcheckisa kindofstaticchecking.
de f inition .
static feasibility of a partialprogram .
for apartiallywrittenprogram prog pl wesayitisfeasibleatthecaret positioncaretwithrespecttothestaticspeci f ication written as prog caret if and only if there exists a possible continuation aftercaretwith which completing progresults in a statically valid program.
the de f initioncan be formally written as prog caret cont pl prog .
where we use the notation prog as the action of completing progatcaretwithcont i.e.
prog prog0..caret cont progcaret.. prog .
.
inalgorithm weextendthisnotationtoaccepta range n n so thatprog speci f ies the action of replacing prog s contentswithin rangewithhunk.
.
abstractionofcompletion engines a completion engine showed in figure provides suggested continuations to apartiallywritten program given the caretposition.
de f inition3.
completionengine .
formallyspeaking acompletion engine ceisapair ce pl complete .
where plisthe character setof the target language and complete pl n p pl unknown .
is a function to obtain the completions given a program at some caret position with unknown indicatingthe enginecannot determine the suggestions from the code context e.g.
when completing avariabledeclaration .notethatwemakeadistinctionbetween unknown andemptycompletions becauseinthispaperweare interested in a speci f ic group of strictcompletion engines that helpsdeterminethe feasibilityof apartialprogram.
completion engine ... public multiplepieplot ... super this.set ... program and caret position dataset datasetgroup backgroundalpha dataextractorder drawingsupplier foregroundalpha ... completions uni03a3 pl n p uni03a3 pl unknown uni03a3 pl n p uni03a3 pl unknown complete figure abstractionofacompletion engine.
de f inition .
strict completion engine .
assume that a completion engine cecan obtain a set of completions given a program progfeasible at caret i.e.
prog caret completions complete prog caret wherecompletions unknown .
.
then ceis said to be strict if and only if under this condition continuing progwith any code that does not match with this set of completions yields an infeasible program at the new caret position c pre f ix completions prog caret whereprog prog andcaret caret c pre f ix u1d450 u1d460 and u1d450isapre f ix of u1d460orvice versa .
.
thisde f initionessentiallymeansthatastrictcompletionengine shouldnotgiveincorrectsuggestions.itshouldreturn unknown wheneverunsure.atrivialstrictcompletionenginecanbetheone that alwaysreturns unknown .
.
abstractionofllms in this section we give a formal abstraction of an encoder decoder basedllmasshowedinfigure whichinpracticeismorecomplex butconformstotheabstraction.theabstractionsubsumesdecoderonly models and can also describe encoder only models that use the encoder outputs directlyas token probabilitiesfor generation.
175copilotingthe copilots fusing large languagemodelswithcompletion enginesforautomatedprogram repair esec fse december3 san francisco ca usa lm encrep encrep uni03a3 lm decrep lm decoder inputsencoder decoder encoder inputs uni03a3 lm encrep encrep decrep probability map !
... uni03a3lm uni03a3 lm encrep encrep decrep uni03a3 lm encrep encrep decrep encrep encrep decrep encrep encrep decrep ... figure abstractionofencoder decoderbased llm.
de f inition3.
largelanguagemodel .
formally wede f inean encoder decoder basedllm lmas a3 tuple lm lm encode decode .
where lmis avocabulary consisting of the set of tokens de f ined by the model.
the encoder encodeis a function that maps from an inputsequenceto its encodedrepresentation in encrep encode lm encrep.
.
the decoder decode de f ined below then memorizes the encoded representation in encrep takes as input a sequence of tokens and produces as outputits decodedrepresentation in decrep decode encrep parenleftbig lm decrep parenrightbig.
.
inthisde f inition thedecodermemorizingtheencodedrepresentation is modeled as a higher order function that returns a detailed decoding function given the encoded representation.
the decoded representation in decrepessentially assignsa probability toeach token in the vocabulary to state its likelihood of being the next token inthe sequence.therefore we can de f inedecrepas decrep lm .
.
approach followingmostrecentdeeplearningbasedaprtools repilot focuses on f ixing single hunk bugs where the patch is obtainedbychangingacontinuoussectionofcodeunderperfect fault localization.
repilot can be extended for multi hunk bugs by replacing all hunk locations at the same time with separate in f illing tokens and using llm to generate the replacement hunks.
bene f itingfromtheeraofllms asshowninfigure inthispaper we treat the repair problem as a clozetask where a patch is formedby f irstreplacingthebuggyhunkwithamaskedspantoken span andthenusingthellmtodirectsynthesizethe f ixedhunk from the surroundingcode contextto replace the span token.
private boolean inspecificscope ... int bottom stack.size if bottom maxscopesearchdepth bottom maxscopesearchdepth final int top bottom ... bug private boolean inspecificscope ... final int bottom stack.size final int top bottom ... cloze patch private boolean inspecificscope ... final int top bottom ... span figure cloze style program repair.
.
overview figure5shows an overview of how repilot synthesizes a program that acts as therepaired hunkoftheoriginal buggy program.
the generation loop consists of a loop that keeps updating the generation with tokens newly generated from the synergy between the language model and completion engine.
the loop starts byapplyingthecurrentgenerationastheinputtothelanguagemodel whichreturnsasearchspaceofamappingfromasuggested nexttoken toitsprobability.repilot thenenters atokenselection phasethatrepeatedlysamplesatokenfromthesearchspace checking its feasibility and pruning the search space until a token is accepted.
every time a token is sampled repilot f irst checks if it hitsthememorization whichstoresthetokensthatareknown tobe feasibleor infeasible.the memorization ofinfeasibletokens includestheuseofapre f ixtreedatastructure trie discussedin .
.whenthetokenhitsthememorizationandisinfeasible the search space is prunedby setting this token s probability to zero andthenextsamplingwillrunontheupdatedsearchspace.
in this way the same token is not sampled again during the token selectionphase.ifthetokenmissesthememorization thesearch space is pruned under the guidance of the completion engine whichweelaboratein .
.
providedthatthesampledtokenisrejected by the completion engine repilot zeroes out its probability.
otherwise it is accepted and this token selection process terminates.
the memorization gets updated in both cases .
after a token is accepted we further leverage the completion engine tryingtoactivelycompletethetoken .theactivecompletion discussed in .
may either produce more tokens or add nothing to the accepted token.
finally repilot appends all the newly generated tokens to the current generation and begins a new loop untilacompletepatchisgenerated.theloopstopswhenthemodel generatesthe specialtoken end token.
algorithm 1detailsthisprocessandshowshowacompletepatch programisgeneratedusingwhatisestablishedin .itadditionally describes how repilot performs the pre processing lines 3to6 and formalizes completion guided pruning procedure illustrated in figure 5using two functions guidedprune andactivelycomplete lines7to17 .
in all our algorithms we use a dotnotation tospecifyanentityofatuple e.g.
lm.encode butuse anabbreviationformwhenthecontextisclear e.g.
lmand plfor lm.
lmandce.
pl .we also optionally apply typeannotations for clari f ication.notethatwesimplifythede f initionofthecompletion engine by restricting it to be called with one program.
in practice acompletionengineisalwaysinitializedwiththeentireproject andcan providesuggestionsbasedonglobalinformation.
.
completion guidedsearch spacepruning in this section we explain the core idea of how repilot utilizes a completionengine to prune the search spaceof an llm.
algorithm 2explainsindepthhowacompletionenginehelps prune the model s search space.
the function guidedprune takes asinputsacompletionengine ce thecurrentprogram prog the currentcaretposition caret andtheprobabilitymap tokensgivenby the model and produces a token next tokenas the continuation of theprogram progatposition caret.thefunctionconsistsofa whileloop lines 2to11 where repilot f irst samples a possible next tokenaccordingtotheprobabilities line updatesthecurrent program accordingly line and moves the caretafter next token.
repilot then invokes the completion engine using the function complete de f ined in equation .
given the program prog and thecaretposition caret .iftheresultisnot unknown butthereis no completion line it means that no possible continuation can 176esec fse december3 san francisco ca usa yuxiang wei chunqiu stevenxia andlingming zhang token sampling looplanguage model completion engineactive completion completion engine pruning new tokens endtag string name t.as ... generated tokens ... string ... memorization trie search space ... name91 string end .
pruned search space0 name0 string end .
... end prune with memorization obtain probabilities from language model1check memorization2 update memorization5 prune using completion engine43 token accepted6 actively complete the token7update the patch with new tokens8 figure overview of repilot.
algorithm1 mainrepairloopof repilot inputs large language model lm completion engine ce buggy programprog andrange ofbuggyhunk range.
output patch forthe buggyprogram.
funcrepair lm ce prog pl range n n pl initializationsbased on de f inition .
encoder inputs lm buildinputs prog range encoded rep encrep lm.encode encoder inputs decoder lm decrep lm.decode encoded rep hunk lm u1d700 whiletruedo formpatchby replacing buggyhunkwith hunk patch prog movecaretafterthe currentgeneration caret range.start str hunk tokens lm decoder hunk next token lm guidedprune ce patch caret tokens ifnext token end tokenthen returnpatch completion toks lm activelycomplete ce patch caret hunk hunk next token completion toks be formed after next token so the token next tokenis considered infeasible thus pruned line9 inthisroundofsearch andtheloop willcontinue line .otherwise weconsiderthetokenfeasible andreturn next token line11 .
thepruningatline 9isdonebysettingtheprobabilityofthe entrynext tokenoftheprobabilitymap tokenstozero.thenotation usedat this lineisde f inedsubsequently.assumethat f x y x0 y0 x1 y1 ... .
isan arbitrary function and a x y x y x y ... .
isapartialfunction ofthesametype meaningthatonlyasubsetof inputs in the domain xis associated with an output in the range y. we de f ine the action of changing the output values of the inputs in fusing the assignments given by aas f f fremoved a wherefremoved x f x x y a .
.
.
memorization forfaster search algorithm guidedprune involves a loop of trials and pruning actions which slows down the repair task in some situation.
toalgorithm2 completion guidedsearch space pruning inputs completion engine ce current program prog caret position caret andtoken probability map tokens.
output nexttoken next tokento generate.
funcguidedprune ce prog caret tokens lm lm whiletruedo next token lm sample tokens prog prog caret caret str next token completions p pl unknown completions ce.complete prog caret ifcompletions unknown and completions 0then tokens tokens continue returnnext token speedup its search procedure we apply several memorization techniques to reduce the frequency of invoking the completion engine for analysis.
memorizing rejectedtokens.
to repair a bug in practice requires generatingplentyofsamples meaningthatthesameprogram prog andcaret lines4to5 mayoccurrepeatedlyinalgorithm guidedprune .therefore wecanmemorizeallthetokensprunedat line9bystoringtheminavariable rejected pl n p lm .
whichmapsfromaprogram progandacaretposition carettoaset of rejected tokens.
then we zero the probabilities of the rejected tokens inadvance written as tokens tokens .
before the while loop line starts.
memorizingacceptedtokens.
besidesrejectedtokens wecanalso memorizetokens that are acceptedbefore inavariable accepted pl n p lm .
to avoid the overhead incurred from querying the completion engine at lines 7to8.
buildingapre f ixtreeofrejectedtokens.
itiscommonthatmany tokens in the vocabulary of the language model are pre f ixes of another.anditisobvious thatifatokenisrejected meaningthat no possible continuation can be formed after the token to obtain a staticallyvalidprogram thenanytokensharingsuchpre f ixshould be rejected.
for this reason we build and keep updating a pre f ix tree or trie of all the rejected tokens given progandcaret and 177copilotingthe copilots fusing large languagemodelswithcompletion enginesforautomatedprogram repair esec fse december3 san francisco ca usa checksifanyofthetokensinthetrieisapre f ixof next tokenright afterline 3inalgorithm .ifitisthecase repilotdirectlyskipsto the nextiteration avoidingfurther analysis.
.
activecompletion notonlyisacompletionengineabletodeterminethefeasibilityof apossiblenexttokensuggestedbythemodel asshownin .
butit can alsoproactively suggest a potential continuation of the current program without querying the model just like how developers bene f itfrom autocompletion.
algorithm 3describes active completion indetail.
thefunction activelycomplete takesthreeinputs thecompletionengine ce the current program prog and the current caret position caret and outputsasequenceoftokens completion toksasthecontinuationof progatcaret.
initially repilot gets the completion result according toequation .
givenprogandcaret line2 andchecksifitis unknown line3 .
if it is the case completions unknown the result is set to an empty string meaning no extra completions are produced line .
otherwise repilot calculates the common pre f ix ofallthecompletions line .notethatthetypeoftheresultant variablecompletion isasequenceofcharactersintheprogramming language alphabet different from the language model s lm so repilot further aligns the completion to f it the model s vocabulary line7 .
finally the result isreturnedat line .
algorithm3 active completion inputs completion engine ce program prog andcaret position caret.
output theactivelycompleted tokens completion toks.
funcactivelycomplete ce prog caret lm completions p pl unknown ce.complete prog caret ifcompletions unknown then completion toks u1d700 else completion pl commonprefix completions completion toks lm aligntokens lm completion returncompletion toks .
soundness of repilot inthissection weshowthetheoreticalguaranteeofeachalgorithm discussedabove underthe condition that thecompletion engine is strict de f inition .
.
lemma4.
soundnessofpruning .
thetokensprunedaway in algorithm guidedprune resultin infeasbileprograms.
discussion.
from equation .
in de f inition .
we can deduce that a program is infeasible at some caret position if the completionenginedoesnotreturn unknown butthesetofcompletions isempty i.e.
completions prog caret ifcompletions unknown .
thepruningatalgorithm 2happensatlines 8to9 whichisexactly what is described above.
as a result we can conclude that the programwith next tokenappendedisinfeasible andhenceitissafe for repilot to abandonthe token.
lemma4.
soundnessofmemorization .
thememorization discussed in .3does not affect guidedprune s behavior.
discussion.
thetheoremholdsbecauseallthememorization techniquesmentionedin .3donotchangethesemanticsof guidedprune but only speedupthe process.
lemma4.
soundnessofactivecompletion .
ifaprogram is feasible at some caret position the new program produced by algorithm3 activelycomplete is feasible at itsnew caret position.
discussion.
based on equation .
from de f inition .
any continuations not matching the set of completions would bring aboutaninfeasibleprogram.inthecasewherethesecompletions have a shared common pre f ix any continuations not starting with this common pre f ix would be invalid.
therefore completing the originalprogramwiththecommonpre f ix line 6inalgorithm isthe only wayto yieldanewfeasible program.
on the basis of lemmas .1to4.
we can easily prove that repilot soverallalgorithm issound.
theorem4.
overallsoundness .
algorithm repair does not miss any feasible programs in the language model s search space.
when will repilot fail?
although the theorems are about the soundnessof repilot i.e.
it prunesthesearchspacecorrectly itdoes notprovidesanyguaranteethatrepilot producesavalidpatch every time.
therefore repilot s expected behavior is to be able to obtain valid patches more efficiently rather than being entirely error free duringthe generation.
experimentalsetup inthispaper westudythefollowingresearchquestionstoevaluate repilot.
rq1 how does repilot s bug f ixing capability compare with state of the artapr techniques .
?
rq2 how effective is repilot in improving the compilation rate ofpatch generation .
?
rq3 areallcomponentsof repilotmakingpositivecontributionsto its effectiveness .
?
rq4 can repilot generalize to different subjects of bugs and models .
?
we f irstcomparetherepairperformanceof repilot instantiated withcodet5 againststate of the artaprtoolsacrossbothtraditional nmt based and llm based tools on the defects4j datasets inrq1.inrq2 wethencloselyevaluatetheimprovementincompilationrate percentageofcompilablepatchesgeneratedtodemonstrate that repilot is not only effective in bug repair but can generate a higher number of compilable patches compared with existing tools.
furthermore we perform a detailed ablation study in rq3 to evaluate the contribution of different components of repilot.
finally in rq4 we extend our evaluation of repilot beyond its use withcodet5inthepreviousrqs.wegoastepfurtherbyimplementingrepilotwith incoder andassessingtheperformanceof repilot usingboth codet5and incoder onsingle hunkbugs from both defects4j .
and .
to demonstrate the generalizability of repilot acrossdifferentllmsandbugsubjects.
178esec fse december3 san francisco ca usa yuxiang wei chunqiu stevenxia andlingming zhang .
implementation we use the python implementation of the codet5 large and the incoder .7b models obtained on hugging face .
we build our generation pipeline in python with 5k lines of code and implementamodi f iedversionoftheeclipsejdtlanguageserver in java with .5k additional lines of code which serves as the strictcompletion engine of our framework.
our default generation usestop p nucleus sampling with u1d45d .
temperature .
u1d45a u1d44e u1d465 u1d461 u1d45c u1d458 u1d452 u1d45b u1d460 50and samples times per bug for fair comparisonsagainstpriorworks .1and .
.duetothehigh cost of apr we sample times per bug for the ablation study .
and the generalizability evaluation .
.
following prior work weuseatimeoutof5hourstogenerateand validate all patches per bug.
we generate and validate patches on a corewithryzenthreadripperpro3975wxcpu 256gbram and nvidia rtx a6000 gpu runningubuntu20.
.4ltswith java versionopenjdk .
.0 181. .
subject programs we use the popular repair benchmark of defects4j for our evaluation.
defects4j is a manually curated java dataset with pairs of buggy and patched versions of the source project along with developer test suites for validation.
following prior work and apr literatureconvention weseparatedefects4jintodefects4j1.
containing bugs removing depreciated bugs from java source projects anddefects4j2.
containing438newbugsfrom9additional projects.
for defects4j .
we focus on only the single hunk bugs as repilot is designed for single hunk repair.
note this is also the evaluation setting used in the prior baseline .
furthermore weremovethebugsthatareincompatiblewithourcompletionengineduetoengineeringissues.intotal weconsider138single hunk bugsfromdefects4j1.2and135single hunkbugsfromdefects4j .
.forourmainevaluationinrq1 followingthesamesetupas priorllmforaprwork wereporttheresultsonall135 single hunk bugs from defects4j .
and single line bugs a subsetofsingle hunk bugs fromdefects4j2.
.meanwhile inour generalizabilitystudy rq4 wefurtherevaluaterepilotonthefull set of single hunk bugs from both defects4j .
and .
for both codet5 and incoder.
.
comparedtechniques wecomparerepilotagainststate of the artbaselinesfromtraditional nmt based and llm for apr tools.
we evaluate against alpharepair as it is the top performing llm for apr approach.
for nmt based approaches we choose recent tools rewardrepair recoder cure coconut dlfix and sequencer based on the nmt architecture.
additionally wecompareagainst12traditionalapr tools prapr tbar avatar simfix fixminer capgen jaid sketchfix nopol jgenprog jmutrepair andjkali .altogether weinclude19aprbaselinesand compare repilot against them on defects4j .
and .
.
our evaluationsettingisonperfectfaultlocalization wheretheground truth locationofthebugisgiventotheaprtool.wenotethatthisisthe preferred evaluation setting as it eliminates any differences caused bydifferentfaultlocalizationmethods .wefollowthetable1 numberofcorrect f ixesondefects4j1.2single hunk anddefects4j .
single linebugs tool methodology correct fixes defects4j .
defects4j .
total coconut nmt dlfix nmt prapr template tbar template cure nmt rewardrepair nmt recoder nmt alpharepair llm repilot llm repilot rewardrepairalpharepairrecoder cure repilot rewardrepairalpharepairrecoder others a with best llm and nmt based baselines b with all apr tools figure correct f ixvenndiagramson defects4j .
conventionusedinpriorwork anddirectlyreport the bug f ixresults obtainedfrom previous studies .
.
evaluationmetrics plausiblepatches arepatchesthatpassalltestcasesbutmay violate the real userintent.
correct patches are patches that are semantically equivalent to the developer patch.
following common apr practice we determine semantic equivalency by manually examining each plausiblepatch.
patch compilation rate is also used in many deep learning based apr works which indicates the percentage of compilablepatchesinallgeneratedpatches.
resultanalysis .
rq1 comparisonwith existingtools in rq1 and rq2 we follow the prior approach for cloze style apr to makeuse ofrepairtemplates forafaithful evaluation.
instead of replacing the entire buggy line with model generated code thesetemplatessystematicallykeeppartsofthebuggyline to reduce the amount of code the llm needs to generate.
note thatwedonotapplyanyrepairtemplatesinrq3andrq4because we consider a smaller number of samples there i.e.
samples as shown in section .
and also want to focus on the impact of differentexperimental con f igurations.
defects4j1.
.
we f irstcomparerepilotagainstthestate of the art aprtoolsonsingle hunkbugsfromdefects4j1.
.table 1shows the number of correct patches produced by repilot evaluated in cloze style along with the baselines.
repilot achieves the new stateof the artresultof66correctbug f ixesondefects4j1.
outperforming 179copilotingthe copilots fusing large languagemodelswithcompletion enginesforautomatedprogram repair esec fse december3 san francisco ca usa private string getremainingjsdocline string result stream.
getremainingjsdocline unreadtoken no unread token return result unreadtoken no unread token bug id closure patch generation processllmcompletion engine figure uniquebug f ixby repilot on defects4j .
all previous apr tools .
figure6a shows the venn diagram of the unique bugs f ixed for the top performing llm and nmt based apr tools where repilot is able to obtain the highest number of 8uniquebugsfurthermore figure 6bcomparestheuniquebugs f ixed for all top performing baselines and with all other apr tools combined others .
we observe that repilot is able to f ix bugs that nootherbaselineshave been ableto f ixsofar.
to demonstrate the ability of repilot to f ix difficult bugs figure7shows a unique bug closure from defects4j .
that only repilot can f ix.
this bug is f ixed by adding the new assignmentstatementusingtheglobalvariable no unread token whichis difficulttogenerateasitdoesnotappearwithinthesurrounding contextofthebuglocation.repilot f irstusescodet5togeneratethe initial pre f ix of unread.
then using the completion engine repilot recognizes that tokenis the only semantically correct continuation anddirectlyperformsactivecompletiontoreturn unreadtoken .similarly for generating no unread token repilot f irst generates no and then uses active completion to directly generate this rare identi f ierwithouthavingtorepeatedlysamplethellm.itisdifficultfor prior llm and nmt based apr tools to generate this f ix as llms or nmt models may not be able to complete this rare identi f ier since it requires multiple continuous steps to generate.
in contrast repilot throughtheuseofactivecompletion candirectlygenerate this rare identi f ier given only the initial identi f ier pre f ix to quickly arrive at this correctpatch.
defects4j .
.
we further evaluate repilot against baselines evaluatedonthesingle linebugsindefects4j2.
.forthesebugs we followpriorapproachforcloze styleapr tomakeuseofrepair templates.insteadofreplacingtheentirebuggylinewithmodelgenerated code these templates systematically keep parts of the buggyline e.g.
pre f ixorsuffix methodparametersandcalls toreducetheamountofcodethellmneedstogenerate.weapplythese repairtemplatesfordefects4j2.0single linebugsonlysincethey aredesignedforsingle linebugs.table 1alsoshowsthenumber ofcorrect f ixesondefects4j2.0comparedwiththebaselines.we observethat repilotisableto f ixthehighestnumberofbugs50 morethanthenextbestbaseline ondefects4j2.
.
thisimprovement over existing baselines shows that repilot can generalize to two versionsofdefects4jdatasetsanddemonstratesthepowerofrepair templates to boost the performance ofllm basedapr tools.
figure8showsauniquebugfromdefects4j2.0thatonlyrepilot can f ix.first repilotgeneratesthepatchuptothecaretposition.
thecompletionenginethen capturestheexacttypeof theobject fromtoken.endtag tostring.
using this information repilot correctlyprunestokensthatarenotapartofthe stringclass e.g.
name andtext .
hence the generated patch contains a valid stringclass private void popstacktoclose token.endtag endtag string elname endtag.name string elname endtag.name .tolowercase element firstfound null bug id jsoup patch generation processstring elname endtag.name .text name ... tolower type token.endtagtype string completion enginefigure uniquebug f ixby repilot on defects4j .
table2 comparisonwithexistingaprtoolsoncompilation rate on defects4j .
.
denotes data notavailable.
tool compilable patches top top top top sequencer coconut cure alpharepair rewardrepair 1repilot 1thisisthe top200ratefor rewardrepair as it doesnot include top1000 method of tolowercase which correctly f ixes this bug.
similar to the previous unique bug f ix in defects4j .
prior llm based aprtoolsmaywastealotoftimegeneratingsemanticallyincorrect continuations as they do not have access to the type information.
furthermore nmt based apr tools such as cure over approximatingthelistofvalididenti f iersbystaticallygrabbing all the accessible f ields may not generate this f ix since a pruned identi f ier e.g.
name can also be valid for a different object type.
repilot uses the completion engine to analyze partial programs andrealizecomplex type propagationfor effective pruning.
.
rq2 compilationrateanalysis we evaluate the compilation rate of the patches generated by repilot compared with prior learning based apr techniques.
table shows the percentage of compilable patches on the defects4j .
dataset.weobservethatacross allnumbersofpatchesgenerated repilotsigni f icantlyimprovesthepercentageofcompilablepatches compared with prior tools.
we f irst notice that llm based apr tools repilotandalpharepair areabletosustaintheircompilationratecomparedwithnmt basedtools coconutandcure where the compilation rate drastically decreases as we increase the number of patches.
this shows the ability for llms to generate large amounts of reasonable patches.
repilot is able to sustain a near compilationpercentage at patches generated while the prior approach isbarelyabove .
compared with cure where an overestimation of valid identi f iers is obtained via static analysis and used to prune invalid tokensgeneratedbynmtmodel repilotleveragesthepowerful completionenginetokeeptrackofthecurrentcontexttoobtain a more accurate pruning step.
furthermore compared with rewardrepair where the compilation rate is boosted through penalizinguncompilablepatchesduringtraining repilotdirectly uses a llm combined with a completion engine to avoid this high 180esec fse december3 san francisco ca usa yuxiang wei chunqiu stevenxia andlingming zhang table componentcontributionof repilot variant generation time compilable patches plausible patches plausible fixes correct fixes repilot .232s .
.
repilotp0.294s .
.
repilotm p0.255s .
.
repilot .248s .
.
costoftraininganewmodel.additionally repilotusestheactive completion ability of completion engine to directly generate these rare identi f iers to further boost the compilation rate.
as such repilot is able to achieve the highest percentage of compilable patches acrossallfourdifferentsettings.
.
rq3 ablation study tostudythecontributionofeachcomponentof repilottoitsoverall effectiveness we conduct an ablationstudy that aims at justifying the following hypothesis algorithm guidedprune helpsllmtoachievevalid compilable patchesmore efficiently onaprunedsearchspace.
memorization .
reducesthefrequencyofqueryingthecompletion engine thus speeding uppatch synthesis.
active completion provides further guidance of synthesis that andhelpsrepilot efficiently achieve more valid patches.
the plausible rate of patches becomes higher along with the compilation rate.
togivegroundsforthesehypotheses wesetupthefollowing fourvariants repilot uses only the basellm codet5 for patch synthesis.
repilotpapplies pruning de f inedinalgorithm .
repilotm pleveragesmemorization .
ontop ofpruning.
repilot employs active completion for further guidance.
andevaluatethembycomparingthemagainsttheirefficiencyin generatingcompilable plausiblepatches andcorrectpatches.
table3shows the generation time in seconds per patch the contributionintermsofthepercentageofcompilableandplausiblepatchesamongalluniquelygeneratedpatches thenumberof plausible f ixes and the number of correct f ixes for each of the four variantsondefects4j1.2single hunkbugs.we f irstobservethat just using the base llm for apr repilot we achieve the lowest compilationrateat43.
.byaddingthepruningprovidedbythe completion engine we can signi f icantly improve the compilation rateto60.
thenumberofplausible f ixesfrom56to62 andthe numberofcorrect f ixesfrom37to41.additionalimprovementis made by adding the active completion technique to achieve the full repilot with the highest compilation rate at .
plausible percentage .
the most number of plausible f ixes at and the mostcorrect f ixes at .
looking at the patch generation time starting from repilot addingpruningviacompletionengineincursanover25 overhead.
however this can be signi f icantly reduced by using memorization repilotp to achieve around overhead by avoiding querying thecompletion engineoncewe knowanidenti f ier isinvalid.
furthermore active completion can further reduce the overhead to7 sinceinsteadofhavingtosamplethellmforeachstepinthe generation we can activelycomplete an identi f ier.
asaresult allthecomponentscontributetotheoveralleffectivenessof repilot.repilotcanconsistentlyincreasethecompilation andplausiblerate aswellasproducemoreplausible correct f ixes while incurring minimal overhead compared with directly using llmsfor patch synthesis.
.
rq4 generalizability to demonstrate the generalizability of repilot across different subjects of bugs and models on the one hand we further evaluate repilotwithcodet5onallsingle hunkbugsofdefects4j2.
.on the other hand we additionally instantiate and evaluate repilot withalarger incoder .7bmodel.identicaltorq3 wealsoconduct 500samples inrq4 dueto the high costof apr.
table4shows the comparison between the baseline repilot and our full repilot approach across different subjects of bugs and models.weconsiderthesamesetofdefects4j1.2single hunkbugs as inrq3 andan extrasetof defects4j2.
single hunkbugs.
upon investigation we can see that repilot with codet5 surpasses the baseline on defects4j .
as illustrated in rq3.
furthermore ondefects4j2.
itcanalsoachieve18.1percentagepoints pp morecompilableand3.0ppmoreplausiblepatches aswellas6 moreplausible f ixesand4morecorrect f ixes witha7.
overhead.
meanwhile whenrepilotisinstantiatedwith incoder itstill producesmorecompilableandplausiblepatches aswellasmore plausibleandcorrect f ixesonbothdefects4j .2and defects4j2.
over the baseline incoder.
it eventually gives more correct f ixes ondefects4j1.
and1more ondefects4j2.
.
one major difference comparing repilot with incoder and codet5 is that when repilot is equipped with incoder a much larger model than codet5 it incurs negligible overhead.
this is becausecomparedtothehighcostofautoregressivesamplingusing largermodels theextracostfromqueryingthecompletionengine ismuch smallerand thustrivializesthe overheadof repilotwhen appliedonlargermodels.also thelarger incoder model whether or not it is applied with repilot can consistently f ix more bugs across bothdefects4j .2and2.0thancodet5 further con f irming prior f indingthat larger llmsoften perform betterfor apr .
overall theexperimentalresultsindicatethatrepilotcangeneralizetodifferentsetsofbugs bothsingle hunkbugsindefects4j .
and2.
as well as larger llms incoder limitations first to bring out repilot s full potential it is important that the completionenginecanprovideusefulguidancewhileremaining strict de f inition .
.
however it is generally more difficult to balance the usefulness and strictness of a completion engine in many dynamically typed programming languages such as python comparedwithjavastudiedinthispaper whichisastaticallytyped programming language.
meanwhile there is a growing trend of dynamicallytypedlanguagesadoptingsupportfortypehints .consideringthis webelievethatrepilotcanstillprovide signi f icant advantagesinsuch environments.
another limitation of repilot lies in the evaluation.
on the one hand while it is true that an increase in the compilation rate of 181copilotingthe copilots fusing large languagemodelswithcompletion enginesforautomatedprogram repair esec fse december3 san francisco ca usa table generalizability of repilot across bothsubjectsofbugsand models variant model subject ofbugs generation time compilable patches plausiblepatches plausiblefixes correct fixes repilot codet5 large defects4j .
.232s .
.
repilot codet5 large defects4j .
.248s .
.
repilot codet5 large defects4j .
.230s .
.
repilot codet5 large defects4j .
.247s .
.
repilot incoder .7b defects4j .
.70s .
.
repilot incoder .7b defects4j .
.70s .
.
repilot incoder .7b defects4j .
.67s .
.
repilot incoder .7b defects4j .
.69s .
.
repilotcanleadtothediscoveryofmoreplausibleandcorrect f ixes it is important to note that a signi f icantly higher compilation rate does not necessarily translate to a proportionally large increase in plausible and correct f ixes.
on the other hand repilot is only evaluated with codet5 for rq1 and rq2 with a sampling budget.codet5isarather small llmcomparedtothosellms with billions of parameters.
although we further include incoder6.7b as a multi billion parameter llm in rq4 due to time cost we only sample times per bug which may be insufficient to re f lect the distribution of the generated patches.
overall the scope of our evaluation consideringtwollms codet5 and incoder and one programminglanguage java isstillnarrowgiventhatrepilotis ageneralframeworkthatcanbeinstantiatedwithanypairofan llmandacompletionengine for someprogramming language.
finally despite the examples we show in the paper our evaluation lacks strong empirical evidence to support the claim that llms have difficulty in generating rare tokens and how repilot solvestheproblem.besides ourevaluationlimitstheapplication of repilot to patch synthesis even though we claim that repilot canbeappliedtoothercodegenerationtasks.inthefuture wewill apply and evaluaterepilot on more diverse code generation tasks.
threats to validity internal.
we share thesame main internal threat to validity with prioraprtoolswherewehavetomanuallyexamineeachplausible patch to determine patch correctness.
we address this by carefully analyzingeachpatchtodetermineifitissemanticallyequivalent to the reference developer patch.
furthermore we have released our full setofcorrectpatchesfor publicevaluation .
ouruseofthecodet5modelposesanotherinternalthreatwhere the open source training dataset of github projects may overlap with our evaluation of defects4j.
we follow prior work andaddressthisbycomputingthecorrectbug f ixesof repilotfrom defects4j that is part of the codet5 training data.
in total out of and out of overlap with training data on defects4j .
and2.0respectively.forcomparisonfairness ifweweretoexclude these7and6bugsandcomparethemwiththepreviousbaseline toolsontheremainingbugs wearestillabletoachievethehighest bug f ixes at and best baseline at and .
the same threat appliestotheuseof incoder butsinceitsdetailedtrainingdatais notrevealed weareunabletoexplicitlyaddressthisproblem.to mitigate the problem we only evaluate incoder in rq4 where all the variants face the same potentialleakage.moreover ourmodi f iedimplementationofthecompletionenginerequiresmanual inspectiontoguaranteesoundnessproperty.
in practice this is a signi f icant trust base that may introduce false positives during pruning.
however our theorem still provides a partialguarantee andisable to explainunsoundness.
at the same time our evaluation result justi f ies our claims and demonstrates the practicalityof repilot.
finally inourevaluation wefollowtheconventionusedinprior worktodirectlyreportthebug f ixresultswithoutreproducingthem which poses a threat to the reliability of the results.
meanwhile we onlyrun eachof our experimentsonce whichcould introduce extrastatisticalbiases.
external.
the main external threat to validity comes from our evaluation dataset where the performance of repilot may not generalizetootherdatasets.toaddressthis wecomparerepilotagainst state of the artbaselinesonbothdefects4j1.2and2.0toshowthat the performance is sustained across both versions.
to address this further weplantoevaluaterepilotonadditionalaprdatasetsalso acrossdifferentprogramming languages.
conclusion we propose repilot the f irst apr approach to combining the directusageofllms e.g.
codet5and incoder withon the f ly guidance provided by completion engines.
during autoregressive token generation repilot queries the completion engine not only topruneinvalidtokensbutalsoto proactivelycomplete thecurrently generatedpartialprogram therebyreducingthesearchspaceofthe llm.ourevaluationonasubsetofthewidely studieddefects4j1.
and2.0datasetsshowsrepilotisabletoachievethestate of the art results.
furthermore repilot through the usage of completion engine is able to generate more valid and compilable patches than priortoolswithminimaloverheadcomparedwithdirectlyusing llmsfor apr.
data availability wehaveopen sourcedrepilot whichcanbeaccessedongithub at .additionally animmutable artifact for repilot ispubliclyavailable onzenodo .