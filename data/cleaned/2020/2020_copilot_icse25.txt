measuring the runtime performance of c code written by humans using github copilot daniel erhabor university of waterloo waterloo canada derhabor uwaterloo.casreeharsha udayashankar university of waterloo waterloo canada s2udayas uwaterloo.cameiyappan nagappan university of waterloo waterloo canada m2nagapp uwaterloo.casamer al kiswany university of waterloo waterloo canada alkiswany uwaterloo.ca abstract github copilot is an artificially intelligent programming assistant used by many developers.
while a few studies have evaluated the security risks of using copilot there has not been any study to show if it aids developers in producing code with better runtime performance.
we evaluate the runtime performance of c code produced when developers use github copilot versus when they do not.
to this end we conducted a user study with participants where each participant solved two c programming problems one with copilot and the other without it and measured the runtime performance of the participants solutions on our test data.
our results suggest that using copilot may produce c code with statistically significant slower runtime performance.
i. i ntroduction advances in natural language processing and deep learning have resulted in large language models llms that can generate code from free form text.
with this language models like gpt have been extended to what xu et al.
have termed natural language to code nl2code generators.
notably open ai s extension of the gpt language model codex and the production ready product derived from it github copilot are popular examples of nl2code tools in use today.
in a recent stackoverflow survey of developers state that they use llm based tools in their development process already and plan to use such tools soon .
while some studies show that developers may have a positive experience using github copilot others show that it could generate potentially vulnerable code .
we present the first ever evaluation of copilot from a runtime performance perspective in systems programming.
we focus on runtime performance as it is critically important in large scale systems.
google notes that a few additional seconds of page load latency can increase customer bounce rates by .
amazon reports that milliseconds of latency cost them millions of dollars in revenue .
each millisecond of additional latency costs financial firms million every year .
thus large scale systems designed to maximize performance measure and report metrics such as their tail latencies and throughputs .
we conducted the first user based study on copilot to evaluate the runtime performance of the c code generated when developers use it.
with the results from our study we answer the following research questions rq0 does using copilot influence program correctness?rq1 is there a runtime performance difference in c code when using github copilot?
rq2 do copilot s suggestions sway developers towards or away from c code with faster runtime performance?
to answer these questions we conducted a user study involving participants with systems programming experience.
each participant solved two programming problems in c one was solved with copilot and the other was solved without it.
the problems were related to i o operations and concurrent programming.
we selected problems related to these two domains as they directly impact the code runtime.
we compared the runtime performance of copilot aided solutions against copilot unaided solutions obtained survey responses from participants after they completed the study and analyzed the video recordings of participants solving the problems.
our findings indicate that using copilot resulted in c code with statistically significant slower runtime performance.
specifically copilot unaided solutions were faster than copilot aided solutions on average for the i orelated problem and faster for the concurrent programming problem.
our expert solutions to the problems had up to6 faster runtime performance compared to the average copilot aided solution.
additionally copilot s aid tended to tilt developers towards code with slower runtime performance.
finally as expected higher developer experience and familiarity with the c programming language were correlated with faster runtime performance.
the rest of this paper is organized as follows we provide background related to github copilot and related work in section ii.
the process of creating the problems solved by the participants and the rationale behind choosing the problems is described in section iii.
our model solutions are elaborated in section iv.
a summary of the participant recruitment process and the participants is described in section v. we present the experiment design in detail in section vi where we cover the tasks that participants solved how tasks were split across the participants and the rationale behind it.
we analyze and discuss the results of our study answering our research questions in section vii.
we include a discussion on the participants and their familiarity with the problems in section viii.
penultimately we discuss the threats to validity of our study in section ix.
finally in section x we discuss the takeaways and potential future directions.a b p2b.cpp a.cpp b.cpp a.cpp a.cpp b.cpp a.cpp b.cppp1 p3 p4generating task design from problems assigning problems to participants to counterbalance order ef fectsproblem selection rq0 rq2rq1runtime survey data video analysis open codingfig.
overview of methodology ii.
b ackground and related work github copilot the production ready tool based on the codex model by open ai can be used as a visual studio code extension to suggest code snippets to users.
users can receive suggestions by starting to write code or by writing comments either way copilot will suggest some snippets .
a. related work runtime performance of code generated by copilot or chatgpt.
a recent study analyzes the correctness and runtime performance of solutions produced by copilot using problems from the humaneval dataset.
they focus on comparing the multiple solutions suggested by copilot.
doderlein et al.
and elnashar et al.
analyze the impact of prompt engineering on the runtime performance of solutions generated by copilot and chatgpt respectively.
mastropaolo et al.
analyze the solutions generated by copilot for different semantically equivalent task descriptions.
nascimento et al.
evaluate the runtime performance of code produced by chatgpt for various leetcode problems to their human written solutions provided within leetcode.
all of the past studies focus on the solutions generated by copilot or chatgpt on their own and do not look at the scenario where humans are using such tools to help write code.
in our study we examine code written by humans who use copilot.
this is a key difference between past work and our work.
security.
several studies within previous literature examine the security aspects of solutions generated by copilot.
one of the earliest such studies by pearce et al.
sought to understand how often suggestions from copilot were vulnerable to security attacks and the contexts which made copilot suggest vulnerable code.
to achieve this they prompted copilot togenerate code in scenarios where the resulting solutions could be either vulnerable or secure.
of the programs produced in these scenarios were discovered to be vulnerable.
a study by sandoval et al.
assesses the security of code written by student programmers when assisted by an nl2code assistant openai s code cushman model like copilot.
they conducted a between subjects study with computer science students where participants were tasked with implementing operations of a singly linked list in c. contrary to the previous study their results showed that copilot had no conclusive impact on security.
asare et al.
use a previously curated set of common c c vulnerabilities from human developers to assess whether copilot introduces similar vulnerabilities when presented with the same scenarios.
they conclude that while copilot is susceptible to introducing a few previously seen vulnerabilities it fares better than human developers in a majority of the cases.
other factors influencing runtime performance.
numerous studies examine the impact of other parameters such as software refactoring and specific code changes on the runtime performance of open source software repositories.
these are orthogonal to our paper as we focus on evaluating the code generated by github copilot.
copilot for alternate problem domains.
drori et al.
evaluate the effectiveness of copilot when generating programmatic solutions to university level linear algebra problems.
tang et al.
use copilot to tackle university level probability and statistics problems.
dakhel et al.
report the correctness ratio of solutions generated by copilot for fundamental algorithmic problems.
in addition they compare copilot s solutions against studentsubmissions for python programming assignments.
they found that while copilot often generates buggy code its repair costs are less than those of similar buggy student solutions.
while they report the optimality of copilot s solutions to the algorithmic problems they do not report the runtime performance of it s solutions to the python assignments or compare them against human submissions.
imai et al.
compare copilot against human pair programming by having participants develop a text based minesweeper game in python.
nguyen et.al evaluate copilot using randomly chosen questions from leetcode primarily focusing on solution correctness and comprehensibility.
liu et al.
characterize the correctness and maintainability of chatgpt s solutions for programming tasks.
choudhuri et al.
look at the benefits and challenges faced by students when using chatgpt for software engineering tasks.
while this study does compare participants who used other resources with students who used chatgpt they did not look at the runtime performance of code.
sobania et al.
compared copilot s solutions against programs synthesised using genetic programming.
they found that genetic programming models are more expensive to train and can sometimes result in solutions which aren t easily comprehensible for humans.
they primarily examine the correctness of solutions generated using copilot and not their runtime performance.
experiment with humans using copilot unlike a majority of past studies that focus on the solutions generated by copilot on its own we focus on the scenario where humans are using such tools to help write code.
copilot was never meant to work without a human at least to date.
therefore these related studies do not examine copilot in its intended environment and do not analyze the impact that such tools can have on software developers.
our study on the other hand is a more realistic experimental setting of how humans will use these tools.
finally studies using copilot without humans are limited to a set of simpler problems that can be auto generated in full by copilot.
thus we are also able to examine more complex problems.
neither of our problems can be solved by copilot with just a prompt and without human intervention.
to the best of our knowledge we are the first study to carry out a controlled experiment of the runtime performance of code written by humans working in tandem with copilot.
iii.
p rogramming problems solved by participants following in the same vein as pearson et al.
we provided incomplete code for participants to implement as a solution to a given problem i.e.
we provided code stubs and accompanying documentation for the solutions participants were asked to implement.
we call the stubs problems throughout this paper.
these problems were provided to participants as a cpp file containing the function declaration the unimplementedfunction definition that participants were expected to implement i.e.
the primary function initialization functions and sanity checks to verify correctness.
a main function was also provided as an entry point to call the initialization functions the primary function and the sanity checks in the appropriate order.
a. problem selection we chose two problem domains for our programming problems file system operations and multi threaded programming.
we chose these areas because problems in those domains directly impact application runtime performance.
with file i o operations accounting for about of interactions in networked file systems there is a need for file system operations to be fast on storage devices .
choosing a problem related to file systems reflects this demand.
additionally since modern computing is moving towards a more parallel domain there is a need to understand the bottlenecks of multithreaded applications and optimize accordingly.
to reflect this we chose a problem related to false sharing a typical multi threading optimization problem .
we chose problems that fit the following criteria the problem must have more than one solution where each solution differs not in correctness but runtime performance the problem should be solvable with or without copilot assistance in minutes.
b. problem a file system operations for problem a participants were asked to read records from three large text files.
a record is a sequence of bytes each file was 1gb.
the read operation is specified by filecombo a struct that specifies which file to read from and at what offset.
the filecombo struct also has a buffer to hold the record read from a file.
for this problem participants received the cpp file and the three text files.
the full function signatures the cpp file and the accompanying documentation given to participants for problem a are shown in appendix a. .
c. problem b multi threaded optimization for problem b participants were asked to use a certain number of threads to set all the values in a source array buffer to zero while setting all the values in a destination array buffer to a particular value.
however they were not allowed to use assignment operations i.e.
move and copy semantics were not allowed on either the source array buffer or the destination array buffer.
participants were only allowed to increment or decrement the values in the respective array buffers.
this restriction was in place because we wanted threads to access and modify array items repeatedly potentially experiencing false sharing.
the full function signatures the cpp file and the accompanying documentation given to participants for problem b are shown in appendix a.
.iv.
m odel solutions to the problems we created model solutions to each problem.
because there was more than one solution to each problem each solution we derived differed only in performance and not correctness.
we itemize our solutions here and categorize them into levels l0 l3 for problem a and levels l0 l1 for problem b. higher levels correspond to faster runtime performance i.e.
l3 has a faster runtime than l0.
details about each of these implementations for both problem a and problem b can be found in appendix b .
a. problem a solutions level a naive solution to problem a where calls to open seek read and close are made for each filecombo .
level using the knowledge that only three files are being interacted with we do not need to open andclose a file for each filecombo .
this optimization involves first opening all the files in file names and closing them only after all filecombos have been processed.
this avoids the repeated opening and closing of file descriptors which is detrimental to runtime performance.
level within this optimization we sort the filecombos byfileid and break ties by offset before reading the files from storage.
as a result reading records within each specific file will be sequential and not random.
such sequential accesses reduce disk response times thereby improving program runtime performance.
level the combination of the l1 and l2 optimizations we outlined above gives us the l3 optimization level representing the best model solution to problem a. b. problem b solutions level consider a solution to problem b using thread count concurrent threads.
a naive solution to this problem is one where all threads start at indices between andthread count 1in the srcanddstarrays.
each thread then decrements and increments one item insrcanddst respectively.
after processing their respective items each thread moves thread count steps until the next index and processes theitem therein.
for instance with a thread count of threads would start at indices increment and decrement their respective items before moving steps ahead to their next index.
this is a naive solution because it promotes false sharing.
due to the contiguous nature of the src and dst arrays threads working on items with neighboring indices would be operating on the same byte cache lines.
as a result these threads would clash by invalidating each other s cache lines when modifying the item within the srcanddstarrays leading to cache thrashing .
level false sharing can be avoided by dividing each array srcand dst into thread count slices and assigning a single thread to process each item within a slice.
this reduces the probability of mutual cache line invalidation greatly reducing cache thrashing .
fig.
distribution of participants developer experience from screening survey on a point likert scale from no experience to years or more .
another solution to false sharing would be to add padding within the item struct definition see appendix a. bringing its size up to bytes the cache line size .
this would place consecutive items within different cache lines reducing cache thrashing .
however we chose not to allow participants to modify the struct definition as this could lead to longer debugging times potentially violating the time limit constraint for the problem.
v. p articipants a. participant recruitment participants were recruited mainly via the mailing list for computer science graduate students and snowballed to other interested participants.
we primarily targeted participants with experience in systems programming.
we considered participants who met one or more of the following conditions to have satisfied this requirement the participant has been involved professionally in the systems networking domain either via industry experience or open source contributions to systems projects.
the participant has been actively involved in a research project within the systems networking areas.
the participant has taken one or more university courses within the systems domain including but not limited to operating systems distributed systems or computer networking.
additionally potential participants needed to be familiar with c and have access to a web browser as well as github copilot on visual studio code at the time.
finally participants could not be employed by openai github or involved with the development of github copilot at the time.
to check if potential participants were eligible to participate they were sent a qualtrics screening survey after they signed the consent form declaring their intent to participate.
the screening survey can be found in appendix c .
b. difficulties recruiting professionals at the halfway point of our desired participant goal we paused participant recruitment to analyze the preliminary datafig.
distribution of participants familiarity with c from screening survey on a point likert scale from not familiar at all to extremely familiar .
collected.
a majority of the preliminary participants thus far had been graduate students with systems experience i.e.
they were part of systems focused research groups.
we decided to diversify our participant pool by including professional systems developers.
the initial recruitment process for professional systems developers started with contacting university of waterloo alumni working within systems related roles.
additionally we looked for contributors to open source systems projects on github which were primarily implemented in c .
the advanced search feature was used to find projects that contained the keywords systems operating systems or databases .
we also narrowed our search to include only projects with a dedicated social platform where interested parties connect such as discord and internet relay chat irc .
while projects such as serenityos and skiftos had active discord communities their members were disinterested in the study.
attempts to garner interest within these communities were met with suggestions to reach out to other discord communities such as the osdev operating systems development discord channel and the associated irc.
within the osdev communities on discord and irc there was a general unwillingness to participate in the study.
community members cited potential copyright issues with copilot and other negative perceptions of github copilot github and microsoft as the primary reasons for their unwillingness to participate in the study.
however our persistent recruitment efforts eventually paid off as we located willing professional participants enabling us to meet our desired goal.
c. participant summary we recruited a total of participants for this study of which were systems programming professionals or contributors to open source systems projects.
of the remaining participants one was a sessional lecturer with systems experience at the university of waterloo while the rest were graduate students with a systems research focus.figures and show the distribution of participants experience and their familiarity with c .
further details about the figures can be found in appendix c .
participants were compensated for their time and the study was approved by the research ethics board reb at the affiliated university.
vi.
e xperiment design a. order of solving the problems given our within subjects experimental design where one participant solves one problem with copilot and then the other problem without it we needed to ensure that any order effects are counterbalanced across all participants.
to this end we present all the possible orders of the problems aandb with themodes candnc which indicate using copilot and not using copilot respectively.
the four possible orders of mode problem are shown in table i. the orders in table i enforced a requirement that our participant pool be a multiple of four.
hence we recruited a total of participants for the study.
first second participant id c x a nc x b p1 c x b nc x a p2 nc x b c x a p3 nc x a c x b p4 table i possible orders of mode xproblem b. session overview within this section we outline the steps carried out in each session.
further details about the tutorial process can be found in appendix d .
pre session orientation.
the session was conducted remotely via an online conferencing platform.
each session began with the facilitator introducing the study and confirming the participant s consent to be a part of it.
after this screen and audio recording consent for the session was obtained as well.
finally the facilitator gave the participant a few basic tips for using copilot such as accepting and rejecting suggestions.
session goals.
participants were given two c programming problems to solve during the session.
each prompt was self contained within a c file and participants were given a compressed archive containing this file.
this compressed archive was sent to the participant via the conferencing platform s chat feature or google drive if technical issues occurred .
the participant was asked to extract the contents of the archive but not open them until the facilitator gave them the signal.
after verbally confirming that the participant was ready for the screen capture process to begin they were asked to share their screen and view the c file.
the facilitator then confirmed that all extensions except for the copilot extension were disabled.
the participant 1keybinding related extensions like vscode vim and ssh related extensions like remote ssh were the only exceptions allowedcould easily switch between their browser and vscode.
the participants were also reminded that the browser and other online resources could be used in addition to github copilot.
timing constraints.
before commencement the participants were notified that they had minutes to tackle each problem.
participants were also alerted at regular intervals such as when and minutes were remaining for each problem.
after each problem.
once the participant declared that they were done with a problem or the timer ran out the facilitator stopped the timer and notified the participant.
they were then instructed to compress their solution and send it back to the facilitator via the conferencing platform google drive or email.
once this step was completed participants were asked to deactivate copilot if activated as well as to close their vscode window browser window and any other