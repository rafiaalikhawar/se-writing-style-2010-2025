detectingnode.jsprototypepollutionvulnerabilities viaobject lookup analysis song li lsong18 jhu.edu johns hopkins university baltimore maryland usamingqingkang mkang31 jhu.edu johns hopkins university baltimore maryland usa jianwei hou houjianwei ruc.edu.cn johns hopkins university renminuniversityof china baltimore usa beijing chinayinzhi cao yinzhi.cao jhu.edu johns hopkins university baltimore maryland usa abstract prototype pollution is a type of vulnerability specific to prototypebased languages such as javascript which allows an adversary to polluteabaseobject sproperty leadingtoafurtherconsequence suchasdenialof service dos arbitrarycodeexecution andsession fixation.
onone hand the onlyprior work in detecting prototypepollutionadoptsdynamicanalysistofuzzpackageinputs whichinevitablyhascodecoverageissuesintriggeringsomedeeply embeddedvulnerabilities.ontheotherhand itischallengingtoapply state of the art static analysis in detecting prototype pollution becauseoftheinvolvementofprototypechainsandfine grained objectrelations includingbuilt inones.
in this paper we propose a flow context and branch sensitive static taintanalysistool called objlupansys todetectprototype pollution vulnerabilities.
the key of objlupansys is a so called object lookup analysis which gradually expands the source and sink objects into big clusters with a complex inner structure by performingtargetedobjectlookupsinbothclusterssothatasystem built infunctioncanberedefined.specifically atthesourcecluster objlupansys proactivelycreatesnewobjectpropertiesbasedon howthetargetprogramusestheinitialsourceobject atthesink cluster objlupansys assigns property values in object lookups to decreasethenumberofobjectlookupstoreachasystembuilt in function.
weimplementedanopen sourcetoolandapplieditforthedetectionofprototypepollutionamongnode.jspackages.ourevaluation shows that objlupansys finds zero day previously unknown exploitable vulnerabilities as opposed to by the state of the art dynamic fuzzing tool and three by a state of the art static analysis tool that is modified to detect prototype pollution.
to date vulnerable node.js packages are assigned with cve numbers and five have already been patched by their developers.
in addition objlupansysalso discovered seven applications or packages including a theauthorcontributedtothepaperasavisitingscholaratjohnshopkinsuniversity.
permissionto make digitalor hard copies of part orall ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
forallotheruses contactthe owner author s .
esec fse august 23 28 athens greece copyright heldby the owner author s .
acm isbn .
the inclusionofvulnerable packages foundby objlupansys .
ccs concepts security and privacy web application security software andits engineering keywords abstract interpretation prototype pollution object lookup analysis javascript acmreference format song li mingqing kang jianwei hou and yinzhi cao.
.
detecting node.js prototype pollution vulnerabilities via object lookup analysis.
in proceedingsofthe29thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse august 23 28 athens greece.
acm new york ny usa 12pages.
introduction javascriptisapopularprogramminglanguagewithmanydynamic flexible features and being used widely in different platforms includingnode.js.
for example one notable dynamic feature is that javascript is prototype based i.e.
any property lookup does not end up with the present object but goes further up to traverse a chain of prototypical objects called a prototype chain for a definition.
another interesting dynamic feature is that javascript allows flexibleredefinitionstocustomizealmostalltheobjectsincluding built infunctions.
interestingly the combinationof two aforementioned dynamic features leads to a new type of object related vulnerability called prototypepollution .specifically anadversaryabusesvulnerablepropertylookupstotraversetheprototypechainforthebase object and then redefines a built in function.
let us look at an illustrative example say there isa vulnerablestatementwith two property lookups and an assignment i.e.
obj c .
ifa b andcare all controllable by an adversary the adversary can use obj hack to redefine the built in functionobject.prototype.tostring .theconsequenceofprototypepollutionissevere includingdenial of service dos arbitrary code execution andsessionfixation according to prior work .
esec fse august athens greece song li mingqingkang jianweihou andyinzhi cao there is not much prior work on prototype pollution detection the first detection tool from arteau is a dynamic fuzzer that enumerates different possible attack inputs and then tests whether thebaseobject spropertyispolluted.althoughadynamicanalysis toollikethefuzzerhasitsadvantages suchaslowfalsepositives thedrawbacksarealsoapparent.first thefuzzermaynottriggerthe vulnerable code and thus cannot detect a vulnerability accordingly i.e.
the relatively low code coverage is an issue.
second the fuzzer needs a full installation of the target node.js package including all the dependencies which takes considerable amount of time during testing.
another classic research direction in parallel to dynamic analysisistheuseofstaticanalysistodetectjavascriptvulnerabilities.
dapp mostlyadopts abstract syntaxtree ast andcontrolflow features as simple detection patterns ofprototype pollution vulnerabilities.however becausedappcannothandlerecursive calls objectlookups e.g.
thoseviaaliases andconstraints both thefalsepositiveandnegativeratesareveryhigh i.e.
.
and .
according to the paper .
regardless of prototype pollution prior works have also adopted flow context sensitive and branch insensitive abstract interpretation to construct accurate control flows.
then some of them particularly nodest propagate taints from a sourcelikeexternalinputstoasinksuchasadangerousfunction call likeevalandexecto detect injection relatedvulnerabilities.
however state of the art taint analysis of javascript cannot detectprototypepollutionvulnerabilities.themajorchallengescome from the complexity of the sink and source structures in prototype pollutiondetection using staticanalysis.
first let us start from the sink which is a system builtin function such as object.prototype.tostring .
the challenge here is that the sink is implicit instead of a clearlydefined function like evalfor injection related vulnerabilities.
specifically an adversary needs to guide the vulnerable program to find the sink object gradually in multiple statements via different lookup paths to finally reach the target.
the aforementioned obj is one lookup path and obj is another.
the lookup path could be arbitrary long as far as the prototypechainexistsandallthelookupsofapathcanbescattered indifferentstatements acrossthe entire program.
second letusexplainthesource.manytraditionalvulnerabilities such as commandinjection usually startfrom auserinputwitha simple type like string i.e.
the source is a single value and can simply be annotated as tainted from the beginning.
by contrast theinputinaprototypepollutionvulnerabilityisoftenanobject withcomplexstructures e.g.
oneparsedfromajsoninput.the challengeisthattheinputobjectstructureisoftenunknownand dynamic i.e.
being determined by the adversary.
a simple mark of theobjectastainteddoesnotreflecttheinnerstructureandhow the structure mayaffectthe aforementionedsink objectlookup.
in thispaper wedesign a flow context and branch sensitive static taintanalysistool called objlupansys todetectprototype pollution vulnerabilities.
the key insight is that objlupansys performs a so called object lookup analysis which performs conditional object lookups to expand source and sink objects into two clustersandthenfinallyreachasystembuilt infunction.thesourcecluster starts from a few objects directly controllable by the adversaryandexpandsasthevulnerableprogramaccessesobjectsinthe cluster.forexample whentheprogramaccesses source objlupansys infersthat sourceobjecthasapropertyandthencreates one accordingly.
the sink cluster starts from a few objects accessiblebytheadversaryandexpandstowardssystembuilt inobjectsso thattheycanbeoverriddenbytheadversaryinthefuture.forexample whentheprogramexecutes obj objlupansys includes obj andobj with the conditionsthat attackval equalsto proto andconstructor respectively.
tosupportthisobjectlookupanalysis weproposeanew heterogeneousgraphstructure calledobjectproperty graph opg .
an opg represents all the object information such as variable names and properties and objects themselves as nodes in a graph like structureandthentherelationsofthosenodes suchasonecontributing to another i.e.
an object level dataflow and one being a propertyofanother viagraphedges.by objlupansys not only propagates traditional taints between objects and properties via dataflow edges but also includes more objects to expand sourceandsink clustersviaobjectproperty edges.
specifically hereishow objlupansys workstodetectprototype pollutionvulnerabilities.
objlupansys parsesatargetjavascript program into abstract syntax tree ast and abstractly interprets eachnodefollowingcontrol flowedges.therearethreestepsinthe abstract interpretation ofeach astnode.
first objlupansys constructs opg e.g.
adding or deleting opg nodes and edges by followingthesemanticsoftheastnode.second objlupansys propagates taints like traditional taint analysis.
note that if conditional objectlookupsasdescribedbelowareusedinthetaintpropagations objlupansys ensures thatall the constraints putting together are solvable.lastly objlupansys resolvesadversary controlledobject lookups.iftheobjectisnotcontrollablebytheadversarybutthe looked uppropertyis objlupansys expandsthesinkobjectcluster byaddingconditionalopgedgeswithconstraintsspecifyingthe adversary controlledvalueasthepropertynameandshortening thepathstothesystembuilt inobjects.ifboththeobjectandthe looked up properties are controllable by the adversary objlupansysexpands the source object cluster by adding a new property node to the target source object.
during the analysis if a system built in function is redefined objlupansys reports a prototype pollutionvulnerability.
weevaluatedourprototypeimplementationof objlupansys in termsoftruevs.falsepositives indirectly vulnerablepackages and performance.first objlupansys discovered61truepositivesfrom allthenode.jspackageswithmorethan1 000weeklydownloadsas opposedto18frompriorwork .11ofthemhavealreadyindependentlyverifiedbyathird partyvulnerabilitydatabasemaintainer and assigned with cve numbers.
at the same time objlupansys reports false positives the true vs. false positive ratio is comparablewithexistingvulnerabilitydetectiontools and reasonableforahumanexperttosievethrough.second objlupansysfound seven indirectly vulnerable node.js applications or packages including a real world online website .
the website is vulnerable to denial of service dos attack accordingtoourofflinetestingonalocalcopyoftheonlineversion.lastly the performance evaluation on the same benchmark shows that 269detectingnode.js prototype pollutionvulnerabilities viaobjectlookup analysis esec fse august athens greece a vulnerablecode 1function merge a b for varpinb try if b .constructor object a merge a b else a b catch e a b return a ... 16varpaypal function config 17if !config.userid 18thrownewerror config must have userid 19if !config.password 20thrownewerror config must have password ... 22this.config merge defaultconfig config ... 25module.exports paypal b exploit 1varpaypal require paypal adaptive 2varp newpaypal json.parse proto tostring polluted userid foo password bar signature abcd appid sandbox 6console.log .tostring figure a motivating example paypal adaptive with a prototypepollutionvulnerability cve foundby objlupansys .
objlupansys finishes analyzing of node.js packages with seconds.
we make the following contributions wedesignedanovelobjectlookupanalysisandproposedagraph structure called object property graph opg to support such an analysisindetecting prototype pollutionvulnerabilities.
we implemented an open sourceframework called objlupansys to generate opg perform object lookup analysis and detect prototype pollutions.
our implementation is available at .
objlupansys found61exploitablezero dayvulnerabilitiesin61 node.jspackagesandalsodetectedsevenindirectly vulnerable onesduetoinclusionofvulnerablepackages.thecompletezeroday vulnerability list is in the aforementioned github repository.
overview in this section we give an overview by starting from a motivating example andthen presenting the threatmodel.
.
a motivating example in this subsection we describe a zero day prototype pollution vulnerability cve found by objlupansys in paypal adaptive .
.
as a motivating example.
specifically paypal adaptive isansdkforpaypaladaptivepaymentsandaccounts.
users can create a paypal object with a json formatted configurationobject possiblycontrolledbytheadversary asthe!
.
.
.
!
!
!
!
!
.
!
.
!
!
.
.
.
!
.
.
!
!
!
!
!
.
.
.
.
!
.
.
.
!
!
!
figure an example object property graph note we only keepimportant i.e.
vulnerability relevant edgesandnodes and skip many others e.g.
the prototype constructor and otherbuilt inpropertiesofmanyobjects forthesimplicity andbeautyofthegraph .
parametertologintoandtransferbalancebetweenpaypaladaptive accounts.
.
.
why is the package vulnerable?
the vulnerable code of paypal adaptive particularly the vulnerable function merge is shown in figure a which recursively merges allthe properties oftwoobjects aandb.wealsoshowtheexploitcodeinfigure b anddescribehowtheexploitcodetriggersthevulnerability.briefly speaking the control flow ofthevulnerabilitytriggeringis asfollows line22 line1 line5 line1 line7.
here are the details notethat we markedtwoimportantobjectlookupsas red line line merge a defaultconfig b config .
this function call at line passes two objects to the vulnerable mergefunction.
the first object defaultconfig is created by the vulnerable program but accessible to the adversary this object is used as an entry point for further lookup to the final sinkobject.thesecondobject config isfullycontrollableby theadversaryandusedtoguidethefirstobjecttoreachthefinal sink object.
line line a merge a b .
this function call together with an object lookup the second a marked as red makes the adversary one step further to the final sink object.
specifically when we consider the original objects and the values in the exploit code the two parameters in thefunction callbecomes defaultconfig and config .
line a b .
this object lookup and assignment is the final vulnerable location which overrides object.prototype.tostring .
specifically based on the newaandb the statement will expand to the following defaultconfig config .
then based on the pvalue inconfig the assignee becomes defaultconfig i.e.
object.prototype.tostring and the assigner is config whichis polluted .
270esec fse august athens greece song li mingqingkang jianweihou andyinzhi cao .
.
howdoes objlupansys detectthevulnerability?
fromahighlevel perspective objlupansys expands both clusters and reports a prototype pollution vulnerability if a system built in object is redefined.figure 2showsboth sourceandsinkclustersaswell as objectlookupsandtaintpropagationsoftwoclustersinfigure a .
this analysis can be brokendown intofour typesof edges i two object lookups in the source cluster ii one object lookup in the sink cluster iii two data related edges with taint propagations and iv twoconditionalobjectlookups whicheventuallyleadto the built inobjectredefinition.
first we start from the two object lookups in the source cluster whicharethetwo b atlines5and7respectivelyandmarkedas edges in the source cluster of figure .
both properties are marked as wildcards because the values i.e.
p are unknown when the program looks up the properties.
by so objlupansys expands the single source object into a complex structure based on howthe program usedthe sourceobject.
second we look at one object lookup in the sink cluster which is thea at lines and marked as the outgoing red edge of the green proto node in figure .objlupansys performs sink object lookups so that the path to a target system built in objectisshortenedintermsofnumberofobjectlookups therefore objlupansys performsthelookupvia proto .notethatthe red edges are just one possible lookup path and there exists an alternativepathvia constructor andprototype whichcanalso be foundby objlupansys .
third we describe twodata relatededges.
the firststartsfrom the first wildcard property in the source cluster flows to an object andisthenalignedwiththe proto propertyinthesink cluster the second starts from the second wildcard property in the sourcecluster flowstoanotherobject andisthenalignedwiththe tostring propertyinthesinkcluster.bothalignmentsaremade byobjlupansys to reachthe final systembuilt inobject.
lastly we explain two conditional object lookups.
the first is the lookup of aat line of the second mergecall and denoted as the left outgoing edge of the anode in figure .
the lookup has a condition that the first wildcard equals to proto .
these conditions are important because some object lookups may not be solvable.
for example an adversary cannot pollute a system built in object with obj because strcannot be both proto andtostring at the same time.
the second i.e.
the one leading to a prototype pollution reported by objlupansys is thelookupof a atline7.thelookuphasaconditionthatthe secondwildcardequalsto tostring .notethattheobjectlookup alsohaveanothercondition whichisinheritedwhen objlupansys performs the firstconditional objectlookupof aat line7.
.
.
why is it hardfor existing analysis to detect the vulnerability?wenowexplainwhythisisachallengingexampleforexisting dynamicanalysis particularlythefuzzerfromarteau andexisting static analysis .
first the fuzzer from arteau cannot detect this vulnerability because the mergefunction can onlybetriggeredwhenconditionsatline17and18offigure 1are satisfied otherwise the program will exit directly.
this is a classic tradeoff between staticanddynamicanalysis.
second existingstaticanalysis doesnotdetectthis vulnerability andit is challengingfor them todoso.we listthree a vulnerablecode 1classnotes 2edit note id author raw 3undefsafe this.note list id .author author 4undefsafe this.note list id .raw note raw ... 8app.route edit note .post function req res 9body req.body 10notes.edit note body.id body.author body.raw 12app.route status .get function req res ... all elements of the commands array are known.
14for let index incommands 15exec commands shell bin bash err stdout stderr ... b exploit 1post edit note id proto .a author curl 20http x.x.x.x shell bash raw 2get status figure3 aexploitablewebserverexample leadingtocommand injection that includes undefsafe a vulnerable package foundby objlupansys .
majorreasons.
i thesourceobjectthateventuallycompromises the vulnerable program has a complex three layer inner structure.
existing static analysis only marks configas tainted and thus cannotdifferentiatethesethreefine grainedtaintflowsinvolving different parts of configas shown in figure .
ii the sink object is not directly reachable it is indirectly accessible via two object lookups and existing static analysis does not model such complex lookups.
iii thestaticanalysistodetectmanyprototypepollution vulnerabilitiesrequiresbranchsensitivity e.g.
theanalysisoflines 5and7infigure .
.
threatmodel in this subsection we describe our threat model and also a realworld example to illustrate the consequence of prototype pollution vulnerabilities.
we consider a node.js package as vulnerable to prototypepollutionifanadversarycancontrolpackageinputs e.g.
thoseinexportednode.jsfunctions whichdirectsthepackageexecution to modify abuilt in function of node.js environment.
note thatourthreatmodelalignswithexistingworksoninjected related vulnerabilities in node.js such as synode and nodest as well as historical prototype pollution and injected related vulnerabilitiesincve e.g.
cve 10744andcve .
next we illustrate an exploitable node.js web server example that we find online for the purpose of describing the vulnerability consequence.theserverincludesoneofthevulnerablepackages foundby objlupansys namely undefsafe lines3 4ofthevulnerablecode .thenameof undefsafe seemstosuggestthatitisa safepackage butithasaprototypepollutionvulnerabilityallowingadversariestopolluteanypropertiesunderthe objectobject.
specifically anadversarycancraftanhttppostrequest line of the exploit to create a property under object and then the originally safe execcall line of thevulnerable code becomes vulnerable because the injected property value is accessible via commands leadingtoacommandinjection line2ofthe exploit .
271detectingnode.js prototype pollutionvulnerabilities viaobjectlookup analysis esec fse august athens greece astobject property graph opg vulnnodeopg node edgesconstraints next ast node following control flowstep ast node interpretationabstract interpretation ...taint propagationconstraint solverstep taint analysis source cluster expansionstep object lookup analysis sink cluster expansion edgesconstraints built in redefined figure systemarchitecture.
notethatthewebserveritselfissafebecausetheinputsto exec aresupposedtoberestrictedinanenumerableset.however the vulnerabilityin undefsafe makesthis safeweb servervulnerable and leads to an even severe consequence i.e.
the execution of arbitrary os command.
design in this section we describe the designof objlupansys .
.
systemarchitecture figure4shows the overall architecture of objlupansys which takestheabstractsyntaxtree ast ofatargetnode.jsprogram as an input abstractly interprets the program and detects whether theprogramhasaprototypepollutionvulnerabilitybychecking whethera built infunction canbe redefined.
objlupansys starts from the entry points of the ast with adversary controlled parametersastaintedandfollowsthecontrolflowtoanalyzeeachast node.specifically theanalysiscanbebrokendownintothreesteps.
first objlupansys abstractly interprets the target ast node and constructs a special graph structure called object property graph opg which is used for later analysis.
second objlupansys performsataintanalysistopropagatetaintsifalltheconstraintscan be satisfied along a certain propagation path.
lastly objlupansys analyzesvulnerableobjectlookupsbyqueryingopg suchas a wherebcanbetaintedbytheadversary.
objlupansys willexpand the source and sink cluster based on whether ais tainted by the adversary and add constraints to cluster expansions.
objlupansys reports avulnerabilityif abuilt infunction isredefined.
.
ast nodeinterpretation in this subsection we describe how objlupansys abstractly interprets each ast node.
we first present the definition opg and then describe our branch sensitive abstract interpretation.
.
.
object property graph opg .
in this part we introduce objectpropertygraph opg whichisusedtofacilitateourclusterbased taint propagation.
specifically an object property graph opg is a runtime representation using graph notation of all the javascript object interplays such as object properties object value influencesandobjectdefinitions.
we start from describing opg nodes.
there are two types of nodes in opg as shown in figure object and name.
an object node represents an object of any type in the abstract interpretation.
anamenode represents an identifier.
it can be a variable name or a property name of an object.
a name node will be under a certain scope in the abstract interpretation which definesaccessibilityofjavascriptvariables.scopesareclassifiedasthree types global function file and block and are connected in a tree structurebyedges.aglobalscopenodeistherootofthescopetree and represents the global runtime environment.
function scope nodes represent the scope of functions.
block scope nodes represent the scopes of code blocks like the body of iforfor.
variables defined by letorconstare under a block scope and accessible only within the same blockscope.
we then describe opg edges which can be roughly classified as property relatedforobjectlook upsand data related.first opg has two types of edges to represent object lookups which are name objectandobject nameedges.forexample theonebetweenthe defaultconfig namenodeandtheconnectedobjectisa name objectedge.theobjectnodefurtherpointstoanamenode proto which indicatesthat defaultconfig hasa childproperty and the edge between them is an object name edge.
second opghastwotypesofdata relatededges source sinkobjectlookup alignment edges and traditional dataflow edges.
the former is made by objlupansys to align a source object lookup to a sink object lookup bymatching the input value with the property.
the latterisjustadataflowedge betweenobjectandnamenodes as showninfigure .
.
.
branch sensitiveabstract interpretation.
in this part we describethebranch sensitiveabstractinterpretationdesign.
objlupansysadopts different strategies for different types of ast nodes and constructs corresponding opg.
we describe some representative ast node types below due to space limit and similarity in semantics.
branch sensitiveinterpretationofconditionalstatements.
objlupansys executesbothorallbranchesofaconditional statement in parallel assuming that the condition can be satisfied called branching constructs opg during the execution of each branch and then merges the branched opgs into one called merging.
i branching.
during the branching stage every name object edgeinthe opg nomatter addedordeleted is accompanied by a tag to indicate the corresponding branch e.g.
consequentoralternativebranchin ifstatement andtheoperation i.e.
additionordeletion.suchatagisaddedrecursivelyif multiplebranchesarepresent i.e.
anedgemayhavetwotagsundertwonested ifstatements.when objlupansys looks up an identifier objlupansys onlyfollowsedgesthathavethecorrect branchingtagandarenotdeletedunderthisbranch.
ii merging.
duringthemergingstage objlupansys keepsanaddededge as long as the edge has one branching tagand deletes an edge if the edge is deleted by all the branches.
say for example if a variable is redefined in both branches of an ifstatement the oldname objectedgeisdeleted.however ifonlyonebranch redefinesthevariable boththeoldandthenewname object edge are preserved.
loops.objlupansys tries its best to calculate the loop conditionbased on allthe known values e.g.
constant variables and executes loops.
if objlupansys cannot estimate the number of executedtimes objlupansys executesaloopextensivelyuntil nomoreobjectsoutsidetheloopbecometainted.herearethe details based on the loop type.
i objlupansys first executes its pre run block in the forloop determines whether to run 272esec fse august athens greece song li mingqingkang jianweihou andyinzhi cao the loop and executes its post run block.
ii the procedure of a whileloopissimilartoa forloopbutwithoutpost run block execution.
iii objlupansys goes over all the properties of a for...in orfor...of loopunderatargetobjectandexecutes the loop body with each property name or object as a parameter.
functioncallandnewoperation.wegroupfunctioncalland newoperationtogetherbecausebothinvolvetheinvocationof afunction.wedescribehow objlupansys handlesbothoperationsviafoursteps.first objlupansys looksupthefunctionobjectintheopgandfindsitsdefinition.second ifthisisa newoperation objlupansys createsanewobjectandthenpoints this pointertothenewobject.
objlupansys alsoaddsthefunction objectinthe newoperationasthenewobject s constructor and the function object s prototype as the new object s proto .
third objlupansys adds dataflow edges for all the function parametersandexecutesthefunctionbody.notethatifthefunctionisabuilt inoneimplementednatively objlupansys will simulateitsbehaviorasdocumentedinecmascriptandnode.js.
lastly if this is a newoperation objlupansys points the return objectto the newobjectandalsorestores the thispointer.
.
taint analysis inthis subsection we describethetaint analysis which canbedividedintotwosub steps.first objlupansys collectstheconditions that are attached to object lookups for the target ast node and thenconvertstheseconditionsintoconstraintsthatareunderstandablebyaconstraintsolver.second ifallthecollectedconstraints are satisfiable objlupansys will propagate taints between objects basedonthe target ast node type.
.
.
constraintcollectionandsolving.
inthispart wedescribe howobjlupansys collectsandsolvesconstraintsbeforetaintpropagation.
specifically objlupansys records all the conditions attached to object lookups and then traverses backward along the dataflowedgerelatedtoeachconditiontocollectconstraints.letus takealookatline7inthesecond mergerunoffigure .objlupansyscollectstwoconditionsmarkedascirclednumbersoneandtwo infigure circledoneisfromtheobjectlookupof aandtheother circled two is from the vulnerable object lookup of b .objlupansysthen traverses backward the original dataflow edge to find the wildcardpropertiesand generates twoconstraints these two constraints are obviously solvable because they are independent from eachother.
.
.
taint propagation.
in this part we describe how objlupansyspropagatestaintsifalltheconstraintstogetheraresatisfiable.
we illustrate the propagation using two major ast node types operators such as plus and minus and built in function calls.
i objlupansys propagates taints from operands to the result for operators.
ii objlupansys modelsbuilt infunctionsandpropagates taints from parameters to the return value based on the built in function.notethatthetaintpropagationadoptedby objlupansys isontheobjectlevelinsteadofstatementlevelinprogramdependencygraph pdg .themajoradvantageisthatiftwovariables pointtothesameobject e.g.
tmp1 tmp2 objlupansys doesnot needtopropagatetaintsbecausethepropagationiswithinthesame object.source cluster expansion sink cluster expansiontarget object lookup a is a tainted?b is tainted creating a wildcard objecty n reducing lookup distance between built in objects figure flowchart forobject lookup analysis.
.
object lookupanalysis inthissubsection wedescribehow objlupansys handlesobject lookups that are potentially vulnerable to prototype pollution in figure5.
specifically we call an object lookup in the format of a vulnerableif biscontrollablebytheadversary i.e.
marked astainted.therearetwosub cases i if aisalsocontrollableby the adversary the object lookup is entirely controllable by the adversary thus being considered as an expansion of the source cluster and ii if ais not controllable but only accessible to the adversaryvia b thisobjectlookupisapathtoredefineabuilt in function thus consideredas an expansion of the sink cluster.
afterobjectlookupanalysis objlupansys willcheckwhether asystembuilt infunctionisredefined i.e.
whetherthereexistsa solvableedgefromasystemnamenodetoanattacker controlled object node.
if the answer is yes i.e.
the existence of the second conditionaledgeatthebottomoffigure objlupansys willreport aprototype pollutionvulnerability.
.
.
source cluster expansion.
in this part we describe how objlupansys expandsthesourcecluster.thehigh levelideaisthat objlupansys graduallyaddsnewpropertiestothesourceobject based on how the target program uses the object.
for example the program in figure a accesses the source object configtwice in twomergecalls and therefore objlupansys creates two wildcard properties under config.
here is the detailed procedure.
particularly when objlupansys handlesa objlupansys first createsawildcard namenodeunder a.next objlupansys looks upbto find the object node.
then objlupansys follows dataflow edges both forward and backward to find out the value of the objectnode.ifthevalueisknown e.g.
determinedbeforeinobject lookups objlupansys creates another dataflow edge between the objectandthe name node.
.
.
sink cluster expansion.
in this part we describe how objlupansys expands the sink cluster.
the high level idea is that objlupansys attempts to assign the value of bina to decrease the distance i.e.
the number of property edges between the object that a represents and built in objects like object.prototype.tostring inopg.
here is thedetailed procedure.specifically objlupansys firstlooksup btofinditsobject node.then objlupansys analyzesallthepropertiesof aandfinds thosethatcandecreasethedistance.next objlupansys creates dataflowedges betweentheobjectthat bpointstoandthose 273detectingnode.js prototype pollutionvulnerabilities viaobjectlookup analysis esec fse august athens greece properties of a. note that before creating dataflow edges objlupansyswill check whether all the constraints are satisfiable as describedinsection .
.3and3.
.
.
.
.
conditionsattachedtovulnerableobjectlookup.
inthispart we describe opg edges that are created due to the aforementioned vulnerableobjectlookupinsourceorsinkclusterexpansion.for example when a statement is res a orres a str objlupansyswill create corresponding name object or dataflow edge.
theseedgesareconditional theconditionisthatthereexistthe dataflowscreatedinclusterexpansion e.g.
bobj proto name inthe sink clusterexpansion.
therearetwothingsworthnotinghere.first theseconditions are transferrable i.e.
when conditional edges are used to create future edges these edges are also attached with conditions.
for example when the aforementioned resis used in tmp res the name object edge for the tmpnode is also attached with the samecondition.second objlupansys maycreatemore thanone paralleledgewithdifferentconditionsduringsinkclusterexpansion.
for example there are two alternative object lookup paths to reach a system built in function for the example in figure .
therefore the name node apoints to two different object nodes config.
proto andconfig.constructor with different conditions.
note that the latter is not shown in figure 2due to limited space.
implementation we implemented an open source prototype of objlupansys and released it as this repository objlupansys.git .ourimplementation has twomajorparts lines of javascript code and lines of python code.
the javascript code converts the ast produced by esprima https esprima.org tothestructureadoptedby objlupansys andalso modelsnode.jsbuilt inobjectsandfunctions.thepythoncodeis our core implementation on abstract interpretation opg construction vulnerableobjectlookups includingsourceandsinkcluster expansion andcluster basedtaint analysis.
systemevaluation in this section we describe the evaluation of objlupansys .
.
evaluationmethodologies we describe the general evaluation methodology of objlupansys .
.
.
baseline detectors ppfuzzerandppnoest.
we compare objlupansys with two baseline approaches one dynamic and the otherstatic intheevaluation.first thedynamicanalysistoolisthe onlyexistingprototypepollutiondetectiontoolfromarteau for brevity we callthe toolppfuzzerinthis paper.
second because there isnostatic analysis to detect prototype pollution we used the state of the art taintanalysis on javascript callednodest andthenmodifiednodesttodetectprototype pollution vulnerability.
the modified version is called ppnodest in the paper.
since nodest does not support opg we cannot migrate our object lookup analysis for the detection of prototype pollution.
instead for a statement a c if the base object a the lookedupproperty b andtheassignedvalue carealltainted ppnodestreportsaprototypepollutionvulnerability.wealsouploadedour implementationofppnodestas asupplementary material.
note that nodest itself is closed source and we have to reimplement it.
we did contact the authors for their source code butdidnotobtainitduetotheauthors companyrule.atthesame time wescheduledseveralconferencecallswiththeauthorsand showedthem ourimplementation.
the authors pointed outseveral missingimplementationsandconfirmedthattherestiscorrect we then added the missing implementation following the authors suggestion.
.
.
experimentsetup.
alltheexperimentsareperformedona serverwith192gb 32gbrdimm2666mt sdualrankmemory intel xeon e5 2690v4 .6ghz 35mcache .60gt sqpi turbo ht 14c 28t 135w maxmem2400mhz and4 2tb7.2krpm sata 6gbps3.5inhot plugharddrive.
.
.
researchquestions.
inthispart wedescribefourresearch questionsto be answeredinthe evaluation.
rq1 what are the tp fp and fn of objlupansys on detecting vulnerable node.js packages?
rq2 will node.js applications or packages become indirectly vulnerable dueto inclusionof avulnerable package?
rq3 whatisthecodecoverageof objlupansys onanalyzing node.js packages?
rq4 whatis performanceoverheadof objlupansys onanalyzingnode.js packages?
.
rq1 tp fp andfn in this subsection we evaluate true positive tp false positive fp andfalsenegative fn of objlupansys .weadopttwobenchmarksfor the comparison.
popular packages crawled from the node package manager npm .
specifically we crawled npm packageswithover1 000weeklydownloadsonfebruary25 .
we mainly evaluate tp and fp using this benchmark due to the lack of ground truth information in vulnerability distribution.
notethatwechoosepopularnpmpackagesbecausetheytend to be well maintained and used by many people thus increasing the impacts ofvulnerabilities.
legacyvulnerablepackagesfromcommon vulnerabilities and exposures cve database.
specifically we searchedthecvedatabaseforprototypepollutionvulnerabilities andobtained52historically vulnerablepackagesasabenchmark.
wemainlyevaluatetpandfnusingthisbenchmark because wehavegroundtruthinformationandtherearenosafepackages in the benchmark.
note that this benchmark favors ppfuzzer because manyexisting cvesare foundbythe fuzzer.
.
.
comparisonwithppfuzzer.
table1showsthat objlupansys found43morezero dayvulnerabilitiesthanppfuzzeronreal world npmbenchmarkandeightmoreonthecvebenchmark.themain reason is that vulnerable parts of packages may not be triggered in dynamic analysis.
we show a selective list of true positives in table2.
therearetwothingsworthnotinghere.first asageneraldrawback of static analysis objlupansys also produces more false positives fps than ppfuzzer.
the true vs. false positive rate of 274esec fse august athens greece song li mingqingkang jianweihou andyinzhi cao table true positive false positive and false negative of objlupansys and ppfuzzer from arteau on two benchmarks.
namereal worldnpm packages legacycve packages tp fp tp fn ppfuzzer ppnodest objlupansys branch insensitive objlupansys branch sensitive objlupansys between and is on par with prior vulnerability detection tools .
the major reason for fps isthatthereareunmodelledconstraintsbetweenobjectproperty lookupandthevalueassignment.forexample onepackageadopts object.keys to iterate all the keys under the current object and avoid a prototype chain lookup.
second objlupansys still has some fns and we describe two main reasons below.
i due tothe largenumberofallbuilt infunctions somefunctionsmaynotbe modeledin objlupansys .
ii somepackages e.g.
lodash arevery largeand objlupansys willtimeoutwithoutfinishingtheabstract interpretationafter thirtyseconds.
.
.
comparison with ppnodest a static analysis detector created from nodest.
table1also shows that objlupansys finds much more vulnerabilities than ppnodest on both benchmarks.
the reasons are described below.
first tajs the abstract interpretation toolthatppnodestandnodestrelyon isbranch insensitive.therefore ppnodestfailstodetectmanyzero dayvulnerabilitiesinan ifstatement like our motivating example.
second tajs does not support many es6 features such as arrow function which also contributessomefailedanalysis.
table1also shows that the false positive rate of ppnodest is high.
the reason is that ppnodest does not support source and sinkclusterexpansion whichcannotcapturethecomplexobject structure in both the source and the sink and propagate taints.
instead traditional taint analysis has to report many impossible cases such as a .
.
.
branch sensitivity.
the last row of table 1shows the importance of branch sensitivity in detecting prototype pollution vulnerabilities.
specifically we switch off branch sensitivity in objlupansys and show that this version of objlupansys detects significantlyfewervulnerabilities.thebranch insensitive objlupansysdetects fewer vulnerabilities on the npm packages and fewer onthe cvebenchmark.
.
.
acasestudyontruepositive.
inthissubsection weillustrate onevulnerablepackageasanexampletoillustratezero dayvulnerabilities found by objlupansys .
specifically dot object is a popularutilitypackagewithmorethan100kweeklydownloads which transforms javascript objects using dot notation.
the developer fixedthevulnerablecodeafterwereportedthevulnerabilitytothem.
figure6 a shows simplified version of the vulnerable code and figure6 b the corresponding exploit code.
specifically at line of a keyequals to proto kequals to tostring andval equalsto exploit .therefore object.prototype.tostring is pollutedto anotherstring.
a vulnerablecode 1module.exports.set function path val obj merge 2vari k keys key 3keys parsepath path .
4for i i keys.length i 5key keys 6if i keys.length if merge for k inval if hasownproperty.call val k obj val ... 17return obj b exploit 1vara require dot object 2varpath proto 3varval tostring exploit 4a.set path val true figure6 aprototypepollutionvulnerabilityanditsexploit codefordot object cve .
.
rq2 indirectlyvulnerable applicationsor packages in this subsection we answer the question whether safe node.js packagesbecomevulnerableandexploitableduetoinclusionofvulnerablepackages.specifically thevulnerablefunctionofadirectlyvulnerablepackageisusedinanotherpackageandtheparameter related to the vulnerability is controllable by the adversary e.g.
alsobeingexported.then thosepackagesaredefinedasindirectlyvulnerablepackagesinthepaper.ourmethodologyisasfollows.
first we find packages orapplications that have a dependency on the vulnerable packages found by objlupansys .
we find them by searching in both npm and github.
second we run objlupansys onthecombinationofthetargetandvulnerablepackagesanddecidewhether thecombinationisvulnerable.lastly wemanually generate exploits for the target package together with the vulnerableone.
here are the results.
objlupansys detects seven packages as indirectly vulnerable and then our manual verification confirms them as exploitable as shown in table .
next we illustrate two examplesasacasestudyonhowtoexploitthoseindirectly vulnerable packages.
.
.
casestudies.
inthissubsection wegivetwocasestudieson end to endvulnerable node.js applications.
avulnerablewebsite.
ishostingapersonal restfulapiserviceandthesourcecodeofthewebsiteisat https github.com remy jsonbin .
the website adopts undefsafe a packagewithaprototypepollutionvulnerabilityfoundby objlupansys .
we found this website via searching the keyword undefsafe ongithub.asaproofofconcept wedownloadedthe githubrepositoryanddeployedthewebsitelocallyforattack note that due to ethics concerns we cannot attack the online website directly.
275detectingnode.js prototype pollutionvulnerabilities viaobjectlookup analysis esec fse august athens greece table a selective list of zero day vulnerabilities found by objlupansys weekly download data is a snapshot of august .
node.js package loc weeklydownload vulnerable version location cve patched undefsafe .
.
lib undefsafe.js line106 cve yes append field .
.
lib set value.js line14 n a no graphql anywhere .
.
lib bundle.cjs.js line141 n a no aws xray sdk core .
.
subsegment.js line161 n a no cli table redemption .
.
lib utils.js line64 n a no dot object .
.
index.js line415 cve yes fastest validator .
.
lib helpers deep extend.js line7 n a no protractor jasmine2 html reporter .
.
index.js line28 n a no progress kendo angular charts .
.
configuration.service.js line55 n a no eivindfjeldstad dot .
.
index.js line20 cve no i18next sync fs backend .
.
lib utils.js line60 n a no mathjax full .
.
js components global.js line27 n a no component flatten .
.
index.js line56 cve no paypal adaptive .
.
lib paypal adaptive.js line31 cve no querymen .
.
dist index.js line42 cve yes bodymen .
.
dist index.js line43 cve yes ini parser .
.
index.js line14 cve no table indirectly vulnerable applications packages.
vulnerable package indirectly vulnerable applications packages undefsafe dset design system utils .
.
weoptions .
.
quaff .
.
just safe set magasin .
.
object set node architect .
.
simple odata server thedefaultserver for thepackage curl x post http localhost test test h authorization token xxxxxxxx xxxx xxxx xxxx xxxxxxx xxxxx d curl x patch http localhost test test h authorization token xxxxxxxx xxxx xxxx xxxx xxxxxxx xxxxx d proto tostring abc figure7 exploitcodethatleadstoadenial of serviceattack on a local copy of a real world website which hosts apersonal restful apiservice.
curl d constructor prototype tostring exploited h content type application json x post http localhost users figure8 exploitcodethatleadstoadenial of serviceattack on simple odata server.
the result is that we successfully launched a denial of service attack to any users of the service by crashing the local server withtheexploitcodeinfigure .followinguponoursuccessful attack we have disclosed it to the website owner and are still waiting for aresponse.
avulnerableservercode.
simple odata server isanimplementation odata server running on node.js with adapters for mongodbandnedb.wedeployedthedefaultserver coming with the node.js package locally at port and successfully exploited the server with exploit code as shown in figure .
the server crashes after exploitation leading to a denial of server consequence.
100percentage of packages coverage ppfuzzer objlupansys ppnodest figure statement coverage distribution of objlupansys ppfuzzer and ppnodest timeout seconds .
one major reasonofuncoveredcodein objlupansys issomedeadcode e.g.
uninvoked functions ordeadbranching statement .
.
rq3 codecoverage in this subsection we evaluate the code coverage of objlupansys intermsofstatementcoverageandcompareitwithppfuzzer and ppnodest.
specifically statement coverage defines the percentage ofstatements that are abstractly interpreted by objlupansys orexecutedbyppfuzzer.wemeasurestatementcoverageof objlupansys or ppnodest directly during abstract interpretation and adoptistanbul nyc together withmocha for measuringppfuzzer s coverage.
now we show the cumulative distribution of statementcoveragesinfigure themediancoverageof objlupansysis .
as opposed to .
for ppfuzzer and .
for ppnodest.
the reason for the low coverage of ppfuzzer is that ppfuzzerisadynamictool whichcanonlycoverabranchingstatement when the branching condition is satisfied.
the reason for the low coverage of ppnodest is that ppnodest cannot exhaustively find all the entry points and it stops abstract interpretation if an unimplementedfunction isencountered.
notethatthe coveragesof objlupansys insomepackages are alsorelativelylow.therearethreemajorreasons.
i somefunctions aredeadcode whicharenevercalledfromtheentryfunction ii 276esec fse august athens greece song li mingqingkang jianweihou andyinzhi cao 30percentage of finished packages time branch sensitive objlupansys branch insensitive objlupansys ppnodest figure cdfgraphoftotal analysis time.
somebranchingstatementconditionswillneverbesatisfied when objlupansys candecidethebranchingconditionstatically objlupansyswillsmartlyskipthedeadbranch.notethisandtheformer are both probably because the developer copies and pastes code from somewhere else.
iii some files included via require contain variablesfromapackageinput objlupansys cannotresolvethese variables withoutconcrete inputs.
.
rq4 performance in this subsection we evaluate the performance in terms of how fastobjlupansys andppnodestcanfinishanalyzingnode.jspackagesonthenpmbenchmark.figure 10showsacdfgraphwith 30secondsasthetime outthreshold objlupansys finishesanalyzing85 ofpackageswithin30secondswithbranchsensitivity and without branch sensitivity.
the performance of branchinsensitive objlupansys is similar to ppnodest which is also a branch insensitive static analysis.
ppnodest needs additional time to compute control flows and that is why it does not finish any packages inthe firstfive seconds.
discussion responsible disclosure.
we have responsibly disclosed allthe vulnerabilities found by objlupansys to their developers together with proof of vulnerability pov and will not release those vulnerabilities before a day window.
if the developers ask us for more time for patching we will also wait for their patches before public release.
loop execution and recursive call.
objlupansys executes a loop orarecursivecallextensivelyuntilnomorenewobjectsoutsidethe loop or recursive call become tainted in the object level prototypeorientedtaint analysis.
arrayhandling.
arraysarehandledsimilartoobjectsin objlupansys because an array is essentially a special type of objects representedinjavascript inwhichindexesarethepropertynames.
manyarrayoperations suchaspushandpop mayintroduceambiguitiesespeciallywhenwedonotknowthenumberofelementsin the array.dynamic code.
javascript code can be introduced dynamically viaevalandnewfunction.ifthosedynamiccodeareknown objlupansys parses and abstractly interprets the code.
if part of the dynamiccodeisunknown objlupansys willadoptthetemplate approach adoptedbycspautogen .
implementation of javascript features.
we investigated randomlyselected 10k node.js packages on npm and implemented all the features basedonastnodetypeoutputtedbyesprima thatare used by more than ofpackages.
specifically thecurrentimplementation of objlupansys supports all es5 features except for with whichisusedbylessthan1 ofnode.jspackagesanddeprecated in the strict mode of javascript.
the support beyond es5 i.e.
es2015andplus isstilldeveloping currently objlupansys supportspromise includingawaitandyield arrowfunction template literals and template element.
note that although objlupansys doesnotsupportsomees2015features e.g.
classandextends it can be combined with babel to convert es2015 andplusfeatures to be es5compatible for analysis.
asynchronous callbacks and events.
the current implementation ofobjlupansys puts asynchronous callbacks in a queue during registration and then invokes them after objlupansys finishes executingthecurrententryfunction.inmanycases thisisjustone ofmanypossibilitiesinexecutingasynchronouscallbacks wewill leave this as a future work to model them as an event based call graph like madsenetal.
.
related work inthissection wediscussrelatedwork.westartfromdescribing security works on node.js platform and then present client side javascriptsecurity.lastly wepresentgeneralvulnerabilitydetectionwork onotherplatforms.
node.jssecurity.
manyresearchworkshavebeenproposedtostudy thesecurityofnode.jsplatformonavarietytypesofvulnerabilities and we describe them separately below.
for example ojamaa et al.
and nodest proposed potential risks including command injection attack.
synode adopts a rewriting technique to enforce a template before executing a possible injection api like eval.
arteau proposes a fuzzer to execute node.js package and finds prototype pollution vulnerabilities.
then the general issue of path traversal has been studied for web applications using static or dynamic analysis.
next researchers have studied node.jsspecificdenialofservice dos attacks suchasregularexpression dos redos and event handler poisoning ehp .
the binding layers of the node.js also have vulnerabilities .
conflictjs analyzed conflicts among different javascript libraries and zimmermannetal.
studiedtherobustnessof asmallnumber ofthird partynode.jspackagestoinfluencethesecurityofother packages.
as a comparison prototype pollution is specific to javascript due to dynamic features of javascript i.e.
prior works on other vulnerabilities cannot detect prototype pollution.
arteau is the first work that detects prototype pollution but misses many vulnerabilities because it is a dynamic analysis tool with limited code coverage.
dapp mostly adopts abstract syntax tree ast and control flow features as simple detection patterns of prototype 277detectingnode.js prototype pollutionvulnerabilities viaobjectlookup analysis esec fse august athens greece pollutionvulnerabilitydetection whichleadstohighfalsepositives andnegatives inboth cases .
client sidejavascriptsecurity.
researchershavealsostudiedclientside javascript security in addition to the server side.
for example cross sitescripting xss andcross sitescript inclusionattack xssi attacksarewellstudiedontheclient side.manyresearchworks suchashidenoseek jshield and jstap have been proposed to detect or analyze malicious javascriptcode.researchershavealsoproposedtosecurejavascript using security policies with works such as gatekeeper and cspautogen .programanalysis havealsobeenadopted at the client side for security analysis.
many prior works have been proposed to restrict javascript especially those from third party ina subset for security.
it worth noting that object property graph opg can also be applied to analyze client sidejavascript code but isleft as afuture work.
error analysis of javascript programs.
prior works have proposed todetect commonerrors that developers maymake when writing javascript programs.
for example both tajs and jsai adopt abstract interpretation to analyze javascript programs for moreaccuratecallgraphgenerationandthendetecttype related errors.
madsen et al.
propose event based call graph to detect problemsreportedonstackoverflow.asacomparison noneofthe aforementionedworkscandetectprototypepollutionvulnerabilitieslikethosetargetedinthispaperduetothelackofmodeling interplaysbetween objects.
othergraph representationofjavascriptobjects.
priorworkshave alsousedgraphstructurestorepresentjavascriptobjects.forexample the heap graph proposed by guarnieri et al.
models local object relations.
however guarnieri et al.
do not simulate javascript execution via abstract interpretation like tajs and jsai which leads to the lack of runtime states e.g.
scopes in the graph.
therefore object resolution related to runtime states e.g.
parametersoftwoseparateexecutionsofthesamefunction are inevitablyapproximated.inaddition javascriptfunctionsarenot represented as objects in the heap graph leading to another object resolution approximation.
brave s pagegraph and its predecessor adgraph model the relations between different browser objects like scripts dom and ajax during runtime with concrete inputs.
as a comparison objlupansys models fine grained relations between javascript objects without any concrete inputs whichare not inpagegraph oradsgraph.
generalvulnerabilityanalysisframework.
codepropertygraph cpg isproposedbyyamaguchietal.
asageneralframework combining cfg dfg and ast to detect c c vulnerabilities.
lateron cpgisportedtophpbybackesetal.
asanopen source toolcalledphpjoern .inthepast codeanalysis has been also widely used to detect various vulnerabilities on different platforms.
the concept of objects and relations between object arealsoadoptedintraditionalprogramanalysisanddefenses suchasobjectflowintegrity .theconceptsofobjectsin javascriptaredifferentfromthoseonc c duetotheexistenceof prototypeandruntimeresolution whichmakestraditionalobject analysisnot applicable onjavascript.
conclusion dynamic flexiblejavascriptfeaturesnotonlybringconvenience to web developers but also introduce new vulnerabilities like prototype pollution.
in this paper we propose object property graph opg to capture the interplays of javascript objects via abstract interpretation and design a framework called objlupansys to facilitate object lookup analysis and detect prototype pollution vulnerabilities.
objlupansys finds previously unknown vulnerabilities with cves and also detects seven indirectly vulnerable node.js applications or packages due to the inclusion of vulnerable packages.wehaveresponsiblyreportedallthevulnerabilitiesto theirdevelopers andfive have already been fixed.