conquering the extensional scalability problem for value flow analysis frameworks qingkai shi the hong kong university of science and technology hong kong china qshiaa cse.ust.hkrongxin wu xiamenuniversity xiamen china wurongxin xmu.edu.cn gang fan the hong kong university of science and technology hong kong china gfan cse.ust.hkcharles zhang the hongkong university of science and technology hong kong china charlesz cse.ust.hk abstract modern static analyzersoften need to simultaneouslycheck a few dozenorevenhundredsofvalue flowproperties causingserious scalabilityissueswhenhighprecisionisrequired.amajorfactor to this deficiency as we observe is that the core static analysis engineisobliviousofthemutualsynergyamongthepropertiesbeing checked thusinevitablylosingmanyoptimizationopportunities.
ourworkistoleveragetheinter propertyawarenessandtocapture redundanciesandinconsistencieswhenmanypropertiesareconsideredatthesametime.wehaveevaluatedourapproachbycheckingtwentyvalue flowpropertiesinstandardbenchmarkprogramsand ten real world software systems.
the results demonstrate that our approachismorethan8 fasterthanexistingonesbutconsumes only of the memory.
such substantial improvement in analysis efficiency is not achieved by sacrificing the effectiveness at the time of writing thirty nine bugs found by our approach have been fixed by developers and four of them have been assigned cve ids due to their security impact.
ccsconcepts software and its engineering software verification and validation.
keywords staticbugfinding demand drivenanalysis compositionalprogram analysis value flow analysis.
acm reference format qingkai shi rongxin wu gang fan and charles zhang.
.
conquering theextensionalscalabilityproblemforvalue flowanalysisframeworks.
in42nd international conference on software engineering icse may seoul republicofkorea.
acm newyork ny usa 12pages.
permissionto make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may23 seoul republic of korea 2020association for computing machinery.
acm isbn ... .
introduction value flow analysis which tracks how values are stored and loaded in a program underpins the inspection of a very broad category of software properties such as memory safety e.g.
null dereference double free etc.
resource usage e.g.
memory leak file usage etc.
and security properties e.g.
the use of tainted data .
in addition there are a large and growing number of domain specific value flow properties.
for instance mobile software requires that the personal information cannot be passed to an untrusted code and in web applications tainted database queries are not allowed to be executed .fortify 1a commercial staticcodeanalyzer checksnearlytenthousandvalue flowpropertiesfromhundredsofuniquecategories.value flowproperties exhibit a very high degree of versatility which poses great challenges to the effectiveness of general purpose program analyzers.
facedwithsuchamassivenumberofpropertiesandtheneedof extension existingapproaches suchas fortify csa 2andinfer provide a customizable framework together with a set of property interfaces that enable the quick customization for new properties.
forinstance csausesasymbolic executionenginesuchthat at every statement it invokes the callback functions registered forthe properties.
these callback functions are overwritten by the property checker writers to collect the symbolic execution results suchas thesymbolic memoryand thepath conditions so thatwe canjudgethepresence ofany propertyviolationat thestatement.
despite the existence of many csa like frameworks when high precision like path sensitivity is required existing static analyzers still cannot scale well with respect to a large number of properties to check which we refer to as the extensional scalability issue .
for example ourevaluationshowsthat csacannotpath sensitively check twenty properties for many programs in ten hours.
pinpoint anotherrecentanalyzer exhausted256gbofmemory for onlyeightproperties.
we observe that a major factor for the extensional scalability issue is that in the conventional extension mechanisms such asthat of csa the core static analysis engine is oblivious to the properties being checked.
although the property obliviousness givesthemaximumflexibilityandextensibilitytotheframework 1fortifystaticanalyzer 2clangstaticanalyzer .
3inferstaticanalyzer .
oe oufsobujpobm pogfsfodf po 4pguxbsf ohjoffsjoh icse may seoul republic of korea qingkai shi rongxin wu gang fan and charles zhang italsopreventsthecoreenginefromutilizingtheproperty specific analysis results for optimization.
this scalability issue is slightly alleviated by a class of approaches that are property aware anddemand driven .thesetechniquesarescalablewithrespect to a small number of properties because the core engine can skipcertainprogramstatementsbyunderstandingwhatstatements arerelevantorirrelevanttotheproperties.however intheseapproaches thesemanticsofpropertiesarealsoopaquetoeachother.
asaresult whenthenumberofpropertiesgrowsverylarge the performanceofthedemand drivenapproacheswillquicklydeteriorate because property irrelevant program statements becomefewer and fewer such as in the case of pinpoint.
to the best of ourknowledge thenumberofliteraturespecificallyaddressingthe extensional scalability issue is very limited.
readers can refer to section7fora detailed discussion.
in this work we advocate an inter property aware design to relaxtheproperty propertyandtheproperty engineopaquenessso that the core static analysis engine can exploit the mutual synergy among different properties for optimization.
to check a value flow property insteadofconformingtoconventionalcallbackinterfaces property checkerwritersofourframeworkneedtoexplicitlydeclareasimplepropertyspecification whichpicksoutsourceand sink values respectively as well as the predicate over these values forthesatisfactionoftheproperty.forinstance foranulldeference property our propertymodel onlyrequires thechecker writersto indicate where a null pointer may be created and where the nulldereference may happen using pattern expressions as well as a simplepredicatethatconstrainsthepropagationofthenullpointer.
surprisingly given a set of properties specified in our property model ourstaticanalyzercanautomaticallyunderstandtheoverlaps and inconsistencies of the properties to check.
based on theunderstanding before analyzing a program we can make dedicated analysis plans so that at runtime the analyzer can share the analysis results on path reachability and path feasibility among differentpropertiesforoptimization.theoptimizationallowsusto significantlyreduceredundantgraphtraversalsandunnecessary invocationsofthesmtsolver twocriticalperformancebottlenecksofconventionalapproaches.weprovidesomeexamplesinsection to illustrate our approach.
we have implemented our approach named catapult which is a new demand driven and compositional static analyzer with theprecisionofpath sensitivity.likeaconventionalcompositional analysis our implementation allows us to concurrently analyzefunctionsthatdonothavecallingrelations.in catapult w e have included all c c value flow properties that csachecks by default.
in the evaluation we compared catapult to three state ofthe artbug findingtools pinpoint csa and infer usingastandard benchmark and ten popular industrial sized software systems.
the experimental results demonstrate that catapult is more than faster than pinpoint but consumes only of the memory.
it is as efficientas csaandinferintermsofbothtimeandmemorycost butismuchmoreprecise.suchpromisingscalabilityof catapult isnotachievedbysacrificingthecapabilityofbugfinding.inour experiments although the benchmark software systems have been checkedbynumerousfreeandcommercialtools catapult isstill a path overlappingcheck for free global pointer bugscheck for memory leak bugsa malloc c a b c 1b x global pointer heap pointer b path contradictiona malloc b a free b b 1check for memory leak bugscheck for null dereference bugsx a a heap pointer or null figure path overlapping and contradiction among differ entproperties.
each edge represents a value flow.
able to detect many previously unknown bugs in which thirtyninehavebeenfixedbythedevelopersandfourhavebeenassigned cveids.
in summary we make the following contributions an inter property aware design for checking value flow properties which mitigates the extensional scalability issue.
a series of cross property optimization rules that can be made useof for general value flow analysis frameworks.
a detailed implementation and a systematic evaluation that demonstratesourhighscalability precision and recall.
overview the key factor that allows us to conquer the extensional scalability problem is the exploitation of the mutual synergy among different properties.
in this section we first use two simple examples to illustrate this mutual synergy and then provide a running example used in the whole paper.
.
mutualsynergy weobservethatthemutualsynergyamongdifferentpropertiesare primarily in the forms of path overlapping and path contradiction.
in figure 1a to check the memory leak bug we need to track valueflows fromthenewly created heappointer atocheck ifthe pointer will be freed.4to check the free global pointer bug we track value flows from the global variable bto check if it will be freed.5asillustratedinthefigure thevalue flowpathstosearch forthesetwobugsoverlapfromthevertex c a b tothevertex c .beingawareoftheoverlap whentraversingthegraphfrom the vertex a malloc for the memory leak bug we record that the vertexc a b cannot reach any free operation.
therefore when checking the free global pointer bug we can use this recorded informationto immediatelystopthegraph traversalatthe vertex c a b thereby avoiding redundant graph traversals.
infigure 1b tocheckthememory leakbug wetrackvalueflows from the newly created pointer ato where it is freed.
to check the null dereference bug considering that the function mallocmay returnanullpointerwhenthememoryallocationfails wetrack thevalueflowsfromthesamepointer atowhereitisdereferenced.
the two properties have an inconsistent constraint the former requiresa nequal0foratobeavalidheappointerwhilethelatterrequires 4in the paper we say a pointer pis freed if it is used in the function call free p .w e willdetailhow to use the value flow information to check bugs later.
5freeing a pointer pointing to non heap memory e.g.
memory allocated by global variables is buggy.
see details in conquering the extensional scalability problem for value flow analysis frameworks icse may seoul republic of korea property specificationsgraph traversal plan optimization plan bug reports engine of graph traversalplan makercore engine key novelty a plan maker is inserted in a conventional design figure the workflow of our approach.
.char g .voidmain .
char a .
if .
p malloc ... a p heap pointer or null .
else .
a g nonheappointer .
.
if b a free b .
.
if c a c .
.
if d a free d .
dp a free d g nonheap pointer may be null free b b c 1c figure an example to illustrate our method.
a forato be a null pointer.
being aware of this inconsistency whentraversingthegraphforcheckingthenull dereferencebug we check and record if the path condition of the path from the vertexa malloc tothevertex b aconflictswiththenullpointer condition a .
if the path condition is satisfiable but conflicts with the null pointer condition a i.e.
the conjunction a 0i s unsatisfiable we can conclude that the conjunction a nequal0 must besatisfiablewithoutanexpensiveconstraint solvingprocedure whencheckingthe memory leakbug.
.
a running example figure3shows a running example using the value flow graph wherewecheckthenull deferenceandthefree global pointerbugs followingtheworkflowillustratedinfigure .givenaprogram we firstfollowthe previous work tobuild thevalue flow graph in order to check the two properties with the precision of path sensitivity.
here path sensitivity means that when searching pathsonthevalue flowgraph weinvokeansmtsolvertosolve path conditions and other property specific constraints to prune infeasiblepaths.
the property specifications.
the users of our framework need to declaratively specify the value flow properties which consists of the simple descriptions of the sources the sinks and the predicates for triggering the bug.
for instance the specifications of the aforementioned two properties are describedby the following two quadruples respectively propnull deref v malloc v v v never propfree glob ptr glob free v true never separated by the semicolons the first and second components denote the descriptors of the source and the sink respectively specified using pattern expressions to represent the values used ordefinedinsomeprogramstatements.the don t care valuesare written as underscores.
in the running example the source values of the properties null deref andfree glob ptr are the return pointer ofthefunction mallocandtheglobalpointer g respectively.the sink value of the property null deref is the dereferenced value cat the statement c .
the sink values of the property free glob ptr are the freed values at the statements free b andfree d .
the third component is a property specific constraint representing the triggering condition of the bug.
in our example theconstraint of the property null deref is v meaning that the value on a value flow path should be a null pointer.
the constraint of the property free glob ptr istrue meaning that the value on a value flow path is unconstrained.
thebuilt inpredicate never meansthatvalue flowpathsbetween the specified sources and sinks should never be feasible.
otherwise a bug exists.
the core static analysis engine.
given these declarative specifications our core engine automatically makes analysis plans before the analysis begins including both the graph traversal plan and the optimization plan.
in the example we make the following optimizationplans checkingtheproperty free glob ptr before theproperty null deref whentraversingthegraphforthepropertyfree glob ptr werecordtheverticesthatcannotreachanysink vertex of the property null deref.
the graph traversal plan in the exampleistrivial whichistoperformadepth firstsearchonthe value flow graph from every source vertex of the two properties.
infigure whentraversingthevalue flowgraphfromtheglobal pointergto check the property free glob ptr the core engine visits allverticesexceptthevertex ptolookfor free operations.according to the optimization plan during the graph traversal we record that the vertices banddcannotreach any dereference operation.
to check the property null deref we traverse the value flow graphfromthevertex p.whenvisitingthevertex bandthevertex d since the previously recorded information tells us that they cannot reachanysinkvertices weprunethesubsequentpathsfromthe two vertices.
it is noteworthy that if we check the property null deref before the property free glob ptr we only can prune one path from the vertexcfor the property free glob ptr based on the results of the property null deref see section .
.
.
we will further explain the rationaleof our analysis plans in the following sections.
value flow properties thissectionprovidesaspecificationmodelforvalue flowproperties with the following two motivations.
first we observe that many property specific constraints play a significant role in performance optimization.
the specific constraints of one property can be used tooptimizecheckingofnotjustthepropertyitself butalsoofother properties being checked together.
second despite many studies on value flow analysis we still have a lack of general and extensible specification models that can maximize the opportunities of sharing analysis results across the processes of checking different properties.
some oftheexistingstudiesonlyfocusoncheckingaspecificproperty e.g.
memory leak while others adopt different specifications to check the same value flow property e.g.
double free .
icse may seoul republic of korea qingkai shi rongxin wu gang fan and charles zhang table pattern expressions used in the specification.
p patterns p1 p2 patternlist v0 sig v1 v2 call v0 v1 load v0 v1 store v0 v1 assign glob globals v symbol sig characterstring uninterested value examples v malloc ret values of any statementcalling malloc send v the 2ndarg of any statementcalling send v dereferenced values at every load statement preliminaries.
in a similar style to existing approaches we assume that the code of a program is in static single assignment ssa form whereeveryvariablehasonlyonedefinition .
also wesaythevalueofavariable aflowstoavariable b orbis data dependent on a i fais assigned to bdirectly via assignments suchasb a orindirectly viapointerdereferences suchas p a q p b q .thus avalue flowgraphcanbedefinedasadirected graphwherethe vertices are valuesin the program andthe edges represent the value flow relations.
a path is called value flow path if it is a path on the value flow graph.
property specification.
as defined below we model a valueflow property as an aggregation of value flow paths.
definition .
value flow property .
a value flow property x i s a quadruple propx src sink psc agg where srcandsinkaretwopatternexpressions thatspecify the sources and the sinks of the value flow paths to track.
pscis a first order logic formula representing the propertyspecificconstraintthateveryvalueonthevalue flowpath needs to satisfy.
agg never never sim must is an extensible predicatethatdetermineshowtoaggregatevalue flowpathsto check the specified property.
in practice we can use the quadruple to specify a wide range of value flow properties.
as discussed below we put the properties intothreecategories whicharecheckedbyaggregatingasingle two or more value flow paths respectively.
single pathproperties.
we can check many program propertiesusingasinglevalue flowpath suchastheproperties null deref andfree glob ptr defined in section .
as well as a broad range oftaintissuesthatpropagateataintedobjecttoaprogrampoint consumingtheobject .
double path properties.
a wide range of bugs happen in a programexecutionbecausetwoprogramstatements e.g.
twostatements calling the function free consecutively operate on the same value e.g.
a heap pointer .
typical examples include the use afterfree bug a general form of the double free bug as well as the onesthatoperate on expired resources such as a closed file descriptor oraclosednetworksocket.wecheckthemusingtwovalue flow paths from the same source value.
as an example the specification for checking the double free bugs can be specified as propdouble free v malloc free v v nequal0 never sim in the specification the property specific constraint v nequal0r e quirestheinitialvalue orequivalently allvalues onthevalue flow pathis a valid heap pointer.
this is because v means the functionmallocfailstoallocatememoryandreturnsanullpointer.in this case the free operation is harmless.
the aggregate predicate never sim meansthattwovalue flowpathsfromthesamepointer should never occur simultaneously.
in other words there is no control flow path that goes through two different free operations on the same heap pointer.
otherwise a double free bug exists.
infigure forthetwovalue flowpathsfromthevertex ptothe two free operations wecanchecktheconstraint 1 2 1 4 p nequal0 tofinddouble freebugs.here 1 2 and 1 4 are the path conditions of the two paths respectively.
all path properties.
many bugs happen because we do not properlyhandleavalueinallprogrampaths.forinstance amemoryleak bug happens if there exists a feasible program path where we do not free a heap pointer.
other typical examples include many types of resource leaks such as the file descriptor leak and the socket leak.
we check them by aggregating all value flow paths fromthesamesourcevalue.asanexample wewritethefollowing specification for checking memory leaks propmem leak v malloc free v v nequal0 must compared to the property double free the only difference in the specification is the aggregate predicate.
the aggregate predicate must meansthatthevalue flowpathfromaheappointermustbe abletoreacha free operation.otherwise amemoryleakexists in the program.
in figure for the value flow paths from the vertex pto the two free operations wecancheckthedisjunctionoftheirpath conditions i.e.
1 2 1 4 1 p nequal0 todetermine ifamemoryleakexists.here 1 2 and 1 4 arethepath conditions of these two paths respectively.
the additional 1is the conditionon which the heap pointer is created.
inter property aware analysis givenanumberofvalue flowpropertiesspecifiedasthequadruples src sink psc agg ourinter property awarestaticanalyzer searchesthevalue flowpathsandchecksbugsbasedonthepath conditions theproperty specificconstraint psc andthepredicate agg.inthispaper weconcentrateonhowtoexploitthemutualsynergyarisingfromtheinteractionsofdifferentpropertiestoimprove the searchingefficiencyof value flow paths.
.
a na ve static analyzer formultiplevalue flowproperties ana vestaticanalyzerchecks them independently in a demand driven manner.
as illustratedby algorithm for each value flow property the static analyzer traverses the value flow graph from each of the source vertices.
at eachstepof the graph traversal we check if the property specific conquering the extensional scalability problem for value flow analysis frameworks icse may seoul republic of korea input thevalue flow graph of a progam to check input a set of value flow properties to checkoutput pathsbetween sources and sinks for each propertyforeachproperty in the input property set do foreachsourcevin its source set do whilevisitv primein the depth first search from vdo ifpsccannotbe satisfied then stopthe search from v prime end end end end algorithm1 thena ve static analyzer.
constraint pscis satisfiable with respect to the current path condition.
if it is not satisfiable we can stop the graph traversal alongthe current path.
this path pruning process is illustrated in theshaded part of algorithm which is a critical factor to improve the performance.
thekey optimizationopportunitiescome fromtheobservation thatthepropertiestocheckusuallyintroduceoverlapsandinconsistencies during the graph traversal which cannot be exploited if they are independently checked as in the na ve approach.
.
optimized intra procedural analysis as summarized in table given the property specifications our inter property awarestaticanalysisenginecarriesouttwotypes of optimizations when traversing the value flow graph the first aiming at pruning paths and the second focusing on sharing paths when multiple properties are being checked.
each row of the table is a rule describing the specific precondition the corresponding optimization as well as its benefit.
for the clarity of the discussion weexplaintherulesinthecontextofprocessingasingle procedure program followed by the discussion on the inter procedural analysis in the next subsection.
.
.
optimization plan.
given the property specifications we adoptrules1 4i nt able2to facilitate the path pruning.
ordering the properties rule .
given a set of properties with different source values we need to determine the order inwhich they are checked.
while we leave the finding of the perfectorderthatguaranteestheoptimaloptimizationtoourfuture work weobservethatarandomordercansignificantlyaffectthe effectiveness of the path pruning and must be circumvented.
let us consider the example in figure 3again.
in section .
w e have explained that if the property free glob ptr is checked before theproperty null deref wecanprunethetwopathsfromthevertex band the vertex dwhen checking the latter.
however if we flip the checking order only one path from the vertex ccan be pruned.
this is because when checking the property null deref the core enginerecordsthatthevertex ccannotreachanysinksspecified by the property free glob ptr.
intuitively whatcausesthefluctuationinthenumberofprunable pathsisthatthenumberofthe free operationsismorethanthe dereferenceoperationsinthevalue flowgraph.thatis themoresink vertices we have in the value flowgraph the fewer paths we canprunefortheproperty.inspiredbythisintuition theorderof checking the properties is arranged according to the number of sinkvertices.thatis themoresinkverticesapropertyhasinthe value flow graph the earlier we check this property.
recording sink reachability rule .
given a set of properties prop1 prop2 when checking the property propiby traversing the value flow graph we record if each visited vertexmay reach a sink vertex of the property propj j nequali .
with the recorded information when checking the property propj j nequali andvisitingavertexthatcannotreachanyofitssinks weprune the pathsfrom the vertex.
section .2illustratesthemethod.
recordingthecheckingresultsofproperty specificconstraints rules3 .
givenasetofproperties prop1 prop2 when we check the property propiby traversing the value flow graph we record the path segments i.e.
a set of edges that conflict with the property specific constraint pscjof the property propj j nequali .whencheckingtheproperty propj j nequali weprune the pathsthat includethe pathsegments.
let us consider the running example in figure 3again.
when traversingthegraphfromthevertex gtochecktheproperty freeglob ptr thecoreenginerecordsthattheconditionoftheedgefrom thevertex atothevertex c i.e.
a nequal0 conflictswiththepropertyspecificconstraintoftheproperty null deref i.e.
a .withthis information when checking the property null deref we can prune the subsequentpath after the vertex c. thankstotheadvancesintheareaofclauselearning weare able to efficiently compute some reusable facts when using smt solvers to check path conditions and property specific constraints.
specifically wecomputetworeusablefactswhenaproperty specific constraint psciconflictswith the current pathcondition pc.
when pc psciis unsatisfiable we record the unsatisfiable core whichisasetofbooleanpredicatesinthepathcondition pc e.g.
1 2 such that 1 2 psci false.
since the pathcondition pcis theconjunction of theedge constraint on the value flow path each predicate icorresponds to the condition of an edge ion the value flow graph.
thus we can record an edgesete 1 2 whichconflictswiththeproperty specific constraint psci.
whenchecking theother propertywith the same property specific constraint if a value flow path contains these recorded edges we can prune the remaining paths.
in addition to the unsatisfiable cores we also can record the interpolation constraints which are even reusable for properties with a different property specific constraint.
in the above example assume that the property specific constraint psciisa and the predicate set 1 2 is a b b .
in the constraint solving phase an smt solver can refute the satisfiability of a b b a by finding an interpolant primesuch that a b b primebut prime a .intheexample theinterpolant primeisa whichprovidesadetailedexplanation why the set conflicts with the property specific constraint a .
in addition the interpolant also indicates that the set conflicts withmany otherconstraints suchas a 0anda .thus given apropertywhosespecificconstraintconflictswiththeinterpolation constraint it is sufficient to conclude that any value flow path passingthrough the edge set ecan be pruned.
icse may seoul republic of korea qingkai shi rongxin wu gang fan and charles zhang table rules of making analysis plans for a pair of properties.
optimizationplans propx src1 sink1 psc1 agg1 andpropy src2 sink2 psc2 agg2 src1 nequalsrc2 idrulename precondition plan benefit 1property ordering sink1 sink2 checkxbeforey more chances to prune paths result recordingcheckxbeforey record vertices that cannot reach sink2prune pathsat a vertex checkxbeforey psc1 psc2record unsat cores that conflict with psc2prune pathsif going through checkxbeforey psc1 nequalpsc2record interpolants that conflict with psc2a set of edges graphtraversal plans propx src1 sink1 psc1 agg1 andpropy src2 sink2 psc2 agg2 src1 src2 idrulename precondition plan benefit 5traversal merging search from src1for both properties sharingpath conditions psc check orderingpsc1 psc2 psc1 check psc1first if satisfiable so is psc2 psc1 psc2 nequalfalse check psc1 psc2if satisfiable both psc1and psc2can be satisfied psc1 psc2 false check any e.g.
psc1 firstif unsatisfiable psc2can be satisfied dp a free d g a heap pointer or a null pointer free b b print c c mem leak null deref mem leak null deref mem leak null deref mem leak psc a psc a mem leak null deref null deref figure merging the graph traversal.
.
.
graph traversal plan.
the graph traversal plan is to provide strategiesof sharing paths among different properties.
mergingthegraphtraversal rule5 .
weobservethatmany properties actually share the same or a part of source vertices and eventhesamesinkvertices.ifthecoreenginecheckseachproperty one by one it will repetitively traverse the graph from the same sourcevertexfordifferentproperties.therefore ourgraphtraversal plan mergesthe pathsearchingprocesses for different properties.
as an example in figure since the vertex pmay represent either a heap pointer or a null pointer checking both the property null deref andtheproperty mem leak needstotraverse thegraph from the vertex p. figure4illustrates how the merged traversal is performed.
that is we maintain a property set during the graph traversal to record what properties the current path contributes to.
whenever visiting a vertex we check if a property needs to be removed from the property set.
for instance at the vertex d w e may remove the property null deref from the property set if we candeterminethevertex dcannotreachanyofitssinks.whenthe propertysetbecomesempty thegraphtraversalstopsimmediately.ordering the checks of property specific constraints rules .
sincethegraphtraversalsaremergedfordifferent properties atavertex e.g.
ainfigure wehavetocheckmultiple property specific constraints e.g.
a nequal0 for the property mem leak anda 0fortheproperty null deref withrespecttothepathcondition.inausualmanner wehavetoinvokeanexpensivesmtsolver tocheckeachproperty specificconstraint significantlyaffecting theanalysisperformancewhentherearemanypropertiestocheck.
we mitigate this issue by utilizing various relations between the property specific constraints so that we can reuse smt solving results and reduce the invocations of the smt solver.
given two property specific constraints psc1andpsc2 we consider all three possible relations between them psc1 psc2 psc1 psc1 psc2 nequalfalse and psc1 psc2 false.
since the propertyspecific constraints are often simple these relations are easy to compute.theserelationsmakeitpossibletocheckboth psc1and psc2by invoking an smt solver only once.
thefirstrelation psc1 psc2 psc1 impliesthatanysolution of the constraint psc1also satisfies the constraint psc2.
in this case we first check if the constraint psc1conflicts with the current path condition pcbysolvingtheconjunction pc psc1.ifitissatisfiable we can conclude that the conjunction pc psc2 is also satisfiable.
thesecondrelation psc1 psc2 nequalfalse impliesthatthereexists asolutionthatsatisfyingboththeconstraint psc1andtheconstraint psc2.
in this case we first check the conjunction pc psc1 psc2.
ifitissatisfiable wecanconcludethatbothoftheconstraints psc1 andpsc2 are satisfiable with respect to the path condition.
the third relation psc1 psc2 false implies that there does notexistanysolutionthatsatisfiesboththeconstraint psc1andthe constraint psc2.
in this case we check any of the constraints psc1 andpsc2 first.
if the current path is feasible but the conjunction pc psc1isnotsatisfiable wecanconcludethattheconjunction pc psc2can be satisfied without invoking smt solvers.
conquering the extensional scalability problem for value flow analysis frameworks icse may seoul republic of korea .
modular inter procedural analysis scalableprogram analyses need to exploit the modular structure of a program.
they build function summaries which are reused at differentcallingcontexts .in catapult wecanseamlessly extendouroptimizedintra proceduralanalysistomodularinterproceduralanalysisbyexploringthelocalvalue flowgraphofeach function and then stitching the local paths together to generate complete value flow paths.
in what follows we explain our design of the function summaries.
in our analysis for each function we build three kinds of valueflow paths as the function summaries.
they are defined below and inalongerversionofthispaper weformallyprovethesoundness of generating these function summaries.
intuitively these summariesdescribehow functionboundaries i.e.
formalparameters and return values partition a complete value flow path.
using the property double free as an example a complete value flow path fromthevertex ptothevertex free b infigure 5ispartitionedtoa sub pathfromthevertex ptothevertex ret pbytheboundaryof thefunction xmalloc.thissub pathisanoutputsummaryofthe functionxmallocas defined below.
definition .
transfer summary .
a transfer summary of a function fisavalue flowpathfromoneofitsformalparameters to one of its return values.
definition4.
inputsummary .
aninputsummaryofafunction fisavalue flowpathfromoneofitsformalparameterstoasink value in the function for in the callees of the function f. definition .
output summary .
an output summary of a functionfis a value flow path from a source value to a return value of the function.
the source value is in the function for in the callees of the function f. after generating the function summaries to avoid separately storing them for different properties each function summary is labeledwithabitvectortorecordwhatpropertiesitisbuiltfor.assume that we need to check there properties i.e.
null deref doublefree andmem leak in figure .
we assign three bit vectors b001 0b010 and b100 to the three properties as their identities respectively.asexplainedbefore allthreepropertiesregardthevertex pas thesource.thesinkverticesforcheckingtheproperties double free andmem leak are the vertices free b andfree u .
there are no sink verticesfortheproperty null deref.accordingtodefinitions .
.
we generate the following function summaries function summary path label type xmalloc p ret p b111 output xfree u ret u b111 transfer u free u b110 input the summary p ret p is labeled with b111 because all three properties regard pas the source.
the summary u ret u is also labeledwith0 b111becausethepathdoesnotcontainanypropertyspecificverticesand thus maybeusedtocheckallthreeproperties.
the summary u free u is only labeled with b110 because we do not regard the vertex free u as a sink of the property null deref.void xmalloc void p malloc ... return p void xfree void u free u return u void main void a xmalloc void b xfree a if ... free b return p ret p ret ua u free u b free b xmalloc xfree figure5 anexampletoshowtheinter proceduralanalysis.
when analyzing the main function we concatenate its intraprocedural paths with summaries from its callees to generate a complete path.
for example a concatenation is illustrated below anditsresultislabeledby0 b110 meaningthattheresultingpath onlyworksfortheproperty double free andtheproperty mem leak.
p retp 0b111 a u free u 0b110 p retp a u free u 0b111 0b110 p retp a u free u 0b110 we observe that using value flow paths as function summaries has a significant advantage for checking multiple properties.
that is sincevalueflowisacommonprogramrelations itcanbereusedacrossdifferentproperties.thisisdifferentfromexistingapproaches thatutilizestatemachinetomodelpropertiesandgeneratestatespecific function summaries .
since different properties usually have different states compared to our value flow based functionsummaries suchstate specificfunctionsummarieshave fewer opportunities to be reused across properties.
implementation in this section we present the implementation details as well as the properties to check in our framework.
path sensitivity.
we have implemented our approach as a prototypetoolcalled catapult ontopof pinpoint .giventhesource code of a program we first compile it to llvm bitcode 6on which ouranalysisisperformed.toachievepath sensitivity webuilda path sensitivevalue flowgraphandcomputepathconditionsfollowingthemethodof pinpoint.thepathconditionsinouranalysis are first order logic formulae over bit vectors.
a program variable is modeled as a bit vector of which the length is the bit width e.g.
of the variable s type e.g.
int .
the path conditions are solved by z3 a state of the art smt solver to determine the path feasibility.
propertiestocheck.
catapult currentlysupportstwentyc c properties brieflyintroducedintable definedby csa.7these 6llvm 7more details of the properties can be found on .
icse may seoul republic of korea qingkai shi rongxin wu gang fan and charles zhang table properties to check in catapult.
id property name brief description core.callandmessage check for uninitialized arguments and null function pointers core.dividebyzero check for division by zero core.nonnullparamchecker check for null passed to function parameters marked with nonnull core.nulldereference check for null pointer dereference core.stackaddressescape check that addresses of stack memory do not escape the function core.undefinedbinaryoperatorresult check for the undefined results of binary operations core.vlasize variable length array check for declaration of vla of undefined or zero size core.uninitialized.arraysubscript check for uninitialized values used as array subscripts core.uninitialized.assign check for assigning uninitialized values core.uninitialized.branch check for uninitialized values used as branch conditions core.uninitialized.capturedblockvariable check for blocks that capture uninitialized values core.uninitialized.undefreturn check for uninitialized values being returned to callers cplusplus.newdelete check for c use after free cplusplus.newdeleteleaks check for c memory leaks unix.malloc check for c memory leaks double free and use after free unix.mismatcheddeallocator check for mismatched deallocators e.g.
new and free unix.cstring.nullarg check for null pointers being passed to c string functions like strlen alpha.core.callandmessageuninitrefarg check for uninitialized function arguments alpha.unix.simplestream check for misuses of c stream apis e.g.
an opened file is not closed alpha.unix.stream check stream handling functions e.g.
using a null file handle in fseek propertiesincludeall csa sdefaultc c value flowproperties.
all other default c c properties in csabut not in catapult are simpleonesthatdonotrequireapath sensitiveanalysis.forexample the property security.insecureapi.bcopy requires csareport a warning whenever a program statement calling the function bcopy is found.
parallelization.
ouranalysisisperformedinabottom upmanner in which a function is always analyzed before its callers.
after afunctionisanalyzed itsfunctionbehaviorissummarizedasfunction summaries which can be reused at different call sites.
thus itiseasytoruninparallelbyanalyzingfunctionswithoutcallercalleerelationsindependently .ourspecialdesignforchecking multiple properties together does not prevent the analysis from this parallelizationstrategy.
soundness.
weimplement catapult inasoundymanner .
thismeansthattheimplementationsoundlyhandlesmostlanguage featuresand meanwhile includessomewell knownunsounddesign decisions as previous works .
for example in our implementation virtual functions are resolved by classic class hierarchy analysis .
however we do not handle c style functionpointers inlineassembly andlibraryfunctions.wealso followthecommonpracticetoassumedistinctfunctionparametersdonotaliaswitheachother andunrolleachcycletwiceonthe callgraphandthecontrol flowgraph.
theseunsound choices significantlyimprovethescalabilitybuthavelimitednegativeimpacts on the bug finding capability.
evaluation todemonstratethescalabilityofourapproach wecomparedthe time and the memory cost of catapult to three existing industrialstrength static analyzers.
we also investigated the capability of finding real bugs inorder to show that the increased scalabilityis not at the cost of sacrificing the bug finding capability.table subjects for evaluation.
id program size kloc id program size kloc mcf shadowsocks bzip2 webassembly gzip transmission parser redis vpr imagemagick crafty python twolf glusterfs eon icu gap openssl vortex mysql perlbmk gcc total baselineapproaches.
we first compared catapult topinpoint amostrecentvalue flowanalyzerwiththeprecisionofinter proce dural path sensitivity .
in addition we also compared catapult totwowidely usedopen sourcebugfindingtools csaandinfer.
all these tools in our evaluation were configured to use fifteen threadsto take advantage of parallelization.
we also tried to compare catapult to other static bug detection toolssuchas saturn calysto semmle fortify and klocwork.8however theyareeitherunavailableornotrunnableonthe experimental environmentwe areable toset up.the open source static analyzer findbugs 9was not included in our experiments because it only works for java while we focus on the analysis ofc c programs.
we did not compare catapult totricoder the static analysis platform from google.
this is because it uses csaas the c c analyzer which is included in our experiments.
8klocwork 9findbugsstaticanalyzer .
conquering the extensional scalability problem for value flow analysis frameworks icse may seoul republic of korea subjectsforevaluation.
toavoidpossiblebiasesonthebenchmark programs we included the standard and widely used benchmarks speccint200010 id 12intable inourevaluation.
meanwhile to demonstrate the efficiency and effectiveness of catapulton real world projects we also included ten industrial sized open source c c projects id in table of which the size rangesfrom a few thousand to two million lines of code.
environment.
allexperimentswereperformedonaserverwith eighty intel r xeon r cpue5 2698v4 .20ghz processors and 256gbof memory running ubuntu .
.
.
comparingto static value flow analyzer we first compared catapult topinpoint the state of the art valueflowanalyzer.toquantifytheeffectofthegraphtraversalplanand the optimizationplan separately we alsoconfigured catapult to only containthe graphtraversal plan.
inthisexperiment weperformedthewholeprogramanalysis by linking all compilation units of a project into a single file for the static analyzers to perform the cross file analysis.
before the analysis both pinpoint andcatapult needtobuildthevalue flow graph as the program intermediate representation.
since catapult is built on top of pinpoint the pre processing time and the size ofvalue flowgrapharethesameforbothtools whicharealmost lineartothesizeofaprogram .typically formysql aprogram with about two million lines of code it takes twenty minutes to build a value flow graph with seventy million nodes and ninety millionedges.
efficiency.
the time and memory cost of checking each benchmark program is shown in figure 6a.
owing to the inter propertyawareness catapult is about faster than pinpoint and takes only 7of thememory on average.typically catapult can finish checkingmysqlin5hours whichisalignedwiththeindustrial requirement of finishing an analysis in to hours .
when the optimization plan is disabled catapult is about .
fasterthan pinpointandtakes1 5ofthememoryonaverage.comparedtotheresultof catapult itimpliesthatthegraphtraversal plan and the optimization plan contribute to and of the time cost reduction respectively.
meanwhile they contribute to and of the memory cost reduction respectively.
as a summary thetwoplanscontributesimilartothetimecostreduction and the graph traversal plan is more important for the memory cost reduction because it allows us to avoid duplicate data storage by sharing analysis results across different properties.
using the largestsubject mysql as anexample figure 6b illustratesthegrowthcurvesofboththetimeandthememoryoverhead whentheproperties in table 3areadded into the coreengine one by one.
figure 6b shows that in terms of both time and memory overhead catapult grows much slower than pinpoint and thus scalesup quite gracefully.
it is noteworthy that except for the feature of inter propertyawareness catapult follows the same method of pinpoint to build value flowgraphandperformpath sensitiveanalysis.thus they have the similar performance to check a single property.
catapult performsbetterthan pinpoint onlywhenmultiplepropertiesare checked together.
10speccint2000benchmarks since both catapult andpinpoint check programs with the precision of inter procedural path sensitivity as shown in the left part of table they produce a similar number of bug reports rep and false positives fp for all the real world programs except for the programs that pinpoint fails to analyze due to the out of memory exception.
.
comparingto other static analyzers tobetterunderstandtheperformanceof catapult incomparison to other types of property unaware static analyzers we also ran catapult against two prominent and mature static analyzers csa based on symbolic execution and infer based on abductive inference .notethat inferdoesnotclassifythepropertiestocheck as table3buttargets at a similar range of properties suchas null dereference memory leak and others.
in our experiment csawas run withtwo different configurations one is its default configuration where a fast but imprecise range basedsolverisemployedtosolvepathconditions andthe other uses z3 a full featured smt solver to solve path conditions.
to ease the explanation we denote csain the two configurations as csa default and csa z3 respectively.
since csa separatelyanalyzeseachsourcefileand inferonlyhaslimitedcapability of detecting cross file bugs for a fair comparison all tools intheexperimentswereconfiguredtochecksourcefilesseparately and the timelimit for analyzing eachfile is set to minutes.
since a single source file is usually small we did not encounter memory issuesintheexperimentbutmissedalotofcross filebugsasdiscussedlater.also sincewebuildvalue flowgraphsseparatelyfor eachfileanddo notneed totrackcross filevalueflows thetime costofbuildingvalue flowgraphsisalmostnegligible.typically formysql ittakesaboutfiveminutestobuildvalue flowgraphs for all of its source code.
this time cost is included in the results discussed below.
note that we did not change other default configurations of csaandinfer.
this is because the default configuration is usually the best in practice.
modifying their default configuration may introduce more biases.
efficiency catapult vs.csa z3 .whenboth catapult and csaemployz3tosolvepathconditions theyhavesimilarprecision i.e.
full path sensitivity in theory.
however as illustratedin figure 6c catapult is much faster than csaand consumes a similar amount ofmemory for all of thesubjects.
for example for mysql ittakesabout36hoursfor csatofinishtheanalysiswhile catapult takesonlyhalfanhour consumingasimilaramountof memory.onaverage catapult is68 fasterthan csaatthecost ofonly2 morememoryspace.bothanalysescanfinishin12gb of memory available in common personal computers.
efficiency catapult vs.csa default and infer .as illustrated in figure 6c compared to both inferand the default version ofcsa catapult consumes a similar sometimes a little higher amount of time and memory.
for instance for mysql the largest subjectprogram allthreetoolsfinishtheanalysisin40minutesand consume about 10gb of memory.
with similar efficiency catapult as a fully path sensitive analysis is much more precise than theother two.
the lower precision of csaandinferleads to many false positives as discussed below.
icse may seoul republic of korea qingkai shi rongxin wu gang fan and charles zhang 236hrtime log scale subjects ordered by size0.5hr 35hr .8hr 2memory gb subjects ordered by sizetime minutes checkersmemory out 0memory outmemory gb checkers050100150200250300 0memory out 2memory gb subjects ordered by sizenot finish due to memory out020040060080010001200 2subjects ordered by sizenot finish due to memory outtime minutes a b c catapult infercsa z3 csa default pinpoint catapultpinpoint catapult catapult catapult figure6 a comparing catapult topinpoint.
b thegrowthcurvesofthetimeoverheadandthememoryoverhead.
c comparing catapult tocsaandinfer.
table effectiveness catapult vs.pinpoint csa and infer .
programcatapult pinpoint rep fp rep fp shadowsocks webassembly transmission redis imagemagick python glusterfs icu openssl mysql f p .
.
programcatapult csa z3 csa default infer rep fp rep fp rep fp rep fp shadowsocks webassembly transmission redis imagemagick python glusterfs icu openssl mysql f p .
.
.
.
we inspected one hundred randomly sampled bug reports.
we fail to run the tool on glusterfs.
effectiveness.
in addition to the efficiency we also investigate the bug finding capability of the tools.
the right part of table presents the results.
since we only perform file level analysis in this experiment the bugs reported by catapult is much fewer than thoseintheleftpartoftable .becauseoftheprohibitivecostof manually inspecting all of the bug reports we randomly sampled a hundred reports for the projects that have more than one hundred reports.
our observation shows that on average the false positive rateof catapult ismuchlowerthanboth csaandinfer.intermsof recall catapult reportsmoretruepositives whichcoverallthose reportedby csaandinfer.
csaandinfermissmanybugsdueto the trade offs they make in exchange for efficiency.
for example csaoften stops itsanalysis on a path after it finds the first bug.
together with the results on efficiency we can conclude that catapult ismuchmorescalablethan csaandinferbecausethey havesimilartimeandmemoryoverheadbut catapult ismuchmore precise and able to detect more bugs.
.
detected real bugs we note that the real world software used in our evaluation is frequentlyscannedbycommercialtoolssuchas coverity save11 and thus is expected to have very high quality.
nevertheless due tothehighefficiency precision andrecall catapult stillcandetect manydeeply hiddensoftwarebugsthatexistingstaticanalyzers suchas pinpoint csa and infer cannot detect.
at the time of writing thirty nine previously unknown bugs have been confirmed and fixed by the software developers includingseventeennullpointerdereferences tenuse after freeor double free bugs eleven resource leaks and one stack addressescape bug.
four of them even have been assigned cve ids due to theirsignificantsecurityimpact.wehavemadeanonlinelistfor all bugsassigned cve ids or fixed by their original developers.
11coverity scan 12detected real bugs .
conquering the extensional scalability problem for value flow analysis frameworks icse may seoul republic of korea resamplefilter acquireresamplefilterthreadset ... ... if ... return resamplefilter null ... image distortimage ... lines of code ...resample filter acquireresamplefilterthreadset ... ... switch method caseaffinedistortion scalefilter resample filter ... ... ... location magickcore resample private.h location magickcore distort.ca null pointer is returned if some condition is satisfied.
get the null pointer from the callee function.
the null pointer is dereferenced after a long propagation figure a null dereference bug in imagemagick.
asanexample figure 7presentsanull deferencebugdetectedby catapult in imagemagick which is a software suite for processing images.
this bug is of high complexity as it occurs in a function of morethan 000linesofcode andthecontrolflow involvedinthe bug spansacross56 functions over files.
since both csaandinfermake many unsound trade offs to achievescalability neitherofthemdetectsthisbug.
pinpoint also cannotdetectthebugbecauseitisnotmemory efficientandhasto give up its analysis after the memory is exhausted.
related work to the best of our knowledge a very limited number of existing staticanalyseshavestudiedhowtostaticallycheckmultipleprogrampropertiesatonce despitethattheproblemisveryimportant atanindustrialsetting.goldbergetal .
makeunsoundassumptions and intentionally stop the analysis on a path after finding the first bug.
apparently the approach will miss many bugs which violates our design goal.
different from our approach that reduces unnecessary program exploration via cross property optimization mordanandmutilin studiedhowtodistributecomputingresources sothattheresourcesarenotexhaustedbyafewproperties.
cabodi and nocco studied the problem of checking multiple propertiesinthecontextofhardwaremodelchecking.theirmethod has a similar spirit to our approach as it also tries to exploit the mutual synergy among different properties.
however it works in adifferentmannerspeciallydesignedforhardware.inordertoavoid state spaceexplosioncausedbylargesetsofproperties someotherapproachesstudiedhowtodecomposeasetofpropertiesintosmall groups .owingtothedecomposition wecannotsharethe analysis results across different groups.
there are also some static analyzerssuchas semmle and doop thattakeadvantage of datalog engines for multi query optimization.
however they are usually not path sensitive and their optimization methods are closely related to the sophisticated datalog specifications.
in this paper we focus on value flow queries that can be simply specified as a quadruple and thus cannot benefit from the datalog engines.csaandinfercurrentlyaretwoofthemostfamousopen source static analyzers with industrial strength.
csais a symbolic execution based exhaustive and whole program static analyzer.
as a symbolicexecution itsuffersfromthepath explosionproblem .
to be scalable it has to make unsound assumptions as in the aforementioned related work limit its capability of detecting crossfile bugs and give up full path sensitivity by default.
inferis an abstract interpretation based exhaustive and compositional static analyzer.tobescalable italsomakesmanytrade offs givingup path sensitivity and discarding sophisticated pointer analysis in most cases.
similarly tricoder the analyzer in google only works intra procedurally in order to analyze large code base .
in the past decades researchers have proposed many general techniques that can check different program properties but do not consider how to efficiently check them together .thus westudy differentproblems.
inaddition there are also many techniques tailored only for a special program property including null dereference use after free memory leak and buffer overflow to name a few.
since we focus on the extensional scalability issue for multiple properties our approach is different from them.
value flow properties checked in our static analyzer are also related to well known type state properties .
generally we canregardavalue flowpropertyasatype statepropertywithat most two states.
nevertheless value flow properties have covered a wide range of program issues.
thus a scalable value flow analyzerisreallynecessaryandusefulinpractice.modelingaprogram issueas avalue flow property has many advantages.for instance cherem et al .
pointed out that we can utilize the sparseness ofvalue flowgraphtoavoidtrackingunnecessaryvaluepropagation in a control flow graph thereby achieving better performance and outputtingmore concise issuereports.
in thispaper we also demonstratethatusingthevalue flow basedmodelenablesusto mitigatethe extensional scalability issue.
conclusion we have presented catapult a scalable approach to checking multiple value flow properties together.
the critical factor that makes ourtechniquefastistoexploitthemutualsynergyamongtheprop ertiestocheck.sincethenumberofprogrampropertiestocheckisquicklyincreasingnowadays webelievethatitwillbeanimportant research direction to study how to scale up static program analysis for simultaneouslychecking multipleproperties.