jiset javascript ir based semantics extraction toolchain jihyeok park kaist south korea jhpark0223 kaist.ac.krjihee park kaist south korea j31d0 kaist.ac.kr seungmin an kaist south korea h2oche kaist.ac.krsukyoung ryu kaist south korea sryu.cs kaist.ac.kr abstract javascript was initially designed for client side programming in web browsers but its engine is now embedded in various kinds of hostsoftware.despitethepopularity sincethejavascriptsemantics iscomplexespeciallyduetoitsdynamicnature understandingand reasoningaboutjavascriptprogramsarechallengingtasks.thus researchers have proposed several attempts to define the formal semanticsofjavascriptbasedonecmascript theofficialjavascript specification.
however the existing approaches are manual laborintensive and error prone and all of their formal semantics target ecmascript .
es5.
or its former versions.
therefore theyarenotsuitableforunderstanding modernjavascript language features introduced since ecmascript es6 .
moreover ecmascript hasbeen annuallyupdated sincees6 whichalready made five releases after es5.
.
toalleviatetheproblem wepropose jiset ajavascriptir based semanticsextractiontoolchain.itisthefirsttoolthat automatically synthesizes parsersandast irtranslatorsdirectlyfromagivenlanguage specification ecmascript.
for syntax we develop a parser generationtechniquewith lookaheadparsing forbnfes avariant of the extended bnf used in ecmascript.
for semantics jiset synthesizesast irtranslatorsusing forwardcompatible rule based compilation.
compile rules describe how to convert each step of abstractalgorithmswritteninastructurednaturallanguageinto ires an intermediate representation that we designed for ecmascript.
forthefourmostrecentecmascriptversions jisetautomatically synthesized parsers for all versions and compiled .
of thealgorithmstepsonaverage.afterwecompletethemissingpartsmanually the extracted core semantics of the latest ecmascript es10 passedall18 064applicabletests.usingthis firstformal semantics of modern javascript we found nine specification errors in es10 which were all confirmed by the ecma technical committee39.furthermore weshowedthat jisetisforwardcompatible by applyingittoninefeatureproposalsreadyforinclusioninthenext ecmascript which let us find three errors in the bigint proposal.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
figure existing approaches manually built parsers and ast ir translators for javascript ir based semantics keywords javascript mechanized formal semantics program synthesis introduction javascript is one of the most widely used programming languages not only for client side but also for server side programming and even for small embedded systems .
it is the top ranked language used in active github repositories1 and in the tiobe programmingcommunityindex2.accordingtow3techs3 .
of websites use javascript as their client side programming language.
despite its popularity javascript developers often suffer from itsintricatesemantics whichmaycauseunexpectedbehaviors.for example the following function may seem to always return false function f x returnx !
x unfortunately itreturns truewhenitsargumentisanemptyarray .tocorrectlyunderstandandreasonaboutsuchacomplex behavior the formal semantics of javascript is necessary.
researchershavedefinedvariousjavascriptformalsemantics suitableforstaticanalysis andformalverification byreferringtoecmascript.ecmascriptistheofficial specification that describes the javascript syntax using a variant of theextendedbnf ebnf notation anditssemanticsusingabstract algorithms written in english in a clear and structured manner.
ir based semanticsextraction is atraditional way todefine the formal semantics of a language by building a compiler front end that takesprogramsandproducestheirintermediaterepresentations irs toindirectlyrepresentthesemanticsofthegivenprograms.
as illustrated in figure a compiler front end consists of a parser that constructs abstract syntax trees asts of given javascriptprograms and an ast ir translator that converts asts to their own irs.
it helps researchers focus on irs without worrying about 35th ieee acm international conference on automated software engineering ase diverse and enormous features of javascript in developing new techniques for static analysis and formal verification.
however to the best of our knowledge all existing approaches to javascript ir based semantics extraction manually build parsers and translators.
although manually building them was reasonable until ecmascript .
es5.
it is too tedious laborintensive and error prone to deal with the large size of modern javascript since ecmascript es6 .
es6 introduced numeroussignificantlynewfeaturessuchaslexicalbindingvia let the spread ...operator classes the for ofoperator the async functions andgenerators.forexample considerkjs oneof formalsemanticsofes5.1definedontopof k whichisaframework for defining language semantics.
according to an author of kjs it tookfour months to implement an ast ir translator for stepsoutof2 932stepsin368abstractalgorithms .however themostrecentversionofecmascript es10 has2 abstract algorithms consisting of steps.
thus the manual approachesdonotseemtobescalableenoughtobuildanast ir translatorformodernjavascript andindeednoformalsemantics exists for es6 to es10.
moreover javascriptsyntaxandsemanticsareannuallyupdated.
until es5.
javascript was a stable language because the specification was rarely updated.
however the ecma technical committee tc39 decidedtoreleasethespecificationannuallyinlate .
after this official announcement several syntax features and roughly to steps of abstract algorithms have been modified or newly added in the specification every year.
to handlethese frequent and massive updates of ecmascript the manualapproaches require researchers to manually update parsers and ast ir translators which incurs tremendous efforts.
toalleviatethisproblem weproposeatechniqueto automatically synthesize parsers and ast ir translators directly from ecmascriptwith forwardcompatibility.thereareseveraltechnical challenges in synthesizing parsers and translators.
for syntax ecmascript utilizes its own variant of ebnf with parametric non terminals conditional alternatives and various special terminal symbols.thus noexistingparsergenerationtechniqueisdirectly applicable for this variant.
moreover javascript provides auto matic semicolon insertion in its parsing algorithm with several complex rules not in a lexer.
for semantics abstract algorithms in ecmascript are written in english.
besides a general and forward compatible representation of abstract algorithms is necessary to support future versions of ecmascript.
our contribution is jiset a javascript ir based semantics extraction toolchain jisetisthefirsttoolthatautomaticallyextract ir based semanticsfromalanguagespecification ecmascript.
for syntax weformallyintroduceavariantofebnf bnfes and propose a parser generation technique with lookahead parsing forbnfes which supports automatic semicolon insertion.
for semantics we propose semi automatic synthesis of ast ir translators assisted by compile rules.
compile rules describehow to convert each step of abstract algorithms into our intermediaterepresentation iresdesignedforecmascript.
we evaluated jisetwith the four most recent ecmascript versions es7toes10 .
jisetautomaticallygeneratedparsersfor figure overall structure of jiset automatically synthesizedjavascript parser andast irestranslator for javascript ir based semantics all versions and automatically compiled .
of the steps in abstract algorithms on average.
jisetbridgesgapsbetweenthespecificationwrittenina natural language and tests.
to evaluate the correctness of jiset we checked the extracted semantics with the official test conformance suite test262 .
by manually completing missing parts of the ast ir translator for the latest ecmascript es10 wedefinedthe firstir basedformalsemanticsof modern javascript.
it failed for tests because of specificationerrorsines10.usingthetests wefoundeightspecificationerrors threeofwhichhadnotbeenreportedbefore.theywereallconfirmedbytc39andwillbefixedinthenextrelease.after fixingthem theformal semanticspassedall 064applicable tests.
jisetis alsoforward compatible with new language featuresproposedforfutureecmascriptspecifications.
we evaluatedtheforwardcompatibilityof jisetbyapplyingitto allnineproposalsthatarereadyforinclusioninthenextecmascript es11 .itautomaticallysynthesizedparsersand compiled560 outof 595algorithm steps forall theproposals.
aftercompletionofthemissingparts wefoundthreespecifications errors in bigint proposal by executing the corresponding tests in test262.
after fixing them the extracted semantics passed all applicable es10 tests and new applicable tests.
overview inthissection weintroducetheoverallstructureof jisetdepicted infigure2.comparedtotheexistingapproachesshowninfigure1 our tool automatically synthesizes javascript parser andast ires translator directly from ecmascript.
the motivation of this work is twofold ecmascript is written in a well organized style and the writing style is converged since es7 in .
we explainhow jisetutilizes such common patterns in the writing style to a arrayliteral production in es10 valarrayliteral list laparser memo caselist yield await arrayliteral0 arrayliteral1 elementlist yield await opt elision arrayliteral2 b generated parser for the arrayliteral production figure arrayliteral production in es10 and its parser synthesize javascript parser andast irestranslator using the syntax and semantics in json format extracted from ecmascript byspec extractor.
syntax.ecmascript provides the lexical and syntactic grammars in appendix a using a variant of ebnf for ecmascript.
we dubitbnfesandformallydefineitinsection3.our specextractor readsthegrammarswrittenin bnfesandconvertsthemintojson files.forexample figure3 a showsthe arrayliteral production ines10.ittakestwobooleanparameters yieldandawaitandhas threealternatives.thefirstalternativeconsistsofthreesymbols two terminal symbols and one non terminal symbol elisionopt.theoptsubscriptdenotesthatitisoptional.inthesecond and third alternatives elementlist denotes a parametricnon terminalsymbol elementlist withtheparameters yieldand awaitofarrayliteral asitstwoarguments.theprefix ?ofasymbol denotes that the symbol is passed as an argument.
to generate javascript parser from a given bnfesgrammar we construct parser generator in scala.
it synthesizes a javascript parseraccordingtothegiven bnfes andthegeneratedparseris defined with scala parser combinators .
moreover in order to parse bnfesgrammars correctly and efficiently we propose lookahead parsers which keep track of lookaheads sets of possible next tokens.
with lookahead parsing generated parsers now have one to one mapping to their corresponding grammar productions improving readability.
for example figure b shows the gener ated parser for the arrayliteral production in figure a .
each parserhasthe list laparser typebecauseeach productionin bnfesisparametricwithbooleanvalues.the memois a memoization function for pairs of boolean parameters and resulting parsers for performance optimization.
the value arrayliteral corresponds to the arrayliteral production.
in the parser each string literal such as denotes a parser for a terminal symbol.the opthelperfunctioncreatesoptionalparsers.theparametricnon terminal elementlist witharguments yieldandawait is represented as a function call elementlist yield await .
the operatorcombinestwoparsersandthe operatordescribeshow to construct asts.
when the left hand side of is matched its right hand side shows a corresponding ast constructor wherethe name of each constructor has a number denoting the order a evaluation abstract algorithm for the third alternative arrayliteral .evaluation elementlist elision l e ta r r a y !
arraycreate let len elementlist.arrayaccumulation array ?l e n if elision absent let padding else let padding elision.elisionwidth set array length touint32 padding len false return array b the generated ir esfunction figure4 evaluationabstractalgorithmforthethirdalterna tive ofarrayliteral in es10 and its generated ir esfunction among alternatives.
for example the arrayliteral0 constructor corresponds to the first alternative of the arrayliteral production.
semantics.
ecmascript describes the language semantics as abstract algorithms in english.
while they are written in a natural language thewritingstyleiswell organizedwithorderedstepsandtaggedtokens.
specextractor readsabstractalgorithmswithhtml tags and converts them into json files.
for example figure a presents the evaluation abstract algorithm of the third alternativeof the arrayliteral productionin es10 andit hassevensteps.
in the html files describing the abstract algorithms each nonterminalsymbol e.g.
elementlist localvariable e.g.
array code e.g.
length or value e.g.
false has the nt var code o r emu val tag respectively.
totranslatesuchabstractalgorithmsintorepresentationssuitableformanipulation wedefine ires aspecializedintermediate representation for ecmascript.
then we develop algorithm compilerinscalausingscalaparsercombinatorsagaintoconvertgiven abstractalgorithmsto iresfunctions.italsotakes compilerules as another input which has two parts parsing rules and conver sion rules.
they are manually specified for ecmascript we explain them in detail in section .
thus each abstract algorithmis converted into a function written in iresviaalgorithm compiler.forexample figure4 b presentsthegenerated iresfunction for theevaluation abstract algorithm shown in figure a .
the arrayliteral .evaluation function takes two parameters for twonon terminalsymbols elementlist andelision.theparameterelisionhas a special value absentwhen the non terminal symbolelisionoptis not present.
thus we convert the condition in step if elisionis not present into the equality check with absent if elision absent .
codes are represented as string valuesandvaluesarerepresentedascorresponding iresvalues.for 649instance thecode length andthevalue falseareconvertedinto thestringvalue length andthebooleanvalue false respectively.
finally jisetconstructs ast irestranslator with the given iresfunctions and manually specified global setting which has minorbutnecessaryinformationtoevaluatejavascriptprograms describedinecmascriptsuchasthestructureofthestandardbuiltinobjectsandecmascriptdatatypes.puttingthemalltogether wecantranslateagivenjavascriptprograminto iresviagenerated javascriptparser andast irestranslator byjiset.eventhough jisetisnotfullyautomaticbecauseof compilerules andglobal setting it could dramatically reduce the efforts to building parsers and translators from scratch.
in the remainder of this paper we explain the details of how toautomaticallygenerateparsers section3 andhowtocompile abstract algorithms section .
after evaluating jiset section we discuss related work section and conclude section .
parser generator inthissection weexplainhowtoautomaticallygeneratejavascript parsers from a given ecmascript.
.
bnf es grammar for ecmascript ecmascript describes the javascript syntax using a variant of the extendedbnf.weformallydefinethenotationanddubit bnfes.
it consists of a number of productions with the following form a p1 pk c1 ?
1 cn ?
n the left hand side of represents a parametric non terminal a with multiple boolean parameters p1 pk.
if a non terminal takes no parameter parentheses are omitted for brevity.
a productionhasmultiplealternativesseparatedby withoptionalconditions.
a condition cis either a boolean parameter por its negation !p.
an alternative is a sequence of symbols where a symbol sis one of the following theemptysequence whichpasseswithoutanyconditions a a terminal which is any token a a1 ak a non terminal which takes multiple argumentswhere eachargument aiiseither abooleanvalue t or f or a parameter pi s?
option which is the same with s s s positive negative lookahead whichcheckswhether ssucceeds fails and never consumes any input s integerdivides prime exclusion which firstchecks whether ssucceeds and then checks whether the parsing result does not correspond tos prime angbracketleft lt angbracketright no line terminator which is a special symbol that restricts the white spaces between two different symbols for example consider the following production a p p a !p b c then a t meansa canda f meansb c. .
lookahead parsing tosupport bnfescorrectly weextendpeg basedparsergeneration techniques with lookahead parsing.background parsingexpressiongrammar.
mostparsergenerators target context free languages with specific parsing algorithmsforcontext freegrammar cfg javaccwithll k bison with glr and antlr with all .
however they are not directly applicable for the ecmascript syntax because ecmascript lexical and syntactic grammars require context sensitive lexers and parsers context sensitivetokens ecmascripttokensarecontextsensitive because of javascript regular expressions and template strings.
for example x gcould be a single regular expressiontokenorfourtokensthatrepresentdivisionby variables xandgdependingonenclosingcontexts.thus lexers should be evaluated during parsing not before parsing.
context sensitivebnf essymbols bnfessupportscontextsensitivesymbols whicharepositive negative lookahead s s exclusion s integerdivides prime and no line terminator angbracketleft lt angbracketright.
they arehighlyexpressiveandtheycanevenrepresenttheclassic non context free language anbncn n with the following productions s xc ay x ax?b a aa?
y by?c however it is not trivial to support such bnfessymbols in cfg based parser generators.
unlike cfg based parser generators parser generators based onparsing expression grammar peg can easily resolve these problems.pegsaredefinedwithatop down ll style recursive descent parser with backtracking.
it visits each alternative of a productioninorderandbacktrackstoitspreviousproductionwhen parsingfails.peg basedparsergeneratorstreatlexersasparsers thus we can use appropriate lexers depending on parsing contexts.
moreover pegs support and predicate andnot predicate !
operatorsthatdenotethesamemeaningofthepositiveandnegative lookaheadsymbolsin bnfes respectively.therefore wecaneasily supportcontext sensitivetokensand bnfessymbolsinpeg based parser generators.
problem prioritized choices.
while peg based parser generatorssupportthecontext sensitivity pegshaveonefundamental difference with bnfes prioritized choices.
pegs use the prioritized choice operator instead of the unordered pipe operator i n bnfes even when multiple alternatives are applicable pegs alwayspickthefirstsuccessfulalternative.forexample considerthe following bnf es s e e e x x.p as expected this grammar accepts the string x x.p.
however the following peg s e e e x x.p does not accept the same string x x.p.
because the first alternative xofeis chosen whenever an input string starts with x the second alternative x.pofeis always unreachable.
a simple solution to acceptthestringisjusttochangetheorderofalternativesof elike e x.p x.
650first s1 sn firsts s1 first s2 sn wherex y braceleftbigg x yif x xotherwise firsts firsts a a firsts a a1 ak first 1 first n wherea a1 ak 1 n firsts s?
firsts s firsts s firsts s firsts s firsts s integerdivides prime firsts s firsts angbracketleft lt angbracketright figure over approximated first tokens of bnf essymbols unfortunately simple reordering is not a general solution for all cases.
consider the following bnf es s ab a a ab it accepts both strings abandabb.
however the following peg s ab a a ab accepts only ab and another peg with reordered productions as follows s ab a ab a accepts only abb.
solution lookahead tokens.
to alleviate the problem we proposelookaheadparsing whichisanextendedparsingalgorithm for pegs with lookahead tokens.
the key idea of lookahead parsing is to keep track of the next possible tokens by statically calculating asetoffirsttokensforeachsymbolusingthealgorithminfigure5.
for example the following steps explainhow to utilize lookahead tokens during parsing of the string x x.pwith the peg in equation x e e s zzx x x.p x x.p x x .p x x. px x.px x.p x x.p x x.p x x .p x .
p x .
p x eachnode s denotesasymbol swithasetoflookaheadtokens l. the underlined character in the string of each node denotes the current position in the parsing process that follows a pre order traversal.theparserstartsfromthestartingnon terminal swith thespeciallookahead whichdenotestheendofinputs.then it visits the first alternative e ewith the same lookahead .
each symbol is visited with its corresponding lookahead which is the s1 sn s1 s1 sn gets l a a gets l a a1 ak 1 n wherea a1 ak 1 n s?
s s s s integerdivides prime s integerdivides prime angbracketleft lt angbracketright angbracketleft lt angbracketright gets l figure formal semantics of lookahead parsers firsttokensoftherightnextsymbol.forexample forthesecond symbol ine e the next symbol is eand its first tokens are firsts e first x first x.p firsts x firsts x first .p x thus the parser visits with the lookahead x. the most important point here is the difference between two visits of the non terminal eine e. the first visit of ehas the lookahead and the actual next character after matching xis also .
thus the first alternative xofeischosenforthefirstvisit.however inthesecondvisitof e the lookahead is the end of inputs but the next character after matching xis the dot character .
instead of the end of inputs.
therefore thesecond alternative x.pis chosenin thesecond visit and the parser now successfully parses the input x x.p.
we formally define the semantics of lookahead parsers in figure6.thehelperfunction gets l generatesaparserbycombining all tokens in the lookahead lusing prioritized choices.
in this case theorderdoesnotchangethesemanticsoflookaheadparsersbecausegets l just checks the existence of a given token.
.
implementation we implemented the lookahead parsing technique by extending the scala parser combinators library which is a scala library for peg basedparsergeneration.wedeveloped parsergenerator to synthesize peg based parsers with lookahead parsing for bnf es.
ast generation.
parser generator first automatically synthesizes asts as scala classes from a given bnf esgrammar.
because thestructureoflexicalproductionsdonotaffecttheecmascript semantics we represent lexical non terminals as string values.
for each syntactic production a p1 pk c1 ?
1 cn ?
n the generator synthesizes a trait aand its multiple subclassesaifor i n that represent its alternatives.
each classaihas non terminals in its corresponding alternative as its fields.
for instance the arrayliteral production in figure gets automatically translated to the following scala classes traitarrayliteral extends ast case class arrayliteral0 x1 option case class arrayliteral1 x1 elementlist case class arrayliteral2 x1 elementlist x3 option parser generation.
the next step is to automatically synthesizes parsers for each production in bnfes.
we extended scala parser combinators to support lookahead parsing and bnfesnotations.forexample thesynthesizedparserfromtheproduction 651figure overall structure of algorithm compiler arrayliteral in figure a is the one in figure b .
a na ve implementation of lookahead parsing would take exponential time because of backtracking.
to reduce it to linear time we applied the memoizationtechniqueintroducedinpackratparsing .moreover wealsoimplementedthe growingtheseed techniquepresented bywarthetal .
tosupportdirectandevenindirectleftrecursive productions.itenablesthesynthesisofparserswithoutchanging the structure of each production in bnf es.
thesynthesizedparsersalsosupporttheautomaticsemicolon insertion algorithm which is one of the most distinctive parsing featuresinecmascript.weextendedourparsingalgorithmtokeep track of the right most position that fails to be parsed in a given input.
in ecmascript the token at that position is defined as an offending token and the automatic semicolon insertion algorithm is definedwithsuchtokens.thealgorithmissimplewhenwealready have the positions of offending tokens.
thus we just manually supportedthembyfollowingtherulesdefinedinsection11.94in es10.
the automatic semicolon insertion rules rarely change since es5.
written in only one sub rule was added.
algorithm compiler inthissection weexplain algorithmcompiler thatcompilesabstract algorithms to ir esfunctions as illustrated in figure .
.
tokenizer beforecompilingabstractalgorithms tokenizer firsttokenizeseach abstractalgorithmintoalistoftaggedtokens.analgorithmconsistsoforderedsteps andastepmaycontainsub stepsaswell.forexample the evaluation abstractalgorithminfigure4 a hasseven steps.
moreover the tokens of each step have their own htmltags and each tag has a meaning.
we keep such html tag infor mation for each token to construct more precise compile rules.
if an html element is just a text without any explicit tags it is dividedintomultipletokensandeachtokenbecomesasequence ofalphanumericcharactersorasinglenon alphanumericcharacter.
for example in the evaluation algorithm length is a single tokenwiththehtmltag code andperform set isdividedinto three text tokens perform set and .
moreover tokenizer flattens a structured step to a single token list to handle multi step statements easily.
some statementsinabstractalgorithmsconsistofmultiplesteps.forexample the if then elsestatementoftenconsistsoftwosteps oneforthe then branch and the other for the else branch.
to treat them as a weintroducethreespecialtokensto breakdown structured algorithms denotes the end of a single step and arrowsoutheast and arrowsouthwestdenote the start and the end of nested steps respectively.
forexample thefollowingleftabstractalgorithmistokenizedto the right token list.
.
a .
b a b arrowsoutheastc arrowsouthwest a. c after tokenizing abstract algorithms algorithm compiler compiles token lists into iresfunctions using token list parser and token ast converter.
they depend on compile rules and each compile rule consists of a parsing rule and aconversion rule valcompilerule parsingrule conversionrule for each compile rule its parsing rule describes how to parse a giventokenlistintoastructuredtokenast anditsconversionrule describeshowtoconvertthegiventokenaststructureintoan ires component.now weexplainthetokenlistparserandtokenast converter with parsing rules and conversion rules respectively.
.
token list parser thetokenlistparserisdefinedwith parsingrules.aparsingrule isabasicparsingruleoracompositionofmultipleparsingrules.
thecomposition a boftwoparsingrules aandbparsesaninput usingbothrulesandcollectsthelongestmatchedresults.ifbothrulesfailormatchthesamelengthoftheinput thecomposition fails.
we provide two kinds of basic parsing rules tag based rules andcontent basedrules.atag basedrulejustcheckswhetherthe next token has a given tag.
for example the tag based parser vart andcodetcheck whether the next token has the tag var and code respectively.
a content based parser checks whether the next token is a text token and its content passes a given condition.
forexample thestringliteral perform denotesacontent based parser that checks whether the next token is a text token withthe content perform.
we also define two content based parsers wordandnumberthat check whether the content of the next token consists of only alphabets or numbers respectively.
in addition we provide several helper functions such as the optional rule a?
andthepositive negative predicate a a .forinstance thehelper function repsep a b generatesanewparsingrulethatdenotes zero or more repetition of the parsing rule ausing another parsing rulebas a separator.
consider the following example parsing rule for the step of theevaluation algorithm in figure a .
statements valstmt perform expr .
... expressions valexpr codes false literal codet ... false ... variables additions vart ... expr e x p r .
.
.
function calls word repsep expr ... 652we omit the conversion rule for each compile rule for brevity.
the stmtcompileruledescribeshowtocompilestatementswithasingle parsingrule andthe exprcompileruledescribeshowtocompile expressions with five parsing rules.
a token parser with the above rulesparses thestep 5of evaluation tothe followingtoken ast .
token ast converter conversion rules describe how to generate an iresfunction for a given token ast.
each conversion rule is defined with its corresponding parsing rule.
for basic parsing rules their conversion rulesalwaysreturnthestringvaluesofthecontentsinparsedtokens.
for example the following conversion rules are the omitted parts in the previous example for the step of evaluation statements valstmt ... case e iexpr e expressions valexpr codes false literal .
.
.
e s t r .
.
.
ebool false variables additions .
.
.
e i d .
.
.
case x y eadd x y function calls ... casex y ecall x y the conversion rule of the stmtcompile rule uses only the second subtreeandconstructsan iexpriresinstruction.forthesecond sub tree theconversionruleofthefifth exprcompileruleisapplied.
it constructs ecalliresexpression with the string value of the first sub treeand the sequence ofthe expressions of thethird subtree.
in this way the step of evaluation is converted to the following iresinstruction whose beautified form is the seventh line in figure b .
iexpr ecall eid set list eid array estr length ecall eid touint32 list eadd eid padding eid len ebool false we define iresto represent abstract algorithms as its functions with the following design choices dynamictyping becauseeachvariableinabstractalgorithms is not statically typed variables do not have their own static types while each value of ir eshas its dynamic type.
imperative style iresrepresentsalgorithmstepsasimperative instructions in the sense that each instruction changes the current state consisting of an environment and a heap.table general compile rules for ecmascript name stmt expr cond value ty ref rules higher orderfunctionswithrestrictedscopes ineachfunctionofires onlyglobalvariables parameters anditslocalvariablesareavailable whichmeansthatafunctionclosuredoesnot capture its current environment.
we use such restricted scopes because they are enough to represent abstract algorithms.
primitivevalues iressupportsecmascriptprimitivevalues except symbols because symbols can be represented as singleton objects.
also iresprovides the unique absentvalue to represent the absence of parameters.
for example when the optionalsecondparameter elisionofevaluation infigure4 a is absent the parameter has the absentvalue.
abstract data types iressupports only three abstract data types recordfor mappings from values to values listfor sequential data and symbolfor singleton data.
for example ecmascript environment records are represented as record fromstringvaluestoaddressesthatrepresentthebindingsof the string values.
wedefinethesyntaxof iresthathas15kindsofinstructionsand26 kindsofexpressionswiththenotation iande respectively.wealso formallydefineitsoperationalsemantics turnstilelefti forinstructions and turnstilelefte v for expressions where denotes a stateand v denotesavalue.forpresentationbrevity weomittheformalization of iresin this paper and include it in a companion report .
.
implementation we implemented algorithm compiler by extending the packrat parsing library inscala parser combinators.
we modified the meaning of the composition operator to collect all the longest matched results.
if a parser detects a step that cannot be parsed or is parsed in multiple ways it reports the stepwith parsing results.
compile rules.
algorithm compiler requires compile rules to compile given abstract algorithms to iresfunctions.
as already explainedinsection2 wefoundcommonpatternsinthewriting style of abstract algorithms.
we manually defined general compile rules to represent sucha writing style withsix different kinds as summarized in table .
the compile rule for statements stmt generatesiresinstructions.
the expr cond andvaluecompile rules generate iresexpressions but they represent different contexts in ecmascript exprrepresents a context where any expression canappear conddenotesacontextwhereanyboolean valuedexpressioncanappear and valuerepresentsacontextwhereafully evaluatedvaluecanappear.the tycompileruledenotestypenames andgeneratesstringprimitivesusedinobjectconstructions.the refcompile rule represents