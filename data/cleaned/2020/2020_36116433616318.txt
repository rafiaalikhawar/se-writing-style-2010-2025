leveraging hardware probes and optimizations for accelerating fuzztesting ofheterogeneous applications jiyuanwang university ofcalifornia losangeles usa wangjiyuan cs.ucla.eduqian zhang university ofcalifornia riverside usa qzhang cs.ucr.eduhongborong intellab usa hongbo.rong intel.com guoqing harryxu university ofcalifornia losangeles usa harryxu cs.ucla.edumiryungkim university ofcalifornia losangeles usa miryung cs.ucla.edu abstract thereisagrowinginterestinthecomputerarchitecturecommunity to incorporate heterogeneity and specialization to improve performance.
developers can create heterogeneous applications that consistofboth hostcodeand kernelcode wherecompute intensive kernelscanbeoffloadedfromcputohardwareaccelerators.testing such applications on realheterogeneous architectures is extremely challengingaskernelsareblackboxes providingnoinformation about the kernels internal execution to diagnose issues such as silent hangs or unexpected results.
additionally inputs for heterogeneous applications are often large matrices leading to a vast searchspacefor identifyingbug revealinginputs.
weproposeanovelfuzztestingtechnique hfuzz toenableefficienttestingonrealheterogeneousarchitectures.
hfuzzaimsto increase both the observability of hardware kernels and testing efficiency through a three pronged approach.
first hfuzzautomatically generates test guidance by inserting device side in kernel hardwareprobesinadditiontohost sidesoftwaremonitors.second itperformsrapidinputspaceexplorationbyoffloadingcomputeintensive input mutations to hardware kernels.
third hfuzzparallelizesfuzzingandenablesfaston chipmemoryaccess byutilizing four fpga level optimizationsincluding loop unrolling shannonization datapreloading anddynamickernelsharing.
we evaluate hfuzzon seven open source oneapi subjects from intel.hfuzzspeeds up fuzz testing by .
with hw accelerated inputspaceexploration.byincorporatinghwprobesintandem withswmonitors hfuzzfinds33defectswithin4hoursandreveals unique unexpected behavior symptoms that could not be found bysw basedmonitoringalone.
hfuzzisthefirsttodesignhardware optimizations toaccelerate fuzz testing.
ccsconcepts softwareanditsengineering softwaretestinganddebugging computersystemsorganization heterogeneous .
esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
fuzz testing heterogeneous applications acm reference format jiyuan wang qian zhang hongbo rong guoqing harry xu and miryung kim.
.leveraginghardwareprobesandoptimizationsforaccelerating fuzz testing of heterogeneous applications.
in proceedings of the 31st acmjointeuropeansoftwareengineeringconferenceandsymposiumonthe foundationsofsoftwareengineering esec fse december3 san francisco ca usa.
acm new york ny usa 13pages.
.
introduction therehasbeenagrowinginterestindevelopingspecializablehardware accelerators for domain specific workloads for various performance and energy benefits .
as an example fpga canbeeasilycustomizedtoaccelerateapplicationsacrossawide variety of domains at lower power and higher performance thangeneral purposecpus .majorhardwarevendors areofferingorplantoofferpackagesthatincludebothcpusand fpgas .suchhardwarepackageshavealsobeenmadeinto allmajorclouds toaccelerate various analytic andlearningtasks.
in recent years fuzz testing has emerged as an effective test generationtechniqueforlargesoftwaresystems .mostfuzzing techniques such as afl start from a seed input generate new inputs by mutating the previous input and add new inputs to thequeueif theyimprove agivenguidancemetric suchasbranch coverage.
in this paper we focus on fuzz testing i.e.fuzzing of applications on a heterogeneous platform with a cpu host and an fpgadevice.sucha heterogeneousapplication consistsof hostcode andkernelcode and the host code offloads compute intensive kernelsfromthecputothefpgatorun.despitethepotentialbenefits of fpgas and their commercial availability to a broad user base programmingfpgasisnotoriouslydifficultinpractice.ensuring the correctness of fpga programs even seemingly simple kernels could take a substantial amount of time in terms of months .
as such fpga programming can be done by only a small handful of hardware experts .
automatic fuzz testing of heterogeneous applications together with root cause analysis of failures cangreatlysimplifyfpgaprogramming therebymakingfpgas accessible tothe masses.
there has been significant effort to ease the development of heterogeneousapplicationswithfpgas.themostsuccessfuleffort thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa jiyuan wang qian zhang hongbo rong guoqing harry xu andmiryungkim figure latency breakdown of running applications on heterogeneous architectures.
on average data transfer into kernelstakes60 ofexecution time highlighted ingray.
ishigh levelsynthesis hls .hlsraisesthelevelofprogramming abstraction from hardware description languages such as verilog to c c dialects such as sycl dpc enabling c c developersonfpgas.evenwhenheterogeneousapplications are written in hls languages debugging and testing these heterogeneous applications can remain a significant challenge due to the following reasons lackofobservability.
fpgaisadeviceofmassiveparallelism.
little debugging support exists to help high level programmers.
kernelsrunonanfpgadeviceasblackboxes anditoftenconfuses programmers e.g.
when the kernels silently deadlock.
generalpurpose fpga debugging works at the gate level.
even when in circuit debugging information is available it is difficult to correlate low level gate signals with high level variables in hls programs.
consider a scenariowhere an applicationmultiplies twomatricesaandbto create a new matrix m m a b and then applies a reciprocaltransformationoneachelementof m.thisapplication hastwokernelsoffloadedtofpga matrix multiply and transformer .totransfertheintermediateresult mfromthefirstto thesecondkernel apipeisestablishedtofacilitatedatatransfer.for eachelementinthematrix m thefirstkernelwritesitscomputed valuetothedesignatedpipe andthesecondkernel transformer readsitfromthepipe computesthereciprocal andtransfersthe final result back to the host.
with fpga emulation the application works as expected because both kernels run at the same speed.
however whenrunonanactualfpga thespeedofthefirstkernel generating a value can be different from the speed of the second kernel consuming it.
the developer should check the size of the pipe delay writing if it is full or delay reading if it is empty.
if such check is not done the pipe would be saturated or depleted resulting in data loss and wrong reciprocal outcomes.
currently duetoalackofobservabilityintothedynamicusageofthepipe the developer mayfind itdifficult to diagnosethe root cause.
costlytransferofdatawithhighredundancy.
traditionaliterativefuzzingtechniquesoftenmutateasmallpartofaseedinput to generate new inputs.
while this approach works well for many cpuprograms itisextremely ineffective forapplicationsthatare run onheterogeneous architectures.
inputs of heterogeneous applicationsare oftenlargematricesand tensors leading tosignificant data access and transfer overheads the host which mutates the matrices must send newly mutated matrices e.g.
with only a fewelements modified to the device.
figure 1illustrates the latency breakdown of running applications on intel s heterogeneous architecture.onaverage datatransferfromcputohardwarekernels takes60 oftheexecutiontime.fora100k 100kmatrix asingle process of offloading the new generated matrix from the fuzzer to the device would take minutes prohibiting fast fuzzing on heterogeneous architectures.
overlooked opportunities forfpga level optimizations.
fuzzing heterogeneous applications may be approached in a na ve mannerbytreatinghardwarekernelinvocationsasanalogousto softwarefunctioncallsandrepeatedlyinvokingthemfromaniterative input mutation loop.
however this approach ignores the potentialoptimizingcapabilityoffpga asthemutationsoftenconsistofindependenttasksthatcanbeparallelizedefficientlywhen offloadedtothefpgaside.inotherwords thenatureoffuzzing i.e.
iterative input generation and program invocation unlocks new micro architecturelevelperformanceoptimizations.indeed wecan treat the domain of heterogeneous applications not only as a new targetdomain butasanewenablerforacceleratingautomatedtest generation.whensoftware stylematrixinputmutationisoffloaded to fpga and is then combined with subsequent kernel invocation manymicro architectureleveloptimizationssuchasloopunrolling datapreloading shannonization anddynamickernelsharingare nowapplicable for further performance speed up.
hfuzz.we developed hfuzz a novel fuzz testing tool that aims to quicklyrevealbugsinheterogeneousapplications.ourkeyinsights are elaboratedbelow first toimproveerrorobservabilityduringtesting hfuzzinjects hardwareprobesinsidethekernels intandemwithsoftwaremonitors inside the host.
this is different from prior approaches that consideranfpgakernelasablackboxandinjectsoftwaremonitors only .inhfuzz bothsoftwaremonitorsandhardwareprobes are designed to effectively detect overflows caused by intermediate variables within the fpga kernel as well as pipe saturation errors that may occur during data transfer between different devices.
thesehardwareprobesareinjectedthroughsource to sourcetransformationandthensynthesizedforfpga.withtimelyexecution feedbackfromthehardwareprobes hfuzzprioritizesinputsthat provide a new behavior signal at the fpga execution level.
for example hfuzzmonitorsthesaturationofacommunicationpipe between two fpga kernels and retains the inputs that lead to a newmaximum pipe saturationlevel for further mutations.
second hfuzzoffloads input mutations into fpga kernels to reduceunnecessarydatatransfer.fora vector add example instead ofrepeatedlytransferringamutatedinputvectorofsize hfuzz retains the initial input vector in the fpga buffer and mutates the elementsof thevectorwithinthefpga kernel.for another example thehost sidemutationofaseedmatrixwith10 000elements for1 000timestakes9.1seconds inourevaluation whilein kernel inputmutation takes only .
seconds.
third hfuzzimplementsfourtypesoffpga leveloptimizations to speed up fuzzing.
for example one such optimization is dynamickernelsharinginparallelfuzzingloops whichenablesamore effective search space exploration when utilizing multiple input generators each with its own seed queue.
hfuzzthen invokes the target kernel functionusing amutatedinput selectedfrom one of 1102leveraginghardware probesandoptimizations foraccelerating fuzz testingof heterogeneousapplications esec fse december3 san francisco ca usa theseedqueuesanddynamicallyincreasestheprobabilityofchoosing that input generator if the input yields new behavior signals at thehardwareexecutionlevel.theotherthreemicro architecture leveloptimizationsare loopunrolling whichenablesparalleliteration shannonization which precomputes operations and reduces thelatencyofcriticalpaths and datapre loading forfastmemory accessbymovingdatafromglobalmemorytolocalmemory.
hfuzz isthefirsttodirectlyleveragetheperformanceenhancingpower offpgaforautomatedtestingofheterogeneousapplicationson an fpga device.
we evaluate hfuzz s effectiveness on seven programs.
these programs are from intel s oneapi benchmarksfor heterogeneous applications with fpga kernels .
we compare hfuzzagainst four alternatives alternative afl like an afl like grey box fuzzingtoolthatuses branchcoverageas feedback andruns onthe hostentirely alternative2 heterofuzz thestate of the arttesting tool for heterogeneous applications using software monitors only alternative nokernelmutation hfuzzwith cpu side input mutation without offloadingit tofpga and alternative nohwoptimization hfuzzwithout fpga level optimizations.
it took hfuzz much less time i.e.
.
.
and .
of the time used by the four alternatives to find the same number of defects.
given thesametimebudget 4hours hfuzzfound11 .
.
and .
more defects than the four alternatives.
we tried longer time hours but nomoredefect is foundafter hours.perthe open science policy we make hfuzz s artifacts benchmark programs anddatasets available at .
in summary this work makesthe following contributions toourknowledge hfuzzisthefirstfuzztestingtechniquethat useshardwareprobesintandemwithsoftwaremonitorstoguide test inputgenerationfor heterogeneous applications.
hfuzzis the first to unlock new micro architecture level performanceoptimizations for fuzz testing by mapping both iterative inputmutationandkernelinvocationtofpga sidecomputation.
it implements four fpga level optimizations and accelerates fuzzingby3.
.
hfuzzacceleratesfuzztestingby4.
bydirectlysynthesizing inputmutationswithinkernelsonfpga.thisalsoreducesthe host device data transfer overheadby66 .
witha4 hourbudgetonsevenbenchmarks hfuzzwasableto discover defects while traditional coverage guided fuzzing onlyuncovered3defects.outofthese33defects 25couldnot have been foundwithoutthe use ofdevice sidefeedback.
background .
heterogeneousapplicationswith fpga drivenbyperformanceandenergybenefits heterogeneouscomputingapplications containcodethatisexecutedondifferent kindsofprocessorssuch as cpu gpu andfpga.
fpgasarefieldprogrammablegatearrays.modernfpgasinclude millions of look up tables luts thousands of embedded block memories brams thousands of digital signal processing blocks dsps and millions of flip flop registers ffs .
intel providescpu fpgamulti chippackages withitsrecentacquisitionofaltera suchintegrationisexpectedtobeeventighterinthe1for ints s nsteps s ... kernel calculate velocity 4h.parallel for n item i acc0 acc1 acc2 pragma unroll factor for intj j n j if j i continue int8dx dy dz dx p .pos p .pos dy p .pos p .pos dz p .pos p .pos int8sqr dx dx dy dy dz dz acc0 kg p .mass sqr dx calculate acceleration acc1 kg p .mass sqr dy acc2 kg p .mass sqr dz p .vel acc0 dt calculate velocity p .vel acc1 dt p .vel acc2 dt figure nbody simulation a heterogeneous version with dpc high levelsynthesis.
future.fpgahasmadeitswayintomoderndatacenters including microsoft sazure amazonf1 andintel devcloud .
a heterogeneous application typically consists of hostcode executedonthecpuand kernelcodetobesynthesizedandexecutedon fpga or gpu.
host code initializes the device allocates the device memory transfers data to the device and invokes the computeintensivekernelonthedeviceside.aftertheexecution ittransfers the kernel outputback to the hostanddeallocates the memory.
to simplify kernel development high level synthesis hls lifts the abstraction of hardware development by automatically generating register transfer level rtl descriptions from code written in c like dialects.
one example of hls c c dialects is intel s data parallel c dpc a cross platform abstraction layerthatenablescodetobe targetedtodifferentcpus gpus and fpgas .
with dpc users can specify which hardware platform to implement a kernel on.
for example a user may use a compilerflag xsboard intel s10sx pac toselectintel sfpga s10.theusercandevelopakernelfunction f callingh.parallel for n f witha job handler h.this handler executes fwithndegree parallelism on fpga s10.
consider the example in section .
.
.
anillustratingexample nbody simulation figure2illustrates the simulation of n particles moving over a sequence of nsteps.
lines calculate the distance between particles while lines calculate the acceleration.
in lines theprogramsubsequentlyupdatestheparticles velocities based on the acceleration.
these computations are extracted as compute intensive kernels and offloaded to an fpga.
to enable parallelismandspeedupthevelocitycalculation thedeveloperuses h.parallel for and loop unrolling pragma unroll factor highlightedinred at lines4and6.
when writing a heterogeneous application a user must conservatively estimate the limit of hardware resources and specify bitwidths for custom types and the size of buffers and pipes because all hardware resources are finite.
due to the need to finite hardware resources a heterogeneous application often contains defectsthatcannotbedetectedstaticallyviastaticanalysis.thisisa problemthatuniversallyexistswithallhlslanguages.toillustrate considerthe real defectsinthe nbody simulation.
1103esec fse december3 san francisco ca usa jiyuan wang qian zhang hongbo rong guoqing harry xu andmiryungkim divide by zero in nbody simulation.
for code in figure with the input p.pos the velocity calculation on an fpga a10 device produces absurdly large numbers p.vel .this isbecause whenthekernelinputs contain two particles with the same position a divide by zero may happen inside the kernel inlines14 16dueto sqr 0at line13.
overflow in nbody simulation.
when the kernel calculates the accelerationoftwoparticlesinfigure anin kerneloverflowcould occur if two particles are close to each other i.e.
sqr 0at line .thisisbecausewhen sqrisclosetozero accbecomeslarge.
when the inputs p.pos are sent to the kernel it produces a small value sqr leading to overflow for thevariables acc1 finally thewrongresultissentbacktothehost.
state of the art.
grey boxfuzzing generatesprograminputs based on per iteration execution feedback.
suppose that a user uses grey box fuzzing to monitor the value range of the inputs and outputsofkernelsonthehost side cpu code.forthedivide byzerobugthatcouldoccurinfigure because sqrisanin kernel variableanddoesnotappearinthehostcode software sidegreybox fuzzing cannot easily reveal defects that originate from the inside ofthe kernel.
hfuzzaddressesthelimitationsofexistingworkbyutilizinghardwareprobestomonitortheintermediatestatesofkernels.
hfuzz identifies the in kernel local variable sqrat line and inserts hardware probes to track its value range.
the input generation process is then optimized by prioritizinginputs that result innew minimum ormaximum values of sqr.
as a result hfuzzis ableto effectivelydetectoverflowwhen sqrreachesthesmallvalue sqr anddivide by zerodefectswhen sqrreachesitsminimumvalue0.
approach hfuzzaims to find inputs that can trigger both in kernel errors andhost sideerrorsforheterogeneousapplicationswritteninintel sdpc hls .hfuzzcontainsthreenovelcomponentsthat work in concert in tandem monitoring of software and hardwarefeedbackbyinjectingsoftwaremonitorsandin kernelprobes section3.
offloading input mutations to hardware kernels section3.
and fpga level optimizations to speed up iterativeinputgenerationandkernelinvocation section .
.hfuzz s design builds on two key insights.
first hardware level parallelism canbringnotableperformanceenhancementforiterativefuzzing which is often characterized by independent task level parallelism.
second grey box fuzzing s effectiveness can be significantly improved by observing feedback signals from both hardware and software.
the fuzzing process.
the overall workflow of hfuzzis shown in algorithm .hfuzztakes as input a program u1d45dwritten in intel s dpc andproducesconcreteinputsthattriggerdefectsin u1d45d.hfuzz first appliesa source to sourcetransformation to u1d45dto produce an instrumentedversion u1d45d byinsertingin kernelprobesandsoftware monitorsthatcanguidefuzztesting.
hfuzzselectsaninputgenerator u1d43afromasetofgenerator u1d446.itthenrandomlyoffloadsarandom seed input u1d456 u1d45b from u1d43a s seed queue into the kernels.
to generate new inputs hfuzzcreates a new mutation kernel job in addition to the original kernel and utilizes parallelism within fpgas toalgorithm1 fuzzingworkflow.
input program u1d45d input generatorset u1d446 mutation operator set u1d442 1fuzzingloop u1d45d u1d446 2begin u1d45d instrument u1d45d u1d439 u1d452 u1d452 u1d451 u1d44f u1d44e u1d450 u1d458 5for1..maxdo u1d43a u1d446.
u1d460 u1d452 u1d459 u1d452 u1d450 u1d461 u1d456 u1d45b u1d45d u1d462 u1d461 u1d454 u1d452 u1d45b u1d452 u1d45f u1d44e u1d461 u1d45c u1d45f u1d456 u1d45b random select u1d43a u1d439 u1d43b u1d44a u1d439 u1d446 u1d44a u1d45d .h u1d45c u1d460 u1d461 u1d456 u1d45b u1d458 u1d452 u1d45f u1d45b u1d452 u1d459 u1d45a u1d462 u1d461 u1d44e u1d461 u1d452 u1d452 u1d465 u1d452 u1d450 u1d462 u1d461 u1d452 in o for u1d439 u1d439 u1d43b u1d44a uniontext.
u1d439 u1d446 u1d44a do if u1d439 u1d439 u1d452 u1d452 u1d451 u1d44f u1d44e u1d450 u1d458 then increase prob u1d446 u1d43a u1d454 u1d45c u1d45c u1d451 u1d456 u1d45b u1d45d u1d462 u1d461 regenerate u1d439.
u1d45a u1d456 u1d45b u1d43a u1d43a uniontext.
u1d454 u1d45c u1d45c u1d451 u1d456 u1d45b u1d45d u1d462 u1d461 u1d439 u1d452 u1d452 u1d451 u1d44f u1d44e u1d450 u1d458 u1d439 u1d452 u1d452 u1d451 u1d44f u1d44e u1d450 u1d458 uniontext.
u1d453 end end 17end 18end input kernel input u1d458 u1d460 mutation ops set u1d442 output u1d439 u1d43b u1d44ais aqueue oftriples u1d453 u1d45a u1d45c u1d462 u1d461 where u1d453is kernel feedback u1d45ais mutation and u1d45c u1d462 u1d461is kerneloutput 19in kernel mutate execute u1d458 u1d460 u1d442 20begin 21fori ..max do operator u1d45c select op u1d442 start u1d460 random generate end u1d452 random generate mutation u1d45a u1d45c u1d460 u1d452 u1d43c u1d45b u1d45e u1d462 u1d452 u1d462 u1d452 u1d43c u1d45b u1d45e u1d462 u1d452 u1d462 u1d452 uniontext.1mutate input u1d45c u1d460 u1d452 u1d458 u1d460 27end 28foreach u1d456 u1d45b u1d43c u1d45b u1d45e u1d462 u1d452 u1d462 u1d452do u1d453 u1d45a u1d45c u1d462 u1d461 executeondevice u1d456 u1d45b u1d439 u1d43b u1d44a u1d439 u1d43b u1d44a uniontext.
u1d453 u1d45a u1d45c u1d462 u1d461 31end 32return u1d439 u1d43b u1d44a 33end mutatetheinputlocally.thetargetfunctiondirectlyaccessesthe newinputfromlocalmemory.inthisprocessofinputmutationand targetexecution hfuzzincorporatedfourfpgaleveloptimizations forperformanceefficiency.asshowninalgorithm 1atlines10 inputsthatadvanceeithersoftwareorhardwarefeedbackaresaved totheinputqueueas u1d454 u1d45c u1d45c u1d451 u1d456 u1d45b u1d45d u1d462 u1d461forthenextfuzzingiteration.if anewinputgeneratedbygenerator u1d43aresultsinnewfeedback u1d43a willbeconsideredafavoredgeneratoranditsactivationprobability willbe increasedwith u1d43c u1d441 u1d436 u1d445 u1d438 u1d434 u1d446 u1d438 u1d443 u1d445 u1d442 u1d435 u1d446 u1d43a at line11.
.
injecting hwprobesin addition to sw monitors hfuzz for the first time directly introduces application specific observability to hardware kernels by inserting hardware probes.
it leverages these kernel probes in tandem with software level monitorstoformeffectivefeedbacksignalstostretchheterogeneous applicationbehavior.
1104leveraginghardware probesandoptimizations foraccelerating fuzz testingof heterogeneousapplications esec fse december3 san francisco ca usa table mutationsaccelerated by hardware.
average category description sw mutations in kernelmutations speedup m1sparsity replace non zeroswith zerosfrom for i in s..e do pragma unroll .
mutation index u1d460to u1d452 or do theopposite vector for i in s..e vector m2copy replace eachelementfrom index u1d460to u1d452for i in s..e do pragma unroll .
mutation with elementat u1d460 vector vector for i in s..e vector vector m3addition addconstant u1d44eto eachelement for i in s..e do pragma unroll .
mutation from index u1d460to u1d452 vector a for i in s..e vector a m4bit mutatean elementwith binary xor for i in s..e do pragma unroll .
mutation given a constant u1d465 vector x for i in s..e vector x first kernel... 2h.parallel for range m p autoindex 3intsum pragma unroll factor 5for inti i num element i sum a b if min sum sum min sum sum if max sum sum max sum sum 9boolflag ktokpipe write sum flag 11ktokpipesize pipe usage probe 12devicetohostktokpipe write ktokpipesize 13devicetohostmax sum write max sum sum s value range probe 14devicetohostmin sum write min sum second kernel... 16h.single task 17for size t i i number element i out ktokpipe read 19ktokpipesize pipe usage probe 20devicetohostktokpipe write ktokpipesize out reciprocaltransform output 22for inti i number element i sw monitor for kernel output 23outmin min outmin output 24outmax max outmax output figure matrix transform inserted value range probes are in the green rectangle.
insertedpipe usage probes are in theredrectangles.insertedswmonitorsareintheorange rectangle.
hardwareprobes.
whileosvirtualizationcouldprovidetheappearanceofunboundedresourcesforthecodeexecutedontraditional cpus kernel functions are physically mapped to resourcelimitedheterogeneousarchitectures.thisdistinctionleadstounique failuresthatareofteninducedby resourcelimitations onthedeviceside whicharenoteasilydetectablewhenrunningsoftwaresimulators.
for example in figure a local variable sqrcustomizes regularintegersto8 bitintegersforresourceefficiency.overflow conditions can occur if the variable s value exceeds its customized bitwidth.asanotherexample pipesaturationbetweentwoconsecutivekernelfunctionscanleadtoreadandwritefailures.infact such incorrect intermediate computationstates withinhardwarekernels havebeenidentifiedastheprimaryreasonforhardware originated bugs.hfuzztakes advantage of this observation identifies local variableswithinkernelsthatholdintermediatestates andinjects hardware probes to expose potentialfailures inkernel.
hfuzzautomatestheprocessofhardwareprobeinsertionthrough source tosource transformation creating an instrumented kernel.
from such instrumented kernel intermediate states in the hw device are sent directlyto thehost codeusing dedicated host kernelcommunication channels.
the channels are implemented as global fifobuffersandcanbeaccessedfromboththehostandthekernel.
the kernel side writes hardware feedback into the channels while thehostsidereadsinformationfromthechannels.bothreadand writeoperations are non blocking in orderto minimize any additionaloverheadtotheoriginalkernellogic.toexposeintermediate computationstates hfuzzidentifiesin kernellocalvariablesand pipe usage via a c c ast analysis .
as shown in figure in kernel variable sumis highlighted in green and pipe usage is highlightedinred.withafocusonin kernellocalvariableandpipe monitoring hfuzzaimstouncoverthetwomostcommonlyseen errorsincustomhardwareaccelerators overflowsresultingfrom theresourceandbitwidthfinitization aswellasread writefailures causedbycommunicationpipe saturations.
value range probe hfuzzcreates a value range monitor that checks the maximum and minimum value for each in kernel variable.
in figure hfuzzinserts probes on the intermediate variablesumwhichsaves the cumulative sum of the product a b .theseprobesmonitortheminimum and maximum value of sum.hfuzzalso constructs channels devicetohostmax sum anddevicetohostmin sum tosendthesecapturedvaluesback to the hostat line13 .
pipeusageprobe hfuzzcreatesapipeusagemonitorforeachcommunicationpipe.considerthesameexampleinfigure .hfuzz usesanastanalysistool toidentifythelocationsoftwokernelfunctions matrix multiply atline1 14and transformer line .
we identify the variable name ktokpipe used for pipe based data transfer between the two kernels.
by using ktokpipe write andktokpipe read the first kernel writesitsresult sumatline10andthesecondkernelreadsthe valuefrom thispipeatline 18in figure .hfuzzapplies source tosourcetransformationtoinjectacounter basedusagemonitor for this pipe and update the counter ktokpipesize at line and line in figure .
thenhfuzzsends this counter value tothehostbycreatinganotherdirectcommunicationchannel calleddevicetohostktokpipe at line12 andline20.
software monitors.
in addition to in kernel probes hfuzzinserts asetofsoftwaremonitorsonthehostside specializedtothecustomfpgaacceleratorsynthesizedonthedevice.wemonitor the number of loop iterations because it is related to pipelining andloopunrolling commonoptimizationsforparallelizationimplementation on fpga the value range of each kernel input and output the kernel execution time as hang or unexpectedly slow execution could be an indicator of failures.
hfuzzretrieves the time and loop unrolling information from the hls compilation 1105esec fse december3 san francisco ca usa jiyuan wang qian zhang hongbo rong guoqing harry xu andmiryungkim report generated by dpc .
besides to monitor the value range of eachkernel input and output hfuzzinserts avalue range monitor before andafter eachkernel as showninlines22 24offigure .
.
offloadinginput mutations to kernels the traditional fuzzingprocess involvesrepeatedly mutating seed inputsandfeedingthemintoatargetprogram.theimplicitassumption underlying such mutations is that seed inputs can be mutated and sent to the targetprogram fast.
unfortunately this assumption doesnotholdtrueforheterogeneousapplications.inputstoheterogeneousapplicationsareoftenlargematrices leadingtosignificant data transfer overheads between cpu and fpga.
we observe that localdatatransfer datatransferwithinfpgas consumeslessthan ofthetimerequiredfordatatransferbetweenthefuzzerand thekernel.additionally intheprocessoffuzzing avarietyof independent mutationoperationsarefrequentlyemployedonsmall segments of the same seeds with the aim of exploring the input space.
thus we can avoid repetitive data transfer by offloading the seed inputs to hardware kernels and mutating them directly within fpgas.
toachieve this hfuzzcreates adedicatedkernel for mutations in parallel to the original kernel as well as a segment of on chipmemoryforthestorageofseedsandnewlygeneratedinputs.themutationkernelandtheoriginalkernelfunctionareboth synthesizedtothefpgahardwareconcurrently.table 1showsfour supported mutation operators.
because mutation operators are all order independent anddeterministic hfuzzmodifiesallelements in the seed input at once.
a resulting input can be re generated given the seedandaconcrete instanceofmutation.
considerfigure 3asanexample.thefirstkernelcodecomputes thematrixproductwith twoinputmatrices.weshowhow hfuzz tracksthefeedbackandmutatestheinputstepbystepintable .
with the initial seed input offloaded to the kernel hfuzztracks hardwarefeedbackfromthein kernelvariable sumatline2bythe inserted in kernel probes in the green rectangle column hardware probesintable2 .afterweapplythe m3additionmutation with loop unrolling optimization from the starting offset s 1to the endingoffset e 4onarraya agreyboxfuzzerthatonlymonitors the value range for the kernel interface variables aandbwould discard the input because it does not achieve a newvaluespectraat thesoftware level.however hfuzzsavesthe corresponding mutation information since this input registers a newfeedbackat the hardware level for the in kernel variable sum.
.
fpga optimizations forfuzzing traditional fuzz testing can be na vely applied to heterogeneous applications by treating hardware kernel invocations as equivalent to software function calls.
however such straightforward application of software style fuzzing results in severe performance inefficiencies.
in heterogeneous applications there is a distinct opportunity toutilizehardwaremicro architectureleveloptimizations to accelerate the traditional fuzzing process.
both iterative matrix mutations and target executions involve independent tasks enabling task level parallelism.
hfuzzapplies four fpga optimizations to accelerate iterative matrix mutations and target execution including loop unrolling shannonization local memory access and dynamic kernel sharing.1for inti s i e i 2if a a generate number seed a original mutation 1intlocal a pragma unroll factor 3for inti i e s i local a a 4intt generate number seed 5for inti i e s i 6if local a 7local a t 8t generate number seed pragma unroll factor 10for inti i e s i a local a b optimizedmutation inkernel figure4 sparsitymutation replacethezeroelementstononzeroelements fromindex sto index e. these optimizations are not specific to hfuzzor intel s heterogeneousarchitecture andthusalsoareapplicabletootherapplications on other fpgas.
for instance loop unrolling is a technique that canbeusedtooptimizeiterativecomputationsthatdonothavesignificantdatadependenciesbetweeniterations anditcanbeapplied independently ofthe specific fpga platform.
.
dynamic kernel sharing.
in traditional fuzzing the difficulty oftestingoftenarisesfromtheneedtoexploredeepbrancheswithin theprogram.however whentestingheterogeneousapplications errors tend to occur due to variations in the range of values for in kernel variables and resource usage.
this presentsa significant challenge of rapid input space exploration especially when inputs are large matrices.
weproposeadynamic probabilistickernel sharingmethodto interleavetheexplorationofinputsearchspaceoriginatingfrom multiple seeds in heterogeneous applications.
to implement this method hfuzzemploys fourinput generatorsthatshare thesame target kernel and each has its own seed queue.
these input generators start with different seed inputs and during each iteration one generatorischosenbasedonanactivationprobabilityarray.the selected generator then picks a seed input from its queue mutates it within the kernel and sends the generated input to the target kernelfunctionviaon chipmemoryonthedevice.ifthegenerated input results in new feedback it is saved in the generator s seed queuefor use infuture fuzzingiterations.
hfuzzutilizesanadaptiveapproachtoinputgenerationbyselecting an input generator and its associated seed queue based onanactivationprobabilityarray.theselectionprocessinvolves evaluating the performance of each generator and adjusting its probabilities accordingly.
for instance if a new input generated by generator u1d43aresultsinnewfeedback itwillbeconsideredafavored generator and its activation probability will be increased.
otherwise itwillbelabeledasaninactivegeneratoranditsactivation probability will be decreased.
this approach allows for efficient input space exploration and ensures that the test generation is 1106leveraginghardware probesandoptimizations foraccelerating fuzz testingof heterogeneousapplications esec fse december3 san francisco ca usa table example execution ofinput generator u1d43a.
mutation kernel hardwareprobes softwaremonitors new value over save memorization id operator inputs variable min max min max range flow input hwrange swrange u1d443 u1d43a seed n a sum n a no n a .
a a n a b b n a 1m3 sum yes noyes .
starts 1a a no ende 4b b no 2m2 sum no no no .
starts 1a a no ende 4b b no 3m3 sum no yes yes .
starts 1a a no ende 4b b no focusedonareas that are likely to yieldnewfeedback u1d443 u1d43a u1d443 u1d43a u1d6fcif u1d43ais chosenand hfuzz gets newfeedback u1d443 u1d43a u1d6fc u1d459 1if u1d43ais notchosenand hfuzz gets newfeedback u1d443 u1d43a u1d6fcif u1d43ais chosenand hfuzz gets no newfeedback u1d443 u1d43a u1d6fc u1d459 1if u1d43ais notchosenand hfuzz gets no newfeedback inourexperiment wesetthenumberofgenerators u1d459tobe4.the initialactivationprobabilityforeachgenerator u1d443 u1d43aissetto1 u1d459 .
.
theupdate factor u1d6fcis predefined as .
.
in table inthe second execution id inputs generated by generator u1d43aincreased the hardwaremonitorrange.asaresult hfuzzincreasestheactivation probability of u1d43afrom .25to .
u1d6fc .
.
.
data preloading .matrix mutation on large matrices requiresasignificantamountofdatareadandwriteoperations.to improveefficiency itiscrucialtominimizememoryaccesstimefor inputvectorsormatrices.manyheterogeneouscomputingsystems suchasinteloneapi haveboth globalmemory thatcanbeaccessed by both kernel and host code and on chip local memory that is only accessible by kernel code.
accessing local memory within the kerneltypicallyhasashorterlatencythanaccessingglobalmemory.
wethusapplydatapreloadingtotransferdatafromglobalmemory to local memory.
in figure 4b hfuzzreduces memory access costs highlightedin red bytransferringdatafromarray atothelocalarray local a. thisresultsinareductionofmemoryaccesscostasseenatlines67 in the optimized code compared to the original code in figure 4a atline2.thisoptimizationleadstoa1.31xspeedupinthemutation process.
.shannonization .sparsitymutationreplaceszeroelements with non zero elements.
it necessitates the implementation of a null check for each element in the matrix.
as shown in line of figure4a anifstatementisaddedtoaccomplishthis.however this ifstatement induces extra hardware overhead as it increases the delayinthecriticalpath.eachtimethe ifconditionissatisfied i.e.
a theoperation generate number needstobecomputed whichcan slowdownthe overallperformance.
shannonization improves performance by precomputing operationswithinaloopandremovingthemfromthecriticalpath.inthisexample hfuzzappliesshannonization highlightedingreeninfigure4b byprecomputingtheoperation generate number atline andremovingitfromthecriticalpathinsidethebranchatline6.
thenhfuzzprecomputesthe next value of t generate number at line for a later iteration of the loop to use when required thatis thenexttime local a .thisprecomputationcan bedonesimultaneouslywithintheloop allowingforareductionin thecriticalpathdelayandleadingtoa1.24xspeedupinthesparsity mutation process.
.loopunrolling .software stylemutationsonlargevectors andmatricesareoftenperformedbymodifyingoneorsomeparticularelements.line2infigure 4ashowsanexamplemutationbased onaforloop.suchdirectapplicationofloopsonhardwareneglects thepotentialforhardwareparallelism resultingininefficientuse ofhardware resources.
loopunrollingimprovesperformancebycreatingmultiplecopies of the loop body thus the required number of iterations is reduced.
in the example shown in figure 4b the pragma unroll directive highlighted in orange causes the kernel to unroll the loop by a factorof4 asspecifiedbythe factor argument.thecompiler thenexpandsthepipelinebyquadruplingthenumberofoperations and loading three times more data.
this results in a 4x speedup of the loopprocess.
evaluation we evaluate the following research questions rq1how much improvement in defect detection capability is achieved by incorporating both device side feedback and host sidefeedbackin hfuzz?
rq2how much speed up is achieved by in kernel input mutations?
rq3howmuchspeed upisachievedbyfpga leveloptimizations for fuzzing?
rq4howmuchoverheadisincurredbyinjectinghardwareprobes inhfuzz?
toassesstheimprovementindefectdetectionandfuzzingacceleration we compare hfuzzagainst fourbaselines.
alternative afl like this option uses branch coverage guidedfuzzingsimilartoaflandperformsinputmutations oncpuside.
1107esec fse december3 san francisco ca usa jiyuan wang qian zhang hongbo rong guoqing harry xu andmiryungkim time min r1 time min r2 time min r3 time min r4 time min r5 time min r6 heterofuzz nokernelmutation afl like nohwoptimization hfuzz0 time min r7 figure numberofdefects alternative heterofuzz this option is a replication of the state of art work heterofuzz for intel dpc .
comparedto hfuzz itdoesnothavein kernelprobesonfpga devices andconsidersonly software monitoringfeedback.
alternative nokernelmutation this option disables inkernel mutations and performs input mutations on the cpu.
alternative nohwoptimization this option disables hardware optimizations andonly uses one inputqueueinstead.
benchmarks.
we choose sevenapplicationsfrom intel soneapi github repositories r1 matrix transform.
it has two kernels one for matrix multiplication m a b and the other for reciprocal transformation on each element of m r2 matrix mul multiplicationoftwomatrices r3 complex mul multiplicationof two vectorsof complex numbers in parallel r4 apsp the floydwarshallalgorithmtofindtheshortestpathbetweenthepairsof vertices in a graph r5 nbody sim simulation of a dynamical system of particles under the influence of gravity r6 hiddenmarkov model a statistical model using a markov process r7 match num readingdatafromthehostandsendingthenumbers that matchasetofpre definedconstants back to the host.
these benchmarks are widely used in hardware acceleration literature and cover a representative set of optimizations used inkernels e.g.
custombitwidth loopunrolling etc.
andexhibit differentmemoryusagepatterns e.g.
buffermemoryandunified shared memory for kernel input and output kernel to kernel pipe and kernel to host pipe local memory for in kernel variables etc.
.
testingdifficultiesforheterogeneousapplicationsdonotdepend on the code size rather it depends on how hardware resources are synthesized e.g.
in kernel variables loop unrolling and the communicationchanneldetailsbetweensoftwareandhardwareand betweenhardwarekernels.thesebenchmarks kernels are widely used and their code size is similar to commercial hls benchmarks.
theyarecomplexinbothoptimizationsandmemoryarrangements andhardto getright.
experimental environment.
all experiments were conducted on intel devcloud a10 nodes .
the automated kernel probe insertionwasimplementedusingdpc compilerandpycparser .
the refactored programs were synthesized to rtl and targeted to intel arria gx fpga .
we also tried hfuzzon other fpgas like intel stratix socfpga andachievedsimilar results.table example symptoms ofkerneldefectsinr1.
id symptom description heterofuzz find s1 kernel the value of intermediate runtime variables sumat line2of overflow figure 3exceedsits bitwidth capacity leading to awrong result.
s2 pipe pipewrite failurehappens write whenfpga attempts to write failure into apipewhenthepipeisfull.
s3 pipe pipereadhanghappens read whenfpga attempts to read hang synchronouslyfrom anemptypipe.
s4 division suminline5of figure by zero equals leading to divide by zeroat line21.
s5 incorrect cpuand fpga produce different loop resultswhentheinput array size unrolling num element isnot multiple of .
.
defect detectionby hwandswfeedback we assess theeffectivenessof hfuzz sfeedback guidancebycomparingthenumberofdefectsdetectedthroughcombinedhardware probesandsoftwaremonitorstothatof heterofuzz whichrelies solelyonsoftwaremonitors.foreachbenchmark we generatetest inputs using hfuzzandheterofuzz for hours.
we tried longer time hours but no more defect is found after hours.
using the generated inputs we then perform differential testing between cpu only executions and cpu fpga executions and measure the number ofdefects i.e.
divergingoutcomes found.
figure5shows the averageexperimentalresults fromtenruns.
hfuzzis able to detect .
more defects than heterofuzz .
for example forr5nbody simulation withoutmonitoringin kernel variablesqr heterofuzz cannotfindthedivide by zeroerrorwe mentioned in section .2at lines in figure .
when using heterofuzz the value range of kernel inputs does not reflect the change in the square of distance between particles sqr.hfuzz instead directlymonitorsthevaluerangeofin kernelvariable sqr and finds the defects when sqrreaches its minimum value .
in total heterofuzz finds unique defects in .
hours while hfuzz finds the same defects in .
hours almost reduction in the testingtime.
table3listsfivedefectsfoundby hfuzzinr1matrix transform .
first s1showsanoverflowoccurredinthefpgaexecutiondue to the in kernel variable sumat line in figure .
it happens when 1108leveraginghardware probesandoptimizations foraccelerating fuzz testingof heterogeneousapplications esec fse december3 san francisco ca usa r1 r2 r3 r4 r5 r6 r7104105inputtrialshfuzz nokernelmutation figure numberofinput trials the input vector aincludes a large number such as .
by monitoringin kernelvariable sum svaluerange hfuzzincreases the chance ofgeneratinganewvector withlarge numbers.
second two kernels in r1 use a byte pipe to facilitate direct data transfer.
as mentioned in section when the first kernel producesresultsfasterthanthesecondkernelcanconsume thepipe maybecomesaturated.consequently apipewritefailureoccurs silently and the newly written value is lost shown as s2in table3.
this may further lead to another defect s3 pipe read hang.
the second kernelin figure 3reads values fromthe pipe for number elements times.
however if the number of values successfully writtentothepipeislessthan number elements thesecondkernel willhangatthispiperead.bothdefectscannotbedetectedbyprior workheterofuzz becausehost sidesoftwaremonitorscannotdetect the saturationofcommutation pipes.
third s4depicts a divide by zero error caused by the intermediate result sumin the second kernel reciprocaltransform at line21infigure .ithappenswhenbothtwoinputmatricesare sparse matrices.
oncpu thisexecution mayraiseadivision byzero exception however it silently returns an unexpected number on fpga instead.
by monitoring sum s value range hfuzztriggers this defectbygeneratinginputsusing sparsitymutation .
fourth since r1 makes two copies of the loop body at line in figure 3by using pragma unroll factor a wrong result happens if the number of loop iterations num elements is not a multiple ofthe unroll factor .
hfuzzachieves .
speed up and finds new defects comparedto heterofuzz demonstratingthecombinedbenefit ofhardware probes andsoftware monitors.
.
speed upfrom in kernelinput mutations to assess speed up enabled by offloading input mutations to fpga devices wecompare hfuzzwithadowngradedversion nokernelmutation .wemeasurethenumberofgeneratedinputsanddefects foundwithin the same hourbudget.
figure6reportstheaveragenumberofinputtrialswithin4hours.
for example in r7 nokernelmutation generates inputs whilehfuzzgenerates100918inputs .
speed up byavoiding redundant data transfer and parallelizing input mutations.
in r2 nokernelmutation andhfuzzenumerate and inputs respectively leading to .
speed up.
r2 achieves higher speedup thanr7becauseitsperformanceismoredominatedbydatatransfer as showninfigure .
figure5shows the number of defects found by nokernelmutation.whilenokernelmutation reports14uniquedefectsin24hours hfuzzdetectsthesamedefectsin5.1hours whichtranslates to4.
speed upindefectdetection.thesedefectsarenotfoundby nokernelmutation becauseitwastestimeinsequentiallymutating inputsincpuandsendingthe large data to the kernel.
hfuzzreduces the need for data transfer by offloading mutationsintokernelsandthusspeedsupfuzzingby4.
.
.
speed upfrom fpga level optimizations to evaluate the effectiveness of fpga level optimizations for input generation we created a downgraded version of our tool nohwoptimization whichdisablesthisfeature.weevaluatedthetimetaken tofindthesamedefects.theresultsareshowninfigure .compared to nohwoptimization hfuzzfinds the same bugs .4x faster taking only .
hours as opposedto hours.
in r1 e.g.
figure the detected defects include a divideby zeroerrorwhenthekerneltakesasinputtwosparsematrices and anoverflowerrorwhenthekerneltakesasinputtwodense matriceswithlargeelements.becauseinputsleadingtothesedefects are distinct from each other traditional mutational fuzzers with a single input queue may be inefficient to find them.
in fact it takes2hourstomutatetwosparsematricesintodenseones.
hfuzz usesone hardwareoptimizationtechnique calleddynamickernel sharing to enable simultaneous exploration of input subspaces originatingfromdifferentseeds.forthat hfuzzutilizesmultiple inputgenerators.onegenerator u1d434starts withdense matrices and anothergenerator u1d435startswithsparsematrices.
hfuzzcandetect these two bugs by interleaving generator u1d434and generator u1d435based onruntimefeedback.forexample whengenerator u1d434reachesits maximum value and triggers an overflow it can no longer provide any new feedback.
hfuzzwill switch to generator u1d435and detect the divided by zeroerror.
hfuzzreduces the detection time to 5mins.
hfuzzachieves3.
speed upinthedetectionofdetects by implementing hardware optimizations.
loop unrolling shannaization andfastmemoryaccessdirectlyspeedup the mutation process.
dynamic kernel sharing enables efficient inputspaceexploration.
.
probeoverhead insertinghardwareprobesintotheoriginalkernelsmaycauseextra overheadonhardwareresources asreportedintable .wemeasure four types of hardware resource including alut a lookup table implementing the boolean function ff flip flops for storing temporarydata ram randomaccessmemoryblocks anddsp a digital signal processing unit for common fixed point and floatingpointarithmetic .theinsertedkernelprobesincurarelativelylarge overhead for a simple kernel because the inserted probes significantlyincreasekernellogiccomplexitycomparedtotheoriginal kernel.inr2 comparedtotheoriginalkernelwith9592alutsand 14466ffs insertedprobesused22 morealutsand33 moreffs.
forarelativelycomplexkernelr4 theoverheadis6 alutand ffs.theextraresourceusagemainlycomesfrom theprobe computationincludingread andwrite and thekerneldispatch logic establishes the communicationbetween kernel andhost.
1109esec fse december3 san francisco ca usa jiyuan wang qian zhang hongbo rong guoqing harry xu andmiryungkim table resource overhead from injecting hardware probes.
id program lut ff ram dsp freq mhz r1 orig .
matrix trans probe .
r2 orig matrix mul probe r3 orig complex mul probe r4 orig apsp probe r5 orig nbody sim probe r6 orig hmm probe r7 orig match num probe suchoverheadcouldbefurtherreducedbymanualoptimizations.
forexample curreri performsresourcesharingbyusing the same fifo probe for multiple feedbacksignals.
hardwareprobeinsertionuses24 extralut extra ff and extra ram and reduces frequency by on average.
however it enables an overall .
speed up in defectdetection byprovidinghardware feedback.
threats to validity we discuss the threatsto validity as follows.
devicedependence.
ourexperimentsrunallkernelexecutions on two prominent fpga cards s10 and a10 which are among the most widely used fpgas currently.
this specific configuration may constrain the applicability of our results to other devices suchasintel saltera becausethedivergencesymptoms detected could differ across different platforms.
while the absolute values of execution time and symptoms depend on configurations we believe that hfuzzwill preserve its overall advantages in terms of acceleration and divergence detection capability when extended to variousplatforms.
time limit.
we empirically set four hours as the time limit for fuzzing.longerexecutiontimemayexposemoredivergenceerrors or more execution paths as suggested in however this time limitis reasonable aswedid notseeanyincreaseinnewtypesof divergenceerrorswithahigher time limit for subjectsr1 r7.
scalability.
theinsertionofourprobesreliesonthestaticanalysis ofheterogeneousprogramsandoftennecessitateshumanintervention to address potential transformation errors.
this process can becomechallenging particularlyforcomplexin kernellogicwithin large programs.
further experimentation is essential to validate the scalability of our method.
however our benchmarks may look smallinsizefromthesoftwareengineeringperspective butthey aresizableinthehardwarecommunity.rossetabenchmarks andheterogeneousapplicationsininteldevcloud arecomparable insize i.e.
hundredsoflinesofcode.
testingcomplexityforheterogeneous applications do not depend on the lines of code size.
instead theydependonfactorssuchashowhardwareresources are synthesized e.g.
in kernel variables loop unrolling as wellas the nuanced details of the communication channels between software andhardware as well as among hardware kernels.
related work fuzz testing.
traditional fuzzing starts from a seed input runs the program on the selected input generates new inputs by mutating the previous input and adds new inputs to the queue if they improve a given guidance metric such as branch coverage.
instead of using coverage as guidance several techniques use custom guidancemechanisms.uafl incorporatestypestatepropertiesand informationflowanalysistodetecttheuse after freevulnerabilities.bigfuzz monitorsdataflowoperatorcoverage intandem with branch coverage for dataflow based analytics.
for example memlock employsbothcoverage and memoryconsumption metrics.
aflgo extends afl to direct fuzzing towards userspecified target sites.
silifuzz finds cpu defects by fuzzing softwareproxies likecpusimulatorsordisassemblers andthen executingtheaccumulatedtestinputs knownasthecorpus onactual cpus on a large scale.
perffuzz uses the execution counts of exercised instructions together with branch coverage to identify inputs revealing pathological performance.
heterofuzz generates concrete test inputs for heterogeneous applications to performdifferentialtestingbetweencpuvs.cpu fpga.unlike hfuzz heterofuzztreatsthekernelsasblackboxesandperforms software levelmonitoringonly.allthesetechniquesrelyonpure software levelfeedbackeitheratthelevelofcodecoverageorusing custom monitors.
none leverages hardware probes in tandem with software monitors to guide test inputgeneration like hfuzz.
afuzzingloopconsistsofmultipleinvocationsofatargetprogram with different inputs in an independent manner thus it provides a natural opportunity for parallelism.
afl injects a fork server which tells the target to fork itself to run and thus realizes parallel fuzzing across multiple cpu cores or across a fleet of systems.
for example p fuzz distributes unique seeds to runfuzzinginparallel andpafl maintainsglobalandlocal guiding information for synchronizing parallel fuzzing jobs.
these techniquesacceleratefuzztestingviadistributedcomputationon cpu unlike hfuzz noneacceleratesfuzzingbyusingfpgas.
hfuzz pushes iterative input mutation directly to an fpga kernel and benefitsfromthemassivehardwareparallelismintrinsictofpga duringiterative testingof heterogeneous applications.
coverage guided greybox fuzzing adds test cases into the set ofseedsiftheyexercisethenewpathornewbehavior.however mostseedsexercisethesame high frequency paths.toexplore more paths with the same number of tests researchers develop strategiestoselectseedswisely.aflfast modelscoverage based greybox fuzzing as a markov chain and assigns different selection probabilitiesfordifferentseeds.ecofuzz improvesaflfast s markov chain model and presents a variant of the adversarial multi armedbanditmodel.ecofuzzsetsthreestatesoftheseeds set and develops a unique adaptive scheduling algorithm.
while these techniques select seedsbasedon probabilities none of them leveragesfpga leveloptimizationstospeedupseedselectionwith dynamic kernel sharing.
1110leveraginghardware probesandoptimizations foraccelerating fuzz testingof heterogeneousapplications esec fse december3 san francisco ca usa high level synthesis in circuit debugging.
to ease the development of heterogeneous applications hls tools automatically generate rtl descriptions from c c programs.
to help debugginghls generated circuits inspect introducessoftware debugger likecapabilities includinggdb likebreakpoints step and data inspection.
it tracks file names and line numbers in hls code sothathwprobesatthelevelofwiresandregisterscouldbelinked to specific lines in the hls code.
a user can monitor each variable for its data width and the number of elements in an array.
monson and hutchings design a debugger for hls generated fpgabasedcircuitsviasourceinstrumentationbyconnecting c expressionstotop levelportsthatserveasdebugsignals.hlscope isaperformancedebuggerthattracesthecauseofstallsforhlsgenerated circuits.
curreri et al.
realize in circuit assertions for timinganalysisandstall relatebugs .whilethesedebuggers andhfuzzleverageasimilarmechanismofinjectinghwprobes hfuzz sgoal is different itimproves theeffectiveness of grey box fuzzing for heterogeneous applications by designing meaningful monitors at both software andhardware levels.
inthehardwaredesigncommunity circuitverification including formal verification and runtime verification has been used to validate code written in hardware description languages verilog vhdl etc.
.for example rfuzz isacircuit level input generatorforfirrtlir ucberkeley srtlvariant .rfuzzinvents a notion of mux toggle coverage for circuit testing at the gate level and employs a rapid memory resetting on fpga for rtl circuit verification.
however their monitors are gate level and not application specific.
qin and mishra present a scalable test generation technique for hardware kernels in verilog by interleaving concrete and symbolic execution to bridge the gap between model checking and testing.
kourfali and stroobandt exploit parameterizationoflutsandroutinginfrastructuresinanfpgatocreate avirtualdebuggingoverlaynetworkinsidecircuits.thesecircuit testingandverificationtechniquesfindbugsinkernelsatrtllevel whilehfuzztargetsend to end testing of heterogeneous applications writteninhls .inotherwords itisnotfeasibletodirectlycompare hfuzzagainst thesein circuitverification techniques.
fpgaperformanceoptimizations.
maetal.exploredvarious loop optimization techniques such as loop tiling loop interchange and loop unrolling to reduce memory consumption and data movementwhenmappingdeepconvolutionalneuralnetworks to fpga.
zhang et al.
adopt data buffering techniques to hide the memoryaccesslatencyandinterconnects avoidingdatatransfer overhead from the global memory to fpgas on chip memory .
li et al.
use pipeline optimizations when mapping layer bylayer computation to multiple fpgas resources.
pipelining can increase hardware utilization and achieve high throughput by preventingthecomputingenginestobecomeidleduetoimbalanced computation speed across layers.
other widely used kernel optimizations include i o optimization by sharing resources among computationtasksat differenttimestamps.another optimization isretiming which moves edge triggered registers across combinatorial gates or luts to improve timing while ensuring identical behavior etc .inspiredbythesefpga levelperformanceoptimizations hfuzzdesignsfouruniquefpga leveloptimizations to accelerate the combined computation of input generation and kernelinvocation dynamickernelsharing shannonization loopunrolling anddata buffering.
hfuzzis apioneering tool thefirst to embody fpga level optimizations to enhance fuzzing efficiency andeffectiveness for heterogeneous applications.
snap leveragestheexistingcpupipelineandhardwarefeatures tooptimizethebitmap updaterequiredfor coverage guided testing.
as opposed to snap that targets fuzzing traditional programsrunningonacpuandsimplyusesexistinghardwarefeatures asablackboxaccelerationaid hfuzzhfuzz designsnewfpga level optimizations for mapping input generation and kernel invocation tofpgas and empirically demonstrates significantfuzzing speedupfrom theseoptimizations .
.
data availability per the open science policy we make hfuzz s artifacts benchmark programs and datasets available at .
conclusion in recent years performance improvement in cpu has slowed significantlytoonlyafewpercent duetochallengesinpowersupply scaling heatdissipation spaceandcost.thistrendnecessitatesthe needstoembraceheterogeneouscomputerarchitecturessuchas gpuandfpga.inparticular fpgaisapromising reprogrammable alternative for improving performance and energy efficiency.
however due to the lack of observability into fpga execution and complex interactionbetween cpuandkernel execution onfpga developing and testing heterogeneous applications is extremely inaccessibleto regularsoftware engineers.
hfuzzisthefirstgrey boxtestingapproachleveragesthe capability of heterogeneous hardware for testing heterogeneous applications .
inparticular hfuzzinjectshardwareprobesinadditiontoinjecting software monitors to better guide input generation and offloads iterativeinputgenerationtohardwareaccelerators.
hfuzzspeeds upfuzzingbyoffloadinginputmutationstofpgasby4.
without sacrificingany defect detectioncapability.
itspeeds up testing .
onaveragebygatheringmeaningfulsignalsfromhardware execution directly by injecting in kernel probes.
this work fits the domain of software testing as it targets hls c c dialects and it hasthe potentialtosignificantly improve correctnessinthe new era ofheterogeneous computing where regular software developers writecodeinhlsc c toexploitcustomhardwareacceleration.