quantitative relational modelling with qalloy pedro silva inesc tec universidade do minho braga portugal pedro.d.silva inesctec.ptjos n. oliveira inesc tec universidade do minho braga portugal jno di.uminho.pt nuno macedo inesc tec universidade do porto porto portugal nmacedo fe.up.ptalcino cunha inesc tec universidade do minho braga portugal alcino di.uminho.pt abstract alloy is a popular language and tool for formal software design.
a key factor to this popularity is its relational logic an elegant specification language with a minimal syntax and semantics.
however many software problems nowadays involve both structural and quantitative requirements and alloy s relational logic is not well suited to reason about the latter.
this paper introduces qalloy an extension of alloy with quantitative relations that add integer quantities to associations between domain elements.
having integers internalised in relations instead of being explicit domain elements like in standard alloy allows quantitative requirements to be specified in qalloy with a similar elegance to structural requirements with the side effect of providing basic dimensional analysis support via the type system.
the qalloy analyzer also implements an smt based engine that enables quantities to be unbounded thus avoiding many problems that may arise with the current bounded integer semantics of alloy .
ccs concepts software and its engineering specification languages formal methods software system models .
keywords alloy quantitative modelling smt model finding linear algebra relational specifications acm reference format pedro silva jos n. oliveira nuno macedo and alcino cunha.
.
quantitative relational modelling with qalloy .
inproceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
introduction employing trustworthy software design techniques early in the development process is crucial to avoid critical faults in later stages.
this process often focuses on structural and architectural modelling but there is a trend towards quantitative modelling in the software sciences.
in the words of the editors of ... today there are many quantitative aspects of system design they include timing whether discrete continuous or hybrid probabilistic aspects of success or failure including cost and reward and quantified information flow.
moreover data science has emerged as a very important discipline in computing which is quantitative by definition.
while software modelling relies mainly on logics and relational algebra data analysis relies mostly on linear algebra .
the need for a linear algebra of programming has been identified as a possible way to extend standard software design techniques to such quantitative fields .
this work goes in a similar direction.
alloy is a lightweight formal specification language based on relational logic which is supported by an automatic analyzer1.
the flexibility and simplicity of the language together with the quick and intuitive feedback provided by the analyzer have led to the wide adoption of alloy in the formal validation and verification of software design models.
unfortunately while alloy s relational logic has shown to be well suited to reason about structural problems it is rather limited for reasoning about quantitative models.
some of these issues arise at the language level.
although integers in alloy are a special kind of atom they mostly act as other uninterpreted atoms in the relational formalism.
this has some unintuitive consequences due to the uniqueness of elements in sets and undermines the ability of alloy s rich type system to catch specification errors.
other issues are due to the associated analysis procedures.
the analyzer supports either wrap around semantics with a necessarily reduced precision due to the sat based backend or non standard semantics that prevent overflows which has unpredictable side effects.
while work has been developed to tackle some of these issues such as supporting multi relations or allowing an unbounded integer domain through smt based backends there is no unified and principled approach to quantitative modelling and analysis based on alloy .
1this work is based on version of alloy and still does not consider the temporal features recently introduced in alloy .esec fse november singapore singapore pedro silva jos n. oliveira nuno macedo and alcino cunha 1sig bag contains int one product 4abstract sig product stock one int weight one int 8one sig tea coffee milk extends product 9fact all b bag p product b contains p all p product p weight all p product p stock 0and p stock milk weight milk weight coffee weight coffee weight mul all p product p stock sum b bag b contains p figure sco model in alloy yet alloy offers a particularly interesting setting for such a quantitative extension amounting to extending its underlying boolean matrices to numeric ones hiding the numeric calculations under the carpet while keeping its notational elegance at a highlevel.
following on this vision this paper presents qalloy and its analyzer .qalloy is a minimal extension to the alloy language that internalizes quantities in the relations without sacrificing the simplicity flexibility and high level of abstraction of the alloy language.
qalloy allows relations to be declared as quantitative and the relational operators have been generalized to this setting.
integers are no longer elements of the universe of discourse but rather measures of relationships.
in practice this means that quantities can be associated with units of measure allowing the type checker to detect dimensional inconsistencies and forcing a disciplined use of integers when modelling.
internally this entailed moving from a formalization based on boolean matrices to one based on integer matrices and adapting the backend to be smt based rather than sat based naturally allowing unbounded quantities.
the rest of the paper is structured as follows.
section presents qalloy through a motivating example.
section presents its syntax and semantics while section presents the smt based analysis backend.
section evaluates the flexibility and performance of qalloy .
section discusses relevant related work and section wraps up the paper with conclusions and directions for future work.
motivating example alloy excels at describing and exploring structures.
one typical application is domain modelling where the goal is to describe entities and their relationships and elicit the requirements that govern them.
take for example a simple partial domain model of a supermarket self checkout sco system.
some of the relevant entities in this domain are shopping bags and the different products on sale.
several quantities of different units are also relevant the quantity of products each bag contains the current stock of products to issue alerts for stock shortages and the weight of each product to confirm that a given item was placed inside the bag .
the first and second are measured in number of items while the third is measured in ounces.
.
quantitative modelling with alloy the sco can be encoded in alloy as presented in figure .
entities can be modelled in alloy by declaring signatures which are sets of elements drawn from the universe of discourse.
an optional multiplicity can be used before the sigkeyword to restrict the cardinality of the declared signature.
signatures can also be structured in a hierarchy with disjoint sub signatures being declared with keyword extends .
the parent signature can be declared as abstract if it should not contain elements besides those in its extensions.
this is the case of signature product which has three singleton extension sub signatures each representing a different product on sale.
the most natural way to model quantities in alloy is to specify them explicitly using integers.
alloy has a pre defined intsignature that contains all the integers that can be represented with a given bit width using two s complement representation.
inside a signature it is possible to declare fields relations i.e.
sets of tuples that connect elements of the parent signature to elements of other signatures.
for each of the above quantities there is a field in the model that relates the relevant signatures to exactly one int fields weight andstock are binary relations that associate each product with the respective weight and stock and field contains is a ternary relation that associates each bagandproduct to the number of items of that product the bag contains.
constraints are specified using relational logic an extension of first order logic with relational operators.
the most used relational operator is dot join that composes two relations.
to simplify the syntax and semantics in alloy everything is a relation.
in particular signatures are unary relations sets of tuples with a single element and scalars and quantified variables are singletons.
this means that operators like dot join can be used not only to compose two fields but also variables and signatures with fields.
for example if pis a product and ba bag b contains pis the number of items of product pinside bag b. in our model a fact contains the various assumptions in our domain.
the first three constraints lines force quantities to be non negative weights to be positive and impose an upper limit on the current stock of products.
the next three constraints lines impose rather loose restrictions on the weight of the three different products.
the final constraint lines restricts the total quantity of a product in all bags to be less or equal than its current stock.
one of the drawbacks of using integers in alloy is that simple constraints such as these are not trivial to specify.
the problem is that since all expressions denote sets repeated quantities are not properly accounted when using composition.
for example expression bag contains pcollects the quantities of p in all bags but if two bags have the same quantity of pthat integer will appear only once in the final set.
this means that to compute this value we need to use the special sumquantifier that sums all expressions ranging over a set.
still related to language support a more fundamental drawback is lack of typing for units.
alloy s type system is quite good at catching specification errors .
for example expression contains bag would raise a warning since bags cannot contain bags.
by using intto represent all kinds of quantities not taking into account thequantitative relational modelling with qalloy esec fse november singapore singapore figure bogus alloy counter example to hasmilk respective units the type system does not help in detecting silly constraints such as all p product p stock p weight .
alloy models can include runcommands to ask for an instance of the model a valid assignment to all declared signatures and fields or check commands to verify assertions which returns a counter example instance if the assertion is invalid .
for decidability the analysis performed by these commands is bounded the universe of discourse is finite and its size can be controlled by a scope imposed on signatures that defines the maximum number of elements they can contain.
an exception is the scope on int that defines the bit width of the integers created in the universe of discourse.
this means that a check command may fail to find a counter example to an invalid assertion.
but since most invalid assertions can be refuted with small counter examples the so called small scope hypothesis the bounded analysis implemented by the alloy analyzer is still useful in practice to achieve a high level of confidence.
moreover the analyzer allows the user to iterate over the instances returned by these commands to see alternative scenarios or counter examples and also depicts them as graphs for easier comprehension2.
these features make runcommands extremely useful since they allow the user to easily explore design alternatives and discover missing requirements.
consider for example the following assertion that checks if bags weighting more that oz necessarily contain milk cartons inside.
assert hasmilk all b bag sum p product mul implies b contains milk this assertion is invalid the lightest counter example being a bag with three 9ozcoffee bags and two 3oztea packets with total weight 33oz.
to verify it we could have the following command that sets a scope of to all signatures and a bit width for int3.
check hasmilk for 2but 5int by executing this command we get the bogus counter example in figure where one bag contains milk cartons although there are none in stock.
the weight of coffee bags is also not three times the weight of tea packets as specified in the fact.
this points to another drawback of alloy when dealing with quantities the default semantics for integer operations is wrap around hence the above bogus counter example the other bag 2these graphs can also be customised using themes.
the instances show in this paper use custom themes to make them easier to understand.
3note that the analyzer automatically grows the scope of product to to accommodate the declared singleton extensions.in the counter example had milk cartons which added to overflows with bit width and yields a negative number .
the analyzer currently also implements a semantics that prevents overflows for integers which would need to be activated to verify this assertion.
however rerunning the command now yields no counter examples.
this time the reason is rather pedantic the specified bit width is not big enough to represent the constant so all instances overflow when evaluating the left hand side of the implication in the assertion and are discarded.
this means that the user has to be very careful when setting the scope for int at the risk of easily missing possible counter examples.
in fact even increasing the bit width to which already is enough to represent all integer constants in the model would not suffice to falsify the assertion since the lightest counter example bag has total weight that exceeds 32oz.
in this case we would need a bit width of at least .
this choice is further complicated by the complexities of theprevent overflows semantics.
one might think that the solution would be to set a rather large bit width but unfortunately that is not viable in many situations.
on the one hand it would slow down analysis considerably.
on the other hand with a bit width larger than the universe would be too large to allow the representation of ternary relations in the sat based analysis engine rendering assertion verification impossible.
.
quantitative modelling with qalloy qalloy improves the handling of integers in alloy addressing all the above drawbacks.
first instead of having an explicit int signature qalloy internalises integers in relations while alloy relations are matrices of booleans that determine which tuples belong to the relation in qalloy it is possible to declare relations that are matrices of integers which we will denote by quantitative relations where each tuple is paired with a quantity.
qalloy also generalizes integer operations to work on quantitative relations and provides a new composition operator that implements matrix multiplication allowing easier specification of constraints involving quantities.
second this internalisation of integers in quantitative relations allows them to inherit the type stated in the declaration.
this means that the standard alloy type system can now detect meaningless constraints where integers of different units of measure are compared.
finally the qalloy analyzer uses smt solvers instead of sat solvers in the analysis backend in order to support unbounded integers.
this means that the semantics of integer operations is now straightforward and the user no longer needs to worry about determining the correct bit width.
the sco can be modelled in qalloy as shown in figure .
quantitative relations are declared with keyword int.
for example contains is now a binary quantitative relation that associates each bag with the quantity of each product it contains.
to model the weight we first introduce a singleton signature ozto model the respective unit and then declare weight as a binary quantitative relation that relates each product to the quantity of ounces it weights.
it is also possible to declare quantitative subset signatures declared with keyword in likewise in alloy .
that is the case of stock a quantitative subset of product .
quantitative subsets are vectors that pair each element of the parent signature with a quantity.esec fse november singapore singapore pedro silva jos n. oliveira nuno macedo and alcino cunha 1sig bag int contains set product 4one sig oz 5abstract sig product int weight one oz 8one sig tea coffee milk extends product 9int sig stock inproduct fact contains bag product weight product oz stock product and stock product milk weight oz milk weight coffee weight coffee weight tea weight bag contains stock figure sco model in qalloy inqalloy integer operators such as comparisons or and arithmetic operations addormul have been lifted to work on quantitative relations operating entry wise in the respective matrices or vectors.
for example addimplements matrix addition and mulimplements the hadamard product.
in addition the new quantitative composition operator implements matrix multiplication.
these operators can also be used with non quantitative relations and signatures treating them as binary quantitative matrices.
integer constants can no longer be used standalone but only in the left hand side of the new scalar multiplication operator.
the reason for this is to achieve type safety.
for example to specify a quantity of 10oz one should write oz while a quantity of tea packets would be specified as tea .
a comparison such as10 oz tea yields a type error.
to specify a binary quantitative relation from bags to products with a quantity of in all possible tuples one should first compute the cartesian product bag product that attaches a quantity of to all possible pairs and than use scalar multiplication to scale up those quantities as in bag product .
the normal alloy operators such as dot join intersection or union also work with quantitative relations implementing a min max algebra inspired by multi sets which are just a special case of quantitative relations where all quantities are non negative.
if used only with non quantitative relations these have the same semantics as before meaning that alloy models that do not use integers are retro compatible with qalloy .
the first three constraints lines in figure specify that all the quantitative relations in this example are in fact multi sets with non negative quantities.
like before the weight is restricted to be strictly positive and the stock of each product is limited to items.
note that since comparisons operate entry wise in quantitative relations we do not need quantifiers to specify these properties and can adopt a more terse point free style of specification.
the next three constraints lines specify the weight restrictions of the different products.
to determine the weight of a given product we should use the quantitative composition operator while milk weight determines if milk weights something milk weight determines its actual weight.
notice that milk is a vector with a in figure qalloy counter example to hasmilk the entry corresponding to milk while weight is a matrix that only has positive quantities in the ozcolumn and the product rows.
hence their multiplication yields a vector that has a single positive quantity in the ozentry.
the last constraint line shows the advantage of the new quantitative composition enabling a very elegant specification of the requirement that the total products in all bags does not exceed the current stock.
lastly the hasmilk assertion can be specified as follows.
assert hasmilk all b bag b contains weight oz implies b contains milk to verify this assertion we could use a check hasmilk for the smt backend analysis that implements unbounded integer semantics would immediately return the counter example in figure .
if we increase the weight to oz the assertion becomes valid due to the current limits on the stock and the qalloy analyzer no longer returns any counter example.
syntax and semantics the proposed language is a minor adaptation of the alloy language.
its concrete syntax is presented in figure with additions highlighted underlined and