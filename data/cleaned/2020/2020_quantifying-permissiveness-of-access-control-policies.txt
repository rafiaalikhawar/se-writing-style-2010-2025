quantifying permissiveness of access control policies williameiers universityofcaliforniasantabarbara santabarbara ca usa weiers cs.ucsb.eduganeshsankaran universityofcaliforniasantabarbara santabarbara ca usa ganesh cs.ucsb.edualbertli universityofcaliforniasantabarbara santabarbara ca usa albert li cs.ucsb.edu emilyo mahony universityofcaliforniasantabarbara santabarbara ca usa emilyomahony cs.ucsb.edubenjaminprince universityofcaliforniasantabarbara santabarbara ca usa benjaminprince cs.ucsb.edutevfikbultan universityofcaliforniasantabarbara santabarbara ca usa bultan cs.ucsb.edu abstract duetoubiquitoususeofsoftwareservices protectingtheconfidentialityofprivateinformationstoredincomputecloudsisbecoming anincreasinglycriticalproblem.althoughaccesscontrolspecificationlanguagesandlibrariesprovidemechanismsforprotecting confidentialityofinformation withoutverificationandvalidation techniquesthatcanassistdevelopersinwritingpolicies complex policyspecificationsarelikelytohaveerrorsthatcanleadtounintendedandunauthorizedaccesstodata possiblywithdisastrous consequences.inthispaper wepresentaquantitativeanddifferential policy analysis framework that not only identifies if one policyismorepermissivethananotherpolicy butalsoquantifies therelativepermissivenessofaccesscontrolpolicies.wequantify permissivenessofpoliciesusingamodelcountingconstraintsolver.
wepresentaheuristicthattransformsconstraintsextractedfrom accesscontrolpoliciesandsignificantlyimprovesthemodelcountingperformance.wedemonstratetheeffectivenessofourapproach byapplyingittopolicieswritteninamazon sawsidentityand accessmanagement iam policylanguageandmicrosoft sazure policylanguage.
ccs concepts security and privacy logic and verification access control.
acm reference format william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan.
.
quantifying permissiveness of access controlpolicies.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm newyork ny usa 13pages.
introduction modernsoftwareservicesrunoncomputeclouds.amongthemost popularcloudserviceprovidersareamazonwebservices aws thismaterialisbasedonresearchsupportedbyanamazonresearchawardandby nsfundergrantsccf ccf ccf this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
letscustomerssecuretheirservicesbywriting accesscontrolpolicies.
accesscontrolpoliciesspecifyrulesthatallowauthorizedaccess whiledenyingunauthorizedaccesstoclouddata.policiescanbe writtenusingmanyaccesscontrolspecificationlanguages likethe awsidentityandaccessmanagement iam languageorthe extensible access control markup language xacml .
in contrast libraries such as cancan and pundit provide supportforspecificationofpoliciesattheimplementationlevel.
bythemselves theseareusefullanguagesandlibraries however withoutverificationandvalidationtechniquesthatcanassistin writingpolicies policyspecificationsarelikelytohaveerrorsthat canleadtounintendedandunauthorizedaccesstodata.infact incorrectspecificationofaccesscontrolpoliciesincloudstorage serviceshasresultedintheexposureofmillionsofcustomers datatothepublic.forexample itwasreportedthat datarecordsfor morethan2milliondowjones co.customerswereexposedduetoanaccesscontrolerror.exposeddataincludednames addresses accountinformation emailaddresses andlastfourdigitsofcredit cardnumbersofsubscribers.theexposeddatawasinapubliclyaccessibleawssimplestorageservice s3 bucket.thisisadisastrouserrorinthepolicyspecificationforcloudstoragebuckets.
asimilarerrorresulteddataexposureof50thousandaustralian employeesthatincludedfullnames passwords salaries ids phone numbers andcreditcarddata .yetanothererrorexposedthe accountrecordsof14millionverizoncustomers .avulnerabilityinmicrosoft sazurecosmosdbservice allowedpublic accesstoaccountsanddatabasesofthousandsofcustomers.
theseexampleshighlighttheurgentneedtodeveloptechniques toprotectclouddata.automaticallyfindingaccesscontrolissues wouldpreventexposureofprivatedata protectingtheprivacyof millions of people.
hence it is necessary to develop automated verificationtechniquesthatcananalyzeaccesscontrolpoliciesfor computeclouds.inordertocheckforcorrectnessofapolicy itis necessarytohaveaspecificationofcorrectnessproperties butwritingcorrectnesspropertiesmanuallycanbechallengingandtime consuming.moreover writingexpectedpropertiesofthepolicy iserror prone.hence whenaninconsistencybetweenaproperty specificationandapolicyisidentified itdoesnotnecessarilymean thatthepolicyhasanerror thepropertyspecificationitselfcould beerroneous.adifferentialpolicyanalysisapproachremovesthe needtomanuallyspecifypolicyproperties instead itcompares differentpoliciesandidentifiesinconsistenciesamongthem.basic policies can be compared to a complex policy to verify that the ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan latterdoesnothaveunintendedconsequences.forexample we maywanttoverifythatacomplexpolicyspecificationisnotmore permissivethanasimplepolicythatspecifiescommonsenseaccess rules.moreover differentialpolicyanalysistechniquescanidentify differencesbetweendifferentversionsofapolicy.whenapolicy specification is modified it would be worthwhile to know how thepermissivenessofthepolicyhaschanged.however abinary answertoaquestionthatcomparestwopoliciesmaybeinsufficient.
forexample itmaynotsufficethatweknow ifonepolicyismore permissivethananother.wemaywanttoknow howmuchmore permissiveapolicyisthananother i.e.
wemaywantto quantify therelativepermissivenessofdifferentpolicies.modelcounting constraintsolversfindthenumberofsatisfyingassignmentsfora givenconstraint withinagivenbound .they havebeenappliedtoseveralquantitativeanalysisproblemssuch asprobabilisticanalysis reliabilityanalysis andquantitativeinformationflowanalysis .
inthispaperweproposeaframeworktoquantifypermissiveness ofaccesscontrolpoliciesusingmodelcountingconstraintsolvers.
ourcontributionsincludethefollowing aformalmodelforaccesscontrolpolicies aformalizationofaccesscontrolpolicypermissiveness anautomatedapproachforquantifyingpermissivenessofaccesscontrolpoliciesbytranslatingapolicytoasmtformula andusingamodelcountingconstraintsolvertoquantifyits permissiveness anextensionoftheformalmodelandautomatedapproach toquantify relativepermissivenessbetweenpolicies aheuristicthattransformsformulasextractedfrompolicies forimprovingmodelcountingperformance an open source tool qacky that implements the automatedapproachtoanalyzepolicieswritteninawsidentity andaccessmanagement iam andazurepolicylanguages apubliclyavailablepolicydatasetconsistingofdozensof real worldpoliciesfromawsforumsandazuredocumentation aswellashundredsofpoliciessynthesizedbyapplying mutationtechniquestothereal worldpolicies anexperimentalevaluationof qackyonthedataset therestofthepaperisorganizedasfollows.insection2wefirst introduce cloud policies and motivate the need for quantitative permissivenessanalysis.insection3wepresentourformalpolicy model insection4wediscusssmt basedpolicyanalysis insection 5wediscussquantitativepermissivenessanalysis insection6we presentourconstrainttransformationheuristic insection7we discusstheimplementationofourapproachonawsandazure policies insection8wediscussourexperiments insection9we surveyrelatedwork andinsection10weconcludethepaper.
background and motivation in this section we first introduce access control policies for the popularcloudservicesamazonwebservices aws andmicrosoft azure.wethendiscussseveralexamplesmotivatingtheneedfor quantitativeanalysisofaccesscontrolpolicies.
.
access control policies for the cloud amazonwebservicespolicies.
amazonwebservices aws uses asharedresponsibilitysecuritymodelwhereawsguaranteessecurityof the cloud but users are responsible for security in the cloud.
aws lets users control who has access to their resources withaccesscontrolpolicieswrittenintheawspolicylanguage.
accessrequestsareevaluatedagainstpoliciesandadynamicenvironmentcontextwithinapolicyevaluationenginethateither allowsordeniesaccess.
awsdefinesapolicylanguagewherepolicieseitherallowor denyaccessthroughdeclarativestatements.a statementisa5 tuple principal effect action resource condition where principalspecifiesalistofusers entities orservices effect allow deny specifieswhetherthestatementallowsordeniesaccess actionspecifiesalistofactions resourcespecifiesalistofresources conditionisanoptionallistofconditionsfurtherconstraininghowaccessisallowedordenied eachconditionconsistsofaconditionoperator conditionkey and condition value on elements of the request context.
full details ofthelanguagecanbefoundin .notethatwhilemostofthe elementsofapolicyarestrings certainconditionkeysspecifyother typesofconstraints e.g.
s3 max keysexpectsanintegralnumber .
additionally theawspolicylanguageallowstheuseoftwospecial characterswithinstrings orwildcard representsanystring and ?
whichrepresentsanysinglecharacter.givenanaccessrequest andassociatedpolicy permissionisgrantedifandonlyif forthe givenprincipal action resource andconditionkeyvaluesinthe request context a statement in the policy allows access and no statementinthepolicyexplicitlydeniesaccess.
microsoft azure policies.
likeaws azureusesasharedresponsibilitysecuritymodel wheresecurity inthecloud isachievedby role based access control rbac .
azure rbac defines a policy language consisting of role definitions and role assignments.
a role definition isasetofallowedactions actions dataactions notactions notdataactions where actionsisalistofallowedmanagementactions dataactions isalistofalloweddataactions notactions actionsisalistofdeniedmanagementactions notdataactions notactions isalistofdenieddataactions.
arole assignment isatuple principalid roledefid scope condition where principalid identifiesa principalgrantedaccess roledefididentifiestheroledefinition scopeidentifiesasetof resourcesgrantedaccess conditionisanoptionalexpressionforgrantingaccess the scope is a path in azure s resource hierarchy rooted at .
resourcesrootedatthepatharegrantedaccess.unlikeinaws theazureconditionisaninfixlogicalexpression.azurehaslogical operators and relational operators on strings and integral numbers butitalsosupportscrossproductrelationaloperatorsonsets likeforanyofallvalues stringeqals.likeaws azureallows 1806quantifying permissiveness of access control policies icse may pittsburgh pa usa wildcardsinstrings exceptscope .givenanaccessrequest role definition androleassignment permissionisgrantedifandonly if boththeroledefinitionandroleassignmentexplicitlyallowthe principalandactionunderthescopeandcondition.
.
motivating examples capitalonedatabreach.
capitaloneisoneofmanycompanies whichuseamazonwebservices aws fortheircloudcomputing needs.awsprovidesanaccesscontrolmechanismforcontrolling accesstoresourcesthroughtheidentityandaccessmanagement iam policyspecificationlanguage.awsiamallowscustomersto createiamrolesandtogivepermissionstorolesbyattachingiam policiestotherole.policieswrittenintheiampolicylanguage allowawsuserstocontrolaccesstoresourcesandawsservices through fine grained permissions.
a role can then be assumed by a user or application.
recently a server run by capital one was breached by an outside attacker who was able to run user commandsunrestricted .theattackerwasthenabletolist thebuckets whichstoreresourcesasobjects ontheserverand downloadthecontentsofeachbucket.theattackitselfinvolvedtwo maincomponents.first theattackerwasabletogainauthenticated accesstoanawsiamrole .secondly therolehadbroadaccess to s3 buckets due to a misconfigured policy.
for confidentiality reasons themisconfiguredpolicyisnotpubliclyavailable.
thefollowingrepresentsasimplifiedmodelofthepermissions allowedinthecapitalonedatabreach.
effect allow action resource whenattachedtoaniamrole thepolicygrantsbroadaccesstothe s3service allowingtheroletolistandgatherdatawithins3buckets.
however iftheattachedroleiscompromisedbyamalicioususer as inthecapitalonedatabreach agreatdealofdatacanbeexposed.
alesspermissivepolicymightrestrictresourcestoasinglebucket resource orrestrictresourcestoonlytwoobjectswithinabucket resource existingpolicyanalysistechniques canverifyifapolicyis moreorlesspermissivethananotherbuttheycannotquantify the magnitude of permissiveness ineachcase.ourworkcanquantify thedifferencesinpermissivenessbetweenallthreepolicies.ifwe assumevalidresourcesarealphanumericand characters with max length of the initial policy allows the getobject actionon2 .
1036moreresourcesthanwhenaccessisrestricted toasinglebucket whichallowsactionon1 .
1020moreresources thanwhenaccessisrestrictedtotwoobjectswithinabucket.
policies in the wild.
fortheaverageuser theabovepoliciesare simple enough to manually analyze without sophisticated techniques.thisisnotalwaysthecase.policiescanbecomplex especiallytothoseunfamiliarwithaccesscontrol.awsprovidesforums whereuserscanposttheirpoliciesandgetfeedbackfromother users andawsemployees .weconsiderasetofpoliciestakenfrom theforumstoshowcasetheusefulnessofourapproach.forsimplicityweassumevaluesforfieldsinapolicycontainalphanumeric and characters.
statement effect allow action s3 getaccelerateconfiguration ... s3 listbucketmultipartuploads resource statement effect allow action s3 describejob ... s3 getaccelerateconfiguration ... s3 getobject s3 getobjectlegalhold ... s3 listbucketmultipartuploads resource statement effect allow action s3 describejob ... s3 getaccelerateconfiguration ... s3 getobjectlegalhold ... s3 listbucketmultipartuploads resource figure initial topmost a modified middle b and fixed bottom c versionsofapolicyusedbyawssupport quantifying allowed actions and requests.
indecember2021 theawssupportservicerolepolicypolicyusedbyawssupport automatedsystemswasmodifiedtoallowmoreactions.however thismodificationinadvertentlyallowedtheactions3 getobject whichgreatlyincreasedthenumberrequestsallowedbythepolicy due to the nature of the getobject action .
a bot detected the changeandpublishedittogithub whereseveralusersraisedconcernsaboutgetobject .withouthumanswhohadsubstantial awsknowledgeandwhomanuallyinspectedthepolicychange thisvulnerabilitymaynothavebeenmitigatedasquickly thusnecessitatingtheneedforautomatedverification.additionally prior work suchasbinarydifferentialanalysis wouldbeinsufficient as anadditionalactionwouldundoubtedlyincreasepermissiveness butthegetobjectactioninparticularincreasespermissiveness byalmostanorderofmagnitude.awseventuallyfixedthepolicy removinggetobject.simplifiedinitial modified andfixedpolicies areshowninfig1.thefixedpolicydoesnotallowgetobject wecanquantifythepermissivenessofpolicy1 a intermsofhow manyactionsandrequestsareallowedbythepolicy.assumingthat resourcesarenomorethan100characterslong ourtoolreports that24actionsand4 .
10138requestsareallowedbythepolicy.
thisresultiswithrespecttothesetofvalidawss3actionsandall possibleresources notthesetofresourcesintheuser sorganization.
ifthesetofresourcesisknown theycanbeaddedasaconstraint andthenourapproachwouldcounttherequestsallowedbythe policywithrespecttothesetofknownrequests.
wecanquantifythepermissivenessofpolicy1 b and1 c .our toolreportsthat47actionsand2 .
10205requestsareallowed bypolicy1 b .byremovinggetobjectfrompolicy1 b ourtool reportsthat46actionsand1 .
10205requestsareallowedby policy1 c .notethatbothpoliciesareidenticalexceptthatpolicy c does not contain the s3 getobject action.
if instead of the s3 getobjectactionbeingremovedfrompolicy1 b anotheraction suchass3 describejob wereremoved thenourtoolreportsthat 46actionsand2 .
10205requests asopposedto1 .
1807icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan statement effect allow principal action s3 getobject resource arn aws s3 myexamplebucket effect deny principal action s3 getobject resource arn aws s3 myexamplebucket statement effect allow principal action s3 getobject resource arn aws s3 myexamplebucket effect deny principal action s3 getobject resource arn aws s3 myexamplebucket condition stringnotlike aws userid aroaexampleid aidaexampleid figure initial top a and fixed bottom b versions of a policy for restricting access to certain users requests areallowedbytheresultingpolicy.thisdemonstrates theneedforquantitativeanalysisinthecontextofaccesscontrol.
quantifying allowed users.
depending on the scenario most awsuserswantamixofpublicandprivateaccesstotheirdata.
this entails creating complex policies specifying access to their data whichoftenrequiresin depthknowledgeoftheawspolicy language.inonescenario auserpostedontheforumsseekinghelp inhowtograntaspecificsetofusersaccesstoabucket.theuser wasunabletocraftapolicywithoutallowingunintendedaccess.
fig2showsthepoliciesanotheruserpostedinresponse.policy2 a deniesallaccesstoanydata eliminatingallaccess .policy2 b isa modificationoftheinitialpolicysothatonlyaspecificsetofusers canaccessdatawithinthebucket aswellasdenyinganonymous access .suchpoliciesthatalignwiththeuser sintentioncanbe difficulttocraft oftenduetocomplexaccesscontrollogicneeded orsheercomplexityinhowpermissionsshouldbegoverned.
wecanquantifythepermissivenessofpolicy2 b intermsof how many aws userids are allowed by the policy.
this lets the userverifythatachangeinpolicysemanticsmatchestheoriginal intentiontoonlyallowaccessforacertainsetofusers.assuming thatvalidaws useridsarenomorethan20characterslong ourtool reportsthat8 .
1010aws useridsareallowedbythepolicyout of2.
1036possibleaws userids.thisresultiswithrespecttothe setofallpossibleuserids andnotthesetofuseridsintheuser s organization.ifthesetofuseridsisknown theycanbeaddedasa constraintandthenourapproachwouldcounttheuseridsallowed bythepolicywithrespecttothesetofknownuserids.
ifwemodifypolicy2 b andremovethewildcardinthecondition that defines allowed userids i.e.
the line aroaexampleid thenourtoolwouldreportexactlythenumberofalloweduserids 2inthiscase .so inascenariowhereanawsuserwantstospecify apolicywithaconcretenumberofpermissions ourquantitative analysiscanbeusedtoverifythequantityofpermissions.quantifying trusted values inferred from a policy.
trustsafety introduced in is the notion that a policy should not allow untrusted i.e.public access.determiningifapolicyis trustsafe requiresinferringthesetof trustedvalues fromthepolicybyanalyzingthevaluesfor trusted keys andmakingsuretheydonotmatch an overlylarge setofvalues.in asyntacticcheckofthepolicy isperformedtolookforvaluescontainingawildcardcharacter andifso thepolicyisdeemednottrustsafe.however ingeneral asyntacticcheckcannotdeterminethesizeofasetofvaluesinan accesscontrolpolicy.ourapproachcanbeusedtopreciselydetermineifthesetofvaluesis overlylarge byquantifyingthesizeof thesetofvalues.ifthesizesurpassesapredeterminedthreshold thepolicywouldbedeemednottrustsafe.
policy model inthissection weintroduceourpolicymodelwhichformsthebasis ofourframework.ourmodelisdesignedtobeexpressiveenoughto modelcomplexpolicyspecificationsthatcanbeefficientlyandpreciselyanalyzedbymodernverificationandvalidationtechniques.
weuseanapproachsimilarto indefiningourpolicymodel.
anaccesscontrolpolicyspecifies whocandowhatunderwhich conditions.wedefineanaccesscontrolmodelinwhich declarative policiesfieldaccessrequestsfromadynamicenvironment andall requestsareinitiallydenied.anaccessrequestisatuple a r e a r ewhere isthesetofallpossibleprincipalsmaking a request ris the set of all possible resources which access is allowedordenied aisthesetofallpossibleactions and eisthe environmentattributesinvolvedinanaccessrequest.anaccess controlpolicy p 0 1 ... n consistsofasetofrules iwhere each rule is defined as a partial function a r e allow deny .thesetofprincipalsspecifiedbyarule is a r e a r e a fora a r forr r e fore earesimilarlydefined.
givenapolicy p 0 1 ... n arequest a r e isgranted accessif i p i a r e allow nexists j p j a r e deny thepolicygrantsaccessiftherequestisallowedbyaruleinthe policyandisnotrevokedbyanyotherruleinthepolicy.explicit deniesoverruleexplicitallows ifarequestisallowedbyonerule anddeniedbyanotherrule therequestisultimatelydenied .the setofallowrulesanddenyrulesfor paredefinedas pallow i p i ai ri ei i i i ai ri ei allow pdeny j p j aj rj ej j j j aj rj ej deny givenapolicy p therequestsallowedbythepolicyarethosein whichapolicyrulegrantstheaccessthroughan alloweffectand isnotrevokedbyanypolicyrulewitha denyeffect allow p a r e a r e i p a r e i i a r e allow nexists j p a r e j j a r e deny 1808quantifying permissiveness of access control policies icse may pittsburgh pa usa thesetofprincipals resources oractionsallowedbyapolicyis allow p a r e allow p allow p a a a a r e allow p allow p r r r a r e allow p permissiveness analysis inthissectionwediscusshowthepermissivenessofourpolicy modelisanalyzed.givenapolicy thegoalistodeterminewhat requestsareallowedbythepolicy andifthepolicyismoreorless permissivethananotherpolicy.thisisdonebyreducingpolicies tologicformulas similartotheapproachusedin .
.
smt encoding of a policy the permissiveness of a policy is determined by the number of requeststhatitallows themorerequestsallowedbyapolicy the higheritspermissiveness.thepolicyallowingallpossiblerequests isthemostpermissivepolicy andthepolicywhichdeniesallrequestsistheleastpermissivepolicy.itfollowsthat givenapolicy reasoningoverallpossiblerequestsallowedbythepolicydeterminesthepermissivenessofthepolicy.weencodethesetofpossiblerequestsbyintroducingvariables smt rsmt r asmt a esmt e inthegeneratedsmtformula.
llbracketp rrbracket parenleftbigg logicalordisplay.
pallow llbracket rrbracket parenrightbigg logicalanddisplay.
parenleftbigg logicalordisplay.
pdeny llbracket rrbracket parenrightbigg llbracket rrbracket parenleftbigg logicalordisplay.
smt parenrightbigg logicalanddisplay.
parenleftbigg logicalordisplay.
a a asmt a parenrightbigg logicalanddisplay.
parenleftbigg logicalordisplay.
r r rsmt r parenrightbigg logicalanddisplay.
parenleftbigg logicalordisplay.
e e esmt e parenrightbigg thesmtencodingofapolicy pisgivenby llbracketp rrbracketandrepresentsthe setofrequestsallowedby p.policyrulesareencodedasvaluesfor setsof a r e whereeachvaluesetpotentiallygrantsorrevokes permissions.
satisfying solutions to llbracketp rrbracketcorrespond to requests allowedbythepolicy i.e.
allow p a r e a r e llbracketp rrbracket .
relative permissiveness of policies forasinglepolicy equations8 9provideawaytomodelthesemanticsofapolicyinisolation.below weprovideapolicyanalysis frameworkthat giventwopolicies determinestherelativepermissivenessbetweenthetwo.
intuitively giventwopolicies p1andp2wecandeterminewhether oneismorepermissivethantheotherbyanalyzingformulas llbracketp1 rrbracket llbracketp2 rrbracketand llbracketp2 rrbracket llbracketp1 rrbracket.however itispossiblethatbothpolicies allowdifferentsetsofrequests orthesetofrequestsoverlap.in general therearefourpossibleoutcomes allow p1 allow p2 allow p1 allow p2 allow p1 allow p2 p1andp2donotsubsumeeachother therelativepermissivenessof p1andp2directlyfollowsfromeach scenario p1islesspermissivethan p2 p1ismorepermissivethanp2 p1andp2areequallypermissive or p1andp2areincomparable.thecalculationinvolvessatisfiabilitychecksoftwoformulas llbracketp1 rrbracket negationslash llbracketp2 rrbracketand llbracketp2 rrbracket negationslash llbracketp1 rrbracket if llbracketp1 rrbracket negationslash llbracketp2 rrbracketisnotsatisfiable then p1cannotbemore permissivethan p2 p2isatleastaspermissiveas p1 .
if llbracketp2 rrbracket negationslash llbracketp1 rrbracketisnotsatisfiable then p2cannotbemore permissivethan p1 p1isatleastaspermissiveas p2 .
ifboth llbracketp1 rrbracket negationslash llbracketp2 rrbracketand llbracketp2 rrbracket negationslash llbracketp1 rrbracketarenotsatisfiable then p1andp2areequivalent.
otherwise p1andp2donotsubsumeeachother.
notethattheformula llbracketp1 rrbracket negationslash llbracketp2 rrbracketcanbesimplifiedas llbracketp1 rrbracket negationslash llbracketp2 rrbracket llbracketp1 rrbracket llbracketp2 rrbracket whichcanbecheckedusingansmtsolver.
quantifying permissiveness translatinganaccesscontrolpolicyintoansmtformulaforsatisfiability checking allows some permissiveness analysis but it doesnotgiveinsightastohowpermissiveapolicyis.inthissection weintroduceanovelapproachformoreprecisereasoningin determiningthepermissivenessofasinglepolicyortherelative permissivenessoftwopolicies.
given p allow p isthesetofallrequestsallowedby p.let allow p denotethenumberofsuchrequests.thepermissivenessof pisgivenby allow p llbracketp rrbracket where llbracketp rrbracket denotesthenumberofmodelsforformula llbracketp rrbracket.using amodelcountingconstraintsolver wecanautomaticallycompute thevalueof llbracketp rrbracket .largervaluesfor llbracketp rrbracket indicateamorepermissive policy lowervaluesindicatealesspermissivepolicy.ametricfor analyzingpermissivenessofapolicyistoconsiderthelikelihood that a randomly generated request is allowed by the policy.
let dbethesetofallpossiblerequests with d beingthenumber ofallpossiblerequests.if llbracketp rrbracket 0allrequestsaredeniedby p if llbracketp rrbracket d allrequestsareallowedby p.let a r e be a request chosen uniformly at random from the set all possible requests.theprobabilitythat isallowedby pis p llbracketp rrbracket llbracketp rrbracket d thiseffectivelygivespermissivenessofapolicywithrespectto itsdomain.higherprobabilitiesindicatemorepermissivepolicies lowerprobabilitiesindicateslesspermissivepolicies.aprobability of0.5indicatesthepolicyallowshalfofallpossiblerequests.note thataprobabilityof0indicatesapolicywhichdeniesallrequests whileaprobabilityof1indicatesapolicyallowingallrequests.
thisapproachcanbeextendedforquantifyingrelativepermissiveness between policies.
given policies p1 p2 the number of requestsallowedby p1andnotallowedby p2is llbracketp1 rrbracket negationslash llbracketp2 rrbracket a r e a r e llbracketp1 rrbracket llbracketp2 rrbracket thenumberofrequestsallowedby p2andnotallowedby p1is llbracketp2 rrbracket negationslash llbracketp1 rrbracket a r e a r e llbracketp2 rrbracket llbracketp1 rrbracket recallthatwhencalculatingrelativepermissivenesstherearefour possibleoutcomes p1isequivalentto p2 p1ismorepermissive 1809icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan algorithm transformactions f m input smtformula f mapm output smtformulawithmappingappliedtoactions iff f1 f2then returntransformactions f1 m transformactions f2 m else iff f1 f2then returntransformactions f1 m transformactions f2 m else iff asmt c then return asmt m c else iff asmt c then return asmt m c else iff asmt regex then f prime false forci getactionsfromregex regex do f prime f prime asmt ci end for returntransformactions f prime m end if returnf thanp2 p1islesspermissivethan p2 orp1andp2areincomparable.
usingequations14 ifp1ismorepermissivethan p2then llbracketp1 rrbracket negationslash llbracketp2 rrbracket quantifieshowmuchmorepermissive p1isthan p2 ifp2ismorepermissivethan p1then llbracketp2 rrbracket negationslash llbracketp1 rrbracket quantifieshowmuchmorepermissive p2isthan p1 ifp1andp2donotsubsumeeachother llbracketp1 rrbracket negationslash llbracketp2 rrbracket and llbracketp2 rrbracket negationslash llbracketp1 rrbracket can be used to determine which policy is objectively more permissive totalrequestsallowed constraint transformation inthissectionwepresentaheuristicthattransformsasetofequality andinequalityconstraintsforastringvariabletoasetofrange constraints on an ordered set.
we do this by mapping a set of stringconstantstoanorderedsetofvalues.aswediscussbelow thisenablesustocompactlyencodeconstraintsonpolicyactions extractedfromaccesscontrolpolicies.
inpractice thereareafinitenumberofvalidactionsinanaccess controlpolicy.forexample s3 getobject isavalidaction butthe fictitiousaction s3 foobar isnot.forouranalysistobeprecise constraintsspecifyingvalidactionsmustbespecified.recallthat llbracketp rrbracketistheconstraintformulaextractedfrompolicy p.i.e.
llbracketp rrbracket f wherefisansmtformula.inaformula fextractedfromanaccess controlpolicy weobservethreetypesoftermsthatinvolveactions asmt ca smt ca smt regex wherecisastringconstantand regexisaregularexpression.we first consider cases where only the first two types of terms are present in a formula and then discuss how the transformation handlesregularexpressionconstraints.considertheformula f asmt s3 listbucket asmt s3 listbucketversions asmt s3 listbucketmultipartuploads bymapping s3 listbucket s3 listbucketversions s3 listbucketmultipartuploads fcanberewrittenas f asmt asmt theuseofrangeconstraintsgivesamorecompactencodingfor constraintson policyactions particularlywhenthereisa large numberofconstraintsonpolicyactions suchastheconstraints specifyingthesetofallvalidactions .
weintroduceaconstraintalgorithm disjunctiontorange f input smtformula fwithmappedactions output transformedsmtformulawithdisjunctionscollapsedintorange constraintswhenpossible iff f1 ... fnthen fr false f prime false s forfi f1 ... f n do iffi asmt c then fr fr fi s s c else f prime f prime disjunctiontorange fi end if end for ifsize s 2andsize s max s min s then returnf prime asmt min s asmt max s else returnf prime fr end if else iff f1 ... fnthen f prime true forfi f1 ... f n do f prime f prime disjunctiontorange fi end for returnf prime end if returnf transformationwhichtransformstheconstraintsonvalidactions intoamuchsmallersetofrangeconstraints.let v a bethesetof allvalidactions.thekeyinsightisthattheset v a canbemapped toatotallyorderedset v prime a whichcanbecompactlyrepresented usingacombinationofequalityandinequalityconstraints.the mappingand v prime a arestraightforwardtoconstruct eachvalid actiona v a ismappedtoauniqueinteger i andv prime a isthesetofallsuchintegers.
theconstrainttransformationheuristicconsistsoftwophases thefirstappliesthemappingtoconstraintsonactions thesecond transformsdisjunctionconstraintsintorangeconstraints.givena constraintformulainnegationnormalformandtheactionmapping algorithm1firsttransformsconstraintscontainingactionvariable asmtsoitisconsistentwiththemapping.forconstraints asmt c orasmt cwherecissomestringconstant cisreplacedbytheintegeraccordingtothemapping.forregularexpressionconstraintson actionasmt regex thefunction getactionsfromregex regex returnsallvalidactionssatisfiedbytheregex thenumberofvalid actionsisfinite andadisjunctiononallpossibilitiesisreturned e.g.
iftheconstraintis asmt s3 listb where correspondsto awildcard thengetactionsfromregexreturnstheonlyvalidactionsmatchingtheregex s3 listbucket s3 listbucketversions s3 listbucketmultipartuploads.aftertheactionconstraints havebeenmapped algorithm2attemptstotransformequalityconstraintsonactionsunderasingledisjunctionintorangeconstraints suchasinequation18 .ifthetransformationisnotpossible e.g.
theconstantsarenotcontiguous theinputformulaisreturned.
analyzing aws and azure policies basedonourproposednotionofpolicypermissivenessandour approach for quantifying permissiveness we have developed a differentialpolicyanalysisframeworkforpermissivenessanalysis ofaccesscontrolpolicies.ourframeworkisgeneralenoughtobe 1810quantifying permissiveness of access control policies icse may pittsburgh pa usa appliedtoavarietyofpolicieswritteninmultiplepolicylanguages.
todemonstratetheeffectivenessofourapproach weshowthatit canbeappliedtoexistingrealworldaccesscontrolmodels policies forawsiamandmicrosoftazure.
.
translation and implementation scopeandtranslationoftheawspolicylanguage.
theawspolicylanguageisenormous witheachservicehavingitsownrules onactionsandresources.weconsiderthreeofthemostpopular awsservices elasticcomputecloud ec2 identityandaccess management iam andsimplestorageservice s3 .weconsider two levels of constraints for each service.
first actions are constrainedtothesetofactionsdefinedbytheservice.s3 listbucket or s3 putobject are valid s3 actions but s3 foobar is not.
second actions and resource types are constrained by each other certainactionscanactonlyoncertainresourcetypes e.g.
action s3 listbucketoperatesonresourcearn aws s3 bucket.additionally resourcetypesareconstrainedbynamingrequirements e.g.
lengthofbucketnamesisbetween3and63characters an aws policy is a list of statements each statement allowing or denying access for a given set of principals actions and resources.foreachstatement wecreatearule capturingitssemantics.principals actions andresourceswithinastatementmap to a rin .modelingconditionsintoenvironmentattributesof eismorecomplex.eachconditionkeytogetherwithacondition operator specifies values for which access is allowed or denied.
theenvironmentattributesarethusasetoftuplesspecifyingthe conditionkeyandtheirrespectivevalues wherethenumberof tuplesdependsontheconditionoperator.forwildcardoranychar ?
symbols weuseregularexpressionstocapturethesetof allowed strings.
for example resource bucket translates to matchresource bucket.
where .
correspondstoanychar denotesthestartandendofaregularexpression representskleene star.wehandleconditionoperatorssuchasstringlikesimilarly.
scopeandtranslationoftheazurepolicylanguage.
likeaws eachazureservicehasitsrespectivesetofrulesonactionsand resources.weconsiderazurevmsandblobstorage whichare analogoustoec2ands3.weconsiderthesametwolevelsofconstraintsaswedoforaws.
anazure policy isgivenbyalistofroledefinitionsandalistof roleassignments.wejointhemtogetheronthe roledefidintorules .foreach wemap principalid to actions dataactions notactions notdataactions toa andscopetor.thecondition isparsedintoatreewhoseleavesspecifyconditionkeysandtheir respectivevalues thesearetheenvironmentattributes.likefor aws weuseregexforwildcards.
translatingactionandresourcetypeconstraints.
lettbethe setofconstraintsrepresentingactionandresourcetyperestrictions.
equation12nowbecomes llbracketp rrbracket llbracketp rrbracket t forcomparingmultiplepolicies equations14 15become llbracketp1 rrbracket negationslash llbracketp2 rrbracket llbracketp1 rrbracket negationslash llbracketp2 rrbracket t llbracketp2 rrbracket negationslash llbracketp1 rrbracket llbracketp2 rrbracket negationslash llbracketp1 rrbracket t algorithm translatepolicy p input policy p output smtformula llbracketp rrbracketencoding p llbracketpallow rrbracket false llbracketpdeny rrbracket false forrule inpdo llbracket rrbracket encode llbracketa rrbracket encode a llbracketr rrbracket encode r llbrackete rrbracket encode e llbracket rrbracket llbracket rrbracket llbracketa rrbracket llbracketr rrbracket llbrackete rrbracket if llbracketpallow rrbracketthen llbracketpallow rrbracket llbracketpallow rrbracket llbracket rrbracket else llbracketpdeny rrbracket llbracketpdeny rrbracket llbracket rrbracket end if end for return llbracketp rrbracket llbracketpallow rrbracket llbracketpdeny rrbracket algorithm permissiveness p b input policy p boundb output permissivenessof p llbracketp rrbracket translatepolicy p t gettypeconstraints ifissat llbracketp rrbracket t then return countmodels llbracketp rrbracket t b else return end if algorithm relativepermissiveness p1 p2 b input policies p1 p2 boundb output relativepermissivenessof p1 p2 llbracketp1 rrbracket translatepolicy p1 llbracketp2 rrbracket translatepolicy p2 t gettypeconstraints f1 llbracketp1 rrbracket llbracketp2 rrbracket t f2 llbracketp2 rrbracket llbracketp1 rrbracket t ifissat f1 and notissat f2 then return p1ismorepermissive countmodels f1 b else if not issat f1 andissat f2 then return p2ismorepermissive countmodels f2 b else if not issat f1 and notissat f2 then return p1andp2areequivalent else ifissat f1 andissat f2 then return p1andp2donotsubsumeeachother countmodels f1 b countmodels f2 b end if we implement translation for t for aws by scraping the aws resource andproperty typesreferencewebpages toidentify the resourcetypeseachactioncanoperateon.forazure wegenerate constraintsbyreadingacsvfilefromtheazureportalthatrelates actionstoresourcetypes.notethatpriorwork doesnot considertypeconstraintsintheiranalysisofaccesscontrolpolicies.
policy translator.
basedonourapproach weimplementedan open sourcetoolcalledqackythatquantifiespermissivenessor relativepermissivenessbytranslatingpoliciesintosmtformulas andpassingtheformulastoamodelcountingconstraintsolver.our implementationusesthepopularautomata basedmodelcounter abc whichusesautomata theoretictomodelcountstring andnumericconstraints.abccountssatisfyingsolutionstothe formulabyconstructingautomataforansmtformulaandperformingpathcountingontheautomata.smtformulasfromqacky canalsobefedintoothersmt lib conformantconstraintsolvers suchasmicrosoftz3.
1811icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan qackytranslatesapolicy pintoasmtformula llbracketp rrbracketbytranslatingeachrule asshowninalgorithm3.toquantifythepermissivenessofapolicy p qackytranslates p appendsthetype constraintst andcallsabctocountthesolutionssatisfying llbracketp rrbracket t asshowninalgorithm4.toanalyzetherelativepermissiveness betweentwopolicies p1andp2 qackyproducestwosmtformulas llbracketp1 rrbracket negationslash llbracketp2 rrbracketand llbracketp2 rrbracket negationslash llbracketp1 rrbracketandcallsabctochecktheir satisfiabilityandtocountmodels asshowninalgorithm5.
experimental evaluation below wefirstdescribeourmethodologyforgatheringpolicies thenwediscussthefourexperimentsweconductedtoevaluateour approachanditsimplementationinqacky1.thefirstexperiment benchmarksqacky anditevaluatesqacky sperformanceand identifieswhichfactorsinfluencetheanalysis.thesecondexperimentevaluateshoweffectiveqackyisatreasoningaboutthe relativepermissivenessofaccesscontrolpolicies.thethirdexperimentcomparestheperformanceof qackywithanenumerative modelcountingapproachbasedonsmtsolvers.thefourthexperimentdemonstratesthatourapproachcanbeappliedtoazure policies.unlessotherwisenoted allexperimentsusetheconstraint transformationheuristic andincludetypeconstraints.
intheexperimentsreportedbelowweassumestringvariables principal action resource conditionkeys containanyofthe256 asciicharactersandatmost100characterslong unlessotherwise specified.wereportpermissivenessasnumberofrequestsallowed arequestisatuple a r e .resultsarereportedinlog scale.
for all experiments we use a desktop machine with an intel i5 .5ghzx4processor 128gbddr3ram withalinux4.
.
bitkernel z3v4.
.
andthelatestbuildofabc2.
.
policy datasets duetosecurityimplicationsofmakingaccesscontrolpoliciesthat areusedinanorganizationpublic policiesthatarebothpublicly availableandrepresentativeofreal worldpoliciesarepractically non existent.weareunawareofanysuchdatasetforneitheraws thosein werenotreleasedtothepublic norazurepolicies.
toevaluateourapproach acomprehensivedatasetisrequired.we usetwoawspolicydatasetscollectedfromusersandarguethese datasetsarerepresentativeofreal worldpoliciesandcomprehensiveenoughtoshowthatourapproachiseffective.wealsocompile adatasetofazureroledefinitionsfrommicrosoftdocs.
obtainingawspoliciesfromusers.
thelackofpubliclyavailable policydatasetsforawsmeansthatfindingqualitypoliciesisa cumbersometask.awsuserstendnottosharepoliciespossibly containingsensitivedata policiescanleakorganizationstructure .
however we found this to notbe the case when users needed assistancedesigninganddebuggingtheirpolicies.awspolicies canbecomplexandunwieldy especiallytothoseunfamiliarwith accesscontrol.consequently awsprovidesforumswhereusers needingassistanceoftenposttheirpoliciesandotherusers and awsemployees canprovideassistance.suchpoliciesareusually sanitizedandvaryincomplexity makingtheawsforumsagood sourceforcompilingadataset.
1toolandbenchmarksavailableat asof2021 aws offersmorethan200services manyofwhichuseaccesscontrol policiesandallofwhichhavededicatedforums.wesearchedfor policiesbasedonseveralcriteria.wefocusedoniam s3 andec2 astheyareamongthemostpopularservicesandaremorelikely toyieldthebestsampleofpolicies.ourgoalwastohaveagood balanceofsimpleandcomplexpoliciesaswellaspolicysets and weonlyincludedpoliciesthataresemanticallyvalid.
outofseveralhundredforumpostsdatingbackseveralyears weidentified30postscontainingatotalof41well formedpolicies the vast majority of posts either contained no policies or fragmented invalidpolicies fromec29postswithsinglepoliciesand 2postswithmultiplepolicies 4policies fromiam2postswith singlepoliciesand3postswithmultiplepolicies 6policies from s39postswithsinglepoliciesand5postswithmultiplepolicies policies .fromourobservations wefoundthatwhenuserssought assistanceviatheforums theyoftenonlypostedasinglepolicyin isolation.only10postscontainedeithermultipleversionsofthe samepolicyormultiplepoliciescombinedtogetherinapolicyset multipleawspoliciescanbecombinedintoasinglepolicy .
synthesizing aws policies through mutations.
we synthesize awspoliciesthroughmutationsfortworeasons.first wewanta largerdatasetonwhichtoevaluateourpolicyanalysisframework andtool.second wewanttomimicrealisticscenarioswherethe semanticmeaningofapolicyisslightlymodifiedbyanemployee withinsomeorganization.modificationstoapolicycanalterthe permissivenessofapolicyinwaysindiscerniblewithoutintensive manualinspection.asimplemodificationcouldallowonemore useraccesstoaresourceoritcouldallowonethousandmoreusers access to a resource in either case the modified policy is more permissivebutclearlydiffersinmagnitude.synthesizingpolicies throughmutationisoneapproachformodelingsuchscenarios.
weuseideasfrommutationtestingtosynthesizepolicies .
mutationtestingisawidelyusedsoftwaretestingtechniquefor measuringtestsuitestrength.thetechniqueappliesmutationsto aprogramundertesttogeneratevariationsoftheprogram and evaluatesthemagainstatestsuite.afaultyprogram ormutant is killedifatleastonetestinthesuitefails.themoremutantskilled thehighertheconfidenceinthetestsuite.
we synthesize mutants of a policy with mutations intended toalterthepermissivenessofapolicy whichweusetoevaluate theeffectivenessofourapproach.weimplementthreetypesof mutationswhichmimicrealisticscenariosandgenerallyyieldmore permissivemutants ifastatement s effectisdeny changeitto allowandnegate thestatement s actionandresourcekeystonotactionand notresource orviceversa.
ifastatement s actionorresourcevaluesarelists change themtoasinglestringcontainingawildcard.forexample anactionlistcontainings3 listbucketands3 getobject ischangedtoasinglestrings3 .
ifastatementcontainsany conditions removethem.
foreachstatementofagivenpolicy wecreateasetofapplicable mutationtypes.forexample considerastatementwithan allow effect alistof actionvalues anda condition.thesetofapplicable mutationsis type2 type3 becausethetype1mutationdoesnot 1812quantifying permissiveness of access control policies icse may pittsburgh pa usa table times for each aws service with and without the constraint transformation heuristic.
times are in seconds.
withouttransformation withtransformation min max avg min max avg ec22.
.
.
.
.
.
iam0.
.
.
.
.
.
s30.
.
.
.
.
.
table results for each aws service with and without type constraints.
permissiveness is the number of requests allowed.
am is arithmetic mean gm is geometric mean.
avgexectime s log2 am log2 gm notype type notype type notype type ec20.
.
.
.
.
.
iam0.
.
.
.
.
.
s30.
.
.
.
.
.
apply to the alloweffect.
the power set of applicable mutation typesrepresentscombinationsofmutationsthatcanbeappliedto thatstatement.thus wecreatesuchapowersetforeachstatement.
bychoosingonesetfromeachpowersetandapplyingthemutation typesinthatsettoitsrespectivestatement weoutputamutated policy.
from original ec2 policies we generated mutants.
from6originaliampolicies wegenerated26mutants.from14 originals3policies wegenerated280mutants.intotal from29 originalpolicies wegenerated546mutants.
obtainingazure policiesfrom microsoftdocs.
asof2021 azure comprisesmorethan200servicesand120built inroles.weare unawareofanyforumswhereuserspostcustomroledefinitions so wesearchedmicrosoftdocsforbuilt inroledefinitions.wefocused onazurevmsandblobstoragebecausetheyareanalogoustoec2 ands3.weobtained2policiesfromvmsand3fromblobstorage forourproofofconcept.
.
qacky benchmarking thegoaloftheseexperimentsistoevaluateqacky sperformance andidentifywhichfactorsinfluencetheeffectoftheanalysis in termsofcountsandtimetaken .weevaluatetheperformanceand effectivenessof qackyon41policiestakenfromawsforums.
firstweevaluatetheeffectivenessoftheconstrainttransformation heuristicfromsection5byanalyzingeachpolicy withtypeconstraints twice bothwithouttheheuristicandwiththeheuristic enabled.then weanalyzeeachpolicytwice oncewithouttype constraintsandoncewithtypeconstraints.
effectivenessofconstrainttransformation.
theresults separated byawsservice areshownintable1.thedecreaseinminimum timeswiththeconstrainttransformationheuristicwasbetween fors3to76 forec2.themaximumtimesdecreasedbetween fors3to96 forec2.theresultsforaveragetimesweresimilar withadecreaseofbetween78 fors3to92 forec2.theheuristicreducedtheminimum maximum andaveragetimesbyaboutan orderofmagnitudeforec2 butnotasmuchforiamands3.this maybebecauseec2hasmoreactions 311asofwriting thanboth iam ands3 andthusitmayreapmorebenefitsfrom rangeconstraintsasopposedtoequalityconstraints.
impact of type constraints.
theresultsforeachawsservice areshownintable2.outofthe41policies 1policyallowedno requestbothwithandwithouttypeconstraints 1policyallowed requestswithouttypeconstraintsbutallowednonewhentypeconstraintswerepresent.withouttypeconstraints qackyanalyzed eachpolicyinunderasecond.typeconstraintsslowtheanalysisconsiderablybutdrasticallyeffectpermissiveness decreasing thenumberofallowedrequestsbyhundredsofordersofmagnitude.thisisduetotypeconstraintsrestrictingthesetofpossible actionsandconstrainingactionstoonlyactonspecificresource types.typeconstraintsrepresentallpossibleactionandresource typerestrictionsandmustbeexplicitlyenumeratedwithintheconstraint slowingdowntheanalysis.foreverypolicy thepresenceof typeconstraintsresultedinamorepreciseanalysis.withouttype constraintstomodelthesemanticsofthepolicylanguage qacky givesanoverapproximation ofthepermissivenessforapolicy.
.
relative permissiveness quantification thegoalofthisexperimentistoevaluatehoweffectiveqacky isatreasoningabouttherelativepermissivenessofaccesscontrol policies andtoshowcasetheeffectivenessofquantifyingrelative permissivenessingeneral.weevaluatetheeffectivenessof qacky in quantifying relative permissiveness between a policy and its synthesizedmutants.werecordtheaveragetimesanddifferences inpermissivenessbetweenthemutantsandtheoriginalpolicy.
eachpolicy piscomparedagainsteveryoneofitsmutants pm twice oncetoquantifythenumberofrequestsallowedby pbut notpmandoncetoquantifythenumberofrequestsallowedby pm butnot p.weusedtypeconstraints constrainttransformation and atimeoutof10minutesforeachpairofcomparisons.theresults areshownintable3.thethirdcolumnshowstheaveragetime acrossallpairsofcomparisons.
columns3 6oftable3showthedistributionofpermissiveness between each policy and its mutants.
the majority of mutants wereeitherlesspermissive morepermissive orequivalenttothe originalpolicy.columns7 10showtheresultsofquantifyingthe differenceinpermissivenesswheneverapolicyanditsmutantwere notequivalentanddidnotsubsumeeachother.foreachpolicy anditssetofmutants columns7and8reportthearithmeticand geometricmeansforthenumberofrequestsallowedby pbutnotby pm.conversely columns9and10reportthemeansforthenumber ofrequestsallowedby pmbutnotby p. .
comparison with enumerative model counting sat smt solvers have been used in prior access control policy analysistechniquestoresolvequeriesaboutpolicybehavior e.g.
zelkova margrave .thisofteninvolvesenumeratingthe setofsolutionstothequery throughrepeatedcallstoaconstraint solver.ineachcall theconstraintsarerevisedbyappendingthe negationofallpriorsolutions.ourapproachdiffersfundamentally 1813icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan table3 resultsforawspoliciescomparedwiththeirmutants.arithmetic geometricmean am gm fornumberofrequests allowed log scale usedwhenthecountis arereportedwhenthemutantislessormorepermissivethanitsoriginalpolicy.
policyavgexec pmless pmmore equivalent neither pmlesspermissive pmmorepermissive time s permissive permissive subsumes log2 am log2 gm log2 am log2 gm p1 .
.
.
.
.
p2 .
.
.
.
.
p3 .
.
.
p4 .
.
.
p5 .
.
.
.
.
p6 .
.
.
.
.
p7 .
.
.
.
.
p8 .
.
.
p9 .
p10 .
.
.
p11 .
.
.
p12 .
.
.
p13 .
p14 .
.
.
p15 .
.
.
p16 .
.
.
.
.
.
.
p17 .
.
.
p18 .
.
.
p19 .
.
.
.
.
p20 .
p21 .
.
.
p22 .
.
.
.
.
.
.
p23 .
.
.
p24 .
p25 .
.
.
p26 .
.
.
.
.
p27 .
.
.
.
.
.
.
.
.
p28 .
.
.
p29 .
.
.
.
.
.
.
.
.
of qacky s0 .
figure counts for the enumerative approach as percentage of the count from qacky on a simple policy over a minute period for bounds left and right .
aswedonotrelyonenumeratingsolutionsbyrepeatedlycallinga constraintsolver butratherweuseamodelcountingconstraint solver abc thatcancountallsolutionsinasinglecall.
intheseexperimentswecompareourapproachtoanenumerativeapproachusingthez3smtconstraintsolver .first weanalyzeasimplepolicyallowing2s3actionson2resources arn aws s3 foo andarn aws s3 bar.wevariedthestringbound from16to21toletthewildcardmatch0to5characters resp.
and weseta20minutetimeout.forbounds16and17 bothapproaches finishedcounting4and516modelsin0.15and16.77seconds resp.
table average model counting rates for the enumerative approach and qacky with type constraints.
the former s averagemodelcountingratesinthefirsthalf 5min.
and secondhalf 10min.
ofthe10minutetimeoutintervalare reported.
averagemodelscountedpersecond enum.
5min.
enum.
10min.
qacky ec2 .
.
.
iam .
.
.
s3 .
.
.
fortheenumerativeapproachandin0.03and0.03seconds resp.
forqacky.forbounds18to21 theenumerativeapproachtimed outaftercounting3446 3125models resp.
whereas qackyfinishedcounting1 .
.
.
.
models resp.
withinonesecond.theresultsforbounds18and19 areshowninfig.
.
wealsoanalyzethe41awspoliciesusingbothapproaches.the resultsareshownintable4.foreachnamespace qackyyielded 1814quantifying permissiveness of access control policies icse may pittsburgh pa usa table5 resultsforazurevmandblobstoragepolicies with andwithouttypeconstraints.permissivenessisthenumber of requests allowed and is reported in log scale base time s permissiveness notype type notype type loginuser .
.
.
.
loginadmin .
.
.
.
datareader .
.
.
.
datacontributor .
.
.
.
dataowner .
.
.
.
anastronomicallygreateraveragemodelcountingratethanthe enumerativeapproach.moreover theaveragerateoftheenumerativeapproachdecreasedbetweenthefirstandsecondhalvesofthe 10minutetimeoutinterval.theseresultsshowthatquantifying permissivenessusinganenumerativeapproachforpolicyanalysis suchas basedonanoff the shelfsmtorsatsolverisnota viableoptionforquantitativepermissivenessanalysis.
.
microsoft azure policies thegoalofthisexperimentistodemonstratethatourapproachcan beusedtoanalyzeazurepolicies.likewedidforaws weevaluate theperformanceandeffectivenessofqackyonthe5policiestaken frommicrosoftdocs.weanalyzeeachpolicytwice oncewithout type constraints and once with type constraints.
because many stringvariablesinazurepoliciesaremorethan100characterslong weassumethattheyareatmost250characterslong.
the results are shown in table .
like previous experiments thereisatradeoffbetweentimeandpermissiveness.withouttype constraints thetwovmpoliciesseemtohavethesamepermissivenessinlogscale base2 butwithtypeconstraints itisclear thatmoredistinctrequestsareallowedbyloginadminthanby loginuser.
the blob storage datareader datacontributor and dataownerpoliciesareincreasinglypermissive.withouttypeconstraints dataownerseemsmuchmorepermissivethandatareader anddatacontributor.withtypeconstraints weseethat2810.03distinctrequestsareallowedbydataowner whereas2806.
.
distinctrequestsareallowedbydatareader datacontributor resp.
.
.
threats to validity thepoliciesextractedfromawsforums azuredocumentationare basedonasmallsampleandmaynotberepresentativeenough.we mitigatethisthreatbyexpandingthedatasetthroughmutations creating a larger benchmark and publicly releasing this benchmark.ourcurrentexperimentalevaluationfocusesonasubsetof aws azureservices s3 ec2 iamforawsandvm bsforazure .
althoughourtechniquesareextensible extensionsofourapproach tomoreservicesrequiresfurtherexperimentalevaluation.
related work accesscontrolhasbeenthesubjectofextensiveresearch manyaccesspolicylanguageshavebeenproposed andtheproblemwithaccesspoliciesbecominglargeanddifficultto reasonabouthasbeennotedinthepast .
therehasbeenearlierworkonverificationofaccesscontrol policies as well as on assisting policy creation .
someearlierworkanalyzerolebasedaccesscontrolschemasusing thealloyanalyzer .
theworkmostcloselyrelatedtoourworkisthatofzelkova .
zelkovaisaclosed sourcetoolforanalyzingpropertiesofaws policieswhichcanautomaticallycomparetwoawspoliciesand determinewhetheroneismorepermissivethantheother.thetwo crucialdistinctionsbetweenzelkovaandourworkisthat we provideageneralpolicyframeworkforanalyzingaccesscontrol policieswhichcanbeappliedtootherpolicylanguages and weintroduceanovelapproachforquantifyingthepermissiveness ofaccesscontrolpolicies ratherthanabinaryyes noanswerin zelkova .bothourworkandzelkovabuildfromideasfromthesatbasedcheckingofxacml .intheirapproach hughesetaluse aboundedapproachtoanalyzepropertiesofxacmlpolicieswith satsolvers.recentworkhasbuiltuponzelkova butdoesnot providequantitativeassessmentsofpermissiveness.margrave isatoolthatanalyzesxacmlpoliciesusingamulti terminaldecisiondiagrams.margravegoesbeyondbinary ternarydifferential analysis allowing a user to write general purpose queries over changes to a policy.
in a later work margrave uses a sat solvertoenumerativelyproducesetsofsolutionstoqueries.our experimentsshowthatthistypeofenumerativeanalysisapproach isnotnearlyscalableenoughformeaningfulquantitativeanalysis.
verificationtechniquesforanalyzingaccesscontrolpoliciesembeddedinprogramshavebeenstudied .derailerisinteractivetoolthatletthedevelopertraversethetreeofalldataexposed byanapplicationandinteractivelygenerateadesiredpolicy .
rubyx isatoolforsymbolicexecutionforrailsthatcanbe usedtofindaccesscontrolbugs.cancheck isanautomated verificationtoolthatusesfirstorderlogicencodingandtheorem provingforfindingaccesscontrolbugsinrailsapplications.
differentialanalysistechniqueshavealsobeeninvestigatedin thepast .forexample in differential symbolic execution is used to find differences between original and refactored code by summarizing procedures into symbolic constraintsandthencomparingdifferentsummariesusingansmt solver.symdiff computesthesemanticdifferencebetween twofunctionsusingthez3smtsolver .however weare notawareofanypriorworkonquantitativedifferentialanalysis.
conclusions errors in access control policies used for controlling access to datasourcesavailableoncloudserverscanhavedisastrousconsequences.inthispaperwepresentedanewapproachformodeling andquantifyingpermissivenessofaccesscontrolpolicies.ourapproachreliesonmodelcountingconstraintsolverstoassessthe permissivenessofagivenpolicy.weimplementedthisapproach for aws policies and experimentally evaluated its effectiveness onawspolicieswecollectedfromdiscussionforums.ourresults demonstratethatourquantitativepermissivenessanalysisapproach isapplicableinpractice.infuturework weaimtoinvestigatehow quantitative analysis techniques can be applied to other policy analysisproblems suchaspolicyrepair.
1815icse may pittsburgh pa usa william eiers ganesh sankaran albert li emily o mahony benjamin prince and tevfik bultan