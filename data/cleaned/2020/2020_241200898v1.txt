preserving privacy in software composition analysis a study of technical solutions and enhancements huaijin wang1 zhibo liu1 yanbo dai2 shuai wang1 qiyi tang3 sen nie3 shi wu3 1hong kong university of science and technology 2hong kong university of science and technology guangzhou 3keen security lab tencent hwangdz zliudc shuaiw cse.ust.hk ydai851 connect.hkust gz.edu.cn dodgetang snie shiwu tencent.com abstract software composition analysis sca denotes the process of identifying open source software components in an input software application.
sca has been extensively developed and adopted by academia and industry.
however we notice that the modern sca techniques in industry scenarios still need to be improved due to privacy concerns.
overall sca requires the users to upload their applications source code to a remote sca server which then inspects the applications and reports the component usage to users.
this process is privacy sensitive since the applications may contain sensitive information such as proprietary source code algorithms trade secrets and user data.
privacy concerns have prevented the sca technology from being used in real world scenarios.
therefore academia and the industry demand privacy preserving sca solutions.
for the first time we analyze the privacy requirements of sca and provide a landscape depicting possible technical solutions with varying privacy gains and overheads.
in particular given that de facto sca frameworks are primarily driven by code similaritybased techniques we explore combining several privacy preserving protocols to encapsulate the similarity based sca framework.
among all viable solutions we find that multi party computation mpc offers the strongest privacy guarantee and plausible accuracy it however incurs high overhead .
we optimize the mpc based sca framework by reducing the amount of crypto protocol transactions using program analysis techniques.
the evaluation results show that our proposed optimizations can reduce the mpc based sca overhead to only .
without sacrificing sca s privacy guarantee or accuracy.
i. i ntroduction given a piece of software software composition analysis sca identifies components borrowed from third party and open source software oss projects.
hence according to the component usage information developers are aware of the usage of vulnerable or outdated oss projects and therefore are able to take further actions to reduce security risk ensure license compliance and promote healthy opensource project usage.
in recent years the industry and academia have extensively studied sca techniques in different settings and achieved promising results regarding accuracy and efficiency.
despite the prosperous development and adoption of sca techniques we notice that the accompanying privacy concerns are hindering the usage of sca in real world scenarios.
indeed some authors of this paper have been working in a leading industrial company of sca solutions and they are frequently encountering and handling requests for performing sca without disclosing customer s data in recent years.
the typical pipelines of industrial sca solutions require a customer corresponding author.to upload the software to a remote server possessed by the sca vendor where the software is analyzed to produce a report that reveals the potential security and legal risks of the software.
the report usually contains a list of reused oss projects some of which may include known vulnerabilities.
this process is privacy sensitive since the uploaded software may contain sensitive information such as trade secrets or personal data.
moreover the source code is proprietary and deemed part of the customer s intellectual property ip .
in reality few companies are willing to provide commercial products source code to another party since it is hazardous to leak valuable ips .
to avoid leaking customers privacy contemporary sca vendors may deploy the sca service in the customer s inhouse domain.
while this alleviates the privacy concerns from the user side it requires the sca vendor to share its ips i.e.
the sca frameworks algorithms and accompanying data with the customers.
for instance when the sca service is deployed on the customer s side the sca vendor has to release the oss database to customers periodically.
however existing sca vendors are often unwilling to share the valuable oss database which requires many resources to build.
existing works show that a comprehensive oss database with reliable oss dependencies has an essential impact on the accuracy of sca and it is not economical for small and medium sized companies to build their own databases.
for instance it is disclosed that binaryai an industrial sca vendor has spent over three years a dozen senior engineers and pb level disk space to construct its oss database.
in addition binaryai relies on a large model that has been trained with ten nvidia tesla t4 gpus for years.
thus exposing the model s parameters is unacceptable.
since sca serves as one of the cornerstones of software security and a paramount part of software engineering the industry and academia are demanding a privacy preserving sca solution to promote the practical adoption of sca in industry scenarios.
accordingly this paper targets this practical need to study the possible technical solutions for privacypreserving sca and we aim to answer the following two research questions rqs rq1 how can we effectively protect both customers and vendors privacy in sca?
rq2 how can a privacy preserving sca pipeline be built with satisfactory performance for practical use?
to answer rq1 we systematically study existing technical solutions and their dis advantages exploring and proposing two novel privacy preserving sca frameworks.
as shownarxiv .00898v1 dec 2024server oss dboss repositories oss signaturesopenssl ... c code segmentationclient inputinput signatures matched signatures with oss inforeport1 a oss collection b c b signature generation a oss collection b signature generation c code segmentationfig.
a common sca pipeline.
in table i each studied solution exhibits distinct privacy guarantees required resources overhead and potential pitfalls.
furthermore we concretize the technical solutions and empirically benchmark their overheads and accuracies.
specifically the two novel solutions we proposed involve advanced privacypreserving protocols to offer privacy preserving sca.
one solution relies on similarity based bucketization sbb a scale private similarity testing technique the other depends on multi party computation mpc which enables multiple parties to jointly perform computation without revealing their private data to each other.
sec.
v e demonstrates that the sbb based solution although lightweight still bears the risk of potential privacy leakage.
in contrast mpc offers a much stronger privacy guarantee by shielding both the sca customers and vendors valuable assets such as code model and data.
overall our study illustrates the promising potential of mpc based sca.
nevertheless the mpc based sca pipeline we proposed incurs excessively high overhead which prohibits its practical usage.
to answer rq2 we propose three optimization strategies with program analysis techniques which significantly reduce the amount of crypto protocol transactions.
our optimization strategies including symbol filter informative source function selector and assembly function selector can vastly reduce the time cost of mpc based sca from to and the most time consuming process i.e.
encrypted computation with mpc is reduced to .
leading to a practical privacy preserving sca solution.
in sum this work presents the following contributions observing the privacy concerns of sca over both the user and the sca service provider we for the first time study the privacy preserving sca whose absence is a crucial hindrance to the practical adoption of sca in industry scenarios.
we analyze the privacy leakage risks in three typical sca solutions and formulate two novel privacy preserving sca frameworks with sbb and mpc respectively.
each studied solution exhibits distinct privacy guarantees and required resources.
we then present an empirical evaluation of their overheads and accuracy.
we find that mpc offers high accuracy with the strongest privacy guarantee.
we design a set of optimizations that can largely reduce the cost of expensive crypto operations for the mpc based sca solution and without sacrificing accuracy achieving the first practical privacy preserving sca.
artifact availability.
we have released our artifact at .
we will maintain it for future research comparison and usage.ii.
b ackground a. a common sca pipeline this section introduces the common sca pipeline which is widely adopted by state of the art sota c c sca works .
as shown in fig.
the pipeline comprises a server usually owned by the sca vendor and a client for customers to access the sca service.
to perform sca the server first builds an oss database oss db offline i.e.
a b and c and then provides an online sca service i.e.
edges and3 to the client.
accurate sca analysis relies on extracting high quality distinguishable code signatures that can help identify semantic differences between code snippets.
recent sca works generate signatures with advanced similarity analysis techniques such as locality sensitive hashing lsh and deep learningbased embeddings to extract features from source or binary code.
below we introduce the major steps in sca.
moreover sec.
ii b discusses a concrete example c entris .
offline analysis.
the offline process for building oss db consists of three steps oss collection signature generation andcode segmentation .
oss collection.
an extensive oss db is inevitable for realworld sca tasks.
existing sca techniques e.g.
centris and tplite build their oss db by downloading reputed repositories from open source platforms like github and gitlab.
in this work we build our oss database from the same sources.
more details are discussed in sec.
v a. signature generation.
the sca server dissects an oss repository into smaller code pieces with finer granularities e.g.
functions and source files .
then the server generates signatures for each code piece based on specific underlying sca techniques.
a common practice is to generate functionlevel signatures with hash algorithms or embedding techniques .
therefore each oss repository in the oss db has a set of function level signatures e.g.
hash values or embedding vectors .
code segmentation.
a common observation is that an oss project often reuses other oss projects.
therefore the signatures of an oss project may overlap with some other projects signatures due to the borrowed code.
for instance sdl a popular media library borrows code from yuv2rgb an image conversion library.
thus some function signatures of yuv2rgb are also included in sdl s signatures.
the overlapped signatures likely result in false positives in sca e.g.
a project reusing yuv2rgb is likely to be identified as reusing sdl.
existing works e.g.
centris and tplite segment the sets of oss projects signatures into non overlapped sets to address this issue.
online analysis.
to conduct sca the client first uploads the input source or binary code to the server and generates signatures derived from the input .
then the server searches for similar or identical signatures in the oss db and records the matched signatures with their oss information .
finally the server returns the matched information and the sca report to the client .
details of the three steps are below.
the client sends the target software s codebase e.g.
source or binary code to the sca server which computes the input signatures in the same way as the offline signature generation.
precisely the server dissects the input codebase into smaller code pieces e.g.
functions and then generates signatures with hash or embedding models for each code piece.
given the input signatures the server searches for relevant signatures in the oss db.
since signatures generated from similar code pieces have short distances if an input signature is similar or identical to one signature in the oss db the code piece is likely borrowed from the corresponding oss project.
having identified which code snippets are being borrowed from oss projects the server reports the sca results to the client which depict the information on reused oss projects.
specifically the server can warn the client if the reused oss projects have known vulnerabilities or license issues.
b.centris tlsh to better understand the pipeline we take centris a sota source based sca framework depending on the trend micro locality sensitive hash tlsh for signature generation and oss identification as an example.
for simplicity we refer to it as centris tlsh to distinguish it from other c entris variants.
tlsh.
tlsh is a locality sensitive hash algorithm designed for similarity testing.
tlsh generates a hash value for one function and ensures similar functions result in close hash values.
in practice if the distance between two hash values is smaller than a threshold the two source functions are considered from the same source with high confidence.
specifically with the distance measure function dis the functions fiandfjare similar if their hash values hiandhjsatisfy dis hi hj .
offline analysis.
given the set of collected oss repositories o o1 o2 .
.
.
o n centris first dissects ok ointo a set of source functions fk and then generates tlsh hash values for each function in fk which forms the function hash value set hk.
after processing all oss repositories for each oss ok centris segments the hash value set hkinto a non overlapped set dbk which is stored in the oss db for online analysis.
online analysis.
assume there are noss projects in the oss db and the function hash value set of the oss project k isdbk.
first given the target software s codebase centris dissects it into source functions and generates tlsh hash values for each function resulting in the function hash value seti.
then centris searches for similar hash values and their original oss projects in the oss db.
for each oss project k centris checks the set of similar hash values between iand dbkwith eq.
and gets the set of similar function pairs sk.
finally if sk dbk is greater than a threshold set as .
in centris which denotes that a certain portion of functions are deemed as reused centris reports the oss project kas reused.
by traversing all oss projects centris can report all reused oss projects in the input codebase.
sk hi hj hi hj i dbkanddis hi hj embed w p p noiseclient server oo ooo oooo oodatabase db sim p db b bfig.
similarity based bucketization protocol.
c. privacy preserving protocols privacy preserving protocols allow users to protect their privacy while maintaining the service without being affected.
in this paper privacy preserving protocols aim to protect sca consumers and vendors ips from being exposed to other parties while allowing a valid and accurate sca analysis.
this section introduces the relevant mainstream privacy preserving protocols that are relevant to our work.
sbb.
similarity based bucketization sbb provides private similarity testing.
compared with expensive cryptographic protocols sbb scales well to large databases and does not sacrifice the correctness of matching.
fig.
presents the framework of sbb.
given a client s element w to be queried the client first embeds the element and get its representation p. after mutating pwith noises the mutated result p is sent to the server.
then the server searches for similar elements with p i.e.
the red point in its database and get a bucket i.e.
b of similar elements which is then returned by the server.
after receiving the bucket the client searches for the most similar element with the non mutated p. since the server can only get the mutated p the client s privacy is preserved.
sec.
iv a will discuss the application of sbb in the sca scenario.
nevertheless the mutated p may still leak some information to the sca vendor.
sec.
v e will discuss the sbb leakage in the sca scenario.
mpc.
multi party computation mpc is a privacy preserving paradigm that allows participating parties to jointly perform computations over each party s local data.
following exact mpc protocols nothing except for the correct computation result is revealed to each party.
practical mpc protocols can be either garbled circuits based or secret sharing based methods .
we use crypten a secret sharing method for machine learning to implement our framework.
sca involves two parties including the client and the server.
the secret is split into two shares one for each party and the secret cannot be constructed without the agreement between the two parties.
to facilitate secure computations crypten implements arithmetic secret sharing and binary secret sharing.
in such cases private addition between two arithmetically secret shared values can be implemented by having each party locally sum their shares of and .
specifically each party p p needs to locally compute p p p. private multiplication between two arithmetically secret shared values is implemented with the assistance of random beaver triples which consists of with c ab provided by the trusted third party.
each party computes and and then reconstructs and through exchanging the shares.
the result can then be computed .while the application of mpc protocols provides cryptographically guaranteed privacy they often introduce significant overhead which is influenced by the number of parties and the complexity of the model.
there are always two parties in our scenario and the model remains unchanged after encryption.
iii.
p rivacy concerns in sca and motivation in this section we discuss the assets to be protected in sca sec.
iii a the leakage of existing sca techniques sec.
iii b and the motivation for proposing privacypreserving sca.
in the following discussion we assume the customer and the vendor hold the client and the server in fig.
respectively unless otherwise stated i.e.
private deployment .
a. assets of concern in sca valuable assets.
as shown in fig.
the online sca service involves three resources including the client s input in source or binary code format the sca report and the server s oss database with any embedding models used to establish the database .
we consider those resources listed in table i as valuable assets to be protected for privacy security.
as aforementioned in sec.
i the privacy of customers code and vendors oss database and model are essential.
as the importance of protecting customers source code and the vendor s model is self evident and securing the vendor s database has been discussed in sec.
i e.g.
binaryai keeps the database private we discuss the necessity of protecting the client s binary code and sca reports below.
privacy concerns for binary code.
although the compiled binary code is less comprehensible than the source code it still contains sensitive information that can be reverse engineered and disclosed.
therefore customers are unwilling to share binaries due to potential security and ip risks .
for instance leaking an online game s server executable results in deploying private servers easily and causing catastrophic financial loss .
even if a binary is publicly available developers may only release the secured binaries to protect their ip by hindering reverse engineering .
for instance many android apps are packed and obfuscated before release.
since reverse engineering on those binaries is challenging binary based sca works can hardly extract accurate features resulting in unreliable sca reports.
thus it is necessary to consider binary code as a valuable asset to be protected.
privacy concerns for sca reports.
leaking the sca report allows a potential attacker to know what oss is used by the customer thus if the customer uses an oss with a known vulnerability or weakness the attacker can directly exploit it instead of searching for vulnerabilities blindly which is often a time consuming step in real world attacks .
hence leaking the sca report can ease the attacker s effort in searching and exploiting software vulnerabilities.
for example once an attacker knows a web server uses the vulnerable log4j the attacker can reuse the disclosed attack resources e.g.
crafted payloads for other systems depending on the vulnerable log4j to attack the target web server.table i leaked resources of various settings.
denotes resources are leaked.
na means the sca solution does not rely on a trained model.
sca solutionvaluable assets tool customer side vendor side src bin report model db source based na centris tlsh private deployment na centris tlsh binary based binaryai sbb based na centris tlsh sbb mpc based centris dpcnn crypten b. existing sca solutions based on the input types we categorize existing sca techniques into source based sca and binary based sca .
besides we also observe that some companies deploy the server of source based sca on the customer side we refer to it as private deployment to protect customers proprietary source code.
these representative sca solutions and their privacy leakage are summarized in table i. assume a customer develops a software project p the source code of pispsrc and the compiled and stripped binary is pbin.
the vendor owns an oss database db and provides an sca service to detect the reused oss in p. besides binarybased sca may use an embedding model mfor signature generation due to the difficulties in analyzing binaries .
initially the customer owns psrcandpbin and the vendor owns db andm.
after the analysis the customer receives an sca report r. when psrc pbin and rare available to the vendor we mark them as in table i. the vendor s oss database db and model mare marked as if they are leaked to the customer.
the three sca solutions and their leakages are discussed separately below.
source based sca.
to perform sca the customer s client uploads psrcto the vendor s server which then generates the sca report rand sends it back to the client.
while oss db is not disclosed to the customer s client the sca server can access psrcandr.
therefore the customer s psrcandrare leaked while the vendor s db is secure.
private deployment of source based sca .
to address the customer s privacy concerns some vendors deploy the sca server on the customer side.
in this way the customer has full control over the sca client and server while the vendor needs to provide the oss database db.
hence the customer s psrc pbin and rare secure but the vendor s db is leaked.
binary based sca.
the customer s binary pbinis uploaded to the vendor s server while the source code psrcis not disclosed.
after receiving pbin the vendor performs reverse engineering and sca analysis generates the sca report r and sends it back to the customer.
as a result the vendor has access to pbinandr while its oss database db and model mfor signature generation are secure.
source based sca vs. binary based sca.
binary based sca is mainly proposed for scenarios where source code is unavailable to the vendor which can be caused by the usage of closed source libraries or by the customer s privacy concerns.
compared with source based sca binary based sca only leaks obscure binary code to the vendor.
however as discussed earlier a binary still exposes sensitive information when it is reverse engineered.
on the other hand binary analysis is difficult leading to a relatively low sca accuracy.
in sec.
v d we show that binaryai a commercial binary based sca tool has relatively low accuracy compared with source based techniques.
we thus deem binary based sca is far from an ideal privacypreserving solution.
motivation.
existing sca solutions have different privacy concerns.
source and binary based sca leaks customers assets while private deployment leaks vendors assets.
thus there is a dilemma between customers and vendors privacy in sca and addressing the dilemma with a privacypreserving sca solution is an urgent need.
iv.
p rivacy preserving sca f rameworks this section illustrates the privacy preserving sca frameworks where we expect that neither the client nor the server can learn the other s valuable assets see sec.
iii a .
specifically the vendor cannot learn the client s source code binary code and the sca report while the client cannot learn the vendor s database and model if any .
before introducing their designs in detail we first clarify the threat model.
threat model.
we consider a semi honest threat model where the client and the server are assumed to follow the protocol specification exactly .
however they are curious about each other s private information and record all intermediate results .
we assume the customer and the sca vendor are entities with a reputation and are not likely to conduct maliciously adversarial behaviors.
in order to design privacy preserving sca frameworks we adapt the privacy protocols to an existing sota sca solution.
specifically we enhance centris which is introduced in sec.
ii b. we select advanced and representative privacy preserving protocols to protect the privacy of the sca pipeline in two aspects protecting the signature matching process based on similarity algorithm i.e.
in fig.
and encrypting the package transactions between the client and the server i.e.
and in fig.
.
we tentatively adapt sbb to protect the signature matching process resulting in an sca framework referred to as centris tlsh sbb whose details are presented in sec.
iv a .
however we notice that such a solution leaves sca reports and oss db unprotected explained in sec.
v e we resort to the other approach that employs mpc to protect the privacy of different parties with encryption.
specifically we enhance centris with code embedding techniques referred to as centris dpcnn in sec.
iv b and then adapt the popular mpc framework crypten to protect it referred to as centris dpcnn crypten in sec.
iv c .
a. sbb based sca centris tlsh sbb fig.
presents the workflow of sbb based sca.
the client first dissects the input source repository into functions and then generates the signatures with tlsh .
by employing the sbb protocol to protect the private data a function s hash client reportserver 2hashing hash value phash value p 3mutation h oss functions oo ooo oooooodatabase db o ooo oo oo h oss ...h oss input the most similar hash protected by sbb protocolfig.
workflow of sbb based sca.
value pwill not be sent to the server directly.
instead the client mutates the hash value pinto a new hash value p and sends p to the server .
the server then searches for similar signatures of p i.e.
the red point in the oss db and replies to the client with a bucket of signatures close to p .
after receiving the bucket the client can identify the most similar signature in the bucket with p .
after repeating the process from to for all functions the client can report the sca results to the customer .
hyperparameters of sbb.
the sbb protocol has two hyperparameters the distance threshold for mutating the hash value ptop and the bucket size for the server to reply to the client.
intuitively if is too small the mutated hash value p is close to p which discloses the information of the client s source code however if is too large the server has to use a large which can result in high overhead in identifying the most similar signature in the bucket otherwise the exact similar signatures of pmay be missed in the replied bucket.
privacy concerns of sbb based sca.
as shown in fig.
the sbb protocol protects the client s private data by mutating the signatures before sending them to the server.
the client locally generates sca results according to the embeddings returned by the server.
thus the server has no access to the original signatures of source code and sca results.
however the mutated signatures are similar to the original ones and still disclose some information about the client s source code.
in sec.
v e we demonstrate that the server can infer the client s sca report given only the mutated signatures.
moreover because the server replies to the client with a bucket of similar signatures i.e.
thousands of signatures for each query the client can efficiently steal the server s oss db by repeatedly querying the oss db.
as a result we mark the customer s sca report and the server s oss db as leaked in table i. b.centris dpcnn since there is no mpc solution for tlsh we design a variant ofcentris tlsh that replaces tlsh with an embedding model which is a deep parallel convolutional neural network dpcnn that maps a source function to an embedding.
we use the euclidean distance between two embeddings to evaluate the similarity between two functions.
as mentioned in sec.
ii b centris tlsh identifies an oss project as reused when of its functions are recognized in the input.
an observation is that the threshold is too high for many oss projects .
hence like manyclient reportserver oss db2tokenizetensor encrypted tensor3encrypt encrypted modeloriginal model 3encrypt encrypted tensor oss db5decrypt tensor 6search reused functionsfunctions protected by crypteninput fig try enlarging the fontfig.
workflow of mpc based sca.
existing static analysis methods centris tlsh struggles to avoid false negatives and lowering the threshold cause a significant increase in false positives .
to further explore unleashing the full potential and achieving higher accuracy we consider assigning weights to the source functions following the idea of bat for weighted strings.
weight enhancements.
given a function fwith similar functions in the oss database let the number of oss repositories with similar functions be n and the lines of fbeloc .
we define the weight of fasw loc 5n .
the intuition behind this formula is that a function with many similar functions is less representative e.g.
helper functions and should consequently have a lower weight.
on the other hand a longer function usually contains rich semantics and should have a higher weight.
we then score each oss project in the oss db by the sum of the weights of its similar functions.
if an oss project s score exceeds the threshold it is identified as reused.
table ii shows the result when which is the threshold used by bat.
to efficiently search similar embeddings we use faiss an efficient similarity search library provided by meta to build an index for all embeddings.
c. mpc based sca centris dpcnn crypten to adapt mpc to sca we build a sca framework whose workflow is presented in fig.
.
compared with centris dpcnn the data transaction between the client and the server is protected by crypten.
before the online analysis the client first downloads the oss db from the server.
during online analysis the client initially dissects the input source repository into source functions and then tokenizes and converts each function into a plaintext tensor .
the client then encrypts the tensor with crypten and the server encrypts the original model with crypten .
then the client sends the encrypted tensor to the server for encrypted computation and receives the encrypted results .
after decrypting the results the client gets the plaintext embedding vectors of the functions with which the client can search for similar embeddings in the oss db and report the sca results to the customer .
shared oss vector database.
to avoid leaking the customer s privacy e.g.
sca reports to the sca vendor the client needs to download the oss db from the vendor s server and query the db locally.
otherwise if the vendor takes responsibility for conducting db queries sca reports will be revealed directly to the vendor.
as summarized in table i source and binary based sca have the same issue when the db is deployed on the vendor s server side.
nevertheless note that the oss db contains only embedded vectors i.e.
signatures of oss projects.
consequently without the embedding model which is exclusive to the client the client cannot exploit the db or hurt the vendor s privacy which will be introduced in the next few paragraphs.
on the other hand downloading the oss db requires additional storage space and network bandwidth.
we clarify that the cost is acceptable since the client only downloads the oss vector database around gbs instead of oss repositories over gbs .
privacy concerns of mpc based sca.
from the client s perspective the crypten protocol protects the client s private data by encrypting the data before sending it to the server.
thus the server cannot access the client s source code and sca results.
moreover no information about the client s data is leaked as the mpc protocol guarantees clients privacy.
a notable concern from the server s perspective is that the server s oss db is exposed to the client.
however we emphasize that the meaningful information of the oss database isstill protected .
to clarify the client uses the oss database to search for similar functions from oss projects.
each record in the oss database stores the embedding vector of a function and the information about the project to which this function belongs.
to use the oss database the client needs access to the embedding model to embed functions for similarity search.
however the model itself is notdisclosed to the client.
consequently even if the client has downloaded the oss database the client still needs to request the server s service to use the database.
in this way the only meaningful information accessible to clients is the set of included oss projects therefore the privacy of the oss database is protected.
another concern is that the client may approximate the server s plaintext model with sufficient query results we view this as orthogonal and mostly beyond the consideration of mpc based model protection.
to understand the mitigation we observe that the community has developed various techniques to alleviate such model stealing attacks such as limiting the query frequency updating the model periodically and detecting malicious queries.
second in our context issuing sufficient queries is time consuming due to the mpc protocol s overhead.
as a proof of concept we studied stealing of the oss database to approximate the source model.
the result is not promising about .
of the plaintext model f1 score and it takes about three days to finish all queries.
v. b enchmarking privacy preserving sca in line with the landscape of privacy preserving sca solutions presented in sec.
iv this section performs empirical evaluations and discusses the results.
we first introduce the dataset and the oss database used in our evaluation and then present the evaluation results.
we additionally discuss the privacy leakage of the sbb based sca at the end.
a. oss database construction building a large scale oss database is inevitable for realworld sca tasks.
existing sca techniques e.g.
centris and tplite build their oss database by downloading reputed osss from open source platforms like github and gitlab.
since prior works do not release their database or the dependency ground truth due to privacy protection policies we establish a new large scale database in this work.
in particular we build the database by identifying all c c software with github url