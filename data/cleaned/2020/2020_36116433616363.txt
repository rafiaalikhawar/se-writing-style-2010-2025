program repair guided bydatalog definedstatic analysis yu liu nationaluniversity ofsingapore singapore liuyu comp.nus.edu.sgsergeymechtaev university collegelondon unitedkingdom s.mechtaev ucl.ac.uk pavle suboti microsoft serbia pavlesubotic microsoft.comabhikroychoudhury nationaluniversity ofsingapore singapore abhik comp.nus.edu.sg abstract automated program repair relying on static analysis complements test driven repair since it doesnot require failingteststo repaira bug and it avoids test over f itting by considering program properties.duetotherichvarietyandcomplexityofprogramanalyses existingstaticprogramrepairtechniquesaretiedtospeci f icanalysers and thus repair only narrow classes of defects.
to develop ageneral purposestaticprogramrepairframeworkthattargetsa wide range of properties and programming languages we propose tointegrateprogramrepairwithdatalog basedanalysis.
datalog solversareprogrammable f ixedpointengineswhichcanbeusedto encodemanyprogramanalysisproblemsinamodularfashion.the programunderanalysisisencodedasdatalogfacts whilethe f ixed point equations of the program analysis are expressed as recursive datalog rules.
in this context we view repairing the program as modifyingthecorrespondingdatalogfacts.thisisaccomplished by a novel technique symbolic execution of datalog that evaluatesdatalogqueriesoverasymbolicdatabaseoffacts insteadof a concrete set of facts.
the result of symbolic query evaluation allows us to infer what changes to a given set of datalog facts repairtheprogramso thatitmeetsthedesiredanalysisgoals.we developedasymbolicexecutorfordatalogcalledsymlog ontop ofwhichwebuiltarepairtoolsymlogrepair.weshowtheversatilityofourapproachonseveralanalysisproblems repairingnull pointerexceptionsinjavaprograms repairingdataleaksinpython notebooks andrepairingfourtypesofsecurityvulnerabilitiesin solidity smart contracts.
ccsconcepts softwareanditsengineering automaticprogramming automatedstatic analysis theory ofcomputation constraint and logic programming information systems query languages .
corresponding author esec fse december sanfrancisco ca usa copyright held bytheowner author s .
acm isbn979 .
programrepair static analysis datalog symbolic execution acm referenceformat yu liu sergey mechtaev pavle suboti and abhik roychoudhury.
.
programrepairguidedbydatalog de f inedstaticanalysis.in proceedingsof the31stacmjointeuropeansoftwareengineeringconferenceandsymposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.https introduction programanalysisdeterminesifthebehaviourofagivenprogram satis f iesacertainproperty.programrepairbasedonstaticprogram analysis is an attractive technique since in contrast to test driven programrepair itdoesnotrequireexecutingtheprogram thus signi f icantly simplifyingdeployment and it avoids test over f itting by taking program properties into account.
a plethora of static analysis techniques exist each characterised by a unique set of underlyingmechanisms targetprogramminglanguages andtarget programproperties.
these characteristics signi f icantlyimpact the implementation and optimisation of each analysis.
existing program repair methods based on static analysis do not accommodate this diversity and are inherently tied to speci f ic analysers.
this restricts theircapacity torectify awide class ofdefects.
thegoalofthisworkistodesignamodularstaticprogramrepair systemthat f ixesbugsviolatingawiderangeofprogramproperties acrossmultipleprogramminglanguages.themodularityimplies that the conceptual components the modeling of programming languagesemantics analysisalgorithms searchspaceconstruction and patch generation are independent and reusable.
such a design radicallyreducesthecomplexityofcreatingastaticprogramrepair systemcapableofefficientlyaddressingawidespectrumofdefects.
our proposed architecture leverages the modular static analysis frameworkbasedondatalog.inthissetup datalogactsasadomain speci f iclanguage dsl forde f iningprogramanalyses.aprogramis encodedintoadatabasei.e.
asetofinputrelations andtheprogram analysisconstraintsarede f inedasadatalogquery.adatalogsolver acts as a programmable f ixed point engine that computes a least f ixedpointsolutiontotheprogramanalysisconstraints.datalog enables both a succinct and modular encoding of the program analysis while providinghigh efficiency and interoperability .
tointroduceprogramrepairtothissetup weproposeanovel approachcalledsymbolicexecutionofdatalog sedl .
wede f ine therepairsearchspacebyinjectingsymbolsintotheinputrelations thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 9 san francisco ca usa yuliu sergey mechtaev pavle suboti andabhik roychoudhury buggy pl s semanticsmodeling constructionsearch space execution of querysymbolic solvingconstraintmappingsource codesymbolic symlogviolationdatalog analysisaschange ofprogram program facts datalogqueryfactspatch datalogfacts inference conditions figure symlogrepair a program repair system using symbolicexecution ofdatalog sedl implemented insymlog.
representing the buggy program.
these symbols denote unknown constants unknown predicates and unknown truthfulness of facts inthedatabase.theresultingsymbolicdatabaserepresentsaset of changes to the original database.
sedl executes the datalog analysisqueryonthesymbolicdatabase andtheoutcomeofthis execution summarises how values from various subdomains when substituted in place of symbols impact the inference of various output facts.
these subdomains expressed as logical constraints over the symbols capture the dependencies between the input and outputofthequery inanalogywithpathconditionsinconventional symbolicexecution wecalltheminferenceconditions.
givenan inferenceconditionforanoutputfact anysatisfyingassignment of symbols enables the inference of this fact and any falsifying assignmentdisablesitsinference.torepairtheprogram weusean smtsolverto f indavaluationofsymbolsthatproducesthedesired query output such as the absenceofproperty violations.
we implemented sedl in a tool called symlog which utilises thestate of the artdatalogenginesouffl .symlogtransforms agivensymbolic databaseandqueryintoameta program which whenexecutedusingaconventionaldatalogevaluator produces the result of symbolically executing the original query on the original database.
to mitigate state explosion we implemented two optimisationtechniquesforthemeta program.first wegrouppossible valuations of symbols into equivalent classes to eliminate redundant exploration of identical proof trees during symbolic datalogevaluation.
second we apply delta debugging toefficiently identify dependencies between input and output facts.
the key advantage of the meta programming approach is that it allows ustoleveragetheoptimisationsprovidedbyexistingdatalogengines without modifying the engines.
lastly we implemented symlogrepairthatgeneratescandidatepatchesbysolvingsymlog s inference conditions for program analysis outputs with z3 to avoid property violations and then ranks the candidates based on minimality.
the architecture of symlogrepair is shown in figure .
to demonstrate the modularity of the proposed architecture we specialisedsymlogrepairforsixtypesofdefectsacrossthreeprogramminglanguages.first werealised symlogrepair whichusessedltorepairnullpointerexception npe bugsinjava programs .weusedoop tomodelthesemanticsofjava and digger to de f ine the analysed property.
second we realised symlogrepair the f irst approach for repairing data leaksinpythonnotebooks .weusetherulesbyyang et al.
to model the semantics of python and to de f ine the analysed property.finally werealised symlogrepair forrepairing four classes of security vulnerabilities in solidity smart contracts access control unhandled exception reentrancy and locked ether.
we use securify2 to model the semantics of smart contracts andto de f inethe analysedproperties.
inourevaluation symlogrepair correctlyrepaired8 outof10npebugsdetectedbydigger outperformingnpex by correct patch and alpharepair and incoder by and correctpatchesrespectfully.
symlogrepair correctly repaired out of notebook preprocessing leakage bugs detected bytheanalyser whilealpharepairandincoderfailedtorepairany.
symlogrepair correctly repaired out of vulnerabilitiesinsmartcontracts outperformingelysium by correct patches.
our optimisations played a key role in enabling the generation of patches as our tool without optimisations repair fewer bugsdueto running outof memory.
the contributionsofour work are summarisedas follows astaticprogramrepairarchitecturebasedondatalog where repair is formulated as the problem of modifying a given databaserepresentingthebuggyprogramtomakethequery representing the analysisdetectzeroproperty violations symbolic execution of datalog sedl the enabling component of our architecture which identi f ies how changes to the databaseimpact the result of aquery anefficientimplementationofsedlinatoolcalledsymlog1 andits applicationto program repair symlogrepair.
symlogrepair instances symlogrepair for f ixingnpebugsinjavaprograms symlogrepair for repairing data leak defects in python notebooks and symlogrepair for repairing four classes ofsecurityvulnerabilitiesinsoliditysmartcontracts aswell as an evaluation of theseinstancesonrealistic bugs.
overview in this section we give an overview of our approach.
we f irst explain how datalog is used to de f ine a program analysis.
then we demonstrate how sedl the key technical novelty of this work symbolicallyexecutesthisanalysis.finally weshowsymlogrepair f ixes anull pointer exception npe defect.
sincethede f initionsofpracticalanalysesrequirehundredsof lines of code and the semantics of real world programming languagesisextremelycomplex fortheillustrativepurpose weuse simpli f iedlanguageandanalysis.thelanguagecontainselementarystatements variableinitialisations assignmentsandmethod calls and call statement guards that check if a variable is not null.
the formalgrammarofthis languageisgiven in figure .
consider the following program written in our simple language x null y x y.call thisprogramtriggersannpeas ywillbenullwhen y.call is performed.
the remainder of this section will describe how this bugcan be detectedand f ixedwithdatalog.
1implementation of symlogand symlogrepair 1217program repairguidedby datalog definedstatic analysis esec fse december3 9 san francisco ca usa x null y x y.call flow .
flow .
assign null x .
assign y x .
call y .
a a program s cfg and its edb representation.npe v l call v l null v l !guard v l .
null v l flow l1 l assign null v l1 .
null v l flow l1 l null v l1 !assign v l1 !assign obj v l1 .
null v l flow l1 l assign v v1 l1 null v1 l1 .
b npe analysis expressed as a datalog query.
x null y x if y!
null y.call guard x .
c repairwithguardandthecorresponding edb change.
x null y x y.call x new obj flow .
flow .
flow .
assign obj x .
d repair with assignment and thecorresponding edb change.
flow assign null x null x flow assign y x null y call y !guard y npe y e aproof treeof theoutput of npe analysisquery demonstratingthepresence of an npe bug.
figure a program witha null pointer exception npe bug an analysisthat detects this bug its prooftree andtwo repairs.
u1d7093flow u1d6fc1 u1d6fc2 assign null x u1d7091 u1d6fc1 1null x u1d6fc2 u1d7094flow u1d6fc2 u1d6fc3 !assign x u1d6fc2 u1d7096assign obj u1d6fc5 u1d6fc6 u1d7094 u1d6fc3 u1d7096 u1d6fc5 u1d465 u1d6fc6 u1d6fc2 null x u1d6fc2 null x u1d6fc2 u1d7092flow assign y x u1d7092null y call y u1d7095guard u1d6fc4 u1d7095 u1d6fc4 u1d466.alt npe y figure asymbolicprooftree in twoparts ofan npeafter inserting astatementbetween the nodes and .
stmt var new obj var null var var call guard var !
null call var .call if guard var .call figure example programming language.
.
programanalysis with datalog datalogisaquerylanguagebasedonlogicprogramming.adatalog query is a set of horn clauses comprising of a set of body predicates left part and a head predicate right part .
the symbol showsthattheleftpartislogicallyimpliedfromtherightpart.
a datalog query is executed against a database of facts referred to as the extensional database edb and produces a set of derived facts referredtoastheintensionaldatabase idb .sincedatalog implements the semantics of f ix point computation and many program analysis algorithms are instances of f ix point computation datalog is often used asa language for de f ining program analyses.
to analyse a program with datalog the program is represented asanedb.forinstance wecanconstructaprogram scontrol f lowgraph cfg asasetoffactsasshownin figure2a.inthisedb the predicate flowencodes arcs of the cfg e.g.flow states that thereisanarcbetweenthenodes1and2.thefact assign null x states that the variable xis assigned to null in the node assign y x states that the value of xis assigned to y in the node and call y states that a method of the object storedin yiscalledinthe node .
figure2b showsanexampleanalysisfordetectingnpes.this analysisde f inestwopredicates.thepredicate npe v l statesthat there may be a dereferencing of null stored in the variable vin thenodel.thepredicate null v l statesthatthevariable vmay storenullattheentryofthenode l.thepredicatesarede f inedusing four rules.
the f irst rule states an npe happens when a method of anullobjectiscalledwithoutaguard.thesecondrulestatesthat a variablemay be nullatthe entry ofa nodeifitis assignedto null inaparentnode.thethirdrulestatesthatavariablemaybenull attheentryofanodeifitisnotassignedattheentryofaparent node and may be null at the entry of that parent node.
the fourth rulestatethatavariablemaybenullattheentryofanodeifitis assignedto avariable that maybe null inaparentnode.
whenaqueryisexecutedonanedb adatalogenginecomputes allfactsthatcanbeinferredfromthedatabaseusingtherulesofthe 1218esec fse december3 9 san francisco ca usa yuliu sergey mechtaev pavle suboti andabhik roychoudhury query.forexample fortheaboveprogramandanalysis datalog infersthefact npe y statingthattheremaybeannpeinthe node .
in figure 2e a proof tree visualises how this fact is derived.
.
symbolic execution ofdatalog the key technical novelty of this work is sedl that determines how a change to the edb affects the output of a given query.
a set of changes to the database is encoded using symbols and then the queryisexecutedsymbolically.theresultofsymbolicexecutionof adatalog querycompactlysummarisesthe relationsbetweenthe inputsymbolsandthe outputofthe query.
consider the following symbolic edb obtained from the edb in figure2a byinjectingsymbolicconstants u1d6fc u1d456representingunknown constantsandsymbolicsigns u1d709 u1d456representingunknowntruthfulness ifthe associatedfactsare true offalse u1d7091flow .
assign y x .
u1d7092flow .
call y .
u1d7093flow u1d6fc1 u1d6fc2 .
u1d7095guard u1d6fc4 .
u1d7094flow u1d6fc2 u1d6fc3 .
u1d7096assign obj u1d6fc5 u1d6fc6 .
assign null x .
anyvaluationofthesesymbolscorrespondstoaconcreteedb.for example the original edb corresponds to the following valuation u1d7091 u1d447 u1d7092 u1d447 u1d7093 u1d439 u1d7094 u1d439 u1d7095 u1d439 u1d7096 u1d439 ... .
executingtheanalysisin figure2b onthissymbolicedbwith sedl yields the fact npe y and the inferencecondition u1d719for this fact de f inedas a f initesetofdisjuncts u1d719 u1d7091 u1d7092 u1d7095 u1d6fc4 u1d466.alt u1d7092 u1d7093 u1d6fc1 u1d7094 u1d6fc3 u1d7096 u1d6fc5 u1d465 u1d6fc6 u1d6fc2 u1d7095 u1d6fc4 u1d466.alt ... each disjunct represents a subset of programs encoded in the symbolicedbwherethedefect npe y isdetectedusingthesame proof.
the f irst disjunct corresponds to the original program.
the seconddisjunctcorrespondstobuggyprogramswithastatement insertedbetween the nodes 1and2 for example x null y new obj y x y.call a symbolic proof tree corresponding to the second disjunct is giveninfigure3.inthisprooftree thelabelsateachproduction capture the conditions under which the rule can be applied.
the disjunct iscomputedas aconjunction ofalltheselabels.
.
fixing annpewith symlogrepair wenowdemonstratehowtoapplysedlforprogramrepair.given abuggyprogramandadatalog de f inedanalyserthatdetectsthe bug symlogrepair de f ines the patch search space by injecting symbolsintoanedbrepresentationoftheprogram.themethodof search space construction is determined by a domain expert based ontheanalysedpropertyandthemodellingoftheprogramming languagesemanticsintheedb.
section5 showshowtogenerate searchspacesforrealisticanalyses.hereweassumethatthesearch spaceisde f inedbythe symbolic edb in section .
.since not all assignments of symbols may correspond to syntactically valid programs we restrict them with structural constraints u1d713.
for the example above the structural constraints capture that theflowrelationdoesnotformbranchesorcycles andthateach node contains asinglestatement.
to generate a patch for the program we construct and solve a repair condition.
a repair condition is a formula over symbols injected into the edb representation of the program such that any satisfying assignment of this formula corresponds to a program for which the analysis does not infer property violations.
we obtain this condition by symbolically executing the analysis using our implementationofsedl symlog.fortheexampleabove therepair conditionis u1d719 u1d713 sinceitensuresthefact npe y willnot be inferred andthe program issyntactically valid.
sincerepairconstraintsacceptmultiplesolutions weonly consider minimal solutions such thatall other satisfying assignments change a superset of values corresponding to the original program.
a minimal solution for the above example is u1d7091 u1d447 u1d7092 u1d447 u1d7093 u1d439 u1d7094 u1d439 u1d7095 u1d447 u1d6fc4 u1d466.alt ... .
itcorrespondsto the cfg andedb presentedin figure 2c.
anotherminimal solution shownin figure 2d is u1d7091 u1d439 u1d7092 u1d447 u1d7093 u1d447 u1d7094 u1d447 u1d7095 u1d439 u1d7096 u1d447 u1d6fc1 u1d6fc2 u1d6fc3 u1d6fc5 u1d465 u1d6fc6 ... .
thesecond solutionshows theability ofour approachto invent newvaluesthat do not exist inthe originaldatabase.
symbolic execution ofdatalog in this section we introduce relevant background on datalog and de f ineour key technical novelty symbolic executionof datalog.
.
background datalog is a query language based on horn clauses in the form l0 l1 ... l u1d45b where each l u1d456is aliteralp t1 ... t u1d45b such that p is apredicate andt u1d456areterms.
a term is either a constant or a variable.
factsare ground literals i.e.literals without variables.
aground substitution u1d703 u1d4651 u1d4501 ... u1d465 u1d45b u1d450 u1d45b is a mapping from variablestoconstants.wedenoteanapplicationofthesubstitution u1d703to the term tast u1d703 and to the literal lasl u1d703.
edb extensional database is a set of input facts.
idb intensional database is a set of output facts determined by the query.
the herbrand base hb is the set of all expressible facts.
ehbdenotes the set of all hb factswherethepredicateappearsinedb ihbdenotesthesetof allhbfacts where the predicate appears in idb but not edb.
the semantics of a datalog program u1d443can be represented as a function u1d510 u1d443 2ehb 2ihbthat foreach existential database computesall idb factsthatlogicallyfollowfromthatdatabase.datalogallows specifyingagoaltoselectasubsetofitsoutputsthataresubsumed bythegoal.
forexample the fact f issubsumedbythegoal f x x butf isnot.
consider the datalog query u1d443infigure 2b that speci f ies an npe analysis for a simple programming language de f ined in figure .
let the cfg of an analysed program be represented via an edb consistingofnodes arcs suchas flow andinformationabout statements such as the fact assign y x stating that the 1219program repairguidedby datalog definedstatic analysis esec fse december3 9 san francisco ca usa value ofxis assigned to yin the node .
the semantics of such program u1d510 u1d443 is a function that for an cfg represented as a set of factsreturns the setofidb facts npeandnullas follows u1d510 u1d443 parenlefttpa parenleftexa parenleftexa parenleftexa parenleftexa parenleftexa parenleftbta flow flow assign null u1d465 assign u1d466.alt u1d465 call u1d466.alt parenrighttpa parenrightexa parenrightexa parenrightexa parenrightexa parenrightexa parenrightbta npe u1d466.alt null u1d465 null u1d466.alt tode f ine u1d510 u1d443 we use theproof theoreticinterpretation ofdataloginwhichthemeaningofaprogramisde f inedasthesetofall facts that can be inferred from the program.
for a given rule l0 l1 ... l u1d45band a set of ground facts f1 ... f u1d45b the output fact f0 can be inferred in one step from f1 ... f u1d45bif there is a substitution u1d703such that for any u1d456 .. u1d45b f u1d456 l u1d456 u1d703.
this procedure is referred tointhedatalogliteratureasthe elementaryproductionprinciple epp .agroundfact u1d439canbeinferredfromaprogram u1d443ifeither u1d439 u1d443or u1d439canbeinferredbyapplyingeppa f initenumberoftimes.
thesequenceofapplicationsofeppusedtoinferafact u1d439from u1d443 forms aproofof u1d439from u1d443.
aproofcanberepresentedusinga prooftree.foragivendatalog query u1d444 anedb u1d438 andagroundfact u1d439 aprooftreeof u1d439from u1d438 is the tree u1d439 u1d445 u1d703 u1d4611 ... u1d461 u1d45b such that u1d45b 0iff u1d439 u1d438 otherwise u1d445 l0 l1 ... l u1d45bis a rule from u1d444 u1d439 l0 u1d703 and u1d461 u1d456are proof trees ofl u1d456 u1d703.forthenpeanalysisdescribedabove theprooftreeofthe factnpe y isvisualisedin figure 2e .
.
semantics ofsedl the goal of symbolic execution of datalog sedl is to identify how varyingvaluesinadatabaseimpactstheresultofexecutingaquery onthisdatabase.toachievethis sedlexecutesadatalogqueryon anabstracteddatabasewhichrepresentsasetofconcretedatabases.
the result of symbolic execution is a set of pair of output facts and logicalconstraintsthatenabletheinferencethatfacts.throughthis process sedlsuccinctlysummarisestheoutcomeofexecutingthe query onallofthe encodedconcrete databases.
by analogywith symbolicexecution ofconventional programs we abstract a given database by injecting symbolsthat represent unknowninformation.sedlusesthreecategoriesofsymbols symbolicconstants symbolicpredicatesandsymbolicsigns.wedenote symbolic constants as u1d6fc u1d6fd u1d6fethat range over f inite domains of numbers strings etc.
we use them to represent facts with unknown constants e.g.
flow u1d6fc u1d6fd .
we denote symbolic predicates as u1d70cthat rangeoverallpredicates.weusethemtorepresentfactswithunknown predicates e.g.
u1d70c .
we denote symbolic signs as u1d709that range over booleans.
we associate a symbolic sign with a fact to control if the fact is positive or negative.
collectively we refer to such symbols as u1d70e1 ... u1d70e u1d45b over domains u1d4371 ... u1d437 u1d45b.
all thesesymbolscanbeusedsimultaneouslytorepresentfactswith unknownpredicates constants andtruthfulness.
we consider the set of constraints over the symbols that include the standard logical connectives and equalities between symbols and constants from the corresponding domains.
for example thefollowingisavalidconstraint u1d7091 u1d7092 u1d6fc u1d6fe u1d6fd uni22605 .
wedenotetheevaluationoftheformula u1d719valueundertheinterpretation u1d463 u1d456 u1d437 u1d456 u1d456 as u1d719 u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b .we call the set of all facts expressible using given predicates constants andsymbolsthe symbolicherbrandbase denotedas shb.
we similarly de f ine sehbandsihb.
given a symbolic fact u1d453 shb we de f ineits concretisation withthevalues u1d463 u1d456 u1d437 u1d456 u1d456 denotedas u1d453 u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b asthefactobtainedbyreplacing all symbols with their concrete counterparts.
given a symbolic edbe sehb we de f ine its concretisation with the values u1d463 u1d456 u1d437 u1d456 u1d456 denotedas e u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b astheedbobtained fromeby concretising all symbolic facts and removing all facts corresponding to symbolic signswiththe negative interpretation.
wede f inethe semanticsofsymbolicexecution ofadatalogprogram u1d443as a function u1d516 u1d443 2sehb 2sihb .
given a symbolic edbe this function returns a set of pairs of symbolic facts and logicalconstraints.werefertothesepairsasthesetof symbolicoutputsandthecorresponding inferenceconditions .thelatterresemble path conditions in conventional symbolic execution in that they specify under which condition the outputis generated.
speci f ically for each concretisation of ewith u1d463 u1d456 u1d437 u1d456 u1d456 the output of the query is identical to the set of all concretisations of the outputs ofsedl on ecorresponding to the positive inference conditions u1d4631 u1d4371 ... u1d463 u1d45b u1d437 u1d45b.
u1d510 u1d443 e u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b u1d453 u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b u1d453 u1d719 u1d516 u1d443 e u1d719 u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b the inference of a symbolic fact from a symbolic edb can be visualised using a symbolic proof tree a proof tree in which productions are annotated with logical constraints that enable that productions.
formally for a given datalog query u1d444 a symbolic edbe and a symbolic fact u1d439 a symbolic proof tree of u1d439frome is the tree u1d439 u1d445 u1d719 u1d7030 ... u1d703 u1d45b u1d4611 ... u1d461 u1d45b such that u1d45b 0iff u1d439 e otherwise u1d445 l0 l1 ... l u1d45bis a rule from u1d444 u1d439 l0 u1d7030 u1d461 u1d456are symbolicprooftrees of l u1d456 u1d703 u1d456 and thesubstitutions u1d7030 ... u1d703 u1d45b are identicalundereachsatisfyingassignmentof u1d719.apartfromthat we areonlyinterestedinfeasiblesymbolicprooftrees thatissymbolic prooftreeswherealllogicalannotationsareconsistentwitheach other sinceinthiscasethesymbolicprooftreecorrespondstoat leastone concrete prooftree for aconcrete database.
to illustrate sedl consider the datalog query in figure 2b and thesymbolicdatabasein section2.
.asymbolicprooftreeofthe factnpe y inferred by sedl from this database is given in figure .
the inference condition for this fact is formed as the conjunction ofallconstraintsinthe symbolic proof tree u1d7092 u1d7093 u1d6fc1 u1d7094 u1d6fc3 u1d7096 u1d6fc5 u1d465 u1d6fc6 u1d6fc2 u1d7095 u1d6fc4 u1d466.alt .
encoding a neighbourhoodofadatabase although sedl can execute an abstracted database that is fully symbolic practicalapplicationssuchasprogramrepairdescribed insection bene f it from injecting symbols into an existing concretedatabase thus considering aneighbourhood of thisconcrete database.
let u1d438be an edb its u1d458 neighbourhood n u1d438 u1d458 represents thesetofdatabasesdifferedfromtheoriginaloneinatmost u1d458facts n u1d438 u1d458 u1d438 u1d438 ehb u1d438 u1d438 u1d458 where is symmetric difference and u1d458is a user de f ined parameter.
1220esec fse december3 9 san francisco ca usa yuliu sergey mechtaev pavle suboti andabhik roychoudhury torepresentaneighbourhoodofconcretedatabaseusingsymbols we augment the symbolic edb with structural constraints.
forexample thesymbolicencodingof u1d458 neighbourhood n u1d438 u1d458 foranedb u1d438canbede f inedthroughapairofasymbolicedb e andconstraints u1d713such that n u1d438 u1d458 e u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b u1d713 u1d70e1 u1d4631 ... u1d70e u1d45b u1d463 u1d45b u1d463 u1d456 u1d437 u1d456 toillustrate such encoding considerthe edb node .
flow .
node .
its1 neighbourhoodcan be encodedas the symbolic edb node .
assoc.with u1d7091flow .
assoc.with u1d7094 node .
assoc.with u1d7092flow u1d6fd u1d6fe .assoc.with u1d7095 node u1d6fc .assoc.with u1d7093 andthe structuralconstraints u1d7093 u1d7095 atleast u1d7091 u1d7092 u1d7094 u1d7091 u1d7092 u1d7094 atmost u1d7093 u1d7095 whereatleastandatmostarecardinalityconstraints.inthecontext ofprogramrepairdrivenbydataloganalysis section5 showshow to encode an analysis speci f ic neighbourhood consisting of only syntactically valid programs.
realisation ofsedl insymlog symlogemploysameta programmingapproachtoimplementing sedl.
speci f ically a given datalog query and a symbolic edb are transformed into a meta query and ameta edb in such a way that executingthemeta queryonthemeta edbwiththestandarddatalogsemanticsyieldstheoutputofsymbolicexecutionoftheoriginal queryontheoriginalsymbolicdatabase.wecollectivelyreferto themeta queryandthemeta edbasthe meta program .theadvantage of this approach is that it enables us to reuse existing efficient implementationsofdatalog andmakessymlogindependentofthe datalogevaluation strategy.
.
na veencoding ofsedl we f irst describe a na ve implementation of sedl.
it explicitly enumeratesallvaluesfromthedomainsofsymbolsinsidethemetaprogram andcomputeshoweachofthemrelates tothe outputof thequery.toachievethis weaugmentallpredicatesusedinthe querywithauxiliaryvariablesthatstoretheassignmentofsymbolic constantstoconcretevalues whichwerefertoas symbolicbindings .
to ensure that assignments of symbolic constants are consistent within a derivation of each output fact as per the de f inition of symbolic proof trees in section .
we propagate the values of symbolic bindings acrosseachrule.
assumethatagivensymbolicedbcontainsthesymbolicconstants u1d6fc1 ... u1d6fc u1d45b.weintroduceauxiliarydatalogvariables u1d4361 ... u1d436 u1d45b forsymbolicbindings.foreachrule themeta queryadds u1d4361 ... u1d436 u1d45b tothe headand eachliteralofthebody.forinstance wetransform the f irstrulede f ining nullinfigure 2b into null v l u1d4361 ... u1d436 u1d45b flow l1 l u1d4361 ... u1d436 u1d45b assign null v l1 u1d4361 ... u1d436 u1d45b .to transform the edb into a meta edb the na ve approach enumeratesallinstantiationsofsymbolicconstantswiththevalues from the corresponding domains.
for example given the edb fact flow u1d6fc1 we transform itintothe rule flow u1d4361 u1d4361 ... u1d436 u1d45b domain alpha 1 u1d4361 ... domain alpha n u1d436 u1d45b .
whereeachpredicate domain alpha u1d456 calledsymbolicdomainpredicate is truefor allvaluesfrom the domain of u1d6fc u1d456.after the metaprogram is executed the resulting values of symbolic bindings capture the assignment of symbolic constants that enable the generation ofcorresponding outputfacts.
to support symbolicpredicates thena ve approach introduces auxiliary integer variables u1d443 u1d456calledpredicate selectors for each symbolic predicate to identify which of the concrete predicates from the corresponding domain is enabled.
for each rule the metaquery adds these variables to the head and each literal of the body.
inthemeta edb wetransformeachfactwithasymbolicpredicate say u1d70c where the domainof u1d70cis p1 p2 intothe rules p1 u1d443 p .
p2 u1d443 p .
afterthemeta programisexecuted theresultingvaluesofpredicate selectors indicate if output facts can be inferred by relying on variousinstantiationsofthe symbolic predicates.
to support symbolic signs the na ve approach introduces auxiliary boolean variables u1d446 u1d456calledsign selectors for each fact with a symbolicsign.togenerateameta edb wetransformeachfactwith a symbolic sign say u1d439de f ined as u1d709p into the fact p true and each other fact with the same or a different predicate say q intoq false .togenerateameta query we transform each ruleby addingsign selectors to the head andeach literal of the body and also additional constraints that state that the head depends on u1d439if at least one of the literals of the body dependson u1d439.forexample giventherule t x y v x r y we transform itintothe rule t x y u1d446 v x u1d4461 r y u1d4462 u1d446 u1d4461 u1d4462.
after the meta program is executed the resulting values of sign selectors indicate if output facts can be inferred with or without relying onthe fact withasymbolic sign.
bycomputingthevaluesofauxiliaryvariables symbolicbindings predicateselectorsandsignselectors itispossibletoreconstruct inference conditions for each output fact.
however since the domains of symbolic constants and the number of facts with symbolicsignscanbehuge thisapproachdoesnotscaletorealistic databases which motivated us to design optimisations to avoid explicit enumerationfor thesetwocategoriesof symbols.
.
optimisation forsymbolic constants toaddressthesearchspaceexplosionofthena veapproach instead of enumerating all possible values of symbolic constants in the de f inition of symbolic domain predicates we explicitly maintain abstractsymbolsduringevaluation.foreachsymbolicconstant u1d6fc with the domain u1d437de f ined by the symbolic domain predicate in themeta programdescribedin section .
we optimisethemetaprogrambycompressing u1d437inawaythatdoesnotchangetheoutput ofthequery.weseparatelyhandletwocategoriesofconstantsin 1221program repairguidedby datalog definedstatic analysis esec fse december3 9 san francisco ca usa u1d45d ... u1d450 u1d456 ... e depend u1d45d u1d456 u1d450 u1d456 u1d43f ... u1d45d ... u1d450 u1d456 ... .... u1d444 depend u1d45d u1d456 u1d450 u1d456 u1d43f ... u1d45d1 ... u1d44b u1d456 ... ... u1d45d2 ... u1d44b u1d457 ... .... u1d444 u1d44b u1d456 u1d44b u1d457 u1d450.depend u1d45d1 u1d456 u1d450 depend u1d45d2 u1d457 u1d450 figure constraints de f ining the relation depend u1d444is the query eisthesymbolicedb u1d450 u1d456 u1d44b u1d456isaconstant symbolicor concrete avariable appearing as the i thpredicateparameter u1d44b u1d456 u1d44b u1d457denotes that u1d44b u1d456and u1d44b u1d457are identical variables.
thedomain thoseconstantsthatalreadyexistsomewhereelsein the program andpreviously unseen constants.
to handle constants that already exist somewhere in the program weconsiderallsuchconstants u1d450from u1d437 whichwerefertoas uni f iableconstants of u1d6fc appearingeitherintheedborthequery thatthereexistsasymbolicprooftreewhoseproductionruleannotations contain a dependency between u1d6fcand u1d450 e.g.a constraint u1d6fc u1d450.
if such dependency does not exist in any of the symbolic trees weprunetheseconstantsfromthesymbolicdomainpredicate sincethelackofinteractionswithexistingconstantsimpliesthat theseelementsofthedomaincanbehandledinthesamewayas previously unseen constants.
however identifying the exact set of uni f iable constants is impractical because that would require computing all symbolic proof trees in advance.
instead we compute an overapproximationofthissetbyusingtherelation depend u1d45d u1d456 u1d450 thatstatesthatthei thparameterofthepredicate u1d45dmaydependon the symbolic orconcrete constant u1d450.
this relationcan becomputed using constraints de f ined in figure 5via a f ixed point computation algorithm.forthesymbolicconstant u1d6fc weselectallpairs u1d45d u1d457 u1d456 u1d457 suchthat depend u1d45d u1d457 u1d456 u1d457 u1d6fc forall u1d457.then anoverapproximationof the setofuni f iableconstants for u1d6fccan be de f inedas uni f iable u1d6fc u1d437 uniondisplay.
u1d457 u1d450 depend u1d45d u1d457 u1d456 u1d457 u1d450 .
to handle the elements of u1d437that do not exist anywhere else in the program which we refer to u1d437new u1d437 uni f iable u1d6fc we introduceextraconstantsthatserveasabstractrepresentationof u1d437new.
we also consider interactions between multiple symbolic constants.
for example assume that the symbolic edb contains symbolicconstants u1d6fcand u1d6fd.weintroduceextraconstants u1d45b1and u1d45b2toencodeallpartitioningsof u1d6fcand u1d6fdintoequivalenceclasses.
given the edb fact flow u1d6fc we transform itintothe rules flow u1d4361 u1d4361 u1d4362 domain u1d4361 u1d4362 .
domain x y domain alpha unifiable x domain beta unifiable y .
domain u1d45b1 y domain beta unifiable y .
domain x u1d45b1 domain alpha unifiable x .
domain u1d45b1 u1d45b1 .
domain u1d45b1 u1d45b2 .
wheredomain alpha unifiable isthesetofuni f iableconstants for u1d6fc thesamefor u1d6fd anddomainistheoptimisedsymbolicdomain predicate.
the f irst rule de f ining this predicate states that symbolic constants may take any of the values of corresponding uni f iable constants.thesecondandthethirdrulesstatethatoneofthemmay takeanew previouslyunseenvalue.thelasttworulesstatethatboth symbolic constants can take previously unseen values either equal rulefour ordifferent rule f ive .aftersuchmeta program is executed u1d45b1and u1d45b2can be replaced with u1d6fcand u1d6fdby adding constraints imposed by the corresponding equivalence classes.
for example themeta programoutputfact null v u1d45b1 u1d45b1 u1d45b2 wouldcorrespondto null v u1d6fc underthe condition u1d6fc uni2209uni f iable u1d6fc u1d6fd uni2209uni f iable u1d6fd u1d6fc uni2260 u1d6fd .
optimisation forsymbolic signs supporting symbolic signs is challenging because there are edb ways to negate facts in the database.
to avoid a search space explosion we generate inference conditions for only u1d458selected outputs undertheassumptionthatatmost u1d45bofthesymbolicfactsarenegative.thisassumption holds inourapplicationto program repair since we only explore a neighbourhood of a given database and program repairconstraints only dependonthe inferenceof a small numberofoutputfacts.forbrevity weonlyexplainhowtosupport symbolic signsfor u1d458 u1d45b .
foragivenfactwithasymbolicsign u1d43c theencodingin section4.
enables us to determine if an output fact u1d442depends on that fact if it can be inferred with and without the presence that fact in the database .
we say that u1d43cis a hard dependency of u1d442 if u1d442is only inferred when the sign of u1d43cis true.
we formulate the problem of computing the inference condition of u1d442in terms of symbolic signs as the problem of f inding all hard dependencies of u1d442among all inputs withsymbolicsigns sinceremoving anyhard dependency from the databasedisablesthe generationof the outputfact.
to identify all hard dependencies of a given output fact we rely on zeller s delta debugging algorithm that operates by iterativelysplittingthespaceofsolutionsandinvestigatingeach half individually.
to apply delta debugging we de f ine the function interesting u1d442thatforagiven setofinputfactsreturnstrueifthis set contains all hard dependencies of u1d442.
we also extend the encoding of symbolic signs in section .
so that sign selectors are appliednot toindividualfacts buttosetsof facts toidentifyif an outputfactcanbeinferredwithoutusinganyelementfromthatset.
suchanextendedencodingenablesustoimplementthefunction interesting u1d442 andthus apply the delta debugging algorithm.
symlogrepairand its instances in this section we describe how symlogrepair uses symlog and an smt solver to generate patches and describe symlogrepair instances symlogrepair symlogrepair andsymlogrepair .
.
architectureofsymlogrepair thearchitectureofsymlogrepairisshownin figure1.itaccepts two inputs the source code of the buggy program and an analysis de f inedindatalog.itthen executesthe following steps convertstheprogramintoadatalogedb injectssymbols intothisedb andproducesstructuralconstraints u1d713overthe symbolsthatcaptures asetofsyntactically validprograms executes the analysis symbolically obtaining inference conditions u1d719for the analysisoutputs manifesting violations.
constructsthe repaircondition u1d719 u1d713 1222esec fse december3 9 san francisco ca usa yuliu sergey mechtaev pavle suboti andabhik roychoudhury solves the repair condition to produce minimal repairs that is repairs that minimally modify original values in the edb mapstheobtainedvaluationofsymbolsbackintothesource code to generateapatch.
ourapproachgeneratesminimalrepairs becausesuchrepairs arelesslikelytobreakunspeci f iedfunctionalityoftheprogram .
the f irst step generating a repair search space is analysis and programming language speci f ic.
below we describe how it is realised for the three analysisproblems we considerinthis work.
.
symlogrepairforjava npe digger s npe analysis is built on top of a points to analysis which approximatestheheapmemorycon f igurationatprogrampoints.
amongotheruses thisinformationcanbeusedtodetectifapointer variable pointsto nullwhen itisdereferenced.
the search space for f ixing npes is de f ined through generic templatesthatcheckifdereferencedprogramvariablesequalnull andifso performvariousactions suchasnotexecutingafragment of code returning a default value such as the call to the default constructorofagiventype orperformanearlyexit.weselectfacts relatedtotheabovetemplatestosymboliseandaddsymbolicsigns to the factsthat represent the functionwiththe detectedbug.
.
symlogrepairforpython notebook dataleakanalysisassessesthedependencebetweentrainingand test data which can lead to arti f icially optimistic results.
preprocessingdataleakagehappenswhentrainingandtestdataaretransformed together by a function that may impute results based on bothdatasets likenormalizationusingbothdatasets distributions.
torepairthebug preprocessingshouldberemovedfromsource dataandappliedseparatelytotrainingandtestdata.forexample infigure the correct version uses fit transform for training data andtransform for testing data.
we de f ine the search space of repair by a generic template that moves preprocessing from source to training data and add corresponding preprocessing for test data.
symbolicconstantsandsymbolicsignsareaddedforpreprocessing apis andcontrol f lowgraph components respectively.
.
symlogrepairforsmartcontracts we address four smart contract vulnerabilities detected by securify2 access control reentrancy unhandled exceptions and lockedether.
there are four types of access control bugs.
transaction origin bugs emerge from using the outdated tx.origin for caller veri f ication.the f ixistoreplaceitwith msg.sender .wesymbolisetx.origin related facts.
suicidal bugs result from unchecked selfdestruct calls.
the f ix is to ensure the caller is the contract sowner.wesymbolisethefactsofownervariableandcontrol f low graph.
leaking and delegate call bugs are addressed similarly as the suicidalbug.
reentrancy bugs occur when external contract can make new callstothecallingcontractbeforethe f irstinvocationis f inished.
therepairis f inalisingallinternalstatechangesbeforethecallis executed.wesymbolisecontrol f lowfactsforsuchbugs.unhandled exceptionbugsarecausedbyuncheckedlow levelcallreturns.the f ix is to add a check for the returned value of the low level call.table npe10 dataset ofnpebugsfromjavaprojects.
program bugs kloc project description jfreechart a 2d chart libraryfor java spoon a libraryfor javacodetransformation jackson databind a data binding package for jackson jeveassets anassetmanager for eve online fastjson a jsonprocessing library karaf a modulithruntime acs aem commons componentsof aem consulting practice camel anintegration framework thirdeye a toolfor time seriesanalysis lockedetherbugsresultfromcontractswithpayablefunctionsbut no withdrawal functions.
one can f ix the bugs by removing the payable attribute adding a withdraw function or adding a function withselfdestruct .we symbolisefacts for selfdestruct .
evaluation in this section we evaluate symlogrepair by investigating the following researchquestions rqs .
rq i ability to repair adiverseclassofbugs.
cansymlogrepair f ixadiversebugsandhowitcomparestoexisting toolsthat target the same bugs?
rq ii impactofoptimisations.
how much doour optimisations improve the result compared to the na ve implementation ofsedl insymlog?
.
experimentalsetup our experiments were performed on an intel coretmintel r xeon r gold 6258r cpu at .70ghz with 256gb of physical ram running ubuntu20.
.1lts.we settimeoutto 1hour.
datasets.
weconstructedthreedatasets.the f irstis npe10 a dataset consisting of npe bugs in java projects f ive of them are from npex dataset two from bugswarm and three bugs that we systematically mined on github the criterion of including thebugsintonpe10isthattheyaredetectedbydigger the underlyingcomponentof symlogrepair .thesummary of this dataset is given in table .
the second is pl11 a dataset consistingof11preprocessing leakagebugs inpythonnotebooks collected by yang et al.
which excludes bugs not detectable by the used analyser and false positives.
finally sc63is a dataset composedof63bugsinsoliditysmartcontracts.itincludes22bugs fromsmartbugs and41bugsfromscrawlid .sc63excludes bugsfromsmartbugsandfromscrawlidthatsecurify2 cannot detect.asscrawliddoesnotprovidegroundtruth wemanually annotatedthe selectedbugswithcorrectrepairs.
tools.whenrepairingjavanpebugs weconsideredtwocon f igurationsof symlogrepair srnjnusingthena ve algorithmde f inedin section4.
and srnjousingtheoptimisations described in section .
andsection .
.
we considered three baselines for npe bugs npex that is speci f ically designedfornpebugs andageneralmachinelearningbasedtoolalpharepair and incoder a code model that demonstrated state of the art results for program repair .
when repairing python notebook data leaks we considered two con f igurations 1223program repairguidedby datalog definedstatic analysis esec fse december3 9 san francisco ca usa table patches generated by symlogrepair npex alpharepair and incoder for npe10 circleindicates correct patch leftcircle circle property over f itting patch circle no patch found oom out of memory symbols show the num.
of symbolic constants the num.
of symbolic signs.
the optimised symlogrepair f ixed more bugs than npex alpharepair and incoder andoutperformed thenon optimised versionby avoidingooms.
project version symbolspatch time memory gb npex alpharepair incoder srnjn srnjo srnjn srnjo srnjn srnjo jfreechart circle circle circle circle circle 3m 53s 2m 54s .
.
spoon b3f568d circle circle circle circle circle 3m 6s 2m 7s .
.
jackson databind 974ccdd circle leftcircle circle circle circle circle 2m 44s 2m 36s .
.
jeveassets f35ccd9 circle circle circle circle circle 2m 16s 2m 11s .
.
camel 597883f circle circle circle circle circle 11m29s 8m 30s .
.
thirdeye e286991 circle circle circle circle circle 1m 20s 1m 21s .
.
fastjson 7c05c6f circle circle circle circle leftcircle circle 2m 43s oom .
karaf leftcircle circle leftcircle circle circle leftcircle circle leftcircle circle 10m32s 4m 28s .
.
acs aem commons circle circle circle circle circle 5m 47s oom .
acs aem commons circle circle circle circle circle 5m 46s oom .
overall .
.
3m 50s 3m 50s .
.
symlogrepair srplnusingthena vealgorithm and srplousing the optimisations.
we also selected alpharepair andincoder as baselines for python bugs.
for repairing bugs in solidity smart contracts we considered two con f igurations of symlogrepair srssnusingthena vealgorithmand srssousing theoptimisations.asthe baseline we selectedthestate of the artsmartcontractrepairtoolelysium .
correctnesscriteria.
patchesthatsatisfytheanalysispropertywe classify as plausible contrary to test driven repair where plausible patches refer to patches that pass given tests .
a patch is correctif itissemanticallyequivalenttothedeveloperpatch.wemanually investigated generated patches to check their correctness.
in the manual analysis we conservatively assumed that the correct patch must be syntactically identical to the developer patch subject to trivialrefactorings.thosepatchesthatareplausible butnotcorrect inanalogywithtest over f itting we call property over f itting .
.
ability to repair adiverse class ofbugs to investigate the ability to handle a diverse class of bugs we evaluated symlogrepair on npe10 dataset of java npe bugs symlogrepair onpl11datasetofpythondata leaks and symlogrepair on sc63 dataset of soliditysmart contracts bugs.
table 2summarises the results of our experiments on npe10.
in this table the columns patch show the number of correct and property over f itting patchesfor each con f iguration.srnjo is thedefault optimised con f igurationof symlogrepair .
srnjo generated patches for all bugs and of them were repaired correctly and for the tool generated over f itting patches.
wecomparedsrnjowithnpex alpharepairandincoder.foralpharepairandincoderweusedthedataloganalyserforvalidating candidate patches.
the experiments demonstrated that srnjo correctlyrepairedone more bugsthan npex more bugscompared withalpharepair and8more thanincoder.
table3summarisestheresultsofourexperimentsonpl11.as in the previous experiment the columns patch show the number of correct and property over f itting patches generated by each con f iguration.
for pl11 developer patches are not available thereforeweclassifygeneratedpatchesintocorrectorplausibleviaamanual inspection and cross checking.
srplo is the default optimised con f igurationofthe symlogrepair .srplorepaired out of bugs correctly.
among the remaining bugs for bugs it generated patches that over f it the property and one was not repaired due to timeout.
alpharepair and incoder failed to generate any patchesthat satisfy the analysisproperty.
table 4summarises the results of our experiments on sc63.
the columns fixed show the numbers of f ixed bugs by the state ofthe art smart contract repair tool elysium and the default con f igurationof symlogrepair srsco.
time shows the average time taken by symlogrepair for generating patches.
the experiments demonstrated that our tool generated more correct patches than elysium.
the non optimised version srssn failedto generateany patchesbecause of oomerrors.
rq i symlogrepairdemonstrateditsabilitytostaticallyrepair a diverse class of realistic bugs acrossmultiple programming languages where it demonstrated results close to or betterthanthe state of the art.
.
impactofoptimisations symbolicexecutionofdatalogrequiresadditionalmemory because it has to explore a large space of possible relations which poses a scalability challenge.
to improve scalability we introduced optimisations.
to investigate the impact of these optimisations we comparedtheperformanceofthena ve cf.section .
andoptimised cf.section .
con f igurationsofsymlogrepairintermsof time andmemory usage.
table2andtable3providedetailedstatisticsofexecutingsrnjn srnjo srpln and srplo on the corresponding datasets.
the columns symbols showhowmanysymbols symbolicconstants symbolic signs were automatically injected into the edb to generatearepairsearchspace.thecolumns time showtotalelapsed time and memory showthepeakmemoryusageoroomifan out of memory error occurred.
the results in table 2show that of the time our optimisation exhibits speedups of up to .
ignoring un f inishedbenchmarks .
in terms of memory usage our 1224esec fse december3 9 san francisco ca usa yuliu sergey mechtaev pavle suboti andabhik roychoudhury table3 patchesgeneratedby symlogrepair forpl11.thenotationisidenticalto table2.theoptimisations enabled symlogrepair to repairmultiple bugsby avoidingooms.
notebook symbolspatch time memory mb alpharepair incoder srpln srplo srpln srplo srpln srplo nb 2528 circle circle circle circle 23m50s oom .
nb 2816 circle circle circle circle 30m46s oom .
nb 1417 circle circle circle circle 10m58s oom .
nb 949 circle circle circle circle 47m24s oom .
nb 2760 circle circle circle leftcircle circle 18m51s oom .
nb 3144 circle circle circle circle timeout oom .
nb 318 circle circle circle leftcircle circle 27m59s oom .
nb 296 circle circle circle leftcircle circle 25m35s oom .
nb 2646 circle circle circle leftcircle circle 35m20s oom .
nb 195 circle circle circle circle 12m44s oom .
nb 3594 circle circle circle circle 13m36s oom .
overall .
24m7s .
table patches generated by elysium and symlogrepair for sc63.
the notation isidentical to table .
bugtype bugsfixed correct over f itting time elysium srsso access control 3m 39s unhandled exception .32s reentrancy 1m 47s locked ether 1m 34s overall 4m optimisation exhibits a reduction of the time of up to a ignoring cases that ran out of memory .
in the case of results in table3 thena veversionrunsoutofmemoryonallbenchmarks.
on the other hand the optimised version was able to repair all but a single benchmark.
programs in table 2are signi f icantly larger buttheirrepairsearchspace asshowninthe symbols column is smaller due to localisation described in section .
which explains the difference in time and memory usage across these benchmarks.
in the experiments on sc63 the non optimised version of symlogrepair failed to generate any patches because of oom errors while the optimised version f ixed bugs correctly while using less than16gb of memory onaverage and less than4 minutes on average.
rq iiour optimisations play a crucial role in ensuring the scalability of symlogrepair as they on average reduce the repair time and memory usage while enabling the generation ofmore patchesbypreventingoomexceptions.
discussion theuseofprogrampropertiesde f inedindatalogenablesourapproach to avoid test over f itting intrinsic to test driven program repair butourapproachmayover f ittheproperty.first static analysis properties are designed to avoid undesirable behaviour but notto specifythe intendedbehaviour.second staticanalysis is subjecttofalsepositives.third someanalysismaynotbeableto recognise a patch as correct due to the use of over approximations.from sklearn.preprocessing import minmaxscaler dataset load data scaler minmaxscaler feature range scale data scaler.fit transform dataset train data test data split data scale data train data test data split data dataset x train y train split train data train data x test y test split test data test data model lstm model x train new scaler.fit transform x train x test new scaler.transform x test model.fit x train y train model.fit x train new y train predictions model.predict x test predictions model.predict x test new figure patch forpreprocessing leakage buginnb 2528. thus patches generated by our approach still need to be reviewed by developers and or prioritised by ai.
we will investigate the problem of prioritising statically generated patches in future work.
ourmethodofsymbolicallyexecutingstandarddatalog howevermanypracticalapplicationsofdatalogrelyonextensionssuch as strati f iednegation andextra logical operations.in futurework we plantoinvestigate howtosupportvariousdatalogextensions.
to support a newclass of bugs in symlogrepair itis necessary toprovideadatalogprogramfordetecting thisclassofbugs and de f inesymbolicsearchspacefor f ixingthebugs.inthiswork we usedexistingresearchanalysersforjava pythonandsolidity.commercial datalog based analyserslike semmle provideanalyses for more programming languages.
we manuallywrote three groundtruthpatches fromnpe10 as well as all the patches from pl11 and sc63.
due to the nuances of domain speci f icknowledge theprovidedsolutionsmaynotcapture allpossible intricacies orbe optimal.
in this work we only investigate the application of sedl to program repair.
however we believe sedl can be applied to many domains soasconventionalsymbolicexecution.infuturework we 1225program repairguidedby datalog definedstatic analysis esec fse december3 9 san francisco ca usa willinvestigateotherapplicationsofsedl dataintegration repairing networks anddatabasetesting.
related work our workcontributestoautomated program repair itis relevanttostaticprogramrepairandrepairbasedonsymbolicexecution.sedlisrelevanttodatalogextensionsanddatalogdebugging.
staticprogramrepair.
programrepairsystemsbasedonstatic analysis f ix speci f ic types of bugs such as memory leaks null pointer exceptions npes data races or locking errors.
memfix addressesthememoryleakproblembyreducingittoan exact cover problem and using a sat solver to f ind a solution.
saver uses object f low graphs to patch memory errors in c programs.
npex applies a custom symbolic execution technique to repair npes in java programs but relies on stack traces to detect bugs.
footpatch uses separation logic to f ix memory leaks and npes.
hippodrome repairs data races in java programswiththeaid ofracerd sstaticanalysis .crayons synthesisespatchesforlocking apimisusesusinggraphcoloring and ranking and estimates the criticality of code in static analyser error traces.
we did not compare symlogrepair with techniques other than npex because they handle different defect classes and use an ad hoc integration of static analysis and repair.
rather than developingnewdatalog basedanalyzersforthesedefects which isoutside thiswork sscope we showedourmethod sgenerality byintegratingexistingdatalog basedanalyzersforvariousbugs acrossmultiple languages.
several work employs static analysers to discover repair patterns.phoenix minesrepairpatternsfromexamplesofbug f ixes reported by static analysers and abstracts patterns by clustering similareditexamplesthroughtheuseofadomain speci f iclanguage.
avatar infers f ix patterns from the static analysis violations detectedbyfindbugs.ourapproachdoesnotlearnrepairpatterns butinsteadprovidesrepairstrategiesthroughtheuseofdatalog whichenables itto addressawider range ofbugs.
programrepairwithsymbolicexecution.
ourworkisrelevant tosemantic program repairsuch assemfix angelix and symbolic executionwithexistentialsecond order constraints seesoc .
these approaches also abstract a given program by injectingsymbols andexecutetheprogramsymbolicallytoinfer repairconstraints.thekeydifferenceofourworkisthatinstead of inferring constraints from test we infer them from a datalog analyser thus taking the analysedproperty intoaccount.
programrepairbenchmarks.
weconstructeddatasetsspeci f ically for the defectclasses handled by the datalog analysers instead of relyingondefects4j andquixbugs oftenusedforevaluating test driven repair.
the new datasets better re f lect the intended usagescenarioofourapproach i.e.repairingbugsdetectedbystatic analysis asoppositetorepairingbugsfoundbytesting.bugsfound bystaticanalysistouniversalprogramproperties e.g.thelackof crashes and security vulnerabilities rather than project speci f ic requirements andsuch bugsare not accompaniedwithtests.ml based program repair.
ml based program repair recently demonstrated promising results .
we used two state of theart tools alpharepair and incoder as baselines in our evaluation.infuturework wewillinvestigatehowtoaugmentmlbasedrepairwithsemanticinformationfromsymlogtoimprove theireffectiveness inrepairing staticanalysisbugs.
datalog input repair.
databaseinputrepair has been studiedin the context of integrity constraints violations that are limited to fragments of f irst order logic .
theoretical solutions for positive datalog using abductionare proposed .however traditional databasemethodsoftendon tscalewellforlargerstaticanalysis rulesets .
zhao et al.
s technique uses proof annotations indatalogforenhancedscalability butitmainlyrestrictstononsymbolic domains and doesn t execute repairs.
elastic incrementalisation extends this by incorporating provenance annotations forinputadjustmentsinincrementaldatalog .xinetal.
s method usescounter exampleabstractre f inementtochoose theoptimaledbsubsetmodelinganabstractioninprogramanalysis.synnet generatescandidateinputsforrulesinnetwork synthesis.
to our knowledge our work is the f irst repair technique thatscalestolargerulesetsandinputsindatalog basedprogram analyses.
symbolic datalog.
standard datalog is limited to the domain of powersets.
recently datalog engines have integrated symbolic reasoning.
formulog is a datalog engine that uses smt solving in the presence of symbolic variables in the ruleset.
modus isanon recursivedatalogenginethatallowsnon groundedvariablestosolvethecontainerpackagedependencyproblem.unlike these approaches symlog executes symbolic variables by encoding them in the standard datalog setup thus existing optimised datalogenginescanbeused.basedontheinferredconstraintssimlogrepair can provide a patch that transforms the edb to a correct version basedoninferredconstraints andansmtsolver.
thus our techniquecanseamlesslyplugintostandarddatalog basedstatic analysissetups.
conclusion we introduced a new static program repair architecture that by relyingondatalog isabletorepairawiderangeofdefectsforvarious programminglanguages.itscoreenabling componentissymbolic executionofdatalog whichcomputesdependenciesbetweenthe input and the output of a query and repairs the database based on the desiredoutputspeci f ication.
we implementedthistechniquein an efficient tool symlog and applied to program repair based on datalog de f ined program analysis in the tool symlogrepair.
our experiments demonstrated that symlogrepair scales to real world programs and repairs a wide range of defects including npe bugs injava programs anddata leaksinpythonnotebooks.